(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.standalone = f()}})(function(){var define,module,exports;return (function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
'use strict';

exports.grid = ['.hypergrid-container {', '	position: relative;', '	height: 510px;', '}', '.hypergrid-container > div:first-child {', '	position: absolute;', '	left: 0;', '	top: 0;', '	right: 0;', '	bottom: 0;', '}', '.hypergrid-container > div:first-child > div.info {', '	position: absolute;', '	display: none; /* initially hidden */', '	margin-top: 150px; /* to place below headers */', '	color: #eee;', '	text-shadow: 1px 1px #ccc;', '	font-size: 36pt;', '	font-weight: bold;', '	text-align: center;', '	top: 0; right: 0; bottom: 0; left: 0;', '}', '.hypergrid-textfield {', '	position: absolute;', '	font-size: 12px;', '	color: black;', '	/*background-color: ivory;*/', '	box-sizing: border-box;', '	margin: 0;', '	padding-right: 5px;', '	padding-left: 5px;', '	padding-bottom: 2px;', '	border: 1px #5292f7 solid;', '	/*border: 0; */', '	/*border: 1px solid #777;*/', '	outline: 0;', '	-webkit-box-shadow: 0 2px 5px rgba(0,0,0,0.4);', '	-moz-box-shadow: 0 2px 5px rgba(0,0,0,0.4);', '	box-shadow: 0 2px 5px rgba(0,0,0,0.4);', '}', '', '.fin-link-details-div > a:hover {', '	text-decoration: underline !important;', '}', '', '', ''].join('\n');

},{}],2:[function(require,module,exports){
"use strict";

module.exports = {
	"calendar": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAc0lEQVR4nIXQwQkCMRSE4U9ZLMCT9Xjaq2AfNhfYU5oQLMAOtoN48EWei5iBIRPe/yYQ3qrhf1lFG7iKcEaJxSfukUvMWgdHavt0uWHtg2QwxXnAnJZ2uOLyVZtybzzhgWNmfoFl0/YB87NbzR1cjP9xeQHSDC6mcL1xFQAAAABJRU5ErkJggg=="
	},
	"checked": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA0AAAAPCAYAAAA/I0V3AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAYJJREFUOE+NkstLglEQxf0fahG0iFrUxm2ElFDYLohCqCDaCAkWPaxIRbFFEJEaGEKLDCoMETRFUAMLyaIHBUG6sSKIMtKFqEhLT818ZUgmDhzu3DPn9z0uV1RrmUwmyGQyqNVqfFvViwBxu5RFPZuLSyGMKhz/qlEsRV19K8xm6y+w7bpBPFnAferjj3bdQX6DpHcAUwavAHUN2RGIZxBJZHH2mC/TUeydwwTZvBegLENNgw7sX6Wh1FswNmPEmjPCDyGRRwCtW9E3tMgdAtQw7GZjYcNX+gza2wJ3ZXsSZUuQ0vWCOV8SHfJJ/uluhbHUj1v8PKNMszIoQNRMHCShD6Wh8zyhrbOPwz8w+STKlCCJ7oRNUzQH63kBs5thBghePXxlj2aUoSxDPcuXPNiLAc5EEZ6HIkbmV2DYiXBPHs0o079+K0DTVj/s11mE00A0L+g4VcDp10qKZMAzytBhMaTRaPmYg885DlcSzSij0eoEiIouoUqlqqqaL2rlEok+Ad4vlfzPoVDsAAAAAElFTkSuQmCC"
	},
	"down-rectangle": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAkAAAAECAYAAABcDxXOAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAABpJREFUGFdjgIL/eDAKIKgABggqgAE0BQwMAPTlD/Fpi0JfAAAAAElFTkSuQmCC"
	},
	"filter-off": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAMCAYAAABSgIzaAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAAChSURBVChTzZHBCoUgFET9TqEiskgyWoutQvRLRIr+cR7XQAjiJW/1BgZmMUevXsY5xy9OoDEGMcYiUzeB67qibVuwQjVNA6311V+WBeM4vsLDMEApde/1fY9pmtI453neHEKAlBJd1z0fXtc16PbjODK07zvmeUZVVd8nooc75zJIOX3Gm6i0bVsGKf8xKIRIuyJTLgJJ3nvQzsjW2geIsQ/pr9hMVrSncAAAAABJRU5ErkJggg=="
	},
	"filter-on": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAMCAYAAABSgIzaAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAACoSURBVChTY3BqfP2fHAzWmDbj7f8p294RhVOBasEa02e+/e/VBmQQCTxaX/9PnvYGoj5ywpv/Qd2ENft3vv4f1gfVBAP+nW/+h/a+ATtn1q73KHjytvdgg3070DTBgHvL6/8g22fsQGiaDmSHA21xaybgIpDHixa8hWssnA8NDEIApCh3LkIjiD2INYJCL2X6W3B8gdhEaQQBUOCA4gyE8+e9xaKJgQEA/74BNE3cElkAAAAASUVORK5CYII="
	},
	"unchecked": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA0AAAAPCAYAAAA/I0V3AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAARBJREFUOE+9krtug1AQRPldSio7FQ1tZImOkoKOBomGT0EURC5ino54yTw90WywQhTkIkVWGoF2zuxdrlD+t0zThKZpT0Vmxb8CQRCg6zr0fb8rer7vfwcPxxdcrx+YpgnzPGNZlh9ibxxHlGUJshLSdV0at9tNpg7DIBrX5+OkPM9BVkKGYSBJEtR1jbZrBdiqbVtUVYU0TUFWQq+nE+I4xvvlImGaW7FHjwxZCVmWhbfzGVmWoSgKWXUr9uiRISshx3FkEldomubXauzRI0NWQp7nyUR+NG/rfr/jUXxnjx5vmKyEbNuWox9Xvid6ZMhK6HA4wnVdhGGIKIp2RY8MWQmx+JuoqvpUZFb8L6UonyYL3uOtrFH+AAAAAElFTkSuQmCC"
	},
	"up-down-spin": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAPCAYAAADUFP50AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAGJJREFUOE+lkwEKACEIBH2Zb/PnHsoGeaVJDUjGOgRRpKpkiIj+y4MME3eDR7kaKOVNsJyMNjIHzGy9YnW6J7qIcrriQimeCqORNABd0fpRTkt8uVUj7EsxC6vs/q3e/Q6iD2bwnByjPXHNAAAAAElFTkSuQmCC"
	},
	"up-down": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAPCAYAAADUFP50AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAGFJREFUOE+lkkEKQCEIRD2ZJ3Ph3iN4WD9GflpYhj0YYowpGgJmbikd3gjMDFokwbuT1iAiurG5nomgqo5QaPo9ERQRI6Jf7sfGjudy2je23+i0Wl2oQ85TOdlfrJQOazF8br+rqTXQKn0AAAAASUVORK5CYII="
	}
};

},{}],3:[function(require,module,exports){
/* eslint-env browser */

/**
 * This is a registry of `HTMLImageIcon` objects.
 *
 * Hypergrid comes with a few images (see below).
 *
 * Application developer is free to register additional image objects here (see {@link module:images.add|add}).
 * @module images
 */

'use strict';

var _ = require('object-iterators');

var images = require('./images'); // this is the file generated by gulpfile.js (and ignored by git)

/**
 * <img src="https://raw.githubusercontent.com/openfin/fin-hypergrid/master/images/calendar.png">
 * @name calendar
 * @memberOf module:images
 */

/**
 * <img src="https://raw.githubusercontent.com/openfin/fin-hypergrid/master/images/checked.png">
 * @name checked
 * @memberOf module:images
 */

/**
 * <img src="https://raw.githubusercontent.com/openfin/fin-hypergrid/master/images/unchecked.png">
 * @name unchecked
 * @memberOf module:images
 */

/**
 * <img src="https://raw.githubusercontent.com/openfin/fin-hypergrid/master/images/filter-off.png">
 * @name filter-off
 * @memberOf module:images
 */

/**
 * <img src="https://raw.githubusercontent.com/openfin/fin-hypergrid/master/images/filter-on.png">
 * @name filter-on
 * @memberOf module:images
 */

/**
 * <img src="https://raw.githubusercontent.com/openfin/fin-hypergrid/master/images/up-down.png">
 * @name up-down
 * @memberOf module:images
 */

_(images).each(function (image, key) {
  var element = new Image();
  element.src = 'data:' + image.type + ';base64,' + image.data;
  images[key] = element;
});

/**
 * Synonym of {@link module:images.checked|checked} (unaffected if `checked` overridden).
 * @name checkbox-on
 * @memberOf module:images
 */
images['checkbox-on'] = images.checked;

/**
 * Synonym of {@link module:images.unchecked|unchecked} (unaffected if `unchecked` overridden).
 * @name checkbox-off
 * @memberOf module:images
 */
images['checkbox-off'] = images.unchecked;

/**
 * @name add
 * @method
 * @param {string} key
 * @param {HTMLImageElement} img
 * @memberOf module:images
 */
images.add = function (key, img) {
  return images[key] = img;
};

/**
 * Convenience function.
 * @name checkbox
 * @method
 * @param {boolean} state
 * @returns {HTMLImageElement} {@link module:images.checked|checked} when `state` is truthy or {@link module:images.unchecked|unchecked} otherwise.
 * @memberOf module:images
 */
images.checkbox = function (state) {
  return images[state ? 'checked' : 'unchecked'];
};

/**
 * Convenience function.
 * @name filter
 * @method
 * @param {boolean} state
 * @returns {HTMLImageElement} {@link module:images.filter-off|filter-off} when `state` is truthy or {@link module:images.filter-on|filter-on} otherwise.
 * @memberOf module:images
 */
images.filter = function (state) {
  return images[state ? 'filter-on' : 'filter-off'];
};

module.exports = images;

},{"./images":2,"object-iterators":12}],4:[function(require,module,exports){
/* eslint-env browser */

'use strict';

/** @module automat */

var ENCODERS = /%\{(\d+)\}/g; // double $$ to encode

var REPLACERS = /\$\{(.*?)\}/g; // single $ to replace


/**
 * @summary String formatter.
 *
 * @desc String substitution is performed on numbered _replacer_ patterns like `${n}` or _encoder_ patterns like `%{n}` where n is the zero-based `arguments` index. So `${0}` would be replaced with the first argument following `text`.
 *
 * Encoders are just like replacers except the argument is HTML-encoded before being used.
 *
 * To change the format patterns, assign new `RegExp` patterns to `automat.encoders` and `automat.replacers`.
 *
 * @param {string|function} template - A template to be formatted as described above. Overloads:
 * * A string primitive containing the template.
 * * A function to be called with `this` as the calling context. The template is the value returned from this call.
 *
 * @param {...*} [replacements] - Replacement values for numbered format patterns.
 *
 * @return {string} The formatted text.
 *
 * @memberOf module:automat
 */
function automat(template, replacements/*...*/) {
    var hasReplacements = arguments.length > 1;

    // if `template` is a function, convert it to text
    if (typeof template === 'function') {
        template = template.call(this); // non-template function: call it with context and use return value
    }

    if (hasReplacements) {
        var args = arguments;
        template = template.replace(automat.replacersRegex, function(match, key) {
            key -= -1; // convert to number and increment
            return args.length > key ? args[key] : '';
        });

        template = template.replace(automat.encodersRegex, function(match, key) {
            key -= -1; // convert to number and increment
            if (args.length > key) {
                var htmlEncoderNode = document.createElement('DIV');
                htmlEncoderNode.textContent = args[key];
                return htmlEncoderNode.innerHTML;
            } else {
                return '';
            }
        });
    }

    return template;
}

/**
 * @summary Replace contents of `el` with `Nodes` generated from formatted template.
 *
 * @param {string|function} template - See `template` parameter of {@link automat}.
 *
 * @param {HTMLElement} [el] - Node in which to return markup generated from template. If omitted, a new `<div>...</div>` element will be created and returned.
 *
 * @param {...*} [replacements] - Replacement values for numbered format patterns.
 *
 * @return {HTMLElement} The `el` provided or a new `<div>...</div>` element, its `innerHTML` set to the formatted text.
 *
 * @memberOf module:automat
 */
function replace(template, el, replacements/*...*/) {
    var elOmitted = typeof el !== 'object',
        args = Array.prototype.slice.call(arguments, 1);

    if (elOmitted) {
        el = document.createElement('DIV');
        args.unshift(template);
    } else {
        args[0] = template;
    }

    el.innerHTML = automat.apply(null, args);

    return el;
}

/**
 * @summary Append or insert `Node`s generated from formatted template into given `el`.
 *
 * @param {string|function} template - See `template` parameter of {@link automat}.
 *
 * @param {HTMLElement} el
 *
 * @param {Node} [referenceNode=null] Inserts before this element within `el` or at end of `el` if `null`.
 *
 * @param {...*} [replacements] - Replacement values for numbered format patterns.
 *
 * @returns {Node[]} Array of the generated nodes (this is an actual Array instance; not an Array-like object).
 *
 * @memberOf module:automat
 */
function append(template, el, referenceNode, replacements/*...*/) {
    var replacementsStartAt = 3,
        referenceNodeOmitted = typeof referenceNode !== 'object';  // replacements are never objects

    if (referenceNodeOmitted) {
        referenceNode = null;
        replacementsStartAt = 2;
    }

    replacements = Array.prototype.slice.call(arguments, replacementsStartAt);
    var result = [],
        div = replace.apply(null, [template].concat(replacements));

    while (div.childNodes.length) {
        result.push(div.firstChild);
        el.insertBefore(div.firstChild, referenceNode); // removes child from div
    }

    return result;
}

/**
 * Use this convenience wrapper to return the first child node described in `template`.
 *
 * @param {string|function} template - If a function, extract template from comment within.
 *
 * @returns {HTMLElement} The first `Node` in your template.
 *
 * @memberOf module:automat
 */
function firstChild(template, replacements/*...*/) {
    return replace.apply(null, arguments).firstChild;
}

/**
 * Use this convenience wrapper to return the first child element described in `template`.
 *
 * @param {string|function} template - If a function, extract template from comment within.
 *
 * @returns {HTMLElement} The first `HTMLElement` in your template.
 *
 * @memberOf module:automat
 */
function firstElement(template, replacements/*...*/) {
    return replace.apply(null, arguments).firstElementChild;
}

/**
 * @summary Finds string substitution lexemes that require HTML encoding.
 * @desc Modify to suit.
 * @default %{n}
 * @type {RegExp}
 * @memberOf module:automat
 */
automat.encodersRegex = ENCODERS;

/**
 * @summary Finds string substitution lexemes.
 * @desc Modify to suit.
 * @default ${n}
 * @type {RegExp}
 * @memberOf module:automat
 */
automat.replacersRegex = REPLACERS;

automat.format = automat; // if you find using just `automat()` confusing
automat.replace = replace;
automat.append = append;
automat.firstChild = firstChild;
automat.firstElement = firstElement;

module.exports = automat;

},{}],5:[function(require,module,exports){
'use strict';

/* eslint-env browser */

/** @namespace cssInjector */

/**
 * @summary Insert base stylesheet into DOM
 *
 * @desc Creates a new `<style>...</style>` element from the named text string(s) and inserts it but only if it does not already exist in the specified container as per `referenceElement`.
 *
 * > Caveat: If stylesheet is for use in a shadow DOM, you must specify a local `referenceElement`.
 *
 * @returns A reference to the newly created `<style>...</style>` element.
 *
 * @param {string|string[]} cssRules
 * @param {string} [ID]
 * @param {undefined|null|Element|string} [referenceElement] - Container for insertion. Overloads:
 * * `undefined` type (or omitted): injects stylesheet at top of `<head>...</head>` element
 * * `null` value: injects stylesheet at bottom of `<head>...</head>` element
 * * `Element` type: injects stylesheet immediately before given element, wherever it is found.
 * * `string` type: injects stylesheet immediately before given first element found that matches the given css selector.
 *
 * @memberOf cssInjector
 */
function cssInjector(cssRules, ID, referenceElement) {
    if (typeof referenceElement === 'string') {
        referenceElement = document.querySelector(referenceElement);
        if (!referenceElement) {
            throw 'Cannot find reference element for CSS injection.';
        }
    } else if (referenceElement && !(referenceElement instanceof Element)) {
        throw 'Given value not a reference element.';
    }

    var container = referenceElement && referenceElement.parentNode || document.head || document.getElementsByTagName('head')[0];

    if (ID) {
        ID = cssInjector.idPrefix + ID;

        if (container.querySelector('#' + ID)) {
            return; // stylesheet already in DOM
        }
    }

    var style = document.createElement('style');
    style.type = 'text/css';
    if (ID) {
        style.id = ID;
    }
    if (cssRules instanceof Array) {
        cssRules = cssRules.join('\n');
    }
    cssRules = '\n' + cssRules + '\n';
    if (style.styleSheet) {
        style.styleSheet.cssText = cssRules;
    } else {
        style.appendChild(document.createTextNode(cssRules));
    }

    if (referenceElement === undefined) {
        referenceElement = container.firstChild;
    }

    container.insertBefore(style, referenceElement);

    return style;
}

/**
 * @summary Optional prefix for `<style>` tag IDs.
 * @desc Defaults to `'injected-stylesheet-'`.
 * @type {string}
 * @memberOf cssInjector
 */
cssInjector.idPrefix = 'injected-stylesheet-';

// Interface
module.exports = cssInjector;

},{}],6:[function(require,module,exports){
var pSlice = Array.prototype.slice;
var objectKeys = require('./lib/keys.js');
var isArguments = require('./lib/is_arguments.js');

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}

},{"./lib/is_arguments.js":7,"./lib/keys.js":8}],7:[function(require,module,exports){
var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};

},{}],8:[function(require,module,exports){
exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}

},{}],9:[function(require,module,exports){
'use strict';

/** @namespace extend-me **/

/** @summary Extends an existing constructor into a new constructor.
 *
 * @returns {Constructor} A new constructor, extended from the given context, possibly with some prototype additions.
 *
 * @desc Extends "objects" (constructors), with optional additional code, optional prototype additions, and optional prototype member aliases.
 *
 * > CAVEAT: Not to be confused with Underscore-style .extend() which is something else entirely. I've used the name "extend" here because other packages (like Backbone.js) use it this way. You are free to call it whatever you want when you "require" it, such as `var inherits = require('extend')`.
 *
 * Provide a constructor as the context and any prototype additions you require in the first argument.
 *
 * For example, if you wish to be able to extend `BaseConstructor` to a new constructor with prototype overrides and/or additions, basic usage is:
 *
 * ```javascript
 * var Base = require('extend-me').Base;
 * var BaseConstructor = Base.extend(basePrototype); // mixes in .extend
 * var ChildConstructor = BaseConstructor.extend(childPrototypeOverridesAndAdditions);
 * var GrandchildConstructor = ChildConstructor.extend(grandchildPrototypeOverridesAndAdditions);
 * ```
 *
 * This function (`extend()`) is added to the new extended object constructor as a property `.extend`, essentially making the object constructor itself easily "extendable." (Note: This is a property of each constructor and not a method of its prototype!)
 *
 * @this Base class being extended from (i.e., its constructor function object).
 *
 * @param {string} [extendedClassName] - This is simply added to the prototype as $$CLASS_NAME. Useful for debugging because all derived constructors appear to have the same name ("Constructor") in the debugger.
 *
 * @param {extendedPrototypeAdditionsObject} [prototypeAdditions] - Object with members to copy to new constructor's prototype.
 *
 * @property {boolean} [debug] - See parameter `extendedClassName` _(above)_.
 *
 * @property {object} Base - A convenient base class from which all other classes can be extended.
 *
 * @memberOf extend-me
 */
function extend(extendedClassName, prototypeAdditions) {
    switch (arguments.length) {
        case 0:
            prototypeAdditions = {};
            break;
        case 1:
            switch (typeof extendedClassName) {
                case 'object':
                    prototypeAdditions = extendedClassName;
                    extendedClassName = undefined;
                    break;
                case 'string':
                    prototypeAdditions = {};
                    break;
                default:
                    throw 'Single-parameter overload must be either string or object.';
            }
            break;
        case 2:
            if (typeof extendedClassName !== 'string' || typeof prototypeAdditions !== 'object') {
                throw 'Two-parameter overload must be string, object.';
            }
            break;
        default:
            throw 'Too many parameters';
    }

    /**
     * @class
     */
    function Constructor() {
        if (this.preInitialize) {
            this.preInitialize.apply(this, arguments);
        }

        initializePrototypeChain.apply(this, arguments);

        if (this.postInitialize) {
            this.postInitialize.apply(this, arguments);
        }
    }

    /**
     * @method
     * @see {@link extend-me.extend}
     * @desc Added to each returned extended class constructor.
     */
    Constructor.extend = extend;

    Constructor.getClassName = getClassName;

    /**
     * @method
     * @param {string} [ancestorConstructorName] - If given, searches up the prototype chain for constructor with matching name.
     * @returns {function|null} Constructor of parent class; or ancestor class with matching name; or null
     */
    Constructor.parent = parentConstructor;

    var prototype = Constructor.prototype = Object.create(this.prototype);
    prototype.constructor = Constructor;

    extendedClassName = extendedClassName || prototype.$$CLASS_NAME || prototype.name;
    if (extendedClassName) {
        Object.defineProperty(Constructor, 'name', { value: extendedClassName, configurable: true });
        prototype.$$CLASS_NAME = extendedClassName;
    }

    // define each prototype addition on the prototype (including getter/setters)
    var key, descriptor;
    for (key in prototypeAdditions) {
        if ((descriptor = Object.getOwnPropertyDescriptor(prototypeAdditions, key))) {
            Object.defineProperty(prototype, key, descriptor);
        }
    }

    if (typeof this.postExtend === 'function') {
        this.postExtend(prototype);
    }

    return Constructor;
}

function Base() {}
Base.prototype = {

    constructor: Base.prototype.constructor,

    getClassName: function() {
        return (
            this.$$CLASS_NAME ||
            this.name ||
            this.constructor.name // try Function.prototype.name as last resort
        );
    },

    /**
     * Access a member of the super class.
     * @returns {Object}
     */
    get super() {
        return Object.getPrototypeOf(Object.getPrototypeOf(this));
    },

    /**
     * Find member on prototype chain beginning with super class.
     * @param {string} memberName
     * @returns {undefined|*} `undefined` if not found; value otherwise.
     */
    superMember: function(memberName) {
        var parent = this.super;
        do { parent = Object.getPrototypeOf(parent); } while (!parent.hasOwnProperty(memberName));
        return parent && parent[memberName];
    },

    /**
     * Find method on prototype chain beginning with super class.
     * @param {string} methodName
     * @returns {function}
     */
    superMethod: function(methodName) {
        var method = this.superMember(methodName);
        if (typeof method !== 'function') {
            throw new TypeError('this.' + methodName + ' is not a function');
        }
        return method;
    },

    /**
     * Find method on prototype chain beginning with super class and call it with remaining args.
     * @param {string} methodName
     * @returns {*}
     */
    callSuperMethod: function(methodName) {
        return this.superMethod(methodName).apply(this, Array.prototype.slice.call(arguments, 1));
    }
};
Base.extend = extend;
extend.Base = Base;

/**
 * Optional static method is called with new "class" (constructor) after extending.
 * This permits miscellaneous tweaking and cleanup of the new class.
 * @method postExtend
 * @param {object} prototype
 * @memberOf Base
 */

/** @typedef {function} extendedConstructor
 * @property prototype.super - A reference to the prototype this constructor was extended from.
 * @property [extend] - If `prototypeAdditions.extendable` was truthy, this will be a reference to {@link extend.extend|extend}.
 */

/** @typedef {object} extendedPrototypeAdditionsObject
 * @desc All members are copied to the new object. The following have special meaning.
 * @property {function} [initialize] - Additional constructor code for new object. This method is added to the new constructor's prototype. Gets passed new object as context + same args as constructor itself. Called on instantiation after similar function in all ancestors called with same signature.
 * @property {function} [preInitialize] - Called before the `initialize` cascade. Gets passed new object as context + same args as constructor itself. If not defined here, the top-most (and only the top-most) definition found on the prototype chain is called.
 * @property {function} [postInitialize] - Called after the `initialize` cascade. Gets passed new object as context + same args as constructor itself. If not defined here, the top-most (and only the top-most) definition found on the prototype chain is called.
 */

/** @summary Call all `initialize` methods found in prototype chain, beginning with the most senior ancestor's first.
 * @desc This recursive routine is called by the constructor.
 * 1. Walks back the prototype chain to `Object`'s prototype
 * 2. Walks forward to new object, calling any `initialize` methods it finds along the way with the same context and arguments with which the constructor was called.
 * @private
 * @memberOf extend-me
 */
function initializePrototypeChain() {
    var term = this,
        args = arguments;
    recur(term);

    function recur(obj) {
        var proto = Object.getPrototypeOf(obj);
        if (proto.constructor !== Object) {
            recur(proto);
            if (proto.hasOwnProperty('initialize')) {
                proto.initialize.apply(term, args);
            }
        }
    }
}

function getClassName() {
    return (
        this.prototype.$$CLASS_NAME ||
        this.prototype.name ||
        this.name // try Function.prototype.name as last resort
    );
}

function parentConstructor(ancestorConstructorName) {
    var prototype = this.prototype;
    if (prototype) {
        do {
            prototype = Object.getPrototypeOf(prototype);
        } while (ancestorConstructorName && prototype && prototype.constructor.name !== ancestorConstructorName);
    }
    return prototype && prototype.constructor;
}

module.exports = extend;

},{}],10:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var automat = require('automat');

/**
 * @summary Injects the named stylesheet into `<head>`.
 * @desc Stylesheets are inserted consecutively at end of `<head>` unless `before === true` (or omitted and `injectStylesheetTemplate.before` truthy) in which case they are inserted consecutively before first stylesheet found in `<head>` (if any) at load time.
 *
 * The calling context (`this`) is a stylesheet registry.
 * If `this` is undefined, the global stylesheet registry (css/index.js) is used.
 * @this {object}
 * @param {boolean} [before=injectStylesheetTemplate.before] - Add stylesheet before intially loaded stylesheets.
 *
 * _If omitted:_
 * 1. `id` is promoted to first argument position
 * 2. `injectStylesheetTemplate.before` is `true` by default
 * @param {string} id - The name of the style sheet in `this`, a stylesheet "registry" (hash of stylesheets).
 * @returns {Element|*}
 */
function injectStylesheetTemplate(before, id) {
    var optionalArgsStartAt, stylesheet, head, refNode, css, args,
        prefix = injectStylesheetTemplate.prefix;

    if (typeof before === 'boolean') {
        optionalArgsStartAt = 2;
    } else {
        id = before;
        before = injectStylesheetTemplate.before;
        optionalArgsStartAt = 1;
    }

    stylesheet = document.getElementById(prefix + id);

    if (!stylesheet) {
        head = document.querySelector('head');

        if (before) {
            // note position of first stylesheet
            refNode = Array.prototype.slice.call(head.children).find(function(child) {
                var id = child.getAttribute('id');
                return child.tagName === 'STYLE' && (!id || id.indexOf(prefix) !== prefix) ||
                    child.tagName === 'LINK' && child.getAttribute('rel') === 'stylesheet';
            });
        }

        css = this[id];

        if (!css) {
            throw 'Expected to find member `' + id + '` in calling context.';
        }

        args = [
            '<style>\n' + css + '\n</style>\n',
            head,
            refNode || null // explicitly null per https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore
        ];

        if (arguments.length > 1) {
            args = args.concat(Array.prototype.slice.call(arguments, optionalArgsStartAt));
        }

        stylesheet = automat.append.apply(null, args)[0];
        stylesheet.id = prefix + id;
    }

    return stylesheet;
}

injectStylesheetTemplate.before = true;
injectStylesheetTemplate.prefix = 'injected-stylesheet-';

module.exports = injectStylesheetTemplate;

},{"automat":4}],11:[function(require,module,exports){
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */

/*global define: false Mustache: true*/

(function defineMustache (global, factory) {
  if (typeof exports === 'object' && exports && typeof exports.nodeName !== 'string') {
    factory(exports); // CommonJS
  } else if (typeof define === 'function' && define.amd) {
    define(['exports'], factory); // AMD
  } else {
    global.Mustache = {};
    factory(global.Mustache); // script, wsh, asp
  }
}(this, function mustacheFactory (mustache) {

  var objectToString = Object.prototype.toString;
  var isArray = Array.isArray || function isArrayPolyfill (object) {
    return objectToString.call(object) === '[object Array]';
  };

  function isFunction (object) {
    return typeof object === 'function';
  }

  /**
   * More correct typeof string handling array
   * which normally returns typeof 'object'
   */
  function typeStr (obj) {
    return isArray(obj) ? 'array' : typeof obj;
  }

  function escapeRegExp (string) {
    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
  }

  /**
   * Null safe way of checking whether or not an object,
   * including its prototype, has a given property
   */
  function hasProperty (obj, propName) {
    return obj != null && typeof obj === 'object' && (propName in obj);
  }

  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
  // See https://github.com/janl/mustache.js/issues/189
  var regExpTest = RegExp.prototype.test;
  function testRegExp (re, string) {
    return regExpTest.call(re, string);
  }

  var nonSpaceRe = /\S/;
  function isWhitespace (string) {
    return !testRegExp(nonSpaceRe, string);
  }

  var entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;',
    '`': '&#x60;',
    '=': '&#x3D;'
  };

  function escapeHtml (string) {
    return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap (s) {
      return entityMap[s];
    });
  }

  var whiteRe = /\s*/;
  var spaceRe = /\s+/;
  var equalsRe = /\s*=/;
  var curlyRe = /\s*\}/;
  var tagRe = /#|\^|\/|>|\{|&|=|!/;

  /**
   * Breaks up the given `template` string into a tree of tokens. If the `tags`
   * argument is given here it must be an array with two string values: the
   * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
   * course, the default is to use mustaches (i.e. mustache.tags).
   *
   * A token is an array with at least 4 elements. The first element is the
   * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
   * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
   * all text that appears outside a symbol this element is "text".
   *
   * The second element of a token is its "value". For mustache tags this is
   * whatever else was inside the tag besides the opening symbol. For text tokens
   * this is the text itself.
   *
   * The third and fourth elements of the token are the start and end indices,
   * respectively, of the token in the original template.
   *
   * Tokens that are the root node of a subtree contain two more elements: 1) an
   * array of tokens in the subtree and 2) the index in the original template at
   * which the closing tag for that section begins.
   */
  function parseTemplate (template, tags) {
    if (!template)
      return [];

    var sections = [];     // Stack to hold section tokens
    var tokens = [];       // Buffer to hold the tokens
    var spaces = [];       // Indices of whitespace tokens on the current line
    var hasTag = false;    // Is there a {{tag}} on the current line?
    var nonSpace = false;  // Is there a non-space char on the current line?

    // Strips all whitespace tokens array for the current line
    // if there was a {{#tag}} on it and otherwise only space.
    function stripSpace () {
      if (hasTag && !nonSpace) {
        while (spaces.length)
          delete tokens[spaces.pop()];
      } else {
        spaces = [];
      }

      hasTag = false;
      nonSpace = false;
    }

    var openingTagRe, closingTagRe, closingCurlyRe;
    function compileTags (tagsToCompile) {
      if (typeof tagsToCompile === 'string')
        tagsToCompile = tagsToCompile.split(spaceRe, 2);

      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
        throw new Error('Invalid tags: ' + tagsToCompile);

      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
      closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
      closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
    }

    compileTags(tags || mustache.tags);

    var scanner = new Scanner(template);

    var start, type, value, chr, token, openSection;
    while (!scanner.eos()) {
      start = scanner.pos;

      // Match any text between tags.
      value = scanner.scanUntil(openingTagRe);

      if (value) {
        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
          chr = value.charAt(i);

          if (isWhitespace(chr)) {
            spaces.push(tokens.length);
          } else {
            nonSpace = true;
          }

          tokens.push([ 'text', chr, start, start + 1 ]);
          start += 1;

          // Check for whitespace on the current line.
          if (chr === '\n')
            stripSpace();
        }
      }

      // Match the opening tag.
      if (!scanner.scan(openingTagRe))
        break;

      hasTag = true;

      // Get the tag type.
      type = scanner.scan(tagRe) || 'name';
      scanner.scan(whiteRe);

      // Get the tag value.
      if (type === '=') {
        value = scanner.scanUntil(equalsRe);
        scanner.scan(equalsRe);
        scanner.scanUntil(closingTagRe);
      } else if (type === '{') {
        value = scanner.scanUntil(closingCurlyRe);
        scanner.scan(curlyRe);
        scanner.scanUntil(closingTagRe);
        type = '&';
      } else {
        value = scanner.scanUntil(closingTagRe);
      }

      // Match the closing tag.
      if (!scanner.scan(closingTagRe))
        throw new Error('Unclosed tag at ' + scanner.pos);

      token = [ type, value, start, scanner.pos ];
      tokens.push(token);

      if (type === '#' || type === '^') {
        sections.push(token);
      } else if (type === '/') {
        // Check section nesting.
        openSection = sections.pop();

        if (!openSection)
          throw new Error('Unopened section "' + value + '" at ' + start);

        if (openSection[1] !== value)
          throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
      } else if (type === 'name' || type === '{' || type === '&') {
        nonSpace = true;
      } else if (type === '=') {
        // Set the tags for the next time around.
        compileTags(value);
      }
    }

    // Make sure there are no open sections when we're done.
    openSection = sections.pop();

    if (openSection)
      throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);

    return nestTokens(squashTokens(tokens));
  }

  /**
   * Combines the values of consecutive text tokens in the given `tokens` array
   * to a single token.
   */
  function squashTokens (tokens) {
    var squashedTokens = [];

    var token, lastToken;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      if (token) {
        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
          lastToken[1] += token[1];
          lastToken[3] = token[3];
        } else {
          squashedTokens.push(token);
          lastToken = token;
        }
      }
    }

    return squashedTokens;
  }

  /**
   * Forms the given array of `tokens` into a nested tree structure where
   * tokens that represent a section have two additional items: 1) an array of
   * all tokens that appear in that section and 2) the index in the original
   * template that represents the end of that section.
   */
  function nestTokens (tokens) {
    var nestedTokens = [];
    var collector = nestedTokens;
    var sections = [];

    var token, section;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      switch (token[0]) {
        case '#':
        case '^':
          collector.push(token);
          sections.push(token);
          collector = token[4] = [];
          break;
        case '/':
          section = sections.pop();
          section[5] = token[2];
          collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
          break;
        default:
          collector.push(token);
      }
    }

    return nestedTokens;
  }

  /**
   * A simple string scanner that is used by the template parser to find
   * tokens in template strings.
   */
  function Scanner (string) {
    this.string = string;
    this.tail = string;
    this.pos = 0;
  }

  /**
   * Returns `true` if the tail is empty (end of string).
   */
  Scanner.prototype.eos = function eos () {
    return this.tail === '';
  };

  /**
   * Tries to match the given regular expression at the current position.
   * Returns the matched text if it can match, the empty string otherwise.
   */
  Scanner.prototype.scan = function scan (re) {
    var match = this.tail.match(re);

    if (!match || match.index !== 0)
      return '';

    var string = match[0];

    this.tail = this.tail.substring(string.length);
    this.pos += string.length;

    return string;
  };

  /**
   * Skips all text until the given regular expression can be matched. Returns
   * the skipped string, which is the entire tail if no match can be made.
   */
  Scanner.prototype.scanUntil = function scanUntil (re) {
    var index = this.tail.search(re), match;

    switch (index) {
      case -1:
        match = this.tail;
        this.tail = '';
        break;
      case 0:
        match = '';
        break;
      default:
        match = this.tail.substring(0, index);
        this.tail = this.tail.substring(index);
    }

    this.pos += match.length;

    return match;
  };

  /**
   * Represents a rendering context by wrapping a view object and
   * maintaining a reference to the parent context.
   */
  function Context (view, parentContext) {
    this.view = view;
    this.cache = { '.': this.view };
    this.parent = parentContext;
  }

  /**
   * Creates a new context using the given view with this context
   * as the parent.
   */
  Context.prototype.push = function push (view) {
    return new Context(view, this);
  };

  /**
   * Returns the value of the given name in this context, traversing
   * up the context hierarchy if the value is absent in this context's view.
   */
  Context.prototype.lookup = function lookup (name) {
    var cache = this.cache;

    var value;
    if (cache.hasOwnProperty(name)) {
      value = cache[name];
    } else {
      var context = this, names, index, lookupHit = false;

      while (context) {
        if (name.indexOf('.') > 0) {
          value = context.view;
          names = name.split('.');
          index = 0;

          /**
           * Using the dot notion path in `name`, we descend through the
           * nested objects.
           *
           * To be certain that the lookup has been successful, we have to
           * check if the last object in the path actually has the property
           * we are looking for. We store the result in `lookupHit`.
           *
           * This is specially necessary for when the value has been set to
           * `undefined` and we want to avoid looking up parent contexts.
           **/
          while (value != null && index < names.length) {
            if (index === names.length - 1)
              lookupHit = hasProperty(value, names[index]);

            value = value[names[index++]];
          }
        } else {
          value = context.view[name];
          lookupHit = hasProperty(context.view, name);
        }

        if (lookupHit)
          break;

        context = context.parent;
      }

      cache[name] = value;
    }

    if (isFunction(value))
      value = value.call(this.view);

    return value;
  };

  /**
   * A Writer knows how to take a stream of tokens and render them to a
   * string, given a context. It also maintains a cache of templates to
   * avoid the need to parse the same template twice.
   */
  function Writer () {
    this.cache = {};
  }

  /**
   * Clears all cached templates in this writer.
   */
  Writer.prototype.clearCache = function clearCache () {
    this.cache = {};
  };

  /**
   * Parses and caches the given `template` and returns the array of tokens
   * that is generated from the parse.
   */
  Writer.prototype.parse = function parse (template, tags) {
    var cache = this.cache;
    var tokens = cache[template];

    if (tokens == null)
      tokens = cache[template] = parseTemplate(template, tags);

    return tokens;
  };

  /**
   * High-level method that is used to render the given `template` with
   * the given `view`.
   *
   * The optional `partials` argument may be an object that contains the
   * names and templates of partials that are used in the template. It may
   * also be a function that is used to load partial templates on the fly
   * that takes a single argument: the name of the partial.
   */
  Writer.prototype.render = function render (template, view, partials) {
    var tokens = this.parse(template);
    var context = (view instanceof Context) ? view : new Context(view);
    return this.renderTokens(tokens, context, partials, template);
  };

  /**
   * Low-level method that renders the given array of `tokens` using
   * the given `context` and `partials`.
   *
   * Note: The `originalTemplate` is only ever used to extract the portion
   * of the original template that was contained in a higher-order section.
   * If the template doesn't use higher-order sections, this argument may
   * be omitted.
   */
  Writer.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate) {
    var buffer = '';

    var token, symbol, value;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      value = undefined;
      token = tokens[i];
      symbol = token[0];

      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);
      else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);
      else if (symbol === '>') value = this.renderPartial(token, context, partials, originalTemplate);
      else if (symbol === '&') value = this.unescapedValue(token, context);
      else if (symbol === 'name') value = this.escapedValue(token, context);
      else if (symbol === 'text') value = this.rawValue(token);

      if (value !== undefined)
        buffer += value;
    }

    return buffer;
  };

  Writer.prototype.renderSection = function renderSection (token, context, partials, originalTemplate) {
    var self = this;
    var buffer = '';
    var value = context.lookup(token[1]);

    // This function is used to render an arbitrary template
    // in the current context by higher-order sections.
    function subRender (template) {
      return self.render(template, context, partials);
    }

    if (!value) return;

    if (isArray(value)) {
      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);
      }
    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {
      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);
    } else if (isFunction(value)) {
      if (typeof originalTemplate !== 'string')
        throw new Error('Cannot use higher-order sections without the original template');

      // Extract the portion of the original template that the section contains.
      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);

      if (value != null)
        buffer += value;
    } else {
      buffer += this.renderTokens(token[4], context, partials, originalTemplate);
    }
    return buffer;
  };

  Writer.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate) {
    var value = context.lookup(token[1]);

    // Use JavaScript's definition of falsy. Include empty arrays.
    // See https://github.com/janl/mustache.js/issues/186
    if (!value || (isArray(value) && value.length === 0))
      return this.renderTokens(token[4], context, partials, originalTemplate);
  };

  Writer.prototype.renderPartial = function renderPartial (token, context, partials) {
    if (!partials) return;

    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
    if (value != null)
      return this.renderTokens(this.parse(value), context, partials, value);
  };

  Writer.prototype.unescapedValue = function unescapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return value;
  };

  Writer.prototype.escapedValue = function escapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return mustache.escape(value);
  };

  Writer.prototype.rawValue = function rawValue (token) {
    return token[1];
  };

  mustache.name = 'mustache.js';
  mustache.version = '2.3.0';
  mustache.tags = [ '{{', '}}' ];

  // All high-level mustache.* functions use this writer.
  var defaultWriter = new Writer();

  /**
   * Clears all cached templates in the default writer.
   */
  mustache.clearCache = function clearCache () {
    return defaultWriter.clearCache();
  };

  /**
   * Parses and caches the given template in the default writer and returns the
   * array of tokens it contains. Doing this ahead of time avoids the need to
   * parse templates on the fly as they are rendered.
   */
  mustache.parse = function parse (template, tags) {
    return defaultWriter.parse(template, tags);
  };

  /**
   * Renders the `template` with the given `view` and `partials` using the
   * default writer.
   */
  mustache.render = function render (template, view, partials) {
    if (typeof template !== 'string') {
      throw new TypeError('Invalid template! Template should be a "string" ' +
                          'but "' + typeStr(template) + '" was given as the first ' +
                          'argument for mustache#render(template, view, partials)');
    }

    return defaultWriter.render(template, view, partials);
  };

  // This is here for backwards compatibility with 0.4.x.,
  /*eslint-disable */ // eslint wants camel cased function name
  mustache.to_html = function to_html (template, view, partials, send) {
    /*eslint-enable*/

    var result = mustache.render(template, view, partials);

    if (isFunction(send)) {
      send(result);
    } else {
      return result;
    }
  };

  // Export the escaping function so that the user may override it.
  // See https://github.com/janl/mustache.js/issues/244
  mustache.escape = escapeHtml;

  // Export these mainly for testing, but also for advanced usage.
  mustache.Scanner = Scanner;
  mustache.Context = Context;
  mustache.Writer = Writer;

  return mustache;
}));

},{}],12:[function(require,module,exports){
/* object-iterators.js - Mini Underscore library
 * by Jonathan Eiten
 *
 * The methods below operate on objects (but not arrays) similarly
 * to Underscore (http://underscorejs.org/#collections).
 *
 * For more information:
 * https://github.com/joneit/object-iterators
 */

'use strict';

/**
 * @constructor
 * @summary Wrap an object for one method call.
 * @Desc Note that the `new` keyword is not necessary.
 * @param {object|null|undefined} object - `null` or `undefined` is treated as an empty plain object.
 * @return {Wrapper} The wrapped object.
 */
function Wrapper(object) {
    if (object instanceof Wrapper) {
        return object;
    }
    if (!(this instanceof Wrapper)) {
        return new Wrapper(object);
    }
    this.originalValue = object;
    this.o = object || {};
}

/**
 * @name Wrapper.chain
 * @summary Wrap an object for a chain of method calls.
 * @Desc Calls the constructor `Wrapper()` and modifies the wrapper for chaining.
 * @param {object} object
 * @return {Wrapper} The wrapped object.
 */
Wrapper.chain = function (object) {
    var wrapped = Wrapper(object); // eslint-disable-line new-cap
    wrapped.chaining = true;
    return wrapped;
};

Wrapper.prototype = {
    /**
     * Unwrap an object wrapped with {@link Wrapper.chain|Wrapper.chain()}.
     * @return {object|null|undefined} The value originally wrapped by the constructor.
     * @memberOf Wrapper.prototype
     */
    value: function () {
        return this.originalValue;
    },

    /**
     * @desc Mimics Underscore's [each](http://underscorejs.org/#each) method: Iterate over the members of the wrapped object, calling `iteratee()` with each.
     * @param {function} iteratee - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function is undefined; an `.each` loop cannot be broken out of (use {@link Wrapper#find|.find} instead).
     * @param {object} [context] - If given, `iteratee` is bound to this object. In other words, this object becomes the `this` value in the calls to `iteratee`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {Wrapper} The wrapped object for chaining.
     * @memberOf Wrapper.prototype
     */
    each: function (iteratee, context) {
        var o = this.o;
        Object.keys(o).forEach(function (key) {
            iteratee.call(this, o[key], key, o);
        }, context || o);
        return this;
    },

    /**
     * @desc Mimics Underscore's [find](http://underscorejs.org/#find) method: Look through each member of the wrapped object, returning the first one that passes a truth test (`predicate`), or `undefined` if no value passes the test. The function returns the value of the first acceptable member, and doesn't necessarily traverse the entire object.
     * @param {function} predicate - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function should be truthy if the member passes the test and falsy otherwise.
     * @param {object} [context] - If given, `predicate` is bound to this object. In other words, this object becomes the `this` value in the calls to `predicate`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} The found property's value, or undefined if not found.
     * @memberOf Wrapper.prototype
     */
    find: function (predicate, context) {
        var o = this.o;
        var result;
        if (o) {
            result = Object.keys(o).find(function (key) {
                return predicate.call(this, o[key], key, o);
            }, context || o);
            if (result !== undefined) {
                result = o[result];
            }
        }
        return result;
    },

    /**
     * @desc Mimics Underscore's [filter](http://underscorejs.org/#filter) method: Look through each member of the wrapped object, returning the values of all members that pass a truth test (`predicate`), or empty array if no value passes the test. The function always traverses the entire object.
     * @param {function} predicate - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function should be truthy if the member passes the test and falsy otherwise.
     * @param {object} [context] - If given, `predicate` is bound to this object. In other words, this object becomes the `this` value in the calls to `predicate`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} An array containing the filtered values.
     * @memberOf Wrapper.prototype
     */
    filter: function (predicate, context) {
        var o = this.o;
        var result = [];
        if (o) {
            Object.keys(o).forEach(function (key) {
                if (predicate.call(this, o[key], key, o)) {
                    result.push(o[key]);
                }
            }, context || o);
        }
        return result;
    },

    /**
     * @desc Mimics Underscore's [map](http://underscorejs.org/#map) method: Produces a new array of values by mapping each value in list through a transformation function (`iteratee`). The function always traverses the entire object.
     * @param {function} iteratee - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function is concatenated to the end of the new array.
     * @param {object} [context] - If given, `iteratee` is bound to this object. In other words, this object becomes the `this` value in the calls to `predicate`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} An array containing the filtered values.
     * @memberOf Wrapper.prototype
     */
    map: function (iteratee, context) {
        var o = this.o;
        var result = [];
        if (o) {
            Object.keys(o).forEach(function (key) {
                result.push(iteratee.call(this, o[key], key, o));
            }, context || o);
        }
        return result;
    },

    /**
     * @desc Mimics Underscore's [reduce](http://underscorejs.org/#reduce) method: Boil down the values of all the members of the wrapped object into a single value. `memo` is the initial state of the reduction, and each successive step of it should be returned by `iteratee()`.
     * @param {function} iteratee - For each member of the wrapped object, this function is called with four arguments: `(memo, value, key, object)`. The return value of this function becomes the new value of `memo` for the next iteration.
     * @param {*} [memo] - If no memo is passed to the initial invocation of reduce, the iteratee is not invoked on the first element of the list. The first element is instead passed as the memo in the invocation of the iteratee on the next element in the list.
     * @param {object} [context] - If given, `iteratee` is bound to this object. In other words, this object becomes the `this` value in the calls to `iteratee`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} The value of `memo` "reduced" as per `iteratee`.
     * @memberOf Wrapper.prototype
     */
    reduce: function (iteratee, memo, context) {
        var o = this.o;
        if (o) {
            Object.keys(o).forEach(function (key, idx) {
                memo = (!idx && memo === undefined) ? o[key] : iteratee(memo, o[key], key, o);
            }, context || o);
        }
        return memo;
    },

    /**
     * @desc Mimics Underscore's [extend](http://underscorejs.org/#extend) method: Copy all of the properties in each of the `source` object parameter(s) over to the (wrapped) destination object (thus mutating it). It's in-order, so the properties of the last `source` object will override properties with the same name in previous arguments or in the destination object.
     * > This method copies own members as well as members inherited from prototype chain.
     * @param {...object|null|undefined} source - Values of `null` or `undefined` are treated as empty plain objects.
     * @return {Wrapper|object} The wrapped destination object if chaining is in effect; otherwise the unwrapped destination object.
     * @memberOf Wrapper.prototype
     */
    extend: function (source) {
        var o = this.o;
        Array.prototype.slice.call(arguments).forEach(function (object) {
            if (object) {
                for (var key in object) {
                    o[key] = object[key];
                }
            }
        });
        return this.chaining ? this : o;
    },

    /**
     * @desc Mimics Underscore's [extendOwn](http://underscorejs.org/#extendOwn) method: Like {@link Wrapper#extend|extend}, but only copies its "own" properties over to the destination object.
     * @param {...object|null|undefined} source - Values of `null` or `undefined` are treated as empty plain objects.
     * @return {Wrapper|object} The wrapped destination object if chaining is in effect; otherwise the unwrapped destination object.
     * @memberOf Wrapper.prototype
     */
    extendOwn: function (source) {
        var o = this.o;
        Array.prototype.slice.call(arguments).forEach(function (object) {
            Wrapper(object).each(function (val, key) { // eslint-disable-line new-cap
                o[key] = val;
            });
        });
        return this.chaining ? this : o;
    }
};

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
if (!Array.prototype.find) {
    Array.prototype.find = function (predicate) { // eslint-disable-line no-extend-native
        if (this === null) {
            throw new TypeError('Array.prototype.find called on null or undefined');
        }
        if (typeof predicate !== 'function') {
            throw new TypeError('predicate must be a function');
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;

        for (var i = 0; i < length; i++) {
            value = list[i];
            if (predicate.call(thisArg, value, i, list)) {
                return value;
            }
        }
        return undefined;
    };
}

module.exports = Wrapper;

},{}],13:[function(require,module,exports){
'use strict';

/** @module overrider */

/**
 * Mixes members of all `sources` into `target`, handling getters and setters properly.
 *
 * Any number of `sources` objects may be given and each is copied in turn.
 *
 * @example
 * var overrider = require('overrider');
 * var target = { a: 1 }, source1 = { b: 2 }, source2 = { c: 3 };
 * target === overrider(target, source1, source2); // true
 * // target object now has a, b, and c; source objects untouched
 *
 * @param {object} object - The target object to receive sources.
 * @param {...object} [sources] - Object(s) containing members to copy to `target`. (Omitting is a no-op.)
 * @returns {object} The target object (`target`)
 */
function overrider(target, sources) { // eslint-disable-line no-unused-vars
    for (var i = 1; i < arguments.length; ++i) {
        mixIn.call(target, arguments[i]);
    }

    return target;
}

/**
 * Mix `this` members into `target`.
 *
 * @example
 * // A. Simple usage (using .call):
 * var mixInTo = require('overrider').mixInTo;
 * var target = { a: 1 }, source = { b: 2 };
 * target === overrider.mixInTo.call(source, target); // true
 * // target object now has both a and b; source object untouched
 *
 * @example
 * // B. Semantic usage (when the source hosts the method):
 * var mixInTo = require('overrider').mixInTo;
 * var target = { a: 1 }, source = { b: 2, mixInTo: mixInTo };
 * target === source.mixInTo(target); // true
 * // target object now has both a and b; source object untouched
 *
 * @this {object} Target.
 * @param target
 * @returns {object} The target object (`target`)
 * @memberOf module:overrider
 */
function mixInTo(target) {
    var descriptor;
    for (var key in this) {
        if ((descriptor = Object.getOwnPropertyDescriptor(this, key))) {
            Object.defineProperty(target, key, descriptor);
        }
    }
    return target;
}

/**
 * Mix `source` members into `this`.
 *
 * @example
 * // A. Simple usage (using .call):
 * var mixIn = require('overrider').mixIn;
 * var target = { a: 1 }, source = { b: 2 };
 * target === overrider.mixIn.call(target, source) // true
 * // target object now has both a and b; source object untouched
 *
 * @example
 * // B. Semantic usage (when the target hosts the method):
 * var mixIn = require('overrider').mixIn;
 * var target = { a: 1, mixIn: mixIn }, source = { b: 2 };
 * target === target.mixIn(source) // true
 * // target now has both a and b (and mixIn); source untouched
 *
 * @param source
 * @returns {object} The target object (`this`)
 * @memberOf overrider
 * @memberOf module:overrider
 */
function mixIn(source) {
    var descriptor;
    for (var key in source) {
        if ((descriptor = Object.getOwnPropertyDescriptor(source, key))) {
            Object.defineProperty(this, key, descriptor);
        }
    }
    return this;
}

overrider.mixInTo = mixInTo;
overrider.mixIn = mixIn;

module.exports = overrider;

},{}],14:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

/**
 * Creates a new read-only property and attaches it to the provided context.
 * @private
 * @param {string} name - Name for new property.
 * @param {*} [value] - Value of new property.
 */
function addReadOnlyProperty(name, value) {
    Object.defineProperty(this, name, {
        value: value,
        writable: false,
        enumerable: true,
        configurable: false
    });
}

/**
 * @constructor Point
 *
 * @desc This object represents a single point in an abstract 2-dimensional matrix.
 *
 * The unit of measure is typically pixels.
 * (If used to model computer graphics, vertical coordinates are typically measured downwards
 * from the top of the window. This convention however is not inherent in this object.)
 *
 * Note: This object should be instantiated with the `new` keyword.
 *
 * @param {number} x - the new point's `x` property
 * @param {number} y - the new point's `y` property
 */
function Point(x, y) {

    /**
     * @name x
     * @type {number}
     * @summary This point's horizontal coordinate.
     * @desc Created upon instantiation by the {@link Point|constructor}.
     * @memberOf Point.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'x', Number(x) || 0);

    /**
     * @name y
     * @type {number}
     * @summary This point's vertical coordinate.
     * @desc Created upon instantiation by the {@link Point|constructor}.
     * @memberOf Point.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'y', Number(y) || 0);

}

Point.prototype = {

    /**
     * @returns {Point} A new point which is this point's position increased by coordinates of given `offset`.
     * @param {Point} offset - Horizontal and vertical values to add to this point's coordinates.
     * @memberOf Point.prototype
     */
    plus: function(offset) {
        return new Point(
            this.x + offset.x,
            this.y + offset.y
        );
    },

    /**
     * @returns {Point} A new point which is this point's position increased by given offsets.
     * @param {number} [offsetX=0] - Value to add to this point's horizontal coordinate.
     * @param {number} [offsetY=0] - Value to add to this point's horizontal coordinate.
     * @memberOf Point.prototype
     */
    plusXY: function(offsetX, offsetY) {
        return new Point(
            this.x + (offsetX || 0),
            this.y + (offsetY || 0)
        );
    },

    /**
     * @returns {Point} A new point which is this point's position decreased by coordinates of given `offset`.
     * @param {Point} offset - Horizontal and vertical values to subtract from this point's coordinates.
     * @memberOf Point.prototype
     */
    minus: function(offset) {
        return new Point(
            this.x - offset.x,
            this.y - offset.y
        );
    },

    /**
     * @returns {Point} A new `Point` positioned to least x and least y of this point and given `offset`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    min: function(point) {
        return new Point(
            Math.min(this.x, point.x),
            Math.min(this.y, point.y)
        );
    },

    /**
     * @returns {Point} A new `Point` positioned to greatest x and greatest y of this point and given `point`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    max: function(point) {
        return new Point(
            Math.max(this.x, point.x),
            Math.max(this.y, point.y)
        );
    },

    /**
     * @returns {number} Distance between given `point` and this point using Pythagorean Theorem formula.
     * @param {Point} point - A point from which to compute the distance to this point.
     * @memberOf Point.prototype
     */
    distance: function(point) {
        var deltaX = point.x - this.x,
            deltaY = point.y - this.y;

        return Math.sqrt(
            deltaX * deltaX +
            deltaY * deltaY
        );
    },

    /**
     * _(Formerly: `equal`.)_
     * @returns {boolean} `true` iff _both_ coordinates of this point are exactly equal to those of given `point`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    equals: function(point) {
        var result = false;

        if (point) {
            result =
                this.x === point.x &&
                this.y === point.y;
        }

        return result;
    },

    /**
     * @returns {boolean} `true` iff _both_ coordinates of this point are greater than those of given `point`.
     * @param {Point} point - A point to compare to this point
     * @memberOf Point.prototype
     */
    greaterThan: function(point) {
        return (
            this.x > point.x &&
            this.y > point.y
        );
    },

    /**
     * @returns {boolean} `true` iff _both_ coordinates of this point are less than those of given `point`.
     * @param {Point} point - A point to compare to this point
     * @memberOf Point.prototype
     */
    lessThan: function(point) {
        return (
            this.x < point.x &&
            this.y < point.y
        );
    },

    /**
     * _(Formerly `greaterThanEqualTo`.)_
     * @returns {boolean} `true` iff _both_ coordinates of this point are greater than or equal to those of given `point`.
     * @param {Point} point - A point to compare to this point
     * @memberOf Point.prototype
     */
    greaterThanOrEqualTo: function(point) {
        return (
            this.x >= point.x &&
            this.y >= point.y
        );
    },

    /**
     * _(Formerly `lessThanEqualTo`.)_
     * @returns {boolean} `true` iff _both_ coordinates of this point are less than or equal to those of given `point`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    lessThanOrEqualTo: function(point) {
        return (
            this.x <= point.x &&
            this.y <= point.y
        );
    },

    /**
     * _(Formerly `isContainedWithinRectangle`.)_
     * @param rect {Rectangle} - Rectangle to test this point against.
     * @returns {boolean} `true` iff this point is within given `rect`.
     * @memberOf Point.prototype
     */
    within: function(rect) {
        var minX = rect.origin.x,
            maxX = minX + rect.extent.x;
        var minY = rect.origin.y,
            maxY = minY + rect.extent.y;

        if (rect.extent.x < 0) {
            minX = maxX;
            maxX = rect.origin.x;
        }

        if (rect.extent.y < 0) {
            minY = maxY;
            maxY = rect.origin.y;
        }

        return (
            minX <= this.x && this.x < maxX &&
            minY <= this.y && this.y < maxY
        );
    }
};

Point.prototype.EQ = Point.prototype.equals;
Point.prototype.GT = Point.prototype.greaterThan;
Point.prototype.LT = Point.prototype.lessThan;
Point.prototype.GE = Point.prototype.greaterThanOrEqualTo;
Point.prototype.LE = Point.prototype.lessThanOrEqualTo;


/**
 * @constructor Rectangle
 *
 * @desc This object represents a rectangular area within an abstract 2-dimensional matrix.
 *
 * The unit of measure is typically pixels.
 * (If used to model computer graphics, vertical coordinates are typically measured downwards
 * from the top of the window. This convention however is not inherent in this object.)
 *
 * Normally, the `x` and `y` parameters to the constructor describe the upper left corner of the rect.
 * However, negative values of `width` and `height` will be added to the given `x` and `y`. That is,
 * a negative value of the `width` parameter will extend the rect to the left of the given `x` and
 * a negative value of the `height` parameter will extend the rect above the given `y`.
 * In any case, after instantiation the following are guaranteed to always be true:
 * * The `extent`, `width`, and `height` properties _always_ give positive values.
 * * The `origin`, `top`, and `left` properties _always_ reflect the upper left corner.
 * * The `corner`, `bottom`, and `right` properties _always_ reflect the lower right corner.
 *
 * Note: This object should be instantiated with the `new` keyword.
 *
 * @param {number} [x=0] - Horizontal coordinate of some corner of the rect.
 * @param {number} [y=0] - Vertical coordinate of some corner of the rect.
 * @param {number} [width=0] - Width of the new rect. May be negative (see above).
 * @param {number} [height=0] - Height of the new rect. May be negative (see above).
 */
function Rectangle(x, y, width, height) {

    x = Number(x) || 0;
    y = Number(y) || 0;
    width = Number(width) || 0;
    height = Number(height) || 0;

    if (width < 0) {
        x += width;
        width = -width;
    }

    if (height < 0) {
        y += height;
        height = -height;
    }

    /**
     * @name origin
     * @type {Point}
     * @summary Upper left corner of this rect.
     * @desc Created upon instantiation by the {@linkplain Rectangle|constructor}.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'origin', new Point(x, y));

    /**
     * @name extent
     * @type {Point}
     * @summary this rect's width and height.
     * @desc Unlike the other `Point` properties, `extent` is not a global coordinate pair; rather it consists of a _width_ (`x`, always positive) and a _height_ (`y`, always positive).
     *
     * This object might be more legitimately typed as something like `Area` with properties `width` and `height`; however we wanted it to be able to use it efficiently with a point's `plus` and `minus` methods (that is, without those methods having to check and branch on the type of its parameter).
     *
     * Created upon instantiation by the {@linkplain Rectangle|constructor}.
     * @see The {@link Rectangle#corner|corner} method.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'extent', new Point(width, height));

    /**
     * @name corner
     * @type {Point}
     * @summary Lower right corner of this rect.
     * @desc This is a calculated value created upon instantiation by the {@linkplain Rectangle|constructor}. It is `origin` offset by `extent`.
     *
     * **Note:** These coordinates actually point to the pixel one below and one to the right of the rect's actual lower right pixel.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'corner', new Point(x + width, y + height));

    /**
     * @name center
     * @type {Point}
     * @summary Center of this rect.
     * @desc Created upon instantiation by the {@linkplain Rectangle|constructor}.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'center', new Point(x + (width / 2), y + (height / 2)));

}

Rectangle.prototype = {

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Minimum vertical coordinate of this rect.
     * @memberOf Rectangle.prototype
     */
    get top() {
        return this.origin.y;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Minimum horizontal coordinate of this rect.
     * @memberOf Rectangle.prototype
     */
    get left() {
        return this.origin.x;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Maximum vertical coordinate of this rect + 1.
     * @memberOf Rectangle.prototype
     */
    get bottom() {
        return this.corner.y;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Maximum horizontal coordinate of this rect + 1.
     * @memberOf Rectangle.prototype
     */
    get right() {
        return this.corner.x;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Width of this rect (always positive).
     * @memberOf Rectangle.prototype
     */
    get width() {
        return this.extent.x;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Height of this rect (always positive).
     * @memberOf Rectangle.prototype
     */
    get height() {
        return this.extent.y;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Area of this rect.
     * @memberOf Rectangle.prototype
     */
    get area() {
        return this.width * this.height;
    },

    /**
     * @returns {Rectangle} A copy of this rect but with horizontal position reset to given `x` and no width.
     * @param {number} x - Horizontal coordinate of the new rect.
     * @memberOf Rectangle.prototype
     */
    flattenXAt: function(x) {
        return new Rectangle(x, this.origin.y, 0, this.extent.y);
    },

    /**
     * @returns {Rectangle} A copy of this rect but with vertical position reset to given `y` and no height.
     * @param {number} y - Vertical coordinate of the new rect.
     * @memberOf Rectangle.prototype
     */
    flattenYAt: function(y) {
        return new Rectangle(this.origin.x, y, this.extent.x, 0);
    },

    /**
     * @returns {boolean} `true` iff given `point` entirely contained within this rect.
     * @param {Point} pointOrRect - The point or rect to test for containment.
     * @memberOf Rectangle.prototype
     */
    contains: function(pointOrRect) {
        return pointOrRect.within(this);
    },

    /**
     * _(Formerly `isContainedWithinRectangle`.)_
     * @returns {boolean} `true` iff `this` rect is entirely contained within given `rect`.
     * @param {Rectangle} rect - Rectangle to test against this rect.
     * @memberOf Rectangle.prototype
     */
    within: function(rect) {
        return (
            rect.origin.lessThanOrEqualTo(this.origin) &&
            rect.corner.greaterThanOrEqualTo(this.corner)
        );
    },

    /**
     * _(Formerly: `insetBy`.)_
     * @returns {Rectangle} That is enlarged/shrunk by given `padding`.
     * @param {number} padding - Amount by which to increase (+) or decrease (-) this rect
     * @see The {@link Rectangle#shrinkBy|shrinkBy} method.
     * @memberOf Rectangle.prototype
     */
    growBy: function(padding) {
        return new Rectangle(
            this.origin.x + padding,
            this.origin.y + padding,
            this.extent.x - padding - padding,
            this.extent.y - padding - padding);
    },

    /**
     * @returns {Rectangle} That is enlarged/shrunk by given `padding`.
     * @param {number} padding - Amount by which to decrease (+) or increase (-) this rect.
     * @see The {@link Rectangle#growBy|growBy} method.
     * @memberOf Rectangle.prototype
     */
    shrinkBy: function(padding) {
        return this.growBy(-padding);
    },

    /**
     * @returns {Rectangle} Bounding rect that contains both this rect and the given `rect`.
     * @param {Rectangle} rect - The rectangle to union with this rect.
     * @memberOf Rectangle.prototype
     */
    union: function(rect) {
        var origin = this.origin.min(rect.origin),
            corner = this.corner.max(rect.corner),
            extent = corner.minus(origin);

        return new Rectangle(
            origin.x, origin.y,
            extent.x, extent.y
        );
    },

    /**
     * iterate over all points within this rect, invoking `iteratee` for each.
     * @param {function(number,number)} iteratee - Function to call for each point.
     * Bound to `context` when given; otherwise it is bound to this rect.
     * Each invocation of `iteratee` is called with two arguments:
     * the horizontal and vertical coordinates of the point.
     * @param {object} [context=this] - Context to bind to `iteratee` (when not `this`).
     * @memberOf Rectangle.prototype
     */
    forEach: function(iteratee, context) {
        context = context || this;
        for (var x = this.origin.x, x2 = this.corner.x; x < x2; x++) {
            for (var y = this.origin.y, y2 = this.corner.y; y < y2; y++) {
                iteratee.call(context, x, y);
            }
        }
    },

    /**
     * @returns {Rectangle} One of:
     * * _If this rect intersects with the given `rect`:_
     *      a new rect representing that intersection.
     * * _If it doesn't intersect and `ifNoneAction` defined:_
     *      result of calling `ifNoneAction`.
     * * _If it doesn't intersect and `ifNoneAction` undefined:_
     *      `null`.
     * @param {Rectangle} rect - The rectangle to intersect with this rect.
     * @param {function(Rectangle)} [ifNoneAction] - When no intersection, invoke and return result.
     * Bound to `context` when given; otherwise bound to this rect.
     * Invoked with `rect` as sole parameter.
     * @param {object} [context=this] - Context to bind to `ifNoneAction` (when not `this`).
     * @memberOf Rectangle.prototype
     */
    intersect: function(rect, ifNoneAction, context) {
        var result = null,
            origin = this.origin.max(rect.origin),
            corner = this.corner.min(rect.corner),
            extent = corner.minus(origin);

        if (extent.x > 0 && extent.y > 0) {
            result = new Rectangle(
                origin.x, origin.y,
                extent.x, extent.y
            );
        } else if (typeof ifNoneAction === 'function') {
            result = ifNoneAction.call(context || this, rect);
        }

        return result;
    },

    /**
     * @returns {boolean} `true` iff this rect overlaps with given `rect`.
     * @param {Rectangle} rect - The rectangle to intersect with this rect.
     * @memberOf Rectangle.prototype
     */
    intersects: function(rect) {
        return (
            rect.corner.x > this.origin.x &&
            rect.corner.y > this.origin.y &&
            rect.origin.x < this.corner.x &&
            rect.origin.y < this.corner.y
        );
    }
};

// Interface
exports.Point = Point;
exports.Rectangle = Rectangle;

},{}],15:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

(function (module) {  // eslint-disable-line no-unused-expressions

    // This closure supports NodeJS-less client side includes with <script> tags. See https://github.com/joneit/mnm.

    /**
     * @constructor RangeSelectionModel
     *
     * @desc This object models selection of "cells" within an abstract single-dimensional matrix.
     *
     * Disjoint selections can be built with calls to the following methods:
     * * {@link RangeSelectionModel#select|select(start, stop)} - Add a range to the matrix.
     * * {@link RangeSelectionModel#deselect|deselect(start, stop)} - Remove a range from the matrix.
     *
     * Two more methods are available:
     * * Test a cell to see if it {@link RangeSelectionModel#isSelected|isSelected(cell)}
     * * {@link RangeSelectionModel#clear|clear()} the matrix
     *
     * Internally, the selection is run-length-encoded. It is therefore a "sparse" matrix
     * with undefined bounds. A single data property called `selection` is an array that
     * contains all the "runs" (ranges) of selected cells albeit in no particular order.
     * This property should not normally need to be accessed directly.
     *
     * Note: This object should be instantiated with the `new` keyword.
     *
     * @returns {RangeSelectionModel} Self (i.e., `this` object).
     */
    function RangeSelectionModel() {
        /**
         * @name selection
         * @type {Array.Array.number}
         * @summary Unordered list of runs.
         * @desc A "run" is defined as an Array(2) where:
         * * element [0] is the beginning of the run
         * * element [1] is the end of the run (inclusive) and is always >= element [0]
         * The order of the runs within is undefined.
         * @memberOf RangeSelectionModel.prototype
         * @abstract
         */
        this.selection = [];

        //we need to be able to go back in time
        //the states field
        this.states = [];

        //clone and store my current state
        //so we can unwind changes if need be
        this.storeState = function () {
            var sels = this.selection;
            var state = [];
            var copy;
            for (var i = 0; i < sels.length; i++) {
                copy = [].concat(sels[i]);
                state.push(copy);
            }
            this.states.push(state);
        };
    }

    RangeSelectionModel.prototype = {

        /**
         * @summary Add a contiguous run of points to the selection.
         * @desc Insert a new run into `this.selection`.
         * The new run will be merged with overlapping and adjacent runs.
         *
         * The two parameters may be given in either order.
         * The start and stop elements in the resulting run will however always be ordered.
         * (However, note that the order of the runs within `this.selection` is itself always unordered.)
         *
         * Note that `this.selection` is updated in place, preserving validity of any external references.
         * @param {number} start - Start of run. May be greater than `stop`.
         * @param {number} [stop=stop] - End of run (inclusive). May be less than `start`.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        select: function (start, stop) {
            this.storeState();
            var run = makeRun(start, stop);
            var splicer = [0, 1];
            this.selection.forEach(function (each) {
                if (overlaps(each, run) || abuts(each, run)) {
                    run = merge(each, run);
                } else {
                    splicer.push(each);
                }
            });
            splicer.push(run);
            splicer[1] = this.selection.length;
            this.selection.splice.apply(this.selection, splicer); // update in place to preserve external references
            return this;
        },

        /**
         * @summary Remove a contiguous run of points from the selection.
         * @desc Truncate and/or remove run(s) from `this.selection`.
         * Removing part of existing runs will (correctly) shorten them or break them into two fragments.
         *
         * The two parameters may be given in either order.
         *
         * Note that `this.selection` is updated in place, preserving validity of any external references.
         * @param {number} start - Start of run. May be greater than `stop`.
         * @param {number} [stop=stop] - End of run (inclusive). May be less than `start`.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        deselect: function (start, stop) {
            var run = makeRun(start, stop);
            var splicer = [0, 0];
            this.selection.forEach(function (each) {
                if (overlaps(each, run)) {
                    var pieces = subtract(each, run);
                    splicer = splicer.concat(pieces);
                } else {
                    splicer.push(each);
                }
            });
            splicer[1] = this.selection.length;
            this.selection.splice.apply(this.selection, splicer); // update in place to preserve external references
            return this;
        },

        /**
         * @summary Empties `this.selection`, effectively removing all runs.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        clear: function () {
            this.states.length = 0;
            this.selection.length = 0;
            return this;
        },

        clearMostRecentSelection: function () {
            if (this.states.length === 0) {
                return;
            }
            this.selection = this.states.pop();
        },

        /**
         * @summary Determines if the given `cell` is selected.
         * @returns {boolean} `true` iff given `cell` is within any of the runs in `this.selection`.
         * @param {number} cell - The cell to test for inclusion in the selection.
         * @memberOf RangeSelectionModel.prototype
         */
        isSelected: function (cell) {
            return this.selection.some(function (each) {
                return each[0] <= cell && cell <= each[1];
            });
        },

        isEmpty: function (){
            return this.selection.length === 0;
        },

        /**
         * @summary Return the indexes that are selected.
         * @desc Return the indexes that are selected.
         * @returns {Array.Array.number}
         * @memberOf RangeSelectionModel.prototype
         */
        getSelections: function (){
            var result = [];
            this.selection.forEach(function (each) {
                for (var i = each[0]; i <= each[1]; i++) {
                    result.push(i);
                }
            });
            result.sort(function (a, b){
                return a - b;
            });
            return result;
        }

    };

    /**
     * @private
     * @summary Preps `start` and `stop` params into order array
     * @function makeRun
     * @desc Utility function called by both `select()` and `deselect()`.
     * @param {number|number[]} start - Start of run. if array, `start` and `stop` are taken from first two elements.
     * @param {number} [stop=start] - End of run (inclusive).
     */
    function makeRun(start, stop) {
        return (
            start instanceof Array
                ? makeRun.apply(this, start) // extract params from given array
                : stop === undefined
                ? [ start, start ] // single param is a run that stops where it starts
                : start <= stop
                ? [ start, stop ]
                : [ stop, start ] // reverse descending params into ascending order
        );
    }

    /**
     * @private
     * @function overlaps
     * @returns {boolean} `true` iff `run1` overlaps `run2`
     * @summary Comparison operator that determines if given runs overlap with one another.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * Overlap is defined to include the case where one run completely contains the other.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - first run
     * @param {number[]} run2 - second run
     */
    function overlaps(run1, run2) {
        return (
            run1[0] <= run2[0] && run2[0] <= run1[1] || // run2's start is within run1 OR...
            run1[0] <= run2[1] && run2[1] <= run1[1] || // run2's stop is within run1 OR...
            run2[0] <  run1[0] && run1[1] <  run2[1]    // run2 completely contains run1
        );
    }

    /**
     * @private
     * @function abuts
     * @summary Comparison operator that determines if given runs are consecutive with one another.
     * @returns {boolean} `true` iff `run1` is consecutive with `run2`
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - first run
     * @param {number[]} run2 - second run
     */
    function abuts(run1, run2) {
        return (
            run1[1] === run2[0] - 1 || // run1's top immediately precedes run2's start OR...
            run2[1] === run1[0] - 1    // run2's top immediately precedes run1's start
        );
    }

    /**
     * @private
     * @function subtract
     * @summary Operator that subtracts one run from another.
     * @returns {Array.Array.number} The remaining pieces of `minuend` after removing `subtrahend`.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * This function _does not assumes_ that `overlap()` has already been called with the same runs and has returned `true`.
     *
     * Returned array contains 0, 1, or 2 runs which are the portion(s) of `minuend` that do _not_ include `subtrahend`.
     *
     * Caveat: This operator is *not* commutative.
     * @param {number[]} minuend - a run from which to "subtract" `subtrahend`
     * @param {number[]} subtrahend - a run to "subtracted" from `minuend`
     */
    function subtract(minuend, subtrahend) {
        var m0 = minuend[0];
        var m1 = minuend[1];
        var s0 = subtrahend[0];
        var s1 = subtrahend[1];
        var result = [];

        if (s0 <= m0 && s1 < m1) {
            //subtrahend extends before minuend: return remaining piece of `minuend`
            result.push([s1 + 1, m1]);
        } else if (s0 > m0 && s1 >= m1) {
            //subtrahend extends after minuend: return remaining piece of `minuend`
            result.push([m0, s0 - 1]);
        } else if (m0 < s0 && s1 < m1) {
            //completely inside: return 2 smaller pieces resulting from the hole
            result.push([m0, s0 - 1]);
            result.push([s1 + 1, m1]);
        } else if (s1 < m0 || s0 > m1) {
            // completely outside: return `minuend` untouched
            result.push(minuend);
        }

        //else subtrahend must completely overlap minuend so return no pieces

        return result;
    }


    // Local utility functions

    /**
     * @private
     * @function merge
     * @summary Operator that merges given runs.
     * @returns {number[]} A single merged run.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * The runs are assumed to be overlapping or adjacent to one another.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - a run to merge with `run2`
     * @param {number[]} run2 - a run to merge with `run1`
     */
    function merge(run1, run2) {
        var min = Math.min(Math.min.apply(Math, run1), Math.min.apply(Math, run2));
        var max = Math.max(Math.max.apply(Math, run1), Math.max.apply(Math, run2));
        return [min, max];
    }

    // Interface
    module.exports = RangeSelectionModel;
})(
    typeof module === 'object' && module || (window.RangeSelectionModel = {}),
    typeof module === 'object' && module.exports || (window.RangeSelectionModel.exports = {})
) || (
    typeof module === 'object' || (window.RangeSelectionModel = window.RangeSelectionModel.exports)
);

/* About the above IIFE:
 * This file is a "modified node module." It functions as usual in Node.js *and* is also usable directly in the browser.
 * 1. Node.js: The IIFE is superfluous but innocuous.
 * 2. In the browser: The IIFE closure serves to keep internal declarations private.
 * 2.a. In the browser as a global: The logic in the actual parameter expressions + the post-invocation expression
 * will put your API in `window.RangeSelectionModel`.
 * 2.b. In the browser as a module: If you predefine a `window.module` object, the results will be in `module.exports`.
 * The bower component `mnm` makes this easy and also provides a global `require()` function for referencing your module
 * from other closures. In either case, this works with both NodeJs-style export mechanisms -- a single API assignment,
 * `module.exports = yourAPI` *or* a series of individual property assignments, `module.exports.property = property`.
 *
 * Before the IIFE runs, the actual parameter expressions are executed:
 * 1. If `window` object undefined, we're in NodeJs so assume there is a `module` object with an `exports` property
 * 2. If `window` object defined, we're in browser
 * 2.a. If `module` object predefined, use it
 * 2.b. If `module` object undefined, create a `RangeSelectionModel` object
 *
 * After the IIFE returns:
 * Because it always returns undefined, the expression after the || will execute:
 * 1. If `window` object undefined, then we're in NodeJs so we're done
 * 2. If `window` object defined, then we're in browser
 * 2.a. If `module` object predefined, we're done; results are in `moudule.exports`
 * 2.b. If `module` object undefined, redefine`RangeSelectionModel` to be the `RangeSelectionModel.exports` object
 */

},{}],16:[function(require,module,exports){
module.exports={
    "name": "fin-hypergrid",
    "version": "3.0.0",
    "description": "Canvas-based high-performance grid extended",
    "main": "src/Hypergrid",
    "repository": {
        "type": "git",
        "url": "git://github.com/alex-kls/core.git"
    },
    "author": "SWirts, JEiten, DJones, NMichaud, AKlishchevskiy",
    "license": "MIT",
    "readmeFilename": "README.md",
    "gitHead": "",
    "keywords": [
        "spreadsheet",
        "grid",
        "canvas"
    ],
    "dependencies": {
        "chai": "^4.1.2",
        "deep-equal": "^1.0.1",
        "extend-me": "^2.7.0",
        "fin-hypergrid-event-logger": "^1.0.4",
        "finbars": "1.5.2",
        "inject-stylesheet-template": "^1.0.1",
        "mustache": "^2.3.0",
        "object-iterators": "1.3.0",
        "overrider": "^0",
        "rectangular": "1.0.1",
        "sparse-boolean-array": "1.0.1"
    },
    "devDependencies": {
        "babel-core": "^6.26.0",
        "babel-preset-es2015": "^6.24.1",
        "babel-preset-es2016": "^6.24.1",
        "babelify": "^8.0.0",
        "browser-sync": "^2.23.6",
        "browserify": "^16.1.1",
        "css-injector": "^1.1.0",
        "gulp": "^3.9.0",
        "gulp-concat": "^2.6.0",
        "gulp-each": "^0.1.1",
        "gulp-eslint": "^4.0.2",
        "gulp-exclude-gitignore": "^1.2.0",
        "gulp-footer": "^1.1.1",
        "gulp-header": "^1.8.2",
        "gulp-imagine-64": "^1.0.1",
        "gulp-load-plugins": "^1.1.0",
        "gulp-mirror": "^1.0.0",
        "gulp-mocha": "^2.2.0",
        "gulp-rename": "^1.2.2",
        "gulp-replace": "^0.6.1",
        "gulp-uglify": "^3.0.0",
        "gulp-util": "^3.0.8",
        "gutil": "^1.6.4",
        "header": "^0.1.1",
        "multipipe": "^2.0.3",
        "multiple": "^0.2.1",
        "run-sequence": "^1.1.4",
        "through2": "^2.0.3",
        "vinyl-buffer": "^1.0.1",
        "vinyl-source-stream": "^2.0.0"
    }
}

},{}],17:[function(require,module,exports){
/* globals alert */

'use strict';

/**
 * @constructor
 * @desc Extend from this base class using `Base.extend` per example.
 * @example
 * var prototype = { ... };
 * var descendantClass = Base.extend(prototype};
 * @classdesc This is an abstract base class available for all Hypergrid classes.
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Base = require('extend-me').Base;

Object.defineProperty(Base.prototype, 'version', {
    enumerable: true,
    writable: false, // read-only
    configurable: false,
    value: require('../package.json').version
});

Base.prototype.deprecated = require('./lib/deprecated');
Base.prototype.HypergridError = require('./lib/error');

Base.prototype.notify = function (message, onerror) {
    switch (onerror) {
        case 'warn':
            console.warn(message);break;
        case 'alert':
            alert(message);break; // eslint-disable-line no-alert
        default:
            throw new this.HypergridError(message);
    }
};

/**
 * Convenience function for getting the value when that value can be defined as a function that needs to be called to get the actual (primitive) value.
 * @param value
 * @returns {*}
 */
Base.prototype.unwrap = function (value) {
    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value))[0] === 'f') {
        value = value();
    }
    return value;
};

/**
 * @method
 * @summary Mixes source members into calling context.
 * @desc Context is typically either an instance or the (shared) prototype of a "class" extended from {@link Base} (see examples).
 *
 * Typically used by plug-ins.
 * @example
 * // define instance members: myGrid.fix(), etc.
 * myGrid.mixIn({ fix: function() {...}, ... });
 * @example
 * // define prototype members: Hypergrid.prototype.fix(), etc.
 * Hypergrid.prototype.mixIn({ fix: function() {...}, ... });
 * @See {@link https://joneit.github.io/overrider/module-overrider.htm#.mixIn}
 * @param {object} source
 */
Base.prototype.mixIn = require('overrider').mixIn;

/**
 * @method
 * @summary Instantiate an object with discrete + variable args.
 * @desc The discrete args are passed first, followed by the variable args.
 * @param {function} Constructor
 * @param {Array} variableArgArray
 * @param {...*} discreteArgs
 * @returns {object} Object of type `Constructor` newly constructor using the arguments in `arrayOfArgs`.
 */
Base.prototype.createApply = function (Constructor, variableArgArray, discreteArgs) {
    var discreteArgArray = Array.prototype.slice.call(arguments, 2),
        args = [null] // null is context for `bind` call below
    .concat(discreteArgArray) // discrete arguments
    .concat(variableArgArray),
        // variable arguments
    BoundConstructor = Constructor.bind.apply(Constructor, args);

    return new BoundConstructor();
};

module.exports = Base;

},{"../package.json":16,"./lib/deprecated":93,"./lib/error":95,"extend-me":9,"overrider":13}],18:[function(require,module,exports){
'use strict';

function DataSourceBase() {}

DataSourceBase.extend = require('extend-me'); // make `extend`-able

DataSourceBase.prototype = {
    constructor: DataSourceBase.prototype.constructor,

    $$CLASS_NAME: 'DataSourceBase',

    isNullObject: true,

    drillDownCharMap: {
        true: '\u25BC', // BLACK DOWN-POINTING TRIANGLE aka ''
        false: '\u25B6', // BLACK RIGHT-POINTING TRIANGLE aka ''
        undefined: '', // leaf rows have no control glyph
        null: '   ' // indent
    },

    DataSourceError: DataSourceError,

    initialize: function initialize(nextDataSource, options) {
        if (nextDataSource) {
            this.next = nextDataSource;
        }

        this.install(Object.getPrototypeOf(this));
    },

    /**
     * @implements dataModelAPI#needs
     * @see {@link https://fin-hypergrid.github.io/core/doc/dataModelAPI.html#needs|needs}
     */
    needs: function needs(key) {
        var transformer = this,
            source;
        do {
            if (transformer[key] && transformer[key] !== DataSourceBase.prototype[key]) {
                return;
            }
            source = transformer;
            transformer = transformer.next;
        } while (transformer);

        return source;
    },

    /**
     * @implements dataModelAPI#install
     * @see {@link https://fin-hypergrid.github.io/core/doc/dataModelAPI.html#install|install}
     */
    install: function install(api, _install) {
        var dataModel = this,
            keys = getFilteredKeys(api = api || this);

        keys.forEach(function (key) {
            if (_install) {
                var source = dataModel.needs.call(dataModel, key);
                if (source) {
                    source[key] = api[key];
                }
            }

            if (!DataSourceBase.prototype[key]) {
                DataSourceBase.prototype[key] = function () {
                    if (this.next) {
                        return this.next[key].apply(this.next, arguments);
                    }
                };
            }
        });
    },

    // SYNONYMS

    isTree: function isTree(x) {
        return this.isDrillDown(x);
    },

    getDataIndex: function getDataIndex(y) {
        return this.getRowIndex(y);
    },

    // DEBUGGING AIDS

    dump: function dump(max) {
        max = Math.min(this.getRowCount(), max || Math.max(100, this.getRowCount()));
        var data = [];
        var schema = this.getSchema();
        var fields = schema ? schema.map(function (cs) {
            return cs.name;
        }) : this.getHeaders();
        var cCount = this.getColumnCount();
        var viewMakesSense = this.viewMakesSense;
        for (var r = 0; r < max; r++) {
            var row = {};
            for (var c = 0; c < cCount; c++) {
                var val = this.getValue(c, r);
                if (c === 0 && viewMakesSense) {
                    val = this.fixIndentForTableDisplay(val);
                }
                row[fields[c]] = val;
            }
            data[r] = row;
        }
        console.table(data);
    }
};

// api can be array or object
function getFilteredKeys(api) {
    var whitelist = api.hasOwnProperty('!!keys') && api['!!keys'],
        blacklist = api.hasOwnProperty('!keys') && api['!keys'],
        keys = Array.isArray(api) ? api : Object.keys(api).filter(function (key) {
        return typeof api[key] === 'function';
    });

    return keys.filter(function (key) {
        switch (key) {
            case 'initialize':
            case 'constructor':
            case '!!keys':
            case '!keys':
                return;
        }

        return !(whitelist && whitelist.indexOf(key) < 0 || blacklist && blacklist.indexOf(key) >= 0);
    });
}

// DataSourceError

function DataSourceError(message) {
    this.message = message;
}

// extend from `Error`
DataSourceError.prototype = Object.create(Error.prototype);

// override error name displayed in console
DataSourceError.prototype.name = 'DataSourceError';

module.exports = DataSourceBase;

},{"extend-me":9}],19:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var DataSourceBase = require('../DatasaurBase');

/** @typedef {object} columnSchemaObject
 * @property {string} name - The required column name.
 * @property {string} [header] - An override for derived header
 * @property {function} [calculator] - A function for a computed column. Undefined for normal data columns.
 * @property {string} [type] - Used for sorting when and only when comparator not given.
 * @property {object} [comparator] - For sorting, both of following required:
 * @property {function} comparator.asc - ascending comparator
 * @property {function} comparator.desc - descending comparator
 */

/**
 * @param {object} [options]
 * @param {object[]} [options.data]
 * @param {object[]} [options.schema]
 * @constructor
 */
var DataSourceLocal = DataSourceBase.extend('DataSourceLocal', {

    initialize: function initialize(nextDataSource, options) {
        /**
         * @summary The array of column schema objects.
         * @name schema
         * @type {columnSchemaObject[]}
         * @memberOf DataSourceLocal#
         */
        this.schema = [];

        /**
         * @summary The array of uniform data objects.
         * @name data
         * @type {object[]}
         * @memberOf DataSourceLocal#
         */
        this.data = [];
        this.cache = [];
    },

    /**
     * Establish new data and schema.
     * If no data provided, data will be set to 0 rows.
     * If no schema provided AND no previously set schema, new schema will be derived from data.
     * @param {object[]} [data=[]] - Array of uniform objects containing the grid data.
     * @param {columnSchemaObject[]} [schema=[]]
     * @memberOf DataSourceLocal#
     */
    setData: function setData(data, schema) {
        /**
         * @summary The array of uniform data objects.
         * @name data
         * @type {object[]}
         * @memberOf DataSourceLocal#
         */
        this.data = data || [];
        this.onChange();

        if (schema) {
            this.setSchema(schema);
        } else if (this.data.length && !this.schema.length) {
            this.setSchema([]);
        }
    },

    /**
     * Add new data and schema.
     * If no data provided, data will be as is.
     * If no schema provided AND no previously set schema, new schema will be derived from data.
     * @param {object[]} [data=[]] - Array of uniform objects containing the grid data.
     * @param {columnSchemaObject[]} [schema=[]]
     * @memberOf DataSourceLocal#
     */
    addData: function addData(data, schema) {
        this.data.push.apply(this.data, data || []);
        this.onChange();

        if (schema) {
            this.setSchema(schema);
        } else if (this.data.length && !this.schema.length) {
            this.setSchema([]);
        }
    },

    /**
     * @see {@link https://fin-hypergrid.github.io/3.0.0/doc/dataModelAPI#getSchema}
     * @memberOf DataSourceLocal#
     */
    getSchema: function getSchema() {
        return this.schema;
    },
    /**
     * @see {@link https://fin-hypergrid.github.io/3.0.0/doc/dataModelAPI#setSchema}
     * @memberOf DataSourceLocal#
     */
    setSchema: function setSchema(newSchema) {
        if (!newSchema.length) {
            var dataRow = this.data.find(function (dataRow) {
                return dataRow;
            });
            if (dataRow) {
                newSchema = Object.keys(dataRow);
            }
        }

        this.schema = newSchema;
        this.dispatchEvent('data-schema-changed');
    },

    /**
     * @param y
     * @param treeLevel
     * @returns {dataRowObject}
     * @memberOf DataSourceLocal#
     */
    getRow: function getRow(y, treeLevel) {
        return this._getRowByTreeLevel(this.data[y], treeLevel);
    },

    /**
     * Update or blank row in place.
     *
     * _Note parameter order is the reverse of `addRow`._
     * @param {number} y
     * @param {object} [dataRow] - if omitted or otherwise falsy, row renders as blank
     * @memberOf DataSourceLocal#
     */
    setRow: function setRow(y, dataRow) {
        this.data[y] = dataRow || undefined;
        this.onChange();
    },

    /**
     * @see {@link https://fin-hypergrid.github.io/3.0.0/doc/dataModelAPI#getRowMetadata}
     * @memberOf DataSourceLocal#
     */
    getRowMetadata: function getRowMetadata(y, prototype) {
        var dataRow = this.data[y];
        return dataRow && (dataRow.__META || prototype !== undefined && (dataRow.__META = Object.create(prototype)));
    },

    /**
     * @see {@link https://fin-hypergrid.github.io/3.0.0/doc/dataModelAPI#setRowMetadata}
     * @memberOf DataSourceLocal#
     */
    setRowMetadata: function setRowMetadata(y, metadata) {
        var dataRow = this.data[y];
        if (dataRow) {
            if (metadata) {
                dataRow.__META = metadata;
            } else {
                delete dataRow.__META;
            }
        }
        return !!dataRow;
    },

    /**
     * Insert or append a new row.
     *
     * _Note parameter order is the reverse of `setRow`._
     * @param {object} dataRow
     * @param {number} [y=Infinity] - The index of the new row. If `y` >= row count, row is appended to end; otherwise row is inserted at `y` and row indexes of all remaining rows are incremented.
     * @memberOf DataSourceLocal#
     */
    addRow: function addRow(dataRow, y) {
        if (y === undefined || y >= this.getRowCount()) {
            this.data.push(dataRow);
        } else {
            this.data.splice(y, 0, dataRow);
        }
        this.onChange();
        this.dispatchEvent('data-shape-changed');
    },

    /**
     * Insert or append a new rows.
     *
     * _Note parameter order is the reverse of `setRow`._
     * @param {array} dataRows
     * @param {number} [y=Infinity] - The index of the new row. If `y` >= row count, row is appended to end; otherwise row is inserted at `y` and row indexes of all remaining rows are incremented.
     * @memberOf DataSourceLocal#
     */
    addRows: function addRows(dataRows, y) {
        var _data;

        if (y === undefined || y >= this.getRowCount()) {
            y = this.getRowCount();
        }
        (_data = this.data).splice.apply(_data, [y, 0].concat(_toConsumableArray(dataRows)));
        this.onChange();
        this.dispatchEvent('data-shape-changed');
    },

    /**
     * Rows are removed entirely and no longer render.
     * Indexes of all remaining rows are decreased by `rowCount`.
     * @param {number} y
     * @param {number} [rowCount=1]
     * @returns {dataRowObject[]}
     * @memberOf DataSourceLocal#
     */
    delRow: function delRow(y, rowCount) {
        var rows = this.data.splice(y, rowCount === undefined ? 1 : rowCount);
        this.onChange();
        if (rows.length) {
            this.dispatchEvent('data-shape-changed');
        }
        return rows;
    },

    /**
     * @private
     * @param x
     * @param y
     * @private
     */
    _getDataRowObject: function _getDataRowObject(x, y) {
        if (this.cache && x in this.cache && y in this.cache[x]) {
            return this.cache[x][y];
        }

        if (!(x in this.cache)) {
            this.cache[x] = [];
        }

        var row = this.data[y];

        if (!row || x > this.getColumnCount()) {
            return {};
        }

        return this.cache[x][y] = this._getDataRowObjectByRowAndColumnIndex(row, x);
    },

    indexOf: function indexOf(row) {
        var data = this.data;

        var index = data.indexOf(row);

        while (index < 0 && data.some(function (d) {
            return d;
        })) {
            data = data.map(function (d) {
                return d.$$children && d.$$children[0];
            });
            index = data.indexOf(row);
        }

        return index;
    },

    _getRowByTreeLevel: function _getRowByTreeLevel(row, treeLevel) {
        if (row && row.$$children && row.__treeLevel !== treeLevel) {
            while (row.__treeLevel !== treeLevel) {
                if (row.$$children.length === 0) {
                    // if it last level use this level
                    break;
                } else if (row.$$open) {
                    // if it open row, we need to go deeper
                    row = row.$$children[0];
                } else {
                    // if it closed row use parent row
                    break;
                }
            }
        }
        return row;
    },

    _getDataRowObjectByRowAndColumnIndex: function _getDataRowObjectByRowAndColumnIndex(row, x) {
        var columnName = this.getColumnName(x);
        var treeLevel = this.getColumnTreeLevel(x);

        row = this._getRowByTreeLevel(row, treeLevel);

        if (columnName in row) {
            return { foundedValue: row[columnName] };
        }

        // get value if key consists of joined keys
        var foundedValue = void 0,
            skipNeeded = false;
        foundedValue = row[Object.keys(row).find(function (key) {
            var combinedColumns = key.split('/');
            skipNeeded = skipNeeded || combinedColumns.includes(columnName) && combinedColumns[0] !== columnName;
            return combinedColumns[0] === columnName;
        })];

        return { foundedValue: foundedValue, skipNeeded: skipNeeded };
    },

    /**
     * @summary get count value for some cell of data grid
     * @memberOf DataSourceLocal#
     */
    getCount: function getCount(x, y) {
        var val = this._getDataRowObject(x, y).foundedValue;

        if (val !== undefined) {
            return val && val.count && val.count !== null ? val.count : undefined;
        }
    },

    getChildColumnsFromCell: function getChildColumnsFromCell(x, y) {
        var val = this._getDataRowObject(x, y).foundedValue;

        return val && val.childColumnDefs && val.childColumnDefs !== null && val.childColumnDefs !== undefined ? val.childColumnDefs : [];
    },

    getHasChildColumnsFromCell: function getHasChildColumnsFromCell(x, y) {
        var childColumnsArray = this.getChildColumnsFromCell(x, y);

        return childColumnsArray && childColumnsArray.length !== undefined ? childColumnsArray.length > 0 : false;
    },

    getIsColumnOpenByDefaultFromCell: function getIsColumnOpenByDefaultFromCell(x, y) {
        var val = this._getDataRowObject(x, y).foundedValue;

        if (val !== undefined) {
            return val && val.columnOpenByDefault && val.columnOpenByDefault !== null ? val.columnOpenByDefault : false;
        }
    },

    getIsColumnGroupShowFromCell: function getIsColumnGroupShowFromCell(x, y) {
        var val = this._getDataRowObject(x, y).foundedValue;

        var shownValues = ['always-showing', 'open'];

        if (val !== undefined) {
            if (val.columnGroupShow === undefined) {
                return true;
            }

            return val && val.columnGroupShow ? shownValues.indexOf(val.columnGroupShow) > -1 : false;
        }
    },

    getColumnGroupIdFromCell: function getColumnGroupIdFromCell(x, y) {
        var val = this._getDataRowObject(x, y).foundedValue;

        if (val !== undefined) {
            return val && val.groupId && val.groupId !== null ? val.groupId : undefined;
        }
    },

    /**
     * @see {@link https://fin-hypergrid.github.io/3.0.0/doc/dataModelAPI#getValue}
     * @memberOf DataSourceLocal#
     */
    getValue: function getValue(x, y) {
        var foundedDataRowValue = this._getDataRowObject(x, y).foundedValue;

        if (foundedDataRowValue !== undefined) {
            return foundedDataRowValue && foundedDataRowValue.value ? foundedDataRowValue.value : foundedDataRowValue;
        }
    },

    /**
     * @see {@link https://fin-hypergrid.github.io/3.0.0/doc/dataModelAPI#setValue}
     * @memberOf DataSourceLocal#
     */
    setValue: function setValue(x, y, value) {
        var foundedDataRowValue = this._getDataRowObject(x, y).foundedValue;

        if (foundedDataRowValue) {
            if ((typeof foundedDataRowValue === 'undefined' ? 'undefined' : _typeof(foundedDataRowValue)) === 'object' && !!foundedDataRowValue.value) {
                foundedDataRowValue.value = value;
            } else {
                foundedDataRowValue = value;
            }
        }
        this.data[y][this.getColumnName(x)] = foundedDataRowValue;
        this.onChange();
    },

    /**
     * @see {@link https://fin-hypergrid.github.io/3.0.0/doc/dataModelAPI#getValue}
     * @memberOf DataSourceLocal#
     */
    getDefinedCellProperties: function getDefinedCellProperties(x, y) {
        var foundedDataRowValue = this._getDataRowObject(x, y).foundedValue;

        if (foundedDataRowValue !== null && (typeof foundedDataRowValue === 'undefined' ? 'undefined' : _typeof(foundedDataRowValue)) === 'object' && !!foundedDataRowValue.properties) {
            return foundedDataRowValue.properties;
        } else {
            return {};
        }
    },

    /**
     * @public
     * @desc get colspan of an cell, if exist. Otherwise, returns 0;
     * @param x
     * @param y
     * @return {*}
     */
    getColspan: function getColspan(x, y) {
        var dataRowObject = this._getDataRowObject(x, y);
        var foundedDataRowValue = dataRowObject.foundedValue;

        if (foundedDataRowValue && (typeof foundedDataRowValue === 'undefined' ? 'undefined' : _typeof(foundedDataRowValue)) === 'object') {
            if (foundedDataRowValue.colspan) {
                return foundedDataRowValue.colspan;
            }
        } else if (dataRowObject.skipNeeded) {
            var i = x;
            while (dataRowObject.skipNeeded) {
                dataRowObject = this._getDataRowObject(--i, y);
            }
            return dataRowObject.foundedValue ? dataRowObject.foundedValue.colspan - (x - i) : 0;
        }

        return 0;
    },

    /**
     * @summary get additional width based on colspan
     * @param x
     * @param y
     * @returns {number}
     */
    getAdditionalWidth: function getAdditionalWidth(x, y) {
        var additional = 0;
        var colspan = this.getColspan(x, y);
        for (var i = x + 1; i <= x + colspan; i++) {
            additional += this.grid.getColumnWidth(i);
        }
        return additional;
    },

    /**
     * @public
     * @desc get rowspan of an cell, if exist. Otherwise, returns 0;
     * @param x
     * @param y
     * @return {*}
     */
    getRowspan: function getRowspan(x, y) {
        var foundedDataRowValue = this._getDataRowObject(x, y).foundedValue;

        if (foundedDataRowValue && (typeof foundedDataRowValue === 'undefined' ? 'undefined' : _typeof(foundedDataRowValue)) === 'object' && !!foundedDataRowValue.rowspan) {
            return foundedDataRowValue.rowspan;
        } else {
            return 0;
        }
    },

    /**
     * @summary get additional height based on colspan
     * @param x
     * @param y
     * @returns {number}
     */
    getAdditionalHeight: function getAdditionalHeight(x, y) {
        var additional = 0;
        var rowspan = this.getRowspan(x, y);
        for (var i = y + 1; i <= y + rowspan; i++) {
            additional += this.grid.getRowHeight(i);
        }
        return additional;
    },

    /**
     * @public
     * @param x
     * @param y
     * @return {*}
     */
    isColspanedByLeftColumn: function isColspanedByLeftColumn(x, y) {
        var rowValue = this._getDataRowObject(x, y);

        return !!rowValue.foundedValue && rowValue.foundedValue.isColspanedByColumn;
        // return this._getDataRowObject(x, y).skipNeeded;
    },

    /**
     * @public
     * @param x
     * @param y
     * @return {*}
     */
    getRowspanMainRow: function getRowspanMainRow(x, y) {
        var cellOnRow = this._getDataRowObject(x, y);

        return !!cellOnRow.foundedValue && cellOnRow.foundedValue.rowspanedByRow !== undefined ? cellOnRow.foundedValue.rowspanedByRow : null;
    },

    /**
     * @public
     * @param x
     * @param y
     * @return {*}
     */
    getColspanMainColumnName: function getColspanMainColumnName(x, y) {
        var cellOnRow = this._getDataRowObject(x, y);

        return !!cellOnRow.foundedValue && cellOnRow.foundedValue.colspanedByColumn ? cellOnRow.foundedValue.colspanedByColumn : null;
    },

    /**
     * @public
     * @param x
     * @param y
     * @return {*}
     */
    isRowspanedByRow: function isRowspanedByRow(x, y) {
        var cellOnRow = this._getDataRowObject(x, y);

        return !!cellOnRow.foundedValue && cellOnRow.foundedValue.isRowspanedByRow;
    },

    isRenderSkipNeeded: function isRenderSkipNeeded(x, y) {
        return this.isRowspanedByRow(x, y) || this.isColspanedByLeftColumn(x, y);
    },

    /**
     * @see {@link https://fin-hypergrid.github.io/3.0.0/doc/dataModelAPI#getRowCount}
     * @memberOf DataSourceLocal#
     */
    getRowCount: function getRowCount() {
        return this.data.length;
    },

    /**
     * @see {@link https://fin-hypergrid.github.io/3.0.0/doc/dataModelAPI#getColumnCount}
     * @memberOf DataSourceLocal#
     */
    getColumnCount: function getColumnCount() {
        return this.schema.length;
    },

    getColumnName: function getColumnName(x) {
        return (typeof x === 'undefined' ? 'undefined' : _typeof(x))[0] === 'n' && this.schema[x] ? this.schema[x].name : x;
    },

    getColumnTreeLevel: function getColumnTreeLevel(x) {
        return (typeof x === 'undefined' ? 'undefined' : _typeof(x))[0] === 'n' && this.schema[x] && this.schema[x].colDef ? this.schema[x].colDef.treeLevel : undefined;
    },

    getRowsWithValuesCount: function getRowsWithValuesCount() {
        return this.data.filter(function (d) {
            return !d.$$blank_node;
        }).length - this.grid.getFictiveHeaderRowsCount();
    },

    getColumnsWithValuesCount: function getColumnsWithValuesCount() {
        return this.grid.behavior.columns.filter(function (c) {
            return !!c.colDef;
        }).length;
    },

    /**
     * @summary tells if value is link or array contains link
     * @param value
     * @returns {boolean}
     */
    isValueUrl: function isValueUrl(value) {
        var result = false;
        if (Array.isArray(value)) {
            value.forEach(function (v) {
                if (isStringUrl(v)) {
                    result = true;
                }
            });
        } else {
            result = isStringUrl(value);
        }

        return result;
    },


    // next two methods copied from datadocs
    getHighlightRegex: function getHighlightRegex(match, searchType) {
        var words = match.split(/[ ,]+(\(.*?\))?/).filter(function (e) {
            return !!e;
        }).join('|');
        var flags = 'gi';
        var antiTagRegExp = '(?![^<>]*(([\/\"\']|]]|\b)>))';
        if (searchType === 'EXACT_MATCH') {
            return new RegExp('\\b' + words + '\\b' + antiTagRegExp, flags);
        } else if (searchType === 'EDGE') {
            return new RegExp('\\b' + words + antiTagRegExp, flags);
        } else if (searchType === 'FULL') {
            return new RegExp(words + antiTagRegExp, flags);
        }
    },
    getHighlightedValue: function getHighlightedValue(str, match, searchType) {
        if (!match || !str || searchType === 'NONE' || searchType === undefined) {
            return '';
        }

        var reg = this.getHighlightRegex(match, searchType);

        if (!reg) {
            return str;
        }

        return (str + '').replace(reg, '<mark>$&</mark>');
    },
    onChange: function onChange() {
        this.cache = [];
        this._data = this._data.filter(function (d) {
            return !d.$$blank_node;
        });
        var minimumRowCount = this.grid && this.grid.properties.minimumRowCount || 50;
        while (this._data.length < minimumRowCount) {
            this._data.push(_defineProperty({}, '$$blank_node', true));
        }
    },


    get data() {
        return this._data;
    },
    set data(data) {
        this._data = data;
        this.cache = [];
    }
});

function isStringUrl(string) {
    if (!string) {
        return false;
    }
    var URL_REGEXP = /^(\s*(http|https|ftp|ftps|itmss)\:\/\/[a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,6}(\/[^\s,;]*)?)$/g; // copy from datadoc
    return URL_REGEXP.test(string);
}

module.exports = DataSourceLocal;

},{"../DatasaurBase":18}],20:[function(require,module,exports){
'use strict';

/* eslint-disable */

/* eslint-env node, browser */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var orientationHashes = require('./orientationHashes');

/**
 *
 * @param finBar
 * @type {FinBar}
 * @constructor
 */

var FinBarTouch = function () {
    function FinBarTouch(finBar) {
        _classCallCheck(this, FinBarTouch);

        this.finBar = finBar;

        /**
         * @summary flag to detect is mouse was continuously clicked over scrollbar (not thumb)
         * @type {boolean}
         * @memberOf FinBarTouch.prototype
         */
        this.isTouchHoldOverBar = false;

        /**
         * @summary flag to detect is user touch starts over container (used to smooth scroll on mobile devices)
         * @type {boolean}
         * @memberOf FinBarTouch.prototype
         */
        this.isTouchHoldOverContainer = false;

        /**
         * @summary contains last detected position of user touch
         * @type {number|null}
         * @memberOf FinBarTouch.prototype
         */
        this.containerLastTouchPos = null;

        /**
         * @summary contains last detected user touch time (timestamp)
         * @type {number|null}
         * @memberOf FinBarTouch.prototype
         */
        this.containerLastTouchTime = null;

        /**
         * @summary contains current user touch move velocity
         * @type {number}
         * @memberOf FinBarTouch.prototype
         */
        this.containerTouchVelocity = 0;

        // /**
        //  * @summary contains current user touch move velocity limit
        //  * @description use this variable for tuning kinetic scroll speed
        //  * @type {number}
        //  * @memberOf FinBarTouch.prototype
        //  */
        // this.containerTouchVelocityMax = 20000;

        // /**
        //  * @deprecated use containerTouchVelocityModifier from hashed instead
        //  * @summary multiplier for start scroll speed calculation
        //  * @description use this variable for tuning kinetic scroll speed
        //  * @type {number}
        //  * @memberOf FinBarTouch.prototype
        //  */
        // this.containerTouchVelocityModifier = 4.2;

        /**
         * @summary contains current user touch move amplitude
         * @type {number}
         * @memberOf FinBarTouch.prototype
         */
        this.containerTouchAmplitude = 0;

        /**
         * @summary contains current smooth touch scroll interval. Used to smoothly scroll content
         * @type {number}
         * @memberOf FinBarTouch.prototype
         */
        this.containerTouchScrollInterval = 0;

        /**
         * @summary contains current user touch move offset
         * @type {number}
         * @memberOf FinBarTouch.prototype
         */
        this.containerTouchScrollOffset = null;

        /**
         * @summary contains current user touch move target. Used to detect end position of smooth scroll
         * @type {number}
         * @memberOf FinBarTouch.prototype
         */
        this.containerTouchScrollTarget = null;

        this.isLastTouchOverBar = null;

        /**
         * @summary interval which used when mouse hold scroll performed
         * @desc table will be scrolled on one full page with this interval until mouse hold ends
         * @type {number}
         * @memberOf FinBarTouch.prototype
         */
        this.mouseHoldPerformIntervalRate = 50;

        /**
         * @private
         * @summary utility field that contains mouseHold processing interval id
         * @type {number}
         * @memberOf FinBarTouch.prototype
         */
        this.mouseHoldPerformInterval = 0;

        this.mouseHoldPerformIntervalCurrentCoordsObj = null;

        /**
         * @private
         * @summary utility field that contains timeout id, which used when moseHold processing starts
         * @type {number}
         * @memberOf FinBarTouch.prototype
         */
        this.mouseHoldPerformTimeout = 0;

        /**
         * @private
         * @summary flag to detect that user clicked over thumb, and scroll need to be performed exactly to that point
         * @type {boolean}
         * @memberOf FinBarTouch.prototype
         */
        this.isThumbDragging = true;

        /**
         * @private
         * @summary flag to detect that user start touch move over thumb, and scroll need to be placed based on mouse position
         * @type {boolean}
         * @memberOf FinBarTouch.prototype
         */
        this.isThumbTouchDragging = false;

        /**
         * @readonly
         * @name paging
         * @summary Enable page up/dn clicks.
         * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
         *
         * If truthy, listen for clicks in page-up and page-down regions of scrollbar.
         *
         * If an object, call `.paging.up()` on page-up clicks and `.paging.down()` will be called on page-down clicks.
         *
         * Changing the truthiness of this value after instantiation currently has no effect.
         * @type {boolean|object}
         * @memberOf FinBarTouch.prototype
         */
        this.paging = true;
    }

    /**
     * @private
     * @summary utility method to unify logic when user stops holding mouse on empty scroll bar space
     * @return {void}
     * @memberOf FinBarTouch.prototype
     */


    _createClass(FinBarTouch, [{
        key: 'performMouseHoldOverBarEnd',
        value: function performMouseHoldOverBarEnd() {
            this.isTouchHoldOverBar = false;
            this.mouseHoldPerformIntervalCurrentCoordsObj = null;
            if (this.mouseHoldPerformInterval) {
                clearInterval(this.mouseHoldPerformInterval);
                this.mouseHoldPerformInterval = 0;
            }

            this.clearMouseHoldTimeout();
        }

        /**
         * @private
         * @summary utility method to perform clearing of an mouseHold timeout,
         * if user stops holding mouse before timeout function fork
         * @return {void}
         * @memberOf FinBarTouch.prototype
         */

    }, {
        key: 'clearMouseHoldTimeout',
        value: function clearMouseHoldTimeout() {
            if (this.mouseHoldPerformTimeout) {
                clearTimeout(this.mouseHoldPerformTimeout);
                this.mouseHoldPerformTimeout = 0;
            }
        }
    }, {
        key: '_addEvt',
        value: function _addEvt(evtName) {
            var spy = this.testPanelItem && this.testPanelItem[evtName];
            if (spy) {
                spy.classList.add('listening');
            }
            window.addEventListener(evtName, this['on' + evtName]);
        }
    }, {
        key: '_removeEvt',
        value: function _removeEvt(evtName) {
            var spy = this.testPanelItem && this.testPanelItem[evtName];
            if (spy) {
                spy.classList.remove('listening');
            }
            window.removeEventListener(evtName, this['on' + evtName]);
        }
    }, {
        key: 'shortStop',
        value: function shortStop(evt) {
            evt.stopPropagation();
        }
    }, {
        key: 'onwheel',
        value: function onwheel(evt) {
            var key = this.deltaProp;
            // swap coordinates if shift key pressed
            if (evt.shiftKey) {
                key = orientationHashes[key === orientationHashes.horizontal.delta ? 'vertical' : 'horizontal'].delta;
            }
            this.index += evt[key];
            evt.stopPropagation();
            evt.preventDefault();
        }
    }, {
        key: 'onclick',
        value: function onclick(evt) {
            this.thumb.addEventListener('transitionend', function waitForIt() {
                this.removeEventListener('transitionend', waitForIt);
                this.onmouseup(evt);
            }.bind(this));

            evt.stopPropagation();
        }
    }, {
        key: 'onmouseout',
        value: function onmouseout(evt) {
            this.performMouseHoldOverBarEnd();
        }
    }, {
        key: 'onmousedown',
        value: function onmousedown(evt) {
            var thumbBox = this.thumb.getBoundingClientRect();
            this.pinOffset = evt[this.oh.axis] - thumbBox[this.oh.leading] + this.bar.getBoundingClientRect()[this.oh.leading] + this.thumbMarginLeading;
            document.documentElement.style.cursor = 'default';

            this._addEvt('mousemove');
            this._addEvt('mouseup');

            this._performCursorDown(evt);

            evt.stopPropagation();
            evt.preventDefault();
        }
    }, {
        key: 'onbartouchstart',
        value: function onbartouchstart(evt) {
            var thumbBox = this.thumb.getBoundingClientRect();
            this.pinOffset = evt.touches[0][this.oh.coordinate] - thumbBox[this.oh.leading] + this.bar.getBoundingClientRect()[this.oh.leading] + this.thumbMarginLeading;
            document.documentElement.style.cursor = 'default';

            this._addEvt('touchend');
            this._addEvt('touchmove');

            this._performCursorDown(evt.touches[0]);
            this.isLastTouchOverBar = true;

            evt.stopPropagation();
            evt.preventDefault();
        }
    }, {
        key: '_performCursorDown',
        value: function _performCursorDown(coordsObject) {
            var _this = this;

            var thumbBox = this.thumb.getBoundingClientRect();
            var mouseOverThumb = thumbBox.left <= coordsObject.clientX && coordsObject.clientX <= thumbBox.right && thumbBox.top <= coordsObject.clientY && coordsObject.clientY <= thumbBox.bottom,
                mouseOverThumbCenter = false,
                goingUp = false,
                incrementValue = 0;

            if (!mouseOverThumb) {
                goingUp = coordsObject[this.oh.coordinate] < thumbBox[this.oh.leading];

                if (_typeof(this.paging) === 'object') {
                    this.index = this.paging[goingUp ? 'up' : 'down'](Math.round(this.index));
                } else {
                    this.index += goingUp ? -this.increment : this.increment;
                }

                this.clearMouseHoldTimeout();
                this.mouseHoldPerformTimeout = setTimeout(function () {
                    _this.isTouchHoldOverBar = true;
                    _this.isThumbDragging = false;

                    _this.mouseHoldPerformIntervalCurrentCoordsObj = coordsObject;

                    _this.mouseHoldPerformInterval = setInterval(function () {
                        var co = _this.mouseHoldPerformIntervalCurrentCoordsObj;
                        thumbBox = _this.thumb.getBoundingClientRect();
                        mouseOverThumb = thumbBox.left <= co.clientX && co.clientX <= thumbBox.right && thumbBox.top <= co.clientY && co.clientY <= thumbBox.bottom;

                        var thumbCenterLeadingSide = thumbBox[_this.oh.leading] + thumbBox[_this.oh.size] / 3;
                        var thumbCenterTrailingSide = thumbBox[_this.oh.trailing] - thumbBox[_this.oh.size] / 3;
                        mouseOverThumbCenter = mouseOverThumb && thumbCenterLeadingSide <= co[_this.oh.coordinate] && thumbCenterTrailingSide >= co[_this.oh.coordinate];

                        // goingUp value changed only if thumb not in cursor yet.
                        // Otherwise we can think, that scroll continuous and goingUp don't need to be changed
                        if (!mouseOverThumb) {
                            goingUp = co[_this.oh.coordinate] < thumbBox[_this.oh.leading];
                        }

                        incrementValue = goingUp ? -_this.increment : _this.increment;

                        if (_this.isTouchHoldOverBar && !mouseOverThumbCenter) {
                            if (goingUp && co[_this.oh.coordinate] <= thumbCenterLeadingSide && _this.index + incrementValue <= 0) {
                                _this.index = 0;
                            } else {
                                _this.index += incrementValue;
                            }
                        }

                        if (_this.isTouchHoldOverBar && mouseOverThumbCenter) {
                            _this.performMouseHoldOverBarEnd();
                        }
                    }, _this.mouseHoldPerformIntervalRate);
                }, 200);
            } else if (!this.isTouchHoldOverBar) {
                this.isThumbDragging = true;
            }
        }
    }, {
        key: 'onmousemove',
        value: function onmousemove(evt) {
            if (this.isThumbDragging) {
                var scaled = Math.min(this.thumbMax, Math.max(0, evt[this.oh.axis] - this.pinOffset));
                var idx = scaled / this.thumbMax * (this.max - this.min) + this.min;

                this._setScroll(idx, scaled);
            }

            if (this.isTouchHoldOverBar) {
                this.mouseHoldPerformIntervalCurrentCoordsObj = evt;
            }

            evt.stopPropagation();
            evt.preventDefault();
        }
    }, {
        key: 'onmouseup',
        value: function onmouseup(evt) {
            this.performMouseHoldOverBarEnd();
            this.isThumbDragging = false;

            this._removeEvt('mousemove');
            this._removeEvt('mouseup');

            document.documentElement.style.cursor = 'auto';

            evt.stopPropagation();
            evt.preventDefault();
        }
    }, {
        key: 'trackTouchScroll',
        value: function trackTouchScroll() {
            var currentTimestamp = Date.now();
            var elapsed = currentTimestamp - this.containerLastTouchTime;
            this.containerLastTouchTime = currentTimestamp;
            var delta = this.containerTouchScrollOffset - this._touchScrollFrame;
            this._touchScrollFrame = this.containerTouchScrollOffset;
            var v = 1000 * delta / (1 + elapsed);
            this.containerTouchVelocity = this.oh.containerTouchVelocityModifier * v + 0.2 * this.containerTouchVelocity;
            // correct velocity with max value
            if (this.containerTouchVelocity < -this.oh.containerTouchVelocityMax) {
                this.containerTouchVelocity = -this.oh.containerTouchVelocityMax;
            }
            if (this.containerTouchVelocity > this.oh.containerTouchVelocityMax) {
                this.containerTouchVelocity = this.oh.containerTouchVelocityMax;
            }
        }
    }, {
        key: 'ontouchstart',
        value: function ontouchstart(evt) {
            this.isTouchHoldOverContainer = true;
            this.isThumbTouchDragging = false;
            this.containerLastTouchPos = evt.touches[0][this.oh.coordinate];
            this.containerLastTouchTime = Date.now();

            this._touchScrollFrame = this.containerTouchScrollOffset;
            this.containerTouchVelocity = this.containerTouchAmplitude = 0;

            this.isLastTouchOverBar = false;
            this.containerTouchScrollOffset = this.index;
            this.containerTouchScrollInterval = setInterval(this.trackTouchScroll, 100);

            evt.preventDefault();
            evt.stopPropagation();
        }
    }, {
        key: 'getPos',
        value: function getPos(e) {
            // touch event
            if (e.targetTouches && e.targetTouches.length >= 1) {
                return e.targetTouches[0][this.oh.coordinate];
            }
            if (e.touches && e.touches.length >= 1) {
                return e.touches[0][this.oh.coordinate];
            }

            // mouse event
            return e[this.oh.coordinate];
        }
    }, {
        key: 'onthumbtouchstart',
        value: function onthumbtouchstart(evt) {
            var thumbBox = this.thumb.getBoundingClientRect();
            var currentMovePos = this.getPos(evt);
            this.pinOffset = currentMovePos - thumbBox[this.oh.leading] + this.bar.getBoundingClientRect()[this.oh.leading] + this.thumbMarginLeading;

            this.isThumbTouchDragging = true;
            this.containerLastTouchPos = null;

            this._addEvt('touchend');
            this._addEvt('touchmove');

            evt.stopPropagation();
            evt.preventDefault();
        }
    }, {
        key: 'ontouchend',
        value: function ontouchend(evt) {
            if (this.isTouchHoldOverContainer) {
                this.isTouchHoldOverContainer = false;
                clearInterval(this.containerTouchScrollInterval);
                this.trackTouchScroll();
                if (this.containerTouchVelocity > 10 || this.containerTouchVelocity < -10) {
                    this.containerTouchAmplitude = 0.8 * this.containerTouchVelocity;
                    this.containerTouchScrollTarget = Math.round(this.containerTouchScrollOffset + this.containerTouchAmplitude);
                    this.containerLastTouchTime = Date.now();
                    requestAnimationFrame(this._performTouchAutoScroll);
                }
            }

            this.isThumbTouchDragging = false;
            this.isTouchHoldOverContainer = false;
            this.containerLastTouchPos = null;

            this.performMouseHoldOverBarEnd();

            this._removeEvt('touchend');
            this._removeEvt('touchmove');

            evt.stopPropagation();
            evt.preventDefault();
        }
    }, {
        key: '_performTouchAutoScroll',
        value: function _performTouchAutoScroll() {
            if (this.containerTouchAmplitude) {
                var elapsed = Date.now() - this.containerLastTouchTime;
                var delta = -this.containerTouchAmplitude * Math.exp(-elapsed / 325);
                if (delta > 0.5 || delta < -0.5) {
                    this._performTouchScroll(this.containerTouchScrollTarget + delta);
                    requestAnimationFrame(this._performTouchAutoScroll);
                } else {
                    this._performTouchScroll(this.containerTouchScrollTarget);
                }
            }
        }
    }, {
        key: '_performTouchScroll',
        value: function _performTouchScroll(y) {
            var newOffset = y > this.max ? this.max : y < this.min ? this.min : y;
            if (newOffset !== this.containerTouchScrollOffset) {
                this.containerTouchScrollOffset = newOffset;
                this._setScroll(this.containerTouchScrollOffset);
            }
        }
    }, {
        key: 'ontouchmove',
        value: function ontouchmove(evt) {
            if (this.isThumbTouchDragging) {
                var currentMovePos = this.getPos(evt);

                var scaled = Math.min(this.thumbMax, Math.max(0, currentMovePos - this.pinOffset));
                var idx = scaled / this.thumbMax * (this.max - this.min) + this.min;

                this._setScroll(idx, scaled);
            } else if (this.isTouchHoldOverContainer) {
                var pos = this.getPos(evt);
                var delta = this.containerLastTouchPos - pos;
                delta = delta * this.oh.touchToScrollPixelsCoefficient;
                if (delta > 2 * this.oh.touchToScrollPixelsCoefficient || delta < -2 * this.oh.touchToScrollPixelsCoefficient) {
                    this.containerLastTouchPos = pos;
                    this._performTouchScroll(this.containerTouchScrollOffset + delta);
                }
            } else if (this.isLastTouchOverBar) {
                var boundsBox = this.bar.getBoundingClientRect();
                var touchOverBar = boundsBox.left <= evt.touches[0].clientX && evt.touches[0].clientX <= boundsBox.right && boundsBox.top <= evt.touches[0].clientY && evt.touches[0].clientY <= boundsBox.bottom;

                if (!touchOverBar) {
                    this.performMouseHoldOverBarEnd();
                }
            }

            if (this.mouseHoldPerformIntervalCurrentCoordsObj) {
                this.mouseHoldPerformIntervalCurrentCoordsObj = evt.touches[0];
            }

            evt.stopPropagation();
            evt.preventDefault();
        }
    }, {
        key: '_setScroll',
        value: function _setScroll(idx, scaled) {
            this.finBar._setScroll(idx, scaled);
        }
    }, {
        key: 'min',
        get: function get() {
            return this.finBar.min;
        }
    }, {
        key: 'max',
        get: function get() {
            return this.finBar.max;
        }
    }, {
        key: 'bar',
        get: function get() {
            return this.finBar.bar;
        }
    }, {
        key: 'thumb',
        get: function get() {
            return this.finBar.thumb;
        }
    }, {
        key: 'thumbMax',
        get: function get() {
            return this.finBar.thumbMax;
        }
    }, {
        key: 'oh',
        get: function get() {
            return this.finBar.oh;
        }
    }, {
        key: 'deltaProp',
        get: function get() {
            return this.finBar.deltaProp;
        }
    }, {
        key: 'thumbMarginLeading',
        get: function get() {
            return this.finBar.thumbMarginLeading;
        }
    }, {
        key: 'testPanelItem',
        get: function get() {
            return this.finBar.testPanelItem;
        }
    }, {
        key: 'index',
        set: function set(val) {
            this.finBar.index = val;
        },
        get: function get() {
            return this.finBar.index;
        }
    }, {
        key: 'increment',
        get: function get() {
            return this.finBar.increment;
        }
    }]);

    return FinBarTouch;
}();

// Interface


module.exports = FinBarTouch;

},{"./orientationHashes":22}],21:[function(require,module,exports){
'use strict';

/* eslint-disable */
/* eslint-env node, browser */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var cssInjector = require('css-injector');
var events = require('./events');
var orientationHashes = require('./orientationHashes');

/**
 * @constructor FinBar
 * @summary Create a scrollbar object.
 * @desc Creating a scrollbar is a three-step process:
 *
 * 1. Instantiate the scrollbar object by calling this constructor function. Upon instantiation, the DOM element for the scrollbar (with a single child element for the scrollbar "thumb") is created but is not insert it into the DOM.
 * 2. After instantiation, it is the caller's responsibility to insert the scrollbar, {@link FinBar#bar|this.bar}, into the DOM.
 * 3. After insertion, the caller must call {@link FinBar#resize|resize()} at least once to size and position the scrollbar and its thumb. After that, `resize()` should also be called repeatedly on resize events (as the content element is being resized).
 *
 * Suggested configurations:
 * * _**Unbound**_<br/>
 * The scrollbar serves merely as a simple range (slider) control. Omit both `options.onchange` and `options.content`.
 * * _**Bound to virtual content element**_<br/>
 * Virtual content is projected into the element using a custom event handler supplied by the programmer in `options.onchange`. A typical use case would be to handle scrolling of the virtual content. Other use cases include data transformations, graphics transformations, _etc._
 * * _**Bound to real content**_<br/>
 * Set `options.content` to the "real" content element but omit `options.onchange`. This will cause the scrollbar to use the built-in event handler (`this.scrollRealContent`) which implements smooth scrolling of the content element within the container.
 *
 * @param {finbarOptions} [options={}] - Options object. See the type definition for member details.
 */
function FinBar(options) {
    var bound = this.events = new events(this);
    Object.getOwnPropertyNames(Object.getPrototypeOf(bound)).filter(function (f) {
        return typeof bound[f] === 'function';
    }).forEach(function (f) {
        return bound[f] = bound[f].bind(bound);
    });

    /**
     * @name thumb
     * @summary The generated scrollbar thumb element.
     * @desc The thumb element's parent element is always the {@link FinBar#bar|bar} element.
     *
     * This property is typically referenced internally only. The size and position of the thumb element is maintained by `_calcThumb()`.
     * @type {Element}
     * @memberOf FinBar.prototype
     */
    var thumb = this.thumb = document.createElement('div');
    thumb.classList.add('thumb');
    thumb.onclick = bound.shortStop;
    thumb.ontouchstart = bound.onthumbtouchstart;

    /**
     * @name bar
     * @summary The generated scrollbar element.
     * @desc The caller inserts this element into the DOM (typically into the content container) and then calls its {@link FinBar#resize|resize()} method.
     *
     * Thus the node tree is typically:
     * * A **content container** element, which contains:
     *   * The content element(s)
     *   * This **scrollbar element**, which in turn contains:
     *     * The **thumb element**
     *
     * @type {Element}
     * @memberOf FinBar.prototype
     */
    var bar = this.bar = document.createElement('div');
    bar.classList.add('finbar-vertical');
    bar.onmousedown = bound.onmousedown;
    if (this.paging) {
        bar.onclick = bound.onclick;
    }
    bar.appendChild(thumb);
    bar.ontouchstart = bound.onbartouchstart;
    bar.onmouseout = bound.onmouseout;
    options = options || {};

    /**
     * @name mountDiv
     * @summary The generated scrollbar decorative element that renders behind scrollbar and can be styled.
     * @desc The caller inserts this element into the DOM (typically into the content container) and then calls its {@link FinBar#resize|resize()} method.
     * @type {Element}
     * @memberOf FinBar.prototype
     */
    var mountDiv = this.mountDiv = document.createElement('div');
    mountDiv.appendChild(bar);

    // presets
    this.orientation = 'vertical';
    this.min = this._index = 0;
    this.max = 100;

    // options
    for (var key in options) {
        if (options.hasOwnProperty(key)) {
            var option = options[key];
            switch (key) {

                case 'index':
                    this._index = option;
                    break;

                case 'range':
                    validRange(option);
                    this.min = option.min;
                    this.max = option.max;
                    this.contentSize = option.max - option.min + 1;
                    break;

                case 'onBarVisibilityChanged':
                    this.onBarVisibilityChanged = option;
                    break;

                default:
                    if (key.charAt(0) !== '_' && typeof FinBar.prototype[key] !== 'function') {
                        // override prototype defaults for standard ;
                        // extend with additional properties (for use in onchange event handlers)
                        this[key] = option;
                    }
                    break;

            }
        }
    }

    cssInjector(cssFinBars, 'finbar-base', options.cssStylesheetReferenceElement);

    if (this.onBarVisibilityChanged) {
        this.onBarVisibilityChanged(true);
    }
}

FinBar.prototype = {

    /**
     * @summary The scrollbar orientation.
     * @desc Set by the constructor to either `'vertical'` or `'horizontal'`. See the similarly named property in the {@link finbarOptions} object.
     *
     * Useful values are `'vertical'` (the default) or `'horizontal'`.
     *
     * Setting this property resets `this.oh` and `this.deltaProp` and changes the class names so as to reposition the scrollbar as per the CSS rules for the new orientation.
     * @default 'vertical'
     * @type {string}
     * @memberOf FinBar.prototype
     */
    set orientation(orientation) {
        if (orientation === this._orientation) {
            return;
        }

        this._orientation = orientation;

        /**
         * @readonly
         * @name oh
         * @summary <u>O</u>rientation <u>h</u>ash for this scrollbar.
         * @desc Set by the `orientation` setter to either the vertical or the horizontal orientation hash. The property should always be synchronized with `orientation`; do not update directly!
         *
         * This object is used internally to access scrollbars' DOM element properties in a generalized way without needing to constantly query the scrollbar orientation. For example, instead of explicitly coding `this.bar.top` for a vertical scrollbar and `this.bar.left` for a horizontal scrollbar, simply code `this.bar[this.oh.leading]` instead. See the {@link orientationHashType} definition for details.
         *
         * This object is useful externally for coding generalized {@link finbarOnChange} event handler functions that serve both horizontal and vertical scrollbars.
         * @type {orientationHashType}
         * @memberOf FinBar.prototype
         */
        this.oh = orientationHashes[this._orientation];

        if (!this.oh) {
            error('Invalid value for `options._orientation.');
        }

        /**
         * @name deltaProp
         * @summary The name of the `WheelEvent` property this scrollbar should listen to.
         * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
         *
         * Useful values are `'deltaX'`, `'deltaY'`, or `'deltaZ'`. A value of `null` means to ignore mouse wheel events entirely.
         *
         * The mouse wheel is one-dimensional and only emits events with `deltaY` data. This property is provided so that you can override the default of `'deltaX'` with a value of `'deltaY'` on your horizontal scrollbar primarily to accommodate certain "panoramic" interface designs where the mouse wheel should control horizontal rather than vertical scrolling. Just give `{ deltaProp: 'deltaY' }` in your horizontal scrollbar instantiation.
         *
         * Caveat: Note that a 2-finger drag on an Apple trackpad emits events with _both_ `deltaX ` and `deltaY` data so you might want to delay making the above adjustment until you can determine that you are getting Y data only with no X data at all (which is a sure bet you on a mouse wheel rather than a trackpad).
          * @type {object|null}
         * @memberOf FinBar.prototype
         */
        this.deltaProp = this.oh.delta;

        this.bar.className = this.bar.className.replace(/(vertical|horizontal)/g, orientation);

        if (this.bar.style.cssText || this.thumb.style.cssText) {
            this.bar.removeAttribute('style');
            this.thumb.removeAttribute('style');
            this.resize();
        }
    },
    get orientation() {
        return this._orientation;
    },

    /**
     * @summary Callback for scroll events.
     * @desc Set by the constructor via the similarly named property in the {@link finbarOptions} object. After instantiation, `this.onchange` may be updated directly.
     *
     * This event handler is called whenever the value of the scrollbar is changed through user interaction. The typical use case is when the content is scrolled. It is called with the `FinBar` object as its context and the current value of the scrollbar (its index, rounded) as the only parameter.
     *
     * Set this property to `null` to stop emitting such events.
     * @type {function(number)|null}
     * @memberOf FinBar.prototype
     */
    onchange: null,

    onBarVisibilityChanged: function onBarVisibilityChanged() {},

    /**
     * @summary Add a CSS class name to the bar element's class list.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * The bar element's class list will always include `finbar-vertical` (or `finbar-horizontal` based on the current orientation). Whenever this property is set to some value, first the old prefix+orientation is removed from the bar element's class list; then the new prefix+orientation is added to the bar element's class list. This property causes _an additional_ class name to be added to the bar element's class list. Therefore, this property will only add at most one additional class name to the list.
     *
     * To remove _classname-orientation_ from the bar element's class list, set this property to a falsy value, such as `null`.
     *
     * > NOTE: You only need to specify an additional class name when you need to have mulltiple different styles of scrollbars on the same page. If this is not a requirement, then you don't need to make a new class; you would just create some additional rules using the same selectors in the built-in stylesheet (../css/finbars.css):
     * *`div.finbar-vertical` (or `div.finbar-horizontal`) for the scrollbar
     * *`div.finbar-vertical > div` (or `div.finbar-horizontal > div`) for the "thumb."
     *
     * Of course, your rules should come after the built-ins.
     * @type {string}
     * @memberOf FinBar.prototype
     */
    set classPrefix(prefix) {
        if (this._classPrefix) {
            this.bar.classList.remove(this._classPrefix + this.orientation);
        }

        this._classPrefix = prefix;

        if (prefix) {
            this.bar.classList.add(prefix + '-' + this.orientation);
        }
    },
    get classPrefix() {
        return this._classPrefix;
    },

    /**
     * @name increment
     * @summary Number of scrollbar index units representing a pageful. Used exclusively for paging up and down and for setting thumb size relative to content size.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * Can also be given as a parameter to the {@link FinBar#resize|resize} method, which is pertinent because content area size changes affect the definition of a "pageful." However, you only need to do this if this value is being used. It not used when:
     * * you define `paging.up` and `paging.down`
     * * your scrollbar is using `scrollRealContent`
     * @type {number}
     * @memberOf FinBar.prototype
     */
    increment: 1,

    /**
     * @name barStyles
     * @summary Scrollbar styles to be applied by {@link FinBar#resize|resize()}.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * This is a value to be assigned to {@link FinBar#styles|styles} on each call to {@link FinBar#resize|resize()}. That is, a hash of values to be copied to the scrollbar element's style object on resize; or `null` for none.
     *
     * @see {@link FinBar#style|style}
     * @type {finbarStyles|null}
     * @memberOf FinBar.prototype
     */
    barStyles: null,

    /**
     * @name style
     * @summary Additional scrollbar styles.
     * @desc See type definition for more details. These styles are applied directly to the scrollbar's `bar` element.
     *
     * Values are adjusted as follows before being applied to the element:
     * 1. Included "pseudo-property" names from the scrollbar's orientation hash, {@link FinBar#oh|oh}, are translated to actual property names before being applied.
     * 2. When there are margins, percentages are translated to absolute pixel values because CSS ignores margins in its percentage calculations.
     * 3. If you give a value without a unit (a raw number), "px" unit is appended.
     *
     * General notes:
     * 1. It is always preferable to specify styles via a stylesheet. Only set this property when you need to specifically override (a) stylesheet value(s).
     * 2. Can be set directly or via calls to the {@link FinBar#resize|resize} method.
     * 3. Should only be set after the scrollbar has been inserted into the DOM.
     * 4. Before applying these new values to the element, _all_ in-line style values are reset (by removing the element's `style` attribute), exposing inherited values (from stylesheets).
     * 5. Empty object has no effect.
     * 6. Falsey value in place of object has no effect.
     *
     * > CAVEAT: Do not attempt to treat the object you assign to this property as if it were `this.bar.style`. Specifically, changing this object after assigning it will have no effect on the scrollbar. You must assign it again if you want it to have an effect.
     *
     * @see {@link FinBar#barStyles|barStyles}
     * @type {finbarStyles}
     * @memberOf FinBar.prototype
     */
    set style(styles) {
        var keys = Object.keys(styles = extend({}, styles, this._auxStyles));

        if (keys.length) {
            var bar = this.bar,
                barRect = bar.getBoundingClientRect(),
                container = bar.parentElement,
                containerRect = container.getBoundingClientRect(),
                oh = this.oh;

            // Before applying new styles, revert all styles to values inherited from stylesheets
            // bar.removeAttribute('style');

            keys.forEach(function (key) {
                var val = styles[key];
                if (key in oh) {
                    key = oh[key];
                }

                if (!isNaN(Number(val))) {
                    val = (val || 0) + 'px';
                } else if (/%$/.test(val)) {
                    // When bar size given as percentage of container, if bar has margins, restate size in pixels less margins.
                    // (If left as percentage, CSS's calculation will not exclude margins.)
                    var oriented = axis[key],
                        margins = barRect[oriented.marginLeading] + barRect[oriented.marginTrailing];
                    if (margins) {
                        val = parseInt(val, 10) / 100 * containerRect[oriented.size] - margins + 'px';
                    }
                }

                bar.style[key] = val;
            });
        }

        this.restyleMountDiv();
    },

    set thumbStyle(styles) {
        var thumb = this.thumb;
        var keys = Object.keys(styles = extend({}, styles));

        if (keys.length) {
            keys.forEach(function (key) {
                var val = styles[key];

                if (!isNaN(Number(val))) {
                    val = (val || 0) + 'px';
                }

                thumb.style[key] = val;
            });
        }

        thumb.style.opacity = '1.0';

        this._setThumbSize();
    },

    set mountStyle(styles) {
        var keys = Object.keys(styles = extend({}, styles));

        if (keys.length) {
            var mount = this.mountDiv;

            keys.forEach(function (key) {
                var val = styles[key];

                if (!isNaN(Number(val))) {
                    val = (val || 0) + 'px';
                }

                mount.style[key] = val;
            });
        }
    },

    /**
     * @readonly
     * @name paging
     * @summary Enable page up/dn clicks.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * If truthy, listen for clicks in page-up and page-down regions of scrollbar.
     *
     * If an object, call `.paging.up()` on page-up clicks and `.paging.down()` will be called on page-down clicks.
     *
     * Changing the truthiness of this value after instantiation currently has no effect.
     * @type {boolean|object}
     * @memberOf FinBar.prototype
     */
    paging: true,

    /**
     * @name range
     * @summary Setter for the minimum and maximum scroll values.
     * @desc Set by the constructor. These values are the limits for {@link FooBar#index|index}.
     *
     * The setter accepts an object with exactly two numeric properties: `.min` which must be less than `.max`. The values are extracted and the object is discarded.
     *
     * The getter returns a new object with `.min` and '.max`.
     *
     * @type {rangeType}
     * @memberOf FinBar.prototype
     */
    set range(range) {
        validRange(range);
        this.min = range.min;
        this.max = range.max;
        this.contentSize = range.max - range.min + 1;
        this.index = this.index; // re-clamp
    },
    get range() {
        return { min: this.min, max: this.max };
    },

    /**
     * @summary Index value of the scrollbar.
     * @desc This is the position of the scroll thumb.
     *
     * Setting this value clamps it to {@link FinBar#min|min}..{@link FinBar#max|max}, scroll the content, and moves thumb.
     *
     * Getting this value returns the current index. The returned value will be in the range `min`..`max`. It is intentionally not rounded.
     *
     * Use this value as an alternative to (or in addition to) using the {@link FinBar#onchange|onchange} callback function.
     *
     * @see {@link FinBar#_setScroll|_setScroll}
     * @type {number}
     * @memberOf FinBar.prototype
     */
    set index(idx) {
        idx = Math.min(this.max, Math.max(this.min, idx)); // clamp it
        this._setScroll(idx);
    },
    get index() {
        return this._index;
    },

    /**
     * @private
     * @summary Move the thumb.
     * @desc Also displays the index value in the test panel and invokes the callback.
     * @param idx - The new scroll index, a value in the range `min`..`max`.
     * @param [scaled=f(idx)] - The new thumb position in pixels and scaled relative to the containing {@link FinBar#bar|bar} element, i.e., a proportional number in the range `0`..`thumbMax`. When omitted, a function of `idx` is used.
     * @memberOf FinBar.prototype
     */
    _setScroll: function _setScroll(idx, scaled) {
        this._index = idx;

        // Display the index value in the test panel
        if (this.testPanelItem && this.testPanelItem.index instanceof Element) {
            this.testPanelItem.index.innerHTML = Math.round(idx);
        }

        // Call the callback
        if (this.onchange) {
            this.onchange.call(this, Math.round(idx));
        }

        // Move the thumb
        if (scaled === undefined) {
            scaled = (idx - this.min) / (this.max - this.min) * this.thumbMax;
        }
        this.thumb.style[this.oh.leading] = scaled + 'px';
    },

    scrollRealContent: function scrollRealContent(idx) {
        var containerRect = this.content.parentElement.getBoundingClientRect(),
            sizeProp = this.oh.size,
            maxScroll = Math.max(0, this.content[sizeProp] - containerRect[sizeProp]),
            scroll = (idx - this.min) / (this.max - this.min) * maxScroll;

        this.content.style[this.oh.leading] = -scroll + 'px';
    },

    /**
     * @summary Recalculate thumb position.
     *
     * @desc This method recalculates the thumb size and position. Call it once after inserting your scrollbar into the DOM, and repeatedly while resizing the scrollbar (which typically happens when the scrollbar's parent is resized by user.
     *
     * > This function shifts args if first arg omitted.
     *
     * @param {number} [increment=this.increment] - Resets {@link FooBar#increment|increment} (see).
     *
     * @param {barStyles} [barStyles=this.barStyles] - (See type definition for details.) Scrollbar styles to be applied to the bar element.
     * @param {contentFullWidth} [contentFullWidth=this.contentSize] - Content full width in px
     *
     * Only specify a `barStyles` object when you need to override stylesheet values. If provided, becomes the new default (`this.barStyles`), for use as a default on subsequent calls.
     *
     * It is generally the case that the scrollbar's new position is sufficiently described by the current styles. Therefore, it is unusual to need to provide a `barStyles` object on every call to `resize`.
     *
     * @returns {FinBar} Self for chaining.
     * @memberOf FinBar.prototype
     */
    resize: function resize(increment, barStyles, contentFullWidth) {
        if (contentFullWidth !== undefined) {
            this.contentSize = contentFullWidth;
        }

        var bar = this.bar;

        if (!bar.parentNode) {
            return; // not in DOM yet so nothing to do
        }

        var container = this.mountDiv.parentElement,
            containerRect = container.getBoundingClientRect();

        // shift args if if 1st arg omitted
        if ((typeof increment === 'undefined' ? 'undefined' : _typeof(increment)) === 'object') {
            barStyles = increment;
        }

        this.style = this.barStyles = barStyles || this.barStyles;

        // Bound to real content: Content was given but no onchange handler.
        // Set up .onchange, .containerSize, and .increment.
        // Note this only makes sense if your index unit is pixels.
        if (this.content) {
            if (!this.onchange) {
                this.onchange = this.scrollRealContent;
                this.contentSize = this.content[this.oh.size];
                this.min = 0;
                this.max = this.contentSize - 1;
            }
        }

        this.containerSize = containerRect[this.oh.size];
        this.increment = this.containerSize / 3;

        var index = this.index;
        this.testPanelItem = this.testPanelItem || this._addTestPanelItem();
        this._setThumbSize();
        this.index = index;
        this.restyleMountDiv();

        if (this.deltaProp !== null) {
            container.addEventListener('wheel', this.events.onwheel);
            container.addEventListener('touchstart', this.events.ontouchstart);
            container.addEventListener('touchmove', this.events.ontouchmove);
            container.addEventListener('touchend', this.events.ontouchend);
        }

        return this;
    },

    restyleMountDiv: function restyleMountDiv() {
        var computedStyles = window.getComputedStyle(this.bar);

        if (this.orientation === 'horizontal') {
            this.mountDiv.style.height = computedStyles.height;
            this.mountDiv.style.width = '100%';
            this.mountDiv.style.bottom = '0';
        } else {
            this.mountDiv.style.height = '100%';
            this.mountDiv.style.width = computedStyles.width;
            this.mountDiv.style.right = '0';
        }
    },

    /**
     * @summary Shorten trailing end of scrollbar by thickness of some other scrollbar.
     * @desc In the "classical" scenario where vertical scroll bar is on the right and horizontal scrollbar is on the bottom, you want to shorten the "trailing end" (bottom and right ends, respectively) of at least one of them so they don't overlay.
     *
     * This convenience function is an programmatic alternative to hardcoding the correct style with the correct value in your stylesheet; or setting the correct style with the correct value in the {@link FinBar#barStyles|barStyles} object.
     *
     * @see {@link FinBar#foreshortenBy|foreshortenBy}.
     *
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    shortenBy: function shortenBy(otherFinBar) {
        return this.shortenEndBy('trailing', otherFinBar);
    },

    /**
     * @summary Shorten leading end of scrollbar by thickness of some other scrollbar.
     * @desc Supports non-classical scrollbar scenarios where vertical scroll bar may be on left and horizontal scrollbar may be on top, in which case you want to shorten the "leading end" rather than the trailing end.
     * @see {@link FinBar#shortenBy|shortenBy}.
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    foreshortenBy: function foreshortenBy(otherFinBar) {
        return this.shortenEndBy('leading', otherFinBar);
    },

    /**
     * @summary Generalized shortening function.
     * @see {@link FinBar#shortenBy|shortenBy}.
     * @see {@link FinBar#foreshortenBy|foreshortenBy}.
     * @param {string} whichEnd - a CSS style property name or an orientation hash name that translates to a CSS style property name.
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    shortenEndBy: function shortenEndBy(whichEnd, otherFinBar) {
        if (!otherFinBar) {
            delete this._auxStyles;
        } else if (otherFinBar instanceof FinBar && otherFinBar.orientation !== this.orientation) {
            var otherStyle = window.getComputedStyle(otherFinBar.bar),
                ooh = orientationHashes[otherFinBar.orientation];
            this._auxStyles = {};
            this._auxStyles[whichEnd] = otherStyle[ooh.thickness] - 1;
        }
        return this; // for chaining
    },

    shortenEndByValue: function shortenEndByValue(whichEnd, shortenValue) {
        this._auxStyles = this._auxStyles ? this._auxStyles : {};
        this._auxStyles[whichEnd] = shortenValue + 'px';
        return this;
    },

    /**
     * @private
     * @summary Sets the proportional thumb size and hides thumb when 100%.
     * @desc The thumb size has an absolute minimum of 20 (pixels).
     * @memberOf FinBar.prototype
     */
    _setThumbSize: function _setThumbSize() {
        var oh = this.oh,
            thumbComp = window.getComputedStyle(this.thumb),
            thumbMarginLeading = parseInt(thumbComp[oh.marginLeading]),
            thumbMarginTrailing = parseInt(thumbComp[oh.marginTrailing]),
            thumbMargins = thumbMarginLeading + thumbMarginTrailing,
            barSize = this.bar.getBoundingClientRect()[oh.size] - thumbMargins,
            thumbSize = Math.max(20, barSize * this.containerSize / this.contentSize);

        var oldVisibility = this.mountDiv.style.visibility;
        if (this.containerSize < this.contentSize) {
            this.mountDiv.style.visibility = 'visible';
            this.thumb.style[oh.size] = thumbSize + 'px';
        } else {
            this.mountDiv.style.visibility = 'hidden';
        }

        if (oldVisibility !== this.mountDiv.style.visibility && this.onBarVisibilityChanged) {
            this.onBarVisibilityChanged(this.mountDiv.style.visibility === 'visible');
        }

        /**
         * @private
         * @name thumbMax
         * @summary Maximum offset of thumb's leading edge.
         * @desc This is the pixel offset within the scrollbar of the thumb when it is at its maximum position at the extreme end of its range.
         *
         * This value takes into account the newly calculated size of the thumb element (including its margins) and the inner size of the scrollbar (the thumb's containing element, including _its_ margins).
         *
         * NOTE: Scrollbar padding is not taken into account and assumed to be 0 in the current implementation and is assumed to be `0`; use thumb margins in place of scrollbar padding.
         * @type {number}
         * @memberOf FinBar.prototype
         */
        this.thumbMax = barSize - thumbSize - thumbMargins;

        this.thumbMarginLeading = thumbMarginLeading; // used in mousedown
    },

    /**
     * @summary Remove the scrollbar.
     * @desc Unhooks all the event handlers and then removes the element from the DOM. Always call this method prior to disposing of the scrollbar object.
     * @memberOf FinBar.prototype
     */
    remove: function remove() {
        this.bar.onmousedown = null;
        this._removeEvt('mousemove');
        this._removeEvt('mouseup');

        var container = this.mountDiv.parentElement;
        if (container._removeEvt) {
            container._removeEvt('wheel', this.events.onwheel);
        }

        this.bar.onclick = this.thumb.onclick = this.thumb.transitionend = this.thumb.onmouseout = null;

        this.bar.remove();
    },

    /**
     * @private
     * @function _addTestPanelItem
     * @summary Append a test panel element.
     * @desc If there is a test panel in the DOM (typically an `<ol>...</ol>` element) with class names of both `this.classPrefix` and `'test-panel'` (or, barring that, any element with class name `'test-panel'`), an `<li>...</li>` element will be created and appended to it. This new element will contain a span for each class name given.
     *
     * You should define a CSS selector `.listening` for these spans. This class will be added to the spans to alter their appearance when a listener is added with that class name (prefixed with 'on').
     *
     * (This is an internal function that is called once by the constructor on every instantiation.)
     * @returns {Element|undefined} The appended `<li>...</li>` element or `undefined` if there is no test panel.
     * @memberOf FinBar.prototype
     */
    _addTestPanelItem: function _addTestPanelItem() {
        var testPanelItem = void 0,
            testPanelElement = document.querySelector('.' + this._classPrefix + '.test-panel') || document.querySelector('.test-panel');

        if (testPanelElement) {
            var testPanelItemPartNames = ['mousedown', 'mousemove', 'mouseup', 'index'],
                item = document.createElement('li');

            testPanelItemPartNames.forEach(function (partName) {
                item.innerHTML += '<span class="' + partName + '">' + partName.replace('mouse', '') + '</span>';
            });

            testPanelElement.appendChild(item);

            testPanelItem = {};
            testPanelItemPartNames.forEach(function (partName) {
                testPanelItem[partName] = item.getElementsByClassName(partName)[0];
            });
        }

        return testPanelItem;
    },

    _removeEvt: function _removeEvt(evtName) {
        this.events._removeEvt(evtName);
    }
};

function extend(obj) {
    for (var i = 1; i < arguments.length; ++i) {
        var objn = arguments[i];
        if (objn) {
            for (var key in objn) {
                obj[key] = objn[key];
            }
        }
    }
    return obj;
}

function validRange(range) {
    var keys = Object.keys(range),
        valid = keys.length === 2 && typeof range.min === 'number' && typeof range.max === 'number' && range.min <= range.max;

    if (!valid) {
        error('Invalid .range object.');
    }
}

var axis = {
    top: 'vertical',
    bottom: 'vertical',
    height: 'vertical',
    left: 'horizontal',
    right: 'horizontal',
    width: 'horizontal'
};

var cssFinBars = void 0; // definition inserted by gulpfile between following comments
/* inject:css */
cssFinBars = 'div.finbar-horizontal,div.finbar-vertical{position:absolute;margin:3px}div.finbar-horizontal>.thumb,div.finbar-vertical>.thumb{position:absolute;background-color:#d3d3d3;-webkit-box-shadow:0 0 1px #000;-moz-box-shadow:0 0 1px #000;box-shadow:0 0 1px #000;border-radius:4px;margin:2px;opacity:.4;transition:opacity .5s}div.finbar-horizontal>.thumb.hover,div.finbar-vertical>.thumb.hover{opacity:1;transition:opacity .5s}div.finbar-vertical{top:0;bottom:0;right:0;width:11px}div.finbar-vertical>.thumb{top:0;right:0;width:7px}div.finbar-horizontal{left:0;right:0;bottom:0;height:11px}div.finbar-horizontal>.thumb{left:0;bottom:0;height:7px}';

/* endinject */

function error(msg) {
    throw 'finbars: ' + msg;
}

// Interface
module.exports = FinBar;

},{"./events":20,"./orientationHashes":22,"css-injector":5}],22:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

module.exports = {
    vertical: {
        coordinate: 'clientY',
        axis: 'pageY',
        size: 'height',
        outside: 'right',
        inside: 'left',
        leading: 'top',
        trailing: 'bottom',
        marginLeading: 'marginTop',
        marginTrailing: 'marginBottom',
        thickness: 'width',
        delta: 'deltaY',
        // gridOffsetProperty: 'canvasWidthOffset',
        containerTouchVelocityModifier: 4.2,
        containerTouchVelocityMax: 20000,
        touchToScrollPixelsCoefficient: 1
    },
    horizontal: {
        coordinate: 'clientX',
        axis: 'pageX',
        size: 'width',
        outside: 'bottom',
        inside: 'top',
        leading: 'left',
        trailing: 'right',
        marginLeading: 'marginLeft',
        marginTrailing: 'marginRight',
        thickness: 'height',
        delta: 'deltaX',
        // gridOffsetProperty: 'canvasHeightOffset'
        containerTouchVelocityModifier: 2,
        containerTouchVelocityMax: 20000,
        touchToScrollPixelsCoefficient: 2.4
    }
};

},{}],23:[function(require,module,exports){
'use strict';
/* eslint-env browser */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var equal = require('deep-equal');

// helper methods

function range(start, stop) {
    var result = [];
    for (var idx = start.charCodeAt(0), end = stop.charCodeAt(0); idx <= end; ++idx) {
        result.push(String.fromCharCode(idx));
    }
    return result;
}

var az = range('A', 'Z');

function idOf(i) {
    return (i >= 26 ? idOf(az, (i / 26 >> 0) - 1) : '') + az[i % 26 >> 0];
}

function getFormatter(colDef) {
    var formatterMapper = function formatterMapper(f) {
        var formatter = f;
        if (formatter && typeof formatter !== 'string') {
            var update = formatter.prototype.update ? formatter.prototype.update : formatter;
            formatter = function formatter(value) {
                return update({ colDef: colDef, value: value, column: colDef });
            };
        }
        return formatter;
    };

    var dataFormatter = formatterMapper(colDef && colDef.cellRenderer);
    var headerFormatter = formatterMapper(colDef && colDef.headerCellRenderer);

    var checker = function checker(func) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
        }

        return func && typeof func === 'function' ? func.apply(undefined, args) : args[0];
    };

    return function (value, isHeader) {
        if ((typeof isHeader === 'undefined' ? 'undefined' : _typeof(isHeader)) === 'object') {
            isHeader = isHeader.rowProperties ? isHeader.rowProperties.headerRow : isHeader.headerRow;
        }
        if (typeof isHeader !== 'boolean') {
            isHeader = false;
        }
        return checker(isHeader ? headerFormatter : dataFormatter, value);
    };
}

function convertColDefs(colDefs) {
    var schema = [];

    var headersFont = this.properties.columnHeaderFontBold;
    var maximumColumnWidth = this.properties.maximumColumnWidth;

    var getContextMenuItems = this.getContextMenuItems;

    var showAdditionalInfo = this.properties.showAdditionalInfo;

    var self = this;

    var data = [];

    var az = range('A', 'Z');

    var schemaColumnsCount = 0;
    var maxTreeLevel = 0;

    function countMaxTreeLevel(prevLevel, colDefsToDetect) {
        var isTopGroupCollapsed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        var currentLevel = prevLevel + 1;
        var hasVisibleColumns = false;

        colDefsToDetect.forEach(function (cd) {
            var isAlwaysDisplayedColDef = cd.collapsedHeaderName || cd.isTotal;

            var isColDefVisible = !isTopGroupCollapsed || isAlwaysDisplayedColDef;
            if (isColDefVisible) {
                hasVisibleColumns = true;
                var groupCollapsed = cd.columnGroupShow !== undefined && cd.columnGroupShow !== 'open' && cd.columnGroupShow !== 'always-showing';

                if (cd.children && cd.children.length > 0) {
                    countMaxTreeLevel(currentLevel, cd.children, groupCollapsed);
                }
            }
        });

        if (currentLevel > maxTreeLevel && hasVisibleColumns) {
            maxTreeLevel = currentLevel;
        }
    }

    function getEmptyHeaderRow() {
        return {
            __META: {
                __ROW: {
                    headerRow: true, // used for preventing duplicates
                    font: headersFont, // set bold font for title row
                    foregroundSelectionFont: headersFont, // set bold font for title row
                    editable: true, // allow edit content
                    cellContextMenu: self.getMainMenuItems ? self.getMainMenuItems : self.properties.headerContextMenu, // set context menu items with callbacks
                    halign: 'left',
                    showCellContextMenuIcon: showAdditionalInfo,
                    showColumnType: showAdditionalInfo
                }
            }
        };
    }

    countMaxTreeLevel(0, colDefs);

    function colDefMapper(singleColDef) {
        var headerLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var topGroupCollapsed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var topGroupsIds = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

        var letter = idOf(schemaColumnsCount);

        var schemaMapper = function schemaMapper(header, name) {
            return {
                header: header,
                name: name,
                topGroupsIds: topGroupsIds,
                width: singleColDef.width,
                halign: singleColDef.halign,
                colTypeSign: singleColDef.colTypeSign,
                formatter: getFormatter(singleColDef) || undefined,
                format: name,
                headerPrefix: singleColDef.headerPrefix,
                cellContextMenu: getContextMenuItems,
                colDef: singleColDef
            };
        };

        if (singleColDef) {
            if (topGroupCollapsed && !singleColDef.collapsedHeaderName && !singleColDef.isTotal) {
                return [];
            }

            if (!!singleColDef.children && singleColDef.children.length > 0) {
                var insertedColumnNames = [];
                var groupCollapsed = singleColDef.columnGroupShow && singleColDef.columnGroupShow !== 'open' && singleColDef.columnGroupShow !== 'always-showing';
                singleColDef.children.forEach(function (ch) {
                    var newTopGroupsArray = [].concat(_toConsumableArray(topGroupsIds), [singleColDef.groupId]);
                    insertedColumnNames = [].concat(_toConsumableArray(insertedColumnNames), _toConsumableArray(colDefMapper(ch, headerLevel + 1, groupCollapsed, newTopGroupsArray)));
                });

                if (insertedColumnNames.length === 0) {
                    var originalField = singleColDef.columnName + '_$$cluster_size';
                    var _name = originalField || letter;

                    topGroupsIds = [].concat(_toConsumableArray(topGroupsIds), [singleColDef.groupId]);
                    schema.push(schemaMapper(letter || '', _name));
                    schemaColumnsCount++;

                    if (originalField) {
                        if (!data[headerLevel]) {
                            data[headerLevel] = getEmptyHeaderRow();
                        }
                        var rowspan = maxTreeLevel - headerLevel - 1;
                        var columnName = topGroupCollapsed && singleColDef.collapsedHeaderName && singleColDef.collapsedHeaderName.length ? singleColDef.collapsedHeaderName : singleColDef.headerName || '';
                        data[headerLevel][originalField] = {
                            rowspan: 0,
                            value: columnName,
                            count: singleColDef.count,
                            childColumnDefs: singleColDef.children,
                            groupId: singleColDef.groupId,
                            columnOpenByDefault: singleColDef.openByDefault,
                            columnGroupShow: singleColDef.columnGroupShow
                        };

                        if (rowspan > 0) {
                            rowspan--;
                            data[headerLevel + 1][originalField] = {
                                rowspan: rowspan,
                                value: 'Count',
                                count: singleColDef.count
                            };
                        }

                        if (rowspan > 0) {
                            for (var i = headerLevel + 2; i < maxTreeLevel; i++) {
                                if (!data[i]) {
                                    data[i] = getEmptyHeaderRow();
                                }
                                data[i][originalField] = {
                                    rowspan: rowspan - i,
                                    isRowspanedByRow: true,
                                    rowspanedByRow: headerLevel,
                                    count: singleColDef.count
                                };
                            }
                        }
                    }

                    return [_name];
                } else {
                    if (!data[headerLevel]) {
                        data[headerLevel] = getEmptyHeaderRow();
                    }

                    var colspan = insertedColumnNames.length - 1;

                    var _columnName = topGroupCollapsed && singleColDef.collapsedHeaderName && singleColDef.collapsedHeaderName.length ? singleColDef.collapsedHeaderName : singleColDef.headerName || '';

                    data[headerLevel][insertedColumnNames[0]] = {
                        colspan: colspan,
                        value: _columnName,
                        properties: {
                            ignoreValuePrefix: false
                        },
                        count: singleColDef.count,
                        childColumnDefs: singleColDef.children,
                        groupId: singleColDef.groupId,
                        columnOpenByDefault: singleColDef.openByDefault,
                        columnGroupShow: singleColDef.columnGroupShow
                    };

                    for (var _i = 1; _i < insertedColumnNames.length; _i++) {
                        data[headerLevel][insertedColumnNames[_i]] = {
                            colspan: colspan - _i,
                            isColspanedByColumn: true,
                            colspanedByColumn: insertedColumnNames[0],
                            count: singleColDef.count,
                            childColumnDefs: singleColDef.children,
                            groupId: singleColDef.groupId,
                            columnOpenByDefault: singleColDef.openByDefault,
                            columnGroupShow: singleColDef.columnGroupShow
                        };
                    }

                    return insertedColumnNames;
                }
            } else {
                var _originalField = singleColDef.field;
                var _name2 = _originalField || letter;

                schema.push(schemaMapper(letter || '', _name2));
                schemaColumnsCount++;

                if (_originalField) {
                    if (!data[headerLevel]) {
                        data[headerLevel] = getEmptyHeaderRow();
                    }
                    var _rowspan = maxTreeLevel - headerLevel - 1;
                    var _columnName2 = topGroupCollapsed && singleColDef.collapsedHeaderName && singleColDef.collapsedHeaderName.length ? singleColDef.collapsedHeaderName : singleColDef.headerName || '';
                    data[headerLevel][_originalField] = {
                        rowspan: _rowspan,
                        value: _columnName2,
                        count: singleColDef.count
                    };
                    for (var _i2 = headerLevel + 1, it = 1; _i2 < maxTreeLevel; _i2++, it++) {
                        if (!data[_i2]) {
                            data[_i2] = getEmptyHeaderRow();
                        }
                        data[_i2][_originalField] = {
                            rowspan: _rowspan - _i2,
                            isRowspanedByRow: true,
                            rowspanedByRow: headerLevel,
                            count: singleColDef.count
                        };
                    }
                }
                return [_name2];
            }
        } else {
            schema.push({
                header: letter || '',
                name: letter,
                maxWidth: maximumColumnWidth,
                format: name,
                cellContextMenu: getContextMenuItems
            });
            schemaColumnsCount++;
            return [letter];
        }
    }
    colDefs.forEach(function (singleColDef) {
        return colDefMapper(singleColDef);
    });

    if (schemaColumnsCount < az.length) {
        for (var i = schemaColumnsCount; i < az.length; ++i) {
            colDefMapper();
        }
    }

    return { schema: schema, data: data, fictiveHeaderRowsCount: maxTreeLevel };
}

// function getOpenLinkFunc(link) {
//     return function() {
//         window.open(link, '_blank');
//     };
// }

// api methods

var rowModel = {
    virtualPageCache: {
        updateHeightForAllRows: function updateHeightForAllRows() {}
    },
    setExpanded: function setExpanded(id, expanded) {}
};

var rangeController = {
    allRowsSelected: false,
    selectedCols: [],
    refreshBorders: function refreshBorders() {},
    selectAll: function selectAll() {}
};

var gridPanel = {
    resetVerticalScrollPosition: function resetVerticalScrollPosition() {
        this.log('resetVerticalScrollPosition');
        this.vScrollValue = 0;
    },
    setVerticalScrollPosition: function setVerticalScrollPosition(value) {
        this.log('setVerticalScrollPosition');
        this.vScrollValue = value;
    },
    getVerticalScrollPosition: function getVerticalScrollPosition() {
        this.log('getVerticalScrollPosition');
        return this.vScrollValue;
    },
    resetHorizontalScrollPosition: function resetHorizontalScrollPosition() {
        this.log('resetHorizontalScrollPosition');
        this.hScrollValue = 0;
    },
    setHorizontalScrollPosition: function setHorizontalScrollPosition(value) {
        this.log('setHorizontalScrollPosition');
        this.hScrollValue = value;
    },
    getHorizontalScrollPosition: function getHorizontalScrollPosition() {
        this.log('getHorizontalScrollPosition');
        return this.hScrollValue;
    }
};

var columnController = {
    getAllGridColumns: function getAllGridColumns() {
        this.log('getAllGridColumns');
        return this.getActiveColumns();
    },
    updateDisplayedColumns: function updateDisplayedColumns() {
        this.log('updateDisplayedColumns');
    }
};

var floatingRowModel = {
    floatingTopRows: [],
    flattenStage: {
        execute: function execute(rootNode) {
            this.log(rootNode);
        }
    },
    setExpanded: function setExpanded(id, expanded) {
        this.log(id, expanded);
    }
};

var virtualPageRowModel = {
    virtualPageCache: {
        updateAllRowTopFromIndexes: function updateAllRowTopFromIndexes() {
            this.log('updateAllRowTopFromIndexes');
        }
    },
    getRow: function getRow(rowIndex, dontCreatePage) {
        this.log('getRow', rowIndex, dontCreatePage);
    }
};

function getVisibleColDefs(colDefs) {
    var res = colDefs.filter(function (cd) {
        return !cd.isHidden;
    });

    res.filter(function (cd) {
        return cd.children;
    }).forEach(function (cd) {
        cd.children = getVisibleColDefs(cd.children);
    });

    return res;
}

function setColumnDefs(colDefs) {
    var _this = this;

    this.log('setColumnDefs', colDefs);

    this.columnDefs = colDefs;
    this.visibleColumnDefs = getVisibleColDefs(this.columnDefs);

    var schema = convertColDefs.call(this, this.visibleColumnDefs);
    this.log('schema', schema);
    var firstRowsData = schema.data;
    var data = this.behavior.getData();

    if (this.getMainMenuItems) {
        this.behavior.grid.properties.headerContextMenu = this.getMainMenuItems;
    }

    // create first row from headers
    if (this.behavior.grid.properties.useHeaders) {
        if (!data || data.length === 0) {
            data = [].concat(_toConsumableArray(firstRowsData));
        } else {
            if (schema.fictiveHeaderRowsCount < this.behavior.grid.properties.fictiveHeaderRowsCount) {
                var diff = this.behavior.grid.properties.fictiveHeaderRowsCount - schema.fictiveHeaderRowsCount;
                data.splice(schema.fictiveHeaderRowsCount - 1, diff);
            }
            this.behavior.grid.properties.fictiveHeaderRowsCount = schema.fictiveHeaderRowsCount;
            firstRowsData.forEach(function (d, i) {
                if (!equal(data[0], d)) {
                    if (_this.behavior.getRowProperties(i).headerRow) {
                        data[i] = d;
                    } else {
                        data.splice(i, 0, d);
                    }
                }
            });
        }
        this.api.needColumnsToFit = true;
    }

    this.log('schema.schema', schema.schema);

    this.behavior.setData({
        data: data,
        schema: schema.schema
    });
    this.allowEvents(true);
    this.behavior.dataModel.setSchema(schema.schema);
    this.clearSelections();
}

function setRowData(rowData) {
    this.log('setRowData', rowData);

    // todo remove this in future
    if (rowData.length === 1000 && this.behavior.grid.properties.useHeaders) {
        rowData.pop();
    }

    this.data = rowData;

    this.setData({ data: rowData });
    this.behavior.buildFlatMode();

    if (this.columnDefs) {
        this.api.setColumnDefs(this.columnDefs);
    }
}

function sizeColumnsToFit() {
    this.log('sizeColumnsToFit');

    if (this.api.needColumnsToFit) {
        this.behavior.fitColumns();
        this.canvas.resize(false);
        this.addEventListener('fin-grid-rendered', function () {
            if (this.api.needColumnsToFit) {
                this.canvas.resizeNotification();
                this.api.needColumnsToFit = false;
            }
        }.bind(this));
    }
}

function destroy(total) {
    this.log('destroy', total);

    this.setHighlightText('');

    this.cancelEditing();

    this.sbPrevVScrollValue = null;
    this.sbPrevHScrollValue = null;
    this.hoverCell = null;
    this.scrollingNow = false;

    this.behavior.reset();
    this.selectionModel.reset();
    this.renderer.reset();

    this.api.rangeController.selectedCols = [];

    if (total || !this.isAlive()) {
        this.destroyScrollbars();
    } else {
        this.canvas.resize();
        this.behaviorChanged();
        this.refreshProperties();
        if (this.div) {
            this.initialize(this.div);
            this.canvas.start();
        }
    }

    this.behavior.grid.fireSyntheticApiDestroyCalled(total);
}

function getRangeSelections() {
    this.log('getRangeSelections');
    return this.getSelections();
}

function copySelectedRangeToClipboard(includeHeaders) {
    this.log('copySelectedRangeToClipboard', includeHeaders);
    this.copyIncludeHeaders = includeHeaders;
    document.execCommand('copy');
    delete this.copyIncludeHeaders;
}

function getSelectedColumns() {
    this.log('getSelectedColumns');
    return this.api.rangeController.selectedCols;
}

function getModel() {
    this.log('getModel');
    return {
        rowsToDisplay: [],
        getRow: function getRow() {
            this.log('getRow');
        }
    };
}

function applyProperties(newProps) {
    Object.assign(this.properties, newProps);
    this.repaint();
}

function refreshView() {
    this.log('refreshView');
    this.repaint();
}

function removeItems(rowNodes) {
    this.log('removeItems', rowNodes);
}

function insertItemsAtIndex(index, items) {
    this.log('insertItemsAtIndex', index, items);
}

function clearRangeSelection() {
    this.log('clearRangeSelection');
    this.clearSelections();
    this.repaint();
}

function clearFocusedCell() {
    this.log('clearFocusedCell');
    this.clearMostRecentSelection();
    this.repaint();
}

function getFloatingTopRowData() {
    this.log('getFloatingTopRowData');
}

function getFloatingTopRowCount() {
    this.log('getFloatingTopRowCount');
}

function showNoRowsOverlay() {
    this.log('showNoRowsOverlay');
}

function hideOverlay() {
    this.log('hideOverlay');
}

function refreshCells(rowNodes, colIds, animate) {
    this.log('refreshCells', rowNodes, colIds, animate);
}

function setDatasource(datasource) {
    var _this2 = this;

    this.log('setDatasource', datasource);
    this.api.datasource = datasource;

    this.setHighlightText(datasource.search || '');

    var startRow = this.data.length || 0;

    if (startRow < datasource.totalSize || startRow === 0) {
        var params = {
            startRow: startRow, // replace with correct getter
            endRow: startRow + this.paginationPageSize, // replace with correct getter
            successCallback: function successCallback(rows, lastRowIndex) {
                _this2.log('successCallback', rows, lastRowIndex);

                // todo remove this in future
                if (startRow === 0 && rows.length === 1000) {
                    rows.pop();
                }

                [].push.apply(_this2.data, rows);
                _this2.addData({ data: rows });
                _this2.behavior.buildFlatMode();
            },
            failCallback: function failCallback() {
                this.log('failCallback');
                this.addData({ data: [] });
            },
            sortModel: datasource.sortModel,
            filterModel: {},
            context: undefined
        };

        datasource.getRows(params);
    }
}

function onGroupExpandedOrCollapsed(refreshFromIndex) {
    this.log('onGroupExpandedOrCollapsed', refreshFromIndex);
}

function getSortModel() {
    this.log('getSortModel');
    return [];
}

function doLayout() {
    // this.log('doLayout');
}

function refreshInMemoryRowModel() {
    this.log('refreshInMemoryRowModel');
}

function attachLinkToDataCell(x, y, link) {
    this.behavior.setCellProperty(x, y, 'link', link);
}

function registerCellEditedEventListener(callback) {
    this.addInternalEventListener('fin-after-cell-edit', callback);
}

module.exports = {
    // fields
    rowModel: rowModel,
    rangeController: rangeController,
    gridPanel: gridPanel,
    columnController: columnController,
    floatingRowModel: floatingRowModel,
    virtualPageRowModel: virtualPageRowModel,

    // functions
    setColumnDefs: setColumnDefs,
    setRowData: setRowData,
    sizeColumnsToFit: sizeColumnsToFit,
    destroy: destroy,
    getRangeSelections: getRangeSelections,
    copySelectedRangeToClipboard: copySelectedRangeToClipboard,
    getSelectedColumns: getSelectedColumns,
    getModel: getModel,
    refreshView: refreshView,
    removeItems: removeItems,
    insertItemsAtIndex: insertItemsAtIndex,
    clearRangeSelection: clearRangeSelection,
    clearFocusedCell: clearFocusedCell,
    getFloatingTopRowData: getFloatingTopRowData,
    getFloatingTopRowCount: getFloatingTopRowCount,
    showNoRowsOverlay: showNoRowsOverlay,
    hideOverlay: hideOverlay,
    refreshCells: refreshCells,
    setDatasource: setDatasource,
    onGroupExpandedOrCollapsed: onGroupExpandedOrCollapsed,
    getSortModel: getSortModel,
    doLayout: doLayout,
    refreshInMemoryRowModel: refreshInMemoryRowModel,
    attachLinkToDataCell: attachLinkToDataCell,
    registerCellEditedEventListener: registerCellEditedEventListener,
    applyProperties: applyProperties
};

},{"deep-equal":6}],24:[function(require,module,exports){
'use strict';

function getAllGridColumns() {
    this.log('getAllGridColumns');
    return this.getActiveColumns();
}

function setColumnVisible(key, visible) {
    this.log('setColumnVisible', key, visible);

    setColumnsVisible.call(this, [key], visible);
}

function setColumnsVisible(keys, visible) {
    var _this = this;

    this.log('setColumnsVisible', keys, visible);
    var colDef = this.columnDefs;
    var columnsStateChanged = false;
    keys.forEach(function (key) {
        _this.getColDefs(key).forEach(function (cd) {
            cd.isHidden = !visible;
            columnsStateChanged = true;
        });
    });

    if (columnsStateChanged) {
        this.api.setColumnDefs(colDef);
        this.api.needColumnsToFit = true;
    }
}

function changePinnedRange(countToPin) {
    this.log('changePinnedRange', countToPin);
}

function getAllColumns() {
    this.log('getAllColumns');
    return this.getActiveColumns().filter(function (c) {
        return c.colDef;
    });
}

function resetColumnState() {
    this.log('resetColumnState');
}

function getColumn(key) {
    this.log('getColumn', key);
}

function moveColumn(fromIndex, toIndex) {
    this.moveColumns(fromIndex, 1, toIndex, false, true);
    this.log('moveColumn', fromIndex, toIndex);
}

function getAllDisplayedVirtualColumns() {
    this.log('getAllDisplayedVirtualColumns');
    return this.getActiveColumns();
}

function autoSizeColumns(columns, force) {
    var _this2 = this;

    this.log('autoSizeColumns', columns, force);
    columns.forEach(function (c) {
        return _this2.behavior.fitColumn(c, force);
    });
}

module.exports = {
    // functions
    getAllGridColumns: getAllGridColumns,
    setColumnVisible: setColumnVisible,
    setColumnsVisible: setColumnsVisible,
    changePinnedRange: changePinnedRange,
    getAllColumns: getAllColumns,
    resetColumnState: resetColumnState,
    getColumn: getColumn,
    moveColumn: moveColumn,
    getAllDisplayedVirtualColumns: getAllDisplayedVirtualColumns,
    autoSizeColumns: autoSizeColumns
};

},{}],25:[function(require,module,exports){
'use strict';

var dispatchEvent = require('../events.js').dispatchEvent;
var schema = require('./schema');

var handlersByEventString;

/**
 * Hypergrid/index.js mixes this module into its prototype.
 * @mixin
 */
var mixin = {

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-data-schema-changed` event.
     * @see {@link dataModelAPI#event:data-schema-changed data-schema-changed}
     */
    fireSyntheticDataSchemaChangedEvent: function fireSyntheticDataSchemaChangedEvent(event) {
        schema.enrich.call(this, event && event.schema);
        return dispatchEvent.call(this, 'fin-data-schema-changed', event);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-data-changed` event.
     * @see {@link dataModelAPI#event:data-changed data-changed}
     */
    fireSyntheticDataChangedEvent: function fireSyntheticDataChangedEvent(event) {
        this.repaint();
        return dispatchEvent.call(this, 'fin-data-changed', event);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-data-shape-changed` event.
     * @see {@link dataModelAPI#event:data-shape-changed data-shape-changed}
     */
    fireSyntheticDataShapeChangedEvent: function fireSyntheticDataShapeChangedEvent(event) {
        this.behaviorShapeChanged();
        return dispatchEvent.call(this, 'fin-data-shape-changed', event);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-data-preindex` event.
     * @see {@link dataModelAPI#event:data-prereindex data-prereindex}
     */
    fireSyntheticDataPrereindexEvent: function fireSyntheticDataPrereindexEvent(event) {
        this.selectedRowSourceIndexes = getUnderlyingIndexesOfSelectedRows.call(this);
        return dispatchEvent.call(this, 'fin-data-prereindex', event);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-data-postindex` event.
     * @see {@link dataModelAPI#event:data-postreindex data-postreindex}
     */
    fireSyntheticDataPostreindexEvent: function fireSyntheticDataPostreindexEvent(event) {
        if (this.selectedRowSourceIndexes) {
            if (this.selectedRowSourceIndexes.length) {
                reselectRowsByUnderlyingIndexes.call(this, this.selectedRowSourceIndexes);
            }
            delete this.selectedRowSourceIndexes;
        }
        return dispatchEvent.call(this, 'fin-data-postreindex', event) && this.fireSyntheticDataShapeChangedEvent(event);
    },

    delegateDataEvents: function delegateDataEvents() {
        Object.keys(handlersByEventString).forEach(function (eventString) {
            this.addDataEventListener(eventString, handlersByEventString[eventString]);
        }, this);
    },

    addDataEventListener: function addDataEventListener(eventString, handler) {
        var grid = this;

        grid.addInternalEventListener('fin-canvas-' + eventString, function (event) {
            handler.call(grid, event || {});
        });
    }

};

handlersByEventString = {
    'data-schema-changed': mixin.fireSyntheticDataSchemaChangedEvent,
    'data-changed': mixin.fireSyntheticDataChangedEvent,
    'data-shape-changed': mixin.fireSyntheticDataShapeChangedEvent,
    'data-prereindex': mixin.fireSyntheticDataPrereindexEvent,
    'data-postreindex': mixin.fireSyntheticDataPostreindexEvent
};

/**
 * Save underlying data row indexes backing current grid row selections.
 * This call should be paired with a subsequent call to `reselectGridRowsBackedBySelectedDataRows`.
 * @private
 * @this {Behavior}
 */
function getUnderlyingIndexesOfSelectedRows() {
    var sourceIndexes = [],
        dataModel = this.dataModel;

    if (this.properties.keepRowSelections) {
        this.getSelectedRows().forEach(function (selectedRowIndex) {
            sourceIndexes.push(dataModel.getRowIndex(selectedRowIndex));
        });
    }

    return sourceIndexes;
}

/**
 * Re-establish grid row selections based on underlying data row indexes saved by `getSelectedDataRowsBackingSelectedGridRows` which should be called first.
 * @private
 * @this {Behavior}
 */
function reselectRowsByUnderlyingIndexes(sourceIndexes) {
    var i,
        r,
        dataModel = this.dataModel,
        rowCount = dataModel.getRowCount(),
        selectedRowCount = sourceIndexes.length,
        rowIndexes = [],
        selectionModel = this.selectionModel;

    selectionModel.clearRowSelection();

    if (this.properties.keepRowSelections) {
        for (r = 0; selectedRowCount && r < rowCount; ++r) {
            i = sourceIndexes.indexOf(dataModel.getRowIndex(r));
            if (i >= 0) {
                rowIndexes.push(r);
                delete sourceIndexes[i]; // might make indexOf increasingly faster as deleted elements are not enumerable
                selectedRowCount--; // count down so we can bail early if all found
            }
        }

        rowIndexes.forEach(function (rowIndex) {
            selectionModel.selectRow(rowIndex);
        });
    }

    return rowIndexes.length;
}

module.exports = {
    mixin: mixin,
    handlers: handlersByEventString
};

},{"../events.js":27,"./schema":26}],26:[function(require,module,exports){
'use strict';

/**
 * @module dataModel/schema
 */

var headerifiers = require('../../lib/headerifiers');

/**
 * @function module:dataModel/schema.enrich
 * @summary Called via `data-schema-changed` event by data model implementation of `setSchema` when implemented, otherwise by `getSchema`, whenever the schema changes.
 *
 * Enriches schema. For each "column schema" (element of schema array):
 *
 * 1. Objectify column schemata<br>
 * Ensures each column schema is an object with a `name` property.
 * 2. Index schema schemata<br>
 * Adds an `index` property to each column schema element.
 * 3. Create enum entries<br>
 * Constructs an enum directly on the schema array object itself. This is a convenience feature, helpful for looking up column schema by column name rather than by index. To get the index of a column when you know the name:
 * ```javascript
 * var schema = dataModel.getSchema();
 * var columnName = 'foo';
 * var columnIndex = schema[columnName].index;
 * ```
 * 4. Create data row proxy<br>
 * Creates a proxy object with getters for each field to be used as a fallback when `getRow` is not implemented.
 *
 * @param {dataRowObject[]}
 *
 * @this {Hypergrid}
 */
exports.enrich = function (schema) {
    var dataModel = this.behavior.dataModel;

    schema = schema || dataModel.getSchema();

    // Make sure each element of `schema` is an object with a `name` property.
    schema.forEach(function (columnSchema, index) {
        if (typeof columnSchema === 'string') {
            schema[index] = { name: columnSchema };
        }
    });

    // There shouldn't be any meta data columns in the schema proper.
    schema = schema.filter(function (columnSchema) {
        return columnSchema.name.substr(0, 2) !== '__';
    });

    // Set `index` property.
    schema.forEach(function (columnSchema, index) {
        columnSchema.index = index;
    });

    // Set `header` property.
    var headerifier = headerifiers[this.properties.headerify];
    if (headerifier) {
        schema.forEach(function (columnSchema) {
            if (!columnSchema.header) {
                columnSchema.header = headerifier(columnSchema.name);
            }
        });
    }

    initSchemaEnum.call(dataModel);

    initDataRowProxy.call(dataModel);
};

// schema dictionary (enum)

// all instances of xX or _X
var REGEX_CAMEL_CASE_OR_UNDERSCORE = /([^_A-Z])([A-Z]+)/g;
var REGEX_ALL_PUNC_RUN = /[^a-z0-9]+/gi;

// all instances of _x
var REGEX_ALL_PUNC_RUN_BEFORE_LETTER = /[^a-z0-9]+([a-z0-9])?/ig;
function WITH_UPPER_CASE(match, char) {
    return char === undefined ? '' : char.toUpperCase();
}

var REGEX_INITIAL_DIGIT = /^(\d)/;
var WITH_DOLLAR_PREFIX = '$$$1';

var REGEX_INITIAL_CAPITAL = /^([A-Z])/;
function WITH_LOWER_CASE(match, char) {
    return char.toLowerCase();
}

// Pass through as is.
function passThrough(key) {
    return key;
}

// Convert runs of punctuation to camel case by captializing following letter.
// Otherwise, leaves other letters' case as they were.
// If result starts with digit, prefix with '$'.
function toCamelCase(key) {
    return key.replace(REGEX_ALL_PUNC_RUN_BEFORE_LETTER, WITH_UPPER_CASE).replace(REGEX_INITIAL_DIGIT, WITH_DOLLAR_PREFIX).replace(REGEX_INITIAL_CAPITAL, WITH_LOWER_CASE);
}

// Convert all runs of punctuation and camel case transitions to underscore.
// If result starts with digit, prefix with '$'.
// Convert result to all caps.
function toAllCaps(key) {
    return key.replace(REGEX_ALL_PUNC_RUN, '_').replace(REGEX_CAMEL_CASE_OR_UNDERSCORE, '$1_$2').replace(REGEX_INITIAL_DIGIT, WITH_DOLLAR_PREFIX).toUpperCase();
}

var converters = [passThrough, toCamelCase, toAllCaps];

/**
 * @summary Build schema dictionary (enum)
 * @desc For each column schema in the schema array, adds three properties to the array object:
 * * name, verbatim
 * * name, transformed to all-caps with runs of punctuation and camel case transitions to underscore converted to underscore
 * * name, transformed to camelCase with runs of punctuation removed and the next letter capitalized
 *
 * Conflicts can obviously arise, in which case who's ever first wins.
 * @this {dataModelAPI}
 */
function initSchemaEnum() {
    var schema = this.getSchema();

    schema.forEach(function (columnSchema, columnIndex) {
        converters.forEach(function (converter) {
            var convertedKey = converter(columnSchema.name);
            if (!(convertedKey in schema)) {
                schema[convertedKey] = schema[columnIndex];
            }
        });
    });
}

/**
 * @summary Build the `dataRowProxy` getter collection based on current `schema`.
 *
 * @desc The `dataRowProxy` collection is returned by the `getRow` fallback.
 *
 * `dataRowProxy` collection is a dataRow-like object (a hash of column values keyed by column name)
 * for the particular row whose index is in the `$y$` property.
 *
 * The row index can be conveniently set with a call to `fallbacks.getRow()`,
 * which sets the row index and returns the accessor itself.
 *
 * `$y$` is a "hidden" property, non-enumerable it won't show up in `Object.keys(...)`.
 *
 * This fallback implementation is "lazy": The enumerable members are all getters that invoke `getValue` and setters that invoke `setValue`.
 *
 * This function should be called each time a new schema is set.
 *
 * @this {dataModelAPI}
 */
function initDataRowProxy() {
    var dataModel = this,
        dataRowProxy = {};

    Object.defineProperty(dataRowProxy, '$y$', {
        enumerable: false, // not a real data field
        writable: true // set later on calls to fallbacks.getRow(y) to y
    });

    dataModel.getSchema().forEach(function (columnSchema, columnIndex) {
        Object.defineProperty(dataRowProxy, columnSchema.name, {
            enumerable: true, // is a real data field
            get: function get() {
                return dataModel.getValue(columnIndex, this.$y$);
            },
            set: function set(value) {
                return dataModel.setValue(columnIndex, this.$y$, value);
            }
        });
    });

    dataModel.dataRowProxy = dataRowProxy;
}

},{"../../lib/headerifiers":97}],27:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _ = require('object-iterators');

/**
 * Hypergrid/index.js mixes this module into its prototype.
 * @mixin
 */
var mixin = {

    /**
     * @summary Add an event listener to me.
     * @desc Listeners added by this method should only be removed by {@link Hypergrid#removeEventListener|grid.removeEventListener} (or {@link Hypergrid#removeAllEventListeners|grid.removeAllEventListeners}).
     * @param {string} eventName - The type of event we are interested in.
     * @param {function} listener - The event handler.
     * @param {boolean} [internal=false] - Used by {@link Hypergrid#addInternalEventListener|grid.addInternalEventListener} (see).
     * @memberOf Hypergrid#
     */
    addEventListener: function addEventListener(eventName, listener, internal) {
        var self = this,
            listeners = this.listeners[eventName] = this.listeners[eventName] || [],
            alreadyAttached = listeners.find(function (info) {
            return info.listener === listener;
        });

        if (!alreadyAttached) {
            var info = {
                internal: internal,
                listener: listener,
                decorator: function decorator(e) {
                    if (self.allowEventHandlers) {
                        listener(e);
                    }
                }
            };
            listeners.push(info);
            this.canvas.addEventListener(eventName, info.decorator);
        }
    },

    /**
     * @summary Add an internal event listener to me.
     * @desc The new listener is flagged as "internal." Internal listeners are removed as usual by {@link Hypergrid#removeEventListener|grid.removeEventListener}. However, they are ignored by {@link Hypergrid#removeAllEventListeners|grid.removeAllEventListeners()} (as called by {@link Hypergrid#reset|reset}). (But see {@link Hypergrid#removeAllEventListeners|grid.removeAllEventListeners(true)}.)
     *
     * Listeners added by this method should only be removed by {@link Hypergrid#removeEventListener|grid.removeEventListener} (or {@link Hypergrid#removeAllEventListeners|grid.removeAllEventListeners(true)}).
     * @param {string} eventName - The type of event we are interested in.
     * @param {function} listener - The event handler.
     * @memberOf Hypergrid#
     */
    addInternalEventListener: function addInternalEventListener(eventName, listener) {
        this.addEventListener(eventName, listener, true);
    },

    /**
     * @summary Remove an event listeners.
     * @desc Removes the event listener with matching name and function that was added by {@link Hypergrid#addEventListener|grid.addEventListener}.
     *
     * NOTE: This method cannot remove event listeners added by other means.
     * @memberOf Hypergrid#
     */
    removeEventListener: function removeEventListener(eventName, listener) {
        var listenerList = this.listeners[eventName];

        if (listenerList) {
            listenerList.find(function (info, index) {
                if (info.listener === listener) {
                    if (listenerList.length === 1) {
                        delete this.listeners[eventName];
                    } else {
                        listenerList.splice(index, 1); // remove it from the list
                    }
                    this.canvas.removeEventListener(eventName, info.decorator);
                    return true;
                }
            }, this);
        }
    },

    /**
     * @summary Remove all event listeners.
     * @desc Removes all event listeners added with {@link Hypergrid#addEventListener|grid.addEventListener} except those added as "internal."
     * @param {boolean} [internal=false] - Include internal listeners.
     * @memberOf Hypergrid#
     */
    removeAllEventListeners: function removeAllEventListeners(internal) {
        _(this.listeners).each(function (listenerList, key) {
            listenerList.slice().forEach(function (info) {
                if (internal || !info.internal) {
                    this.removeEventListener(key, info.listener);
                }
            }, this);
        }, this);
    },

    allowEvents: function allowEvents(allow) {
        this.allowEventHandlers = !!allow;

        if (this.behavior.featureChain) {
            if (allow) {
                this.behavior.featureChain.attachChain();
            } else {
                this.behavior.featureChain.detachChain();
            }
        }

        this.behavior.changed();
    },

    /**
     * @memberOf Hypergrid#
     * @param {number} c - grid column index.
     * @param {string[]} keys
     */
    fireSyntheticColumnSortEvent: function fireSyntheticColumnSortEvent(c, keys) {
        return dispatchEvent.call(this, 'fin-column-sort', {
            column: c,
            keys: keys
        });
    },

    fireSyntheticEditorKeyUpEvent: function fireSyntheticEditorKeyUpEvent(inputControl, keyEvent) {
        return dispatchEvent.call(this, 'fin-editor-keyup', {
            input: inputControl,
            keyEvent: keyEvent,
            char: this.canvas.getCharMap()[keyEvent.keyCode][keyEvent.shiftKey ? 1 : 0]
        });
    },

    fireSyntheticApiDestroyCalled: function fireSyntheticApiDestroyCalled(total) {
        return dispatchEvent.call(this, 'fin-api-destroy-called', { total: total });
    },

    fireSyntheticEditorKeyDownEvent: function fireSyntheticEditorKeyDownEvent(inputControl, keyEvent) {
        return dispatchEvent.call(this, 'fin-editor-keydown', {
            input: inputControl,
            keyEvent: keyEvent,
            char: this.canvas.getCharMap()[keyEvent.keyCode][keyEvent.shiftKey ? 1 : 0]
        });
    },

    fireSyntheticEditorKeyPressEvent: function fireSyntheticEditorKeyPressEvent(inputControl, keyEvent) {
        return dispatchEvent.call(this, 'fin-editor-keypress', {
            input: inputControl,
            keyEvent: keyEvent,
            char: (this.canvas.getCharMap()[keyEvent.keyCode] || {})[keyEvent.shiftKey ? 1 : 0]
        });
    },

    fireSyntheticEditorDataChangeEvent: function fireSyntheticEditorDataChangeEvent(inputControl, oldValue, newValue) {
        return dispatchEvent.call(this, 'fin-editor-data-change', true, {
            input: inputControl,
            oldValue: oldValue,
            newValue: newValue
        });
    },

    fireSyntheticColumnsMovedEvent: function fireSyntheticColumnsMovedEvent(columns, toIndex) {
        return dispatchEvent.call(this, 'fin-columns-moved', true, {
            columns: columns,
            toIndex: toIndex
        });
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-row-selection-changed` event.
     */
    fireSyntheticRowSelectionChangedEvent: function fireSyntheticRowSelectionChangedEvent() {
        return dispatchEvent.call(this, 'fin-row-selection-changed', this.selectionDetailGetters);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-column-selection-changed` event.
     */
    fireSyntheticColumnSelectionChangedEvent: function fireSyntheticColumnSelectionChangedEvent() {
        return dispatchEvent.call(this, 'fin-column-selection-changed', this.selectionDetailGetters);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-grid-data-added` event.
     * @param {array} dataRows - added data rows
     */
    fireSyntheticGridDataAddedEvent: function fireSyntheticGridDataAddedEvent(dataRows) {
        return dispatchEvent.call(this, 'fin-grid-data-added', true, {
            dataRows: dataRows
        });
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-context-menu` event
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticContextMenuEvent: function fireSyntheticContextMenuEvent(event) {
        Object.defineProperties(event, this.selectionDetailGetterDescriptors);
        return dispatchEvent.call(this, 'fin-context-menu', {}, event);
    },

    fireSyntheticMouseUpEvent: function fireSyntheticMouseUpEvent(event) {
        Object.defineProperties(event, this.selectionDetailGetterDescriptors);
        return dispatchEvent.call(this, 'fin-mouseup', {}, event);
    },

    fireSyntheticMouseDownEvent: function fireSyntheticMouseDownEvent(event) {
        Object.defineProperties(event, this.selectionDetailGetterDescriptors);
        return dispatchEvent.call(this, 'fin-mousedown', {}, event);
    },

    fireSyntheticMouseMoveEvent: function fireSyntheticMouseMoveEvent(event) {
        return dispatchEvent.call(this, 'fin-mousemove', {}, event);
    },

    fireSyntheticButtonPressedEvent: function fireSyntheticButtonPressedEvent(event) {
        var subrects = this.isViewableButton(event.dataCell.x, event.gridCell.y);
        if (subrects) {
            var subrow = subrects.findIndex(function (bounds) {
                var mouse = event.primitiveEvent.detail.mouse;
                return bounds.y <= mouse.y && mouse.y < bounds.y + bounds.height;
            });
            if (subrow >= 0) {
                event.subrow = subrow;
                return dispatchEvent.call(this, 'fin-button-pressed', {}, event);
            }
        }
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-column-drag-start` event.
     */
    fireSyntheticOnColumnsChangedEvent: function fireSyntheticOnColumnsChangedEvent() {
        return dispatchEvent.call(this, 'fin-column-changed-event', {});
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-column-drag-start` event.
     */
    fireSyntheticOnColumnResizedEvent: function fireSyntheticOnColumnResizedEvent(columnOrIndex, width) {
        var event = {
            columnOrIndex: columnOrIndex,
            width: width
        };
        return dispatchEvent.call(this, 'fin-column-resized-event', {}, event);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-fixed-column-count-changed` event.
     */
    fireSyntheticOnFixedColumnCountChangedEvent: function fireSyntheticOnFixedColumnCountChangedEvent(oldFixedCount, newFixedCount) {
        var event = {
            oldFixedCount: oldFixedCount,
            newFixedCount: newFixedCount
        };
        return dispatchEvent.call(this, 'fin-fixed-column-count-changed', {}, event);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-fixed-row-count-changed` event.
     */
    fireSyntheticOnFixedRowCountChangedEvent: function fireSyntheticOnFixedRowCountChangedEvent(oldFixedCount, newFixedCount) {
        var event = {
            oldFixedCount: oldFixedCount,
            newFixedCount: newFixedCount
        };
        return dispatchEvent.call(this, 'fin-fixed-row-count-changed', {}, event);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-keydown` event.
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticKeydownEvent: function fireSyntheticKeydownEvent(keyEvent) {
        return dispatchEvent.call(this, 'fin-keydown', keyEvent.detail);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-keyup` event.
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticKeyupEvent: function fireSyntheticKeyupEvent(keyEvent) {
        return dispatchEvent.call(this, 'fin-keyup', keyEvent.detail);
    },

    fireSyntheticFilterAppliedEvent: function fireSyntheticFilterAppliedEvent() {
        return dispatchEvent.call(this, 'fin-filter-applied', {});
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-cell-enter` event
     * @param {Point} cell - The pixel location of the cell in which the click event occurred.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticOnCellEnterEvent: function fireSyntheticOnCellEnterEvent(cellEvent) {
        return dispatchEvent.call(this, 'fin-cell-enter', cellEvent);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-cell-exit` event.
     * @param {Point} cell - The pixel location of the cell in which the click event occured.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticOnCellExitEvent: function fireSyntheticOnCellExitEvent(cellEvent) {
        return dispatchEvent.call(this, 'fin-cell-exit', cellEvent);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-cell-click` event.
     * @param {Point} cell - The pixel location of the cell in which the click event occured.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticClickEvent: function fireSyntheticClickEvent(cellEvent) {
        return dispatchEvent.call(this, 'fin-click', {}, cellEvent);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-double-click` event.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticDoubleClickEvent: function fireSyntheticDoubleClickEvent(cellEvent) {
        if (!this.abortEditing()) {
            return;
        }

        return dispatchEvent.call(this, 'fin-double-click', {}, cellEvent);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a rendered event.
     */
    fireSyntheticGridRenderedEvent: function fireSyntheticGridRenderedEvent() {
        return dispatchEvent.call(this, 'fin-grid-rendered', { source: this });
    },

    fireSyntheticTickEvent: function fireSyntheticTickEvent() {
        return dispatchEvent.call(this, 'fin-tick', { source: this });
    },

    fireSyntheticGridResizedEvent: function fireSyntheticGridResizedEvent(e) {
        return dispatchEvent.call(this, 'fin-grid-resized', e);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a scroll event.
     * @param {string} type - Should be either `fin-scroll-x` or `fin-scroll-y`.
     * @param {number} oldValue - The old scroll value.
     * @param {number} newValue - The new scroll value.
     */
    fireScrollEvent: function fireScrollEvent(eventName, oldValue, newValue) {
        return dispatchEvent.call(this, eventName, {
            oldValue: oldValue,
            value: newValue
        });
    },

    fireRequestCellEdit: function fireRequestCellEdit(cellEvent, value) {
        return dispatchEvent.call(this, 'fin-request-cell-edit', true, { value: value }, cellEvent);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a fin-before-cell-edit event.
     * @param {Point} cell - The x,y coordinates.
     * @param {Object} value - The current value.
     * @returns {boolean} Proceed (don't cancel).
     */
    fireBeforeCellEdit: function fireBeforeCellEdit(cellEvent, oldValue, newValue, control) {
        return dispatchEvent.call(this, 'fin-before-cell-edit', true, {
            oldValue: oldValue,
            newValue: newValue,
            input: control
        }, cellEvent);
    },

    /**
     * @memberOf Hypergrid#
     * @returns {Renderer} sub-component
     * @param {Point} cell - The x,y coordinates.
     * @param {Object} oldValue - The old value.
     * @param {Object} newValue - The new value.
     */
    fireAfterCellEdit: function fireAfterCellEdit(cellEvent, oldValue, newValue, control) {
        return dispatchEvent.call(this, 'fin-after-cell-edit', {
            newValue: newValue,
            oldValue: oldValue,
            input: control
        }, cellEvent);
    },

    /**
     * @memberOf Hypergrid#
     * @returns {Renderer} sub-component
     * @param {Point} cell - The x,y coordinates.
     * @param {Object} oldValue - The old value.
     * @param {Object} newValue - The new value.
     */
    fireAfterHeaderCellEdit: function fireAfterHeaderCellEdit(cellEvent, oldValue, newValue, control) {
        return dispatchEvent.call(this, 'fin-after-header-cell-edit', {
            newValue: newValue,
            oldValue: oldValue,
            input: control
        }, cellEvent);
    },

    delegateCanvasEvents: function delegateCanvasEvents() {
        var grid = this;

        function handleMouseEvent(e, cb) {
            if (grid.getLogicalRowCount() === 0) {
                return;
            }

            var c = grid.getGridCellFromMousePoint(e.detail.mouse),
                primitiveEvent,
                decoratedEvent;

            // No events on the whitespace of the grid unless they're drag events
            if (c && (!c.fake || e.detail.dragstart)) {
                primitiveEvent = c.cellEvent;
            }

            if (primitiveEvent) {
                decoratedEvent = Object.defineProperty(primitiveEvent, 'primitiveEvent', {
                    value: e,
                    enumerable: false,
                    configurable: true,
                    writable: true
                });
                cb.call(grid, decoratedEvent);
            }
        }

        this.addInternalEventListener('fin-canvas-resized', function (e) {
            grid.resized();
            grid.fireSyntheticGridResizedEvent(e);
        });

        this.addInternalEventListener('fin-canvas-mousemove', function (e) {
            if (grid.properties.readOnly) {
                return;
            }
            handleMouseEvent(e, function (mouseEvent) {
                this.delegateMouseMove(mouseEvent);
                this.fireSyntheticMouseMoveEvent(mouseEvent);
            });
        });

        this.addInternalEventListener('fin-canvas-mousedown', function (e) {
            if (grid.properties.readOnly) {
                return;
            }
            if (!grid.abortEditing()) {
                event.stopPropagation();
                return;
            }

            handleMouseEvent(e, function (mouseEvent) {
                mouseEvent.keys = e.detail.keys;
                this.mouseDownState = mouseEvent;
                this.delegateMouseDown(mouseEvent);
                this.fireSyntheticMouseDownEvent(mouseEvent);
                this.repaint();
            });
        });

        this.addInternalEventListener('fin-canvas-outside-mousedown', function (e) {
            grid.delegateCanvasOutsideMousedown(event);
        });

        this.addInternalEventListener('fin-canvas-click', function (e) {
            if (grid.properties.readOnly) {
                return;
            }
            handleMouseEvent(e, function (mouseEvent) {
                mouseEvent.keys = e.detail.keys; // todo: this was in fin-tap but wasn't here
                this.fireSyntheticClickEvent(mouseEvent);
                this.delegateClick(mouseEvent);
            });
        });

        this.addInternalEventListener('fin-canvas-mouseup', function (e) {
            if (grid.properties.readOnly) {
                return;
            }
            grid.dragging = false;
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
            if (grid.columnDragAutoScrolling) {
                grid.columnDragAutoScrolling = false;
            }
            handleMouseEvent(e, function (mouseEvent) {
                this.delegateMouseUp(mouseEvent);
                if (grid.mouseDownState) {
                    grid.fireSyntheticButtonPressedEvent(grid.mouseDownState);
                }
                this.mouseDownState = null;
                this.fireSyntheticMouseUpEvent(mouseEvent);
            });
        });

        this.addInternalEventListener('fin-canvas-dblclick', function (e) {
            if (grid.properties.readOnly) {
                return;
            }
            handleMouseEvent(e, function (mouseEvent) {
                this.fireSyntheticDoubleClickEvent(mouseEvent, e);
                this.delegateDoubleClick(mouseEvent);
            });
        });

        this.addInternalEventListener('fin-canvas-drag', function (e) {
            if (grid.properties.readOnly) {
                return;
            }
            grid.dragging = true;
            handleMouseEvent(e, grid.delegateMouseDrag);
        });

        this.addInternalEventListener('fin-canvas-keydown', function (e) {
            if (grid.properties.readOnly) {
                return;
            }
            grid.fireSyntheticKeydownEvent(e);
            grid.delegateKeyDown(e);
        });

        this.addInternalEventListener('fin-api-destroy-called', function (e) {
            grid.delegateApiDestroyCalled(e);
        });

        this.addInternalEventListener('fin-canvas-keyup', function (e) {
            if (grid.properties.readOnly) {
                return;
            }
            grid.fireSyntheticKeyupEvent(e);
            grid.delegateKeyUp(e);
        });

        this.addInternalEventListener('fin-canvas-wheelmoved', function (e) {
            handleMouseEvent(e, grid.delegateWheelMoved);
        });

        this.addInternalEventListener('fin-canvas-mouseout', function (e) {
            if (grid.properties.readOnly) {
                return;
            }
            handleMouseEvent(e, grid.delegateMouseExit);
        });

        this.addInternalEventListener('fin-canvas-context-menu', function (e) {
            handleMouseEvent(e, function (mouseEvent) {
                grid.delegateContextMenu(mouseEvent);
                grid.fireSyntheticContextMenuEvent(mouseEvent);
            });
        });

        this.addInternalEventListener('fin-grid-rendered', function (e) {
            grid.delegateGridRendered(event);
        });

        //Register a listener for the copy event so we can copy our selected region to the pastebuffer if conditions are right.
        document.body.addEventListener('copy', function (evt) {
            grid.checkClipboardCopy(evt);
        });

        document.body.addEventListener('paste', function (evt) {
            console.log(evt.clipboardData.getData('text/html'));
        });

        this.addInternalEventListener('fin-column-resized-event', function (e) {
            grid.delegateColumnResizedEvent(event);

            grid.synchronizeScrollbarsVisualization();
        });

        this.addInternalEventListener('fin-fixed-column-count-changed', function (e) {
            grid.synchronizeScrollbarsVisualization();
        });

        this.addInternalEventListener('fin-fixed-row-count-changed', function (e) {
            grid.synchronizeScrollbarsVisualization();
        });

        this.addInternalEventListener('fin-after-cell-edit', function (e) {
            var headerRowY = grid.properties.useHeaders ? grid.getFictiveHeaderRowsCount() : 0;
            if (e.detail.primitiveEvent.y <= headerRowY) {
                grid.fireAfterHeaderCellEdit(e.detail.primitiveEvent, e.detail.oldValue, e.detail.newValue, e.detail.input);
            }
        });

        this.addInternalEventListener('fin-after-header-cell-edit', function (e) {
            if (e.detail.newValue !== e.detail.oldValue) {
                var column = grid.behavior.getActiveColumn(e.detail.primitiveEvent.x);
                grid.behavior.fitColumn(column); // recalculate preferredWidth for column
                if (grid.onUpdateColumnName) {
                    if (column) {
                        grid.onUpdateColumnName(column, e.detail.newValue);

                        // refresh names from colDefs
                        var rowProps = grid.behavior.getRowProperties(0);
                        if (rowProps && rowProps.headerRow) {
                            var row = grid.getRow(0);

                            grid.getColumns().forEach(function (c) {
                                if (c.colDef && row[c.name] !== c.colDef.headerName) {
                                    row[c.name] = c.colDef.headerName;
                                }
                            });
                        }
                    }
                }
            }
        });

        this.addInternalEventListener('fin-grid-data-added', function (e) {
            grid.delegateGridDataAdded(e);
        });
    },

    /**
     * @memberOf Hypergrid#
     * @desc Delegate the wheel moved event to the behavior.
     * @param {Event} event - The pertinent event.
     */
    delegateWheelMoved: function delegateWheelMoved(event) {
        this.behavior.onWheelMoved(this, event);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Delegate MouseExit to the behavior (model).
     * @param {Event} event - The pertinent event.
     */
    delegateMouseExit: function delegateMouseExit(event) {
        this.behavior.handleMouseExit(this, event);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Delegate MouseExit to the behavior (model).
     * @param {Event} event - The pertinent event.
     */
    delegateContextMenu: function delegateContextMenu(event) {
        this.behavior.onContextMenu(this, event);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Delegate GridRendered to the behavior (model).
     * @param {Event} event - The pertinent event.
     */
    delegateGridRendered: function delegateGridRendered(event) {
        this.behavior.onGridRendered(this, event);
    },

    delegateColumnResizedEvent: function delegateColumnResizedEvent(event) {
        this.behavior.onColumnResizedEvent(this, event);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Delegate MouseMove to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseMove: function delegateMouseMove(mouseDetails) {
        this.behavior.onMouseMove(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Delegate mousedown to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseDown: function delegateMouseDown(mouseDetails) {
        this.behavior.handleMouseDown(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Delegate mousedown to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateCanvasOutsideMousedown: function delegateCanvasOutsideMousedown(mouseDetails) {
        this.behavior.handleCanvasOutsideMouseDown(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Delegate mouseup to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseUp: function delegateMouseUp(mouseDetails) {
        this.behavior.onMouseUp(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Delegate click to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateClick: function delegateClick(mouseDetails) {
        this.behavior.onClick(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Delegate mouseDrag to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseDrag: function delegateMouseDrag(mouseDetails) {
        this.behavior.onMouseDrag(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid#
     * @desc We've been doubleclicked on. Delegate through the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateDoubleClick: function delegateDoubleClick(mouseDetails) {
        this.behavior.onDoubleClick(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid#
     * @summary Generate a function name and call it on self.
     * @desc This should also be delegated through Behavior keeping the default implementation here though.
     * @param {event} event - The pertinent event.
     */
    delegateKeyDown: function delegateKeyDown(event) {
        this.behavior.onKeyDown(this, event);
    },

    /**
     * @memberOf Hypergrid#
     * @summary Generate a function name and call it on self.
     * @desc This should also be delegated through Behavior keeping the default implementation here though.
     * @param {event} event - The pertinent event.
     */
    delegateApiDestroyCalled: function delegateApiDestroyCalled(event) {
        this.behavior.onApiDestroyCalled(this, event);
    },

    /**
     * @memberOf Hypergrid#
     * @summary Generate a function name and call it on self.
     * @desc This should also be delegated through Behavior keeping the default implementation here though.
     * @param {event} event - The pertinent event.
     */
    delegateKeyUp: function delegateKeyUp(event) {
        this.behavior.onKeyUp(this, event);
    },

    /**
     * @memberOf Hypergrid#
     * @summary Generate a function name and call it on self.
     * @desc This should also be delegated through Behavior keeping the default implementation here though.
     * @param {event} event - The pertinent event.
     */
    delegateGridDataAdded: function delegateGridDataAdded(event) {
        this.behavior.onDataAdded(this, event);
    }
};

var details = ['gridCell', 'dataCell', 'mousePoint', 'keys', 'row'];

/**
 * @this {Hypergrid}
 * @param {string} eventName
 * @param {boolean} [cancelable=false]
 * @param {object} event
 * @param {CellEvent|MouseEvent|KeyboardEvent|object} [primitiveEvent]
 * @returns {undefined|boolean}
 */
function dispatchEvent(eventName, cancelable, event, primitiveEvent) {
    var detail, result;

    if (!this.canvas) {
        return;
    }

    if (typeof cancelable !== 'boolean') {
        primitiveEvent = event; // propmote primitiveEvent to 3rd position
        event = cancelable; // promote event to 2nd position
        cancelable = false; // default when omitted
    }

    if (!event.detail) {
        event = { detail: event };
    }

    detail = event.detail;

    if (!detail.grid) {
        // CellEvent objects already have a (read-only) `grid` prop
        detail.grid = this;
    }

    detail.time = Date.now();

    if (primitiveEvent) {
        if (!detail.primitiveEvent) {
            detail.primitiveEvent = primitiveEvent;
        }
        details.forEach(function (key) {
            if (key in primitiveEvent && !(key in detail)) {
                detail[key] = primitiveEvent[key];
            }
        });
        if ('dataRow' in primitiveEvent) {
            // reference (without invoking) cellEvent's `dataRow` getter when available
            Object.defineProperty(detail, 'row', { get: function get() {
                    return primitiveEvent.dataRow;
                } });
        }
    }

    if (cancelable) {
        event.cancelable = true;
    }

    result = this.canvas.dispatchEvent(new CustomEvent(eventName, event));

    return !cancelable || result;
}

module.exports = {
    mixin: mixin,
    dispatchEvent: dispatchEvent
};

},{"object-iterators":12}],28:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

require('../lib/polyfills'); // Installs misc. polyfills into global objects, as needed

var Point = require('rectangular').Point;
var Rectangle = require('rectangular').Rectangle;
var _ = require('object-iterators'); // fyi: installs the Array.prototype.find polyfill, as needed
var injectCSS = require('inject-stylesheet-template').bind(require('../../css'));

var Base = require('../Base');
var defaults = require('../defaults');
var dynamicPropertyDescriptors = require('../lib/dynamicProperties');
var Canvas = require('../lib/Canvas');
var Renderer = require('../renderer');
var SelectionModel = require('../lib/SelectionModel');
var Localization = require('../lib/Localization');
var Behavior = require('../behaviors/Behavior');
var behaviorJSON = require('../behaviors/Local');
var cellRenderers = require('../cellRenderers');
var cellEditors = require('../cellEditors');
var modules = require('./modules');

var EDGE_STYLES = ['top', 'bottom', 'left', 'right'],
    RECT_STYLES = EDGE_STYLES.concat(['width', 'height', 'position']);

/**
 * @mixes scrolling.mixin
 * @mixes events.mixin
 * @mixes selection.mixin
 * @mixes themes.instanceMixin
 * @constructor
 * @param {string|Element} [container] - CSS selector or Element
 * @param {object} [options] - If `options.data` provided, passed to {@link Hypergrid#setData setData}; else if `options.Behavior` provided, passed to {@link Hypergrid#setBehavior setBehavior}.
 * @param {function} [options.Behavior=Local] - _Per {@link Behavior#setData}._
 * @param {dataModelAPI} [options.dataModel] - _Passed to behavior {@link Behavior constructor}._
 * @param {function} [options.DataModel=require('datasaur-local')] - _Passed to behavior {@link Behavior constructor}._
 * @param {function|object[]} [options.data] - _Passed to behavior {@link Behavior constructor}._
 * @param {function|menuItem[]} [options.schema] - _Passed to behavior {@link Behavior constructor}._
 * @param {dataModelAPI} [options.metadata] - _Passed to behavior {@link Behavior constructor}._
 * * A schema array
 * @param {subgridSpec[]} [options.subgrids=this.properties.subgrids] - _Per {@link Behavior#setData}._
 *
 * @param {pluginSpec|pluginSpec[]} [options.plugins]
 *
 * @param {object} [options.state]
 *
 * @param {string|Element} [options.container] - CSS selector or Element
 *
 * @param {string} [options.localization=Hypergrid.localization]
 * @param {string|string[]} [options.localization.locale=Hypergrid.localization.locale] - The default locale to use when an explicit `locale` is omitted from localizer constructor calls. Passed to Intl.NumberFomrat` and `Intl.DateFomrat`. See {@ https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation|Locale identification and negotiation} for more information.
 * @param {string} [options.localization.numberOptions=Hypergrid.localization.numberOptions] - Options passed to `Intl.NumberFormat` for creating the basic "number" localizer.
 * @param {string} [options.localization.dateOptions=Hypergrid.localization.dateOptions] - Options passed to `Intl.DateFomrat` for creating the basic "date" localizer.
 *
 * @param {object} [options.margin] - Optional canvas "margins" applied to containing div as .left, .top, .right, .bottom. (Default values actually derive from 'grid' stylesheet's `.hypergrid-container` rule.)
 * @param {string} [options.margin.top='0px']
 * @param {string} [options.margin.right='0px']
 * @param {string} [options.margin.bottom='0px']
 * @param {string} [options.margin.left='0px']
 *
 * @param {object} [options.boundingRect] - Optional grid container size & position. (Default values actually derive from 'grid' stylesheet's `.hypergrid-container > div:first-child` rule.)
 * @param {string} [options.boundingRect.height='500px']
 * @param {string} [options.boundingRect.width='auto']
 * @param {string} [options.boundingRect.left='auto']
 * @param {string} [options.boundingRect.top='auto']
 * @param {string} [options.boundingRect.right='auto']
 * @param {string} [options.boundingRect.bottom='auto']
 * @param {string} [options.boundingRect.position='relative']
 */
var Hypergrid = Base.extend('Hypergrid', {
    initialize: function initialize(container, options) {
        var _this = this;

        this.selectionInitialize();

        //Optional container argument
        if (!(typeof container === 'string') && !(container instanceof HTMLElement)) {
            options = container;
            container = null;
        }

        options = options || {};

        this.clearState();

        //Set up the container for a grid instance
        this.setContainer(container || options.container || findOrCreateContainer(options.boundingRect));

        // Install shared plug-ins (those with a `preinstall` method)
        Hypergrid.prototype.installPlugins(options.plugins);

        this.lastEdgeSelection = [0, 0];
        this.isWebkit = navigator.userAgent.toLowerCase().indexOf('webkit') > -1;
        if (this.selectionModel) {
            this.selectionModel.reset();
        } else {
            this.selectionModel = new SelectionModel(this);
        }

        this.renderOverridesCache = {};
        this.allowEventHandlers = true;
        this.dragExtent = new Point(0, 0);
        this.numRows = 0;
        this.numColumns = 0;
        this.clearMouseDown();
        this.setFormatter(options.localization);
        this.listeners = {};

        /**
         * @name cellRenderers
         * @type {Registry}
         * @memberOf Hypergrid#
         */
        this.cellRenderers = cellRenderers;

        /**
         * Private version of cell editors registry with a bound `create` method for use by `getCellEditorAt`.
         * @name cellEditors
         * @type {Registry}
         * @memberOf Hypergrid#
         */
        this.cellEditors = Object.create(cellEditors);
        Object.defineProperty(this.cellEditors, 'create', { value: createCellEditor.bind(this) });

        this.initCanvas(options);

        if (options.data) {
            this.setData(options.data, options); // if no behavior has yet been set, `setData` sets a default behavior
        } else {
            // behaviour should be
            if (!this.behavior) {
                this.setBehavior(options);
            }
            this.initScrollbars();
        }

        if (options.state) {
            this.loadState(options.state);
        }

        if (options.theme) {
            this.applyTheme(options.theme);
        }

        /**
         * @name api
         * @summary api for using with datadocs like ag-grid
         * @desc set of methods which was used in ag-grid
         * @memberOf Hypergrid#
         */
        // create api
        this.api = options.api || {};
        this.columnApi = options.columnApi || {};
        // merge api mixins
        var bindAllFunctions = function bindAllFunctions(from, to, context) {
            for (var k in from) {
                if (from.hasOwnProperty(k)) {
                    if (typeof from[k] === 'function') {
                        to[k] = from[k].bind(context);
                    } else if ((typeof from === 'undefined' ? 'undefined' : _typeof(from)) === 'object') {
                        if (Array.isArray(from[k])) {
                            to[k] = [];
                        } else {
                            to[k] = from[k];
                            bindAllFunctions(to[k], from[k], context);
                        }
                    }
                }
            }
        };

        bindAllFunctions(require('./api'), this.api, this);
        bindAllFunctions(require('./columnApi'), this.columnApi, this);

        this.columnDefs = options.columnDefs || [];
        this.visibleColumnDefs = this.columnDefs.filter(function (cd) {
            return !cd.isHidden;
        });
        this.data = options.data || [];
        this.rowData = options.rowData || [];
        this.paginationPageSize = options.paginationPageSize || this.paginationPageSize || 1000;

        [// reuse functions
        'onColumnResized', 'onUpdateColumnName', 'onColumnsMoved', 'getMainMenuItems', 'getContextMenuItems', 'onAggregatedCellClick', 'onCtrlAndZ', 'onCtrlShiftAndZ', 'logEnable'].forEach(function (k) {
            _this[k] = options[k] || _this[k];
        });

        if (this.onColumnsMoved) {
            this.addInternalEventListener('fin-columns-moved', function (e) {
                _this.onColumnsMoved(e.detail.columns, e.detail.toIndex);
            });
        }

        /**
         * @name plugins
         * @summary Dictionary of named instance plug-ins.
         * @desc See examples for how to reference (albeit there is normally no need to reference plugins directly).
         *
         * For the dictionary of _shared_ plugins, see {@link Hypergrid.plugins|plugins} (a property of the constructor).
         * @example
         * var instancePlugins = myGrid.plugins;
         * var instancePlugins = this.plugins; // internal use
         * var myInstancePlugin = myGrid.plugins.myInstancePlugin;
         * @type {object}
         * @memberOf Hypergrid#
         */
        this.plugins = {};

        // Install instance plug-ins (those that are constructors OR have an `install` method)
        this.installPlugins(options.plugins);

        // Listen for propagated mouseclicks. Used for aborting edit mode.
        document.addEventListener('mousedown', this.mouseCatcher = function () {
            this.abortEditing();
        }.bind(this));

        setTimeout(this.repaint.bind(this));

        Hypergrid.grids.push(this);

        this.resetGridBorder('Top');
        this.resetGridBorder('Right');
        this.resetGridBorder('Bottom');
        this.resetGridBorder('Left');
    },

    /**
     * Be a responsible citizen and call this function on instance disposal!
     */
    terminate: function terminate() {
        document.removeEventListener('mousedown', this.mouseCatcher);
        this.canvas.stop();
        if (this.grids) {
            Hypergrid.grids.splice(this.grids.indexOf(this), 1);
        }
    },

    /*
    * check if grid alive
     */
    isAlive: function isAlive() {
        // check if div still in DOM
        if (!document.body.contains(this.div)) {
            this.terminate();
            this.div = undefined;
            return false;
        }
        return true;
    },

    resetGridBorder: function resetGridBorder(edge) {
        edge = edge || '';

        var propName = 'gridBorder' + edge,
            styleName = 'border' + edge,
            props = this.properties,
            border = props[propName];

        switch (border) {
            case true:
                border = props.lineWidth + 'px solid ' + props.lineColor;
                break;
            case false:
                border = null;
                break;
        }
        this.canvas.canvas.style[styleName] = border;
    },

    modules: modules, // Mutate or replace prototype prop to affect all grid instances; set instance prop to affect just instance.

    /**
     *
     * A null object behavior serves as a place holder.
     * @type {object}
     * @memberOf Hypergrid#
     */
    behavior: null,

    /**
     * Cached resulan}
     * @memberOf Hypergrid#
     */
    isWebkit: true,

    /**
     * The pixel location of an initial mousedown click, either for editing a cell or for dragging a selection.
     * @type {Point}
     * @memberOf Hypergrid#
     */
    mouseDown: [],

    /**
     * The extent from the mousedown point during a drag operation.
     * @type {Point}
     * @memberOf Hypergrid#
     */

    dragExtent: null,

    /**
     * @property {fin-hypergrid-selection-model} selectionModel - A [fin-hypergrid-selection-model](module-._selection-model.html) instance.
     * @memberOf Hypergrid#
     */
    selectionModel: null,

    /**
     * @property {fin-hypergrid-cell-editor} cellEditor - The current instance of [fin-hypergrid-cell-editor](module-cell-editors_base.html).
     * @memberOf Hypergrid#
     */
    cellEditor: null,

    /**
     * @property {fin-vampire-bar} sbHScroller - An instance of {@link https://github.com/openfin/finbars|FinBar}.
     * @memberOf Hypergrid#
     */
    sbHScroller: null,

    /**
     * is the short term memory of what column I might be dragging around
     * @type {object}
     * @memberOf Hypergrid#
     */

    renderOverridesCache: {},

    /**
     * The pixel location of the current hovered cell.
     * @todo Need to detect hovering over bottom totals.
     * @type {Point}
     * @memberOf Hypergrid#
     */
    hoverCell: null,

    lastEdgeSelection: null,

    /**
     * @memberOf Hypergrid#
     */
    setAttribute: function setAttribute(attribute, value) {
        this.div.setAttribute(attribute, value);
    },

    /**
     * @memberOf Hypergrid#
     */
    clearState: function clearState() {
        /**
         * @name properties
         * @type {object}
         * @summary Object containing the properties of the grid.
         * @desc Grid properties objects have the following structure:
         * 1. User-configured properties and dynamic properties are in the "own" layer.
         * 2. Extends from the theme object.
         * 3. The theme object in turn extends from the {@link module:defaults|defaults} object.
         *
         * Note: Any changes the application developer may wish to make to the {@link module:defaults|defaults}
         * object should be made _before_ reaching this point (_i.e.,_ prior to any grid instantiations).
         * @memberOf Hypergrid#
         */
        this.properties = Object.defineProperties(this.initThemeLayer(), {
            grid: { value: this },
            var: { value: new Var() }
        });

        // For all all default props of object type, if a dynamic prop, invoke setter; else deep clone it so changes
        // made to inner props won't go to object on theme or defaults layers which are shared by other instances.
        Object.keys(defaults).forEach(function (key) {
            var value = defaults[key];
            if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
                if (dynamicPropertyDescriptors[key]) {
                    this[key] = value; // invoke dynamic prop setter
                } else {
                    this[key] = deepClone(value); // just a plain object
                }
            }
        }, this.properties);
    },

    /**
     * @desc Clear out all state settings, data (rows), and schema (columns) of a grid instance.
     * @param {object} [options]
     * @param {object} [options.subgrids] - Consumed by {@link Behavior#reset}.
     * If omitted, previously established subgrids list is reused.
     * @memberOf Hypergrid#
     */
    reset: function reset(options) {
        this.clearState();

        this.removeAllEventListeners();

        this.lastEdgeSelection = [0, 0];
        this.selectionModel.reset();
        this.renderOverridesCache = {};
        this.clearMouseDown();
        this.dragExtent = new Point(0, 0);

        this.numRows = 0;
        this.numColumns = 0;

        this.vScrollValue = 0;
        this.hScrollValue = 0;

        this.cancelEditing();

        this.sbPrevVScrollValue = null;
        this.sbPrevHScrollValue = null;

        this.hoverCell = null;
        this.scrollingNow = false;
        this.lastEdgeSelection = [0, 0];

        this.behavior.reset({
            subgrids: options && options.subgrids
        });

        this.renderer.reset();
        this.canvas.resize();
        this.behaviorChanged();

        this.refreshProperties();
    },

    /** @typedef {object|function|Array} pluginSpec
     * @desc One of:
     * * simple API - a plain object with an `install` method
     * * object API - an object constructor
     * * array:
     *    * first element is an optional name for the API or the newly instantiated object
     *    * next element (or first element when not a string) is the simple or object API
     *    * remaining arguments are optional arguments for the object constructor
     * * falsy value such as `undefined` - ignored
     *
     * The API may have a `name` or `$$CLASS_NAME` property.
     */
    /**
     * @summary Install plugins.
     * @desc Plugin installation:
     * * Each simple API is installed by calling it's `install` method with `this` as first arg + any additional args listed in the `pluginSpec` (when it is an array).
     * * Each object API is installed by instantiating it's constructor with `this` as first arg + any additional args listed in the `pluginSpec` (when it is an array).
     *
     * The resulting plain object or instantiated objects may be named by (in priority order):
     * 1. if `pluginSpec` contains an array and first element is a string
     * 2. object has a `name` property
     * 3. object has a `$$CLASS_NAME` property
     *
     * If named, a reference to each object is saved in `this.plugins`. If the plug-in is unnamed, no reference is kept.
     *
     * There are two types of plugin installations:
     * * Preinstalled plugins which are installed on the prototype. These are simple API plugins with a `preinstall` method called with the `installPlugins` calling context as the first argument. Preinstallations are automatically performed whenever a grid is instantiated (at the beginning of the constructor), by calling `installPlugins` with `Hypergrid.prototype` as the calling context.
     * * Regular plugins which are installed on the instance. These are simple API plugins with an `install` method, as well as all object API plugins (constructors), called with the `installPlugins` calling context as the first argument. These installations are automatically performed whenever a grid is instantiated (at the end of the constructor), called with the new grid instance as the calling context.
     *
     * The "`installPlugins` calling context" means either the grid instance or its prototype, depending on how this method is called.
     *
     * Plugins may have both `preinstall` _and_ `install` methods, in which case both will be called. However, note that in any case, `install` methods on object API plugins are ignored.
     *
     * @this {Hypergrid}
     * @param {pluginSpec|pluginSpec[]} [plugins] - The plugins to install. If omitted, the call is a no-op.
     * @memberOf Hypergrid#
     */
    installPlugins: function installPlugins(plugins) {
        var shared = this === Hypergrid.prototype; // Do shared ("preinstalled") plugins (if any)

        if (!plugins) {
            return;
        } else if (!Array.isArray(plugins)) {
            plugins = [plugins];
        }

        plugins.forEach(function (plugin) {
            var name, args, hash;

            if (!plugin) {
                return; // ignore falsy plugin spec
            }

            // set first arg of constructor to `this` (the grid instance)
            // set first arg of `install` method to `this` (the grid instance)
            // set first two args of `preinstall` method to `this` (the Hypergrid prototype) and the Behavior prototype
            args = [this];
            if (shared) {
                args.push(Behavior.prototype);
            }

            if (Array.isArray(plugin)) {
                if (!plugin.length) {
                    plugin = undefined;
                } else if (typeof plugin[0] !== 'string') {
                    args = args.concat(plugin.slice(1));
                    plugin = plugin[0];
                } else if (plugin.length >= 2) {
                    args = args.concat(plugin.slice(2));
                    name = plugin[0];
                    plugin = plugin[1];
                } else {
                    plugin = undefined;
                }
            }

            if (!plugin) {
                return; // ignore empty array or array with single string element
            }

            // Derive API name if not given in pluginSpec
            name = name || plugin.name || plugin.$$CLASS_NAME;
            if (name) {
                // Translate first character to lower case
                name = name.substr(0, 1).toLowerCase() + name.substr(1);
            }

            if (shared) {
                // Execute the `preinstall` method
                hash = this.constructor.plugins;
                if (plugin.preinstall && !hash[name]) {
                    plugin.preinstall.apply(plugin, args);
                }
            } else {
                // instance plug-ins:
                hash = this.plugins;
                if (typeof plugin === 'function') {
                    // Install "object API" by instantiating
                    plugin = this.createApply(plugin, args);
                } else if (plugin.install) {
                    // Install "simple API" by calling its `install` method
                    plugin.install.apply(plugin, args);
                } else if (!plugin.preinstall) {
                    throw new Base.prototype.HypergridError('Expected plugin (a constructor; or an API with a `preinstall` method and/or an `install` method).');
                }
            }

            if (name) {
                hash[name] = plugin;
            }
        }, this);
    },

    /**
     * @summary Uninstall all uninstallable plugins or just named plugins.
     * @desc Calls `uninstall` on plugins that define such a method.
     *
     * To uninstall "preinstalled" plugins, call with `Hypergrid.prototype` as context.
     *
     * For convenience, the following args are passed to the call:
     * * `this` - the plugin to be uninstalled
     * * `grid` - the hypergrid object
     * * `key` - name of the plugin to be uninstalled (_i.e.,_ key in `plugins`)
     * * `plugins` - the plugins hash (a.k.a. `grid.plugins`)
     * @param {string|stirng[]} [pluginNames] If provided, limit uninstall to the named plugin (string) or plugins (string[]).
     * @memberOf Hypergrid#
     */
    uninstallPlugins: function uninstallPlugins(pluginNames) {
        if (!pluginNames) {
            pluginNames = [];
        } else if (!Array.isArray(pluginNames)) {
            pluginNames = [pluginNames];
        }
        _(this.plugins).each(function (plugin, key, plugins) {
            if (plugins.hasOwnProperty(key) && pluginNames.indexOf(key) >= 0 && plugin.uninstall) {
                plugin.uninstall(this, key, plugins);
            }
        }, this);
    },

    computeCellsBounds: function computeCellsBounds() {
        this.renderer.computeCellsBounds();
    },

    setFormatter: function setFormatter(options) {
        options = options || {};
        this.localization = new Localization(options.locale || Hypergrid.localization.locale, options.numberOptions || Hypergrid.localization.numberOptions, options.dateOptions || Hypergrid.localization.dateOptions);
    },

    getFormatter: function getFormatter(localizerName) {
        return this.localization.get(localizerName).format;
    },

    formatValue: function formatValue(localizerName, value, isHeader) {
        return value !== undefined ? this.getFormatter(localizerName)(value, isHeader) : '';
    },

    /**
     * @memberOf Hypergrid#
     * @desc Set the cell under the cursor.
     * @param {CellEvent} cellEvent
     */
    setHoverCell: function setHoverCell(cellEvent) {
        var hoverCell = this.hoverCell;
        if (!hoverCell || !hoverCell.equals(cellEvent.gridCell)) {
            this.hoverCell = cellEvent.gridCell;
            if (hoverCell) {
                this.fireSyntheticOnCellExitEvent(cellEvent);
            }
            this.fireSyntheticOnCellEnterEvent(cellEvent);
            this.repaint();
        }
    },

    /**
     * @memberOf Hypergrid#
     * @desc Amend properties for this hypergrid only.
     * @param {object} moreProperties - A simple properties hash.
     */
    addProperties: function addProperties(properties) {
        Object.assign(this.properties, properties);
        this.refreshProperties();
    },

    /**
     * @todo deprecate this in favor of making properties dynamic instead (for those that need to be)
     * @memberOf Hypergrid#
     * @desc Utility function to push out properties if we change them.
     * @param {object} properties - An object of various key value pairs.
     */
    refreshProperties: function refreshProperties() {
        this.behaviorShapeChanged();
        this.behavior.defaultRowHeight = null;
        this.behavior.autosizeAllColumns();
    },

    /**
     * @memberOf Hypergrid#
     * @desc Set the state object to return to the given user configuration.
     * @param {object} state - A memento object.
     * @see [Memento pattern](http://en.wikipedia.org/wiki/Memento_pattern)
     */
    setState: function setState(state) {
        this.behavior.setState(state);
        this.refreshProperties();
        this.behaviorChanged();
    },

    getState: function getState() {
        return this.behavior.getState();
    },

    loadState: function loadState(state) {
        this.behavior.setState(state);
    },

    /**
     * @todo Only output values when they differ from defaults (deep compare needed).
     * @param {object} [options]
     * @param {string[]} [options.blacklist] - List of grid properties to exclude. Pertains to grid own properties only.
     * @param {boolean} [options.compact] - Run garbage collection first. The only property this current affects is `properties.calculators` (removes unused calculators).
     * @param {number|string} [options.space='\t'] - For no space, give `0`. (See {@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Local/stringify|JSON.stringify}'s `space` param other options.)
     * @param {function} [options.headerify] - If your headers were generated by a function (taking column name as a parameter), give a reference to that function here to avoid persisting headers that match the generated string.
     * @memberOf Hypergrid#
     */
    saveState: function saveState(options) {
        options = options || {};

        var space = options.space === undefined ? '\t' : options.space,
            properties = this.properties,
            calculators = properties.calculators;

        if (calculators) {
            if (options.compact) {
                var columns = this.behavior.getColumns();
                Object.keys(calculators).forEach(function (key) {
                    if (!columns.find(function (column) {
                        return column.properties.calculator === calculators[key];
                    })) {
                        delete calculators[key];
                    }
                });
            }
            calculators.toJSON = stringifyFunctions;
        }

        // Temporarily copy the given headerify function for access by columns getter
        this.headerify = options.headerify;

        var json = JSON.stringify(properties, function (key, value) {
            if (options.blacklist && this === properties && options.blacklist.indexOf(key) >= 0) {
                value = undefined;
            } else if (key === 'calculator') {
                if (calculators) {
                    // convert function reference to registry key
                    value = Object.keys(calculators).find(function (key) {
                        return calculators[key] === value;
                    });
                } else {
                    // registry may not exist if Column.calculator setter was used directly so just save as is
                    value = value.toString();
                }
            }
            return value;
        }, space);

        // Remove the temporary copy
        delete this.headerify;

        return json;
    },

    /**
     * @memberOf Hypergrid#
     * @returns {object} The initial mouse position on a mouse down event for cell editing or a drag operation.
     * @memberOf Hypergrid#
     */
    getMouseDown: function getMouseDown() {
        if (this.mouseDown.length) {
            return this.mouseDown[this.mouseDown.length - 1];
        }
    },

    /**
     * @memberOf Hypergrid#
     * @desc Remove the last item from the mouse down stack.
     */
    popMouseDown: function popMouseDown() {
        var result;
        if (this.mouseDown.length) {
            result = this.mouseDown.pop();
        }
        return result;
    },

    /**
     * @memberOf Hypergrid#
     * @desc Empty out the mouse down stack.
     */
    clearMouseDown: function clearMouseDown() {
        this.mouseDown = [new Point(-1, -1)];
        this.dragExtent = null;
    },

    /**
     * Set the mouse point that initiated a cell edit or drag operation.
     * @param {Point} point
     * @memberOf Hypergrid#
     */
    setMouseDown: function setMouseDown(point) {
        this.mouseDown.push(point);
    },

    /**
     * @memberOf Hypergrid#
     * @returns {Point} The extent point of the current drag selection rectangle.
     */
    getDragExtent: function getDragExtent() {
        return this.dragExtent;
    },

    /**
     * @memberOf Hypergrid#
     * @summary Set the extent point of the current drag selection operation.
     * @param {Point} point
     */
    setDragExtent: function setDragExtent(point) {
        this.dragExtent = point;
    },

    /**
     * @memberOf Hypergrid#
     * @desc This function is a callback from the HypergridRenderer sub-component. It is called after each paint of the canvas.
     */
    gridRenderedNotification: function gridRenderedNotification() {
        if (this.cellEditor) {
            this.cellEditor.gridRenderedNotification();
        }
        this.checkColumnAutosizing();
        this.fireSyntheticGridRenderedEvent();
    },

    tickNotification: function tickNotification() {
        this.fireSyntheticTickEvent();
    },

    /**
     * @memberOf Hypergrid#
     * @desc The grid has just been rendered, make sure the column widths are optimal.
     */
    checkColumnAutosizing: function checkColumnAutosizing() {
        this.behavior.autoSizeRowNumberColumn();
        if (this.behavior.checkColumnAutosizing(false)) {
            this.behaviorShapeChanged();
        }
    },

    /**
     * @memberOf Hypergrid#
     * @summary Conditionally copy to clipboard.
     * @desc If we have focus, copy our current selection data to the system clipboard.
     * @param {event} event - The copy system event.
     */
    checkClipboardCopy: function checkClipboardCopy(event) {
        if (this.hasFocus() || this.menuClick) {
            event.preventDefault();
            var csvData = this.getSelectionAsTSV();
            event.clipboardData.setData('text/plain', csvData.text);
            event.clipboardData.setData('text/html', csvData.html);
        }
    },

    /**
     * @memberOf Hypergrid#
     * @returns {boolean} We have focus.
     */
    hasFocus: function hasFocus() {
        return this.canvas.hasFocus();
    },

    /**
     * @memberOf Hypergrid#
     * @summary Set the Behavior object for this grid control.
     * @desc Called when `options.Behavior` from:
     * * Hypergrid constructor
     * * `setData` when not called explicitly before then
     * @param {object} [options] - _Per {@link Behavior#setData}._
     * @param {Behavior} [options.Behavior=Local] - The behavior (model) can be either a constructor or an instance.
     * @param {dataModelAPI} [options.dataModel] - A fully instantiated data model object.
     * @param {function} [options.DataModel=require('datasaur-local')] - Data model will be instantiated from this constructor unless `options.dataModel` was given.
     * @param {dataModelAPI} [options.metadata] - Value to be passed to setMetadataStore if the data model has changed.
     * @param {dataRowObject[]} [options.data] - _Per {@link Behavior#setData}._
     * @param {function|menuItem[]} [options.schema] - _Per {@link Behavior#setData}.
     */
    setBehavior: function setBehavior(options) {
        var Behavior = options && options.Behavior || behaviorJSON;
        this.behavior = new Behavior(this, options);
        this.initScrollbars();
        this.refreshProperties();
        this.behavior.reindex();
    },

    /**
     * @memberOf Hypergrid#
     * @summary Set the underlying datasource.
     * @desc This can be done dynamically.
     * @param {function|object[]} dataRows - May be:
     * * An array of congruent raw data objects.
     * * A function returning same.
     * @param {object} [options] - _(See also {@link Behavior#setData} for additional options.)_
     * @param {Behavior} [options.Behavior=Local] - The behavior (model) can be either a constructor or an instance.
     * @param {dataModelAPI} [options.dataModel] - _Passed to behavior {@link Behavior constructor} (when `options.Behavior` given)._
     * @param {function} [options.DataModel=require('datasaur-local')] - _Passed to behavior {@link Behavior constructor} (when `options.Behavior` given)._
     * @param {dataModelAPI} [options.metadata] - _Passed to behavior {@link Behavior constructor} (when `options.Behavior` given)._
     * @param {dataRowObject[]} [options.data] - _Passed to behavior {@link Behavior constructor} (when `options.Behavior` given)._
     * @param {function|menuItem[]} [options.schema] - _Passed to behavior {@link Behavior constructor} (when `options.Behavior` given)._
     */
    setData: function setData(dataRows, options) {
        if (!this.behavior) {
            this.setBehavior(options);
        }
        this.behavior.setData(dataRows, options);
        this.setInfo(dataRows.length ? '' : this.properties.noDataMessage);
        this.behavior.changed();
        this.fireSyntheticGridDataAddedEvent(dataRows);
    },

    /**
     * @memberOf Hypergrid#
     * @summary Add the underlying datasource.
     * @desc This can be done dynamically.
     * @param {function|object[]} dataRows - May be:
     * * An array of congruent raw data objects.
     * * A function returning same.
     * @param {object} [options] - _(See also {@link Behavior#setData} for additional options.)_
     * @param {Behavior} [options.Behavior=Local] - The behavior (model) can be either a constructor or an instance.
     * @param {dataModelAPI} [options.dataModel] - _Passed to behavior {@link Behavior constructor} (when `options.Behavior` given)._
     * @param {function} [options.DataModel=require('datasaur-local')] - _Passed to behavior {@link Behavior constructor} (when `options.Behavior` given)._
     * @param {dataModelAPI} [options.metadata] - _Passed to behavior {@link Behavior constructor} (when `options.Behavior` given)._
     * @param {dataRowObject[]} [options.data] - _Passed to behavior {@link Behavior constructor} (when `options.Behavior` given)._
     * @param {function|menuItem[]} [options.schema] - _Passed to behavior {@link Behavior constructor} (when `options.Behavior` given)._
     */
    addData: function addData(dataRows, options) {
        if (!options) {
            options = {};
        }
        if (!this.behavior) {
            this.setBehavior(options);
        }
        if (!options.schema) {
            options.schema = this.behavior.dataModel.getSchema();
        }
        this.behavior.addData(dataRows, options);
        this.setInfo(this.behavior.dataModel.getData().length ? '' : this.properties.noDataMessage);
        this.behavior.changed();
        this.fireSyntheticGridDataAddedEvent(dataRows);
    },

    setInfo: function setInfo(messages) {
        this.renderer.setInfo(messages);
    },

    /**
     * @memberOf Hypergrid#
     * @desc I've been notified that the behavior has changed.
     */
    behaviorChanged: function behaviorChanged() {
        if (this.divCanvas) {
            if (this.numColumns !== this.getColumnCount() || this.numRows !== this.getRowCount()) {
                this.numColumns = this.getColumnCount();
                this.numRows = this.getRowCount();
                this.behaviorShapeChanged();
            } else {
                this.behaviorStateChanged();
            }
        }
    },

    /**
     * @memberOf Hypergrid#
     * @desc The dimensions of the grid data have changed. You've been notified.
     */
    behaviorShapeChanged: function behaviorShapeChanged() {
        this.needsShapeChanged = true;
        this.repaint();
    },

    /**
     * @memberOf Hypergrid#
     * @desc The dimensions of the grid data have changed. You've been notified.
     */
    behaviorStateChanged: function behaviorStateChanged() {
        this.needsStateChanged = true;
        this.repaint();
    },

    /**
     * Called from renderer/index.js
     */
    deferredBehaviorChange: function deferredBehaviorChange() {
        if (this.needsShapeChanged) {
            if (this.divCanvas) {
                this.canvas.refreshBounds();
                this.synchronizeScrollingBoundaries(); // calls computeCellsBounds and repaint (state change)
            }
        } else if (this.needsStateChanged) {
            if (this.divCanvas) {
                this.computeCellsBounds();
            }
        }

        this.needsShapeChanged = this.needsStateChanged = false;
    },

    /**
     * @memberOf Hypergrid#
     * @returns {Rectangle} My bounds.
     */
    getBounds: function getBounds() {
        return this.renderer.getBounds();
    },

    repaint: function repaint() {
        var now = this.properties.repaintImmediately;
        var canvas = this.canvas;
        if (canvas) {
            if (now === true) {
                canvas.paintNow();
            } else {
                canvas.repaint();
            }
        }
    },

    /**
     * @memberOf Hypergrid#
     * @desc Paint immediately in this microtask.
     */
    paintNow: function paintNow() {
        this.canvas.paintNow();
    },

    /**
     * @memberOf Hypergrid#
     * @summary Set the container for a grid instance
     * @private
     */
    setContainer: function setContainer(div) {
        this.initContainer(div);
        this.initRenderer();
        // injectGridElements.call(this);
    },

    /**
     * @memberOf Hypergrid#
     * @summary Initialize container
     * @private
     */
    initContainer: function initContainer(div) {
        if (typeof div === 'string') {
            div = document.querySelector(div);
        }

        //Default Position and height to ensure DnD works
        if (!div.style.position) {
            div.style.position = null; // revert to stylesheet value
        }

        if (div.clientHeight < 1) {
            div.style.height = null; // revert to stylesheet value
        }

        injectCSS('grid');

        //prevent the default context menu for appearing
        div.oncontextmenu = function (event) {
            event.stopPropagation();
            event.preventDefault();
            return false;
        };

        div.removeAttribute('tabindex');

        div.classList.add('hypergrid-container');
        div.id = div.id || 'hypergrid' + (document.querySelectorAll('.hypergrid-container').length - 1 || '');

        this.div = div;
    },

    /**
     * @memberOf Hypergrid#
     * @summary Initialize drawing surface.
     * @param {object} [options]
     * @param {object} [options.margin] - Optional canvas "margins" applied to containing div as .left, .top, .right, .bottom. (Default values actually derive from 'grid' stylesheet's `.hypergrid-container` rule.)
     * @param {string} [options.margin.top='0px']
     * @param {string} [options.margin.right='0px']
     * @param {string} [options.margin.bottom='0px']
     * @param {string} [options.margin.left='0px']
     * @private
     */
    initCanvas: function initCanvas(options) {
        if (!this.divCanvas) {
            var divCanvas = document.createElement('div');

            setStyles(divCanvas, options && options.margin, EDGE_STYLES);

            this.div.appendChild(divCanvas);

            var canvas = new Canvas(divCanvas, this.renderer);
            canvas.canvas.classList.add('hypergrid');

            this.divCanvas = divCanvas;
            this.canvas = canvas;

            this.delegateCanvasEvents();
            this.delegateDataEvents();
        }
    },

    convertViewPointToDataPoint: function convertViewPointToDataPoint(unscrolled) {
        return this.behavior.convertViewPointToDataPoint(unscrolled);
    },

    convertDataPointToViewPoint: function convertDataPointToViewPoint(dataPoint) {
        return this.behavior.convertDataPointToViewPoint(dataPoint);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Switch the cursor for a grid instance.
     * @param {string|string[]} cursorName - A well know cursor name.
     * @see [cursor names](http://www.javascripter.net/faq/stylesc.htm)
     */
    beCursor: function beCursor(cursorName) {
        if (!cursorName) {
            cursorName = ['default'];
        } else if (!Array.isArray(cursorName)) {
            cursorName = [cursorName];
        }
        if (this.div) {
            cursorName.forEach(function (name) {
                this.cursor = name;
            }, this.div.style);
        }
    },

    /**
     * @summary Shut down the current cell editor and save the edited value.
     * @returns {boolean} One of:
     * * `false` - Editing BUT could not abort.
     * * `true` - Not editing OR was editing AND abort was successful.
     * @memberOf Hypergrid#
     */
    stopEditing: function stopEditing() {
        return !this.cellEditor || this.cellEditor.stopEditing();
    },

    /**
     * @summary Shut down the current cell editor without saving the edited val
     * @returns {boolean} One of:
     * * `false` - Editing BUT could not abort.
     * * `true` - Not editing OR was editing AND abort was successful.
     * @memberOf Hypergrid#
     */
    cancelEditing: function cancelEditing() {
        return !this.cellEditor || this.cellEditor.cancelEditing();
    },

    /**
     * @summary Give cell editor opportunity to cancel (or something) instead of stop .
     * @returns {boolean} One of:
     * * `false` - Editing BUT could not abort.
     * * `true` - Not editing OR was editing AND abort was successful.
     * @memberOf Hypergrid#
     */
    abortEditing: function abortEditing() {
        return !this.cellEditor || (this.cellEditor.abortEditing ? this.cellEditor.abortEditing() : this.cellEditor.stopEditing());
    },

    /**
     * @memberOf Hypergrid#
     * @returns {Rectangle} The pixel coordinates of just the center 'main" data area.
     */
    getDataBounds: function getDataBounds() {
        var b = this.canvas.bounds;
        return new Rectangle(0, 0, b.origin.x + b.extent.x, b.origin.y + b.extent.y);
    },

    /**
     * @memberOf Hypergrid#
     * @summary Open the cell-editor for the cell at the given coordinates.
     * @param {CellEvent} event - Coordinates of "edit point" (gridCell.x, dataCell.y).
     * @return {undefined|CellEditor} The cellEditor determined from the cell's render properties, which may be modified by logic added by overriding {@link DataModel#getCellEditorAt|getCellEditorAt}.
     */
    editAt: function editAt(event) {
        var cellEditor;

        this.abortEditing(); // if another editor is open, close it first

        var editableX = event.dataCell.x,
            editableY = event.dataCell.y;

        if (event.isColspanedByLeftColumn && event.colspanMainColumnName) {
            var mainColumn = this.behavior.getHeaderColumnByName(event.colspanMainColumnName);
            var mainColumnIndex = this.behavior.columns.indexOf(mainColumn);

            if (mainColumn && mainColumnIndex) {
                editableX = mainColumnIndex;
            }
        }
        if (event.rowspanMainRow !== undefined && event.rowspanMainRow !== null) {
            editableY = event.rowspanMainRow;
        }

        if (editableX !== event.dataCell.x || editableY !== event.dataCell.y) {
            this.scrollToMakeVisible(editableX, editableY);
            this.paintNow();
            event = new this.behavior.CellEvent(editableX, editableY + this.getHeaderRowCount());
        }

        if (event.isDataColumn && (cellEditor = this.getCellEditorAt(event))) {
            var neededVisibilityProp = event.isDataRow ? 'editable' : 'filterable';
            var isEditable = event.rowProperties[neededVisibilityProp] ? event.rowProperties[neededVisibilityProp] : event.properties[neededVisibilityProp];

            if (isEditable) {
                cellEditor.beginEditing();
            } else {
                cellEditor.showReadonlyEdit();
            }
        }

        return cellEditor;
    },

    /**
     * @memberOf Hypergrid#
     * @param {number} columnIndex - The column index in question.
     * @returns {boolean} The given column is fully visible.
     */
    isColumnVisible: function isColumnVisible(columnIndex) {
        return this.renderer.isColumnVisible(columnIndex);
    },

    /**
     * @memberOf Hypergrid#
     * @param {number} r - The raw row index in question.
     * @returns {boolean} The given row is fully visible.
     */
    isDataRowVisible: function isDataRowVisible(r) {
        return this.renderer.isDataRowVisible(r);
    },

    /**
     * @memberOf Hypergrid#
     * @param {number} c - The column index in question.
     * @param {number} rn - The grid row index in question.
     * @returns {boolean} The given cell is fully is visible.
     */
    isDataVisible: function isDataVisible(c, rn) {
        return this.isDataRowVisible(rn) && this.isColumnVisible(c);
    },

    /**
     * @memberOf Hypergrid#
     * @summary Scroll in the `offsetX` direction if column index `colIndex` is not visible.
     * @param {number} colIndex - The column index in question.
     * @param {number} offsetX - The direction and magnitude to scroll if we need to.
     * @return {boolean} Column is visible.
     */
    insureModelColIsVisible: function insureModelColIsVisible(colIndex, offsetX) {
        var maxCols = this.getColumnCount() - 1; // -1 excludes partially visible columns
        var indexToCheck = colIndex + Math.sign(offsetX);
        return !this.isColumnVisible(indexToCheck) || colIndex === maxCols;
    },

    /**
     * @memberOf Hypergrid#
     * @summary Scroll in the `offsetY` direction if column index c is not visible.
     * @param {number} rowIndex - The column index in question.
     * @param {number} offsetY - The direction and magnitude to scroll if we need to.
     * @return {boolean} Row is visible.
     */
    insureModelRowIsVisible: function insureModelRowIsVisible(rowIndex, offsetY) {
        var maxRows = this.getRowCount() - 1; // -1 excludes partially visible rows
        var scrollOffset = offsetY > -1 ? 2 : 0; // 2 to keep one blank line below active cell, 0 to keep zero lines above active cell
        var indexToCheck = rowIndex + scrollOffset;
        return !this.isDataRowVisible(indexToCheck) || rowIndex === maxRows;
    },

    /**
     * @memberOf Hypergrid#
     * @summary Scroll horizontal and vertically by the provided offsets.
     * @param {number} offsetX - Scroll in the x direction this much.
     * @param {number} offsetY - Scroll in the y direction this much.
     */
    scrollBy: function scrollBy(offsetX, offsetY) {
        // OVERRIDED BY scrolling.js FILE
        this.scrollHBy(offsetX);
        this.scrollVBy(offsetY);
    },

    /**
     * @memberOf Hypergrid#
     * @summary Scroll vertically by the provided offset.
     * @param {number} offsetY - Scroll in the y direction this much.
     */
    scrollVBy: function scrollVBy(offsetY) {
        // OVERRIDED BY scrolling.js FILE
        var max = this.sbVScroller.range.max;
        var oldValue = this.vScrollValue;
        var oldOffset = this.getVScrollValue();
        var newValue = Math.min(max, oldValue + offsetY * this.behavior.getRowHeight(Math.max(0, oldOffset + offsetY)));
        if (newValue !== oldValue) {
            this.setVScrollValue(newValue);
        }
    },

    /**
     * @memberOf Hypergrid#
     * @summary Scroll horizontally by the provided offset.
     * @param {number} offsetX - Scroll in the x direction this much.
     */
    scrollHBy: function scrollHBy(offsetX) {
        // OVERRIDED BY scrolling.js FILE
        var max = this.sbHScroller.range.max;
        var oldValue = this.hScrollValue;
        var oldOffset = this.getHScrollValue();
        var newValue = Math.min(max, oldValue + offsetX * this.behavior.getColumnWidth(Math.max(0, oldOffset + offsetX)));
        if (newValue !== oldValue) {
            this.setHScrollValue(newValue);
        }
    },

    scrollToMakeVisible: function scrollToMakeVisible(column, row) {
        var delta,
            dw = this.renderer.dataWindow,
            fixedColumnCount = this.properties.fixedColumnCount,
            fixedRowCount = this.properties.fixedRowCount;

        // scroll only if target not in fixed columns
        if (column >= fixedColumnCount) {
            // target is to left of scrollable columns; negative delta scrolls left
            if ((delta = column - dw.origin.x) < 0) {
                this.sbHScroller.index += delta;

                // target is to right of scrollable columns; positive delta scrolls right
                // Note: The +1 forces right-most column to scroll left (just in case it was only partially in view)
            } else if (column - dw.corner.x + 1 > 0) {
                this.sbHScroller.index = this.renderer.getMinimumLeftPositionToShowColumn(column);
            }
        }

        if (row >= fixedRowCount && ( // scroll only if target not in fixed rows

        // target is above scrollable rows; negative delta scrolls up
        (delta = row - dw.origin.y) < 0 ||

        // target is below scrollable rows; positive delta scrolls down
        (delta = row - dw.corner.y) > 0)) {
            this.sbVScroller.index += delta;
        }
    },

    selectCellAndScrollToMakeVisible: function selectCellAndScrollToMakeVisible(c, r) {
        this.scrollToMakeVisible(c, r);
        this.selectCell(c, r, true);
    },

    /**
     * @memberOf Hypergrid#
     * @summary Answer which data cell is under a pixel value mouse point.
     * @param {mousePoint} mouse - The mouse point to interrogate.
     */

    getGridCellFromMousePoint: function getGridCellFromMousePoint(mouse) {
        return this.renderer.getGridCellFromMousePoint(mouse);
    },

    /**
     * @param {Point} gridCell - The pixel location of the mouse in physical grid coordinates.
     * @returns {Rectangle} The pixel based bounds rectangle given a data cell point.
     * @memberOf Hypergrid#
     */
    getBoundsOfCell: function getBoundsOfCell(gridCell) {
        var b = this.renderer.getBoundsOfCell(gridCell.x, gridCell.y);

        //convert to a proper rectangle
        return new Rectangle(b.x, b.y, b.width, b.height);
    },

    /**
     * @memberOf Hypergrid#
     * @desc This is called by the fin-canvas when a resize occurs.
     */
    resized: function resized() {
        this.behaviorShapeChanged();
    },

    /**
     * To intercept link clicks, override this method (either on the prototype to apply to all grid instances or on an instance to apply to a specific grid instance).
     * @memberOf Hypergrid#
     */
    windowOpen: function windowOpen(url, name, features, replace) {
        return window.open.apply(window, arguments);
    },

    /**
     * @param {number} [begin]
     * @param {nubmer} [end]
     * * @returns {Column[]} A copy of the all columns array by passing the params to `Array.prototype.slice`.
     */
    getColumns: function getColumns(begin, end) {
        var columns = this.behavior.getColumns();
        return columns.slice.apply(columns, arguments);
    },

    /**
     * @param {number} [begin]
     * @param {nubmer} [end]
     * * @returns {Column[]} A copy of the active columns array by passing the params to `Array.prototype.slice`.
     */
    getActiveColumns: function getActiveColumns(begin, end) {
        var columns = this.behavior.getActiveColumns();
        return columns.slice.apply(columns, arguments);
    },

    getHiddenColumns: function getHiddenColumns() {
        //A non in-memory behavior will be more troublesome
        return this.behavior.getHiddenColumns();
    },

    isViewableButton: function isViewableButton(c, r) {
        return this.renderer.isViewableButton(c, r);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Request input focus.
     */
    takeFocus: function takeFocus() {
        var wasCellEditor = this.cellEditor;
        this.stopEditing();
        if (!wasCellEditor) {
            this.canvas.takeFocus();
        }
    },

    /**
     * @memberOf Hypergrid#
     * @desc Request focus for our cell editor.
     */
    editorTakeFocus: function editorTakeFocus() {
        if (this.cellEditor) {
            return this.cellEditor.takeFocus();
        }
    },

    /**
     * @memberOf Hypergrid#
     * @desc Initialize the scroll bars.
     */
    initScrollbars: function initScrollbars() {
        if (this.sbHScroller && this.sbVScroller) {
            return;
        }

        var Scrollbar = Hypergrid.modules.scrollbar;

        var horzBar = new Scrollbar({
            orientation: 'horizontal',
            onchange: this.setHScrollValue.bind(this),
            cssStylesheetReferenceElement: this.div
        });

        var vertBar = new Scrollbar({
            orientation: 'vertical',
            onchange: this.setVScrollValue.bind(this),
            paging: {
                up: this.pageUp.bind(this),
                down: this.pageDown.bind(this)
            }
        });

        this.sbHScroller = horzBar;
        this.sbVScroller = vertBar;

        var hPrefix = this.properties.hScrollbarClassPrefix;
        var vPrefix = this.properties.vScrollbarClassPrefix;

        if (hPrefix && hPrefix !== '') {
            this.sbHScroller.classPrefix = hPrefix;
        }

        if (vPrefix && vPrefix !== '') {
            this.sbVScroller.classPrefix = vPrefix;
        }

        this.div.appendChild(horzBar.bar);
        this.div.appendChild(vertBar.bar);

        this.synchronizeScrollbarsVisualization();
    },

    synchronizeScrollbarsVisualization: function synchronizeScrollbarsVisualization() {
        this.sbHScroller.shortenBy(this.sbVScroller).resize();
        //this.sbVScroller.shortenBy(this.sbHScroller);
        this.sbVScroller.resize();
    },

    /**
     * @memberOf Hypergrid#
     * @desc Scroll values have changed, we've been notified.
     */
    setVScrollbarValues: function setVScrollbarValues(max) {
        this.sbVScroller.range = {
            min: 0,
            max: max
        };
    },

    setHScrollbarValues: function setHScrollbarValues(max) {
        this.sbHScroller.range = {
            min: 0,
            max: max
        };
    },

    scrollValueChangedNotification: function scrollValueChangedNotification() {
        if (this.hScrollValue !== this.sbPrevHScrollValue || this.vScrollValue !== this.sbPrevVScrollValue) {
            this.sbPrevHScrollValue = this.hScrollValue;
            this.sbPrevVScrollValue = this.vScrollValue;

            if (this.cellEditor) {
                this.cellEditor.scrollValueChangedNotification();
            }

            this.computeCellsBounds();
        }
    },

    /**
     * @memberOf Hypergrid#
     * @summary Get data value at given cell.
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     */
    getValue: function getValue(x, y) {
        return this.behavior.getValue.apply(this.behavior, arguments); // must use .apply (see this.behavior.getValue)
    },

    /**
     * @memberOf Hypergrid#
     * @summary Set a data value of a given cell.
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     * @param {*} value - New cell value.
     */
    setValue: function setValue(x, y, value) {
        this.behavior.setValue.apply(this.behavior, arguments); // must use .apply (see this.behavior.setValue)
    },

    /**
     * @memberOf Hypergrid#
     * @desc Note that "viewable columns" includes any partially viewable columns.
     * @returns {number} The number of viewable columns.
     */
    getVisibleColumns: function getVisibleColumns() {
        return this.renderer.getVisibleColumns();
    },

    /**
     * @memberOf Hypergrid#
     * @summary Initialize the renderer sub-component.
     */
    initRenderer: function initRenderer() {
        this.renderer = this.renderer || new Renderer(this);
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} The width of the given column.
     * @param {number} columnIndex - The untranslated column index.
     */
    getColumnWidth: function getColumnWidth(columnIndex) {
        return this.behavior.getColumnWidth(columnIndex);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Set the width of the given column.
     * @param {number} columnIndex - The untranslated column index.
     * @param {number} columnWidth - The width in pixels.
     */
    setColumnWidth: function setColumnWidth(columnIndex, columnWidth) {
        if (this.abortEditing()) {
            this.behavior.setColumnWidth(columnIndex, columnWidth);
        }
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} The total width of all the fixed columns.
     */
    getFixedColumnsWidth: function getFixedColumnsWidth() {
        return this.behavior.getFixedColumnsWidth();
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} The height of the given row
     * @param {number} rowIndex - The untranslated fixed column index.
     */
    getRowHeight: function getRowHeight(rowIndex, dataModel) {
        return this.behavior.getRowHeight(rowIndex, dataModel);
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} count of rows, that used as fictive headers
     */
    getFictiveHeaderRowsCount: function getFictiveHeaderRowsCount() {
        return this.behavior.getFictiveHeaderRowsCount();
    },

    /**
     * @memberOf Hypergrid#
     * @desc Set the height of the given row.
     * @param {number} rowIndex - The row index.
     * @param {number} rowHeight - The width in pixels.
     */
    setRowHeight: function setRowHeight(rowIndex, rowHeight, dataModel) {
        if (this.abortEditing()) {
            this.behavior.setRowHeight(rowIndex, rowHeight, dataModel);
        }
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} The total fixed rows height
     */
    getFixedRowsHeight: function getFixedRowsHeight() {
        return this.behavior.getFixedRowsHeight();
    },

    /**
     * Number of _visible_ columns.
     * @memberOf Hypergrid#
     * @returns {number} The number of columns.
     */
    getColumnCount: function getColumnCount() {
        return this.behavior.getActiveColumnCount();
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} The number of rows.
     */
    getRowCount: function getRowCount() {
        return this.behavior.getRowCount();
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} The number of fixed columns.
     */
    getFixedColumnCount: function getFixedColumnCount() {
        return this.behavior.getFixedColumnCount();
    },

    /**
     * @memberOf Hypergrid#
     * @returns The number of fixed rows.
     */
    getFixedRowCount: function getFixedRowCount() {
        return this.behavior.getFixedRowCount();
    },

    /**
     * @memberOf Hypergrid#
     * @summary The top left area has been clicked on
     * @desc Delegates to the behavior.
     * @param {event} mouse - The event details.
     */
    topLeftClicked: function topLeftClicked(mouse) {
        this.behavior.topLeftClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid#
     * @summary A fixed row has been clicked.
     * @desc Delegates to the behavior.
     * @param {event} event - The event details.
     */
    rowHeaderClicked: function rowHeaderClicked(mouse) {
        this.behavior.rowHeaderClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid#
     * @summary A fixed column has been clicked.
     * @desc Delegates to the behavior.
     * @param {event} event - The event details.
     */
    columnHeaderClicked: function columnHeaderClicked(mouse) {
        this.behavior.columnHeaderClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid#
     * @desc An edit event has occurred. Activate the editor at the given coordinates.
     * @param {number} event.gridCell.x - The horizontal coordinate.
     * @param {number} event.gridCell.y - The vertical coordinate.
     * @param {boolean} [event.primitiveEvent.type]
     * @returns {undefined|CellEditor} The editor object or `undefined` if no editor or editor already open.
     */
    onEditorActivate: function onEditorActivate(event) {
        return this.editAt(event);
    },

    /**
     * @memberOf Hypergrid#
     * @summary Get the cell editor.
     * @desc Delegates to the behavior.
     * @returns The cell editor at the given coordinates.
     * @param {Point} cellEvent - The grid cell coordinates.
     */
    getCellEditorAt: function getCellEditorAt(event) {
        return this.behavior.getCellEditorAt(event);
    },

    /**
     * @memberOf Hypergrid#
     * @summary Toggle HiDPI support.
     * @desc HiDPI support is now *on* by default.
     * > There used to be a bug in Chrome that caused severe slow down on bit blit of large images, so this HiDPI needed to be optional.
     */
    toggleHiDPI: function toggleHiDPI() {
        if (this.properties.useHiDPI) {
            this.removeAttribute('hidpi');
        } else {
            this.setAttribute('hidpi', null);
        }
        this.canvas.resize();
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} The HiDPI ratio.
     */
    getHiDPI: function getHiDPI(ctx) {
        if (window.devicePixelRatio && this.properties.useHiDPI) {
            var devicePixelRatio = window.devicePixelRatio || 1,
                backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1,
                result = devicePixelRatio / backingStoreRatio;
        } else {
            result = 1;
        }
        return result;
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} The width of the given (recently rendered) column.
     * @param {number} colIndex - The column index.
     */
    getRenderedWidth: function getRenderedWidth(colIndex) {
        return this.renderer.getRenderedWidth(colIndex);
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} The height of the given (recently rendered) row.
     * @param {number} rowIndex - The row index.
     */
    getRenderedHeight: function getRenderedHeight(rowIndex) {
        return this.renderer.getRenderedHeight(rowIndex);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Update the cursor under the hover cell.
     */
    updateCursor: function updateCursor() {
        var cursor = this.behavior.getCursorAt(-1, -1);
        var hoverCell = this.hoverCell;
        if (hoverCell && hoverCell.x > -1 && hoverCell.y > -1) {
            var x = hoverCell.x + this.getHScrollValue();
            cursor = this.behavior.getCursorAt(x, hoverCell.y + this.getVScrollValue());
        }
        this.beCursor(cursor);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Repaint the given cell.
     * @param {x} x - The horizontal coordinate.
     * @param {y} y - The vertical coordinate.
     */
    repaintCell: function repaintCell(x, y) {
        this.renderer.repaintCell(x, y);
    },

    /**
     * @memberOf Hypergrid#
     * @returns {boolean} The user is currently dragging a column to reorder it.
     */
    isDraggingColumn: function isDraggingColumn() {
        return !!this.renderOverridesCache.dragger;
    },

    /**
     * @memberOf Hypergrid#
     * @returns {object[]} Objects with the values that were just rendered.
     */
    getRenderedData: function getRenderedData() {
        return this.renderer.getVisibleCellMatrix();
    },

    /**
     * @summary Autosize a column for best fit.
     * @param {Column|number} columnOrIndex - The column or active column index.
     * @memberOf Hypergrid#
     */
    autosizeColumn: function autosizeColumn(columnOrIndex) {
        var column = columnOrIndex >= -2 ? this.behavior.getActiveColumn(columnOrIndex) : columnOrIndex;
        column.checkColumnAutosizing(true);
        this.behavior.fitColumn(column, true);
        this.computeCellsBounds();
    },

    /**
     * @memberOf Hypergrid#
     * @desc Enable/disable if this component can receive the focus.
     * @param {boolean} - canReceiveFocus
     */
    setFocusable: function setFocusable(canReceiveFocus) {
        this.canvas.setFocusable(canReceiveFocus);
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} The number of columns that were just rendered
     */
    getVisibleColumnsCount: function getVisibleColumnsCount() {
        return this.renderer.getVisibleColumnsCount();
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} The number of rows that were just rendered
     */
    getVisibleRowsCount: function getVisibleRowsCount() {
        return this.renderer.getVisibleRowsCount();
    },

    /**
     * @memberOf Hypergrid#
     * @desc Update the size of a grid instance.
     */
    updateSize: function updateSize() {
        this.canvas.checksize();
    },

    /**
     * @memberOf Hypergrid#
     * @desc Stop the global repainting flag thread.
     */
    stopPaintThread: function stopPaintThread() {
        this.canvas.stopPaintThread();
    },

    /**
     * @memberOf Hypergrid#
     * @desc Stop the global resize check flag thread.
     */
    stopResizeThread: function stopResizeThread() {
        this.canvas.stopResizeThread();
    },

    /**
     * @memberOf Hypergrid#
     * @desc Restart the global resize check flag thread.
     */
    restartResizeThread: function restartResizeThread() {
        this.canvas.restartResizeThread();
    },

    /**
     * @memberOf Hypergrid#
     * @desc Restart the global repainting check flag thread.
     */
    restartPaintThread: function restartPaintThread() {
        this.canvas.restartPaintThread();
    },

    /**
     * @deprecated columns dragging now performed like in google sheets (performed only when user stop dragging on new position)
     */
    swapColumns: function swapColumns(source, target) {
        //Turns out this is called during dragged 'i.e' when the floater column is reshuffled
        //by the currently dragged column. The column positions are constantly reshuffled
        this.behavior.swapColumns(source, target);
    },

    /**
     * @desc utility method to perform columns reordering
     * @param {number} from - visible columns start index
     * @param {number} len - length of columns set to reorder
     * @param {number} target - new start index of an columns
     * @param {boolean?} broadcastEvent - optional param. If set to 'false', synthetic event will not be fired.
     * Useful, when reordering not initiated by user, and don't need to affect side effects
     * @param {boolean?} givenHiddenColumns - if true, method performed like all the columns is shown and indexes
     * of visible columns and all columns are equal
     */
    moveColumns: function moveColumns(from, len, target, broadcastEvent, givenHiddenColumns) {
        this.behavior.moveColumns(from, len, target, broadcastEvent, givenHiddenColumns);
    },

    getSelectedColumns: function getSelectedColumns() {
        return this.behavior.getSelectedColumns();
    },

    endDragColumnNotification: function endDragColumnNotification() {
        this.behavior.endDragColumnNotification();
    },

    getFixedColumnsMaxWidth: function getFixedColumnsMaxWidth() {
        return this.behavior.getFixedColumnsMaxWidth();
    },

    isMouseDownInHeaderArea: function isMouseDownInHeaderArea() {
        var headerRowCount = this.getHeaderRowCount();
        var mouseDown = this.getMouseDown();
        return mouseDown.x < 0 || mouseDown.y < headerRowCount;
    },

    /**
     * @param {index} x - Data x coordinate.
     * @return {Object} The properties for a specific column.
     * @memberOf Hypergrid#
     */
    getColumnProperties: function getColumnProperties(x) {
        return this.behavior.getColumnProperties(x);
    },

    /**
     * @param {index} x - Data x coordinate.
     * @return {Object} The properties for a specific column.
     * @memberOf Hypergrid#
     */
    setColumnProperties: function setColumnProperties(x, properties) {
        this.behavior.setColumnProperties(x, properties);
    },

    /**
     * Clears all cell properties of given column or of all columns.
     * @param {number} [x] - Omit for all columns.
     * @memberOf Behavior#
     */
    clearAllCellProperties: function clearAllCellProperties(x) {
        this.behavior.clearAllCellProperties(x);
        this.renderer.resetAllCellPropertiesCaches();
    },

    /**
     * @param {integerRowIndex|sectionPoint} rn
     * @returns {boolean}
     * @memberOf Hypergrid#
     */
    isGridRow: function isGridRow(y) {
        return new this.behavior.CellEvent(0, y).isDataRow;
    },

    /**
     * @returns {number} The total number of rows of all subgrids preceding the data subgrid.
     * @memberOf Hypergrid#
     */
    getHeaderRowCount: function getHeaderRowCount() {
        return this.behavior.getHeaderRowCount();
    },

    /**
     * @returns {number} The total number of rows of all subgrids following the data subgrid.
     * @memberOf Hypergrid#
     */
    getFooterRowCount: function getFooterRowCount() {
        return this.behavior.getFooterRowCount();
    },

    /**
     * @returns {number} The total number of logical rows of all subgrids.
     * @memberOf Hypergrid#
     */
    getLogicalRowCount: function getLogicalRowCount() {
        return this.behavior.getLogicalRowCount();
    },

    hasTreeColumn: function hasTreeColumn(columnIndex) {
        return this.behavior.hasTreeColumn(columnIndex);
    },
    lookupFeature: function lookupFeature(key) {
        return this.behavior.lookupFeature(key);
    },
    getRow: function getRow(y) {
        return this.behavior.getRow(y);
    },

    newPoint: function newPoint(x, y) {
        return new Point(x, y);
    },
    newRectangle: function newRectangle(x, y, width, height) {
        return new Rectangle(x, y, width, height);
    },

    get charMap() {
        return this.behavior.charMap;
    },

    /**
     * @summary find all column defs by name
     * @param name
     * @param columnDefs
     */
    getColDefs: function getColDefs(name) {
        var _this2 = this;

        var columnDefs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.columnDefs;

        if (!columnDefs) {
            return [];
        }
        var found = columnDefs.filter(function (cd) {
            return cd.field === name || cd.colId === name || cd.originalField === name;
        });

        columnDefs.filter(function (cd) {
            return cd.children;
        }).forEach(function (cd) {
            return [].push.apply(found, _this2.getColDefs(name, cd.children));
        });

        return found;
    },

    getColumnByName: function getColumnByName(name) {
        return this.getActiveColumns().find(function (c) {
            return c.name === name;
        });
    },

    getFieldsErrorsMessage: function getFieldsErrorsMessage() {
        var fields = Object.keys(this.behavior.getColumnsErrors());
        return 'The following fields have possible errors: ' + fields.join(', ') + '. Please review them before saving your data.';
    },

    log: function log() {
        if (this.logEnable) {
            var _console;

            (_console = console).log.apply(_console, arguments);
        }
    },


    /**
     * @summary set text value for highlighting within all values in table
     * @param text
     */
    setHighlightText: function setHighlightText(text) {
        this.properties.highLightText = text;
    }
});

/**
 * Creates an instance variable backer for use by the getters and setters described in {@link dynamicPropertyDescriptors}.
 * @constructor
 * @memberOf Hypergrid~
 * @private
 */
function Var() {
    this.gridRenderer = defaults.gridRenderer;
    this.rowHeaderCheckboxes = defaults.rowHeaderCheckboxes;
    this.rowHeaderNumbers = defaults.rowHeaderNumbers;
    this.gridBorder = defaults.gridBorder;
    this.gridBorderTop = defaults.gridBorderTop;
    this.gridBorderRight = defaults.gridBorderRight;
    this.gridBorderBottom = defaults.gridBorderBottom;
    this.gridBorderLeft = defaults.gridBorderLeft;
}

function findOrCreateContainer(boundingRect) {
    var div = document.getElementById('hypergrid'),
        used = div && !div.firstElementChild;

    if (!used) {
        div = document.createElement('div');
        setStyles(div, boundingRect, RECT_STYLES);
        document.body.appendChild(div);
    }

    return div;
}

function setStyles(el, style, keys) {
    if (style) {
        var elStyle = el.style;
        keys.forEach(function (key) {
            if (style[key] !== undefined) {
                elStyle[key] = style[key];
            }
        });
    }
}

function stringifyFunctions() {
    var self = this;
    return Object.keys(this).reduce(function (obj, key) {
        if (key !== 'toJSON') {
            obj[key] = /^function /.test(key) ? null // anon func: no point in saving because key itself is already the stringified function
            : self[key].toString() // stringify the function
            .replace(/^function anonymous\(/, 'function(') // clean up Chromium artifact
            .replace('\n/*``*/)', ')'); // clean up Chromium artifact
        }
        return obj;
    }, {});
}

function clone(value) {
    if (Array.isArray(value)) {
        return value.slice(); // clone array
    } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
        return Object.defineProperties({}, Object.getOwnPropertyDescriptors(value));
    } else {
        return value;
    }
}

function deepClone(object) {
    var result = clone(object);
    Object.keys(result).forEach(function (key) {
        var descriptor = Object.getOwnPropertyDescriptor(result, key);
        if (_typeof(descriptor.value) === 'object') {
            result[key] = deepClone(descriptor.value);
        }
    });
    return result;
}

function createCellEditor(name, props) {
    var CellEditor = cellEditors.get(name);
    if (CellEditor) {
        return new CellEditor(this, props);
    }
}

/**
 * @name plugins
 * @memberOf Hypergrid
 * @type {object}
 * @summary Hash of references to shared plug-ins.
 * @desc Dictionary of shared (pre-installed) plug-ins. Used internally, primarily to avoid reinstallations. See examples for how to reference (albeit there is normally no need to reference plugins directly).
 *
 * For the dictionary of _instance_ plugins, see {@link Hypergrid#plugins|plugins} (defined in the {@link Hypergrid#intialize|Hypergrid constructor}).
 *
 * To force reinstallation of a shared plugin delete it first:
 * ```javascript
 * delete Hypergrid.plugins.mySharedPlugin;
 * ```
 * To force reinstallation of all shared plugins:
 * ```javascript
 * Hypergrid.plugins = {};
 * ```
 * @example
 * var allSharedPlugins = Hypergrid.plugins;
 * var mySharedPlugin = Hypergrid.plugins.mySharedPlugin;
 */
Hypergrid.plugins = {};

/**
 * @name localization
 * @memberOf Hypergrid
 * @type {object}
 * @summary Shared localization defaults for all grid instances.
 * @desc These property values are overridden by those supplied in the `Hypergrid` constructor's `options.localization`.
 * @property {string|string[]} [locale] - The default locale to use when an explicit `locale` is omitted from localizer constructor calls. Passed to Intl.NumberFormat` and `Intl.DateFormat`. See {@ https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation|Locale identification and negotiation} for more information. Omitting will use the runtime's local language and region.
 * @property {object} [numberOptions] - Options passed to `Intl.NumberFormat` for creating the basic "number" localizer.
 * @property {object} [dateOptions] - Options passed to `Intl.DateFormat` for creating the basic "date" localizer.
 */
Hypergrid.localization = {
    locale: 'en-US',
    numberOptions: { maximumFractionDigits: 0 }
};

// mix in the mixins

Hypergrid.mixIn = Hypergrid.prototype.mixIn;
Hypergrid.mixIn(require('./themes').sharedMixin);

Hypergrid.prototype.mixIn(require('./themes').mixin);
Hypergrid.prototype.mixIn(require('./events').mixin);
Hypergrid.prototype.mixIn(require('./dataModel/events').mixin);
Hypergrid.prototype.mixIn(require('./selection').mixin);
Hypergrid.prototype.mixIn(require('./scrolling').mixin);

// deprecated module access

function pleaseUse(requireString, module) {
    if (!pleaseUse.warned[requireString]) {
        var key = requireString.match(/\w+$/)[0];
        console.warn('Reference to ' + key + ' external module using' + ' `Hypergrid.' + key + '.` has been deprecated as of v3.0.0 in favor of' + ' `require(\'' + requireString + '\')` from within a Hypergrid Client Module' + ' (otherwise use `Hypergrid.require(...)`) and will be removed in a future release.' + ' See https://github.com/fin-hypergrid/core/wiki/Client-Modules#internal-modules.');
        pleaseUse.warned[requireString] = true;
    }
    return module;
}

pleaseUse.warned = {};

Object.defineProperties(Hypergrid, {
    Base: {
        get: function get() {
            return pleaseUse('fin-hypergrid/src/Base', require('../Base'));
        }
    },
    images: {
        get: function get() {
            return pleaseUse('fin-hypergrid/images', require('../../images'));
        }
    }
});

/**
 * @summary List of grid instances.
 * @desc Added in {@link Hypergrid constructor}; removed in {@link Hypergrid#terminate terminate()}.
 * Used in themes.js.
 * @type {Hypergrid[]}
 */
Hypergrid.grids = [];

/** @name defaults
 * @memberOf Hypergrid
 * @type {object}
 * @summary The `defaults` layer of the Hypergrid properties hierarchy.
 * @desc Default values for all Hypergrid properties, including grid-level properties and column property defaults.
 *
 * Synonym: `properties`
 * Properties are divided broadly into two categories:
 * * Style (a.k.a. "lnf" for "look'n'feel") properties
 * * All other properties.
 */
Hypergrid.defaults = Hypergrid.properties = defaults;

// Define modules namespace and install overridable external modules.
// Hypergrid core code references them via this object  rather than require()  where used.
// Note that `modules` also supports the Hypergrid Module Loader (included only with the build file).
Hypergrid.modules = modules;

module.exports = Hypergrid;

},{"../../css":1,"../../images":3,"../Base":17,"../behaviors/Behavior":33,"../behaviors/Local":35,"../cellEditors":52,"../cellRenderers":62,"../defaults":65,"../lib/Canvas":87,"../lib/Localization":89,"../lib/SelectionModel":91,"../lib/dynamicProperties":94,"../lib/polyfills":99,"../renderer":109,"./api":23,"./columnApi":24,"./dataModel/events":25,"./events":27,"./modules":29,"./scrolling":30,"./selection":31,"./themes":32,"inject-stylesheet-template":10,"object-iterators":12,"rectangular":14}],29:[function(require,module,exports){
'use strict';

/*
 * This module is the namespace of loaded external modules known to `Hypergrid.require`,
 * which may include loaded application modules, datasource modules, and plug-in modules.
 *
 * The pre-loaded external modules listed below can conveniently be overridden by the
 * application developer by loading a new module using the same key.
 *
 * For example, to override `finbars` with another compatible module (that conforms to the
 * same interface), just assign it like so: `Hypergrid.modules.Scrollbar = myFinbarReplacement;`
 *
 * Hypergrid usage of these modules should reference the values defined here to be sure to
 * get any developer overrides. Do _not_ use `require` to load them directly!
 */

module.exports = {
  Scrollbar: require('../Finbars/index'),
  templater: require('mustache') // interface  la mustache: { render: function(template, context) }
};

},{"../Finbars/index":21,"mustache":11}],30:[function(require,module,exports){
'use strict';
/* eslint-env browser */

var Scrollbar = require('./modules').Scrollbar;

/**
 * @summary Scrollbar support.
 * @desc Hypergrid/index.js mixes this module into its prototype.
 * @mixin
 */
exports.mixin = {

    /**
     * A float value between 0.0 - 1.0 of the vertical scroll position.
     * @type {number}
     * @memberOf Hypergrid#
     */
    vScrollValue: 0,

    /**
     * A float value between 0.0 - 1.0 of the horizontal scroll position.
     * @type {number}
     * @memberOf Hypergrid#
     */
    hScrollValue: 0,

    /**
     * @property {FinBar} sbVScroller - An instance of {@link https://github.com/openfin/finbars|FinBar}.
     * @memberOf Hypergrid#
     */
    sbVScroller: null,

    /**
     * The previous value of sbVScrollVal.
     * @type {number}
     * @memberOf Hypergrid#
     */
    sbPrevVScrollValue: 0,

    /**
     * The previous value of sbHScrollValue.
     * @type {number}
     * @memberOf Hypergrid#
     */
    sbPrevHScrollValue: 0,

    scrollingNow: false,

    /**
     * @memberOf Hypergrid#
     * @summary Set for `scrollingNow` field.
     * @param {boolean} isItNow - The type of event we are interested in.
     */
    setScrollingNow: function setScrollingNow(isItNow) {
        this.scrollingNow = isItNow;
    },

    /**
     * @memberOf Hypergrid#
     * @returns {boolean} The `scrollingNow` field.
     */
    isScrollingNow: function isScrollingNow() {
        return this.scrollingNow;
    },

    /**
     * @memberOf Hypergrid#
     * @summary Scroll horizontal and vertically by the provided offsets.
     * @param {number} offsetX - Scroll in the x direction this much.
     * @param {number} offsetY - Scroll in the y direction this much.
     */
    scrollBy: function scrollBy(offsetX, offsetY) {
        this.scrollHBy(offsetX);
        this.scrollVBy(offsetY);
    },

    /**
     * @memberOf Hypergrid#
     * @summary Scroll vertically by the provided offset.
     * @param {number} offsetY - Scroll in the y direction this much.
     */
    scrollVBy: function scrollVBy(offsetY) {
        var max = this.sbVScroller.range.max;
        var oldValue = this.vScrollValue;
        var oldOffset = this.getVScrollValue();
        var rowHeight = this.behavior.getRowHeight(Math.max(0, oldOffset + offsetY));
        var newValue = Math.min(max, oldValue + offsetY * rowHeight);
        if (newValue !== oldValue) {
            this.setVScrollValue(newValue);
        }
    },

    /**
     * @memberOf Hypergrid#
     * @summary Scroll horizontally by the provided offset.
     * @param {number} offsetX - Scroll in the x direction this much.
     */
    scrollHBy: function scrollHBy(offsetX) {
        var max = this.sbHScroller.range.max;
        var oldValue = this.hScrollValue;
        var oldOffset = this.getHScrollValue();
        var newValue = Math.min(max, oldValue + offsetX * this.behavior.getColumnWidth(Math.max(0, oldOffset + offsetX)));
        if (newValue !== oldValue) {
            this.setHScrollValue(newValue);
        }
    },

    scrollToMakeVisible: function scrollToMakeVisible(column, row) {
        var _renderer$dataWindow = this.renderer.dataWindow,
            origin = _renderer$dataWindow.origin,
            corner = _renderer$dataWindow.corner;
        var _properties = this.properties,
            fixedColumnCount = _properties.fixedColumnCount,
            fixedRowCount = _properties.fixedRowCount;


        var delta = void 0;
        var pxDelta = 0;

        // scroll only if target not in fixed columns
        if (column >= fixedColumnCount) {
            delta = column - origin.x;
            // target is to left of scrollable columns; negative delta scrolls left
            if (delta < 0) {
                pxDelta = 0;
                for (var i = 0; i <= Math.abs(delta) + 1; i++) {
                    pxDelta += this.getColumnWidth(origin.x - i);
                }

                this.sbHScroller.index -= pxDelta;
            }

            delta = column - corner.x;
            if (delta >= 0) {
                pxDelta = 0;
                // scroll more than just one cut column
                for (var _i = 0; _i <= Math.abs(delta) + 2; _i++) {
                    pxDelta += this.getColumnWidth(corner.x - _i);
                }

                this.sbHScroller.index += pxDelta;
            }
        }

        if (this.sbHScroller.index <= this.getColumnWidth(0)) {
            this.sbHScroller.index = 0;
        }

        // scroll only if target not in fixed rows
        if (row >= fixedRowCount) {
            delta = row - origin.y;
            // target is above scrollable rows; negative delta scrolls up
            if (delta < 0) {
                var deltaPercent = (Math.abs(delta) + 2) / this.getRowCount();
                pxDelta = this.sbVScroller.max * deltaPercent;

                if (pxDelta < this.properties.defaultRowHeight * 3) {
                    this.sbVScroller.index -= pxDelta;
                } else {
                    delta = row - corner.y;

                    var _deltaPercent = (Math.abs(delta) + 2) / this.getRowCount();
                    pxDelta = this.sbVScroller.max * _deltaPercent;
                    this.sbVScroller.index -= pxDelta;
                }
            }

            delta = row - corner.y;
            if (delta >= 0) {
                var _deltaPercent2 = (delta + 2) / this.getRowCount();
                pxDelta = this.sbVScroller.max * _deltaPercent2;

                if (pxDelta < this.properties.defaultRowHeight * 3) {
                    this.sbVScroller.index += pxDelta;
                } else {
                    delta = origin.y - row;

                    var _deltaPercent3 = (Math.abs(delta) + 2) / this.getRowCount();
                    pxDelta = this.sbVScroller.max * _deltaPercent3;
                    this.sbVScroller.index += pxDelta;
                }
            }
        }

        if (this.sbVScroller.index <= this.getRowHeight(0)) {
            this.sbVScroller.index = 0;
        }
    },

    selectCellAndScrollToMakeVisible: function selectCellAndScrollToMakeVisible(c, r) {
        this.scrollToMakeVisible(c, r);
        this.selectCell(c, r, true);
    },

    /**
     * @summary binary search of cell with needed scroll parameters
     * @param scrollValue - scroll value in pixels
     * @param from - first cell index for searching
     * @param to - last cell index for searching
     * @param checkFunction - function for checking height of horizontal or certical scroll
     */
    findCellByScrollValue: function findCellByScrollValue(scrollValue, from, to, checkFunction) {
        var search = Math.round((from + to) / 2);

        if (search === from || search === to) {
            return from;
        }

        var currentHeight = checkFunction.call(this.behavior, search);

        if (currentHeight > scrollValue) {
            return this.findCellByScrollValue(scrollValue, from, search, checkFunction);
        } else {
            return this.findCellByScrollValue(scrollValue, search, to, checkFunction);
        }
    },

    /**
     * @memberOf Hypergrid#
     * @desc Set the vertical scroll value.
     * @param {number} newValue - The new scroll value.
     */
    setVScrollValue: function setVScrollValue(newValue) {
        var _this = this;

        newValue = Math.min(this.sbVScroller.range.max, Math.max(0, Math.round(newValue)));
        if (newValue !== this.vScrollValue) {
            this.behavior.setScrollPositionY(newValue);
            this.behavior.changed();
            var oldY = this.vScrollValue;

            this.vScrollValue = newValue;
            this.scrollValueChangedNotification();
            setTimeout(function () {
                // self.sbVRangeAdapter.subjectChanged();
                _this.fireScrollEvent('fin-scroll-y', oldY, newValue);
            });
        }
        // update scrollbar
        if (this.sbVScroller.index !== newValue) {
            this.sbVScroller.index = newValue;
        }
    },

    /**
     * @memberOf Hypergrid#
     * @return {number} The vertical scroll value.
     */
    getVScrollValue: function getVScrollValue() {
        return this.findCellByScrollValue(this.vScrollValue, 0, this.getRowCount(), this.behavior.getRowsHeight);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Set the horizontal scroll value.
     * @param {number} newValue - The new scroll value.
     */
    setHScrollValue: function setHScrollValue(newValue) {
        var self = this;
        newValue = Math.min(this.sbHScroller.range.max, Math.max(0, Math.round(newValue)));
        if (newValue !== this.hScrollValue) {
            this.behavior.setScrollPositionX(newValue);
            this.behavior.changed();
            var oldX = this.hScrollValue;
            this.hScrollValue = newValue;
            this.scrollValueChangedNotification();

            if (this.sbHScroller) {
                this.sbHScroller.index = newValue;
            }

            setTimeout(function () {
                //self.sbHRangeAdapter.subjectChanged();
                self.fireScrollEvent('fin-scroll-x', oldX, newValue);
                //self.synchronizeScrollingBoundaries(); // todo: Commented off to prevent the grid from bouncing back, but there may be repercussions...
            });
        }
        // update scrollbar
        if (this.sbHScroller.index !== newValue) {
            this.sbHScroller.index = newValue;
        }
    },

    /**
     * @memberOf Hypergrid#
     * @returns The horizontal scroll value.
     */
    getHScrollValue: function getHScrollValue() {
        return this.findCellByScrollValue(this.hScrollValue, 0, this.getColumnCount(), this.behavior.getColumnsWidth);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Initialize the scroll bars.
     */
    initScrollbars: function initScrollbars() {
        if (this.sbHScroller && this.sbVScroller) {
            return;
        }

        var self = this;

        var horzBar = new Scrollbar({
            orientation: 'horizontal',
            onBarVisibilityChanged: function onBarVisibilityChanged(isVisible) {
                self.properties.canvasHeightOffset = isVisible ? Number(window.getComputedStyle(this.mountDiv).height.replace('px', '')) : 0;
                self.canvas.resize(false);
            },
            onchange: self.setHScrollValue.bind(self),
            cssStylesheetReferenceElement: this.div,
            paging: {
                up: self.pageLeft.bind(self),
                down: self.pageRight.bind(self)
            }
        });

        var vertBar = new Scrollbar({
            orientation: 'vertical',
            onBarVisibilityChanged: function onBarVisibilityChanged(isVisible) {
                self.properties.canvasWidthOffset = isVisible ? Number(window.getComputedStyle(this.mountDiv).width.replace('px', '')) : 0;
                self.canvas.resize(false);
            },
            onchange: self.setVScrollValue.bind(self),
            paging: {
                up: self.pageUp.bind(self),
                down: self.pageDown.bind(self)
            }
        });

        this.sbHScroller = horzBar;
        this.sbVScroller = vertBar;

        var hPrefix = this.properties.hScrollbarClassPrefix;
        var vPrefix = this.properties.vScrollbarClassPrefix;

        if (hPrefix && hPrefix !== '') {
            this.sbHScroller.classPrefix = hPrefix;
        }

        if (vPrefix && vPrefix !== '') {
            this.sbVScroller.classPrefix = vPrefix;
        }

        this.div.appendChild(horzBar.mountDiv);
        this.div.appendChild(vertBar.mountDiv);

        this.synchronizeScrollbarsVisualization();
    },

    destroyScrollbars: function destroyScrollbars() {
        if (this.sbHScroller) {
            this.sbHScroller.remove();
            delete this.sbHScroller;
        }
        if (this.sbVScroller) {
            this.sbVScroller.remove();
            delete this.sbVScroller;
        }
    },

    synchronizeScrollbarsVisualization: function synchronizeScrollbarsVisualization() {
        if (this.sbHScroller) {
            this.sbHScroller.shortenEndByValue('leading', this.getHScrollbarLeftMargin()).shortenEndByValue('trailing', this.getHScrollbarRightMargin() - 1).resize(null, null, this.getFullContentWidth());

            this.sbHScroller.style = this.properties.scrollbarHStyle;
            this.sbHScroller.thumbStyle = this.properties.scrollbarHThumbStyle;
            this.sbHScroller.mountStyle = this.properties.scrollbarHMountStyle;
        }
        if (this.sbVScroller) {
            this.sbVScroller.shortenEndByValue('leading', this.getVScrollbarTopMargin()).shortenEndByValue('trailing', this.getVScrollbarBottomMargin() - 1).resize(null, null, this.getFullContentHeight());

            this.sbVScroller.style = this.properties.scrollbarVStyle;
            this.sbVScroller.thumbStyle = this.properties.scrollbarVThumbStyle;
            this.sbVScroller.mountStyle = this.properties.scrollbarVMountStyle;
        }
    },

    getHScrollbarLeftMargin: function getHScrollbarLeftMargin() {
        var res = 0;
        var visibleColumns = this.renderer.visibleColumns;
        res -= this.properties.gridLinesV ? this.properties.gridLinesWidth : 0;
        res += this.properties.gridBorderLeft ? this.properties.gridLinesWidth : 0;

        var neededColumn = visibleColumns[this.behavior.rowColumnIndex];
        res += this.properties.rowHeaderNumbers && neededColumn ? neededColumn.right : 0;

        for (var i = 0; i < this.properties.fixedColumnCount; i++) {
            if (i !== this.behavior.rowColumnIndex) {
                res += this.getColumnWidth(i);
            }
        }

        res += this.properties.fixedColumnCount ? this.properties.fixedLinesVWidth : 0;

        return res;
    },

    getHScrollbarRightMargin: function getHScrollbarRightMargin() {
        var res = -1;

        if (this.properties.scrollbarVStyle && this.properties.scrollbarVStyle.width) {
            res += this.properties.scrollbarVStyle.width;
        }

        return res;
    },

    getVScrollbarTopMargin: function getVScrollbarTopMargin() {
        var res = void 0;
        var rowIndex = this.properties.fixedRowCount;

        var row = this.renderer.visibleRows[rowIndex];
        if (!row) {
            row = this.renderer.visibleRows[0];
        }
        res = row ? row.bottom : 0;

        res -= this.properties.gridLinesH ? this.properties.gridLinesWidth : 0;

        res += this.properties.fixedRowCount ? this.properties.fixedLinesHWidth : 0;

        res += this.properties.gridBorderTop ? this.properties.fixedLinesHWidth : 0;

        // to fully implement google sheets style
        res += 1;

        return res;
    },

    getVScrollbarBottomMargin: function getVScrollbarBottomMargin() {
        var res = -1;

        if (this.properties.scrollbarHStyle && this.properties.scrollbarHStyle.height) {
            res += this.properties.scrollbarHStyle.height;
        }

        return res;
    },

    getFullContentWidth: function getFullContentWidth() {
        var res = 0;

        for (var i = 0; i <= this.getColumnCount(); i++) {
            res += this.getColumnWidth(i);
        }

        return res;
    },
    getFullContentHeight: function getFullContentHeight() {
        var res = 0;

        for (var i = 0; i <= this.getRowCount(); i++) {
            res += this.getRowHeight(i);
        }

        return res;
    },
    /**
     * @memberOf Hypergrid#
     * @desc Scroll values have changed, we've been notified.
     */
    setVScrollbarValues: function setVScrollbarValues(max) {
        this.sbVScroller.range = {
            min: 0,
            max: max
        };
    },

    setHScrollbarValues: function setHScrollbarValues(max) {
        this.sbHScroller.range = {
            min: 0,
            max: max
        };
    },

    scrollValueChangedNotification: function scrollValueChangedNotification() {
        if (this.hScrollValue !== this.sbPrevHScrollValue || this.vScrollValue !== this.sbPrevVScrollValue) {
            this.sbPrevHScrollValue = this.hScrollValue;
            this.sbPrevVScrollValue = this.vScrollValue;

            if (this.cellEditor) {
                this.cellEditor.scrollValueChangedNotification();
            }

            // if (this.properties.onScrollEndLimitTrigger > 0 && this.sbVScroller.range.max - this.vScrollValue < this.properties.onScrollEndLimitTrigger) {
            //     // datadoc infinite scroll
            //     if (this.api.datasource && !this.scrollTriggered) {
            //         this.api.setDatasource(this.api.datasource);
            //     }
            //
            //     this.scrollTriggered = true;
            // } else {
            //     this.scrollTriggered = false;
            // }

            this.computeCellsBounds();
        }
    },

    /**
     * @memberOf Hypergrid#
     * @desc The data dimensions have changed, or our pixel boundaries have changed.
     * Adjust the scrollbar properties as necessary.
     */
    synchronizeScrollingBoundaries: function synchronizeScrollingBoundaries() {
        var numColumns = this.getColumnCount();
        var numRows = this.getRowCount();

        var bounds = this.getBounds();
        if (!bounds) {
            return;
        }

        var scrollableWidth = bounds.width - this.behavior.getFixedColumnsMaxWidth();
        for (var columnsWidth = 0, lastPageColumnCount = 0; lastPageColumnCount < numColumns && columnsWidth < scrollableWidth; lastPageColumnCount++) {
            columnsWidth += this.getColumnWidth(numColumns - lastPageColumnCount - 1);
        }
        if (columnsWidth > scrollableWidth) {
            lastPageColumnCount--;
        }

        var scrollableHeight = this.renderer.getVisibleScrollHeight();
        for (var rowsHeight = 0, lastPageRowCount = 0; lastPageRowCount < numRows && rowsHeight < scrollableHeight; lastPageRowCount++) {
            rowsHeight += this.getRowHeight(numRows - lastPageRowCount - 1);
        }
        if (rowsHeight > scrollableHeight) {
            lastPageRowCount--;
        }

        // inform scroll bars
        if (this.sbHScroller) {
            var hMax = Math.max(0, this.behavior.getColumnsWidth(this.behavior.getActiveColumnCount() - lastPageColumnCount + 1) - this.behavior.getFixedColumnsWidth());
            hMax += this.behavior.getColumnWidth(this.behavior.getActiveColumnCount());
            this.setHScrollbarValues(hMax);
            this.setHScrollValue(Math.min(this.hScrollValue, hMax));
        }
        if (this.sbVScroller) {
            var vMax = Math.max(0, this.behavior.getRowsHeight(this.behavior.getRowCount() - lastPageRowCount + 2) - this.behavior.getFixedRowsHeight()); // todo determine why 2
            this.setVScrollbarValues(vMax);
            this.setVScrollValue(Math.min(this.vScrollValue, vMax));
        }

        this.computeCellsBounds();

        // schedule to happen *after* the repaint
        setTimeout(this.synchronizeScrollbarsVisualization.bind(this));
    },

    /**
     * @memberOf Hypergrid#
     * @desc Scroll up one full page.
     * @returns {number}
     */
    pageUp: function pageUp() {
        var rowNum = this.renderer.getPageUpRow();
        var rowNumPixels = this.behavior.getRowsHeight(rowNum);
        this.setVScrollValue(rowNumPixels);
        return rowNumPixels;
    },

    /**
     * @memberOf Hypergrid#
     * @desc Scroll down one full page.
     * @returns {number}
     */
    pageDown: function pageDown() {
        var rowNum = this.renderer.getPageDownRow();
        var rowNumPixels = this.behavior.getRowsHeight(rowNum);
        this.setVScrollValue(rowNumPixels);
        return rowNumPixels;
    },

    /**
     * @memberOf Hypergrid#
     * @desc Scroll left one full page.
     * @returns {number}
     */
    pageLeft: function pageLeft() {
        var bounds = this.getBounds();
        var currentScroll = this.behavior.getScrollPositionX();
        var scrollableWidth = bounds.width - this.behavior.getFixedColumnsMaxWidth();
        var leftPixel = currentScroll - scrollableWidth;
        this.setHScrollValue(leftPixel);
        return leftPixel;
    },

    /**
     * @memberOf Hypergrid#
     * @desc Scroll right one full page.
     * @returns {number}
     */
    pageRight: function pageRight() {
        var bounds = this.getBounds();
        var currentScroll = this.behavior.getScrollPositionX();
        var scrollableWidth = bounds.width - this.behavior.getFixedColumnsMaxWidth();
        var rightPixel = currentScroll + scrollableWidth;
        this.setHScrollValue(rightPixel);
        return rightPixel;
    }
};

},{"./modules":29}],31:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Rectangle = require('rectangular').Rectangle;

/**
 * Hypergrid/index.js mixes this module into its prototype.
 * @mixin
 */
exports.mixin = {
    selectionInitialize: function selectionInitialize() {
        var grid = this;

        /** for use by fin-selection-changed, fin-row-selection-changed, fin-column-selection-changed
         * @memberOf Hypergrid#
         * @private
         */
        this.selectionDetailGetters = {
            get rows() {
                return grid.getSelectedRows();
            },
            get columns() {
                return grid.getSelectedColumns();
            },
            get selections() {
                return grid.selectionModel.getSelections();
            }
        };

        /**
         * for use by fin-context-menu, fin-mouseup, fin-mousedown
         * @memberOf Hypergrid#
         * @private
         */
        this.selectionDetailGetterDescriptors = Object.getOwnPropertyDescriptors(this.selectionDetailGetters);
    },

    /**
     * @memberOf Hypergrid#
     * @returns {boolean} We have any selections.
     */
    hasSelections: function hasSelections() {
        if (!this.getSelectionModel) {
            return; // were not fully initialized yet
        }
        return this.selectionModel.hasSelections();
    },

    /**
     * @memberOf Hypergrid#
     * @returns {string} Tab separated value string from the selection and our data.
     */
    getSelectionAsTSV: function getSelectionAsTSV() {
        var sm = this.selectionModel;
        if (sm.hasSelections()) {
            return this.getMatrixSelectionAsTSV(this.getSelectionMatrix());
        } else if (sm.hasRowSelections()) {
            return this.getMatrixSelectionAsTSV(this.getRowSelectionMatrix());
        } else if (sm.hasColumnSelections()) {
            return this.getMatrixSelectionAsTSV(this.getColumnSelectionMatrix());
        }
    },

    getMatrixSelectionHtmlStyles: function getMatrixSelectionHtmlStyles(props) {
        return '<style type="text/css">\ntable {\nborder-collapse: collapse;\nfont: 13px "Helvetica Neue",Helvetica,Arial,sans-serif;\n}\ntd {\nborder: ' + props.gridLinesWidth + 'px solid ' + props.gridLinesColor + ';\nmax-width: ' + props.maximumColumnWidth + 'px;\npadding: ' + props.cellPadding + 'px ' + props.cellPaddingLeft + 'px;\n}\na {\ncolor: ' + props.linkColor + ';\ntext-decoration: underline;\n}\n.header {\nfont: ' + props.columnHeaderFontBold + ';\n}\n.prefix {\nfont: ' + props.columnTitlePrefixFont + ';\ncolor: ' + props.columnTitlePrefixColor + ';\npadding-right: ' + props.columnTitlePrefixRightSpace + 'px;\n}\n.postfix {\ncolor: ' + props.cellValuePostfixColor + ';\nfont: ' + props.cellValuePostfixFont + ';\npadding-left: ' + props.cellValuePostfixLeftOffset + 'px;\n}\nmark {\nbackground-color: ' + props.highlightColor + '\n}\n</style>';
    },

    getMatrixSelectionAsTSV: function getMatrixSelectionAsTSV(selections) {
        var text = '';
        var html = '';

        // only use the data from the last selection
        if (selections.length) {

            var props = this.properties;

            html = this.getMatrixSelectionHtmlStyles(props) + '<table>';

            var width = selections.length,
                height = selections[0].length,
                lastCol = width - 1,

            //Whitespace will only be added on non-singular rows, selections
            whiteSpaceDelimiterForRow = height > 1 ? '\n' : '';

            for (var h = 0; h < height; h++) {
                for (var w = 0; w < width; w++) {
                    var val = selections[w][h];

                    var _text = (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? val.text : val;
                    text += (_text || '') + (w < lastCol ? '\t' : whiteSpaceDelimiterForRow);

                    if (w === 0) {
                        html += '<tr>';
                    }
                    var _html = (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? val.html : val;
                    if (_html !== undefined) {
                        html += '<td ' + (val.colspan ? 'colspan="' + (val.colspan + 1) + '"' : '') + ' ' + (val.rowspan ? 'rowspan="' + (val.rowspan + 1) + '"' : '') + '>' + (_html || '') + '</td>';
                        if (w === lastCol) {
                            html += '</tr>';
                        }
                    }
                }
            }

            html += '</table>';
        }

        return { text: text, html: html };
    },

    /**
     * @memberOf Hypergrid#
     * @desc Clear all the selections.
     */
    clearSelections: function clearSelections() {
        this.selectionModel.clear(this.properties.keepRowSelections);
        this.clearMouseDown();
    },

    /**
     * @memberOf Hypergrid#
     * @desc Clear the most recent selection.
     */
    clearMostRecentSelection: function clearMostRecentSelection() {
        this.selectionModel.clearMostRecentSelection(this.properties.keepRowSelections);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Clear the most recent column selection.
     */
    clearMostRecentColumnSelection: function clearMostRecentColumnSelection() {
        this.selectionModel.clearMostRecentColumnSelection();
    },

    /**
     * @memberOf Hypergrid#
     * @desc Clear the most recent row selection.
     */
    clearMostRecentRowSelection: function clearMostRecentRowSelection() {
        this.selectionModel.clearMostRecentRowSelection();
    },

    clearRowSelection: function clearRowSelection() {
        this.selectionModel.clearRowSelection();
    },

    /**
     * @memberOf Hypergrid#
     * @summary Select given region.
     * @param {number} ox - origin x
     * @param {number} oy - origin y
     * @param {number} ex - extent x
     * @param {number} ex - extent y
     */
    select: function select(ox, oy, ex, ey) {
        if (ox < 0 || oy < 0) {
            //we don't select negative area
            //also this means there is no origin mouse down for a selection rect
            return;
        }
        this.selectionModel.select(ox, oy, ex, ey);
    },

    /**
     * @memberOf Hypergrid#
     * @returns {boolean} Given point is selected.
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     */
    isSelected: function isSelected(x, y) {
        return this.selectionModel.isSelected(x, y);
    },

    /**
     * @memberOf Hypergrid#
     * @returns {boolean} The given column is selected anywhere in the entire table.
     * @param {number} y - The row index.
     */
    isCellSelectedInRow: function isCellSelectedInRow(y) {
        return this.selectionModel.isCellSelectedInRow(y);
    },

    /**
     * @memberOf Hypergrid#
     * @returns {boolean} The given row is selected anywhere in the entire table.
     * @param {number} x - The column index.
     */
    isCellSelectedInColumn: function isCellSelectedInColumn(x) {
        return this.selectionModel.isCellSelectedInColumn(x);
    },

    /**
     * @param {boolean|number[]|string[]} [hiddenColumns=false] - _Per {@link Hypergrid~getColumns}._
     * @returns {{}}
     * @memberOf Hypergrid#
     */
    getRowSelection: function getRowSelection(hiddenColumns) {
        var dataModel = this.behavior.dataModel,
            selectedRowIndexes = this.selectionModel.getSelectedRows(),
            columns = getColumns.call(this, hiddenColumns),
            result = {};

        for (var c = 0, C = columns.length; c < C; c++) {
            var column = columns[c],
                rows = result[column.name] = new Array(selectedRowIndexes.length);
            selectedRowIndexes.forEach(getValue);
        }

        function getValue(selectedRowIndex, j) {
            var dataRow = dataModel.getRow(selectedRowIndex);
            rows[j] = valOrFunc(dataRow, column);
        }

        return result;
    },

    /**
     * @param {boolean|number[]|string[]} [hiddenColumns=false] - _Per {@link Hypergrid~getColumns}._
     * @returns {Array}
     * @memberOf Hypergrid#
     */
    getRowSelectionMatrix: function getRowSelectionMatrix(hiddenColumns) {
        var dataModel = this.behavior.dataModel,
            selectedRowIndexes = this.selectionModel.getSelectedRows(),
            columns = getColumns.call(this, hiddenColumns),
            result = new Array(columns.length);

        for (var c = 0, C = columns.length; c < C; c++) {
            var column = columns[c];
            result[c] = new Array(selectedRowIndexes.length);
            selectedRowIndexes.forEach(getValue);
        }

        function getValue(selectedRowIndex, r) {
            var dataRow = dataModel.getRow(selectedRowIndex);
            result[c][r] = valOrFunc(dataRow, column);
        }

        return result;
    },

    getColumnSelectionMatrix: function getColumnSelectionMatrix() {
        var behavior = this.behavior,
            dataModel = behavior.dataModel,
            headerRowCount = this.getHeaderRowCount(),
            selectedColumnIndexes = this.getSelectedColumns(),
            numRows = this.getRowCount(),
            result = new Array(selectedColumnIndexes.length);

        selectedColumnIndexes.forEach(function (selectedColumnIndex, c) {
            var column = behavior.getActiveColumn(selectedColumnIndex),
                values = result[c] = new Array(numRows);

            for (var r = headerRowCount; r < numRows; r++) {
                var dataRow = dataModel.getRow(r);
                values[r] = valOrFunc(dataRow, column);
            }
        });

        return result;
    },

    getColumnSelection: function getColumnSelection() {
        var behavior = this.behavior,
            dataModel = behavior.dataModel,
            headerRowCount = this.getHeaderRowCount(),
            selectedColumnIndexes = this.getSelectedColumns(),
            result = {},
            rowCount = this.getRowCount();

        selectedColumnIndexes.forEach(function (selectedColumnIndex) {
            var column = behavior.getActiveColumn(selectedColumnIndex),
                values = result[column.name] = new Array(rowCount);

            for (var r = headerRowCount; r < rowCount; r++) {
                var dataRow = dataModel.getRow(r);
                values[r] = valOrFunc(dataRow, column);
            }
        });

        return result;
    },

    getSelection: function getSelection() {
        var behavior = this.behavior,
            dataModel = behavior.dataModel,
            selections = this.getSelections(),
            rects = new Array(selections.length);

        selections.forEach(getRect);

        function getRect(selectionRect, i) {
            var rect = normalizeRect(selectionRect),
                colCount = rect.extent.x + 1,
                rowCount = rect.extent.y + 1,
                columns = {};

            for (var c = 0, x = rect.origin.x; c < colCount; c++, x++) {
                var column = behavior.getActiveColumn(x),
                    values = columns[column.name] = new Array(rowCount);

                for (var r = 0, y = rect.origin.y; r < rowCount; r++, y++) {
                    var dataRow = dataModel.getRow(y);
                    values[r] = valOrFunc(dataRow, column);
                }
            }

            rects[i] = columns;
        }

        return rects;
    },

    getSelectionMatrix: function getSelectionMatrix() {
        var _this = this;

        var behavior = this.behavior,
            dataModel = this.behavior.dataModel;

        var selections = this.getSelections();

        var selectionRect = normalizeRect(selections[selections.length - 1]);

        var colCount = selectionRect.extent.x + 1;
        var rowCount = selectionRect.extent.y + 1;
        var rows = [];

        var _loop = function _loop(c, x) {
            var colProps = behavior.getColumnProperties(x);
            var columnName = dataModel.getColumnName(x);
            var searchType = behavior.getColumn(x).searchType;
            var isAggregationTreeColumn = columnName === '$$aggregation';
            var values = rows[c] = new Array(rowCount);
            var alreadyCopied = [];

            var getHeaderValue = function getHeaderValue(x, y) {
                alreadyCopied.push(y);
                if (dataModel.isRenderSkipNeeded(x, y)) {
                    return { text: '' }; // no 'html' key because this cell will be merged with another onw
                } else {
                    var text = '';
                    var html = '';

                    // add prefix
                    if (colProps.colDef && colProps.colDef.headerPrefix && !dataModel.getDefinedCellProperties(x, y).ignoreValuePrefix) {
                        text += colProps.colDef.headerPrefix + ' ';
                        html += '<span class="prefix">' + colProps.colDef.headerPrefix + '</span> ';
                    }

                    // add value
                    var val = (dataModel.getValue(x, y) || '').trim();
                    text += val;
                    html += '<span class="header">' + val + '</span>';

                    // add postfix
                    var postfix = dataModel.getCount(x, y);
                    if (postfix) {
                        text += ' (' + postfix + ')';
                        html += ' <span class="postfix">(' + postfix + ')</span>';
                    }

                    return {
                        text: text.trim(),
                        html: '<div>' + html + '</div>',
                        colspan: dataModel.getColspan(x, y),
                        rowspan: dataModel.getRowspan(x, y)
                    };
                }
            };

            for (var r = 0, y = selectionRect.origin.y; r < rowCount; r++, y++) {
                if (behavior.getRowProperties(y).headerRow) {
                    values[r] = getHeaderValue(x, y);
                } else {
                    var val = dataModel.getValue(x, y);

                    if (val || val === false || val === 0 || val === null) {
                        var color = _this.properties[isAggregationTreeColumn ? 'linkColor' : 'color'];

                        var text = '';
                        var html = '';

                        // add value
                        var isValueUrl = dataModel.isValueUrl(val);
                        val = _this.formatValue(columnName, val, false);
                        if (_this.properties.highLightText && searchType) {
                            val = dataModel.getHighlightedValue(val, _this.properties.highLightText, searchType);
                        }
                        text += val;
                        html += '<span style="color: ' + color + '; ' + (isAggregationTreeColumn ? 'text-decoration: underline;' : '') + '">' + (isValueUrl ? '<a href="' + val + '">' + val + '</a>' : val) + '</span>';

                        // add postfix
                        var postfix = isAggregationTreeColumn ? behavior.getAggregationChildCountByIndex(y) : dataModel.getCount(x, y);
                        if (postfix) {
                            text += ' (' + postfix + ')';
                            html += '<span class="postfix">(' + postfix + ')</span>';
                        }

                        values[r] = {
                            text: text.trim(),
                            html: '<div style="text-align: ' + (colProps.halign || 'left') + '">' + html + '</div>'
                        };
                    } else {
                        values[r] = '';
                    }
                }
            }

            if (_this.copyIncludeHeaders) {
                var _y = 0;
                var headerValues = [];

                while (behavior.getRowProperties(_y).headerRow) {
                    if (!alreadyCopied.includes(_y)) {
                        headerValues.push(getHeaderValue(x, _y));
                    }
                    ++_y;
                }

                if (headerValues.length > 0) {
                    [].unshift.apply(values, headerValues);
                }
            }
        };

        for (var c = 0, x = selectionRect.origin.x; c < colCount; c++, x++) {
            _loop(c, x);
        }

        return rows;
    },

    selectCell: function selectCell(x, y, silent) {
        this.selectionModel.clear(this.properties.keepRowSelections);
        this.selectionModel.select(x, y, 0, 0, silent);
    },

    toggleSelectColumn: function toggleSelectColumn(x, keys) {
        keys = keys || [];
        var model = this.selectionModel;
        var alreadySelected = model.isColumnSelected(x);
        var hasCTRL = keys.indexOf('CTRL') > -1;
        var hasSHIFT = keys.indexOf('SHIFT') > -1;

        if (!hasCTRL && !hasSHIFT) {
            model.clear();
            if (!alreadySelected) {
                model.selectColumn(x);
            }
        } else {
            if (hasCTRL) {
                if (alreadySelected) {
                    model.deselectColumn(x);
                } else {
                    model.selectColumn(x);
                }
            }

            if (hasSHIFT) {
                model.clear();
                model.selectColumn(this.lastEdgeSelection[0], x);
            }
        }
        if (!alreadySelected && !hasSHIFT) {
            this.lastEdgeSelection[0] = x;
        }
        this.repaint();
        this.fireSyntheticColumnSelectionChangedEvent();
    },

    toggleSelectRow: function toggleSelectRow(y, keys) {
        //we can select the totals rows if they exist, but not rows above that
        keys = keys || [];

        var model = this.selectionModel;
        var hasSHIFT = keys.indexOf('SHIFT') > -1;
        var hasCTRL = keys.indexOf('CTRL') > -1;

        if (!hasCTRL && !hasSHIFT) {
            model.clear();

            model.selectRow(y);
        } else {
            if (hasCTRL) {
                model.selectRow(y);
            }

            if (hasSHIFT) {
                model.clear();
                model.selectRow(this.lastEdgeSelection[1], y);
            }
        }

        if (!hasSHIFT) {
            this.lastEdgeSelection[1] = y;
        }

        this.repaint();
        this.fireSyntheticRowSelectionChangedEvent();
    },

    singleSelect: function singleSelect() {
        var result = this.properties.singleRowSelectionMode;

        if (result) {
            this.selectionModel.clearRowSelection();
        }

        return result;
    },

    selectViewportCell: function selectViewportCell(x, y) {
        var vc, vr;
        if (this.getRowCount() && (vc = this.renderer.visibleColumns[x]) && (vr = this.renderer.visibleRows[y + this.getHeaderRowCount()])) {
            x = vc.columnIndex;
            y = vr.rowIndex;
            this.clearSelections();
            this.select(x, y, 0, 0);
            this.setMouseDown(this.newPoint(x, y));
            this.setDragExtent(this.newPoint(0, 0));
            this.repaint();
        }
    },

    selectToViewportCell: function selectToViewportCell(x, y) {
        var selections, vc, vr;
        if ((selections = this.getSelections()) && selections.length && (vc = this.renderer.visibleColumns[x]) && (vr = this.renderer.visibleRows[y + this.getHeaderRowCount()])) {
            var origin = selections[0].origin;
            x = vc.columnIndex;
            y = vr.rowIndex;
            this.setDragExtent(this.newPoint(x - origin.x, y - origin.y));
            this.select(origin.x, origin.y, x - origin.x, y - origin.y);
            this.repaint();
        }
    },

    selectToFinalCellOfCurrentRow: function selectToFinalCellOfCurrentRow() {
        this.selectFinalCellOfCurrentRow(true);
    },

    selectFinalCellOfCurrentRow: function selectFinalCellOfCurrentRow(to) {
        if (!this.getRowCount()) {
            return;
        }
        var selections = this.getSelections();
        if (selections && selections.length) {
            var selection = selections[0],
                origin = selection.origin,
                extent = selection.extent,
                columnCount = this.getColumnCount();

            this.scrollBy(columnCount, 0);

            this.clearSelections();
            if (to) {
                this.select(origin.x, origin.y, columnCount - origin.x - 1, extent.y);
            } else {
                this.select(columnCount - 1, origin.y, 0, 0);
            }

            this.repaint();
        }
    },

    selectToFirstCellOfCurrentRow: function selectToFirstCellOfCurrentRow() {
        this.selectFirstCellOfCurrentRow(true);
    },

    selectFirstCellOfCurrentRow: function selectFirstCellOfCurrentRow(to) {
        if (!this.getRowCount()) {
            return;
        }
        var selections = this.getSelections();
        if (selections && selections.length) {
            var selection = selections[0],
                origin = selection.origin,
                extent = selection.extent;

            this.clearSelections();
            if (to) {
                this.select(origin.x, origin.y, -origin.x, extent.y);
            } else {
                this.select(0, origin.y, 0, 0);
            }

            this.setHScrollValue(0);
            this.repaint();
        }
    },

    selectFinalCell: function selectFinalCell() {
        if (!this.getRowCount()) {
            return;
        }
        this.selectCellAndScrollToMakeVisible(this.getColumnCount() - 1, this.getRowCount() - 1);
        this.repaint();
    },

    selectToFinalCell: function selectToFinalCell() {
        if (!this.getRowCount()) {
            return;
        }
        var selections = this.getSelections();
        if (selections && selections.length) {
            var selection = selections[0],
                origin = selection.origin,
                columnCount = this.getColumnCount(),
                rowCount = this.getRowCount();

            this.clearSelections();
            this.select(origin.x, origin.y, columnCount - origin.x - 1, rowCount - origin.y - 1);
            // this.scrollBy(columnCount, rowCount);
            this.repaint();
        }
    },

    /**
     * @memberOf Hypergrid#
     * @returns {object} An object that represents the currently selection row.
     */
    getSelectedRow: function getSelectedRow() {
        var sels = this.selectionModel.getSelections();
        if (sels.length) {
            var behavior = this.behavior,
                colCount = this.getColumnCount(),
                topRow = sels[0].origin.y,
                row = {
                //hierarchy: behavior.getFixedColumnValue(0, topRow)
            };

            for (var c = 0; c < colCount; c++) {
                row[behavior.getActiveColumn(c).header] = behavior.getValue(c, topRow);
            }

            return row;
        }
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and dispatch a `fin-selection-changed` event.
     */
    selectionChanged: function selectionChanged() {
        // Project the cell selection into the rows
        this.selectRowsFromCells();

        // Project the cell selection into the columns
        this.selectColumnsFromCells();

        // change api data for selected columns
        this.selectColDefsForApi();

        var selectionEvent = new CustomEvent('fin-selection-changed', {
            detail: this.selectionDetailGetters
        });
        this.canvas.dispatchEvent(selectionEvent);
    },

    selectColDefsForApi: function selectColDefsForApi() {
        if (this.visibleColumnDefs) {
            var selectedColumns = this.getSelectedColumns() || [];
            var selections = this.getSelections();

            selections.forEach(function (s) {
                for (var i = s.left; i <= s.right; ++i) {
                    if (!selections.includes(i)) {
                        selectedColumns.push(i);
                    }
                }
            });

            if (selectedColumns.length) {
                this.api.rangeController.selectedCols = this.behavior.getActiveColumns().filter(function (c) {
                    return c.colDef && selectedColumns.includes(c.index);
                });
            } else {
                this.api.rangeController.selectedCols = [];
            }
        } else {
            this.api.rangeController.selectedCols = [];
        }
    },

    isColumnOrRowSelected: function isColumnOrRowSelected() {
        return this.selectionModel.isColumnOrRowSelected();
    },
    selectColumn: function selectColumn(x1, x2) {
        this.selectionModel.selectColumn(x1, x2);
    },
    selectRow: function selectRow(y1, y2) {
        if (this.singleSelect()) {
            y1 = y2;
        } else if (y2 === undefined) {
            // multiple row selection
            y2 = y1;
        }

        this.selectionModel.selectRow(y1, y2);
    },

    selectRowsFromCells: function selectRowsFromCells() {
        if (!this.properties.keepRowSelections && this.properties.autoSelectRows) {
            var last;

            if (!this.properties.singleRowSelectionMode) {
                this.selectionModel.selectRowsFromCells(0, true);
            } else if (last = this.selectionModel.getLastSelection()) {
                this.selectRow(null, last.corner.y);
            } else {
                this.clearRowSelection();
            }
            this.fireSyntheticRowSelectionChangedEvent();
        }
    },
    selectColumnsFromCells: function selectColumnsFromCells() {
        if (this.properties.autoSelectColumns) {
            this.selectionModel.selectColumnsFromCells();
        }
    },
    getSelectedRows: function getSelectedRows() {
        return this.behavior.getSelectedRows();
    },
    getSelectedColumns: function getSelectedColumns() {
        return this.behavior.getSelectedColumns();
    },
    getSelections: function getSelections() {
        return this.behavior.getSelections();
    },
    getLastSelectionType: function getLastSelectionType() {
        return this.selectionModel.getLastSelectionType();
    },
    isInCurrentSelectionRectangle: function isInCurrentSelectionRectangle(x, y) {
        return this.selectionModel.isInCurrentSelectionRectangle(x, y);
    },
    selectAllRows: function selectAllRows() {
        this.selectionModel.selectAllRows();
    },
    areAllRowsSelected: function areAllRowsSelected() {
        return this.selectionModel.areAllRowsSelected();
    },
    toggleSelectAllRows: function toggleSelectAllRows() {
        if (this.areAllRowsSelected()) {
            this.selectionModel.clear();
        } else {
            this.selectAllRows();
        }
        this.repaint();
    },

    /**
     * @summary Move cell selection by offset.
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {number} offsetX - x offset
     * @param {number} offsetY - y offset
     * @memberOf Hypergrid#
     */
    moveSingleSelect: function moveSingleSelect(offsetX, offsetY) {
        // 11.05.2018 client wants to be able continue cell selection from same point after ctrl+a
        var mouseCorner = this.getMouseDown(); //.plus(this.getDragExtent());
        this.moveToSingleSelect(mouseCorner.x + offsetX, mouseCorner.y + offsetY);
    },

    /**
     * @summary Move cell selection by offset.
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {number} newX - x coordinate to start at
     * @param {number} newY - y coordinate to start at
     * @memberOf Hypergrid#
     */
    moveToSingleSelect: function moveToSingleSelect(newX, newY) {
        var maxColumns = this.getColumnCount() - 1,
            maxRows = this.getRowCount() - 1,
            maxViewableColumns = this.getVisibleColumnsCount() - 1,
            maxViewableRows = this.getVisibleRowsCount() - 1;

        if (!this.properties.scrollingEnabled) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        newX = Math.min(maxColumns, Math.max(0, newX));
        newY = Math.min(maxRows, Math.max(0, newY));

        this.clearSelections();
        this.select(newX, newY, 0, 0);
        this.setMouseDown(this.newPoint(newX, newY));
        this.setDragExtent(this.newPoint(0, 0));

        this.selectCellAndScrollToMakeVisible(newX, newY);

        this.repaint();
    },

    /** @summary Extend cell selection by offset.
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     * @memberOf Hypergrid#
     */
    extendSelect: function extendSelect(offsetX, offsetY) {
        var maxColumns = this.getColumnCount() - 1,
            maxRows = this.getRowCount() - 1,
            maxViewableColumns = this.renderer.visibleColumns.length - 1,
            maxViewableRows = this.renderer.visibleRows.length - 1,
            origin = this.getMouseDown(),
            extent = this.getDragExtent(),
            newX = extent.x + offsetX,
            newY = extent.y + offsetY;

        if (!this.properties.scrollingEnabled) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        newX = Math.min(maxColumns - origin.x, Math.max(-origin.x, newX));
        newY = Math.min(maxRows - origin.y, Math.max(-origin.y, newY));

        this.clearMostRecentSelection();

        this.select(origin.x, origin.y, newX, newY);
        this.setDragExtent(this.newPoint(newX, newY));

        var colScrolled = this.insureModelColIsVisible(newX + origin.x, offsetX),
            rowScrolled = this.insureModelRowIsVisible(newY + origin.y, offsetY);

        this.repaint();

        var needScroll = colScrolled || rowScrolled;

        if (needScroll) {
            this.scrollToMakeVisible(newX + origin.x, newY + origin.y);
        }

        return needScroll;
    },

    /**
     * @returns {undefined|CellEvent}
     * @param {boolean} [useAllCells] - Search in all rows and columns instead of only rendered ones.
     * @memberOf Hypergrid#
     */
    getGridCellFromLastSelection: function getGridCellFromLastSelection(useAllCells) {
        var sel = this.selectionModel.getLastSelection();
        return sel && new this.behavior.CellEvent().resetGridXDataY(sel.origin.x, sel.origin.y, null, useAllCells);
    }
};

/**
 * @param {boolean|number[]|string[]} [hiddenColumns=false] - One of:
 * `false` - Active column list
 * `true` - All column list
 * `Array` - Active column list with listed columns prefixed as needed (when not already in the list). Each item in the array may be either:
 * * `number` - index into all column list
 * * `string` - name of a column from the all column list
 * @returns {Column[]}
 * @memberOf Hypergrid~
 */
function getColumns(hiddenColumns) {
    var columns,
        allColumns = this.behavior.getColumns(),
        activeColumns = this.behavior.getActiveColumns();

    if (Array.isArray(hiddenColumns)) {
        columns = [];
        hiddenColumns.forEach(function (index) {
            var key = typeof index === 'number' ? 'index' : 'name',
                column = allColumns.find(function (column) {
                return column[key] === index;
            });
            if (activeColumns.indexOf(column) < 0) {
                columns.push(column);
            }
        });
        columns = columns.concat(activeColumns);
    } else {
        columns = hiddenColumns ? allColumns : activeColumns;
    }

    return columns;
}

function normalizeRect(rect) {
    var o = rect.origin,
        c = rect.corner,
        ox = Math.min(o.x, c.x),
        oy = Math.min(o.y, c.y),
        cx = Math.max(o.x, c.x),
        cy = Math.max(o.y, c.y);

    return new Rectangle(ox, oy, cx - ox, cy - oy);
}

/**
 * @this {dataRowObject}
 * @param column
 * @returns {string}
 */
function valOrFunc(dataRow, column) {
    var result, calculator;
    if (dataRow) {
        result = dataRow[column.name];
        calculator = (typeof result === 'undefined' ? 'undefined' : _typeof(result))[0] === 'f' && result || column.calculator;
        if (calculator) {
            result = calculator(dataRow, column.name);
        }
    }
    if (result.value) {
        return result.value;
    }
    return result || result === 0 || result === false ? result : '';
}

},{"rectangular":14}],32:[function(require,module,exports){
'use strict';

// This file creates the Hypergrid theme registry, exposed via:
// shared methods `Hypergrid.registerTheme` and `Hypergrid.applyTheme`
// and instance methods `myGrid.applyTheme`.
// The initial registry consists of a single theme ('default').
// Application developers can add additional themes to this registry.

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _ = require('object-iterators'); // fyi: installs the Array.prototype.find polyfill, as needed

var defaults = require('../defaults');
var dynamicPropertyDescriptors = require('../lib/dynamicProperties');
var HypergridError = require('../lib/error');

var styles = ['BackgroundColor', 'Color', 'Font'];

var stylesWithHalign = styles.concat(['Halign']);

var dataCellStyles = stylesWithHalign.concat(['cellPadding', 'iconPadding']);

var stylers = [{ prefix: '', props: dataCellStyles }, { prefix: 'foregroundSelection', props: styles }, { prefix: 'columnHeader', props: stylesWithHalign }, { prefix: 'columnHeaderForegroundSelection', props: styles }, { prefix: 'rowHeader', props: styles }, { prefix: 'rowHeaderForegroundSelection', props: styles }];

var dynamicCosmetics = {
    rowHeaderCheckboxes: defaults.rowHeaderCheckboxes,
    rowHeaderNumbers: defaults.rowHeaderNumbers,
    gridBorder: defaults.gridBorder,
    gridBorderTop: defaults.gridBorderTop,
    gridBorderRight: defaults.gridBorderRight,
    gridBorderBottom: defaults.gridBorderBottom,
    gridBorderLeft: defaults.gridBorderLeft,
    gridRenderer: defaults.gridRenderer
};

// Create the `defaultTheme` theme by copying over the theme props,
// which is a subset of all the props defined in defaults.js, beginning with
// they dynamic cosmetics and `themeName`...
var defaultTheme = Object.assign({}, dynamicCosmetics, {
    themeName: defaults.themeName
});

// ...and then adding non-dynamic cosmetics into `defaultTheme`, by combining the above
// prefixes with their styles to get prop names and then copy those props from `defaults`.
stylers.reduce(function (theme, styler) {
    return styler.props.reduce(function (theme, prop) {
        prop = styler.prefix + prop;
        prop = prop.replace('ForegroundSelectionBackground', 'BackgroundSelection'); // unfortunate!
        prop = prop[0].toLowerCase() + prop.substr(1);
        theme[prop] = defaults[prop];
        return theme;
    }, theme);
}, defaultTheme);

/**
 * @summary The Hypergrid theme registry.
 * @desc The standard registry consists of a single theme, `default`, built from values in defaults.js.
 */
var registry = Object.create(null, {
    default: { value: defaultTheme }
});
var pseudopropAdvice = {
    showRowNumbers: 'rowHeaderCheckboxes and rowHeaderNumbers',
    lineColor: 'gridLinesColor and gridLinesColor',
    lineWidth: 'gridLinesWidth and gridLinesWidth',
    gridBorder: 'gridBorderLeft, gridBorderRight, gridBorderTop, and gridBorderBottom'
};

function applyTheme(theme) {
    var themeLayer, grids, props;

    if (theme && (typeof theme === 'undefined' ? 'undefined' : _typeof(theme)) === 'object' && !Object.getOwnPropertyNames(theme).length) {
        theme = null;
    }

    if (this._theme) {
        grids = [this];
        themeLayer = this._theme;
        props = this.properties;

        // If removing theme, reset props to defaults
        if (!theme) {
            // Delete (non-dynamic) grid props named in this theme, revealing defaults
            Object.keys(themeLayer).forEach(function (key) {
                if (!(key in dynamicPropertyDescriptors)) {
                    delete props[key];
                }
            });

            // Reset dynamic cosmetic props to defaults
            Object.keys(dynamicCosmetics).forEach(function (key) {
                props.var[key] = defaults[key];
            });
        }

        // Delete all own props from this grid instance's theme layer (defined by an eariler call)
        Object.keys(themeLayer).forEach(function (key) {
            delete themeLayer[key];
        });
    } else {
        grids = this.grids;
        themeLayer = defaults; // global theme layer
        theme = theme || 'default';
    }

    if (typeof theme === 'string') {
        if (!registry[theme]) {
            throw new HypergridError('Unknown theme "' + theme + '"');
        }
        theme = registry[theme];
    }

    if (theme) {
        // When no theme name, set it to explicit `undefined` (to mask defaults.themeName).
        if (!theme.themeName) {
            theme.themeName = undefined;
        }

        Object.keys(theme).forEach(function (key) {
            if (key in dynamicPropertyDescriptors) {
                if (key in dynamicCosmetics) {
                    grids.forEach(function (grid) {
                        grid.properties[key] = theme[key];
                    });
                } else {
                    // Dynamic properties are defined on properties layer; defining these
                    // r-values on the theme layer is ineffective so let's not allow it.
                    var message = pseudopropAdvice[key];
                    message = message ? 'Ignoring unexpected pseudo-prop ' + key + ' in theme object. Use actual props ' + message + ' instead.' : 'Ignoring invalid property ' + key + ' in theme object.';
                    console.warn(message);
                    delete theme[key];
                }
            }
        });

        // No .assign() because themeName is read-only in defaults layer
        Object.defineProperties(themeLayer, Object.getOwnPropertyDescriptors(theme));
    }

    grids.forEach(function (grid) {
        grid.repaint();
    });
}

/**
 * @summary Instance theme support.
 * @desc Hypergrid/index.js mixes this module into its prototype.
 * @mixin
 */
var mixin = {
    initThemeLayer: function initThemeLayer() {
        /**
         * Descends from {@link module:defaults|defaults}.
         * @memberOf Hypergrid#
         * @private
         */
        this._theme = Object.create(defaults);

        return Object.create(this._theme, dynamicPropertyDescriptors);
    },

    /**
     * @summary Apply a grid theme.
     * @desc Apply props from the given theme object to the grid instance,
     * the instance's `myGrid.themeLayer` layer in the properties hierarchy.
     * @this {Hypergrid}
     * @param {object|string} [theme] - One of:
     * * **string:** A registered theme name.
     * * **object:** A unregistered (anonymous) theme object. Empty object removes grid theme, exposing global theme.
     * * _falsy value:_ Also removes grid theme.
     * @param {string|undefined} [theme.themeName=undefined]
     * @memberOf Hypergrid#
     */
    applyTheme: applyTheme,

    /**
     * @summary Get currently active theme.
     * @desc May return a theme name or a theme object.
     * @returns {string|undefined|object} One of:
     * * **string:** Theme name (registered theme).
     * * **object:** Theme object (unregistered anonymous theme).
     * * **undefined:** No theme (i.e., the default theme).
     * @memberOf Hypergrid#
     */
    getTheme: function getTheme() {
        var themeLayer = this._theme,
            themeName = themeLayer.themeName;
        return themeName === 'default' || !Object.getOwnPropertyNames(themeLayer).length ? undefined // default theme or no theme
        : themeName in registry ? themeName // registered theme name
        : themeLayer; // unregistered theme object
    }
};
Object.defineProperty(mixin, 'theme', {
    enumerable: true,
    set: mixin.applyTheme,
    get: mixin.getTheme
});

/**
 * @summary Theme registration and global theme support.
 * @desc Hypergrid/index.js mixes this module into its "shared namespace" (_i.e.,_ as properties of the constructor).
 * @mixin
 */
var sharedMixin = {
    /**
     * @param {string} [name] - A registry name for the new theme. May be omitted if the theme has an embedded name (in `theme.themeName`).
     * _If omitted, the 2nd parameter (`theme`) is promoted to first position._
     * @param {HypergridThemeObject} [theme]
     * To build a Hypergrid theme object from a loaded {@link https://polymerthemes.com Polymer Theme} CSS stylesheet:
     * ```javascript
     * var myTheme = require('fin-hypergrid-themes').buildTheme();
     * ```
     * If omitted, the theme named in the first parameter is unregistered.
     * Grid instances that have previously applied the named theme are unaffected by this action (whether re-registering or unregistering).
     * @this {Hypergrid.constructor}
     * @memberOf Hypergrid.
     */
    registerTheme: function registerTheme(name, theme) {
        if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
            theme = name;
            name = theme.themeName;
        }

        if (!name) {
            throw new HypergridError('Cannot register an anonymous theme.');
        }

        if (name === 'default') {
            throw new HypergridError('Cannot register or unregister the "default" theme.');
        }

        if (theme) {
            theme.themeName = name;
            registry[name] = theme;
        } else {
            delete registry[name];
        }
    },

    /**
     * App developers are free to add in additional themes, such as those in {@link https://openfin.github.com/fin-hypergrid-themes/themes}:
     * ```javascript
     * Hypergrind.registerThemes(require('fin-hypergrid-themes'));
     * ```
     * @param {object} themeCollection
     * @memberOf Hypergrid.
     */
    registerThemes: function registerThemes(themeCollection) {
        if (themeCollection) {
            _(themeCollection).each(function (theme, name) {
                this.registerTheme(name, theme);
            }, this);
        } else {
            Object.keys(registry).forEach(function (themeName) {
                this.registerTheme(themeName);
            }, this);
        }
    },

    /**
     * @summary Apply global theme.
     * @desc Apply props from the given theme object to the global theme object,
     * the `defaults` layer at the bottom of the properties hierarchy.
     * @this {Hypergrid.constructor}
     * @param {object|string} [theme=registry.default] - One of:
     * * **string:** A registered theme name.
     * * **object:** A theme object. Empty object removes global them, restoring defaults.
     * * _falsy value:_ Also restores defaults.
     * @param {string|undefined} [theme.themeName=undefined]
     * @memberOf Hypergrid.
     */
    applyTheme: applyTheme
};
Object.defineProperty(sharedMixin, 'theme', { // global theme setter/getter
    enumerable: true,
    set: applyTheme,
    get: function get() {
        return defaults;
    } // the defaults layer *is* the global theme layer
});

module.exports = {
    mixin: mixin,
    sharedMixin: sharedMixin
};

},{"../defaults":65,"../lib/dynamicProperties":94,"../lib/error":95,"object-iterators":12}],33:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Point = require('rectangular').Point;

var Base = require('../Base');
var Column = require('./Column');
var cellEventFactory = require('../lib/cellEventFactory');
var featureRegistry = require('../features');
var propClassEnum = require('../defaults.js').propClassEnum;

var noExportProperties = ['columnHeader', 'columnHeaderColumnSelection', 'filterProperties', 'rowHeader', 'rowHeaderRowSelection', 'rowNumbersProperties', 'treeColumnProperties', 'treeColumnPropertiesColumnSelection'];

Array.prototype.move = function (oldIndex, len, newIndex) {
    // eslint-disable-line
    while (oldIndex < 0) {
        oldIndex += this.length;
    }
    while (newIndex < 0) {
        newIndex += this.length;
    }
    if (newIndex >= this.length) {
        var k = newIndex - this.length;
        while (k-- + 1) {
            this.push(undefined);
        }
    }
    if (oldIndex < newIndex) {
        newIndex -= len - 1;
    }
    this.splice.apply(this, [newIndex, 0].concat(this.splice(oldIndex, len)));
    return this;
};

/**
 * @mixes cellProperties.behaviorMixin
 * @mixes rowProperties.mixin
 * @mixes subgrids.mixin
 * @constructor
 * @desc A controller for the data model.
 * > This constructor (actually `initialize`) will be called upon instantiation of this class or of any class that extends from this class. See {@link https://github.com/joneit/extend-me|extend-me} for more info.
 * @param {Hypergrid} grid
 * @param {object} [options] - _(Passed to {@link Behavior#reset reset})._
 * @param {dataModelAPI} [options.dataModel] - _Per {@link Behavior#reset reset}._
 * @param {object} [options.metadata] - _Per {@link Behavior#reset reset}._
 * @param {function} [options.DataModel=require('datasaur-local')] - _Per {@link Behavior#reset reset}._
 * @param {function|object[]} [options.data] - _Per {@link Behavior#setData setData}._
 * @param {function|menuItem[]} [options.schema] - _Per {@link Behavior#setData setData}._
 * @param {subgridSpec[]} [options.subgrids=this.grid.properties.subgrids] - _Per {@link Behavior#setData setData}._
 * @param {boolean} [options.apply=true] - _Per {@link Behavior#setData setData}._
 * @abstract
 */
var Behavior = Base.extend('Behavior', {

    initialize: function initialize(grid, options) {
        /**
         * @type {Hypergrid}
         * @memberOf Behavior#
         */
        this.grid = grid;

        this.initializeFeatureChain();

        this.grid.behavior = this;
        this.reset(options);
    },

    /**
     * @desc Create the feature chain - this is the [chain of responsibility](http://c2.com/cgi/wiki?ChainOfResponsibilityPattern) pattern.
     * @param {Hypergrid} [grid] Unnecesary legacy parameter. May be omitted.
     * @memberOf Behavior#
     */
    initializeFeatureChain: function initializeFeatureChain(grid) {
        var constructors;

        /**
         * @summary Controller chain of command.
         * @desc Each feature is linked to the next feature.
         * @type {Feature}
         * @memberOf Behavior#
         */
        this.featureChain = undefined;

        /**
         * @summary Hash of instantiated features by class names.
         * @desc Built here but otherwise not in use.
         * @type {object}
         * @memberOf Behavior#
         */
        this.featureMap = {};

        this.featureRegistry = this.featureRegistry || featureRegistry;

        if (this.grid.properties.features) {
            var getFeatureConstructor = this.featureRegistry.get.bind(this.featureRegistry);
            constructors = this.grid.properties.features.map(getFeatureConstructor);
        } else if (this.features) {
            constructors = this.features;
            warnBehaviorFeaturesDeprecation.call(this);
        }

        constructors.forEach(function (FeatureConstructor, i) {
            var feature = new FeatureConstructor();

            this.featureMap[feature.$$CLASS_NAME] = feature;

            if (i) {
                this.featureChain.setNext(feature);
            } else {
                this.featureChain = feature;
            }
        }, this);

        if (this.featureChain) {
            this.featureChain.initializeOn(this.grid);
        }
    },

    features: [], // override in implementing class; or provide feature names in grid.properties.features; else no features

    /**
     * Reset the behavior.
     * @param {object} [options] - _Same as constructor's `options`._<br>
     * _Passed to {@link Behavior#resetDataModel resetDataModel} and {@link Behavior#setData setData} (both of which see)._
     * @memberOf Behavior#
     */
    reset: function reset(options) {
        this.schemaOld = this.schema;

        var dataModelChanged = this.resetDataModel(options);

        if (dataModelChanged) {
            // recreate `CellEvent` class so it can update its cached `grid`, `behavior`, and `dataModel` properties
            this.CellEvent = cellEventFactory(this.grid);
        }

        this.scrollPositionX = this.scrollPositionY = 0;

        this.createColumns();

        /**
         * Ordered list of subgrids to render.
         * @type {subgridSpec[]}
         * @memberOf Hypergrid#
         */
        this.subgrids = options && options.subgrids || !dataModelChanged && this.subgrids || this.grid.properties.subgrids;

        this.setData(options);
    },

    /**
     * @abstract
     * @summary Set grid data.
     * @desc Exits without doing anything if no data (`dataRows` undefined or omitted and `options.data` undefined).
     *
     * @param {function|object[]} [dataRows=options.data] - Array of uniform data row objects or function returning same.
     *
     * @param {object} [options] - _(Promoted to first argument position when `dataRows` omitted.)_
     *
     * @param {function|object[]} [options.data] - Passed to behavior constructor. May be:
     * * An array of congruent raw data objects
     * * A function returning same
     * * Omit for non-local datasources
     *
     * @param {function|menuItem[]} [options.schema] - Passed to behavior constructor. May be:
     * * A schema array
     * * A function returning same. Called at filter reset time with behavior as context.
     * * Omit to allow the data model to generate a basic schema from its data.
     *
     * @param {boolean} [options.apply=true] Apply data transformations to the new data.
     *
     * @memberOf Behavior#
     */
    setData: function setData(dataRows, options) {},

    /**
     * @abstract
     * @summary Add grid data.
     * @desc Exits without doing anything if no data (`dataRows` undefined or omitted and `options.data` undefined).
     *
     * @param {function|object[]} [dataRows=options.data] - Array of uniform data row objects or function returning same.
     *
     * @param {object} [options] - _(Promoted to first argument position when `dataRows` omitted.)_
     *
     * @param {function|object[]} [options.data] - Passed to behavior constructor. May be:
     * * An array of congruent raw data objects
     * * A function returning same
     * * Omit for non-local datasources
     *
     * @param {function|menuItem[]} [options.schema] - Passed to behavior constructor. May be:
     * * A schema array
     * * A function returning same. Called at filter reset time with behavior as context.
     * * Omit to allow the data model to generate a basic schema from its data.
     *
     * @param {boolean} [options.apply=true] Apply data transformations to the new data.
     *
     * @memberOf Behavior#
     */
    addData: function addData(dataRows, options) {},

    get renderedColumnCount() {
        return this.grid.renderer.visibleColumns.length;
    },

    get renderedRowCount() {
        return this.grid.renderer.visibleRows.length;
    },

    get leftMostColIndex() {
        return this.grid.properties.showRowNumbers ? this.rowColumnIndex : this.hasTreeColumn() ? this.treeColumnIndex : 0;
    },

    clearColumns: function clearColumns() {
        var schema = this.schema,
            treeColumnIndex = this.treeColumnIndex,
            rowColumnIndex = this.rowColumnIndex;

        schema[treeColumnIndex] = schema[treeColumnIndex] || {
            index: treeColumnIndex,
            name: 'Tree',
            header: 'Tree'
        };

        schema[rowColumnIndex] = schema[rowColumnIndex] || {
            index: rowColumnIndex,
            name: '',
            header: ''
        };

        var treeColumnOld = this.allColumns && this.allColumns[treeColumnIndex] || this.columns && this.columns[treeColumnIndex];
        var rowColumnOld = this.allColumns && this.allColumns[rowColumnIndex] || this.columns && this.columns[rowColumnIndex];

        /**
         * @type {Column[]}
         * @memberOf Behavior#
         */
        this.columns = [];

        /**
         * @type {Column[]}
         * @memberOf Behavior#
         */
        this.allColumns = [];

        this.allColumns[treeColumnIndex] = this.columns[treeColumnIndex] = this.newColumn(treeColumnOld && treeColumnOld.properties ? treeColumnOld.properties : {
            index: treeColumnIndex,
            header: schema[treeColumnIndex].header,
            name: schema[treeColumnIndex].name,
            fixed: true
        });
        this.allColumns[rowColumnIndex] = this.columns[rowColumnIndex] = this.newColumn(rowColumnOld && rowColumnOld.properties ? rowColumnOld.properties : {
            index: rowColumnIndex,
            header: schema[rowColumnIndex].header,
            name: schema[rowColumnIndex].name,
            columnAutosizing: false,
            minWidth: this.grid.properties.columnHeaderInitWidth,
            fixed: true
        });

        this.columns[treeColumnIndex].properties.propClassLayers = this.columns[rowColumnIndex].properties.propClassLayers = [propClassEnum.COLUMNS];

        // Signal the renderer to size the now-reset handle column before next render
        this.grid.renderer.resetRowHeaderColumnWidth();
    },

    getActiveColumn: function getActiveColumn(x) {
        return this.columns[x] || this.columns[parseInt(x, 10)];
    },

    /**
     * The "grid index" given a "data index" (or column object)
     * @param {Column|number} columnOrIndex
     * @returns {undefined|number} The grid index of the column or undefined if column not in grid.
     * @memberOf Hypergrid#
     */
    getActiveColumnIndex: function getActiveColumnIndex(columnOrIndex) {
        var index = columnOrIndex instanceof Column ? columnOrIndex.index : columnOrIndex;
        for (var i = 0; i < this.columns.length; ++i) {
            if (this.columns[i].index === index) {
                return i;
            }
        }
    },

    getColumn: function getColumn(x) {
        return this.allColumns[x];
    },

    /**
     * @default get nearest column to X
     * @param x - index of base column
     * @param rightShift - boolean direction for near column getting. `true` - is direction to the right
     * @returns {Column|undefined}
     */
    getColumnShifted: function getColumnShifted(x, rightShift) {
        if (rightShift) {
            ++x;
        } else {
            --x;
        }

        if (x === this.treeColumnIndex && !this.grid.properties.showTreeColumn) {
            return this.getColumnShifted(x, rightShift);
        }

        if (x === this.rowColumnIndex && !this.grid.properties.rowHeaderNumbers) {
            return this.getColumnShifted(x, rightShift);
        }

        return this.getColumn(x);
    },

    newColumn: function newColumn(options) {
        return new Column(this, options);
    },

    addColumn: function addColumn(options) {
        var column = this.newColumn(options);
        this.columns.push(column);
        this.allColumns.push(column);
        return column;
    },

    createColumns: function createColumns() {
        this.clearColumns();
        //concrete implementation here
    },

    getColumnWidth: function getColumnWidth(x) {
        var column = this.getActiveColumn(x);
        if (!column) {
            return this.grid.properties.defaultColumnWidth;
        }
        return column.getWidth() + (this.grid.properties.gridLinesV ? this.grid.properties.gridLinesWidth : 0);
    },

    /**
     * @param {Column|number} columnOrIndex - The column or active column index.
     * @param width
     * @memberOf Hypergrid#
     */
    setColumnWidth: function setColumnWidth(columnOrIndex, width) {
        var column = columnOrIndex >= -2 ? this.getActiveColumn(columnOrIndex) : columnOrIndex;
        column.setWidth(width);
        this.stateChanged();
        this.grid.fireSyntheticOnColumnResizedEvent(columnOrIndex, width);
    },

    /**
     * @memberOf Behavior#
     * @desc utility function to empty an object of its members
     * @param {object} obj - the object to empty
     * @param {boolean} [exportProps]
     * * `undefined` (omitted) - delete *all* properties
     * * **falsy** - delete *only* the export properties
     * * **truthy** - delete all properties *except* the export properties
     */
    clearObjectProperties: function clearObjectProperties(obj, exportProps) {
        for (var key in obj) {
            if (obj.hasOwnProperty(key) && (exportProps === undefined || !exportProps && noExportProperties.indexOf(key) >= 0 || exportProps && noExportProperties.indexOf(key) < 0)) {
                delete obj[key];
            }
        }
    },

    //this is effectively a clone, with certain things removed....
    getState: function getState() {
        var copy = JSON.parse(JSON.stringify(this.grid.properties));
        this.clearObjectProperties(copy.columnProperties, false);
        return copy;
    },
    /**
     * @memberOf Behavior#
     * @desc clear all table state
     */
    clearState: function clearState() {
        this.grid.clearState();
        this.createColumns();
    },

    /**
     * @memberOf Behavior#
     * @desc Restore this table to a previous state.
     * See the [memento pattern](http://c2.com/cgi/wiki?MementoPattern).
     * @param {Object} memento - assignable grid properties
     */
    setState: function setState(memento) {
        this.clearState();
        this.addState(memento);
    },

    /**
     * @memberOf Behavior#
     * @desc Add new state to params object.
     * @param {Object} properties - assignable grid properties
     */
    addState: function addState(properties) {
        Object.assign(this.grid.properties, properties);
        this.setAllColumnProperties(properties.columnProperties);
        this.reindex();
    },

    /**
     * @summary Sets properties of multiple columns.
     * @desc Sets column properties to elements of given array.
     * The array may be sparse; never defined or deleted elements are ignored.
     * In addition, falsy elements are ignored.
     * @param {object[]} columnProperties
     */
    setAllColumnProperties: function setAllColumnProperties(columnProperties) {
        if (columnProperties) {
            columnProperties.forEach(function (properties, i) {
                if (properties) {
                    this.getColumn(i).properties = properties;
                }
            }, this);
        }
    },

    setColumnOrder: function setColumnOrder(columnIndexes) {
        if (Array.isArray(columnIndexes)) {
            this.columns.length = columnIndexes.length;
            columnIndexes.forEach(function (index, i) {
                this.columns[i] = this.allColumns[index];
            }, this);
        }
    },

    setColumnOrderByName: function setColumnOrderByName(columnNames) {
        if (Array.isArray(columnNames)) {
            this.columns.length = columnNames.length;
            columnNames.forEach(function (columnName, i) {
                this.columns[i] = this.allColumns.find(function (column) {
                    return column.name === columnName;
                });
            }, this);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc Rebuild the column order indexes
     * @param {Array} columnIndexes - list of column indexes
     * @param {Boolean} [silent=false] - whether to trigger column changed event
     */
    setColumnIndexes: function setColumnIndexes(columnIndexes, silent) {
        this.grid.properties.columnIndexes = columnIndexes;
        if (!silent) {
            this.grid.fireSyntheticOnColumnsChangedEvent();
        }
    },

    /**
     * @summary Show inactive column(s) or move active column(s).
     *
     * @desc Adds one or several columns to the "active" column list.
     *
     * @param {boolean} [isActiveColumnIndexes=false] - Which list `columnIndexes` refers to:
     * * `true` - The active column list. This can only move columns around within the active column list; it cannot add inactive columns (because it can only refer to columns in the active column list).
     * * `false` - The full column list (as per column schema array). This inserts columns from the "inactive" column list, moving columns that are already active.
     *
     * @param {number|number[]} columnIndexes - Column index(es) into list as determined by `isActiveColumnIndexes`. One of:
     * * **Scalar column index** - Adds single column at insertion point.
     * * **Array of column indexes** - Adds multiple consecutive columns at insertion point.
     *
     * _This required parameter is promoted left one arg position when `isActiveColumnIndexes` omitted._
     *
     * @param {number} [referenceIndex=this.columns.length] - Insertion point, _i.e.,_ the element to insert before. A negative values skips the reinsert. Default is to insert new columns at end of active column list.
     *
     * _Promoted left one arg position when `isActiveColumnIndexes` omitted._
     *
     * @param {boolean} [allowDuplicateColumns=false] - Unless true, already visible columns are removed first.
     *
     * _Promoted left one arg position when `isActiveColumnIndexes` omitted + one position when `referenceIndex` omitted._
     *
     * @memberOf Behavior#
     */
    showColumns: function showColumns(isActiveColumnIndexes, columnIndexes, referenceIndex, allowDuplicateColumns) {
        // Promote args when isActiveColumnIndexes omitted
        if (typeof isActiveColumnIndexes === 'number' || Array.isArray(isActiveColumnIndexes)) {
            allowDuplicateColumns = referenceIndex;
            referenceIndex = columnIndexes;
            columnIndexes = isActiveColumnIndexes;
            isActiveColumnIndexes = false;
        }

        var activeColumns = this.columns,
            sourceColumnList = isActiveColumnIndexes ? activeColumns : this.allColumns;

        // Nest scalar index
        if (typeof columnIndexes === 'number') {
            columnIndexes = [columnIndexes];
        }

        var newColumns = columnIndexes
        // Look up columns using provided indexes
        .map(function (index) {
            return sourceColumnList[index];
        })
        // Remove any undefined columns
        .filter(function (column) {
            return column;
        });

        // Default insertion point is end (i.e., before (last+1)th element)
        if (typeof referenceIndex !== 'number') {
            allowDuplicateColumns = referenceIndex; // assume reference index was omitted when not a number
            referenceIndex = activeColumns.length;
        }

        // Remove already visible columns and adjust insertion point
        if (!allowDuplicateColumns) {
            newColumns.forEach(function (column) {
                var i = activeColumns.indexOf(column);
                if (i >= 0) {
                    activeColumns.splice(i, 1);
                    if (referenceIndex > i) {
                        --referenceIndex;
                    }
                }
            });
        }

        // Insert the new columns at the insertion point
        if (referenceIndex >= 0) {
            activeColumns.splice.apply(activeColumns, [referenceIndex, 0].concat(newColumns));
        }

        this.grid.properties.columnIndexes = activeColumns.map(function (column) {
            return column.index;
        });
    },

    /**
     * @summary Hide active column(s).
     * @desc Removes one or several columns from the "active" column list.
     * @param {boolean} [isActiveColumnIndexes=false] - Which list `columnIndexes` refers to:
     * * `true` - The active column list.
     * * `false` - The full column list (as per column schema array).
     * @param {number|number[]} columnIndexes - Column index(es) into list as determined by `isActiveColumnIndexes`. One of:
     * * **Scalar column index** - Adds single column at insertion point.
     * * **Array of column indexes** - Adds multiple consecutive columns at insertion point.
     *
     * _This required parameter is promoted left one arg position when `isActiveColumnIndexes` omitted._
     * @memberOf Behavior#
     */
    hideColumns: function hideColumns(isActiveColumnIndexes, columnIndexes) {
        var args = Array.prototype.slice.call(arguments); // Convert to array so we can add an argument (element)
        args.push(-1); // Remove only; do not reinsert.
        this.showColumns.apply(this, args);
    },

    /**
     * @memberOf Behavior#
     * @desc fetch the value for a property key
     * @returns {*} The value of the given property.
     * @param {string} key - a property name
     */
    resolveProperty: function resolveProperty(key) {
        // todo: remove when we remove the deprecated grid.resolveProperty
        return this.grid.resolveProperty(key);
    },

    lookupFeature: function lookupFeature(key) {
        return this.featureMap[key];
    },

    /**
     * @param {CellEvent|number} xOrCellEvent - Grid column coordinate.
     * @param {number} [y] - Grid row coordinate. Omit if `xOrCellEvent` is a CellEvent.
     * @param {dataModelAPI} [dataModel] - For use only when `xOrCellEvent` is _not_ a `CellEvent`: Provide a subgrid. If given, x and y are interpreted as data cell coordinates (unadjusted for scrolling). Does not default to the data subgrid, although you can provide it explicitly (`this.subgrids.lookup.data`).
     * @memberOf Behavior#
     */
    getValue: function getValue(xOrCellEvent, y, dataModel) {
        if ((typeof xOrCellEvent === 'undefined' ? 'undefined' : _typeof(xOrCellEvent)) !== 'object') {
            var x = xOrCellEvent;
            xOrCellEvent = new this.CellEvent();
            if (dataModel) {
                xOrCellEvent.resetDataXY(x, y, dataModel);
            } else {
                xOrCellEvent.resetGridCY(x, y);
            }
        }
        return xOrCellEvent.value;
    },

    /**
     * @memberOf Behavior#
     * @desc update the data at point x, y with value
     * @return The data.
     * @param {CellEvent|number} xOrCellEvent - Grid column coordinate.
     * @param {number} [y] - Grid row coordinate. Omit if `xOrCellEvent` is a CellEvent.
     * @param {Object} value - The value to use. _When `y` omitted, promoted to 2nd arg._
     * @param {dataModelAPI} [dataModel] - For use only when `xOrCellEvent` is _not_ a `CellEvent`: Provide a subgrid. If given, x and y are interpreted as data cell coordinates (unadjusted for scrolling). Does not default to the data subgrid, although you can provide it explicitly (`this.subgrids.lookup.data`).
     * @return {boolean} Consumed.
     */
    setValue: function setValue(xOrCellEvent, y, value, dataModel) {
        if ((typeof xOrCellEvent === 'undefined' ? 'undefined' : _typeof(xOrCellEvent)) === 'object') {
            value = y;
        } else {
            var x = xOrCellEvent;
            xOrCellEvent = new this.CellEvent();
            if (dataModel) {
                xOrCellEvent.resetDataXY(x, y, dataModel);
            } else {
                xOrCellEvent.resetGridCY(x, y);
            }
        }
        xOrCellEvent.value = value;
    },

    /**
     * @memberOf Behavior#
     * @return {number} The width of the fixed column area in the hypergrid.
     */
    getFixedColumnsWidth: function getFixedColumnsWidth() {
        var count = this.getFixedColumnCount(),
            total = 0,
            i = this.leftMostColIndex;

        for (; i < count; i++) {
            total += this.getColumnWidth(i);
        }
        return total;
    },

    /**
     * @memberOf Behavior#
     * @return {number} The width of the data column area in the hypergrid.
     */
    getColumnsWidth: function getColumnsWidth(toX) {
        var count = toX === undefined ? this.getActiveColumnCount() : toX,
            total = 0,
            i = this.leftMostColIndex;

        for (; i < count; i++) {
            total += this.getColumnWidth(i);
        }
        return total;
    },

    /**
     * @memberOf Behavior#
     * @desc This exists to support "floating" columns.
     * @return {number} The total width of the fixed columns area.
     */
    getFixedColumnsMaxWidth: function getFixedColumnsMaxWidth() {
        return this.getFixedColumnsWidth();
    },

    /**
     * @memberOf Behavior#
     * @desc delegate setting the cursor up the feature chain of responsibility
     * @param {Hypergrid} grid
     */
    setCursor: function setCursor(grid) {
        grid.updateCursor();
        this.featureChain.setCursor(grid);
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling mouse move to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseMove: function onMouseMove(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseMove(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling tap to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onClick: function onClick(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleClick(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling tap to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onContextMenu: function onContextMenu(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleContextMenu(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling wheel moved to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onWheelMoved: function onWheelMoved(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleWheelMoved(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling tap to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onGridRendered: function onGridRendered(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleGridRendered(grid, event);
            this.setCursor(grid);
        }
    },

    onColumnResizedEvent: function onColumnResizedEvent(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleColumnResizedEvent(grid, event);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling mouse up to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseUp: function onMouseUp(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseUp(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling mouse drag to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseDrag: function onMouseDrag(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseDrag(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling key down to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onKeyDown: function onKeyDown(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleKeyDown(grid, event);
            this.setCursor(grid);
        }
        if (grid.onCtrlShiftAndZ && event.detail.char === 'Z' && event.detail.ctrl && event.detail.shift) {
            grid.onCtrlShiftAndZ();
        } else if (grid.onCtrlAndZ && event.detail.char === 'z' && event.detail.ctrl) {
            grid.onCtrlAndZ();
        }
    },

    onApiDestroyCalled: function onApiDestroyCalled(grid, event) {
        if (this.featureChain) {
            this.featureChain.onApiDestroyCalled(grid, event);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling key up to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onKeyUp: function onKeyUp(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleKeyUp(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling of grid data added event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onDataAdded: function onDataAdded(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleDataAdded(grid, event);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling double click to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onDoubleClick: function onDoubleClick(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleDoubleClick(grid, event);
            this.setCursor(grid);
        }
    },
    /**
     * @memberOf Behavior#
     * @desc delegate handling mouse down to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function handleMouseDown(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseDown(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling mouse down outside current canvas to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleCanvasOutsideMouseDown: function handleCanvasOutsideMouseDown(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleCanvasOutsideMouseDown(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling mouse exit to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseExit: function handleMouseExit(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseExit(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc I've been notified that the behavior has changed.
     */
    changed: function changed() {
        this.grid.behaviorChanged();
    },

    /**
     * @memberOf Behavior#
     * @desc The dimensions of the grid data have changed. You've been notified.
     */
    shapeChanged: function shapeChanged() {
        this.grid.behaviorShapeChanged();
    },

    /**
     * @memberOf Behavior#
     * @desc The dimensions of the grid data have changed. You've been notified.
     */
    stateChanged: function stateChanged() {
        this.grid.behaviorStateChanged();
    },

    /**
     * @memberOf Behavior#
     * @return {boolean} Can re-order columns.
     */
    isColumnReorderable: function isColumnReorderable() {
        return this.deprecated('isColumnReorderable()', 'grid.properties.columnsReorderable', '2.1.3');
    },

    /**
     * @param {index} x - Data x coordinate.
     * @return {Object} The properties for a specific column.
     * @memberOf Behavior#
     */
    getColumnProperties: function getColumnProperties(x) {
        var column = this.getColumn(x);
        return column && column.properties;
    },

    /**
     * @param {index} x - Data x coordinate.
     * @return {Object} The properties for a specific column.
     * @memberOf Behavior#
     */
    setColumnProperties: function setColumnProperties(x, properties) {
        var column = this.getColumn(x);
        if (!column) {
            throw 'Expected column.';
        }
        var result = Object.assign(column.properties, properties);
        this.changed();
        return result;
    },

    /**
     * Clears all cell properties of given column or of all columns.
     * @param {number} [x] - Omit for all columns.
     * @memberOf Behavior#
     */
    clearAllCellProperties: function clearAllCellProperties(x) {
        if (x !== undefined) {
            var column = this.getColumn(x);
            if (column) {
                column.clearAllCellProperties();
            }
        } else if (this.subgrids) {
            this.subgrids.forEach(function (dataModel) {
                for (var i = dataModel.getRowCount(); i--;) {
                    dataModel.setRowMetadata(i);
                }
            });
        }
    },

    /**
     * @memberOf Behavior#
     * @return {string[]} All the currently hidden column header labels.
     */
    getHiddenColumnDescriptors: function getHiddenColumnDescriptors() {
        var tableState = this.grid.properties;
        var indexes = tableState.columnIndexes;
        var labels = [];
        var columnCount = this.getActiveColumnCount();
        for (var i = 0; i < columnCount; i++) {
            if (indexes.indexOf(i) === -1) {
                var column = this.getActiveColumn(i);
                labels.push({
                    id: i,
                    header: column.header,
                    field: column.name
                });
            }
        }
        return labels;
    },

    /**
     * @memberOf Behavior#
     * @return {number} The number of fixed columns.
     */
    getFixedColumnCount: function getFixedColumnCount() {
        return this.grid.properties.fixedColumnCount;
    },

    /**
     * @memberOf Behavior#
     * @desc set the number of fixed columns
     * @param {number} n - the integer count of how many columns to be fixed
     */
    setFixedColumnCount: function setFixedColumnCount(n) {
        this.grid.properties.fixedColumnCount = n;
    },

    /**
     * @summary The number of "fixed rows."
     * @desc The number of (non-scrollable) rows preceding the (scrollable) data subgrid.
     * @memberOf Behavior#
     * @return {number} The sum of:
     * 1. All rows of all subgrids preceding the data subgrid.
     * 2. The first `fixedRowCount` rows of the data subgrid.
     */
    getFixedRowCount: function getFixedRowCount() {
        return this.getHeaderRowCount() + this.grid.properties.fixedRowCount;
    },

    /**
     * @memberOf Behavior#
     * @desc Set the number of fixed rows, which includes (top to bottom order):
     * 1. The header rows
     *    1. The header labels row (optional)
     *    2. The filter row (optional)
     *    3. The top total rows (0 or more)
     * 2. The non-scrolling rows (externally called "the fixed rows")
     *
     * @returns {number} Sum of the above or 0 if none of the above are in use.
     *
     * @param {number} The number of rows.
     */
    setFixedRowCount: function setFixedRowCount(n) {
        this.grid.properties.fixedRowCount = n;
    },

    /**
     * @memberOf Behavior#
     * @desc a dnd column has just been dropped, we've been notified
     */
    endDragColumnNotification: function endDragColumnNotification() {},

    /**
     * @memberOf Behavior#
     * @return {null} the cursor at a specific x,y coordinate
     * @param {number} x - the x coordinate
     * @param {number} y - the y coordinate
     */
    getCursorAt: function getCursorAt(x, y) {
        return null;
    },

    /**
     * Number of _visible_ columns.
     * @memberOf Behavior#
     * @return {number} The total number of columns.
     */
    getActiveColumnCount: function getActiveColumnCount() {
        return this.columns.length;
    },

    /**
     * @summary Column alignment of given grid column.
     * @desc One of:
     * * `'left'`
     * * `'center'`
     * * `'right'`
     *
     * Cascades to grid.
     * @memberOf Behavior#
     * @desc Quietly set the horizontal scroll position.
     * @param {number} x - The new position in pixels.
     */
    setScrollPositionX: function setScrollPositionX(x) {
        /**
         * @memberOf Behavior#
         * @type {number}
         */
        this.scrollPositionX = x;
    },

    getScrollPositionX: function getScrollPositionX() {
        return this.scrollPositionX;
    },

    /**
     * @memberOf Behavior#
     * @desc Quietly set the vertical scroll position.
     * @param {number} y - The new position in pixels.
     */
    setScrollPositionY: function setScrollPositionY(y) {
        /**
         * @memberOf Behavior#
         * @type {number}
         */
        this.scrollPositionY = y;
    },

    getScrollPositionY: function getScrollPositionY() {
        return this.scrollPositionY;
    },

    /**
     * @memberOf Behavior#
     * @return {cellEditor} The cell editor for the cell at the given coordinates.
     * @param {CellEvent} editPoint - The grid cell coordinates.
     */
    getCellEditorAt: function getCellEditorAt(event) {
        return event.isDataColumn && event.column.getCellEditorAt(event);
    },

    /**
     * @memberOf Behavior#
     * @return {boolean} `true` if we should highlight on hover
     * @param {boolean} isColumnHovered - the column is hovered or not
     * @param {boolean} isRowHovered - the row is hovered or not
     */
    highlightCellOnHover: function highlightCellOnHover(isColumnHovered, isRowHovered) {
        return isColumnHovered && isRowHovered;
    },

    /**
     * @memberOf Behavior#
     * @desc this function is a hook and is called just before the painting of a cell occurs
     * @param {Point} cell
     */
    cellPropertiesPrePaintNotification: function cellPropertiesPrePaintNotification(cell) {},

    /**
     * @memberOf Behavior#
     * @desc this function is a hook and is called just before the painting of a fixed row cell occurs
     * @param {Point} cell
     */
    cellFixedRowPrePaintNotification: function cellFixedRowPrePaintNotification(cell) {},

    /**
     * @memberOf Behavior#
     * @desc this function is a hook and is called just before the painting of a fixed column cell occurs
     * @param {Point} cell
     */
    cellFixedColumnPrePaintNotification: function cellFixedColumnPrePaintNotification(cell) {},

    /**
     * @memberOf Behavior#
     * @desc this function is a hook and is called just before the painting of a top left cell occurs
     * @param {Point} cell
     */
    cellTopLeftPrePaintNotification: function cellTopLeftPrePaintNotification(cell) {},

    /**
     * @memberOf Behavior#
     * @desc swap src and tar columns
     * @param {number} src - column index
     * @param {number} tar - column index
     */
    swapColumns: function swapColumns(source, target) {
        var columns = this.columns;
        var tmp = columns[source];
        columns[source] = columns[target];
        columns[target] = tmp;
        this.changed();
    },

    synchronizeSchemaToColumnDefs: function synchronizeSchemaToColumnDefs() {
        this.grid.api.setColumnDefs(this.grid.columnDefs);
    },

    recalculateColumnSizes: function recalculateColumnSizes() {
        this.grid.api.sizeColumnsToFit();
    },

    /**
     * @desc utility method to perform columns reordering
     * @param {number} from - visible columns start index
     * @param {number} len - length of columns set to reorder
     * @param {number} target - new start index of an columns
     * @param {boolean?} broadcastEvent - optional param. If set to 'false', synthetic event will not be fired.
     * Useful, when reordering not initiated by user, and don't need to affect side effects
     * @param {boolean?} givenHiddenColumns - if true, method performed like all the columns is shown and indexes
     * of visible columns and all columns are equal
     */
    moveColumns: function moveColumns(from, len, target) {
        var _this = this;

        var broadcastEvent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var givenHiddenColumns = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

        this.log('moveColumns called with params', from, len, target, broadcastEvent, givenHiddenColumns);
        var columns = this.columns;

        var visibleColDefs = this.grid.visibleColumnDefs;
        var colDefs = this.grid.columnDefs;

        var colDefsToMove = givenHiddenColumns ? colDefs.slice(0).splice(from, len) : visibleColDefs.slice(0).splice(from, len);

        var headers = [];
        if (this.grid.properties.onlyDataReorder) {
            headers = columns.map(function (c) {
                return c.header;
            });
        }

        if (!givenHiddenColumns) {
            var visibleColumnWithTargetIndex = visibleColDefs[target];
            target = colDefs.indexOf(visibleColumnWithTargetIndex);
        }

        var movedColumns = [];
        var colDefsPrepared = colDefsToMove;
        if (colDefs.indexOf(colDefsToMove[0]) >= target) {
            colDefsPrepared = colDefsToMove.reverse();
        }
        colDefsPrepared.forEach(function (colDef) {
            var columnWithSameColDef = columns.find(function (c) {
                return c.colDef === colDef;
            });
            if (columnWithSameColDef) {
                movedColumns.unshift(columnWithSameColDef);
            }

            var currentColDefIndex = colDefs.indexOf(colDef);
            colDefs.splice(target, 0, colDefs.splice(currentColDefIndex, 1)[0]);

            _this.log('ColDef with index ' + currentColDefIndex + ' moved to ' + target);
        });

        this.synchronizeSchemaToColumnDefs();

        if (broadcastEvent) {
            this.grid.fireSyntheticColumnsMovedEvent(movedColumns, target);
        }

        this.grid.visibleColumnDefs = colDefs.filter(function (cd) {
            return !cd.isHidden;
        });

        if (this.grid.properties.onlyDataReorder) {
            columns.forEach(function (c, i) {
                return c.header = headers[i];
            });
        }

        this.changed();
    },

    convertViewPointToDataPoint: function convertViewPointToDataPoint(unscrolled) {
        return new Point(this.getActiveColumn(unscrolled.x).index, unscrolled.y);
    },

    /**
     * @desc shows, is row with this index represents aggregation
     * @type {boolean}
     * @memberOf CellEvent#
     */
    isAggregationRowByIndex: function isAggregationRowByIndex(rowIndex) {
        var row = this.grid.getRow(rowIndex);

        return this.isAggregationRow(row);
    },

    /**
     * @desc shows, is row represents aggregation
     * @type {boolean}
     * @memberOf CellEvent#
     */
    isAggregationRow: function isAggregationRow(row) {
        return !!row && typeof row.$$aggregation !== 'undefined';
    },

    /**
     * @desc returns array of child rows of an row by index
     * @type {array}
     * @memberOf CellEvent#
     */
    getChildRowsByIndex: function getChildRowsByIndex(rowIndex) {
        var row = this.grid.getRow(rowIndex);

        return this.getChildRows(row);
    },
    /**
     * @desc returns array of child rows of an row if exists
     * @type {array}
     * @memberOf CellEvent#
     */
    getChildRows: function getChildRows(row) {
        return !!row && row.$$children ? row.$$children : [];
    },

    /**
     * @desc shows, is row with index contains aggregated subrows
     * @type {boolean}
     * @memberOf CellEvent#
     */
    hasChildRowsByIndex: function hasChildRowsByIndex(rowIndex) {
        return this.getChildRowsByIndex(rowIndex).length > 0;
    },

    /**
     * @desc shows, is row contains aggregated subrows
     * @type {boolean}
     * @memberOf CellEvent#
     */
    hasChildRows: function hasChildRows(row) {
        return this.getChildRows(row).length > 0;
    },

    /**
     * @desc returns count of aggregated child rows by parent row index
     * @type {number}
     * @memberOf CellEvent#
     */
    getAggregationChildCountByIndex: function getAggregationChildCountByIndex(rowIndex) {
        var row = this.grid.getRow(rowIndex);

        return this.getAggregationChildCount(row);
    },

    /**
     * @desc returns count of aggregated child rows
     * @type {number}
     * @memberOf CellEvent#
     */
    getAggregationChildCount: function getAggregationChildCount(row) {
        return !!row && !!row.$$cluster_size ? row.$$cluster_size : 0;
    },

    isExpandableRowByIndex: function isExpandableRowByIndex(rowIndex) {
        var row = this.grid.getRow(rowIndex);
        return this.isExpandableRow(row);
    },

    isExpandableRow: function isExpandableRow(row) {
        return !!row && row.$$expandable ? row.$$expandable : false;
    },

    isRowExpandedByIndex: function isRowExpandedByIndex(rowIndex) {
        var row = this.grid.getRow(rowIndex);

        return this.isRowExpanded(row);
    },

    isRowExpanded: function isRowExpanded(row) {
        return !!row && row.$$open ? row.$$open : false;
    },

    getRowTreeLevelByIndex: function getRowTreeLevelByIndex(rowIndex) {
        var row = this.grid.getRow(rowIndex);

        return this.getRowTreeLevel(row);
    },

    getRowTreeLevel: function getRowTreeLevel(row) {
        return !!row && row.__treeLevel !== undefined ? row.__treeLevel : false;
    },

    hasTreeColumn: function hasTreeColumn(columnIndex) {
        return true;
    },

    getSelectionMatrixFunction: function getSelectionMatrixFunction(selectedRows) {
        return function () {
            return null;
        };
    },

    getRowHeaderColumn: function getRowHeaderColumn() {
        return this.allColumns[this.rowColumnIndex];
    },

    getHeaderColumnByName: function getHeaderColumnByName(nameToFind) {
        return this.columns.find(function (c) {
            return c.name === nameToFind;
        });
    },

    autosizeAllColumns: function autosizeAllColumns() {
        this.checkColumnAutosizing(true);
        this.changed();
    },

    checkColumnAutosizing: function checkColumnAutosizing(force) {
        force = force === true;
        var autoSized = this.autoSizeRowNumberColumn() || this.hasTreeColumn() && this.getRowHeaderColumn().checkColumnAutosizing(force);
        this.allColumns.forEach(function (column) {
            autoSized = column.checkColumnAutosizing(force) || autoSized;
        });
        return autoSized;
    },

    autoSizeRowNumberColumn: function autoSizeRowNumberColumn() {
        if (this.grid.properties.showRowNumbers && this.grid.properties.rowNumberAutosizing) {
            return this.getRowHeaderColumn().checkColumnAutosizing(true);
        }
    },

    getColumns: function getColumns() {
        return this.allColumns;
    },

    getActiveColumns: function getActiveColumns() {
        return this.columns;
    },

    getHiddenColumns: function getHiddenColumns() {
        var visible = this.columns;
        var all = this.allColumns;
        var hidden = [];
        for (var i = 0; i < all.length; i++) {
            if (visible.indexOf(all[i]) === -1) {
                hidden.push(all[i]);
            }
        }
        hidden.sort(function (a, b) {
            return a.header < b.header;
        });
        return hidden;
    },

    getSelectedRows: function getSelectedRows() {
        return this.grid.selectionModel.getSelectedRows();
    },

    getSelectedColumns: function getSelectedColumns() {
        return this.grid.selectionModel.getSelectedColumns();
    },

    getSelections: function getSelections() {
        return this.grid.selectionModel.getSelections();
    },

    log: function log() {
        var _grid;

        (_grid = this.grid).log.apply(_grid, arguments);
    }
});

// define constants as immutable (i.e., !writable)
Object.defineProperties(Behavior.prototype, {
    treeColumnIndex: { value: -1 },
    rowColumnIndex: { value: -2 }
});

function warnBehaviorFeaturesDeprecation() {
    var featureNames = [],
        unregisteredFeatures = [],
        n = 0;

    this.features.forEach(function (FeatureConstructor) {
        var className = FeatureConstructor.prototype.$$CLASS_NAME || FeatureConstructor.name,
            featureName = className || 'feature' + n++;

        // build list of feature names
        featureNames.push(featureName);

        // build list of unregistered features
        if (!this.featureRegistry.get(featureName, true)) {
            var constructorName = FeatureConstructor.name || FeatureConstructor.prototype.$$CLASS_NAME || 'FeatureConstructor' + n,
                params = [];
            if (!className) {
                params.push('\'' + featureName + '\'');
            }
            params.push(constructorName);
            unregisteredFeatures.push(params.join(', '));
        }
    }, this);

    if (featureNames.length) {
        var sampleCode = 'Hypergrid.defaults.features = [\n' + join('\t\'', featureNames, '\',\n') + '];';

        if (unregisteredFeatures.length) {
            sampleCode += '\n\nThe following custom features are unregistered and will need to be registered prior to behavior instantiation:\n\n' + join('Features.add(', unregisteredFeatures, ');\n');
        }

        if (n) {
            sampleCode += '\n\n(You should provide meaningful names for your custom features rather than the generated names above.)';
        }

        console.warn('`grid.behavior.features` (array of feature constructors) has been deprecated as of version 2.1.0 in favor of `grid.properties.features` (array of feature names). Remove `features` array from your behavior and add `features` property to your grid state object (or Hypergrid.defaults), e.g.:\n\n' + sampleCode);
    }
}

function join(prefix, array, suffix) {
    return prefix + array.join(suffix + prefix) + suffix;
}

// synonyms

/**
 * Synonym of {@link Behavior#reindex}.
 * @name applyAnalytics
 * @deprecated
 * @memberOf Behavior#
 */
Behavior.prototype.applyAnalytics = Behavior.prototype.reindex;

// mix-ins
Behavior.prototype.mixIn(require('./rowProperties').mixin);
Behavior.prototype.mixIn(require('./cellProperties').behaviorMixin);
Behavior.prototype.mixIn(require('./subgrids').mixin);

module.exports = Behavior;

},{"../Base":17,"../defaults.js":65,"../features":84,"../lib/cellEventFactory":92,"./Column":34,"./cellProperties":36,"./rowProperties":43,"./subgrids":44,"rectangular":14}],34:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var overrider = require('overrider');

var toFunction = require('../lib/toFunction');
var HypergridError = require('../lib/error');
var images = require('../../images');

/** @summary Create a new `Column` object.
 * @see {@link module:Cell} is mixed into Column.prototype.
 * @mixes cellProperties.columnMixin
 * @mixes columnProperties.mixin
 * @constructor
 * @param behavior
 * @param {number|string|object} indexOrOptions - One of:
 * * If a positive number, valid index into `fields` array.
 * * If a string, a name in the `fields` array.
 * * If an object, must contain either an `index` or a `name` property.
 *
 * Positive values of `index` are "real" fields; see also {@link Column#setProperties|setProperties} which is called to set the remaining properties specified in `options`.
 *
 * Negative values of `index` are special cases:
 * `index` | Meaning
 * :-----: | --------
 *    -1   | Row header column
 *    -2   | Tree (drill-down) column
 */
function Column(behavior, index) {
    var options, icon;

    this.behavior = behavior;
    this.dataModel = behavior.dataModel;

    if ((typeof index === 'undefined' ? 'undefined' : _typeof(index)) === 'object') {
        options = index;
        index = options.index !== undefined ? options.index : options.name;
    } else {
        options = {};
    }

    this.schema = this.behavior.schema[index];

    if (!this.schema) {
        throw 'Column not found in data.';
    }

    this.properties = options;

    switch (index) {
        case this.behavior.treeColumnIndex:
            // Width of icon + 3-pixel spacer (checked and unchecked should be same width)
            icon = images[Object.create(this.properties.treeHeader, { isDataRow: { value: true } }).leftIcon];
            this.properties.minimumColumnWidth = icon ? icon.width + 3 : 0;
            break;

        case this.behavior.rowColumnIndex:
            break;

        default:
            if (index < 0) {
                throw '`index` out of range';
            }
    }
}

Column.prototype = {
    constructor: Column.prototype.constructor,
    $$CLASS_NAME: 'Column',

    HypergridError: HypergridError,

    mixIn: overrider.mixIn,

    /**
     * @summary Index of this column in the `fields` array.
     * @returns {number}
     */
    get index() {
        // read-only (no setter)
        return this.schema.index;
    },

    /**
     * @summary Name of this column from the `fields` array.
     * @returns {string|undefined} Returns `undefined` if the column is not in the schema (such as for handle column).
     */
    get name() {
        // read-only (no setter)
        return this.schema.name;
    },

    /**
     * @summary alias to name
     * @returns {string|undefined} Returns `undefined` if the column is not in the schema (such as for handle column).
     */
    get colId() {
        // read-only (no setter)
        return this.colDef && this.colDef.colId || this.schema.name;
    },

    get colDef() {
        // read-only (no setter)
        return this.properties.colDef;
    },

    get treeLevel() {
        // read-only (no setter)
        return this.colDef ? this.colDef.treeLevel : undefined;
    },

    /**
     * @summary Get or set the text of the column's header.
     * @desc The _header_ is the label at the top of the column.
     *
     * Setting the header updates both:
     * * the `schema` (aka, header) array in the underlying data source; and
     * * the filter.
     * @type {string}
     */
    set header(headerText) {
        if (headerText === undefined) {
            delete this.schema.header;
        } else {
            this.schema.header = headerText;
        }
        this.behavior.grid.repaint();
    },
    get header() {
        return this.schema.header;
    },

    /**
     * @summary Get or set the computed column's calculator function.
     * @desc Setting the value here updates the calculator in the data model schema.
     *
     * The results of the new calculations will appear in the column cells on the next repaint.
     * @type {string}
     */
    set calculator(calculator) {
        if (calculator) {
            calculator = resolveCalculator.call(this, calculator);
            if (calculator !== this.schema.calculator) {
                if (calculator === undefined) {
                    delete this.schema.calculator;
                } else {
                    this.schema.calculator = calculator;
                }
                this.behavior.reindex();
            }
        } else if (this.schema.calculator) {
            delete this.schema.calculator;
            this.behavior.reindex();
        }
    },
    get calculator() {
        return this.schema.calculator;
    },

    get searchType() {
        return this.colDef && this.colDef.searchType;
    },

    /**
     * @summary Get or set the type of the column's header.
     * @desc Setting the type updates the filter which typically uses this information for proper collation.
     *
     * @todo: Instead of using `this._type`, put on data source like the other essential properties. In this case, sorter could use the info to choose a comparator more intelligently and efficiently.
     * @type {string}
     */
    set type(type) {
        if (type === undefined) {
            delete this.schema.type;
        } else {
            this.schema.type = type;
        }
        this.behavior.reindex();
    },
    get type() {
        return this.schema.type;
    },

    getCount: function getCount(y) {
        return this.dataModel.getCount(this.index, y);
    },

    getValue: function getValue(y) {
        return this.dataModel.getValue(this.index, y);
    },

    setValue: function setValue(y, value) {
        return this.dataModel.setValue(this.index, y, value);
    },

    getWidth: function getWidth() {
        return this.properties.width || this.properties.defaultColumnWidth;
    },

    setWidth: function setWidth(width) {
        width = Math.max(this.properties.minimumColumnWidth, width);

        if (this.properties.maxWidth && width > this.properties.maxWidth) {
            width = this.properties.maxWidth;
        }

        if (width !== this.properties.width) {
            this.properties.width = width;
            this.schema.width = width;
            this.properties.columnAutosizing = false;
        }
    },

    checkColumnAutosizing: function checkColumnAutosizing(force) {
        var properties = this.properties,
            width,
            preferredWidth,
            autoSized;

        if (properties.columnAutosizing) {
            width = properties.width;
            preferredWidth = properties.preferredWidth || width;
            force = force || !properties.columnAutosized;
            if (width !== preferredWidth || force && preferredWidth !== undefined) {
                properties.width = force ? preferredWidth : Math.max(width, preferredWidth);
                properties.columnAutosized = !isNaN(properties.width);
                autoSized = properties.width !== width;
            }
        }

        return autoSized;
    },

    getCellType: function getCellType(y) {
        var value = this.getValue(y);
        return this.typeOf(value);
    },

    getType: function getType() {
        var props = this.properties;
        var type = props.type;
        if (!type) {
            type = this.computeColumnType();
            if (type !== 'unknown') {
                props.type = type;
            }
        }
        return type;
    },

    computeColumnType: function computeColumnType() {
        var headerRowCount = this.behavior.getHeaderRowCount();
        var height = this.behavior.getRowCount();
        var value = this.getValue(headerRowCount);
        var eachType = this.typeOf(value);
        if (!eachType) {
            return 'unknown';
        }
        var type = this.typeOf(value);
        //var isNumber = ((typeof value) === 'number');
        for (var y = headerRowCount; y < height; y++) {
            value = this.getValue(y);
            eachType = this.typeOf(value);
            // if (type !== eachType) {
            //     if (isNumber && (typeof value === 'number')) {
            //         type = 'float';
            //     } else {
            //         return 'mixed';
            //     }
            // }
        }
        return type;
    },

    typeOf: function typeOf(something) {
        if (something == null) {
            return null;
        }
        var typeOf = typeof something === 'undefined' ? 'undefined' : _typeof(something);
        switch (typeOf) {
            case 'object':
                return something.constructor.name.toLowerCase();
            case 'number':
                return parseInt(something) === something ? 'int' : 'float';
            default:
                return typeOf;
        }
    },

    get properties() {
        return this._properties;
    },
    set properties(ownProperties) {
        this._properties = this.createColumnProperties();
        this.addProperties(ownProperties);
    },

    /** This method is provided because some grid renderer optimizations require that the grid renderer be informed when column colors change. Due to performance concerns, they cannot take the time to figure it out for themselves. Along the same lines, making the property a getter/setter (in columnProperties.js), though doable, might present performance concerns as this property is possibly the most accessed of all column properties.
     * @param color
     */
    setBackgroundColor: function setBackgroundColor(color) {
        if (this.properties.backgroundColor !== color) {
            this.properties.backgroundColor = color;
            this.behavior.grid.renderer.rebundleGridRenderers();
        }
    },

    addProperties: function addProperties(properties) {
        var key,
            descriptor,
            obj = this.properties;

        for (key in properties) {
            if (properties.hasOwnProperty(key)) {
                descriptor = Object.getOwnPropertyDescriptor(obj, key);
                if (!descriptor || descriptor.writable || descriptor.set) {
                    obj[key] = properties[key];
                }
            }
        }
    },

    /**
     * @summary Get a new cell editor.
     * @desc The cell editor to use must be registered with the key in the cell's `editor` property.
     *
     * The cell's `format` property is mixed into the provided cellEvent for possible overriding by developer's override of {@link DataModel.prototype.getCellEditorAt} before being used by {@link CellEditor} to parse and format the cell value.
     *
     * @param {CellEvent} cellEvent
     *
     * @returns {undefined|CellEditor} Falsy value means either no declared cell editor _or_ instantiation aborted by falsy return from `fireRequestCellEdit`.
     */
    getCellEditorAt: function getCellEditorAt(cellEvent) {
        var columnIndex = this.index,
            rowIndex = cellEvent.gridCell.y,
            editorName = cellEvent.properties.editor,
            options = Object.create(cellEvent, {
            format: {
                // `options.format` is a copy of the cell's `format` property which is:
                // 1. Subject to adjustment by the `getCellEditorAt` override.
                // 2. Then used by the cell editor to reference the registered localizer (defaults to 'string' localizer)
                writable: true,
                enumerable: true, // so cell editor will copy it to self
                value: cellEvent.properties.format
            }
        }),
            cellEditor = this.dataModel.getCellEditorAt(columnIndex, rowIndex, editorName, options);

        if (cellEditor && !cellEditor.grid) {
            // cell editor returned but not fully instantiated (aborted by falsy return from fireRequestCellEdit)
            cellEditor = undefined;
        }

        return cellEditor;
    },

    getFormatter: function getFormatter() {
        var localizerName = this.properties.format;
        return this.behavior.grid.localization.get(localizerName).format;
    }
};

var REGEX_ARROW_FUNC = /^(\(.*\)|\w+)\s*=>/;

/**
 * Calculators are functions. Column calculators are saved in `grid.properties.calculators` using the function name as key. Anonymous functions use the stringified function itself as the key. This may seem pointless, but this achieves the objective here which is to share function instances.
 * @throws {HypergridError} Unexpected input.
 * @throws {HypergridError} Arrow function not permitted.
 * @throws {HypergridError} Unknown function.
 * @this {Column}
 * @param {function|string} calculator - One of:
 * * calculator function
 * * stringified calculator function with or without function name
 * * function name of a known function (already in `calculators`)
 * * falsy value
 * @returns {function} Shared calculator instance or `undefined` if input was falsy.
 */
function resolveCalculator(calculator) {
    if (!calculator) {
        return undefined;
    }

    if (typeof calculator === 'function') {
        calculator = calculator.toString();
    } else if (typeof calculator !== 'string') {
        throw new HypergridError('Expected function OR string containing function OR function name the "' + this.name + '" column calculator.');
    }

    var matches,
        key,
        calculators = this.behavior.grid.properties.calculators || (this.behavior.grid.properties.calculators = {});

    if (/^\w+$/.test(calculator)) {
        key = calculator; // just a function name
        if (!calculators[key]) {
            throw new HypergridError('Unknown function name "' + key + '" for "' + this.name + '" column calculator.');
        }
    } else {
        matches = calculator.match(/^function\s*(\w+)\(/);

        if (matches) {
            key = matches[1]; // function name extracted from stringified function
        } else {
            key = calculator; // anonymous stringified function
        }

        if (!calculators[key]) {
            // neither a string nor a function (previoulsy functionified string)?
            if (REGEX_ARROW_FUNC.test(calculator)) {
                throw new HypergridError('Arrow function not permitted as column calculator (for column "' + this.name + '").');
            }
            calculators[key] = calculator;
        }
    }

    calculators[key] = toFunction(calculators[key]); // functionifies existing `calculators` entries as well as new entries

    return calculators[key];
}

Column.prototype.mixIn(require('./cellProperties').columnMixin);
Column.prototype.mixIn(require('./columnProperties').mixin);

module.exports = Column;

},{"../../images":3,"../lib/error":95,"../lib/toFunction":100,"./cellProperties":36,"./columnProperties":38,"overrider":13}],35:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Behavior = require('./Behavior');

/** @name DataSource
 * @memberOf Behavior#
 * @default require('datasaur-local')
 * @summary Default data source.
 * @desc If defined, will be used as a default data source for newly instantiated `Hypergrid` objects without `DataSource` or `dataSource` options specified. Scheduled for removal in next version (v4).
 */
var DefaultDataModel = require('../DatasaurLocal');

var decorators = require('./dataModel/decorators');

var GRAND_TOTAL = '$$grand_total';

/**
 * This class mimics the {@link dataModelAPI}.
 * > This constructor (actually {@link Local#initialize}) will be called upon instantiation of this class or of any class that extends from this class. See {@link https://github.com/joneit/extend-me|extend-me} for more info.
 * @constructor
 * @extends Behavior
 */
var Local = Behavior.extend('Local', {

    initialize: function initialize(grid, options) {
        this.setData(options);
    },

    /**
     * @memberOf Local#
     * @description Create columns based on old value of grid.columns
     */
    createColumns: function createColumns() {
        var _this = this;

        var oldColumns = this.columns;
        var oldAllColumns = this.allColumns;

        Behavior.prototype.createColumns.call(this);

        this.schema.forEach(function (columnSchema, index) {
            var findFunction = function findFunction(c) {
                return c.properties.index === index && c.properties.name === columnSchema.name && c.properties.calculator === columnSchema.calculator && c.colDef === columnSchema.colDef;
            };
            var oldColumn = oldAllColumns.find(findFunction) || oldColumns.find(findFunction);
            var oldColumnColdDef = oldAllColumns.find(function (c) {
                return c.colDef && c.colDef === columnSchema.colDef;
            }) || oldColumns.find(function (c) {
                return c.colDef === columnSchema.colDef;
            });

            if (oldColumn) {
                var newColumn = _this.addColumn(oldColumn.properties);
                var props = newColumn.properties;

                // disable resizing for old resized columns
                // when data was added to existed array of data
                if (props.width === props.preferredWidth && props.columnAutosizing && props.columnAutosized) {
                    props.columnAutosizing = false;
                }
            } else {
                var _newColumn = _this.addColumn({
                    index: index,
                    header: columnSchema.header,
                    calculator: columnSchema.calculator,
                    colDef: columnSchema.colDef
                });

                // restore width from previous schema when data just refreshed.
                // this is needed because of almost total refresh of grid
                if (columnSchema.width) {
                    Object.assign(_newColumn.properties, {
                        width: columnSchema.width,
                        columnAutosizing: false
                    });
                } else if (oldColumnColdDef) {
                    var _props = oldColumnColdDef.properties;

                    // disable resizing for old resized columns
                    // when data was added to existed array of data
                    Object.assign(_newColumn.properties, {
                        width: _props.width,
                        preferredWidth: _props.preferredWidth,
                        columnAutosizing: _props.columnAutosizing,
                        columnAutosized: _props.columnAutosized
                    });
                }

                if (columnSchema.formatter) {
                    _newColumn.properties.format = _newColumn.name;
                    _newColumn.schema.format = _newColumn.name;
                    var options = {
                        name: _newColumn.name,
                        format: columnSchema.formatter, // called for render view
                        parse: function parse(value) {
                            return value;
                        }, // called for render value in editor
                        locale: 'en'
                    };
                    _this.grid.localization.add(_newColumn.name, options);
                }

                ['halign', 'maxWidth', 'cellContextMenu'].forEach(function (key) {
                    if (columnSchema[key]) {
                        _newColumn.properties[key] = columnSchema[key];
                    }
                });
            }
        }, this);
    },

    /**
     * @memberOf Local#
     * @description Calculate column prefered size based on cells content
     * @param {number|object} xOrColumn - column object or index
     * @param {boolean} force - if true, width will be changed even if column autosizing disabled
     */
    fitColumn: function fitColumn(xOrColumn, force) {
        var _this2 = this;

        if ((typeof xOrColumn === 'undefined' ? 'undefined' : _typeof(xOrColumn)) !== 'object') {
            xOrColumn = this.getColumn(xOrColumn);
        }

        var column = xOrColumn;
        var data = this.getData();
        var gc = this.grid.canvas.gc;

        var props = column.properties;

        var width = column.width || props.defaultColumnWidth;

        // get max width based of
        data.forEach(function (d, i) {
            var val = column.getValue(i);
            var schema = column.schema;

            if (val && ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) !== 'object' || val instanceof Array)) {
                var widths = {};

                var dataProps = _this2.getRowProperties(i) || props;
                widths.cellPaddingRight = props.cellPaddingRight;

                if (dataProps.showCellContextMenuIcon) {
                    gc.cache.font = props.contextMenuIconFont;
                    widths.showCellContextMenuIcon = props.contextMenuButtonIconPreferedWidth + 2 * props.contextMenuButtonPadding + props.contextMenuLeftSpaceToCutText;
                }

                if (dataProps.showColumnType && schema.colTypeSign) {
                    widths.colTypeSign = (widths.showCellContextMenuIcon || 0) + widths.cellPaddingRight;
                }

                if (schema && schema.headerPrefix && dataProps.headerRow) {
                    gc.cache.font = props.columnTitlePrefixFont;
                    widths.headerPrefix = gc.getTextWidth(schema.headerPrefix) + props.columnTitlePrefixRightSpace;
                }

                if (column.hasError && dataProps.headerRow) {
                    gc.cache.font = props.errorIconFont;
                    widths.hasError = gc.getTextWidth(props.errorIconUnicodeChar) + props.columnTitlePrefixRightSpace;
                }

                if (column.name.startsWith('$$aggregation')) {
                    var treeLevel = _this2.getRowTreeLevel(d);
                    var treeOffset = treeLevel ? _this2.getRowTreeLevel(d) * props.aggregationGroupTreeLevelOffset : 0;
                    widths.treeOffset = treeOffset;

                    var aggregationCount = _this2.getAggregationChildCount(d);
                    if (aggregationCount > 0) {
                        gc.cache.font = props.cellValuePostfixFont;
                        widths.aggregationCount = props.cellPaddingLeft + treeOffset + gc.getTextWidth('(' + aggregationCount + ')') + props.cellValuePostfixLeftOffset;
                    }
                }

                if (_this2.isExpandableRow(d) || _this2.dataModel.getHasChildColumnsFromCell(column.index, i)) {
                    var valuePrefix = props['aggregationGroupExpandIcon' + (_this2.isRowExpanded(d) ? 'Collapsed' : 'Expanded') + 'Char'];
                    if (valuePrefix) {
                        gc.cache.font = props.aggregationGroupExpandIconFont;
                        widths.valuePrefix = gc.getTextWidth(valuePrefix) + props.columnTitlePrefixRightSpace;
                    }
                }

                var count = column.getCount(i);
                if (count !== undefined) {
                    gc.cache.font = props.cellValuePostfixFont;
                    widths.valuePostfix = gc.getTextWidth('(' + count + ')') + props.cellValuePostfixLeftOffset;
                }

                gc.cache.font = dataProps.font;
                widths.val = gc.getTextWidth(_this2.grid.formatValue(column.name, val, dataProps.headerRow)) + props.cellPaddingLeft;

                // console.log('widths', val, widths);
                var textWidth = Object.values(widths).reduce(function (a, b) {
                    return a + b;
                }, 0);
                // console.log('textWidth', textWidth);

                var colspan = _this2.dataModel.getColspan(column.index, i);
                if (colspan > 0) {
                    textWidth = textWidth / (colspan + 1);
                    for (var _i = column.index; _i <= column.index + colspan; ++_i) {
                        _this2.getColumn(_i).width = textWidth;
                    }
                }

                if (textWidth > width) {
                    width = textWidth;
                }
            }
        });

        if (width > props.maxWidth) {
            width = props.maxWidth;
        }

        props.preferredWidth = Math.ceil(width);

        if (force || props.columnAutosizing) {
            if (props.preferredWidth > 0) {
                column.setWidth(props.preferredWidth);
            }
        }
    },

    /**
     * @memberOf Local#
     * @description Recalculate all columns prefered sizes
     * @return {array} - affected columns
     */
    fitColumns: function fitColumns() {
        var _this3 = this;

        var gc = this.grid.canvas.gc;
        var oldFont = gc.cache.font;
        this.allColumns.forEach(function (c) {
            return _this3.fitColumn(c);
        });
        gc.cache.font = oldFont;

        return this.allColumns;
    },

    /**
     * @memberOf Local#
     * @description Find columns by given group Id and recalculate prefered size for each
     * @param {string} groupId - column group id
     * @return {array} - affected columns
     */
    fitColumnsGroup: function fitColumnsGroup(groupId) {
        var _this4 = this;

        var columnsToFit = this.allColumns.filter(function (ac) {
            return ac.schema && ac.schema.topGroupsIds && ac.schema.topGroupsIds.includes(groupId);
        });

        if (columnsToFit.length > 0) {
            var gc = this.grid.canvas.gc;
            var oldFont = gc.cache.font;
            columnsToFit.forEach(function (c) {
                return _this4.fitColumn(c);
            });
            gc.cache.font = oldFont;
        }

        return columnsToFit;
    },

    /**
     * @memberOf Local#
     * @description Set the header labels.
     * @param {string[]|object} headers - The header labels. One of:
     * * _If an array:_ Must contain all headers in column order.
     * * _If a hash:_ May contain any headers, keyed by field name, in any order.
     */
    setHeaders: function setHeaders(headers) {
        if (headers instanceof Array) {
            // Reset all headers
            var allColumns = this.allColumns;
            headers.forEach(function (header, index) {
                allColumns[index].header = header; // setter updates header in both column and data source objects
            });
        } else if ((typeof headers === 'undefined' ? 'undefined' : _typeof(headers)) === 'object') {
            // Adjust just the headers in the hash
            this.allColumns.forEach(function (column) {
                if (headers[column.name]) {
                    column.header = headers[column.name];
                }
            });
        }
    },

    /**
     * @memberOf Local#
     * @summary Set grid data.
     * @desc Exits without doing anything if no data (`dataRows` undefined or omitted and `options.data` undefined).
     *
     * @param {function|object[]} [dataRows=options.data] - Array of uniform data row objects or function returning same.
     *
     * @param {object} [options] - _(Promoted to first argument position when `dataRows` omitted.)_
     *
     * @param {function|object[]} [options.data] - Passed to behavior constructor. May be:
     * * An array of congruent raw data objects
     * * A function returning same
     * * Omit for non-local datasources
     *
     * @param {function|menuItem[]} [options.schema] - Passed to behavior constructor. May be:
     * * A schema array
     * * A function returning same. Called at filter reset time with behavior as context.
     * * Omit to allow the data model to generate a basic schema from its data.
     *
     * @param {boolean} [options.apply=true] Apply data transformations to the new data.
     */
    setData: function setData(dataRows, options) {
        if (!(Array.isArray(dataRows) || typeof dataRows === 'function')) {
            options = dataRows;
            dataRows = options && options.data;
        }

        dataRows = this.unwrap(dataRows);

        if (dataRows === undefined) {
            return;
        }

        if (!Array.isArray(dataRows)) {
            throw 'Expected data to be an array (of data row objects).';
        }

        options = options || {};

        var grid = this.grid,
            schema = this.unwrap(options.schema),
            // *always* define a new schema on reset
        schemaChanged = schema || !this.subgrids.lookup.data.getColumnCount(),
            // schema will change if a new schema was provided OR data model has an empty schema now, which triggers schema generation on setData below
        reindex = options.apply === undefined || options.apply; // defaults to true

        // copy widths from old schema
        if (schemaChanged && this.schemaOld && schema) {
            var schemaOld = this.schemaOld;
            schema.forEach(function (columnSchema, index) {
                if (schemaOld[index] && index === schemaOld[index].index && columnSchema.name === schemaOld[index].name && schemaOld[index].width) {
                    columnSchema.width = schemaOld[index].width;
                }
            });
        }

        // Inform interested data models of data.
        this.subgrids.forEach(function (dataModel) {
            dataModel.setData(dataRows, schema);
        });

        if (grid.cellEditor) {
            grid.cellEditor.cancelEditing();
        }

        if (reindex) {
            this.reindex();
        }

        if (schemaChanged) {
            this.createColumns();
        }

        this.checkForErrors();

        grid.allowEvents(this.getRowCount());
    },

    /**
     * @memberOf Local#
     * @summary Add grid data.
     * @desc Exits without doing anything if no data (`dataRows` undefined or omitted and `options.data` undefined).
     *
     * @param {function|object[]} [dataRows=options.data] - Array of uniform data row objects or function returning same.
     *
     * @param {object} [options] - _(Promoted to first argument position when `dataRows` omitted.)_
     *
     * @param {function|object[]} [options.data] - Passed to behavior constructor. May be:
     * * An array of congruent raw data objects
     * * A function returning same
     * * Omit for non-local datasources
     *
     * @param {function|menuItem[]} [options.schema] - Passed to behavior constructor. May be:
     * * A schema array
     * * A function returning same. Called at filter reset time with behavior as context.
     * * Omit to allow the data model to generate a basic schema from its data.
     *
     * @param {boolean} [options.apply=true] Apply data transformations to the new data.
     */
    addData: function addData(dataRows, options) {
        if (!(Array.isArray(dataRows) || typeof dataRows === 'function')) {
            options = dataRows;
            dataRows = options && options.data;
        }

        dataRows = this.unwrap(dataRows);

        if (dataRows === undefined) {
            return;
        }

        if (!Array.isArray(dataRows)) {
            throw 'Expected data to be an array (of data row objects).';
        }

        options = options || {};

        var grid = this.grid,
            schema = this.unwrap(options.schema),
            // *always* define a new schema on reset
        schemaChanged = schema || !this.subgrids.lookup.data.getColumnCount(),
            // schema will change if a new schema was provided OR data model has an empty schema now, which triggers schema generation on setData below
        reindex = options.apply === undefined || options.apply; // defaults to true

        // Inform interested data models of data.
        this.subgrids.forEach(function (dataModel) {
            if (dataModel.addData) {
                dataModel.addData(dataRows, schema);
            }
        });

        if (grid.cellEditor) {
            grid.cellEditor.cancelEditing();
        }

        if (reindex) {
            this.reindex();
        }

        if (schemaChanged) {
            this.createColumns();
        }

        this.checkForErrors();

        grid.allowEvents(this.getRowCount());
    },

    /**
     * @memberOf Local#
     * @description Get errors summary object
     * @return {object} - errors summary
     */
    getColumnsErrors: function getColumnsErrors() {
        return this.errors;
    },

    /**
     * @memberOf Local#
     * @description Check grid data errors, and fill "errors" object using found errors data
     */
    checkForErrors: function checkForErrors() {
        var _this5 = this;

        this.errors = {};

        this.getData().forEach(function (row) {
            Object.keys(row).forEach(function (columnName) {
                var value = row[columnName];
                if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.type === 'ERROR') {
                    if (!_this5.errors[columnName]) {
                        _this5.errors[columnName] = [];
                    }
                    _this5.errors[columnName].push(value);
                }
            });
        });

        this.errorCount = Object.keys(this.errors).length;

        if (this.errorCount) {
            Object.keys(this.errors).forEach(function (columnName) {
                var column = _this5.grid.getColumnByName(columnName);
                if (column) {
                    column.hasError = true;
                    column.errorCount = _this5.errors[columnName].length;
                    column.firstError = _this5.errors[columnName][0];

                    var colDef = column.colDef;
                    if (colDef) {
                        colDef.errorCount = _this5.errors[columnName].length;
                    }
                }
            });
        }
    },

    /**
     * Create a new data model
     * @param {object} [options]
     * @param {dataModelAPI} [options.dataModel] - A fully instantiated data model object.
     * @param {function} [options.DataModel=require('datasaur-local')] - Data model will be instantiated from this constructor unless `options.dataModel` was given.
     * @returns {boolean} `true` if the data model has changed.
     * @memberOf Local#
     */
    getNewDataModel: function getNewDataModel(options) {
        var newDataModel;

        options = options || {};

        if (options.dataModel) {
            newDataModel = options.dataModel;
        } else if (options.DataModel) {
            newDataModel = new options.DataModel();
        } else {
            newDataModel = new DefaultDataModel();
        }

        return newDataModel;
    },

    /**
     * @summary Attach a data model object to the grid.
     * @desc Installs data model events, fallbacks, and hooks.
     *
     * Called from {@link Behavior#reset}.
     * @this {Behavior}
     * @param {object} [options]
     * @param {dataModelAPI} [options.dataModel] - A fully instantiated data model object.
     * @param {function} [options.DataModel=require('datasaur-local')] - Data model will be instantiated from this constructor unless `options.dataModel` was given.
     * @param {dataModelAPI} [options.metadata] - Passed to {@link dataModelAPI#setMetadataStore setMetadataStore}.
     * @returns {boolean} `true` if the data model has changed.
     * @memberOf Local#
     */
    resetDataModel: function resetDataModel(options) {
        var newDataModel = this.getNewDataModel(options),
            changed = newDataModel && newDataModel !== this.dataModel;

        if (changed) {
            this.dataModel = this.decorateDataModel(newDataModel, options);
            decorators.addDeprecationWarnings.call(this);
            decorators.addFriendlierDrillDownMapKeys.call(this);
        }

        return changed;
    },

    /**
     * @param {dataModelAPI} newDataModel
     * @param {dataModelAPI} [options.metadata] - Passed to {@link dataModelAPI#setMetadataStore setMetadataStore}.
     */
    decorateDataModel: function decorateDataModel(newDataModel, options) {
        decorators.addPolyfills(newDataModel);
        decorators.addFallbacks(newDataModel, this.grid);
        decorators.addDefaultHooks(newDataModel);

        newDataModel.setMetadataStore(options && options.metadata);

        return newDataModel;
    },

    /**
     * @summary Convenience getter/setter.
     * @desc Calls the data model's `getSchema`/`setSchema` methods.
     * @see {@link https://fin-hypergrid.github.io/doc/dataModelAPI.html#getSchema|getSchema}
     * @see {@link https://fin-hypergrid.github.io/doc/dataModelAPI.html#setSchema|setSchema}
     * @type {Array}
     * @memberOf Local#
     */
    get schema() {
        return this.dataModel && this.dataModel.getSchema();
    },
    set schema(newSchema) {
        this.dataModel.setSchema(newSchema);
    },

    /**
     * @summary Map of drill down characters used by the data model.
     * @see {@link https://fin-hypergrid.github.io/doc/dataModelAPI.html#charMap|charMap}
     * @type {{OPEN:string, CLOSE:string, INDENT:string}}
     * @memberOf Local#
     */
    get charMap() {
        return this.dataModel.drillDownCharMap;
    },

    /**
     * @summary Calls `apply()` on the data model.
     * @see {@link https://fin-hypergrid.github.io/doc/dataModelAPI.html#reindex|reindex}
     * @memberOf Local#
     */
    reindex: function reindex() {
        this.dataModel.apply();
    },

    /**
     * @summary Gets the number of rows in the data subgrid.
     * @see {@link https://fin-hypergrid.github.io/doc/dataModelAPI.html#getRowCount|getRowCount}
     * @memberOf Local#
     */
    getRowCount: function getRowCount() {
        return this.dataModel.getRowCount();
    },

    /**
     * Retrieve a data row from the data model.
     * @see {@link https://fin-hypergrid.github.io/doc/dataModelAPI.html#getRow|getRow}
     * @memberOf Local#
     * @return {dataRowObject} The data row object at y index.
     * @param {number} y - the row index of interest
     */
    getRow: function getRow(y) {
        return this.dataModel.getRow(y);
    },

    /**
     * Retrieve all data rows from the data model.
     * > Use with caution!
     * @see {@link https://fin-hypergrid.github.io/doc/dataModelAPI.html#getData|getData}
     * @return {dataRowObject[]}
     * @memberOf Local#
     */
    getData: function getData() {
        return this.dataModel.getData();
    },

    /**
     * @memberOf Local#
     */
    getIndexedData: function getIndexedData() {
        return this.deprecated('getIndexedData()', 'getData()', '3.0.0');
    },

    /**
     * @summary Calls `click` on the data model if column is a tree column.
     * @desc Sends clicked cell's coordinates to the data model.
     * @see {@link https://fin-hypergrid.github.io/doc/dataModelAPI.html#isDrillDown|isDrillDown}
     * @see {@link https://fin-hypergrid.github.io/doc/dataModelAPI.html#click|click}
     * @param {CellEvent} event
     * @returns {boolean} If click was in a drill down column and click on this row was "consumed" by the data model (_i.e., caused it's state to change).
     * @memberOf Local#
     */
    cellClicked: function cellClicked(event) {
        return this.dataModel.isDrillDown(event.dataCell.x) && this.dataModel.click(event.dataCell.y);
    },

    /**
     * @memberOf Local#
     * @description Get boolean data about tree columns show needed
     */
    hasTreeColumn: function hasTreeColumn(columnIndex) {
        return this.grid.properties.showTreeColumn && this.dataModel.isDrillDown(columnIndex);
    },

    /**
     * @memberOf Local#
     * @desc Get all selections made in current grid session
     */
    getSelections: function getSelections() {
        return this.grid.selectionModel.getSelections();
    },

    /**
     * @summary extend row data with aggregation name from parent row
     * @param row - row structure which will be populated with new agg data
     * @param parentParentAggs - agg data from previous row data
     */
    populateAggregationNamesForRow: function populateAggregationNamesForRow(row, parentParentAggs) {
        if (row.__treeLevel !== undefined && row.$$aggregation !== undefined) {
            var parentAggs = Object.assign({}, row.parentAggs || parentParentAggs || {}); // copy parentAggs
            parentAggs[this.aggNameFromRow(row)] = row.$$aggregation;
            Object.assign(row, parentAggs, { parentAggs: parentAggs });
        }
    },


    aggNameFromRow: function aggNameFromRow(row) {
        return '$$aggregation' + row.__treeLevel;
    },

    copyValues: function copyValues(row) {
        var res = {};
        Object.keys(row).filter(function (k) {
            return !k.startsWith('$$') && !k.startsWith('__');
        }).forEach(function (k) {
            return res[k] = row[k];
        });
        return res;
    },

    /**
     * @desc append child rows right after parent
     * @type {boolean}
     * @memberOf CellEvent#
     */
    expandChildRows: function expandChildRows(row) {
        var _this6 = this;

        if (!this.isRowExpanded(row) && row.$$children) {
            this.populateAggregationNamesForRow(row);
            if (row.$$children.length > 0) {
                var rowIndex = this.dataModel.indexOf(row);

                var childrenToAdd = row.$$children;

                if (this.grid.properties.isPivot) {
                    if (row.$$children.length === 0 || !row.$$children[row.$$children.length - 1][GRAND_TOTAL]) {
                        var _Object$assign;

                        row.$$children.push(Object.assign(this.copyValues(row), (_Object$assign = {}, _defineProperty(_Object$assign, GRAND_TOTAL, true), _defineProperty(_Object$assign, this.aggNameFromRow(row), row[this.aggNameFromRow(row)] + ' Total'), _Object$assign)));
                    }
                    childrenToAdd = row.$$children.slice(1);
                }

                this.dataModel.addRows(childrenToAdd, rowIndex + 1);

                row.$$children.forEach(function (r) {
                    r.$$open = false;
                    _this6.populateAggregationNamesForRow(r, _this6.grid.properties.isPivot ? {} : row.parentAggs);
                });

                // remove column because of flat mode
                if (!this.grid.properties.isPivot) {
                    this.dataModel.data.splice(rowIndex, 1);
                }
                this.flatReady = false;
                this.dataModel.cache = [];
            }
        }
        row.$$open = true;
    },

    /**
     * @desc remove all child rows from data model
     * @type {boolean}
     * @memberOf CellEvent#
     */
    collapseChildRows: function collapseChildRows(row) {
        if (row.$$open && row.$$children && row.$$children.length > 0) {
            var rowIndex = this.dataModel.indexOf(row) + 1; // deleting starts from next row

            // collapse children before deleting parent
            this.collapseChildRows(row.$$children[0]);
            for (var i = rowIndex; i < rowIndex + row.$$children.length - 1; ++i) {
                this.collapseChildRows(this.dataModel.data[i]); // really needed access by index
            }
            this.dataModel.delRow(rowIndex, row.$$children.length - 1);
        }
        row.$$open = false;
    },

    /**
     * @desc set colDefs group state to open and synchronize schema
     * @type {boolean}
     * @memberOf CellEvent#
     */
    expandChildColumns: function expandChildColumns(groupId) {
        this._setColDefGroupShowStateRecursive(this.grid.columnDefs, groupId, 'open');

        this.synchronizeSchemaToColumnDefs();
        this.fitColumnsGroup(groupId);
    },

    /**
     * @desc set colDefs group state to closed and synchronize schema
     * @type {boolean}
     * @memberOf CellEvent#
     */
    collapseChildColumns: function collapseChildColumns(groupId) {
        this._setColDefGroupShowStateRecursive(this.grid.columnDefs, groupId, 'closed');

        this.synchronizeSchemaToColumnDefs();
        this.fitColumnsGroup(groupId);
    },

    /**
     * @desc utility function to recursively found colDefs group by id and set it's open state
     * @param {array} colDefs
     * @param {number} groupId
     * @param {string} newState
     * @type {boolean}
     * @memberOf CellEvent#
     */
    _setColDefGroupShowStateRecursive: function _setColDefGroupShowStateRecursive(colDefs, groupId, newState) {
        var _this7 = this;

        colDefs.forEach(function (cd) {
            if (cd.groupId === groupId) {
                cd.columnGroupShow = newState;
            }

            if (cd.children && cd.children.length > 0) {
                _this7._setColDefGroupShowStateRecursive(cd.children, groupId, newState);
            }
        });
    },

    /**
     * @summary set all rows expanded in one time
     */
    buildFlatMode: function buildFlatMode() {
        var _this8 = this;

        var expandRow = function expandRow(row) {
            _this8.expandChildRows(row);
            if (row.$$children) {
                row.$$children.forEach(function (c) {
                    return expandRow(c);
                });
            }
        };
        do {
            this.flatReady = true;
            this.dataModel.data.forEach(function (row) {
                return expandRow(row);
            });
        } while (!this.flatReady);

        this.dataModel.cache = [];
    },

    /**
     * @summary get additional width based on colspan
     * @param x
     * @param y
     * @returns {number}
     */
    getAdditionalWidth: function getAdditionalWidth(x, y) {
        return this.dataModel.getAdditionalWidth(x, y);
    },

    /**
     * @summary get additional height based on rowspan
     * @param x
     * @param y
     * @returns {number}
     */
    getAdditionalHeight: function getAdditionalHeight(x, y) {
        return this.dataModel.getAdditionalHeight(x, y);
    },

    /**
     * @public
     * @desc get colspan of an cell, if exist. Otherwise, returns 0;
     * @param x
     * @param y
     * @return {*}
     */
    getColspan: function getColspan(x, y) {
        return this.dataModel.getColspan(x, y);
    },

    /**
     * @public
     * @desc get rowspan of an cell, if exist. Otherwise, returns 0;
     * @param x
     * @param y
     * @return {*}
     */
    getRowspan: function getRowspan(x, y) {
        return this.dataModel.getRowspan(x, y);
    },

    errors: {}
});

Object.defineProperties(Local.prototype, require('./columnEnum').descriptors);

module.exports = Local;

},{"../DatasaurLocal":19,"./Behavior":33,"./columnEnum":37,"./dataModel/decorators":39}],36:[function(require,module,exports){
'use strict';

/**
 * Behavior.js mixes this module into its prototype.
 * @mixin
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.behaviorMixin = {
    /**
     * @summary Get the cell's own properties object.
     * @desc May be undefined because cells only have their own properties object when at lest one own property has been set.
     * @param {CellEvent|number} xOrCellEvent - Data x coordinate.
     * @param {number} [y] - Grid row coordinate. _Omit when `xOrCellEvent` is a `CellEvent`._
     * @param {dataModelAPI} [dataModel=this.subgrids.lookup.data] - For use only when `xOrCellEvent` is _not_ a `CellEvent`: Provide a subgrid.
     * @returns {undefined|object} The "own" properties of the cell at x,y in the grid. If the cell does not own a properties object, returns `undefined`.
     * @memberOf Behavior#
     */
    getCellOwnProperties: function getCellOwnProperties(xOrCellEvent, y, dataModel) {
        if (arguments.length === 1) {
            // xOrCellEvent is cellEvent
            return xOrCellEvent.column.getCellOwnProperties(xOrCellEvent.dataCell.y, xOrCellEvent.subgrid);
        } else {
            // xOrCellEvent is x
            return this.getColumn(xOrCellEvent).getCellOwnProperties(y, dataModel);
        }
    },

    /**
     * @summary Get the properties object for cell.
     * @desc This is the cell's own properties object if found else the column object.
     *
     * If you are seeking a single specific property, consider calling {@link Behavior#getCellProperty} instead.
     * @param {CellEvent|number} xOrCellEvent - Data x coordinate.
     * @param {number} [y] - Grid row coordinate. _Omit when `xOrCellEvent` is a `CellEvent`._
     * @param {dataModelAPI} [dataModel=this.subgrids.lookup.data] - For use only when `xOrCellEvent` is _not_ a `CellEvent`: Provide a subgrid.
     * @return {object} The properties of the cell at x,y in the grid.
     * @memberOf Behavior#
     */
    getCellProperties: function getCellProperties(xOrCellEvent, y, dataModel) {
        if (arguments.length === 1) {
            // xOrCellEvent is cellEvent
            return Object.assign({}, xOrCellEvent.properties || {}, xOrCellEvent.rowOwnProperties || {});
        } else {
            // xOrCellEvent is x
            return this.getColumn(xOrCellEvent).getCellProperties(y, dataModel);
        }
    },

    /**
     * @summary Return a specific cell property.
     * @desc If there is no cell properties object, defers to column properties object.
     * @param {CellEvent|number} xOrCellEvent - Data x coordinate.
     * @param {number} [y] - Grid row coordinate._ Omit when `xOrCellEvent` is a `CellEvent`._
     * @param {string} key - Name of property to get. _When `y` omitted, this param promoted to 2nd arg._
     * @param {dataModelAPI} [dataModel=this.subgrids.lookup.data] - For use only when `xOrCellEvent` is _not_ a `CellEvent`: Provide a subgrid.
     * @return {object} The specified property for the cell at x,y in the grid.
     * @memberOf Behavior#
     */
    getCellProperty: function getCellProperty(xOrCellEvent, y, key, dataModel) {
        if ((typeof xOrCellEvent === 'undefined' ? 'undefined' : _typeof(xOrCellEvent)) === 'object') {
            key = y;
            return xOrCellEvent.properties[key];
        } else {
            var column = this.getColumn(xOrCellEvent);
            return column && column.getCellProperty(y, key, dataModel);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc update the data at point x, y with value
     * @param {CellEvent|number} xOrCellEvent - Data x coordinate.
     * @param {number} [y] - Grid row coordinate. _Omit when `xOrCellEvent` is a `CellEvent`._
     * @param {Object} properties - Hash of cell properties. _When `y` omitted, this param promoted to 2nd arg._
     * @param {dataModelAPI} [dataModel=this.subgrids.lookup.data] - For use only when `xOrCellEvent` is _not_ a `CellEvent`: Provide a subgrid.
     */
    setCellProperties: function setCellProperties(xOrCellEvent, y, properties, dataModel) {
        if ((typeof xOrCellEvent === 'undefined' ? 'undefined' : _typeof(xOrCellEvent)) === 'object') {
            properties = y;
            return xOrCellEvent.column.setCellProperties(xOrCellEvent.dataCell.y, properties, xOrCellEvent.subgrid);
        } else {
            return this.getColumn(xOrCellEvent).setCellProperties(y, properties, dataModel);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc update the data at point x, y with value
     * @param {CellEvent|number} xOrCellEvent - Data x coordinate.
     * @param {number} [y] - Grid row coordinate. _Omit when `xOrCellEvent` is a `CellEvent`._
     * @param {Object} properties - Hash of cell properties. _When `y` omitted, this param promoted to 2nd arg._
     * @param {dataModelAPI} [dataModel=this.subgrids.lookup.data] - For use only when `xOrCellEvent` is _not_ a `CellEvent`: Provide a subgrid.
     */
    addCellProperties: function addCellProperties(xOrCellEvent, y, properties, dataModel) {
        if ((typeof xOrCellEvent === 'undefined' ? 'undefined' : _typeof(xOrCellEvent)) === 'object') {
            properties = y;
            return xOrCellEvent.column.addCellProperties(xOrCellEvent.dataCell.y, properties, xOrCellEvent.subgrid); // y omitted so y here is actually properties
        } else {
            return this.getColumn(xOrCellEvent).addCellProperties(y, properties, dataModel);
        }
    },

    /**
     * @summary Set a specific cell property.
     * @desc If there is no cell properties object, defers to column properties object.
     *
     * NOTE: For performance reasons, renderer's cell event objects cache their respective cell properties objects. This method accepts a `CellEvent` overload. Whenever possible, use the `CellEvent` from the renderer's cell event pool. Doing so will reset the cell properties object cache.
     *
     * If you use some other `CellEvent`, the renderer's `CellEvent` properties cache will not be automatically reset until the whole cell event pool is reset on the next call to {@link Renderer#computeCellBoundaries}. If necessary, you can "manually" reset it by calling {@link Renderer#resetCellPropertiesCache|resetCellPropertiesCache(yourCellEvent)} which searches the cell event pool for one with matching coordinates and resets the cache.
     *
     * The raw coordinates overload calls the `resetCellPropertiesCache(x, y)` overload for you.
     * @param {CellEvent|number} xOrCellEvent - `CellEvent` or data x coordinate.
     * @param {number} [y] - Grid row coordinate. _Omit when `xOrCellEvent` is a `CellEvent`._
     * @param {string} key - Name of property to get. _When `y` omitted, this param promoted to 2nd arg._
     * @param value
     * @param {dataModelAPI} [dataModel=this.subgrids.lookup.data] - For use only when `xOrCellEvent` is _not_ a `CellEvent`: Provide a subgrid.
     * @memberOf Behavior#
     */
    setCellProperty: function setCellProperty(xOrCellEvent, y, key, value, dataModel) {
        var cellOwnProperties;
        if ((typeof xOrCellEvent === 'undefined' ? 'undefined' : _typeof(xOrCellEvent)) === 'object') {
            value = key;
            key = y;
            cellOwnProperties = xOrCellEvent.setCellProperty(key, value);
        } else {
            cellOwnProperties = this.getColumn(xOrCellEvent).setCellProperty(y, key, value, dataModel);
            this.grid.renderer.resetCellPropertiesCache(xOrCellEvent, y, dataModel);
        }
        return cellOwnProperties;
    }
};

/**
 * Column.js mixes this module into its prototype.
 * @mixin
 */
exports.columnMixin = {

    /**
     * @summary Get the properties object for cell.
     * @desc This is the cell's own properties object if found; else the column object.
     *
     * If you are seeking a single specific property, consider calling {@link Column#getCellProperty} instead (which calls this method).
     * @param {number} rowIndex - Data row coordinate.
     * @return {object} The properties of the cell at x,y in the grid.
     * @memberOf Column#
     */
    getCellProperties: function getCellProperties(rowIndex, dataModel) {
        return this.getCellOwnProperties(rowIndex, dataModel) || this.properties;
    },

    /**
     * @param {number} rowIndex - Data row coordinate.
     * @param {object} properties - Hash of cell properties.
     * @returns {*}
     * @memberOf Column#
     */
    setCellProperties: function setCellProperties(rowIndex, properties, dataModel) {
        return Object.assign(newCellPropertiesObject.call(this, rowIndex, dataModel), properties);
    },

    /**
     * @param {number} rowIndex - Data row coordinate.
     * @param {object} properties - Hash of cell properties.
     * @returns {object} Cell's own properties object, which will be created by this call if it did not already exist.
     * @memberOf Column#
     */
    addCellProperties: function addCellProperties(rowIndex, properties, dataModel) {
        return Object.assign(getCellPropertiesObject.call(this, rowIndex, dataModel), properties);
    },

    /**
     * @summary Get the cell's own properties object.
     * @desc Due to memory constraints, we don't create a cell properties object for every cell.
     *
     * If the cell has its own properties object, it:
     * * was created by a previous call to `setCellProperties` or `setCellProperty`
     * * has the column properties object as its prototype
     * * is returned
     *
     * If the cell does not have its own properties object, this method returns `null`.
     *
     * Call this method only when you need to know if the the cell has its own properties object; otherwise call {@link Column#getCellProperties|getCellProperties}.
     * @param {number} rowIndex - Data row coordinate.
     * @returns {null|object} The "own" properties of the cell at x,y in the grid. If the cell does not own a properties object, returns `null`.
     * @memberOf Column#
     */
    getCellOwnProperties: function getCellOwnProperties(rowIndex, dataModel) {
        var metadata;
        return (
            // this.index >= 0 && // no cell props on row handle cells
            (metadata = (dataModel || this.dataModel).getRowMetadata(rowIndex)) && // no cell props on non-existent rows
            metadata && metadata[this.name] || null // null means not previously created

        );
    },

    deleteCellOwnProperties: function deleteCellOwnProperties(rowIndex, dataModel) {
        dataModel = dataModel || this.dataModel;
        var metadata = dataModel.getRowMetadata(rowIndex);
        if (metadata) {
            delete metadata[this.name];
            if (Object.keys(metadata).length === 0) {
                dataModel.setRowMetadata(rowIndex);
            }
        }
    },

    /**
     * @summary Return a specific cell property.
     * @desc If there is no cell properties object, defers to column properties object.
     * @param {number} rowIndex - Data row coordinate.
     * @param {string} key
     * @return {object} The specified property for the cell at x,y in the grid.
     * @memberOf Column#
     */
    getCellProperty: function getCellProperty(rowIndex, key, dataModel) {
        return this.getCellProperties(rowIndex, dataModel)[key];
    },

    /**
     * @param {number} rowIndex - Data row coordinate.
     * @param {string} key
     * @param value
     * @returns {object} Cell's own properties object, which will be created by this call if it did not already exist.
     * @memberOf Column#
     */
    setCellProperty: function setCellProperty(rowIndex, key, value, dataModel) {
        var cellProps = getCellPropertiesObject.call(this, rowIndex, dataModel);
        cellProps[key] = value;
        return cellProps;
    },

    deleteCellProperty: function deleteCellProperty(rowIndex, key, dataModel) {
        var cellProps = this.getCellOwnProperties(rowIndex, dataModel);
        if (cellProps) {
            delete cellProps[key];
        }
    },

    /**
     * Clear all cell properties from all cells in this column.
     * @memberOf Column#
     */
    clearAllCellProperties: function clearAllCellProperties() {
        this.behavior.subgrids.forEach(function (dataModel) {
            for (var y = dataModel.getRowCount(); y--;) {
                this.deleteCellOwnProperties(y, dataModel);
            }
        }, this);
    }
};

/**
 * @todo: Theoretically setData should call this method to ensure each cell's persisted properties object is properly recreated with prototype set to its column's properties object.
 * @this {Column}
 * @param {number} rowIndex - Data row coordinate.
 * @returns {object}
 * @private
 */
function getCellPropertiesObject(rowIndex, dataModel) {
    return this.getCellOwnProperties(rowIndex, dataModel) || newCellPropertiesObject.call(this, rowIndex, dataModel);
}

/**
 * @this {Column}
 * @param {number} rowIndex - Data row coordinate.
 * @returns {object}
 * @private
 */
function newCellPropertiesObject(rowIndex, dataModel) {
    var metadata = (dataModel || this.dataModel).getRowMetadata(rowIndex, null),
        props = this.properties;

    switch (this._index) {
        case this.behavior.treeColumnIndex:
            props = props.treeHeader;
            break;
        case this.behavior.rowColumnIndex:
            props = props.rowHeader;
            break;
    }

    return metadata[this.name] = Object.create(props);
}

},{}],37:[function(require,module,exports){
'use strict';

var warned = {};

var columnEnum = {};

var columnEnumDeprecationDescriptor = {
    get: function get() {
        warnColumnEnumDeprecation();
        return columnEnum;
    },
    set: function set(x) {
        warnColumnEnumDeprecation();
    }
};

function warnColumnEnumDeprecation() {
    if (!warned.columnEnumDecorators) {
        console.warn('.columnEnumDecorators and .columnEnumKey have both been deprecated as of v3.0.0 and no longer have any meaning. (Will be removed in a future release.) Note that .columnEnum is also deprecated in favor of .schema, which now serves as a column enum. (See https://fin-hypergrid.github.io/doc/dataModel.api#initSchema.)');
        warned.columnEnumDecorators = true;
    }
}

exports.descriptors = {
    columnEnum: {
        get: function get() {
            if (!warned.columnEnum) {
                console.warn('.columnEnum has been deprecated as of v3.0.0 in favor of .schema (largely compatible with the deprecated property; see https://fin-hypergrid.github.io/doc/dataModel.api#initSchema). (Will be removed in a future release.)');
                warned.columnEnum = true;
            }
            return this.schema;
        }
    },
    columnEnumKey: columnEnumDeprecationDescriptor,
    columnEnumDecorators: columnEnumDeprecationDescriptor
};

},{}],38:[function(require,module,exports){
'use strict';

/**
 * @this {Column}
 * @returns {object}
 * @memberOf Column#
 */

function createColumnProperties() {
    var column = this,
        gridProps = column.behavior.grid.properties,
        properties;

    properties = Object.create(gridProps, {

        index: { // read-only (no setter)
            get: function get() {
                return column.index;
            }
        },

        name: { // read-only (no setter)
            get: function get() {
                return column.name;
            }
        },

        field: { // read-only (no setter)
            get: function get() {
                return column.name;
            }
        },

        columnName: { // read-only (no setter)
            get: function get() {
                return column.name;
            }
        },

        header: {
            get: function get() {
                return column.header;
            },
            set: function set(header) {
                if (this !== column.properties) {
                    // trying to set a cell header
                    gridProps.header = header; // throw same error as when trying to set a grid header
                }
                column.header = header;
            }
        },

        type: {
            get: function get() {
                return column.type;
            },
            set: function set(type) {
                if (this !== column.properties) {
                    // trying to set a cell type
                    gridProps.type = type; // throw same error as when trying to set a grid type
                }
                column.type = type;
            }
        },

        calculator: {
            get: function get() {
                return column.calculator;
            },
            set: function set(calculator) {
                if (this !== column.properties) {
                    // trying to set a cell calculator
                    gridProps.calculator = calculator; // throw same error as when trying to set a grid calculator
                }
                column.calculator = calculator;
            }
        },

        format: {
            get: function get() {
                return 'format' in column.schema ? column.schema.format : gridProps.format;
            },
            set: function set(format) {
                if (this !== column.properties) {
                    // set on instance to override this accessor (could be cell props obj or anon obj created by renderer)
                    Object.defineProperty(this, 'format', {
                        enumerable: true,
                        configurable: true,
                        writable: true,
                        value: format
                    });
                } else if (format === undefined) {
                    delete column.schema.format; // remove column prop to so getter returns grid prop
                } else {
                    column.schema.format = format;
                }
            }
        },

        renderer: {
            get: function get() {
                return 'renderer' in column.schema ? column.schema.renderer : gridProps.renderer;
            },
            set: function set(renderer) {
                if (this !== column.properties) {
                    // set on instance to override this accessor (could be cell props obj or anon obj created by renderer)
                    Object.defineProperty(this, 'renderer', {
                        enumerable: true,
                        configurable: true,
                        writable: true,
                        value: renderer
                    });
                } else if (renderer === undefined) {
                    delete column.schema.renderer; // remove column prop to so getter returns grid prop
                } else {
                    column.schema.renderer = renderer;
                }
            }
        },

        toJSON: {
            // although we don't generally want these to be enumerable, we do want them to be serializable
            // todo: ??? not sure now (3/13/2018) why these shouldn't be enumerable
            value: function value() {
                return Object.assign({
                    header: this.header,
                    type: this.type,
                    calculator: this.calculator,
                    format: this.format,
                    renderer: this.renderer
                }, this);
            }
        }

    });

    Object.defineProperties(properties, {
        rowHeader: { value: Object.create(properties, createColumnProperties.rowHeaderDescriptors) },
        treeHeader: { value: Object.create(properties, createColumnProperties.treeHeaderDescriptors) },
        columnHeader: { value: Object.create(properties, createColumnProperties.columnHeaderDescriptors) },
        filterProperties: { value: Object.create(properties, createColumnProperties.filterDescriptors) }
    });

    return properties;
}

createColumnProperties.treeHeaderDescriptors = {
    font: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.treeHeaderFont;
        },
        set: function set(value) {
            this.treeHeaderFont = value;
        }
    },
    color: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.treeHeaderColor;
        },
        set: function set(value) {
            this.treeHeaderColor = value;
        }
    },
    backgroundColor: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.treeHeaderBackgroundColor;
        },
        set: function set(value) {
            this.treeHeaderBackgroundColor = value;
        }
    },
    foregroundSelectionFont: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.treeHeaderForegroundSelectionFont;
        },
        set: function set(value) {
            this.treeHeaderForegroundSelectionFont = value;
        }
    },
    foregroundSelectionColor: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.treeHeaderForegroundSelectionColor;
        },
        set: function set(value) {
            this.treeHeaderForegroundSelectionColor = value;
        }
    },
    renderer: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.treeRenderer;
        },
        set: function set(value) {
            this.treeRenderer = value;
        }
    },
    backgroundSelectionColor: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.treeHeaderBackgroundSelectionColor;
        },
        set: function set(value) {
            this.treeHeaderBackgroundSelectionColor = value;
        }
        //leftIcon: undefined
    } };

createColumnProperties.rowHeaderDescriptors = {
    font: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.rowHeaderFont;
        },
        set: function set(value) {
            this.rowHeaderFont = value;
        }
    },
    color: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.rowHeaderColor;
        },
        set: function set(value) {
            this.rowHeaderColor = value;
        }
    },
    backgroundColor: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.rowHeaderBackgroundColor;
        },
        set: function set(value) {
            this.rowHeaderBackgroundColor = value;
        }
    },
    foregroundSelectionFont: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.rowHeaderForegroundSelectionFont;
        },
        set: function set(value) {
            this.rowHeaderForegroundSelectionFont = value;
        }
    },
    foregroundSelectionColor: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.rowHeaderForegroundSelectionColor;
        },
        set: function set(value) {
            this.rowHeaderForegroundSelectionColor = value;
        }
    },
    backgroundSelectionColor: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.rowHeaderBackgroundSelectionColor;
        },
        set: function set(value) {
            this.rowHeaderBackgroundSelectionColor = value;
        }
    },
    leftIcon: {
        configurable: true,
        enumerable: true,
        get: function get() {
            if (this.grid.properties.rowHeaderCheckboxes) {
                var result;
                if (this.isDataRow) {
                    result = this.isRowSelected ? 'checked' : 'unchecked';
                } else if (this.isHeaderRow) {
                    result = this.allRowsSelected ? 'checked' : 'unchecked';
                } else if (this.isFilterRow) {
                    result = 'filter-off';
                }
                return result;
            }
        },
        set: function set(value) {
            // replace self with a simple instance var
            Object.defineProperty(this, 'leftIcon', {
                configurable: true,
                enumerable: true,
                writable: true,
                value: value
            });
        }
    }
};

createColumnProperties.filterDescriptors = {
    font: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.filterFont;
        },
        set: function set(value) {
            this.filterFont = value;
        }
    },
    color: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.filterColor;
        },
        set: function set(value) {
            this.filterColor = value;
        }
    },
    backgroundColor: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.filterBackgroundColor;
        },
        set: function set(value) {
            this.filterBackgroundColor = value;
        }
    },
    foregroundSelectionColor: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.filterForegroundSelectionColor;
        },
        set: function set(value) {
            this.filterForegroundSelectionColor = value;
        }
    },
    backgroundSelectionColor: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.filterBackgroundSelectionColor;
        },
        set: function set(value) {
            this.filterBackgroundSelectionColor = value;
        }
    },
    halign: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.filterHalign;
        },
        set: function set(value) {
            this.filterHalign = value;
        }
    },
    renderer: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.filterRenderer;
        },
        set: function set(value) {
            this.filterRenderer = value;
        }
    },
    editor: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.filterEditor;
        },
        set: function set(value) {
            this.filterEditor = value;
        }
    },
    rightIcon: {
        configurable: true,
        enumerable: true,
        get: function get() {
            var result;
            if (this.filterable) {
                result = this.filter ? 'filter-on' : 'filter-off';
            }
            return result;
        },
        set: function set(value) {
            // replace self with a simple instance var
            Object.defineProperty(this, 'rightIcon', {
                configurable: true,
                enumerable: true,
                writable: true,
                value: value
            });
        }
    }
};

createColumnProperties.columnHeaderDescriptors = {
    font: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.columnHeaderFont;
        },
        set: function set(value) {
            this.columnHeaderFont = value;
        }
    },
    color: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.columnHeaderColor;
        },
        set: function set(value) {
            this.columnHeaderColor = value;
        }
    },
    backgroundColor: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.columnHeaderBackgroundColor;
        },
        set: function set(value) {
            this.columnHeaderBackgroundColor = value;
        }
    },
    foregroundSelectionFont: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.columnHeaderForegroundSelectionFont;
        },
        set: function set(value) {
            this.columnHeaderForegroundSelectionFont = value;
        }
    },
    foregroundSelectionColor: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.columnHeaderForegroundSelectionColor;
        },
        set: function set(value) {
            this.columnHeaderForegroundSelectionColor = value;
        }
    },
    backgroundSelectionColor: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.columnHeaderBackgroundSelectionColor;
        },
        set: function set(value) {
            this.columnHeaderBackgroundSelectionColor = value;
        }
    },
    halign: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.columnHeaderHalign;
        },
        set: function set(value) {
            this.columnHeaderHalign = value;
        }
    },
    renderer: {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.columnHeaderRenderer;
        },
        set: function set(value) {
            this.columnHeaderRenderer = value;
        }
    },
    leftIcon: { writable: true, value: undefined },
    centerIcon: { writable: true, value: undefined },
    rightIcon: { writable: true, value: undefined }
};

/**
 * Column.js mixes this module into its prototype.
 * @mixin
 */
exports.mixin = {
    createColumnProperties: createColumnProperties
};

},{}],39:[function(require,module,exports){
/* globals CustomEvent */

'use strict';

var hooks = require('.');
var fallbacks = require('./fallbacks');
var HypergridError = require('../../lib/error');

var warned = {};

/**
 * @private
 * @this {Local}
 * @param {dataModelAPI} dataModel
 */
function addPolyfills(dataModel) {
    if (!dataModel.install) {
        dataModel.install = function (api, fallback) {
            if (fallback && !Array.isArray(api)) {
                api = api || this;
                Object.keys(api).filter(function (key) {
                    return typeof api[key] === 'function';
                }).forEach(function (key) {
                    if (!this[key]) {
                        this[key] = api[key];
                    }
                }, this);
            }
        };
    }
}

/**
 * Inject fallback methods into data model when not implemented by data model.
 * Also adds `dispatchEvent`, called by data model to communicate back to Hypergrid.
 * (Hypergrid itself never calls `dispatchEvent` on the data model.)
 * @this {Local}
 * @param {dataModelAPI} dataModel
 * @param {Hypergrid} grid
 * @private
 */
function addFallbacks(dataModel, grid) {
    dataModel.install(fallbacks, true);
    dataModel.install({ dispatchEvent: dispatchEvent.bind(grid) }, true);
}

var REGEX_DATA_EVENT_STRING = /^data(-[a-z]+)+$/;

/**
 * @private
 * @this {Hypergrid}
 * @param eventName
 * @param eventDetail
 */
function dispatchEvent(eventName, eventDetail) {
    if (!REGEX_DATA_EVENT_STRING.test(eventName)) {
        throw new HypergridError('Expected data event string to match ' + REGEX_DATA_EVENT_STRING + '.');
    }
    this.canvas.dispatchEvent(new CustomEvent('fin-canvas-' + eventName, eventDetail));
}

/**
 * @private
 * @this {Local}
 */
function addDeprecationWarnings() {
    var grid = this.grid;

    Object.defineProperty(this.dataModel, 'grid', {
        configurable: true,
        enumerable: false,
        get: function get() {
            if (!warned.grid) {
                console.warn('`this.grid` (dataModel.grid) property has been deprecated as of v3.0.0 and will definitely be removed in a future release. Data models should have no direct knowledge of or access to the grid. (If your data model needs to call grid methods, add a data event to your grid with grid.addDataEventListener(\'data-my-event\', myHandler) and trigger it from your data model with this.dispatchEvent(\'data-my-event\'). If you need access to the grid object from within a `getCell` or `getCellEditAt` override, define `grid` and the override in a closure.)');
                warned.grid = true;
            }
            return grid;
        }
    });

    if (this.dataModel.dataSource) {
        if (!warned.dataSource) {
            console.warn('As of Hypergrid 3.0.0, the external data model is now `grid.behavior.dataModel`. Formerly, it was `grid.behavior.dataModel.dataSource`. Data model authors are strongly advised to avoid implementing a `.dataSource` property inside their data model to reduce the confusion that would result if a legacy application were to try to reference the data model via `.dataModel.dataSource` and get something unexpected instead of an error.)');
        }
    }
}

// for app layer access to drill down chars, provide friendlier keys than data model normally supports in `drillDownCharMap`.
var friendlierDrillDownMapKeys = {
    true: 'OPEN',
    false: 'CLOSE',
    null: 'INDENT'
};

/**
 * @private
 * @this {Local}
 */
function addFriendlierDrillDownMapKeys() {
    var charMap = this.dataModel.drillDownCharMap;
    if (charMap) {
        Object.keys(friendlierDrillDownMapKeys).forEach(function (key) {
            if (key in charMap) {
                var friendlierKey = friendlierDrillDownMapKeys[key];
                if (!(friendlierKey in charMap)) {
                    Object.defineProperty(charMap, friendlierKey, {
                        get: function get() {
                            return this[key];
                        },
                        set: function set(s) {
                            this[key] = s;
                        }
                    });
                }
            }
        });
    }
}

/**
 * @private
 * @param {dataModelAPI} dataModel
 * @this {Local}
 */
function addDefaultHooks(dataModel) {
    if (!dataModel.getCell) {
        dataModel.getCell = hooks.getCell;
    }

    if (!dataModel.getCellEditorAt) {
        dataModel.getCellEditorAt = hooks.getCellEditorAt;
    }
}

module.exports = {
    addPolyfills: addPolyfills,
    addFallbacks: addFallbacks,
    addDeprecationWarnings: addDeprecationWarnings,
    addFriendlierDrillDownMapKeys: addFriendlierDrillDownMapKeys,
    addDefaultHooks: addDefaultHooks
};

},{".":41,"../../lib/error":95,"./fallbacks":40}],40:[function(require,module,exports){
'use strict';

/**
 * @module fallbacks
 *
 * @desc {@link Behavior#resetDataModel resetDataModel()} inserts each of these catcher methods into the new data model when not otherwise implemented, which allows Hypergrid to indiscriminately call these otherwise missing methods on the data model without fear of the call failing.
 */

module.exports = {
    /** @implements dataModelAPI#apply */
    apply: function apply() {},

    /** @implements dataModelAPI#isDrillDown */
    isDrillDown: function isDrillDown() {
        return false;
    },

    /** @implements dataModelAPI#click */
    click: function click() {
        return false;
    },

    /** @implements dataModelAPI#getColumnCount */
    getColumnCount: function getColumnCount() {
        return this.getSchema().length;
    },

    /** @implements dataModelAPI#getRow */
    getRow: function getRow(y) {
        this.dataRowProxy.$y$ = y;
        return this.dataRowProxy;
    },

    /** @implements dataModelAPI#getData */
    getData: function getData(metadataFieldName) {
        var y,
            Y = this.getRowCount(),
            row,
            rows = new Array(Y),
            metadata;

        for (y = 0; y < Y; y++) {
            row = this.data[y]; // do not use getRow because of tree levels
            if (row) {
                rows[y] = Object.assign({}, row);
                if (metadataFieldName) {
                    metadata = this.getRowMetadata(y);
                    if (metadata) {
                        rows[y][metadataFieldName] = metadata;
                    }
                }
            }
        }

        return rows;
    },

    setData: function setData(data) {
        // fail silently because Local.js::setData currently calls this for every subgrid
    },

    setValue: function setValue(x, y, value) {
        console.warn('dataModel.setValue(' + x + ', ' + y + ', "' + value + '") called but no implementation. Data not saved.');
    },

    /** @implements dataModelAPI#getRowIndex */
    getRowIndex: function getRowIndex(y) {
        return y;
    },

    /** @implements dataModelAPI#getRowMetadata */
    getRowMetadata: function getRowMetadata(y, prototype) {
        return this.metadata[y] || prototype !== undefined && (this.metadata[y] = Object.create(prototype));
    },

    /** @implements dataModelAPI#getMetadataStore */
    getMetadataStore: function getMetadataStore() {
        return this.metadata;
    },

    /** @implements dataModelAPI#setRowMetadata */
    setRowMetadata: function setRowMetadata(y, metadata) {
        if (metadata) {
            this.metadata[y] = metadata;
        } else {
            delete this.metadata[y];
        }
        return metadata;
    },

    /** @implements dataModelAPI#setMetadataStore */
    setMetadataStore: function setMetadataStore(newMetadataStore) {
        this.metadata = newMetadataStore || [];
    }
};

},{}],41:[function(require,module,exports){
'use strict';

/**
 * Custom implementations should return with a call to the default implementation:
 * ```js
 * var getCell = require('fin-hypergrid/src/behaviors/dataModel').getCell;
 * function myCustomGetCell(config, rendererName) {
 *     // custom logic here that mutates config and/or renderName
 *     return getCell(config, rendererName);
 * }
 * ```
 * Alternatively, copy in the default implementation body (a one-liner):
 * ```js
 * function myCustomGetCell(config, rendererName) {
 *     // custom logic here that mutates config and/or renderName
 *     return config.grid.cellRenderers.get(rendererName);
 * }
 * ```
 * @implements {dataModelAPI#getCell}
 * @memberOf module:dataModel
 */

exports.getCell = function (config, rendererName) {
  return config.grid.cellRenderers.get(rendererName);
};

/**
 * Custom implementations should return with a call to the default implementation:
 * ```js
 * var getCellEditorAt = require('fin-hypergrid/src/behaviors/dataModel').getCellEditorAt;
 * function myCustomGetCellEditorAt(columnIndex, rowIndex, editorName, cellEvent) {
 *     // custom logic here, may mutate config and/or renderName
 *     return getCellEditorAt(columnIndex, rowIndex, editorName, cellEvent);
 * }
 * ```
 * Alternatively, copy in the default implementation body (a one-liner):
 * ```js
 * function myCustomGetCellEditorAt(columnIndex, rowIndex, editorName, cellEvent) {
 *     // custom logic here, may mutate editorName
 *     return cellEvent.grid.cellEditors.create(editorName, cellEvent);
 * }
 * ```
 * @implements {dataModelAPI#getCellEditorAt}
 * @memberOf module:dataModel
 */
exports.getCellEditorAt = function (columnIndex, rowIndex, editorName, cellEvent) {
  return cellEvent.grid.cellEditors.create(editorName, cellEvent);
};

},{}],42:[function(require,module,exports){
'use strict';

// This module is provided solely in support of build file usage, e.g., `fin.Hypergrid.require('fin-hypergrid/src/behaviors/whatever')`,
// and is not meant to be used elsewhere.

var warned;

module.exports = {
    Behavior: require('./Behavior'),
    Local: require('./Local'),
    Column: require('./Column'),
    dataModel: require('./dataModel'),

    get JSON() {
        if (!warned) {
            console.warn('./src/behaviors/JSON has been renamed to Local as of v3.0.0. (Will be removed in a future release.)');
        }
        warned = true;
        return require('./Local');
    }
};

},{"./Behavior":33,"./Column":34,"./Local":35,"./dataModel":41}],43:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.mixin = {
    /**
     * @summary The total height of the "fixed rows."
     * @desc The total height of all (non-scrollable) rows preceding the (scrollable) data subgrid.
     * @memberOf Behavior#
     * @return {number} The height in pixels of the fixed rows area of the hypergrid, the total height of:
     * 1. All rows of all subgrids preceding the data subgrid.
     * 2. The first `fixedRowCount` rows of the data subgrid.
     */
    getFixedRowsHeight: function getFixedRowsHeight() {
        var subgrid,
            isData,
            r,
            R,
            subgrids = this.subgrids,
            height = 0;

        for (var i = 0; i < subgrids.length && !isData; ++i) {
            subgrid = subgrids[i];
            isData = subgrid.isData;
            R = isData ? this.grid.properties.fixedRowCount : subgrid.getRowCount();
            for (r = 0; r < R; ++r) {
                height += this.getRowHeight(r, subgrid);
            }
        }

        return height;
    },

    /**
     * @summary The total height of the "data rows."
     * @desc The total height of all rows preceding the (scrollable) data subgrid.
     * @memberOf Behavior#
     * @return {number} The height in pixels of the data rows area of the hypergrid, the total height of:
     * 1. All rows of all subgrids preceding the data subgrid.
     * 2. The visible data rows of the data subgrid.
     */
    getRowsHeight: function getRowsHeight(toY) {
        var _this = this;

        var height = 0;

        this.subgrids.forEach(function (subgrid) {
            var maxRowCount = subgrid.getRowCount();
            var R = toY === undefined || toY > maxRowCount ? maxRowCount : toY;
            for (var r = 0; r < R; ++r) {
                height += _this.getRowHeight(r, subgrid);
            }
        });

        return height;
    },

    /**
     * @memberOf Behavior#
     * @param {number|CellEvent} yOrCellEvent - Data row index local to `dataModel`; or a `CellEvent` object.
     * @param {boolean} [prototype] - Prototype for a new properties object when one does not already exist. If you don't define this and one does not already exist, this call will return `undefined`.
     * Typical defined value is `null`, which creates a plain object with no prototype, or `Object.prototype` for a more "natural" object.
     * _(Required when 3rd param provided.)_
     * @param {dataModelAPI} [dataModel=this.dataModel] - This is the subgrid. You only need to provide the subgrid when it is not the data subgrid _and_ you did not give a `CellEvent` object in the first param (which already knows what subgrid it's in).
     * @returns {object|undefined} The row properties object which will be one of:
     * * object - existing row properties object or new row properties object created from `prototype`; else
     * * `false` - row found but no existing row properties object and `prototype` was not defined; else
     * * `undefined` - no such row
     */
    getRowProperties: function getRowProperties(yOrCellEvent, prototype, dataModel) {
        if ((typeof yOrCellEvent === 'undefined' ? 'undefined' : _typeof(yOrCellEvent)) === 'object') {
            dataModel = yOrCellEvent.subgrid;
            yOrCellEvent = yOrCellEvent.dataCell.y;
        }

        var metadata = (dataModel || this.dataModel).getRowMetadata(yOrCellEvent, prototype && null);
        return metadata && (metadata.__ROW || prototype !== undefined && (metadata.__ROW = Object.create(prototype)));
    },

    /**
     * Reset the row properties in its entirety to the given row properties object.
     * @memberOf Behavior#
     * @param {number|CellEvent} yOrCellEvent - Data row index local to `dataModel`; or a `CellEvent` object.
     * @param {object} properties - The new row properties object.
     * @param {dataModelAPI} [dataModel=this.dataModel] - This is the subgrid. You only need to provide the subgrid when it is not the data subgrid _and_ you did not give a `CellEvent` object in the first param (which already knows what subgrid it's in).
     */
    setRowProperties: function setRowProperties(yOrCellEvent, properties, dataModel) {
        if ((typeof yOrCellEvent === 'undefined' ? 'undefined' : _typeof(yOrCellEvent)) === 'object') {
            dataModel = yOrCellEvent.subgrid;
            yOrCellEvent = yOrCellEvent.dataCell.y;
        }

        (dataModel || this.dataModel).getRowMetadata(yOrCellEvent, null).__ROW = properties;

        this.stateChanged();
    },

    /**
     * Sets a single row property on a specific individual row.
     * @memberOf Behavior#
     * @param {number|CellEvent} yOrCellEvent - Data row index local to `dataModel`; or a `CellEvent` object.
     * @param {string} key - The property name.
     * @param value - The new property value.
     * @param {dataModelAPI} [dataModel=this.dataModel] - This is the subgrid. You only need to provide the subgrid when it is not the data subgrid _and_ you did not give a `CellEvent` object in the first param (which already knows what subgrid it's in).
     */
    setRowProperty: function setRowProperty(yOrCellEvent, key, value, dataModel) {
        this.getRowProperties(yOrCellEvent, null, dataModel)[key] = value;
        this.stateChanged();
    },

    /**
     * Add all the properties in the given row properties object to the row properties.
     * @memberOf Behavior#
     * @param {number|CellEvent} yOrCellEvent - Data row index local to `dataModel`; or a `CellEvent` object.
     * @param {object} properties - An object containing new property values(s) to assign to the row properties.
     * @param {dataModelAPI} [dataModel=this.dataModel] - This is the subgrid. You only need to provide the subgrid when it is not the data subgrid _and_ you did not give a `CellEvent` object in the first param (which already knows what subgrid it's in).
     */
    addRowProperties: function addRowProperties(yOrCellEvent, properties, dataModel) {
        Object.assign(this.getRowProperties(yOrCellEvent, null, dataModel), properties);
        this.stateChanged();
    },

    /**
     * @memberOf Behavior#
     * @param {number} yOrCellEvent - Data row index local to `dataModel`.
     * @param {dataModelAPI} [dataModel=this.dataModel]
     * @returns {number} The row height in pixels.
     */
    getRowHeight: function getRowHeight(yOrCellEvent, dataModel) {
        var rowProps = this.getRowProperties(yOrCellEvent, undefined, dataModel);
        return rowProps && rowProps.height || this.grid.properties[dataModel && dataModel.isHeader ? 'defaultHeaderRowHeight' : 'defaultRowHeight'];
    },

    /**
     * @memberOf Behavior#
     * @returns {number} count of rows, that used as fictive headers.
     */
    getFictiveHeaderRowsCount: function getFictiveHeaderRowsCount() {
        return this.grid.properties.fictiveHeaderRowsCount;
    },

    /**
     * @memberOf Behavior#
     * @desc set the pixel height of a specific row
     * @param {number} yOrCellEvent - Data row index local to dataModel.
     * @param {number} height - pixel height
     * @param {dataModelAPI} [dataModel=this.dataModel]
     */
    setRowHeight: function setRowHeight(yOrCellEvent, height, dataModel) {
        var rowProps = this.getRowProperties(yOrCellEvent, null, dataModel),
            oldHeight = rowProps.height;

        rowProps.height = Math.max(5, Math.ceil(height));

        if (rowProps.height !== oldHeight) {
            this.stateChanged();
        }
    }
};

},{}],44:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var dataModels = require('../dataModels/index');

/** @typedef subgridConstructorRef
 * @summary Type definition.
 * @desc One of:
 * * **`function` type** - Assumed to already be a data model constructor.
 * * **`string` type** - The name of a data model "class" (constructor) registered in the {@link src/dataModels} namespace. Used to look up the constructor in the namespace.
 */

/** @typedef subgridSpec
 * @summary Type definition.
 * @desc One of:
 * * **`object` type** _(except when an array)_ - Assumed to be a reference to an already-instantiated data model. Used as is.
 * * **`'data'` special value** - Set to the data subgrid (_i.e.,_ the behavior's already-instantiated data model).
 * * **{@link subgridConstructorRef}** _(see)_ - The constructor ref is resolved and called with the `new` keyword + a reference to the grid as the sole parameter.
 * * **`Array` object**  Accommodates data model constructor arguments. The constructor ref is resolved and called with the `new` keyword + a reference to the grid as the first parameter + the remaining elements as additional parameters. (If you don't have remaining elements, don't give an array here; just provide a simple `subgridConstructorRef` instead.) The array should have two or more elements:
 *   * The first element is a {@link subgridConstructorRef}.
 *   * Remaining elements are used as additional parameters to the constructor.
 */

/**
 * Behavior.js mixes this module into its prototype.
 * @mixin
 */
exports.mixin = {
    /**
     * An array where each element represents a subgrid to be rendered in the hypergrid.
     *
     * The list should always include at least one "data" subgrid, typically {@link Behavior#dataModel|dataModel}.
     * It may also include zero or more other types of subgrids such as header, filter, and summary subgrids.
     *
     * This object also sports a dictionary of subgrids in `lookup` property where each dictionary key is one of:
     * * **`subgrid.name`** (for those that have a defined name, which is presumed to be unique)
     * * **`subgrid.type`** (not unique, so if you plan on having multiple, name them!)
     * * **`'data'`** for the (one and only) data subgrid when unnamed (note that data subgrids have no `type`)
     *
     * The setter:
     * * "Enlivens" any constructors (see {@link Behavior~createSubgrid|createSubgrid} for details).
     * * Reconstructs the dictionary.
     * * Calls {@link Behavior#shapeChanged|shapeChanged()}.
     *
     * @param {subgridSpec[]} subgridSpecs
     *
     * @type {dataModelAPI[]}
     *
     * @memberOf Behavior#
     */
    set subgrids(subgridSpecs) {
        var subgrids = this._subgrids = [];

        subgrids.lookup = {};

        subgridSpecs.forEach(function (spec) {
            if (spec) {
                subgrids.push(this.createSubgrid(spec));
            }
        }, this);

        this.shapeChanged();
    },
    get subgrids() {
        return this._subgrids;
    },

    /**
     * @summary Maps a `subgridSpec` to a data model.
     * @desc The spec may describe either an existing data model, or a constructor for a new data model.
     * @param {subgridSpec} spec
     * @returns {dataModelAPI} A data model.
     * @memberOf Behavior#
     */
    createSubgrid: function createSubgrid(spec, args) {
        var subgrid, Constructor, variableArgArray;

        if (spec === 'data') {
            subgrid = this.dataModel;
        } else if (spec instanceof Array && spec.length) {
            Constructor = derefSubgridRef.call(this, spec[0]);
            variableArgArray = spec.slice(1);
            subgrid = this.createApply(Constructor, variableArgArray, undefined, { grid: this.grid });
            subgrid = this.decorateDataModel(subgrid);
        } else if ((typeof spec === 'undefined' ? 'undefined' : _typeof(spec)) === 'object') {
            subgrid = spec;
        } else {
            Constructor = derefSubgridRef.call(this, spec);
            variableArgArray = Array.prototype.slice.call(arguments, 1);
            subgrid = this.createApply(Constructor, variableArgArray, undefined, { grid: this.grid });
            subgrid = this.decorateDataModel(subgrid);
        }

        // undefined type is data
        if (!subgrid.type) {
            subgrid.type = 'data';
        }

        // make dictionary lookup entry
        var key = subgrid.type === 'data' && subgrid.type || subgrid.name || subgrid.type;
        this._subgrids.lookup[key] = this._subgrids.lookup[key] || subgrid; // only save first with this key

        // make isType boolean
        subgrid['is' + subgrid.type[0].toUpperCase() + subgrid.type.substr(1)] = true;

        return subgrid;
    },

    /**
     * @summary Gets the number of "header rows".
     * @desc Defined as the sum of all rows in all subgrids before the (first) data subgrid.
     * @memberOf Local.prototype
     */
    getHeaderRowCount: function getHeaderRowCount() {
        var result = 0;

        this.subgrids.find(function (subgrid) {
            if (subgrid.isData) {
                return true; // stop
            }
            result += subgrid.getRowCount();
        });

        return result;
    },

    /**
     * @summary Gets the number of "footer rows".
     * @desc Defined as the sum of all rows in all subgrids after the (last) data subgrid.
     * @memberOf Local.prototype
     */
    getFooterRowCount: function getFooterRowCount() {
        var gotData;
        return this.subgrids.reduce(function (rows, subgrid) {
            if (gotData && !subgrid.isData) {
                rows += subgrid.getRowCount();
            } else {
                gotData = subgrid.isData;
            }
            return rows;
        }, 0);
    },

    /**
     * @summary Gets the total number of logical rows.
     * @desc Defined as the sum of all rows in all subgrids.
     * @memberOf Local.prototype
     */
    getLogicalRowCount: function getLogicalRowCount() {
        return this.subgrids.reduce(function (rows, subgrid) {
            return rows += subgrid.getRowCount();
        }, 0);
    }
};

/**
 * @summary Resolves a subgrid constructor reference.
 * @desc The ref is resolved to a data model constructor.
 * @this {Behavior}
 * @param {subgridConstructorRef} ref
 * @returns {DataModel} A data model constructor.
 * @memberOf Behavior~
 */
function derefSubgridRef(ref) {
    var Constructor;
    switch (typeof ref === 'undefined' ? 'undefined' : _typeof(ref)) {
        case 'string':
            Constructor = dataModels[ref];
            break;
        case 'function':
            Constructor = ref;
            break;
        default:
            throw new this.HypergridError('Expected subgrid ref to be registered name or constructor, but found ' + (typeof ref === 'undefined' ? 'undefined' : _typeof(ref)) + '.');
    }
    return Constructor;
}

},{"../dataModels/index":64}],45:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Base = require('../Base');
var effects = require('../lib/DOM/effects');
var Localization = require('../lib/Localization');

/**
 * @constructor
 * @desc Displays a cell editor and handles cell editor interactions.
 *
 * > This constructor (actually `initialize`) will be called upon instantiation of this class or of any class that extends from this class. See {@link https://github.com/joneit/extend-me|extend-me} for more info.
 *
 * Instances of `CellEditor` are used to render an HTML element on top of the grid exactly within the bound of a cell for purposes of editing the cell value.
 *
 * Extend this base class to implement your own cell editor.
 *
 * @param grid
 * @param {CellEditor#renderConfig} options - Properties listed below + arbitrary mustache "variables" for merging into template.
 * @param {Point} options.editPoint - Deprecated; use `options.gridCell`.
 * @param {string} [options.format] - Name of a localizer with which to override prototype's `localizer` property.
 */
var CellEditor = Base.extend('CellEditor', {

    initialize: function initialize(grid, options) {
        // Mix in all enumerable properties for mustache use, typically `column` and `format`.
        for (var key in options) {
            this[key] = options[key];
        }

        this.event = options;

        var value = this.event.value;

        /**
         * my instance of hypergrid
         * @type {Hypergrid}
         * @memberOf CellEditor.prototype
         */
        this.grid = grid;

        this.grid.cellEditor = this;

        this.locale = grid.localization.locale; // for template's `lang` attribute

        // Only override cell editor's default 'null' localizer if the custom localizer lookup succeeds.
        // Failure is when it returns the default ('string') localizer when 'string' is not what was requested.
        var localizer = this.grid.localization.get(options.format); // try to get named localizer
        if (!(localizer === Localization.prototype.string || options.format === 'string')) {
            this.localizer = localizer;
        }

        this.initialValue = value;

        var container = document.createElement('DIV');
        container.innerHTML = this.grid.modules.templater.render(this.template, this);

        /**
         * This object's input control, one of:
         * * *input element* - an `HTMLElement` that has a `value` attribute, such as `HTMLInputElement`, `HTMLButtonElement`, etc.
         * * *container element* - an `HTMLElement` containing one or more input elements, only one of which contains the editor value.
         *
         * For access to the input control itself (which may or may not be the same as `this.el`), see `this.input`.
         *
         * @type {HTMLElement}
         * @default null
         * @memberOf CellEditor.prototype
         */
        this.el = container.firstChild;

        this.input = this.el;

        this.errors = 0;

        var self = this;
        this.el.addEventListener('keyup', this.keyup.bind(this));
        this.el.addEventListener('keydown', function (e) {
            if (e.keyCode === 9) {
                // prevent TAB from leaving input control
                e.preventDefault();
            }
            grid.fireSyntheticEditorKeyDownEvent(self, e);
        });
        this.el.addEventListener('keypress', function (e) {
            grid.fireSyntheticEditorKeyPressEvent(self, e);
        });
        this.el.addEventListener('mousedown', function (e) {
            self.onmousedown(e);
        });
    },

    // If you override this method, be sure to call it as a final step (or call stopPropagation yourself).
    onmousedown: function onmousedown(event) {
        event.stopPropagation(); // Catch mousedown here before it gets to the document listener defined in Hypergrid().
    },

    localizer: Localization.prototype.null,

    specialKeyups: {
        //0x08: 'clearStopEditing', // backspace
        0x09: 'stopEditing', // tab
        0x0d: 'stopEditing', // return/enter
        0x1b: 'cancelEditing' // escape
    },

    keyup: function keyup(e) {
        var grid = this.grid,
            cellProps = this.event.properties,
            feedbackCount = cellProps.feedbackCount,
            keyChar = grid.canvas.getKeyChar(e),
            specialKeyup,
            stopped;

        // STEP 1: Call the special key handler as needed
        if ((specialKeyup = this.specialKeyups[e.keyCode]) && (stopped = this[specialKeyup](feedbackCount))) {
            grid.repaint();
        }

        // STEP 2: If this is a possible "nav key" consumable by CellSelection#handleKeyDown, try to stop editing and send it along
        if (cellProps.mappedNavKey(keyChar, e.ctrlKey)) {
            if (!specialKeyup && (
            // We didn't try to stop editing above so try to stop it now
            stopped = this.stopEditing(feedbackCount))) {
                grid.repaint();
            }

            if (stopped) {
                // Editing successfully stopped
                // -> send the event down the feature chain
                var finEvent = grid.canvas.newEvent(e, 'fin-editor-keydown', {
                    grid: grid,
                    alt: e.altKey,
                    ctrl: e.ctrlKey,
                    char: keyChar,
                    code: e.charCode,
                    key: e.keyCode,
                    meta: e.metaKey,
                    shift: e.shiftKey,
                    identifier: e.key,
                    editor: this
                });
                grid.delegateKeyDown(finEvent);
            }
        }

        this.grid.fireSyntheticEditorKeyUpEvent(this, e);

        return stopped;
    },

    /**
     * if true, check that the editor is in the right location
     * @type {boolean}
     * @default false
     * @memberOf CellEditor.prototype
     */
    checkEditorPositionFlag: false,

    /**
     * @memberOf CellEditor.prototype
     * @desc This function is a callback from the fin-hypergrid.   It is called after each paint of the canvas.
     */
    gridRenderedNotification: function gridRenderedNotification() {
        this.checkEditor();
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc scroll values have changed, we've been notified
     */
    scrollValueChangedNotification: function scrollValueChangedNotification() {
        this.checkEditorPositionFlag = true;
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc move the editor to the current editor point
     */
    moveEditor: function moveEditor() {
        this.setBounds(this.event.bounds);
    },

    beginEditing: function beginEditing() {
        if (this.grid.fireRequestCellEdit(this.event, this.initialValue)) {
            this.checkEditorPositionFlag = true;
            this.checkEditor();
        }
    },

    showReadonlyEdit: function showReadonlyEdit() {
        if (this.grid.fireRequestCellEdit(this.event, this.initialValue)) {
            this.checkEditorPositionFlag = true;
            this.checkEditor(false);
            this.el.readOnly = true;
        }
    },

    /**
     * @summary Put the value into our editor.
     * @desc Formats the value and displays it.
     * The localizer's {@link localizerInterface#format|format} method will be called.
     *
     * Override this method if your editor has additional or alternative GUI elements.
     *
     * @param {object} value - The raw unformatted value from the data source that we want to edit.
     * @memberOf CellEditor.prototype
     */
    setEditorValue: function setEditorValue(value) {
        value = this.localizer.format(value, this.event.rowProperties.headerRow);
        if (Array.isArray(value)) {
            value = '[' + value.join(', ') + ']';
        }
        value = typeof value !== 'undefined' && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object' ? value : '';
        this.input.value = value;
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc display the editor
     */
    showEditor: function showEditor() {
        Object.assign(this.el.style, { display: 'inline' });
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc hide the editor
     */
    hideEditor: function hideEditor() {
        this.el.style.display = 'none';
    },

    /** @summary Stops editing.
     * @desc Before saving, validates the edited value in two phases as follows:
     * 1. Call `validateEditorValue`. (Calls the localizer's `invalid()` function, if available.)
     * 2. Catch any errors thrown by the {@link CellEditor#getEditorValue|getEditorValue} method.
     *
     * **If the edited value passes both phases of the validation:**
     * Saves the edited value by calling the {@link CellEditor#saveEditorValue|saveEditorValue} method.
     *
     * **On validation failure:**
     * 1. If `feedback` was omitted, cancels editing, discarding the edited value.
     * 2. If `feedback` was provided, gives the user some feedback (see `feedback`, below).
     *
     * @param {number} [feedback] What to do on validation failure. One of:
     * * **`undefined`** - Do not show the error effect or the end effect. Just discard the value and close the editor (as if `ESC` had been typed).
     * * **`0`** - Just shows the error effect (see the {@link CellEditor#errorEffect|errorEffect} property).
     * * **`1`** - Shows the error feedback effect followed by the detailed explanation.
     * * `2` or more:
     *   1. Shows the error feedback effect
     *   2. On every `feedback` tries, shows the detailed explanation.
     * * If `undefined` (omitted), simply cancels editing without saving edited value.
     * * If 0, shows the error feedback effect (see the {@link CellEditor#errorEffect|errorEffect} property).
     * * If > 0, shows the error feedback effect _and_ calls the {@link CellEditor#errorEffectEnd|errorEffectEnd} method) every `feedback` call(s) to `stopEditing`.
     * @returns {boolean} Truthy means successful stop. Falsy means syntax error prevented stop. Note that editing is canceled when no feedback requested and successful stop includes (successful) cancel.
     * @memberOf CellEditor.prototype
     */
    stopEditing: function stopEditing(feedback) {
        /**
         * @type {boolean|string|Error}
         */

        var error = this.validateEditorValue();

        if (!error) {
            try {
                var value = this.getEditorValue();
            } catch (err) {
                error = err;
            }
        }

        if (!error && this.grid.fireSyntheticEditorDataChangeEvent(this, this.initialValue, value) && !this.el.readOnly) {
            try {
                this.saveEditorValue(value);
            } catch (err) {
                error = err;
            }
        }

        if (!error) {
            this.hideEditor();
            this.grid.cellEditor = null;
            this.el.remove();
        } else if (feedback >= 0) {
            // false when `feedback` undefined
            this.errorEffectBegin(++this.errors % feedback === 0 && error);
        } else {
            // invalid but no feedback
            this.cancelEditing();
        }

        return !error;
    },

    /** @summary Cancels editing.
     * @returns {boolean} Successful. (Cancel is always successful.)
     */
    cancelEditing: function cancelEditing() {
        this.setEditorValue(this.initialValue);
        this.hideEditor();
        this.grid.cellEditor = null;
        this.el.remove();

        return true;
    },

    /**
     * Calls the effect function indicated in the {@link module:defaults.feedbackEffect|feedbackEffect} property, which triggers a series of CSS transitions.
     * @param {boolean|string|Error} [error] - If defined, call the {@link CellEditor#errorEffectEnd|errorEffectEnd} method at the end of the last effect transition with this error.
     * @memberOf CellEditor.prototype
     */
    errorEffectBegin: function errorEffectBegin(error) {
        var spec = this.grid.properties.feedbackEffect,
            // spec may e a string or an object with name and options props
        options = Object.assign({}, spec.options),
            // if spec is a string, spec.options will be undefined
        effect = effects[spec.name || spec]; // if spec is a string, spec.name will be undefined

        if (error) {
            options.callback = this.errorEffectEnd.bind(this, error);
        }

        if (effect) {
            effect.call(this, options);
        }
    },

    /**
     * This function expects to be passed an error. There is no point in calling this function if there is no error. Nevertheless, if called with a falsy `error`, returns without doing anything.
     * @this {CellEditor}
     * @param {boolean|string|Error} [error]
     */
    errorEffectEnd: function errorEffectEnd(error, options) {
        if (error) {
            var msg = 'Invalid value. To resolve, do one of the following:\n\n' + '   * Correct the error and try again.\n' + '         - or -\n' + '   * Cancel editing by pressing the "esc" (escape) key.';

            error = error.message || error;

            if (typeof error !== 'string') {
                error = '';
            }

            if (this.localizer.expectation) {
                error = error ? error + '\n' + this.localizer.expectation : this.localizer.expectation;
            }

            if (error) {
                if (/[\n\r]/.test(error)) {
                    error = '\n' + error;
                    error = error.replace(/[\n\r]+/g, '\n\n   * ');
                }
                msg += '\n\nAdditional information about this error: ' + error;
            }

            setTimeout(function () {
                // allow animation to complete
                alert(msg); // eslint-disable-line no-alert
            });
        }
    },

    /**
     * @desc save the new value into the behavior (model)
     * @returns {boolean} Data changed and pre-cell-edit event was not canceled.
     * @memberOf CellEditor.prototype
     */
    saveEditorValue: function saveEditorValue(value) {
        var save = !(value && value === this.initialValue) && // data changed
        this.grid.fireBeforeCellEdit(this.event.gridCell, this.initialValue, value, this) // proceed
        ;

        if (save) {
            this.grid.behavior.setValue(this.event, value);
            this.grid.fireAfterCellEdit(this.event.gridCell, this.initialValue, value, this);
        }

        return save;
    },

    /**
     * @summary Extract the edited value from the editor.
     * @desc De-format the edited string back into a primitive value.
     *
     * The localizer's {@link localizerInterface#parse|parse} method will be called on the text box contents.
     *
     * Override this method if your editor has additional or alternative GUI elements. The GUI elements will influence the primitive value, either by altering the edited string before it is parsed, or by transforming the parsed value before returning it.
     * @returns {object} the current editor's value
     * @memberOf CellEditor.prototype
     */
    getEditorValue: function getEditorValue() {
        return this.localizer.parse(this.input.value);
    },

    /**
     * If there is no validator on the localizer, returns falsy (not invalid; possibly valid).
     * @returns {boolean|string} Truthy value means invalid. If a string, this will be an error message. If not a string, it merely indicates a generic invalid result.
     */
    validateEditorValue: function validateEditorValue() {
        return this.localizer.invalid && this.localizer.invalid(this.input.value);
    },

    /**
     * @summary Request focus for my input control.
     * @desc See GRID-95 "Scrollbar moves inward" for issue and work-around explanation.
     * @memberOf CellEditor.prototype
     */
    takeFocus: function takeFocus() {
        var el = this.el,
            leftWas = el.style.left,
            topWas = el.style.top;

        el.style.left = el.style.top = 0; // work-around: move to upper left

        var x = window.scrollX,
            y = window.scrollY;
        this.input.focus();
        window.scrollTo(x, y);
        this.selectAll();

        el.style.left = leftWas;
        el.style.top = topWas;
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc select everything
     */
    selectAll: nullPattern,

    /**
     * @memberOf CellEditor.prototype
     * @desc set the bounds of my input control
     * @param {Rectangle} cellBounds - the bounds to move to
     */
    setBounds: function setBounds(cellBounds) {
        var selectionRegionBorderWidth = this.grid.properties.selectionRegionBorderWidth;
        var _grid$canvas = this.grid.canvas,
            gc = _grid$canvas.gc,
            canvasWidth = _grid$canvas.width,
            canvasHeight = _grid$canvas.height;
        var style = this.el.style;

        var rowFont = this.event.rowProperties.font || this.event.properties.font;

        var left = cellBounds.x;

        var maximumColumnWidth = canvasWidth - left;

        gc.cache.font = rowFont;
        // additional width because of inner padding and border
        var width = gc.getTextWidth(this.initialValue) + 12;

        // correct width if it too much
        if (!width || width < cellBounds.width) {
            width = cellBounds.width + selectionRegionBorderWidth;
        }
        if (width > maximumColumnWidth) {
            width = maximumColumnWidth;
        }

        // move to left if it needed
        if (left + width > canvasWidth) {
            left = canvasWidth - width;
        }

        width += selectionRegionBorderWidth;

        Object.assign(style, { left: px(left), width: px(width), font: rowFont, resize: 'none' });

        // additional height because of inner padding and border
        var height = (width === maximumColumnWidth + selectionRegionBorderWidth ? this.el.scrollHeight : cellBounds.height) + 2;
        var top = cellBounds.y - selectionRegionBorderWidth;
        var maximumColumnHeight = canvasHeight - top;

        // correct height if it too mush
        if (height > maximumColumnHeight) {
            height = maximumColumnHeight;
        }

        // move to top if it needed
        if (top + height > canvasHeight) {
            top = canvasHeight - height;
        }

        Object.assign(style, { top: px(top), height: px(height) });
    },

    /**
     * @desc check that the editor is in the correct location, and is showing/hidden appropriately
     * @param {boolean?} takeFocusNeeded
     * @memberOf CellEditor.prototype
     */
    checkEditor: function checkEditor(takeFocusNeeded) {
        takeFocusNeeded = takeFocusNeeded === undefined ? true : takeFocusNeeded;
        if (this.checkEditorPositionFlag) {
            this.checkEditorPositionFlag = false;
            if (this.event.isCellVisible) {
                this.setEditorValue(this.initialValue);
                this.attachEditor();
                this.moveEditor();
                this.showEditor();
                if (takeFocusNeeded) {
                    this.takeFocus();
                }
            } else {
                this.hideEditor();
            }
        }
    },

    attachEditor: function attachEditor() {
        this.grid.div.appendChild(this.el);
    },

    template: ''

});

function nullPattern() {}
function px(n) {
    return n + 'px';
}

module.exports = CellEditor;

},{"../Base":17,"../lib/DOM/effects":88,"../lib/Localization":89}],46:[function(require,module,exports){
'use strict';

var CellEditor = require('./CellEditor');

/**
 * As of spring 2016:
 * Functions well in Chrome and Firefox; unimplemented in Safari.
 * @constructor
 * @extends CellEditor
 */
var Color = CellEditor.extend('Color', {

  template: '<input type="color" lang="{{locale}}" style="{{style}}">'

});

module.exports = Color;

},{"./CellEditor":45}],47:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var CellEditor = require('./CellEditor');

var isChromium = window.chrome,
    winNav = window.navigator,
    vendorName = winNav.vendor,
    isOpera = winNav.userAgent.indexOf('OPR') > -1,
    isIEedge = winNav.userAgent.indexOf('Edge') > -1,
    isIOSChrome = winNav.userAgent.match('CriOS'),
    isChrome = !isIOSChrome && isChromium !== null && isChromium !== undefined && vendorName === 'Google Inc.' && isOpera == false && isIEedge == false; // eslint-disable-line eqeqeq

/**
 * As of spring 2016:
 * Functions well in Chrome except no localization (day, month names; date format).
 * Unimplemented in Safari, Firefox, Internet Explorer.
 * This is a "snmart" control. It detects Chrome:
 * * If Chrome, uses chromeDate overrides format to that required by the value attribute, yyyy-mm-dd. (Note that this is not the format displayed in the control, which is always mm/dd/yyyy.)
 * * Otherwise uses localized date format _but_ falls back to a regular text box.
 * @constructor
 * @extends CellEditor
 */
var Date = CellEditor.extend('Date', {

    initialize: function initialize(grid) {

        var localizerName,
            usesDateInputControl = isChrome;

        if (usesDateInputControl) {
            localizerName = 'chromeDate';
            this.template = '<input type="date">';
        } else {
            localizerName = 'date';
            this.template = '<input type="text" lang="{{locale}}">';

            this.selectAll = function () {
                var lastCharPlusOne = this.getEditorValue().length;
                this.input.setSelectionRange(0, lastCharPlusOne);
            };
        }

        this.localizer = grid.localization.get(localizerName);
    }
});

module.exports = Date;

},{"./CellEditor":45}],48:[function(require,module,exports){
'use strict';

var Textfield = require('./Textfield');

/**
 * Functions well in Chrome, Safari, Firefox, and Internet Explorer.
 * @constructor
 * @extends Textfield
 */
var Number = Textfield.extend('Number', {

    initialize: function initialize(grid) {
        this.localizer = grid.localization.get('number');
    }

});

module.exports = Number;

},{"./Textfield":51}],49:[function(require,module,exports){
'use strict';

var CellEditor = require('./CellEditor');

/**
 * @constructor
 * @extends CellEditor
 */
var Slider = CellEditor.extend('Slider', {

  template: '<input type="range" lang="{{locale}}" style="{{style}}">'

});

module.exports = Slider;

},{"./CellEditor":45}],50:[function(require,module,exports){
'use strict';

var CellEditor = require('./CellEditor');

/**
 * @constructor
 * @extends CellEditor
 */
var Spinner = CellEditor.extend('Spinner', {

  template: '<input type="number" lang="{{locale}}" style="{{style}}">'

});

module.exports = Spinner;

},{"./CellEditor":45}],51:[function(require,module,exports){
'use strict';

var CellEditor = require('./CellEditor');
var Localization = require('../lib/Localization');

/**
 * As of spring 2016:
 * Functions well in Chrome, Safari, Firefox, and Internet Explorer.
 * @constructor
 * @extends CellEditor
 */
var Textfield = CellEditor.extend('Textfield', {

    template: '<textarea lang="{{locale}}" class="hypergrid-textfield" style="{{style}}">',

    initialize: function initialize() {
        this.input.style.textAlign = this.event.properties.halign;
    },

    localizer: Localization.prototype.string,

    selectAll: function selectAll() {
        this.input.setSelectionRange(0, this.input.value.length);
    }
});

module.exports = Textfield;

},{"../lib/Localization":89,"./CellEditor":45}],52:[function(require,module,exports){
'use strict';

var Registry = require('../lib/Registry');

var warnedBaseClass;

/**
 * @classdesc Registry of cell editor constructors.
 * @constructor
 */
var CellEditors = Registry.extend('CellEditors', {

    BaseClass: require('./CellEditor'), // abstract base class

    initialize: function initialize() {
        // preregister the standard cell editors
        this.add(require('./Color'));
        this.add(require('./Date'));
        this.add(require('./Number'));
        this.add(require('./Slider'));
        this.add(require('./Spinner'));
        this.add(require('./Textfield'));
    },

    get: function get(name) {
        if (name && name.toLowerCase() === 'celleditor') {
            if (!warnedBaseClass) {
                console.warn('grid.cellEditors.get("' + name + '") method call has been deprecated as of v2.1.0 in favor of grid.cellEditors.BaseClass property. (Will be removed in a future release.)');
                warnedBaseClass = true;
            }
            return this.BaseClass;
        }
        try {
            var CellEditor = Registry.prototype.get.call(this, name);
        } catch (err) {
            // fail silently
        }
        return CellEditor;
    }

});

module.exports = new CellEditors();

},{"../lib/Registry":90,"./CellEditor":45,"./Color":46,"./Date":47,"./Number":48,"./Slider":49,"./Spinner":50,"./Textfield":51}],53:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var Button = CellRenderer.extend('Button', {

    paint: function paint(gc, config) {
        var val = config.value,
            c = config.dataCell.x,
            r = config.gridCell.y,
            bounds = config.bounds,
            x = bounds.x + 1,
            y = bounds.y + 1,
            width = bounds.width - 1 - config.lineWidth,
            height = bounds.height - 1 - config.lineWidth,
            radius = height / 2,
            arcGradient = gc.createLinearGradient(x, y, x, y + height);

        if (config.mouseDown) {
            arcGradient.addColorStop(0, '#B5CBED');
            arcGradient.addColorStop(1, '#4d74ea');
        } else {
            arcGradient.addColorStop(0, '#ffffff');
            arcGradient.addColorStop(1, '#aaaaaa');
        }

        // draw the background
        gc.cache.fillStyle = config.backgroundColor;
        gc.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);

        // draw the capsule
        gc.cache.fillStyle = arcGradient;
        gc.cache.strokeStyle = '#000000';
        this.roundRect(gc, x, y, width, height, radius, arcGradient, true);

        var ox = (width - gc.getTextWidth(val)) / 2;
        var oy = (height - gc.getTextHeight(gc.cache.font).descent) / 2;

        // draw the text
        gc.cache.textBaseline = 'middle';
        gc.cache.fillStyle = '#333333';
        gc.cache.font = height - 2 + 'px sans-serif';
        config.backgroundColor = 'rgba(0,0,0,0)';
        gc.simpleText(val, x + ox, y + oy);

        // Identify that we are a button by inserting an array of bounds into buttonCells for this cell's coords,
        // one element per subrow. This will be a single-element array for a cell without `subrows`.
        var key = c + ',' + r,
            buttonCells = config.buttonCells,
            buttonSubrows = buttonCells[key] || (buttonCells[key] = []);

        buttonSubrows[config.subrow] = Object.assign({}, bounds);
    }
});

module.exports = Button;

},{"./CellRenderer":54}],54:[function(require,module,exports){
/* eslint-env browser */
'use strict';

/** @typedef {object} CellRenderer#renderConfig
 *
 * This is the renderer config object, which is:
 * 1. First passed to a {@link dataModelAPI#getCell getCell} method implementation, which may override (most of) its values before returning.
 * 2. Then passed to the specified cell renderers' {@link CellRenderer#paint paint} function for rendering.
 *
 * #### Standard Properties
 *
 * On each and every render of every cell in view, this a fresh instance of an object created from a {@link CellEvent} object, which in turn descends from {@link module:defaults}. It therefore has all the standard properties defined in both objects (see).
 *
 * #### Additional Properties
 *
 * Properties marked _read-only_ below may in fact be writable, but should be considered **off limits** to overriding. Do not attempt to change these properties inside a {@link dataModelAPI#getCell getCell} method override.
 *
 * @property {boolean} config.allRowsSelected
 *
 * @property {BoundingRect} config.bounds - Bounding rect of the cell or subcell to be rendered.
 *
 * @property {object} buttonCells - _For cell renderer use only. Not available in `getCell` override._  (Button renderers register themselves in this object so the click handler can know whether or not to fire the 'fin-button-pressed' event.)
 *
 * @property {dataCellCoords} config.dataCell - _Read-only._ Data coordinates of the cell.
 *
 * @property {dataRowObject} config.dataRow - Access to other column values in the same row.
 *
 * @property {function} config.formatValue - _For cell renderer use only. Not available in `getCell` override._ The cell's value formatter function (based on the formatter name in `config.format`, as possibly mutated by `getCell`).
 *
 * @property {gridCellCoords} config.gridCell - _Read-only._ Grid coordinates of the cell.
 *
 * @property {} config.halign - The cell's horizontal alignment property, as interpreted by it's cell renderer.
 *
 * @property {boolean} config.isCellHovered -
 *
 * @property {boolean} config.isCellSelected -
 *
 * @property {boolean} config.isColumnHovered -
 *
 * @property {boolean} config.isColumnSelected -
 *
 * @property {boolean} config.isDataColumn -
 *
 * @property {boolean} config.isDataRow -
 *
 * @property {boolean} config.isFilterRow -
 *
 * @property {boolean} config.isHandleColumn -
 *
 * @property {boolean} config.isHeaderRow -
 *
 * @property {boolean} config.isInCurrentSelectionRectangle -
 *
 * @property {boolean} config.isRowHovered -
 *
 * @property {boolean} config.isRowSelected -
 *
 * @property {boolean} config.isSelected -
 *
 * @property {boolean} config.isTreeColumn -
 *
 * @property {boolean} config.isUserDataArea -
 *
 * @property {number} config.minWidth - _For cell renderer use only. Not available in `getCell` override._ The Cell renderer returns the pixel width of the rendered contents in this property.
 *
 * @property {boolean} config.mouseDown - The last mousedown event occured over this cell and the mouse is still down. Note, however, that the mouse may no longer be hovering over this cell when it has been dragged away.
 *
 * @property {} [config.prefillColor] - _For cell renderer use only. Do not mutate in `getCell` override._ (This is the color already painted behind the cell to be rendered. If the cell's specified background color is the same, renderer may (and should!) skip painting it. If `undefined`, this is a "partial render" and cell renderers that support partial rendering can use `config.snapshot` to determine whether or not to rerender the cell.)
 *
 * @property {object} [config.snapshot] - _For cell renderer use only. Not available in `getCell` override._ Supports _partial render._ In support of the {@link Renderer#paintCellsAsNeeded by-cells} "partial" grid renderer, cell renderers can save the essential render parameters in this property so that on subsequent calls, when the parameters are the same, cell renderers can skip the actual rendering. Only when the parameters have changed is the cell rendered and this property reset (with the new parameters). This object would typically include at the very least the (formatted) `value`, plus additional properties as needed to fully describe the appearance of the render, such as color, _etc._ This property is undefined the first time a cell is rendered by the `by-cells` grid renderer. See also the {@link dataModelAPI#configObject}'s `prefillColor` property.
 *
 * @property config.value - Value to be rendered.
 *
 * The renderer has available to it the `.formatValue()` function for formatting the value. The function comes from the localizer named in the `.format` property. If there is no localizer with that name, the function defaults to the `string` localizer's formatter (which simply invokes the value's `toString()` method).
 *
 * Typically a Local primitive value, values can be any type, including objects and arrays. The specified cell renderer is expected to know how to determine the value's type and render it.
 */

var Base = require('../Base');

/** @constructor
 * @desc Instances of `CellRenderer` are used to render the 2D graphics context within the bound of a cell.
 *
 * Extend this base class to implement your own cell renderer.
 *
 * @tutorial cell-renderer
 */
var CellRenderer = Base.extend('CellRenderer', {
    /**
     * @desc An empty implementation of a cell renderer, see [the null object pattern](http://c2.com/cgi/wiki?NullObject).
     *
     * @this {CellEditor}
     *
     * @param {CanvasRenderingContext2D} gc
     *
     * @param {CellRenderer#renderConfig} config
     *
     * @returns {number} Preferred pixel width of content. The content may or may not be rendered at that width depending on whether or not `config.bounds` was respected and whether or not the grid renderer is using clipping. (Clipping is generally not used due to poor performance.)
     *
     * @memberOf CellRenderer.prototype
     */
    paint: function paint(gc, config) {},

    /**
     * @desc A simple implementation of rounding a cell.
     * @param {CanvasRenderingContext2D} gc
     * @param {number} x - the x grid coordinate of my origin
     * @param {number} y - the y grid coordinate of my origin
     * @param {number} width - the width I'm allowed to draw within
     * @param {number} height - the height I'm allowed to draw within
     * @param {number} radius
     * @param {number} fill
     * @param {number} stroke
     * @memberOf CellRenderer.prototype
     */
    roundRect: function roundRect(gc, x, y, width, height, radius, fill, stroke) {

        if (!stroke) {
            stroke = true;
        }
        if (!radius) {
            radius = 5;
        }
        gc.beginPath();
        gc.moveTo(x + radius, y);
        gc.lineTo(x + width - radius, y);
        gc.quadraticCurveTo(x + width, y, x + width, y + radius);
        gc.lineTo(x + width, y + height - radius);
        gc.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        gc.lineTo(x + radius, y + height);
        gc.quadraticCurveTo(x, y + height, x, y + height - radius);
        gc.lineTo(x, y + radius);
        gc.quadraticCurveTo(x, y, x + radius, y);
        gc.closePath();
        if (stroke) {
            gc.stroke();
        }
        if (fill) {
            gc.fill();
        }
        gc.closePath();
    },

    /**
     * @desc utility function to render SVG image with an text inside
     * @param {CanvasRenderingContext2D} gc
     * @param {number} x - left point of area where image will be rendered
     * @param {number} y - top point of area where image will be rendered
     * @param {number} width - width of area where image will be rendered
     * @param {number} height - height of area where image will be rendered
     * @param {string} svgSrc - link to an image, that needed to be rendered
     * @param {string} val - text value, that will be rendered inside image area
     * @param {string} font - font of an inner text
     * @param {string} fontColor - font color of an inner text
     * @memberOf CellRenderer.prototype
     */
    renderSvgImageWithText: function renderSvgImageWithText(gc, x, y, height, width, svgSrc, val, font, fontColor) {
        var prevFontState = gc.cache.font,
            prevFillStyleState = gc.cache.fillStyle,
            prevTextAlign = gc.cache.textAlign;

        var img = new Image();
        img.onload = function () {
            gc.drawImage(img, x, y, height, width);

            var textStartX = x + width / 2;
            var textStartY = y + height / 2 + 5;

            gc.cache.font = font;
            gc.cache.fillStyle = fontColor;
            gc.cache.textAlign = 'center';

            if (val.length > 1) {
                val = '...';
            }

            gc.simpleText(val, textStartX, textStartY);

            gc.cache.font = prevFontState;
            gc.cache.fillStyle = prevFillStyleState;
            gc.cache.textAlign = prevTextAlign;
        };
        img.src = svgSrc;
    },

    /**
     * @desc utility function to render triangle with rounded corners with an inner text
     * @param {CanvasRenderingContext2D} gc
     * @param {number} x - left point of area where triangle will be rendered
     * @param {number} y - top point of area where triangle will be rendered
     * @param {number} width - width of area where triangle will be rendered
     * @param {number} height - height of area where triangle will be rendered
     * @param {number} cornerRadius - corner radius of triangle
     * @param {string} fillStyle - fill style of an entire triangle
     * @param {string} val - text value, that will be rendered inside image area
     * @param {string} font - font of an inner text
     * @param {string} fontColor - font color of an inner text
     * @memberOf CellRenderer.prototype
     */
    renderRoundedTriangleWithText: function renderRoundedTriangleWithText(gc, x, y, height, width, cornerRadius, fillStyle, val, font, fontColor) {
        var prevFontState = gc.cache.font,
            prevFillStyleState = gc.cache.fillStyle,
            prevTextAlign = gc.cache.textAlign,
            prevLineJoin = gc.cache.lineJoin,
            prevLineWidth = gc.cache.lineWidth;

        var topPointX = x + width / 2;
        var topPointY = y + cornerRadius * 2;

        var triangleWidth = width - cornerRadius * 2;
        var triangleHeight = height - cornerRadius * 2;

        gc.beginPath();
        gc.moveTo(topPointX, topPointY);
        gc.lineTo(topPointX + triangleWidth / 2, topPointY + triangleHeight);
        gc.lineTo(topPointX - triangleWidth / 2, topPointY + triangleHeight);
        gc.closePath();
        gc.fillStyle = fillStyle;
        gc.fill();

        gc.lineWidth = cornerRadius;
        gc.lineJoin = 'round';
        gc.strokeStyle = fillStyle;
        gc.stroke();

        var textStartX = x + width / 2;
        var textStartY = y + height / 2 + 3;

        gc.cache.font = font;
        gc.cache.fillStyle = fontColor;
        gc.cache.textAlign = 'center';

        if (val.length > 1) {
            val = '...';
        }

        gc.simpleText(val, textStartX, textStartY);

        gc.cache.font = prevFontState;
        gc.cache.fillStyle = prevFillStyleState;
        gc.cache.textAlign = prevTextAlign;
        gc.cache.lineJoin = prevLineJoin;
        gc.cache.lineWidth = prevLineWidth;
    }
});

module.exports = CellRenderer;

},{"../Base":17}],55:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var ErrorCell = CellRenderer.extend('ErrorCell', {

    /**
     * @summary Writes error message into cell.
     *
     * @desc This function is guaranteed to be called as follows:
     *
     * ```javascript
     * gc.save();
     * gc.beginPath();
     * gc.rect(x, y, width, height);
     * gc.clip();
     * behavior.getCellProvider().renderCellError(gc, message, x, y, width, height);
     * gc.restore();
     * ```
     *
     * Before doing anything else, this function should clear the cell by setting `gc.fillStyle` and calling `gc.fill()`.
     *
     * @param {CanvasRenderingContext2D} gc
     * @param {object} config
     * @param message
     * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
     * @memberOf ErrorCell.prototype
     */
    paint: function paint(gc, config, message) {
        var x = config.bounds.x,
            y = config.bounds.y,

        // width = config.bounds.width,
        height = config.bounds.height;

        // clear the cell
        // (this makes use of the rect path defined by the caller)
        gc.cache.fillStyle = '#FFFFFF';
        gc.fill();

        // render message text
        gc.cache.fillStyle = '#a94d4dc2';
        gc.cache.textAlign = 'start';
        gc.cache.textBaseline = 'middle';
        gc.cache.font = '13px "Helvetica Neue",Helvetica,Arial,sans-serif';
        gc.simpleText(message, x + 4, y + height / 2 + 0.5);
    }
});

module.exports = ErrorCell;

},{"./CellRenderer":54}],56:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @desc A rendering of the last Selection Model
 * @extends CellRenderer
 */
var LastSelection = CellRenderer.extend('LastSelection', {
    paint: function paint(gc, config) {
        var visOverlay = gc.alpha(config.selectionRegionOverlayColor) > 0,
            visOutline = gc.alpha(config.selectionRegionOutlineColor) > 0;

        if (visOverlay || visOutline) {
            var x = config.bounds.x,
                y = config.bounds.y,
                width = config.bounds.width,
                height = config.bounds.height;

            if (visOverlay) {
                gc.beginPath();

                gc.rect(x, y, width, height);

                gc.cache.fillStyle = config.selectionRegionOverlayColor;
                gc.fill();

                gc.closePath();
            }

            if (visOutline) {
                drawRectBorder(gc, x - 1, y - 1, width + 1, height + 1, config.selectionRegionOutlineColor, config.selectionRegionBorderWidth);
            }
        }
    }
});

module.exports = LastSelection;

function drawRectBorder(ctx, x, y, width, height, color, lineWidth) {
    ctx.cache.fillStyle = color;
    ctx.fillRect(x, y, lineWidth, height);
    ctx.fillRect(x, y, width, lineWidth);
    ctx.fillRect(x + width, y, lineWidth, height);
    ctx.fillRect(x, y + height, width + 1, lineWidth);
}

},{"./CellRenderer":54}],57:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');
var images = require('../../images');

var WHITESPACE = /\s\s+/g;

/**
 * @constructor
 * @summary The default cell renderer for a vanilla cell.
 * @desc Great care has been taken in crafting this function as it needs to perform extremely fast.
 *
 * Use `gc.cache` instead which we have implemented to cache the graphics context properties. Reads on the graphics context (`gc`) properties are expensive but not quite as expensive as writes. On read of a `gc.cache` prop, the actual `gc` prop is read into the cache once and from then on only the cache is referenced for that property. On write, the actual prop is only written to when the new value differs from the cached value.
 *
 * Clipping bounds are not set here as this is also an expensive operation. Instead, we employ a number of strategies to truncate overflowing text and content.
 *
 * @extends CellRenderer
 */
var SimpleCell = CellRenderer.extend('SimpleCell', {
    paint: function paint(gc, config) {
        var val = config.value,
            bounds = config.bounds,
            x = bounds.x,
            y = bounds.y,
            width = bounds.width,
            height = bounds.height,
            iconPadding = config.iconPadding,
            partialRender = config.prefillColor === undefined,
            // signifies abort before rendering if same
        snapshot = config.snapshot,
            same = snapshot && partialRender,
            valWidth = 0,
            textColor,
            textFont,
            ixoffset,
            iyoffset,
            leftIcon,
            rightIcon,
            centerIcon,
            leftPadding,
            rightPadding,
            hover,
            hoverColor,
            selectColor,
            foundationColor,
            inheritsBackgroundColor,
            c,
            colors;

        // setting gc properties are expensive, let's not do it needlessly

        leftIcon = images[config.leftIcon];
        centerIcon = images[config.centerIcon];
        rightIcon = images[config.rightIcon];

        // Note: vf == 0 is fastest equivalent of vf === 0 || vf === false which excludes NaN, null, undefined
        var renderValue = val || config.renderFalsy && val == 0; // eslint-disable-line eqeqeq

        if (renderValue && config.isDataRow) {
            var count = config.grid.behavior.dataModel.getCount(config.dataCell.x, config.dataCell.y);
            if (count !== undefined) {
                config.valuePostfix = '(' + count + ')';
            }
        }

        if (renderValue) {
            val = config.formatValue(val, config);

            if (Array.isArray(val)) {
                val = '[' + val.join(', ') + ']';
            }

            textFont = config.isSelected ? config.foregroundSelectionFont : config.font;

            textColor = gc.cache.strokeStyle = config.isSelected ? config.foregroundSelectionColor : config.color;
        } else {
            val = '';
        }

        same = same && val === snapshot.value && textFont === snapshot.textFont && textColor === snapshot.textColor;

        // fill background only if our bgColor is populated or we are a selected cell
        colors = [];
        c = 0;

        if (!config.disableHoverHighlighting) {
            if (config.isCellHovered && config.hoverCellHighlight.enabled) {
                hoverColor = config.hoverCellHighlight.backgroundColor;
            } else if (config.isRowHovered && (hover = config.hoverRowHighlight).enabled) {
                hoverColor = config.isDataColumn || !hover.header || hover.header.backgroundColor === undefined ? hover.backgroundColor : hover.header.backgroundColor;
            } else if (config.isColumnHovered && (hover = config.hoverColumnHighlight).enabled) {
                hoverColor = config.isDataRow || !hover.header || hover.header.backgroundColor === undefined ? hover.backgroundColor : hover.header.backgroundColor;
            }
        }

        if (gc.alpha(hoverColor) < 1) {
            if (config.isSelected && !config.isFirstSelectedCell && (config.isHeaderRow || !config.isDataColumn)) {
                selectColor = config.backgroundHeaderSelectionColor;
            }

            if (gc.alpha(selectColor) < 1) {
                inheritsBackgroundColor = config.backgroundColor === config.prefillColor;
                if (!inheritsBackgroundColor) {
                    foundationColor = true;

                    if (config.combineColors) {
                        colors.push(config.backgroundColor);
                    } else {
                        colors = [config.backgroundColor];
                    }

                    same = same && foundationColor === snapshot.foundationColor && config.backgroundColor === snapshot.colors[c++];
                }
            }

            if (selectColor !== undefined) {
                if (config.combineColors) {
                    colors.push(selectColor);
                } else {
                    colors = [selectColor];
                }
                // colors.push(selectColor);
                same = same && selectColor === snapshot.colors[c++];
            }
        }
        if (hoverColor !== undefined) {
            if (config.combineColors) {
                colors.push(hoverColor);
            } else {
                colors = [hoverColor];
            }

            same = same && hoverColor === snapshot.colors[c++];
        }

        // todo check if icons have changed
        if (same && c === snapshot.colors.length) {
            return;
        }

        // return a snapshot to save in cellEvent for future comparisons by partial renderer
        config.snapshot = {
            value: val,
            textColor: textColor,
            textFont: textFont,
            foundationColor: foundationColor,
            colors: colors
        };

        layerColors(gc, colors, x, y, width, height, foundationColor);

        // Measure left and right icons, needed for rendering and for return value (min width)
        leftPadding = leftIcon ? iconPadding + leftIcon.width + iconPadding : config.cellPaddingLeft;
        rightPadding = rightIcon ? iconPadding + rightIcon.width + iconPadding : config.cellPaddingRight;

        if (config.isAggregationTreeColumn) {
            leftPadding += config.treeLevel * config.aggregationGroupTreeLevelOffset;
        }

        var textRightPadding = rightPadding;

        if (config.renderTotalErrorSignNeeded && config.renderTotalErrorCount) {
            var totalErrorsCountIconStartY = y + (height / 2 - config.totalErrorsCountIconHeight / 2) - 2;
            var totalErrorsCountIconStartX = x + (width / 2 - config.totalErrorsCountIconWidth / 2);
            this.renderRoundedTriangleWithText(gc, totalErrorsCountIconStartX, totalErrorsCountIconStartY, config.totalErrorsCountIconHeight, config.totalErrorsCountIconWidth, 2, config.columnWarningIconColor, config.renderTotalErrorCount, config.columnWarningFont, config.columnWarningFontColor);
        }

        if (config.showCellContextMenuIcon && renderValue) {
            gc.cache.strokeStyle = config.contextMenuButtonStrokeStyle;
            if (config.contextMenuIconIsHovered) {
                gc.cache.fillStyle = config.contextMenuButtonHoveredFillStyle;
            } else {
                gc.cache.fillStyle = config.contextMenuButtonFillStyle;
            }

            var buttonStartY = y + (height / 2 - config.contextMenuButtonHeight / 2);
            var buttonContentWidth = config.contextMenuButtonIconPreferedWidth + 2 * config.contextMenuButtonPadding;

            var buttonStartX = x + width - config.contextMenuButtonRightMargin - buttonContentWidth;

            this.roundRect(gc, buttonStartX, buttonStartY, buttonContentWidth, config.contextMenuButtonHeight, 1, true);

            var prevFontState = gc.cache.font,
                prevFillStyleState = gc.cache.fillStyle;

            gc.cache.font = config.contextMenuIconFont;

            if (config.contextMenuIconIsHovered) {
                gc.cache.fillStyle = config.contextMenuIconHoveredColor;
            } else {
                gc.cache.fillStyle = config.contextMenuIconColor;
            }

            var configClone = Object.assign({}, config);
            configClone.halign = 'right';

            var iconStartX = x + width - config.contextMenuButtonRightMargin - config.contextMenuButtonPadding - config.contextMenuButtonIconPreferedWidth;
            var iconStartY = buttonStartY + config.contextMenuButtonHeight / 2;

            gc.simpleText(config.contextMenuIconUnicodeChar, iconStartX, iconStartY);

            gc.cache.font = prevFontState;
            gc.cache.fillStyle = prevFillStyleState;

            textRightPadding += buttonContentWidth + config.contextMenuLeftSpaceToCutText;
        }

        if (config.showColumnType && config.colTypeSign) {
            var _prevFontState = gc.cache.font,
                _prevFillStyleState = gc.cache.fillStyle;

            gc.cache.font = config.columnTypeSignFont;
            gc.cache.fillStyle = config.columnTypeSignColor;

            var _configClone = Object.assign({}, config);
            _configClone.halign = 'right';

            textRightPadding += renderSingleLineText(gc, _configClone, config.colTypeSign, leftPadding, textRightPadding);

            gc.cache.font = _prevFontState;
            gc.cache.fillStyle = _prevFillStyleState;
        }

        if (config.valuePrefix && !config.ignoreValuePrefix) {
            var _prevFontState2 = gc.cache.font,
                _prevFillStyleState2 = gc.cache.fillStyle;

            gc.cache.font = config.valuePrefixFont;
            gc.cache.fillStyle = config.valuePrefixColor;

            var oldIgnoreUnderliningState = config.ignoreUnderlining;
            config.ignoreUnderlining = config.prefixIgnoreUnderliningNeeded;
            renderSingleLineText(gc, config, config.valuePrefix, leftPadding, textRightPadding);
            leftPadding += gc.getTextWidth(config.valuePrefix) + config.columnTitlePrefixRightSpace;
            config.ignoreUnderlining = oldIgnoreUnderliningState;

            gc.cache.font = _prevFontState2;
            gc.cache.fillStyle = _prevFillStyleState2;
        }

        if (config.backgroundText) {
            gc.cache.fillStyle = config.backgroundTextColor;
            gc.cache.font = config.backgroundTextFont;

            renderSingleLineText(gc, config, config.backgroundText, leftPadding, textRightPadding);
        }

        if (renderValue) {
            // draw text
            gc.cache.fillStyle = textColor;
            gc.cache.font = textFont;

            valWidth = config.isHeaderRow && config.headerTextWrapping ? renderMultiLineText(gc, config, val, leftPadding, textRightPadding) : renderSingleLineText(gc, config, val, leftPadding, textRightPadding);

            if (config.valuePostfix && !config.ignoreValuePostfix) {
                var newLeftPadding = leftPadding + gc.getTextWidth(val) + config.cellValuePostfixLeftOffset;
                var _oldIgnoreUnderliningState = config.ignoreUnderlining;
                config.ignoreUnderlining = true;
                gc.cache.fillStyle = config.cellValuePostfixColor;
                gc.cache.font = config.cellValuePostfixFont;
                valWidth += renderMultiLineText(gc, config, config.valuePostfix, newLeftPadding, textRightPadding);
                config.ignoreUnderlining = _oldIgnoreUnderliningState;
            }
        } else if (centerIcon) {
            // Measure & draw center icon
            iyoffset = Math.round((height - centerIcon.height) / 2);
            ixoffset = Math.round((width - centerIcon.width) / 2);
            gc.drawImage(centerIcon, x + width - ixoffset - centerIcon.width, y + iyoffset);
            valWidth = iconPadding + centerIcon.width + iconPadding;
        }

        if (leftIcon) {
            // Draw left icon
            iyoffset = Math.round((height - leftIcon.height) / 2);
            gc.drawImage(leftIcon, x + iconPadding, y + iyoffset);
        }

        if (rightIcon) {
            // Repaint background before painting right icon, because text may have flowed under where it will be.
            // This is a work-around to clipping which is too expensive to perform here.
            var rightX = x + width - (rightIcon.width + iconPadding);
            if (inheritsBackgroundColor) {
                foundationColor = true;
                colors.unshift(config.backgroundColor);
            }
            layerColors(gc, colors, rightX, y, rightPadding, height, foundationColor);

            // Draw right icon
            iyoffset = Math.round((height - rightIcon.height) / 2);
            gc.drawImage(rightIcon, rightX, y + iyoffset);
        }

        if (config.cellBorderThickness) {
            gc.beginPath();
            gc.rect(x, y, width, height);
            gc.cache.lineWidth = config.cellBorderThickness;
            gc.cache.strokeStyle = config.cellBorderStyle;
            gc.stroke();
            gc.closePath();
        }

        if (valWidth) {
            config.minWidth = leftPadding + valWidth + rightPadding;
        }
    }
});

/**
 * @summary Renders single line text.
 * @param {CanvasRenderingContext2D} gc
 * @param {object} config
 * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
 * @param {*} val - The text to render in the cell.
 * @memberOf SimpleCell.prototype
 */
function renderMultiLineText(gc, config, val, leftPadding, rightPadding) {
    var x = config.bounds.x,
        y = config.bounds.y,
        width = config.bounds.width,
        height = config.bounds.height,
        cleanVal = (val + '').trim().replace(WHITESPACE, ' '),
        // trim and squeeze whitespace
    lines = findLines(gc, config, cleanVal.split(' '), width);

    if (lines.length === 1) {
        return renderSingleLineText(gc, config, cleanVal, leftPadding, rightPadding);
    }

    var halignOffset = leftPadding,
        valignOffset = config.voffset,
        halign = config.halign,
        textHeight = gc.getTextHeight(config.font).height;

    switch (halign) {
        case 'right':
            halignOffset = width - rightPadding;
            break;
        case 'center':
            halignOffset = width / 2;
            break;
    }

    var hMin = 0,
        vMin = Math.ceil(textHeight / 2);

    valignOffset += Math.ceil((height - (lines.length - 1) * textHeight) / 2);

    halignOffset = Math.max(hMin, halignOffset);
    valignOffset = Math.max(vMin, valignOffset);

    gc.cache.save(); // define a clipping region for cell
    gc.beginPath();
    gc.rect(x, y, width, height);
    gc.clip();

    gc.cache.textAlign = halign;
    gc.cache.textBaseline = 'middle';

    for (var i = 0; i < lines.length; i++) {
        gc.simpleText(lines[i], x + halignOffset, y + valignOffset + i * textHeight);
    }

    gc.cache.restore(); // discard clipping region

    return width;
}

/**
 * @summary Renders single line text.
 * @param {CanvasRenderingContext2D} gc
 * @param {object} config
 * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
 * @param {*} val - The text to render in the cell.
 * @memberOf SimpleCell.prototype
 */
function renderSingleLineText(gc, config, val, leftPadding, rightPadding) {
    var x = config.bounds.x,
        y = config.bounds.y,
        width = config.bounds.width,
        halignOffset = leftPadding,
        halign = config.halign,
        minWidth,
        metrics;

    if (config.columnAutosizing) {
        metrics = gc.getTextWidthTruncated(val, width - leftPadding - rightPadding, config.truncateTextWithEllipsis, config.highlightedChars);
        minWidth = metrics.width + rightPadding;
        val = metrics.string || val;
        switch (halign) {
            case 'right':
                halignOffset = width - rightPadding - metrics.width;
                break;
            case 'center':
                halignOffset = (width - metrics.width) / 2;
                break;
        }
    } else {
        metrics = gc.getTextWidthTruncated(val, width - leftPadding - rightPadding, config.truncateTextWithEllipsis, config.highlightedChars, true);
        minWidth = 0 + rightPadding;
        if (metrics.string !== undefined) {
            val = metrics.string;
        } else {
            switch (halign) {
                case 'right':
                    halignOffset = width - rightPadding - metrics.width;
                    break;
                case 'center':
                    halignOffset = (width - metrics.width) / 2;
                    break;
            }
        }
    }

    if (val !== null) {
        x += Math.max(leftPadding, halignOffset);
        y += config.bounds.height / 2;

        if (metrics.highlights.length > 0) {
            var fillStyleOld = gc.cache.fillStyle;
            gc.cache.fillStyle = config.highlightColor;
            metrics.highlights.forEach(function (h) {
                return gc.fillRect(x + h.x, config.bounds.y, h.width, config.bounds.height);
            });
            gc.cache.fillStyle = fillStyleOld;
        }

        if (config.isUserDataArea) {
            var isAggregationHighlightingNeeded = !config.isGrandTotalRow && config.isAggregationTreeColumn && config.isAggregationRow && config.aggregationChildCount > 0;
            if (config.link || isAggregationHighlightingNeeded && !config.ignoreUnderlining) {
                if (config.isCellHovered || !config.linkOnHover) {
                    if (config.linkColor) {
                        gc.cache.strokeStyle = config.linkColor;
                    }
                    gc.beginPath();
                    underline(config, gc, val, x, y, 1);
                    gc.stroke();
                    gc.closePath();
                }
                if (config.linkColor && (config.isCellHovered || !config.linkColorOnHover)) {
                    gc.cache.fillStyle = config.linkColor;
                }
            }

            if (config.strikeThrough === true) {
                gc.beginPath();
                strikeThrough(config, gc, val, x, y, 1);
                gc.stroke();
                gc.closePath();
            }
        }

        gc.cache.textAlign = 'left';
        gc.cache.textBaseline = 'middle';
        gc.simpleText(val, x, y);
    }

    return minWidth;
}

function findLines(gc, config, words, width) {

    if (words.length === 1) {
        return words;
    }

    // starting with just the first word...
    var stillFits,
        line = [words.shift()];
    while (
    // so lone as line still fits within current column...
    (stillFits = gc.getTextWidth(line.join(' ')) < width) &&
    // ...AND there are more words available...
    words.length) {
        // ...add another word to end of line and retest
        line.push(words.shift());
    }

    if (!stillFits // if line is now too long...
    && line.length > 1 // ...AND is multiple words...
    ) {
            words.unshift(line.pop()); // ...back off by (i.e., remove) one word
        }

    line = [line.join(' ')];

    if (words.length) {
        // if there's anything left...
        line = line.concat(findLines(gc, config, words, width)); // ...break it up as well
    }

    return line;
}

function strikeThrough(config, gc, text, x, y, thickness) {
    var textWidth = gc.getTextWidth(text);

    switch (gc.cache.textAlign) {
        case 'center':
            x -= textWidth / 2;
            break;
        case 'right':
            x -= textWidth;
            break;
    }

    y = Math.round(y + 0.5) - 0.5;

    gc.cache.lineWidth = thickness;
    gc.moveTo(x - 1, y);
    gc.lineTo(x + textWidth + 1, y);
}

function underline(config, gc, text, x, y, thickness) {
    var textHeight = gc.getTextHeight(config.font).height,
        textWidth = gc.getTextWidth(text);

    switch (gc.cache.textAlign) {
        case 'center':
            x -= textWidth / 2;
            break;
        case 'right':
            x -= textWidth;
            break;
    }

    y = Math.round(y + textHeight / 2) - 0.5;

    //gc.beginPath();
    gc.cache.lineWidth = thickness;
    gc.moveTo(x, y);
    gc.lineTo(x + textWidth, y);
}

function layerColors(gc, colors, x, y, width, height, foundationColor) {
    for (var i = 0; i < colors.length; i++) {
        if (foundationColor && !i) {
            gc.clearFill(x, y, width, height, colors[i]);
        } else {
            gc.cache.fillStyle = colors[i];
            gc.fillRect(x, y, width, height);
        }
    }
}

module.exports = SimpleCell;

},{"../../images":3,"./CellRenderer":54}],58:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * Renders a slider button.
 * Currently however the user cannot interact with it.
 * @constructor
 * @extends CellRenderer
 */
var Slider = CellRenderer.extend('Slider', {
    paint: function paint(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;
        gc.cache.strokeStyle = 'white';
        var val = config.value;
        var radius = height / 2;
        var offset = width * val;
        var bgColor = config.isSelected ? config.backgroundColor : '#333333';
        var btnGradient = gc.createLinearGradient(x, y, x, y + height);
        btnGradient.addColorStop(0, bgColor);
        btnGradient.addColorStop(1, '#666666');
        var arcGradient = gc.createLinearGradient(x, y, x, y + height);
        arcGradient.addColorStop(0, '#aaaaaa');
        arcGradient.addColorStop(1, '#777777');
        gc.cache.fillStyle = btnGradient;
        this.roundRect(gc, x, y, width, height, radius, btnGradient);
        if (val < 1.0) {
            gc.cache.fillStyle = arcGradient;
        } else {
            gc.cache.fillStyle = '#eeeeee';
        }
        gc.beginPath();
        gc.arc(x + Math.max(offset - radius, radius), y + radius, radius, 0, 2 * Math.PI);
        gc.fill();
        gc.closePath();
        config.minWidth = 100;
    }
});

module.exports = Slider;

},{"./CellRenderer":54}],59:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * Renders a bar chart sparkline, hence the name.
 * @constructor
 * @extends CellRenderer
 */
var SparkBar = CellRenderer.extend('SparkBar', {
    paint: function paint(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;

        gc.beginPath();
        var val = config.value;
        if (!val || !val.length) {
            return;
        }
        var count = val.length;
        var eWidth = width / count;
        var fgColor = config.isSelected ? config.foregroundSelectionColor : config.color;
        if (config.backgroundColor || config.isSelected) {
            gc.cache.fillStyle = config.isSelected ? 'blue' : config.backgroundColor;
            gc.fillRect(x, y, width, height);
        }
        gc.cache.fillStyle = fgColor;
        for (var i = 0; i < val.length; i++) {
            var barheight = val[i] / 110 * height;
            gc.fillRect(x + 5, y + height - barheight, eWidth * 0.6666, barheight);
            x += eWidth;
        }
        gc.closePath();
        config.minWidth = count * 10;
    }
});

module.exports = SparkBar;

},{"./CellRenderer":54}],60:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * Renders a sparkline.
 * @see [Edward Tufte sparkline](http://www.edwardtufte.com/bboard/q-and-a-fetch-msg?msg_id=0001OR)
 * @constructor
 * @extends CellRenderer
 */
var SparkLine = CellRenderer.extend('SparkLine', {
    paint: function paint(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;

        gc.beginPath();
        var val = config.value;
        if (!val || !val.length) {
            return;
        }
        var count = val.length;
        var eWidth = width / count;

        var fgColor = config.isSelected ? config.foregroundSelectionColor : config.color;
        if (config.backgroundColor || config.isSelected) {
            gc.cache.fillStyle = config.isSelected ? config.backgroundSelectionColor : config.backgroundColor;
            gc.fillRect(x, y, width, height);
        }
        gc.cache.strokeStyle = fgColor;
        gc.cache.fillStyle = fgColor;
        gc.beginPath();
        var prev;
        for (var i = 0; i < val.length; i++) {
            var barheight = val[i] / 110 * height;
            if (!prev) {
                prev = barheight;
            }
            gc.lineTo(x + 5, y + height - barheight);
            gc.arc(x + 5, y + height - barheight, 1, 0, 2 * Math.PI, false);
            x += eWidth;
        }
        config.minWidth = count * 10;
        gc.stroke();
        gc.closePath();
    }
});

module.exports = SparkLine;

},{"./CellRenderer":54}],61:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * Renders a tree cell (presumably in the tree column).
 * @constructor
 * @extends CellRenderer
 */
var TreeCell = CellRenderer.extend('TreeCell', {
    paint: function paint(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            val = config.value.data,
            indent = config.value.indent,
            icon = config.value.icon;

        // Fill background only if our bgColor is populated or we are a selected cell.
        if (config.backgroundColor || config.isSelected) {
            gc.cache.fillStyle = config.isSelected ? config.backgroundColor : config.backgroundColor;
            gc.fillRect(x, y, config.bounds.width, config.bounds.height);
        }

        if (!val || !val.length) {
            return;
        }

        gc.cache.fillStyle = config.isSelected ? config.backgroundColor : config.backgroundColor;

        var valignOffset = Math.ceil(config.bounds.height / 2);
        gc.simpleText(icon + val, x + indent, y + valignOffset);

        config.minWidth = x + indent + gc.getTextWidth(icon + val) + 10;
    }
});

module.exports = TreeCell;

},{"./CellRenderer":54}],62:[function(require,module,exports){
'use strict';

var Registry = require('../lib/Registry');

var warnedBaseClass;

/**
 * @classdesc Registry of cell renderer singletons.
 * @constructor
 */
var CellRenderers = Registry.extend('CellRenderers', {

    BaseClass: require('./CellRenderer'), // abstract base class

    initialize: function initialize() {
        // preregister the standard cell renderers
        this.add(require('./Button'));
        this.add(require('./SimpleCell'));
        this.add(require('./SliderCell'));
        this.add(require('./SparkBar'));
        this.add(require('./LastSelection'));
        this.add(require('./SparkLine'));
        this.add(require('./ErrorCell'));
        this.add(require('./TreeCell'));
    },

    // for better performance, instantiate at add time rather than render time.
    add: function add(name, Constructor) {
        Constructor = Registry.prototype.add.call(this, name, Constructor);

        if (Constructor) {
            this[Constructor.getClassName()] = new Constructor();
        }
    },

    get: function get(name) {
        if (name && name.toLowerCase() === 'emptycell') {
            if (!warnedBaseClass) {
                console.warn('grid.cellRenderers.get("' + name + '").constructor has been deprecated as of v2.1.0 in favor of grid.cellRenderers.BaseClass property. (Will be removed in a future release.)');
                warnedBaseClass = true;
            }
            this.BaseClass.constructor = this.BaseClass;
            return this.BaseClass;
        }
        return Registry.prototype.get.call(this, name);
    }

});

module.exports = new CellRenderers();

},{"../lib/Registry":90,"./Button":53,"./CellRenderer":54,"./ErrorCell":55,"./LastSelection":56,"./SimpleCell":57,"./SliderCell":58,"./SparkBar":59,"./SparkLine":60,"./TreeCell":61}],63:[function(require,module,exports){
'use strict';

var DataSourceBase = require('../DatasaurBase');

/**
 * @implements dataModelAPI
 * @param {Hypergrid} grid
 * @param {object} [options]
 * @param {string} [options.name]
 * @constructor
 */
var HeaderSubgrid = DataSourceBase.extend('HeaderSubgrid', {
    type: 'header',

    format: 'header', // override column format

    initialize: function initialize(nextDataSource, options) {
        this.grid = options.grid;
    },

    getRowCount: function getRowCount() {
        return this.grid.properties.showHeaderRow ? 1 : 0;
    },

    getValue: function getValue(x, y) {
        var column = this.grid.behavior.getColumn(x);
        return column.header || column.name; // use field name when header undefined
    },

    setValue: function setValue(x, y, value) {
        if (y < this.getRowCount()) {
            this.grid.behavior.getColumn(x).header = value;
        }
    },

    getRow: function getRow(y) {
        return this.dataRow;
    }
});

module.exports = HeaderSubgrid;

},{"../DatasaurBase":18}],64:[function(require,module,exports){
'use strict';

var Registry = require('../lib/Registry');

/**
 * @classdesc Registry of cell editor constructors.
 * @param {object} options
 * @constructor
 */
var DataModels = Registry.extend('DataModels', {

    BaseClass: require('../DatasaurBase'),

    initialize: function initialize() {
        // preregister the standard cell editors
        this.add(require('./HeaderSubgrid'));
    }

});

module.exports = new DataModels();

},{"../DatasaurBase":18,"../lib/Registry":90,"./HeaderSubgrid":63}],65:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var HypergridError = require('./lib/error');

var propClassEnum = {
  COLUMNS: 1,
  STRIPES: 2,
  ROWS: 3,
  CELLS: 4
};

var propClassLayersMap = {
  DEFAULT: [propClassEnum.COLUMNS, propClassEnum.STRIPES, propClassEnum.ROWS, propClassEnum.CELLS],
  NO_ROWS: [propClassEnum.CELLS]
};

/**
 * This module lists the properties that can be set on a {@link Hypergrid} along with their default values.
 * Edit this file to override the defaults.
 * @module defaults
 */

var defaults = {

  /**
   * @summary The global theme name.
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  themeName: 'default',

  /**
   * The default message to display in front of the canvas when there are no grid rows.
   * Format is HTML.
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  noDataMessage: '',

  /**
   * @desc If true, first row will be used to render headers
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  useHeaders: true,

  /**
   * @desc If true, cells, that contains only url will be displayed as a link
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  detectLinksPermanently: true,

  /**
   * @desc Contains count of rows, that currently used as a headers
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  fictiveHeaderRowsCount: 0,

  /**
   * @summary List of subgrids by
   * @desc Restrict usage here to strings (naming data models) or arrays consisting of such a string + constructor arguments. That is, avoid {@link subgridSpec}'s function and object overloads and {@link subgridConstructorRef} function overload.
   * @default "[ 'HeaderSubgrid', 'data' ]"
   * @type {subgridSpec[]}
   * @memberOf module:defaults
   */
  subgrids: ['HeaderSubgrid', 'data'],

  /**
   * The font for data cells.
   * @default
   * @type {cssFont}
   * @memberOf module:defaults
   */
  font: '13px "Helvetica Neue",Helvetica,Arial,sans-serif',

  /**
   * Font color for data cells.
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  color: '#060606',

  /**
   * Background color for data cells.
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  backgroundColor: '#FFFFFF',

  /**
   * Background color for empty space
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  canvasBackgroundColor: '#F3F3F3',

  /**
   * Font style for selected cell(s).
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  foregroundSelectionFont: '13px "Helvetica Neue",Helvetica,Arial,sans-serif',

  /**
   * Font color for selected cell(s).
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  foregroundSelectionColor: '#060606',
  /**
   * Background color for selected cell(s).
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  backgroundSelectionColor: '#ECF3FF',

  /**
   * Background color for header selected cell(s).
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  backgroundHeaderSelectionColor: '#DDDDDD',

  /**
   * @summary Text color for error cell
   * @description Color for symbol of error, when value described as object with type:"ERROR" field
   * @type {string}
   * @memberOf module:defaults
   */
  errorCellDataColor: '#a94d4dc2',

  disableHoverHighlighting: true,

  /********** SECTION: COLUMN HEADER COLORS **********/

  // IMPORTANT CAVEAT: The code is inconsistent regarding the terminology. Is the "column header" section _the row_ of cells at the top (that act as headers for each column) or is it _the column_ of cells (that act as headers for each row)? Oh my.

  /**
   * @default
   * @type {cssFont}
   * @memberOf module:defaults
   */
  columnHeaderFont: '11px arial,sans-serif',

  /**
   * @summary text style for data row with headers/titles
   * @default
   * @type {cssFont}
   * @memberOf module:defaults
   */
  columnHeaderFontBold: 'bold 13px "Helvetica Neue",Helvetica,Arial,sans-serif',

  /**
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  columnHeaderColor: '#060606',

  /**
   * @summary Font style for selected columns' headers.
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  columnHeaderForegroundSelectionFont: '11px arial,sans-serif',

  /**
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  columnHeaderBackgroundColor: 'rgb(243,243,243)',

  /**
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  columnHeaderForegroundSelectionColor: '#060606',

  /**
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  columnHeaderBackgroundSelectionColor: 'rgba(255, 220, 97, 0.45)',

  /**
   * @summary align of first number column
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  columnHeaderHalign: 'center',

  /**
   * @summary initial width of number column
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  columnHeaderInitWidth: 50,

  /**
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  columnHeaderRenderer: 'SimpleCell',

  /********** SECTION: ROW HEADER COLORS **********/

  /**
   * @default
   * @type {cssFont}
   * @memberOf module:defaults
   */
  rowHeaderFont: '11px arial,sans-serif',

  /**
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  rowHeaderColor: '#060606',

  /**
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  rowHeaderBackgroundColor: 'rgb(243,243,243)',

  /**
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  rowHeaderForegroundSelectionColor: '#060606',

  /**
   * Font style for selected rows' headers.
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  rowHeaderForegroundSelectionFont: '11px arial,sans-serif',

  /**
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  rowHeaderBackgroundSelectionColor: 'rgba(255, 220, 97, 0.45)',
  /**
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  backgroundColor2: 'rgb(201, 201, 201)',

  /********** SECTION: TREE HEADER COLORS **********/

  /**
   * @default
   * @type {cssFont}
   * @memberOf module:defaults
   */
  treeHeaderFont: '12px Tahoma, Geneva, sans-serif',

  /**
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  treeHeaderColor: 'rgb(25, 25, 25)',

  /**
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  treeHeaderBackgroundColor: 'rgb(223, 227, 232)',

  /**
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  treeHeaderForegroundSelectionColor: 'rgb(80, 80, 80)',

  /**
   * Font style for selected rows' headers.
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  treeHeaderForegroundSelectionFont: 'bold 12px Tahoma, Geneva, sans-serif',

  /**
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  treeHeaderBackgroundSelectionColor: 'rgba(255, 220, 97, 0.45)',
  /********** SECTION: FILTER ROW COLORS **********/

  /**
   * @default
   * @type {cssFont}
   * @memberOf module:defaults
   */
  filterFont: '12px Tahoma, Geneva, sans-serif',

  /**
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  filterColor: 'rgb(25, 25, 25)',

  /**
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  filterBackgroundColor: 'white',

  /**
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  filterForegroundSelectionColor: 'rgb(25, 25, 25)',

  /**
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  filterBackgroundSelectionColor: 'rgb(255, 220, 97)',

  /**
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  filterHalign: 'center',

  /**
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  filterRenderer: 'SimpleCell',

  /**
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  filterEditor: 'TextField',

  /**
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  filterable: true,

  /**
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  showFilterRow: false,

  /**
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  voffset: 0,

  /**
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  scrollbarHoverOver: 'visible',

  /**
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  scrollbarHoverOff: 'hidden',

  /**
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  scrollingEnabled: true,

  /**
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  vScrollbarClassPrefix: '',

  /**
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  hScrollbarClassPrefix: '',

  /**
   * @summary limit for initiating scroll end event
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  onScrollEndLimitTrigger: -1,

  /**
   * Horizontal alignment of each cell as interpreted by it's cell renderer.
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  halign: 'left',

  /**
   * Padding to left and right of cell value.
   *
   * NOTE: Right padding may not be visible if column is not sized wide enough.
   *
   * See also {@link module:defaults.iconPadding|iconPadding}.
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  cellPadding: 4,

  cellPaddingRight: 5,

  cellPaddingLeft: 6,

  /**
   * Padding to left and right of cell icons.
   *
   * Overrides {@link module:defaults.cellPadding|cellPadding}:
   * * Left icon + `iconPadding` overrides left {@link module:defaults.cellPddingg|cellPddingg}.
   * * Right icon + `iconPadding` overrides right {@link module:defaults.cellPddingg|cellPddingg}.
   * @see {@link module:defaults.leftIcon|leftIcon}
   * @see {@link module:defaults.centerIcon|centerIcon}
   * @see {@link module:defaults.rightIcon|rightIcon}
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  iconPadding: 3,

  /**
   * @summary Name of image to appear at right of cell.
   * Must be a key from {@link module:images|images}.
   * @desc Used by {@link SimpleCell} cell renderer.
   * @see {@link module:defaults.centerIcon|centerIcon}
   * @see {@link module:defaults.rightIcon|rightIcon}
   * @see {@link module:defaults.iconPadding|iconPadding}
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  leftIcon: undefined,

  /**
   * @summary Name of image to appear at right of cell.
   * Must be a key from {@link module:images|images}.
   * @desc Used by {@link SimpleCell} cell renderer.
   * @see {@link module:defaults.leftIcon|leftIcon}
   * @see {@link module:defaults.rightIcon|rightIcon}
   * @see {@link module:defaults.iconPadding|iconPadding}
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  centerIcon: undefined,

  /**
   * @summary Name of image to appear at right of cell.
   * Must be a key from {@link module:images|images}.
   * @desc Used by {@link SimpleCell} cell renderer.
   * @see {@link module:defaults.leftIcon|leftIcon}
   * @see {@link module:defaults.centerIcon|centerIcon}
   * @see {@link module:defaults.iconPadding|iconPadding}
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  rightIcon: undefined,

  /**
   * @summary showCellContextMenuIcon and showColumnType trigger
   */
  showAdditionalInfo: false,

  /**
   * Set to `true` to render `0` and `false`. Otherwise these value appear as blank cells.
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  renderFalsy: true,

  /**
   * The name of a registered headerify function.
   *
   * If the named headerify function is defined, it is applied to the schema:
   * 1. Whenever the schema changes
   * 2. For each column that does not already have an explicitly defined header
   *
   * When this property does not name a defined headerify function, undefined column headers default to their column names.     *
   *
   * @see lib/headerifiers.js
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  headerify: 'titleize',

  /**
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  gridLinesH: true,

  /**
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  gridLinesV: true,

  /** @type {number}
   * @default
   * @memberOf module:defaults
   * @see {@link module:dynamicPropertyDescriptors.lineWidth}
   */
  gridLinesWidth: 1,

  /** @type {string}
   * @default
   * @memberOf module:defaults
   */
  gridLinesColor: '#dadada',

  /** @type {string}
   * @desc Color of borders, that painted on left side of header part of each column
   * @default
   * @memberOf module:defaults
   */
  gridLinesHeaderColor: '#c1c1c1',

  /**
   * Set canvas's CSS border to this string as well as `gridBorderLeft`, `gridBorderRight`, `gridBorderTop`, and `gridBorderBottom`.
   * If set to `true`, uses current `lineWidth` and `lineColor`.
   * If set to `false`, uses null.
   *
   * Caveat: The use of `grid.canvas.canvas.style.boxSizing = 'border-box'` is _not_ recommended due to
   * the fact that the canvas is squashed slightly to accommodate the border resulting in blurred text.
   *
   * @default
   * @type {boolean|string}
   * @memberOf module:defaults
   */
  gridBorder: true,

  /**
   * Set canvas's left CSS border to this string.
   * If set to `true`, uses current `lineWidth` and `lineColor`.
   * If set to `false`, uses null.
   * @default
   * @type {boolean|string}
   * @memberOf module:defaults
   */
  gridBorderLeft: true,

  /**
   * Set canvas's right CSS border to this string.
   * If set to `true`, uses current `lineWidth` and `lineColor`.
   * If set to `false`, uses null.
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  gridBorderRight: true,

  /**
   * Set canvas's top CSS border to this string.
   * If set to `true`, uses current `lineWidth` and `lineColor`.
   * If set to `false`, uses null.
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  gridBorderTop: false,

  /**
   * Set canvas's bottom CSS border to this string.
   * If set to `true`, uses current `lineWidth` and `lineColor`.
   * If set to `false`, uses null.
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  gridBorderBottom: true,

  /**
   * Define this property to style rule lines between fixed & scolling rows differently from `lineWidth`.
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  fixedLinesHWidth: 6,

  /**
   * Define this property to render just the edges of the lines between fixed & scolling rows, creating a double-line effect. The value is the thickness of the edges. Typical definition would be `1` in tandem with setting `fixedLinesWidth` to `3`.
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  fixedLinesHEdge: undefined, // undefined means no edge effect

  /**
   * Define this property to style rule lines between fixed & scolling rows differently from `lineColor`.
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  fixedLinesHColor: 'rgb(218,223,232)', // ~21% darker than `lineColor` default

  /**
   * Define this property to style rule lines between fixed & scolling columns differently from `lineWidth`.
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  fixedLinesVWidth: 6,

  /**
   * Define this property to render just the edges of the lines between fixed & scolling columns, creating a double-line effect. The value is the thickness of the edges. Typical definition would be `1` in tandem with setting `fixedLinesWidth` to `3`.
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  fixedLinesVEdge: undefined, // undefined means no edge effect

  /**
   * Define this property to style rule lines between fixed & scolling columns differently from `lineColor`.
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  fixedLinesVColor: 'rgb(218,223,232)', // ~21% darker than `lineColor` default

  /**
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  defaultRowHeight: 21,

  /**
   * @summary height parameter for header row
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  defaultHeaderRowHeight: 23,

  /**
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  defaultColumnWidth: 101,

  /**
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  minimumColumnWidth: 30,

  /**
   * @summary global max width of column
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  maximumColumnWidth: 650,

  /**
   * @summary minimal count of rows should be shown
   * @type {number}
   */
  minimumRowCount: 50,

  //for immediate painting, set these values to 0, true respectively

  /**
   * @default FPS fow drawing table
   * @type {number}
   * @memberOf module:defaults
   */
  repaintIntervalRate: 60,

  /**
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  repaintImmediately: false,

  //enable or disable double buffering

  /**
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  useBitBlit: false,

  /**
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  useHiDPI: true,

  /**
   * @summary Mappings for cell navigation keys.
   * @desc Cell navigation is handled in the {@link CellSelection} "feature". This property gives you control over which keypresses the built-in mechanism will respond to.
   *
   * (If this built-in cell selection logic is insufficient for your needs, you can also listen for the various "fin-key" events and carry out more complex operations in your listeners.)
   *
   * The keypress names used here are defined in Canvas.js. Note that all keypresses actually have two names, a normal name and a shifted name. The latter name is used when either **shift** is depressed.
   *
   * The built-in nav keypresses are as follows:
   * * **`UP`** _(up-arrow key)_ - Replace all selections with a single cell, one row up from the last selection.
   * * **`DOWN`** _(down-arrow key)_ - Replace all selections with a single cell, one row down from the last selection.
   * * **`LEFT`** _(left-arrow key)_ - Replace all selections with a single cell, one column to the left of the last selection.
   * * **`RIGHT`** _(right-arrow key)_ - Replace all selections with a single cell, one column to the right of the last selection.
   * * **`UPSHIFT`** _(shift + up-arrow)_ - Extend the last selection up one row.
   * * **`DOWNSHIFT`** _(shift + down-arrow)_ - Extend the last selection down one row.
   * * **`LEFTSHIFT`** _(shift + left-arrow)_ - Extend the last selection left one column.
   * * **`RIGHTSHIFT`** _(shift + right-arrow)_ - Extend the last selection right one column.
   *
   * To alter these or add other mappings see the examples below.
   *
   * A note regarding the other meta keys (**trl**, **option**, and **command**): Although these meta keys can be detected, they do not modify the key names as **shift** does. This is because they are more for system use and generally (with the possibly exception fo **ctrl**) should not be depended upon, as system functions will take priority and your app will never see these key presses.
   *
   * A special accommodation has been made to the {@link module:defaults.editOnKeydown|editOnKeydown} property:
   * * If `editOnKeydown` truthy AND mapped character is an actual (non-white-space) character (as opposed to say **tab** or **return**), then navigation requires **ctrl** key to distinguish between nav and data.
   * * If `editOnKeydown` falsy, the **ctrl** key is ignored.
   *
   * So in the last example, if `editOnKeydown` is ON, then `a` (without **ctrl**) would start editing the cell and **ctrl** + `a` would move the selection one column to the left.
   *
   * @example
   * // To void the above build-ins:
   * navKeyMap: {
   *     UP: undefined,
   *     UPSHIFT: undefined,
   *     DOWN: undefined,
   *     ...
   * }
   *
   * @example
   * // To map alternative nav keypresses to RETURN and TAB (default mapping):
   * navKeyMap: {
   *     RETURN: 'DOWN',
   *     RETURNSHIFT: 'UP',
   *     TAB: 'RIGHT',
   *     TABSHIFT: 'LEFT'
   * }
   *
   * @example
   * // To map alternative nav keypresses to a/w/d/s and extend select to A/W/D/S:
   * navKeyMap: {
   *     a: 'LEFT', A: 'LEFTSHIFT',
   *     w: 'UP', W: 'UPSHIFT',
   *     s: 'DOWN', S: 'DOWNSHIFT',
   *     d: 'RIGHT', D: 'RIGHTSHIFT'
   * }
   *
   * @default
   * @type {object|undefined}
   * @memberOf module:defaults
   */
  navKeyMap: {
    RETURN: 'DOWN',
    RETURNSHIFT: 'UP',
    TAB: 'RIGHT',
    TABSHIFT: 'LEFT'
  },

  /** @summary Validation failure feedback.
   * @desc Validation occurs on {@link CellEditor#stopEditing}, normally called on commit (`TAB`, `ENTER`, or any other keys listed in `navKeyMap`).
   *
   * On successful validation, the value is saved back to the data source and the editor is closed.
   *
   * On validation failure, feedback is shown to the user in the form of an "error effect" possibly followed by an "end effect" containing a detailed explanation.
   *
   * The error effect to use is named in `feedbackEffect
   *
   * The value of this property is the number of times to show the "error effect" on validation failure before showing the detailed explanation.
   *
   * `feedback` may be set to one of:
   * * **`undefined`** - Do not show the error effect or the alert. Just discard the value and close the editor (as if `ESC` had been typed).
   * * **`0`** - Just shows the error feedback effect (see the {@link CellEditor#errorEffect|errorEffect} property).
   * * **`1`** - Shows the error feedback effect followed by the detailed explanation.
   * * `2` or more:
   *   1. Shows the error feedback effect
   *   2. On every `feedback` tries, shows the detailed explanation.
   * @default
   * @type {number|undefined}
   * @memberOf module:defaults
   */
  feedbackCount: 3,

  /**
   * @default
   * @type {{name:string,options:object}|string}
   * @memberOf module:defaults
   */
  feedbackEffect: 'shaker',

  /**
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  readOnly: false,

  /**
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  fixedColumnCount: 0,

  /**
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  fixedRowCount: 0,

  /**
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  rowHeaderHalign: 'center',

  /**
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   * @see {@link module:dynamicPropertyDescriptors.showRowNumbers}
   */
  rowHeaderNumbers: true,

  /**
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   * @see {@link module:dynamicPropertyDescriptors.showRowNumbers}
   */
  rowHeaderCheckboxes: false,

  /**
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  rowHeaderStartDisplayedIndex: 1,

  /**
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  showTreeColumn: true,

  /**
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  treeRenderer: 'SimpleCell',

  /**
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  showHeaderRow: true,

  /** Clicking in a cell "selects" it; it is added to the select region and repainted with "cell selection" colors.
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  cellSelection: true,

  /** Clicking in a column header (top row) "selects" the column; the entire column is added to the select region and repainted with "column selection" colors.
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  columnSelection: true,

  /** Clicking in a row header (leftmost column) "selects" the row; the entire row is added to the select region and repainted with "row selection" colors.
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  rowSelection: true,

  /**
   * @desc If true, fictive header rows will use regular selection rules
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  selectFictiveHeaderCellsAsRegular: true,

  /**
   * @desc If true, Ctrl+[UP/Down] will only goes to very first/last row
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  ignoreDataCellsOnVerticalCtrlSelection: true,

  /**
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  singleRowSelectionMode: false,

  /**
   * @summary Fill color for last selection overlay.
   * @desc The color should be translucent (or transparent). Note that "Partial" grid renderers (such as the {@link paintCellsAsNeeded} renderer) do not draw overlay because it just gets darker and darker for non-updated cells.
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  selectionRegionOverlayColor: 'rgba(160,195,255,.2)', // 'transparent', // 'rgba(0, 0, 48, 0.2)',

  /**
   * @summary Stroke color for last selection overlay.
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  selectionRegionOutlineColor: '#4285F4',

  /**
   * @summary Width of selected region border
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  selectionRegionBorderWidth: 1,

  /**
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  columnAutosizing: true,

  /**
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  rowNumberAutosizing: true,

  /**
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  headerTextWrapping: false,

  /**
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  rowResize: false,

  /* CELL EDITING */

  /**
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  editable: false,

  /**
   * Edit cell on double-click rather than single-click.
   *
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  editOnDoubleClick: true,

  /**
   * Grid-level property.
   * When user presses a "printable" keyboard character _or_ BACKSPACE _or_ DELETE:
   * 1. Activate cell editor on current cell (i.e., origin of most recent selection).
   * 2. If cell editor is a text editor:
   *    1. Replace current value with the character the user typed; or
   *    2. Clear it on BACKSPACE, DELETE, or other invalid character (_e.g._ when user types a letter but the cell editor only accepts digits).
   *
   * > In invoked, user has the option to back out by pressing the ESCAPE key.
   *
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  editOnKeydown: true,

  /**
   * @summary Open cell editor when cell selected via keyboard navigation.
   * @desc Keyboard navigation always includes:
   * 1. The four arrow keys -- but only when there is no active text cell editor open
   * 2. Additional keys mapped to the four directs in {@link module:defaults.navKeyMap}
   *
   * Generally set at the grid level. If set at the column (or cell) level, note that the property pertains to the cell navigated _to,_ not the cell navigated _away from._
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  editOnNextCell: false,

  /* COLUMN SORTING */

  /**
   * Ignore sort handling in feature/ColumnSorting.js.
   * Useful for excluding some columns but not other from participating in sorting.
   *
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  unsortable: false,

  /**
   * Sort column on double-click rather than single-click.
   *
   * Used by:
   * * feature/ColumnSorting.js to decide which event to respond to (if any, see `unsortabe`).
   * * feature/ColumnSelection.js to decide whether or not to wait for double-click.
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  sortOnDoubleClick: true,

  /**
   * **This is a standard property definition for sort plug-in use.
   * It is not referenced in core.**
   *
   * The maximum number of columns that may participate in a multi-column sort (via ctrl-click headers).
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  maxSortColumns: 3,

  /**
   * **This is a standard property definition for sort plug-in use.
   * It is not referenced in core.**
   *
   * Column(s) participating and subsequently hidden still affect sort.
   *
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  sortOnHiddenColumns: true,

  /**
   * @summary Retain row selections.
   * @desc When falsy, row selections are cleared when selecting cells; when truthy, row selections are kept as is when selecting cells.
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  keepRowSelections: false,

  /**
   * @summary Select cell's entire row.
   * @desc When truthy, selecting a cell will also select the entire row it is in, subject to note #1 below.
   *
   * Notes:
   * 1. Ineffectual unless `checkboxOnlyRowSelections` is set to `false`.
   * 2. To allow auto-selection of _multiple rows,_ set `singleRowSelectionMode` to `false`.
   *
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  autoSelectRows: false,

  /**
   * @summary Select cell's entire column.
   * @desc When truthy, selecting a cell will also select the entire column it is in.
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  autoSelectColumns: false,

  /** @summary Name of a formatter for cell text.
   * @desc The default (`undefined`) falls back to `column.type`.
   * The value `null` does no formatting.
   * @default undefined
   * @type {undefined|null|string}
   * @memberOf module:defaults
   * @tutorial localization
   */
  format: undefined,

  /** @summary Name of a cell editor from the {@link module:cellEditors|cellEditors API}..
   * @desc Not editable if named editor is does not exist.
   * @default undefined
   * @type {undefined|null|string}
   * @memberOf module:defaults
   * @tutorial cell-editors
   */
  editor: 'textfield',

  /**
   * Name of cell renderer from the {@link module:cellRenderers|cellRenderers API}.
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  renderer: 'SimpleCell',

  /**
   * Name of grid renderer.
   * Renderer must have been registered.
   * @see {@link Renderer#registerGridRenderer}.
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  gridRenderer: 'by-columns-and-rows',

  /********** HOVER COLORS **********/

  /** @typedef hoverColors
   * @property {boolean} [enable=false] - `false` means not hilite on hover
   * @property {cssColor} backgroundColor - cell, row, or column background color. Alpha channel will be respected and if given will be painted over the cells predetermined color.
   * @property {cssColor} [header.backgroundColor=backgroundColor] - for columns and rows, this is the background color of the column or row "handle" (header rows or columns, respectively). (Not used for cells.)
   */

  /** On mouse hover, whether to repaint the cell background and how.
   * @type {hoverColors}
   * @default '{ enabled: true, background: rgba(160, 160, 40, 0.30) }'
   * @memberOf module:defaults
   */
  hoverCellHighlight: {
    enabled: true,
    backgroundColor: 'rgba(160, 160, 40, 0.45)'
  },

  /** On mouse hover, whether to repaint the row background and how.
   * @type {hoverColors}
   * @default '{ enabled: true, background: rgba(100, 100, 25, 0.15) }'
   * @memberOf module:defaults
   */
  hoverRowHighlight: {
    enabled: false,
    backgroundColor: 'rgba(100, 100, 25, 0.30)'

  },

  /** On mouse hover, whether to repaint the column background and how.
   * @type {hoverColors}
   * @default '{ enabled: true, background: rgba(60, 60, 15, 0.15) }'
   * @memberOf module:defaults
   */
  hoverColumnHighlight: {
    enabled: false,
    backgroundColor: 'rgba(60, 60, 15, 0.15)'
  },

  /** @summary Display cell value as a link (with underline).
   * @desc One of:
   * * `boolean` - No action occurs on click; you would need to attach a 'fin-click' listener to the hypergrid object.
   *   * `true` - Displays the cell as a link.
   *   * _falsy_ - Displays the cell normally.
   * * `string` -  The URL is decorated (see {}) and then opened in a separate window/tab. See also {@link module:defaults.linkTarget|linkTarget}.
   *   * `'*'` - Use the cell value as the URL, ready for decorating (see {CellClick#openLink|openLink)).
   *   * _field name_ - Fetches the string from the named field in the same row, assumed to be a URL ready for decorating. (May contain only alphanumerics and underscore; no spaces or other punctuation.)
   *   * _otherwise_ Assumed to contains a URL ready for decorating.
   * * `function` - A function to execute to get the URL ready for decorating. The function is passed a single parameter, `cellEvent`, from which you can get the field `name`, `dataRow`, _etc._
   * * `Array` - An array to "apply" to {@link https://developer.mozilla.org/docs/Web/API/Window/open window.open} in its entirety. The first element is interpreted as above for `string` or `function`.
   *
   * In the case of `string` or `Array`, the link is further unpacked by {@link module:CellClick.openLink|openLink} and then sent to `grid.windowOpen`.
   *
   * @example
   * // following affect upper-left data cell:
   * grid.behavior.setCellProperty(0, 0, 'https://nytimes.com'); // absolute address using specific protocol
   * grid.behavior.setCellProperty(0, 0, '//nytimes.com'); // absolute address using current protocol
   * grid.behavior.setCellProperty(0, 0, '/page2.com'); // relative to current site
   * grid.behavior.setCellProperty(0, 0, 'mypage.com'); // relative to current page
   * grid.behavior.setCellProperty(0, 0, 'mypage.com?id=%value'); // cell's value will replace %value
   * grid.behavior.setCellProperty(0, 0, ['//www.newyorker.com', 'ny', undefined, true]) // target='ny', replace=true
   * @type {boolean|string|Array}
   * @type {boolean}
   * @default
   * @memberOf module:defaults
   */
  link: false,

  /** @summary The window (or tab) in which to open the link.
   * @desc The default ('_blank'`) will open a new window for every click.
   *
   * To have the first click open a new window and all subsequent clicks reuse that same window, set this to an arbitrary string.
   *
   * Otherwise, specific columns or cells can be set to open their links in their own window by setting the appropriate column's or cell's `linkTarget` property.
   * @default
   * @memberOf module:defaults
   */
  linkTarget: '_blank',

  /** @summary Underline link on hover only.
   * @type {boolean}
   * @default
   * @memberOf module:defaults
   */
  linkOnHover: false,

  /** @summary Color for link.
   * @desc Falsy means defer to foreground color.
   * @type {string}
   * @default
   * @memberOf module:defaults
   */
  linkColor: '#337ab7',

  /** @summary Color for visited link.
   * @desc Falsy means defer to foreground color.
   * @type {string}
   * @default
   * @memberOf module:defaults
   */
  linkVisitedColor: '#337ab7',

  /** @summary Color link on hover only.
   * @type {boolean}
   * @default
   * @memberOf module:defaults
   */
  linkColorOnHover: false,

  /** Display cell font with strike-through line drawn over it.
   * @type {boolean}
   * @default
   * @memberOf module:defaults
   */
  strikeThrough: false,

  /** Allow multiple cell region selections.
   * @type {boolean}
   * @default
   * @memberOf module:defaults
   */
  multipleSelections: true,

  /** @summary Re-render grid at maximum speed.
   * @desc In this mode:
   * * The "dirty" flag, set by calling `grid.repaint()`, is ignored.
   * * `grid.getCanvas().currentFPS` is a measure of the number times the grid is being re-rendered each second.
   * * The Hypergrid renderer gobbles up CPU time even when the grid appears idle (the very scenario `repaint()` is designed to avoid). For this reason, we emphatically advise against shipping applications using this mode.
   * @type {boolean}
   * @default
   * @memberOf module:defaults
   */
  enableContinuousRepaint: false,

  /** @summary Allow user to move columns .
   * @desc Columns can be reordered through either of two interfaces:
   * * Column Dragging feature
   * * behavior.columns API
   * @type {boolean}
   * @default
   * @memberOf module:defaults
   */
  columnsReorderable: true,

  /**
   * @summary keep headers as is, only data columns moving
   */
  onlyDataReorder: true,

  /** @summary Column grab within this number of pixels from top of cell.
   * @type {number}
   * @default
   * @memberOf module:defaults
   */
  columnGrabMargin: 5,

  /** @summary Set up a clipping region around each column before painting cells.
   * @desc One of:
   * * `true` - Clip column.
   * * `false` - Do not clip column.
   * * `null` - Clip iff last active column.
   *
   * Clipping prevents text that overflows to the right of the cell from being rendered.
   * If you can guarantee that none of your text will overflow, turn column clipping off
   * for better performance. If not, you may still be able to get away without clipping.
   * If the background color of the next column is opaque, you don't really need to clip,
   * although text can leak out to the right of the last column. Clipping the last column
   * only can help this but not solve it since the leaked text from (say) the column before
   * the last column could stretch across the entire last column and leak out anyway.
   * The solution to this is to clip the rendered string so at most only a partial character
   * will overflow.
   * @type {boolean|undefined}
   * @default
   * @memberOf module:defaults
   */
  columnClip: false,

  /**
   * @summary Repeating pattern of property overrides for grid rows.
   * @desc Notes:
   * * "Grid row" refers to data rows.
   * * Row index modulo is applied when dereferencing this array. In other words, this array represents a _repeating pattern_ of properties to be applied to the data rows.
   * * For no row properties, specify a falsy value in place of the array.
   * * Do not specify an empty array (will throw an error).
   * * Each element of the array may be either:
   *   * An object containing property overrides to be applied to every cell of the row; or
   *   * A falsy value signifying that there are no row properties for this specific row.
   * * Caveat: Row properties use `Object.assign()` to copy properties and therefore are not as performant as column properties which use prototype chain.
   * * `Object.assign()` is a polyfill in older versions of Chrome (<45) and in all Internet Explorer (through 11).
   * @type {undefined|object[]}
   * @default
   * @memberOf module:defaults
   */
  rowStripes: undefined,

  // for Renderer.prototype.assignProps
  propClassLayers: propClassLayersMap.DEFAULT,

  /**
   * Used to access registered features -- unless behavior has a non-empty `features` property (array of feature contructors).
   */
  features: ['filters', 'contextmenu',
  // 'columnfixation',
  // 'rowfixation',
  'cellselection', 'keypaging', 'columnresizing',
  // 'rowresizing',
  'rowselection', 'columnselection', 'columnmoving', 'columnsorting', 'cellclick', 'cellediting', 'onhover', 'linkdetails', 'warningtooltip'],

  /** @summary How to truncate text.
   * @desc A "quaternary" value, one of:
   * * `undefined` - Text is not truncated.
   * * `true` (default) - Truncate sufficient characters to fit ellipsis if possible. Most acceptable option that avoids need for clipping.
   * * `false` - Truncate *before* last partially visible character. Visibly annoying; semantically jarring.
   * * `null` - Truncate *after* partially visible character. Less visibly annoying; still semantically confusing. Best solution when combined with either column clipping or painting over with next column's background.
   * @type {boolean|null|undefined}
   * @default
   * @memberOf module:defaults
   */
  truncateTextWithEllipsis: true,

  /**
   * @desc If true, colors will be combined on render.
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  combineColors: false,

  /**
   * @desc List of context menu items, just title and callback
   * Params, that can be passed to each item declaration:
   * title | name (HTML string) - title of an menu item
   * action (function) - callback function, that will be called on click
   * isShown (boolean | function) - if passed, each item check this param, before it will be rendered
   * @default
   * @memberOf module:defaults
   */
  cellContextMenu: [{
    name: '<b>Filter</b> to value',
    action: function action(clickEvent, gridEvent) {
      console.log('<b>Filter</b> to value with event', gridEvent);
    }
  }, {
    name: '<b>Exclude</b> this value',
    action: function action(clickEvent, gridEvent) {
      console.log('<b>Exclude</b> this value with event', gridEvent);
    }
  }, {
    name: 'Copy',
    action: function action(clickEvent, gridEvent) {
      gridEvent.grid.api.copySelectedRangeToClipboard(false);
    }
  }, {
    name: 'Copy With Headers',
    action: function action(clickEvent, gridEvent) {
      gridEvent.grid.api.copySelectedRangeToClipboard(true);
    }
  }],

  /**
   * @desc List of header row context menu items, just title and callback
   * Params, that can be passed to each item declaration:
   * title | name (HTML string) - title of an menu item
   * action (function) - callback function, that will be called on click
   * isShown (boolean | function) - if passed, each item check this param, before it will be rendered
   * @default
   * @memberOf module:defaults
   */
  headerContextMenu: [{
    name: 'Rename',
    action: function action(clickEvent, cellEvent) {
      console.log('rename selected', clickEvent, cellEvent);
      cellEvent.grid.onEditorActivate(cellEvent);
    }
  }, {
    name: 'Remove',
    action: function action(clickEvent, cellEvent) {
      console.log('remove selected', clickEvent, cellEvent);
      var grid = cellEvent.grid;
      var colDef = grid.columnDefs;
      var column = cellEvent.column;

      // remove if it isn't removed in 'onRemoveColumn' callback
      grid.getColDefs(column.name).forEach(function (singleColDef) {
        colDef.splice(colDef.indexOf(singleColDef), 1);
      });

      grid.api.setColumnDefs(colDef);
    }
  }],

  /**
   * @desc if true, data cell context menu can be triggered.
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  showCellContextMenu: true,

  /**
   * @desc if true, context menu will be styled used next params (contextMenuHolderStyle, contextMenuListStyle,
   * contextMenuListOptionStyle, contextMenuListOptionHoverStyle, contextMenuListOptionIconStyle,
   * contextMenuListOptionTextStyle, contextMenuListOptionShortcutStyle, contextMenuListOptionPopupPointerStyle)
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  applyContextMenuStyling: true,

  /**
   * @desc style object for div, that renders when contextMenu called. This div contains contextMenuList as a child
   * @default
   * @type {Object}
   * @memberOf module:defaults
   */
  contextMenuHolderStyle: {
    position: 'fixed',
    border: 'none',
    fontSize: '14px',
    zIndex: 2,
    margin: '0 0 0 0',
    fontFamily: '"Helvetica Neue",Helvetica,Arial,sans-serif',
    width: 'auto',
    height: 'auto',
    'white-space': 'nowrap'
  },

  /**
   * @desc style object for div, that represents list of an context menu items
   * @default
   * @type {Object}
   * @memberOf module:defaults
   */
  contextMenuListStyle: {
    padding: '5px 0',
    maxHeight: '290px',
    minWidth: '220px',
    overflow: 'hidden',
    border: '1px solid #ccc',
    backgroundColor: '#fff',
    display: 'flex',
    flexDirection: 'column',
    marginTop: '-1px',
    borderCollapse: 'collapse',
    position: 'relative'
  },

  /**
   * @desc style object for div, that represents single list item of context menu
   * @default
   * @type {Object}
   * @memberOf module:defaults
   */
  contextMenuListOptionStyle: {
    height: '27px',
    fontSize: '13px',
    cursor: 'pointer',
    display: 'flex',
    alignItems: 'center',
    backgroundColor: '#fff'
  },

  /**
   * @desc style object for menu list item div, when in hovered state
   * @default
   * @type {Object}
   * @memberOf module:defaults
   */
  contextMenuListOptionHoverStyle: {
    backgroundColor: '#eee'
  },

  /**
   * @desc style object for part of menu list item, that contains an icon
   * @default
   * @type {Object}
   * @memberOf module:defaults
   */
  contextMenuListOptionIconStyle: {
    width: '30px',
    padding: '2px 4px',
    verticalAlign: 'middle'
  },

  /**
   * @desc style object for part of menu list item, that contains main text
   * @default
   * @type {Object}
   * @memberOf module:defaults
   */
  contextMenuListOptionTextStyle: {
    padding: '2px 4px',
    verticalAlign: 'middle',
    flexGrow: '1'
  },

  /**
   * @desc style object for part of menu list item, that contains an shortcut
   * @default
   * @type {Object}
   * @memberOf module:defaults
   */
  contextMenuListOptionShortcutStyle: {
    padding: '2px 2px 2px 20px',
    verticalAlign: 'middle',
    Width: '0'
  },

  /**
   * @desc style object for part of menu list item, that contains an popup pointer
   * @default
   * @type {Object}
   * @memberOf module:defaults
   */
  contextMenuListOptionPopupPointerStyle: {
    padding: '2px 4px',
    verticalAlign: 'middle',
    width: '30px'
  },

  /**
   * @desc style object horizontal line (separator) that used to separate one items group from another
   * @default
   * @type {Object}
   * @memberOf module:defaults
   */
  contextMenuSeparatorStyle: {
    display: 'block',
    borderTop: '1px solid #E5E5E5',
    margin: '5px 0'
  },

  /**
   * @desc html string, that will be displayed, if menu item has child menu.
   * Property contain whole html tag (not just class) because come iconpacks may use "span"(or any another)
   * tag instead of "i"
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  contextMenuChildMenuArrowIconTag: '<i class="fa fa-caret-right"></i>',

  /**
   * @desc header part color of an column fixation dragger, when dragger state is inactive
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  columnFixationDraggerHeaderInactiveColor: '#BCBCBC',

  /**
   * @desc header part color of an column fixation dragger, when dragger state is hovered
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  columnFixationDraggerHeaderHoveredColor: '#A5C6FE',

  /**
   * @desc header part color of an column fixation dragger, when dragger state is dragging
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  columnFixationDraggerHeaderDraggingColor: '#A5C6FE',

  /**
   * @desc body part color of an column fixation dragger, when dragger state is dragging
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  columnFixationDraggerBodyDraggingColor: '#DBE5F7',

  /**
   * @desc header part color of an column fixation placeholder
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  columnFixationPlaceholderHeaderColor: '#659DFC',

  /**
   * @desc body part color of an column fixation placeholder
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  columnFixationPlaceholderBodyColor: '#AFBBD1',

  /**
   * @desc header part color of an row fixation dragger, when dragger state is inactive
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  rowFixationDraggerHeaderInactiveColor: '#BCBCBC',

  /**
   * @desc header part color of an row fixation dragger, when dragger state is hovered
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  rowFixationDraggerHeaderHoveredColor: '#A5C6FE',

  /**
   * @desc header part color of an row fixation dragger, when dragger state is dragging
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  rowFixationDraggerHeaderDraggingColor: '#A5C6FE',

  /**
   * @desc body part color of an row fixation dragger, when dragger state is dragging
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  rowFixationDraggerBodyDraggingColor: '#DBE5F7',

  /**
   * @desc header part color of an row fixation placeholder
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  rowFixationPlaceholderHeaderColor: '#659DFC',

  /**
   * @desc body part color of an row fixation placeholder
   * @default
   * @type {cssColor}
   * @memberOf module:defaults
   */
  rowFixationPlaceholderBodyColor: '#AFBBD1',

  /**
   * @desc style object of an vertical scrollbar bar
   * @default
   * @type {Object}
   * @memberOf module:defaults
   */
  scrollbarVStyle: {
    width: 13,
    background: '#F8F8F8',
    boxShadow: '0 0 0 #000, 0 0 0 #000, 0 0 0 #000',
    marginTop: 0,
    marginBottom: 0,
    marginRight: -1,
    borderRadius: 0,
    borderStyle: 'solid',
    borderColor: '#d9d9d9',
    borderWidth: '1px'
  },

  /**
   * @desc style object of an horizontal scrollbar bar
   * @default
   * @type {Object}
   * @memberOf module:defaults
   */
  scrollbarHStyle: {
    height: 13,
    border: '1px solid #d9d9d9',
    background: '#F8F8F8',
    boxShadow: '0 0 0 #000, 0 0 0 #000, 0 0 0 #000',
    marginLeft: 0,
    marginRight: 0,
    marginBottom: -1,
    borderRadius: 0
  },

  /**
   * @desc style object of an vertical scrollbar thumb
   * @default
   * @type {Object}
   * @memberOf module:defaults
   */
  scrollbarVThumbStyle: {
    margin: 1,
    width: 9,
    right: 0,
    backgroundColor: '#C7C7C7',
    boxShadow: '0px 0px 0px inset',
    position: 'absolute',
    borderRadius: 0
  },

  /**
   * @desc style object of an horizontal scrollbar thumb
   * @default
   * @type {Object}
   * @memberOf module:defaults
   */
  scrollbarHThumbStyle: {
    margin: 1,
    height: 9,
    bottom: 0,
    backgroundColor: '#C7C7C7',
    boxShadow: '0px 0px 0px inset',
    borderRadius: 0
  },

  /**
   * @desc style object of an horizontal scrollbar underlying div
   * @default
   * @type {Object}
   * @memberOf module:defaults
   */
  scrollbarHMountStyle: {
    position: 'absolute',
    background: '#F8F8F8',
    border: '1px solid #D9D9D9'
  },

  /**
   * @desc style object of an vertical scrollbar underlying div
   * @default
   * @type {Object}
   * @memberOf module:defaults
   */
  scrollbarVMountStyle: {
    position: 'absolute',
    background: '#F8F8F8',
    border: '1px solid #D9D9D9',
    borderTopWidth: '0'
  },

  /**
   * @desc style object of an div, that contains link info
   * @default
   * @type {Object}
   * @memberOf module:defaults
   */
  linkDetailsStyle: {
    cursor: 'pointer',
    display: 'flex',
    flexFlow: 'column',
    position: 'absolute',
    background: '#fcfcfc',
    boxShadow: '0 0 2px 0 rgba(0,0,0,.15), 0 1px 2px 0 rgba(0,0,0,.4)',
    borderRadius: '1px',
    padding: '5px 7px',
    zIndex: 1030,
    fontSize: '13px',
    textDecoration: 'none'
  },

  /**
   * @desc style object of an div, that contains link info, when mouse moved over it
   * @default
   * @type {Object}
   * @memberOf module:defaults
   */
  linkDetailsHoveredStyle: {
    boxShadow: '0 0 2px 0 rgba(0,0,0,.15), 0 2px 2px 0 rgba(0,0,0,.4)'
  },

  /**
   * @desc Maximum length of link, that will be displayed on link details popover.
   * If length of string greater than this value, value will be truncated
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  linkDetailsMaxStringLength: 30,

  /**
   * @desc Link details hide timeout in milliseconds
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  linkDetailsHideTimeout: 1000,

  /**
   * @desc style object of an link info anchor tag
   * @default
   * @type {Object}
   * @memberOf module:defaults
   */
  linkDetailsAnchorStyle: {
    color: '#337ab7',
    textDecoration: 'none',
    lineHeight: '19px',
    fontFamily: 'Arial,sans-serif'
  },

  /**
   * @desc pixels count that will be used as canvas right padding on render
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  canvasWidthOffset: 14,

  /**
   * @desc pixels count that will be used as canvas bottom padding on render
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  canvasHeightOffset: 13,

  /**
   * @desc if true, context menu icon will be shown on every table cell
   * Best use of this parameter is set it on column or row
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  showCellContextMenuIcon: false,

  /**
   * @desc font of context menu icon
   * Best use of this parameter is set font family on one of connected icon-pack's, to render needed icon
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  contextMenuIconFont: 'normal normal lighter 14px fontAwesome',

  /**
   * @desc if true, context menu icon style will be set to hovered
   * (Utility prop. You don't need to set this param in most cases)
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  contextMenuIconIsHovered: false,

  /**
   * @desc Color of context menu icon, when not hovered
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  contextMenuIconColor: '#616161',

  /**
   * @desc Color of context menu icon, when hovered
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  contextMenuIconHoveredColor: '#616161',

  /**
   * @desc Color of context menu button border
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  contextMenuButtonStrokeStyle: '#C6C6C6',

  /**
   * @desc Color of context menu button background color
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  contextMenuButtonFillStyle: '#F8F8F8',

  /**
   * @desc Color of context menu button background color when hovered
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  contextMenuButtonHoveredFillStyle: '#f0f0f0',

  /**
   * @desc String, that will be displayed as context menu icon
   * Best way to use this parameter is set it's value on such unicode char, provided by your icons pack
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  contextMenuIconUnicodeChar: decodeURI('\uF0D7'),

  /**
   * @desc String, that will be displayed as error icon
   * Best way to use this parameter is set it's value on such unicode char, provided by your icons pack
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  errorIconUnicodeChar: decodeURI('\uF071'),

  /**
   * @desc height of icon, that represents total number of errors
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  totalErrorsCountIconHeight: 16,

  /**
   * @desc width of icon, that represents total number of errors
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  totalErrorsCountIconWidth: 18,

  /**
   * @desc font of error icon
   * Best use of this parameter is set font family on one of connected icon-pack's, to render needed icon
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  errorIconFont: '13px fontAwesome',

  /**
   * @desc color of error icon
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  errorIconColor: '#FF3D3D',

  /**
   * @desc Prefered width of button
   * (Utility prop. You don't need to set this param in most cases. Used in context menu feature)
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  contextMenuButtonIconPreferedWidth: 8,

  /**
   * @desc space between cell right border and button
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  contextMenuButtonRightMargin: 5,

  /**
   * @desc context menu button height
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  contextMenuButtonHeight: 12,

  /**
   * @desc space between context menu button content and border
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  contextMenuButtonPadding: 3,

  /**
   * @desc Space from context menu icon to main text of cell
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  contextMenuLeftSpaceToCutText: 5,

  /**
   * @desc Font of column type sign
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  columnTypeSignFont: '900 10px "Helvetica Neue",Helvetica,Arial,sans-serif',

  /**
   * @desc Color of column type sign
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  columnTypeSignColor: '#343434',

  /**
   * @desc Font of column title prefix
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  columnTitlePrefixFont: '800 12px "Helvetica Neue",Helvetica,Arial,sans-serif',

  /**
   * @desc Color of column title prefix
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  columnTitlePrefixColor: '#818181',

  /**
   * @desc Space from context menu icon to main text of cell
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  columnTitlePrefixRightSpace: 5,

  /**
   * @desc Font of text (total number of errors), that rendered inside warning icon
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  columnWarningFont: '1000 9px "Helvetica Neue",Helvetica,Arial,sans-serif',

  /**
   * @desc color of error icon
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  columnWarningFontColor: 'white',

  /**
   * @desc color of total errors icon
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  columnWarningIconColor: '#FF3D3D',

  /**
   * @desc classes of tooltip container when placed at bottom
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  warningTooltipBottomClass: 'tooltip bottom ng-animate in-add fade in main-page-tooltip',

  /**
   * @desc classes of tooltip container when placed at right
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  warningTooltipRightClass: 'tooltip right ng-animate in-add fade in main-page-tooltip',

  /**
   * @desc classes of tooltip-arrow
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  warningTooltipArrowClass: 'tooltip-arrow',

  /**
   * @desc classes of tooltip-inner
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  warningTooltipInnerClass: 'tooltip-inner',

  /**
   * @desc tooltip opacity when visible
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  warningTooltipOpacity: 0.8,

  /**
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  columnMoveInsertLineColor: '#777777',

  /**
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  columnMoveInsertLineWidth: 2,

  /**
   * @desc Color of number, that displays total count of each group while aggregated
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  cellValuePostfixColor: '#8F8F8F',

  /**
   * @desc Font of aggregation total number
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  cellValuePostfixFont: '13px "Helvetica Neue",Helvetica,Arial,sans-serif',

  /**
   * @desc Space between main cell content and postfix
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  cellValuePostfixLeftOffset: 5,

  /**
   * @desc font of aggregation group expand icon
   * Best use of this parameter is set font family on one of connected icon-pack's, to render needed icon
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  aggregationGroupExpandIconFont: 'normal normal lighter 14px fontAwesome',

  /**
   * @desc color of aggregated row expand icon
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  aggregationGroupExpandIconColor: '#9F9F9F',

  /**
   * @desc icon (or text(not recomended)) that will be displayed as expand action trigger
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  aggregationGroupExpandIconExpandedChar: decodeURI('\uF196'),

  /**
   * @desc icon (or text(not recomended)) that will be displayed as collapse action trigger
   * @default
   * @type {string}
   * @memberOf module:defaults
   */
  aggregationGroupExpandIconCollapsedChar: decodeURI('\uF147'),

  /**
   * @desc additional left offset of each tree level.
   * Other words, every child row will be displayed with additional offset
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  aggregationGroupTreeLevelOffset: 17,

  /**
   * @desc width of clickable area, that starts on group expand icon start
   * Utility param. Used to perform clicks on icon
   * @default
   * @type {number}
   * @memberOf module:defaults
   */
  aggregationGroupExpandIconClickableWidth: 15,

  /**
   * font of aggregation grand total
   * @default
   * @type {cssFont}
   * @memberOf module:defaults
   */
  grandAggregationCellFont: 'bold 13px "Helvetica Neue",Helvetica,Arial,sans-serif',

  /**
   * If true, values prefixes will not be rendered even if exist
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  ignoreValuePrefix: false,

  /**
   * If true, values postfixes will not be rendered even if exist
   * @default
   * @type {boolean}
   * @memberOf module:defaults
   */
  ignoreValuePostfix: false,

  /**
   * @summary placeholder for drawing null values
   */
  nullCellPlaceholder: '',

  /**
   * @summary color of placeholder for null values
   */
  nullCellColor: '#d4d4d4',

  /**
   * @summary tag in which wrapped text which needed to highlight, for instance, search result
   */
  highLightText: '',

  /**
   * @summary color for highlight text, for instance, search result
   */
  highlightColor: '#F7FFBA',

  /**
   * @summary value for managing behaviour with aggregated data
   */
  isPivot: false
};

var warned = {};

function rowPropertiesDeprecationWarning() {
  if (!warned.rowProperties) {
    warned.rowProperties = true;
    console.warn('The `rowProperties` property has been deprecated as of v2.1.0 in favor of `rowStripes`. (Will be removed in a future release.)');
  }
}

Object.defineProperties(defaults, {
  rowProperties: {
    get: function get() {
      rowPropertiesDeprecationWarning();
      return this.rowStripes;
    },
    set: function set(rowProperties) {
      rowPropertiesDeprecationWarning();
      this.rowStripes = rowProperties;
    }
  }
});

function columnOnlyError() {
  throw new HypergridError('Attempt to set/get column-only property on a non-column properties object.');
}

['name', 'type', 'header', 'calculator'].forEach(function (key) {
  Object.defineProperty(defaults, key, {
    set: columnOnlyError
  });
});

/** @typedef {string} cssColor
 * @see https://developer.mozilla.org/docs/Web/CSS/color_value
 */

/** @typedef {string} cssFont
 * @see https://developer.mozilla.org/docs/Web/CSS/font
 */

/**
 * Returns any value of `keyChar` that passes the following logic test:
 * 1. If a non-printable, white-space character, then nav key.
 * 2. If not (i.e., a normal character), can still be a nav key if not editing on key down.
 * 3. If not, can still be a nav key if CTRL key is down.
 *
 * Note: Callers are typcially only interested in the following values of `keyChar` and will ignore all others:
 * * `'LEFT'` and `'LEFTSHIFT'`
 * * `'RIGHT'` and `'RIGHTSHIFT'`
 * * `'UP'` and `'UPSHIFT'`
 * * `'DOWN'` and `'DOWNSHIFT'`
 *
 * @param {string} keyChar - A value from Canvas's `charMap`.
 * @param {boolean} [ctrlKey=false] - The CTRL key was down.
 * @returns {undefined|string} `undefined` means not a nav key; otherwise returns `keyChar`.
 * @memberOf module:defaults
 */
function navKey(keyChar, ctrlKey) {
  var result;
  if (keyChar.length > 1 || !this.editOnKeydown || ctrlKey) {
    result = keyChar; // return the mapped value
  }
  return result;
}

/**
 * Returns only values of `keyChar` that, when run through {@link module:defaults.navKeyMap|navKeyMap}, pass the {@link module:defaults.navKey|navKey} logic test.
 *
 * @param {string} keyChar - A value from Canvas's `charMap`, to be remapped through {@link module:defaults.navKeyMap|navKeyMap}.
 * @param {boolean} [ctrlKey=false] - The CTRL key was down.
 * @returns {undefined|string} `undefined` means not a nav key; otherwise returns `keyChar`.
 * @memberOf module:defaults
 */
function mappedNavKey(keyChar, ctrlKey) {
  keyChar = this.navKeyMap[keyChar];
  return keyChar && this.navKey(keyChar);
}

/** @summary Reapply cell properties after `getCell`.
 * @type {boolean}
 * @default
 * @memberOf module:defaults
 */
function reapplyCellProperties(value) {
  if (!warned.reapplyCellProperties) {
    console.warn('The `.reapplyCellProperties` property has been deprecated as of v2.1.3 in favor of using the new `.propClassLayers` property. (May be removed in a future release.) This property is now a setter which sets `.propClassLayers` to `.propClassLayersMap.DEFAULT` (grid  columns  stripes  rows  cells) on truthy or `propClassLayersMap.NO_ROWS` (grid  columns  cells) on falsy, which is what you will see on properties stringification. This will give the same effect in most cases as the former property implementation, but not in all cases due to it no longer being applied dynamically. Developers should discontinue use of this property and start specifying `.propClassLayers` instead.');
    warned.reapplyCellProperties = true;
  }
  this.propClassLayers = value ? propClassLayersMap.NO_ROWS : propClassLayersMap.DEFAULT;
}

function deleteProp(propName) {
  var descriptor = Object.getOwnPropertyDescriptor(this, propName);
  if (!descriptor) {
    return false; // own property not found
  } else if (!descriptor.get) {
    return delete this[propName]; // non-accessor property found (returns !descriptor.configurable)
  } else if (descriptor.get.toString().indexOf('.var.')) {
    this.var[propName] = Object.getPrototypeOf(this)[propName];
  } else {
    return true; // property not deletable
  }
  this.grid.repaint();
  return false; // delete was successful
}

/**
 * @summary Execute value if "calculator" (function) or if column has calculator.
 * @desc This function is referenced here so:
 * 1. It will be available to the cell renderers
 * 2. Its context will naturally be the `config` object
 * @default {@link module:defaults.exec|exec}
 * @method
 * @param vf - Value or function.
 * @memberOf module:defaults
 */
function exec(vf) {
  if (this.dataRow) {
    var calculator = (typeof vf === 'undefined' ? 'undefined' : _typeof(vf))[0] === 'f' && vf || this.calculator;
    if (calculator) {
      vf = calculator(this.dataRow, this.name, this.subrow);
    }
  }
  return vf;
}

// Add non-enumerable "utility" props so they will be available wherever props are available.
Object.defineProperties(defaults, {
  mixIn: { value: require('overrider').mixIn },
  delete: { value: deleteProp },
  propClassEnum: { value: propClassEnum },
  propClassLayersMap: { value: propClassLayersMap },
  navKey: { value: navKey },
  mappedNavKey: { value: mappedNavKey },
  reapplyCellProperties: { set: reapplyCellProperties },
  exec: { value: exec }
});

module.exports = defaults;

},{"./lib/error":95,"overrider":13}],66:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Feature = require('./Feature');

/**
 * @constructor
 * @extends Feature
 */
var CellClick = Feature.extend('CellClick', {
    handleMouseMove: function handleMouseMove(grid, event) {
        this.cursor = this._isMouseOverActiveExpandIcon(grid, event) ? 'pointer' : null;

        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    },

    /**
     * @param {Hypergrid} grid
     * @param {CellEvent} event - the event details
     * @memberOf CellClick#
     */
    handleClick: function handleClick(grid, event) {
        grid.log('event', event);
        var consumed = false;
        if (event.isAggregationColumn && this._isMouseOverExpandIcon(grid, event) && event.isExpandableRow) {
            this._toggleExpandableRow(grid, event);
            consumed = true;
        } else if (this.isAggregationTreeCell(event) && event.isExpandableRow && grid.onAggregatedCellClick) {
            grid.onAggregatedCellClick(event);
        } else if (this._isMouseOverExpandIcon(grid, event) && event.isExpandableColumn) {
            this._toggleExpandableColumn(grid, event);
            consumed = true;
        } else {
            consumed = (event.isDataCell || event.isTreeColumn) && (this.openLink(grid, event) !== undefined || grid.behavior.cellClicked(event));
        }

        if (!consumed && this.next) {
            this.next.handleClick(grid, event);
        }
    },

    /**
     * @memberOf CellEditing.prototype
     * @param {Hypergrid} grid
     * @param {CellEvent} event - the event details
     */
    handleDoubleClick: function handleDoubleClick(grid, event) {
        // used to disable event propagation
        if (this._isMouseOverActiveExpandIcon(grid, event)) {
            return;
        }

        if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @private
     * @param {Hypergrid} grid
     * @param {CellEvent} event
     * @private
     */
    _toggleExpandableRow: function _toggleExpandableRow(grid, event) {
        if (!event.isRowExpanded) {
            grid.behavior.expandChildRows(event.dataRow);
        } else {
            grid.behavior.collapseChildRows(event.dataRow);
        }
    },

    /**
     * @private
     * @param {Hypergrid} grid
     * @param {CellEvent} event
     * @private
     */
    _toggleExpandableColumn: function _toggleExpandableColumn(grid, event) {
        if (!event.isColumnExpanded) {
            grid.behavior.expandChildColumns(event.columnGroupId);
        } else {
            grid.behavior.collapseChildColumns(event.columnGroupId);
        }
    },

    /**
     * @desc shows is cell represent aggregation data summary
     * @param {CellEvent} event - the event details
     * @memberOf CellClick#
     */
    isAggregationTreeCell: function isAggregationTreeCell(event) {
        var isAggregationTreeColumn = event.isAggregationTreeColumn,
            isAggregationRow = event.isAggregationRow,
            aggregationChildCount = event.aggregationChildCount,
            aggregationGrandTotalRow = event.isGrandTotalRow;

        return isAggregationTreeColumn && isAggregationRow && aggregationChildCount > 0 && !aggregationGrandTotalRow;
    },

    /**
     * @desc utility function to detect if cursor over expand/collapse button
     * @param {Hypergrid} grid
     * @param {CellEvent} event
     * @memberOf CellClick#
     */
    _isMouseOverExpandIcon: function _isMouseOverExpandIcon(grid, event) {
        if (!event.isExpandableRow && !event.isExpandableColumn || event.isRenderSkipNeeded) {
            return false;
        }

        var iconLeftX = event.properties.cellPaddingLeft + event.treeLevel * event.properties.aggregationGroupTreeLevelOffset;
        var iconRightX = iconLeftX + event.properties.aggregationGroupExpandIconClickableWidth;

        var iconTopY = 5;
        var iconBottomY = event.bounds.height - 5;

        return event.mousePoint.x <= iconRightX && event.mousePoint.x >= 0 && event.mousePoint.y <= iconBottomY && event.mousePoint.y >= iconTopY;
    },

    /**
     * @desc utility function to detect if cursor over expand/collapse button, that can be clicked because of various factors
     * @param {Hypergrid} grid
     * @param {CellEvent} event
     * @memberOf CellClick#
     */
    _isMouseOverActiveExpandIcon: function _isMouseOverActiveExpandIcon(grid, event) {
        return (event.isAggregationColumn && event.isExpandableRow || this.isAggregationTreeCell(event) || event.isExpandableColumn) && this._isMouseOverExpandIcon(grid, event);
    },

    /**
     * @summary Open the cell's URL.
     *
     * @desc The URL is found in the cell's {@link module:defaults.link|link} property, which serves two functions:
     * 1. **Renders as a link.** When truthy causes {@link SimpleCell} cell renderer to render the cell underlined with {@link module:defaults.linkColor|linkColor}. (See also {@link module:defaults.linkOnHover|linkOnHover} and {@link module:defaults.linkColorOnHover|linkColorOnHover}.) Therefore, setting this property to `true` will render as a link, although clicking on it will have no effect. This is useful if you wish to handle the click yourself by attaching a `'fin-click'` listener to your hypergrid.
     * 2. **Fetch the URL.** The value of the link property is interpreted as per {@link module:defaults.link|link}.
     * 3. **Decorate the URL.** The cell name (_i.e.,_ the data column name) and cell value are merged into the URL wherever the respective substrings `'%name'` and `'%value'` are found. For example, if the column name is "age" and the cell value is 6 (or a function returning 25), and the link is `'http://www.abc.com?%name=%value'`, then the actual link (first argument given to `grid.windowOpen`) would be `'http://www.abc.com?age=25'`.
     * 4. **Open the URL.** The link is then opened by {@link Hypergrid#windowOpen|grid.windowOpen}. If `link` is an array, it is "applied" to `grid.windowOpen` in its entirety; otherwise, `grid.windowOpen` is called with the link as the first argument and {@link module:defaults.linkTarget|linkTarget} as the second.
     * 5. **Decorate the link.** On successful return from `windowOpen()`, the text is colored as "visited" as per the cell's {@link module:defaults.linkVisitedColor|linkVisitedColor} property (by setting the cell's `linkColor` property to its `linkVisitedColor` property).
      * @param {Hypergrid} grid
     * @param {CellEvent} cellEvent - Event details.
     *
     * @returns {boolean|window|null|undefined} One of:
     *
     * | Value | Meaning |
     * | :---- | :------ |
     * | `undefined` | no link to open |
     * | `null` | `grid.windowOpen` failed to open a window |
     * | _otherwise_ | A `window` reference returned by a successful call to `grid.windowOpen`. |
     *
     * @memberOf CellClick#
     */
    openLink: function openLink(grid, cellEvent) {
        var result,
            url,
            dataRow = cellEvent.dataRow,
            config = Object.create(cellEvent.properties, { dataRow: { value: dataRow } }),
            value = config.exec(cellEvent.value),
            linkProp = cellEvent.properties.link,
            isArray = linkProp instanceof Array,
            link = isArray ? linkProp[0] : linkProp;

        // STEP 2: Fetch the URL
        switch (typeof link === 'undefined' ? 'undefined' : _typeof(link)) {
            case 'string':
                if (link === '*') {
                    url = value;
                } else if (/^\w+$/.test(link)) {
                    url = dataRow[link];
                }
                break;

            case 'function':
                url = link(cellEvent);
                break;
        }

        if (url) {
            // STEP 3: Decorate the URL
            url = url.toString().replace(/%name/g, config.name).replace(/%value/g, value);

            // STEP 4: Open the URL
            if (isArray) {
                linkProp = linkProp.slice();
                linkProp[0] = url;
                result = grid.windowOpen.apply(grid, linkProp);
            } else {
                result = grid.windowOpen(url, cellEvent.properties.linkTarget);
            }
        }

        // STEP 5: Decorate the link as "visited"
        if (result) {
            cellEvent.setCellProperty('linkColor', grid.properties.linkVisitedColor);
            grid.renderer.resetCellPropertiesCache(cellEvent);
            grid.repaint();
        }

        return result;
    }

});

module.exports = CellClick;

},{"./Feature":75}],67:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');
var CellEditor = require('../cellEditors/CellEditor');

/**
 * @constructor
 * @extends Feature
 */
var CellEditing = Feature.extend('CellEditing', {

    /**
     * @memberOf CellEditing.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleClick: function handleClick(grid, event) {
        edit.call(this, grid, event);
    },

    /**
     * @memberOf CellEditing.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDoubleClick: function handleDoubleClick(grid, event) {
        edit.call(this, grid, event, true);
    },

    /**
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf KeyPaging.prototype
     */
    handleKeyDown: function handleKeyDown(grid, event) {
        var char, isVisibleChar, isDeleteChar, editor, cellEvent;

        if ((cellEvent = grid.getGridCellFromLastSelection()) && cellEvent.properties.editOnKeydown && !grid.cellEditor && ((char = event.detail.char) === 'F2' || (isVisibleChar = char.length === 1 && !(event.detail.meta || event.detail.ctrl)) || (isDeleteChar = char === 'DELETE' || char === 'BACKSPACE'))) {
            var neededVisibilityProp = cellEvent.isDataRow ? 'editable' : 'filterable';
            var isEditable = cellEvent.rowProperties[neededVisibilityProp] || cellEvent.properties[neededVisibilityProp];
            if (isEditable) {
                editor = grid.onEditorActivate(cellEvent);

                if (editor instanceof CellEditor) {

                    if (isVisibleChar) {
                        editor.input.value = char;
                    } else if (isDeleteChar) {
                        editor.setEditorValue('');
                    }
                }
                event.detail.primitiveEvent.preventDefault();
            }
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    }

});

function edit(grid, event, onDoubleClick) {
    if (event.isDataCell && !(event.getCellProperty('editOnDoubleClick') ^ onDoubleClick) // both same (true or falsy)?
    ) {
            grid.onEditorActivate(event);
        }

    if (this.next) {
        this.next[onDoubleClick ? 'handleDoubleClick' : 'handleClick'](grid, event);
    }
}

module.exports = CellEditing;

},{"../cellEditors/CellEditor":45,"./Feature":75}],68:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 * @extends Feature
 */
var CellSelection = Feature.extend('CellSelection', {

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {Point}
     * @memberOf CellSelection.prototype
     */
    currentDrag: null,

    /**
     * the cell coordinates of the where the mouse pointer is during a drag operation
     * @type {Object}
     * @memberOf CellSelection.prototype
     */
    lastDragCell: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf CellSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf CellSelection.prototype
     */
    sbAutoStart: 0,

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function handleMouseUp(grid, event) {
        if (this.dragging) {
            this.dragging = false;
        }
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function handleMouseDown(grid, event) {
        var dx = void 0,
            dy = void 0;
        grid.behavior.getHeaderColumnByName();
        if (event.isColspanedByLeftColumn && event.colspanMainColumnName) {
            var mainColumn = grid.behavior.getHeaderColumnByName(event.colspanMainColumnName);
            var mainColumnIndex = grid.behavior.columns.indexOf(mainColumn);

            if (mainColumn && mainColumnIndex) {
                dx = mainColumnIndex;
            }
        } else if (event.rowspanMainRow !== undefined && event.rowspanMainRow !== null) {
            dy = event.rowspanMainRow;
        }

        dx = dx !== undefined ? dx : event.dataCell.x;
        dy = dy !== undefined ? dy : event.dataCell.y;
        var isSelectable = grid.behavior.getCellProperty(dx, dy, 'cellSelection');

        if (isSelectable && event.isDataCell) {
            if (event.primitiveEvent.detail.isRightClick && event.isCellSelected) {
                return;
            }
            var dCell = grid.newPoint(dx, dy),
                primEvent = event.primitiveEvent,
                keys = primEvent.detail.keys;
            this.dragging = true;
            this.extendSelection(grid, dCell, keys);
        }

        if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function handleMouseDrag(grid, event) {
        if (this.dragging && grid.properties.cellSelection && !event.primitiveEvent.detail.isRightClick) {
            this.currentDrag = event.primitiveEvent.detail.mouse;
            this.lastDragCell = grid.newPoint(event.gridCell.x, event.dataCell.y);
            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, this.lastDragCell, event.primitiveEvent.detail.keys);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function handleKeyDown(grid, event) {
        var cellEvent = grid.getGridCellFromLastSelection(true);
        var detail = event.detail,
            keys = detail.currentKeys;
        var ctrlPressed = event.metaKey || event.ctrlKey || keys.indexOf('CTRL') >= 0 || keys.indexOf('COMMANDLEFT') >= 0 || keys.indexOf('COMMANDRIGHT') >= 0;
        var navKey = cellEvent && (cellEvent.properties.mappedNavKey(detail.char, ctrlPressed) || cellEvent.properties.navKey(detail.char, ctrlPressed));

        var handler = ctrlPressed && this['handleCTRL' + navKey] ? this['handleCTRL' + navKey] : this['handle' + navKey];

        // STEP 1: Move the selection
        if (handler) {
            handler.call(this, grid, detail);

            // STEP 2: Open the cell editor at the new position if it has `editOnNextCell` and is `editable`
            cellEvent = grid.getGridCellFromLastSelection(true); // new cell
            if (cellEvent.properties.editOnNextCell) {
                grid.editAt(cellEvent); // succeeds only if `editable`
            }

            // STEP 3: If editor not opened on new cell, take focus
            if (!grid.cellEditor) {
                grid.takeFocus();
            }

            if (event.detail.sourceEvent && event.detail.sourceEvent.preventDefault) {
                event.detail.sourceEvent.preventDefault();
            }
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle a mousedrag selection.
     * @param {Hypergrid} grid
     * @param {Object} gridCell - grid cell
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function handleMouseDragCellSelection(grid, gridCell, keys) {
        var x = Math.max(0, gridCell.x),
            y = Math.max(0, gridCell.y),
            previousDragExtent = grid.getDragExtent(),
            mouseDown = grid.getMouseDown(),
            newX = x - mouseDown.x,
            newY = y - mouseDown.y;

        if (previousDragExtent.x === newX && previousDragExtent.y === newY) {
            return;
        }

        grid.clearMostRecentSelection();

        grid.select(mouseDown.x, mouseDown.y, newX, newY);
        grid.setDragExtent(grid.newPoint(newX, newY));

        grid.repaint();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function checkDragScroll(grid, mouse) {
        if (!grid.properties.scrollingEnabled) {
            return;
        }
        var b = grid.getDataBounds();
        var inside = b.contains(mouse);
        if (inside) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else if (!grid.isScrollingNow()) {
            grid.setScrollingNow(true);
            this.scrollDrag(grid);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we scroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function scrollDrag(grid) {
        if (!grid.isScrollingNow()) {
            return;
        }

        var lastDragCell = this.lastDragCell,
            b = grid.getDataBounds(),
            xOffset = 0,
            yOffset = 0,
            numFixedColumns = grid.getFixedColumnCount(),
            numFixedRows = grid.getFixedRowCount(),
            dragEndInFixedAreaX = lastDragCell.x < numFixedColumns,
            dragEndInFixedAreaY = lastDragCell.y < numFixedRows;

        if (this.currentDrag.x < b.origin.x) {
            xOffset = -1;
        }
        if (this.currentDrag.y < b.origin.y) {
            yOffset = -1;
        }

        if (this.currentDrag.x > b.origin.x + b.extent.x) {
            xOffset = 1;
        }
        if (this.currentDrag.y > b.origin.y + b.extent.y) {
            yOffset = 1;
        }

        var dragCellOffsetX = xOffset;
        var dragCellOffsetY = yOffset;

        if (dragEndInFixedAreaX) {
            dragCellOffsetX = 0;
        }
        if (dragEndInFixedAreaY) {
            dragCellOffsetY = 0;
        }

        this.lastDragCell = lastDragCell.plusXY(dragCellOffsetX, dragCellOffsetY);
        grid.scrollBy(xOffset, yOffset);
        this.handleMouseDragCellSelection(grid, lastDragCell, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} dataCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function extendSelection(grid, dataCell, keys) {
        var hasCTRL = keys.indexOf('CTRL') >= 0 || keys.indexOf('COMMANDLEFT') >= 0 || keys.indexOf('COMMANDRIGHT') >= 0,
            hasSHIFT = keys.indexOf('SHIFT') >= 0,
            mousePoint = grid.getMouseDown(),
            x = dataCell.x,
            // - numFixedColumns + scrollLeft;
        y = dataCell.y; // - numFixedRows + scrollTop;

        //were outside of the grid do nothing
        if (x < 0 || y < 0) {
            return;
        }

        //we have repeated a click in the same spot deslect the value from last time
        if (hasCTRL && x === mousePoint.x && y === mousePoint.y) {
            grid.clearMostRecentSelection();
            grid.popMouseDown();
            grid.repaint();
            return;
        }

        if (!hasCTRL && !hasSHIFT) {
            grid.clearSelections();
        }

        if (hasSHIFT) {
            grid.clearMostRecentSelection();
            grid.select(mousePoint.x, mousePoint.y, x - mousePoint.x, y - mousePoint.y);
            grid.setDragExtent(grid.newPoint(x - mousePoint.x, y - mousePoint.y));
        } else {
            grid.select(x, y, 0, 0);
            grid.setMouseDown(grid.newPoint(x, y));
            grid.setDragExtent(grid.newPoint(0, 0));
        }
        grid.repaint();
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function handleDOWNSHIFT(grid) {
        this.moveShiftSelect(grid, 0, 1);
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     */
    handleUPSHIFT: function handleUPSHIFT(grid) {
        this.moveShiftSelect(grid, 0, -1);
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     */
    handleLEFTSHIFT: function handleLEFTSHIFT(grid) {
        this.moveShiftSelect(grid, -1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     */
    handleRIGHTSHIFT: function handleRIGHTSHIFT(grid) {
        this.moveShiftSelect(grid, 1, 0);
    },

    /**
     * @private
     * @memberOf CellSelection.prototype
     * @param grid
     * @param selection
     * @return {boolean}
     * @private
     */
    _isSelectionInsideDataArea: function _isSelectionInsideDataArea(grid, selection) {
        var maxColumnWithContent = grid.behavior.dataModel.getColumnsWithValuesCount();
        var maxRowWithContent = grid.behavior.dataModel.getRowsWithValuesCount();

        return selection.corner.x <= maxColumnWithContent - 1 && selection.corner.y <= maxRowWithContent;
    },

    /**
     * @private
     * @memberOf CellSelection.prototype
     * @param grid
     * @param selection
     * @return {boolean}
     * @private
     */
    _isSelectionAlreadyOnFictiveHeaderRow: function _isSelectionAlreadyOnFictiveHeaderRow(grid, selection) {
        return selection.origin.y < grid.getFictiveHeaderRowsCount();
    },

    /**
     * @private
     * @memberOf CellSelection.prototype
     * @param grid
     * @param selection
     * @return {boolean}
     * @private
     */
    _isSelectionAlreadyOnFirstDataRow: function _isSelectionAlreadyOnFirstDataRow(grid, selection) {
        return selection.origin.y === grid.getFictiveHeaderRowsCount() || selection.corner.y === grid.getFictiveHeaderRowsCount();
    },

    /**
     * @private
     * @memberOf CellSelection.prototype
     * @param grid
     * @param selection
     * @return {boolean}
     * @private
     */
    _isSelectionAlreadyOnLastDataRow: function _isSelectionAlreadyOnLastDataRow(grid, selection) {
        var maxRowWithContent = grid.behavior.dataModel.getRowsWithValuesCount();
        return selection.corner.y === maxRowWithContent + grid.getFictiveHeaderRowsCount() - 1;
    },

    /**
     * @private
     * @memberOf CellSelection.prototype
     * @param grid
     * @param selection
     * @return {boolean}
     * @private
     */
    _isSelectionAlreadyOnLastDataColumn: function _isSelectionAlreadyOnLastDataColumn(grid, selection) {
        var maxColumnWithContent = grid.behavior.dataModel.getColumnsWithValuesCount();
        return selection.corner.x === maxColumnWithContent - 1;
    },

    /**
     * @private
     * @memberOf CellSelection.prototype
     * @param grid
     * @param selection
     * @return {boolean}
     * @private
     */
    _isSelectionAlreadyOnLastDataColumnAndRow: function _isSelectionAlreadyOnLastDataColumnAndRow(grid, selection) {
        return this._isSelectionAlreadyOnLastDataRow(grid, selection) && this._isSelectionAlreadyOnLastDataColumn(grid, selection);
    },

    /**
     * @private
     * @memberOf CellSelection.prototype
     * @param grid
     * @param selection
     * @return {boolean}
     * @private
     */
    _isSelectionAlreadyOnFirstCell: function _isSelectionAlreadyOnFirstCell(grid, selection) {
        return selection.origin.x <= 0 && selection.origin.y <= grid.getFictiveHeaderRowsCount();
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     */
    handleCTRLa: function handleCTRLa(grid) {
        var oldLastSelection = grid.selectionModel.getLastSelection();
        var maxColumnWithContent = grid.behavior.dataModel.getColumnsWithValuesCount();
        var maxRowWithContent = grid.behavior.dataModel.getRowsWithValuesCount();
        var fictiveHeaderRowsCount = grid.getFictiveHeaderRowsCount();

        var newSelectionOriginX = 0,
            newSelectionOriginY = 0,
            newSelectionCornerX = 0,
            newSelectionCornerY = 0;

        if (this._isSelectionInsideDataArea(grid, oldLastSelection) && !(this._isSelectionAlreadyOnLastDataColumnAndRow(grid, oldLastSelection) && this._isSelectionAlreadyOnFirstCell(grid, oldLastSelection))) {
            newSelectionOriginX = 0;
            newSelectionOriginY = fictiveHeaderRowsCount;
            newSelectionCornerX = maxColumnWithContent - 1;
            newSelectionCornerY = maxRowWithContent - 1;
        } else {
            newSelectionOriginX = 0;
            newSelectionOriginY = 0;
            newSelectionCornerX = grid.getColumnCount();
            newSelectionCornerY = grid.getRowCount();
        }

        if (this._isSelectionAlreadyOnFictiveHeaderRow(grid, oldLastSelection) || grid.properties.selectFictiveHeaderCellsAsRegular) {
            newSelectionOriginY = 0;
            newSelectionCornerY += grid.getFictiveHeaderRowsCount();
        }

        // 11.05.2018 - Do not remove commented code yet
        grid.clearMostRecentSelection();
        grid.select(newSelectionOriginX, newSelectionOriginY, newSelectionCornerX, newSelectionCornerY);
        // grid.setMouseDown(grid.newPoint(newSelectionOriginX, newSelectionOriginY));
        // grid.setDragExtent(grid.newPoint(newSelectionCornerX, newSelectionCornerY));
        grid.setMouseDown(grid.newPoint(oldLastSelection.firstSelectedCell.x, oldLastSelection.firstSelectedCell.y));
        grid.setDragExtent(grid.newPoint(newSelectionCornerX - oldLastSelection.firstSelectedCell.x, newSelectionCornerY - oldLastSelection.firstSelectedCell.y));
        var newLastSelection = grid.selectionModel.getLastSelection();
        newLastSelection.firstSelectedCell = oldLastSelection.firstSelectedCell;
        newLastSelection.lastSelectedCell = oldLastSelection.lastSelectedCell;
        grid.repaint();
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     */
    handleCTRLUP: function handleCTRLUP(grid) {
        var lastSelection = grid.selectionModel.getLastSelection();
        var maxRowWithContent = grid.behavior.dataModel.getRowsWithValuesCount();

        if (!this._isSelectionInsideDataArea(grid, lastSelection) || grid.properties.ignoreDataCellsOnVerticalCtrlSelection) {
            if (lastSelection.origin.x >= grid.behavior.dataModel.getColumnsWithValuesCount() || grid.properties.ignoreDataCellsOnVerticalCtrlSelection) {
                grid.moveSingleSelect(0, -Math.max(lastSelection.corner.y, lastSelection.origin.y));
            } else {
                grid.moveSingleSelect(0, -(Math.max(lastSelection.corner.y, lastSelection.origin.y) - maxRowWithContent));
            }
        } else {
            if (this._isSelectionAlreadyOnFictiveHeaderRow(grid, lastSelection) || this._isSelectionAlreadyOnFirstDataRow(grid, lastSelection) || grid.properties.selectFictiveHeaderCellsAsRegular) {
                grid.moveSingleSelect(0, -Math.max(lastSelection.corner.y, lastSelection.origin.y));
            } else {
                grid.moveSingleSelect(0, -(Math.max(lastSelection.corner.y, lastSelection.origin.y) - grid.getFictiveHeaderRowsCount()));
            }
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     */
    handleCTRLDOWN: function handleCTRLDOWN(grid) {
        var lastSelection = grid.selectionModel.getLastSelection();
        var maxRowWithContent = grid.behavior.dataModel.getRowsWithValuesCount();

        if (!this._isSelectionInsideDataArea(grid, lastSelection) || this._isSelectionAlreadyOnLastDataRow(grid, lastSelection) || lastSelection.origin.x > grid.behavior.dataModel.getColumnsWithValuesCount() || grid.properties.ignoreDataCellsOnVerticalCtrlSelection) {
            grid.moveSingleSelect(0, grid.getRowCount() - lastSelection.lastSelectedCell.y);
        } else {
            if (this._isSelectionAlreadyOnFictiveHeaderRow(grid, lastSelection) && !this._isSelectionAlreadyOnFirstDataRow(grid, lastSelection) && !grid.properties.selectFictiveHeaderCellsAsRegular) {
                grid.moveSingleSelect(0, grid.getFictiveHeaderRowsCount() - lastSelection.lastSelectedCell.y);
            } else {
                grid.moveSingleSelect(0, maxRowWithContent - lastSelection.lastSelectedCell.y);
            }
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     */
    handleCTRLRIGHT: function handleCTRLRIGHT(grid) {
        var lastSelection = grid.selectionModel.getLastSelection();
        var maxColumnWithContent = grid.behavior.dataModel.getColumnsWithValuesCount();

        if (!this._isSelectionInsideDataArea(grid, lastSelection) || this._isSelectionAlreadyOnLastDataColumn(grid, lastSelection)) {
            grid.moveSingleSelect(grid.getColumnCount() - lastSelection.origin.x, 0);
        } else {
            grid.moveSingleSelect(maxColumnWithContent - 1 - lastSelection.origin.x, 0);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     */
    handleCTRLLEFT: function handleCTRLLEFT(grid) {
        var lastSelection = grid.selectionModel.getLastSelection();
        var maxColumnWithContent = grid.behavior.dataModel.getColumnsWithValuesCount();

        if (this._isSelectionInsideDataArea(grid, lastSelection) || this._isSelectionAlreadyOnLastDataColumn(grid, lastSelection)) {
            grid.moveSingleSelect(-lastSelection.corner.x, 0);
        } else {
            grid.moveSingleSelect(-(lastSelection.corner.x - (maxColumnWithContent - 1)), 0);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     */
    handleCTRLUPSHIFT: function handleCTRLUPSHIFT(grid) {
        var lastSelection = grid.selectionModel.getLastSelection();
        var maxRowWithContent = grid.behavior.dataModel.getRowsWithValuesCount();

        if (!this._isSelectionInsideDataArea(grid, lastSelection) || grid.properties.ignoreDataCellsOnVerticalCtrlSelection) {
            if (lastSelection.origin.x >= grid.behavior.dataModel.getColumnsWithValuesCount() || grid.properties.ignoreDataCellsOnVerticalCtrlSelection) {
                this.moveShiftSelect(grid, 0, -Math.max(lastSelection.corner.y, lastSelection.origin.y));
            } else {
                this.moveShiftSelect(grid, 0, -(Math.max(lastSelection.corner.y, lastSelection.origin.y) - maxRowWithContent));
            }
        } else {
            if (this._isSelectionAlreadyOnFictiveHeaderRow(grid, lastSelection) || this._isSelectionAlreadyOnFirstDataRow(grid, lastSelection) || grid.properties.selectFictiveHeaderCellsAsRegular) {
                this.moveShiftSelect(grid, 0, -Math.max(lastSelection.corner.y, lastSelection.origin.y));
            } else {
                this.moveShiftSelect(grid, 0, -(Math.max(lastSelection.corner.y, lastSelection.origin.y) - grid.getFictiveHeaderRowsCount()));
            }
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     */
    handleCTRLDOWNSHIFT: function handleCTRLDOWNSHIFT(grid) {
        var lastSelection = grid.selectionModel.getLastSelection();
        var maxRowWithContent = grid.behavior.dataModel.getRowsWithValuesCount();

        if (!this._isSelectionInsideDataArea(grid, lastSelection) || this._isSelectionAlreadyOnLastDataRow(grid, lastSelection) || lastSelection.origin.x > grid.behavior.dataModel.getColumnsWithValuesCount() || grid.properties.ignoreDataCellsOnVerticalCtrlSelection) {
            this.moveShiftSelect(grid, 0, grid.getRowCount() - lastSelection.lastSelectedCell.y);
        } else {
            this.moveShiftSelect(grid, 0, maxRowWithContent - lastSelection.lastSelectedCell.y);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     */
    handleCTRLRIGHTSHIFT: function handleCTRLRIGHTSHIFT(grid) {
        var lastSelection = grid.selectionModel.getLastSelection();
        var maxColumnWithContent = grid.behavior.dataModel.getColumnsWithValuesCount();

        if (!this._isSelectionInsideDataArea(grid, lastSelection) || this._isSelectionAlreadyOnLastDataColumn(grid, lastSelection)) {
            this.moveShiftSelect(grid, grid.getColumnCount() - lastSelection.origin.x, 0);
        } else {
            this.moveShiftSelect(grid, maxColumnWithContent - 1 - lastSelection.origin.x, 0);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     */
    handleCTRLLEFTSHIFT: function handleCTRLLEFTSHIFT(grid) {
        var lastSelection = grid.selectionModel.getLastSelection();
        var maxColumnWithContent = grid.behavior.dataModel.getColumnsWithValuesCount();

        if (this._isSelectionInsideDataArea(grid, lastSelection) || this._isSelectionAlreadyOnLastDataColumn(grid, lastSelection)) {
            this.moveShiftSelect(grid, -lastSelection.corner.x, 0);
        } else {
            this.moveShiftSelect(grid, -(lastSelection.corner.x - (maxColumnWithContent - 1)), 0);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function handleDOWN(grid, event) {
        //keep the browser viewport from auto scrolling on key event
        event.primitiveEvent.preventDefault();

        var count = this.getAutoScrollAcceleration();
        grid.moveSingleSelect(0, count);
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function handleUP(grid, event) {
        //keep the browser viewport from auto scrolling on key event
        event.primitiveEvent.preventDefault();

        var count = this.getAutoScrollAcceleration();
        grid.moveSingleSelect(0, -count);
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     */
    handleLEFT: function handleLEFT(grid) {
        grid.moveSingleSelect(-1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     */
    handleRIGHT: function handleRIGHT(grid) {
        grid.moveSingleSelect(1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function getAutoScrollAcceleration() {
        var elapsed = this.getAutoScrollDuration() / 2000;
        return Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function setAutoScrollStartTime() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function pingAutoScroll() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function getAutoScrollDuration() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function moveShiftSelect(grid, offsetX, offsetY) {
        if (grid.extendSelect(offsetX, offsetY)) {
            this.pingAutoScroll();
        }
    }

});

module.exports = CellSelection;

},{"./Feature":75}],69:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

var Feature = require('./Feature');

var dragger;
var draggerCTX;
var placeholder;
var placeholderCTX;

var GRAB = ['grab', '-moz-grab', '-webkit-grab'],
    GRABBING = ['grabbing', '-moz-grabbing', '-webkit-grabbing'];

/**
 * @constructor
 * @extends Feature
 */
var ColumnFixation = Feature.extend('ColumnFixation', {
    /**
     * @type {boolean}
     * @memberOf ColumnFixation.prototype
     */
    dragging: false,

    /**
     * an offset to position the dragger from the cursor
     * @type {number}
     * @memberOf ColumnFixation.prototype
     */
    dragOffset: 0,

    /**
     * current position (index) of an placeholder
     * @type {number}
     * @memberOf ColumnFixation.prototype
     */
    currentPlaceholderColumnPos: -1,

    /**
     * @memberOf ColumnFixation.prototype
     * @desc fired every time when grid rendered
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleGridRendered: function handleGridRendered(grid, event) {
        this.initializeAnimationSupport(grid);

        if (this.next) {
            this.next.handleGridRendered(grid);
        }
    },
    /**
     * @memberOf ColumnFixation.prototype
     * @desc initialize animation support on the grid
     * @param {Hypergrid} grid
     */
    initializeAnimationSupport: function initializeAnimationSupport(grid) {
        this.createOrUpdateDragger(grid);
        if (!placeholder) {
            placeholder = document.createElement('canvas');
            placeholder.setAttribute('width', '0px');
            placeholder.setAttribute('height', '0px');
            placeholder.style.position = 'fixed';

            document.body.appendChild(placeholder);
            placeholderCTX = placeholder.getContext('2d', { alpha: false });
        }
    },

    /**
     * @memberOf ColumnFixation.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function handleMouseDrag(grid, event) {
        if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf ColumnFixation.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function handleMouseDown(grid, event) {
        if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf ColumnFixation.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function handleMouseUp(grid, event) {
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf ColumnFixation.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function handleMouseMove(grid, event) {
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    },

    handleColumnResizedEvent: function handleColumnResizedEvent(grid, event) {
        grid.paintNow();
        this.moveDragger(grid, this.getStartByFixedColumnsCount(grid), false);

        if (this.next) {
            this.next.handleColumnResizedEvent(grid, event);
        }
    },

    /**
     * @memberOf ColumnFixation.prototype
     * @desc utility function to move dragger based on current cursor position
     * @param {Hypergrid} grid
     * @param {number} x
     * @param {boolean?} movePlaceholderNeeded
     */
    moveDragger: function moveDragger(grid, x, movePlaceholderNeeded) {
        movePlaceholderNeeded = typeof movePlaceholderNeeded !== 'undefined' ? movePlaceholderNeeded : true;
        dragger.style.left = x + grid.canvas.size.left + 'px';

        if (movePlaceholderNeeded) {
            var nearestColumnIndex = this.getNearestColumnIndex(grid, x);
            if (nearestColumnIndex !== undefined && nearestColumnIndex !== this.currentPlaceholderColumnPos) {
                this.movePlaceholderTo(grid, nearestColumnIndex);
                this.currentPlaceholderColumnPos = nearestColumnIndex;
            }
        }
    },

    /**
     * @memberOf ColumnFixation.prototype
     * @desc utility function to move placeholder to the start coordinates of column
     * @param {Hypergrid} grid
     * @param {number} column
     */
    movePlaceholderTo: function movePlaceholderTo(grid, column) {
        placeholder.style.display = 'inline';

        var newStartX = this.getStartByColumnIndex(grid, column);

        placeholder.style.left = newStartX + 'px';
    },

    /**
     * @memberOf ColumnFixation.prototype
     * @desc create the placeholder based on current count of fixed columns
     * @param {Hypergrid} grid
     */
    createPlaceholder: function createPlaceholder(grid) {
        var width = grid.properties.fixedLinesHWidth;
        var gridHeight = grid.div.clientHeight;
        var hdpiRatio = grid.getHiDPI(placeholderCTX);
        var headerHeight = grid.getRowHeight(0);

        var location = grid.div.getBoundingClientRect();

        placeholder.style.top = location.top + 'px';
        placeholder.setAttribute('width', Math.round(width * hdpiRatio) + 'px');
        placeholder.setAttribute('height', Math.round(gridHeight * hdpiRatio) + 'px');
        placeholder.style.display = 'inline';

        placeholderCTX.clearRect(0, 0, width, gridHeight);
        placeholderCTX.fillStyle = grid.properties.columnFixationPlaceholderHeaderColor;
        placeholderCTX.fillRect(0, 0, width, headerHeight);
        placeholderCTX.fillStyle = grid.properties.columnFixationPlaceholderBodyColor;
        placeholderCTX.fillRect(0, headerHeight, width, gridHeight);

        placeholderCTX.scale(hdpiRatio, hdpiRatio);

        placeholder.style.zIndex = '4';

        this.movePlaceholderTo(grid, grid.getFixedColumnCount());
    },

    /**
     * @memberOf ColumnFixation.prototype
     * @desc utility function for setting cross browser css properties
     * @param {HTMLElement} element - descripton
     * @param {string} property - the property
     * @param {string} value - the value to assign
     */
    setCrossBrowserProperty: function setCrossBrowserProperty(element, property, value) {
        var uProperty = property[0].toUpperCase() + property.substr(1);
        this.setProp(element, 'webkit' + uProperty, value);
        this.setProp(element, 'Moz' + uProperty, value);
        this.setProp(element, 'ms' + uProperty, value);
        this.setProp(element, 'O' + uProperty, value);
        this.setProp(element, property, value);
    },

    /**
     * @memberOf ColumnFixation.prototype
     * @desc create the dragged column based on current count of fixed columns
     * @param {Hypergrid} grid
     */
    createOrUpdateDragger: function createOrUpdateDragger(grid) {
        if (this.dragging) {
            return;
        }

        this.fixedLinesHWidth = grid.properties.fixedLinesHWidth;

        if (!dragger) {
            dragger = document.createElement('canvas');
            draggerCTX = dragger.getContext('2d', { alpha: false });
            document.body.appendChild(dragger);
        }

        var width = this.fixedLinesHWidth;
        var startX = this.getStartByFixedColumnsCount(grid);

        var headerHeight = grid.getRowHeight(0);
        var gridHeight = grid.div.clientHeight;

        var hdpiRatio = grid.getHiDPI(draggerCTX);
        var location = grid.div.getBoundingClientRect();

        dragger.setAttribute('width', width * hdpiRatio + 'px');
        dragger.setAttribute('height', gridHeight * hdpiRatio + 'px');
        dragger.style.position = 'fixed';
        dragger.style.top = location.top + 'px';
        dragger.style.left = startX + 'px';
        dragger.style.display = 'inline';

        draggerCTX.clearRect(0, 0, width, gridHeight);
        draggerCTX.fillStyle = grid.properties.columnFixationDraggerHeaderInactiveColor;
        draggerCTX.fillRect(0, 0, width, headerHeight);

        var self = this;
        dragger.onmouseenter = function (event) {
            if (!self.dragging) {
                event.stopImmediatePropagation();
                event.preventDefault();
                self.cursor = GRAB;

                draggerCTX.clearRect(0, 0, width, gridHeight);
                draggerCTX.fillStyle = grid.properties.columnFixationDraggerHeaderHoveredColor;
                draggerCTX.fillRect(0, 0, width, headerHeight);
            }
        };

        dragger.onmouseleave = function () {
            if (!self.dragging) {
                event.stopImmediatePropagation();
                event.preventDefault();

                self.cursor = null;

                draggerCTX.clearRect(0, 0, width, gridHeight);
                draggerCTX.fillStyle = grid.properties.columnFixationDraggerHeaderInactiveColor;
                draggerCTX.fillRect(0, 0, width, headerHeight);
            }
        };

        dragger.onmousedown = function (event) {
            event.stopImmediatePropagation();
            event.preventDefault();
            this.cursor = GRABBING;

            self.dragging = true;

            grid.scrollToMakeVisible(grid.getFixedColumnCount(), grid.getFixedRowCount() - 1);

            self.createPlaceholder(grid);
            self.dragOffset = dragger.getBoundingClientRect().left;

            draggerCTX.clearRect(0, 0, width, gridHeight);
            draggerCTX.fillStyle = grid.properties.columnFixationDraggerHeaderDraggingColor;
            draggerCTX.fillRect(0, 0, width, headerHeight);
            draggerCTX.fillStyle = grid.properties.columnFixationDraggerBodyDraggingColor;
            draggerCTX.fillRect(0, headerHeight, width, gridHeight);

            document.onmousemove = function (e) {
                var pos1 = e.clientX - grid.properties.fixedLinesHWidth / 2 - grid.canvas.size.left;

                self.moveDragger(grid, pos1);
            };
            document.onmouseup = function (e) {
                document.onmousemove = null;
                document.onmouseup = null;

                if (self.dragging) {
                    self.cursor = null;
                    self.performFixation(grid);
                    grid.paintNow();
                    self.moveDragger(grid, self.getStartByFixedColumnsCount(grid) - grid.canvas.size.left, false);
                }
                self.dragging = false;
                self.cursor = null;

                draggerCTX.clearRect(0, 0, width, gridHeight);
                draggerCTX.fillStyle = grid.properties.columnFixationDraggerHeaderInactiveColor;
                draggerCTX.fillRect(0, 0, width, headerHeight);
            };
        };
    },

    /**
     * @memberOf ColumnFixation.prototype
     * @desc utility method to get start position of the dragger based on current fixed columns count
     * @param {Hypergrid} grid
     */
    getStartByFixedColumnsCount: function getStartByFixedColumnsCount(grid) {
        return this.getStartByColumnIndex(grid, grid.properties.fixedColumnCount);
    },

    /**
     * @memberOf ColumnFixation.prototype
     * @desc utility method to get start position of the dragger based on columnIndex
     * @param {Hypergrid} grid
     * @param {number} columnIndex
     */
    getStartByColumnIndex: function getStartByColumnIndex(grid, columnIndex) {
        if (columnIndex < 0) {
            columnIndex = 0;
        }

        var column, res;
        if (columnIndex > 0) {
            // otherwise detect column and use it's right side
            column = grid.renderer.visibleColumns[columnIndex - 1];
            if (!column) {
                column = grid.renderer.visibleColumns[0];
            }
            res = column ? column.right : 0;
        } else {
            // if no selection use left side of first column
            res = grid.renderer.visibleColumns[0].left - this.fixedLinesHWidth;
        }

        return res + grid.canvas.size.left;
    },

    /**
     * @memberOf ColumnFixation.prototype
     * @desc utility method to set grid options when dragging ends
     * @param {Hypergrid} grid
     */
    performFixation: function performFixation(grid) {
        var currentFixedColumnCount = grid.properties.fixedColumnCount;
        grid.addProperties({
            fixedColumnCount: this.currentPlaceholderColumnPos
        });

        placeholder.style.display = 'none';

        grid.fireSyntheticOnFixedColumnCountChangedEvent(currentFixedColumnCount, this.currentPlaceholderColumnPos);
    },

    /**
     * @memberOf ColumnFixation.prototype
     * @desc utility function to get nearest possible index from an cursor position
     * @param {Hypergrid} grid
     * @param {number} x - horizontal cursor position
     */
    getNearestColumnIndex: function getNearestColumnIndex(grid, x) {
        var columnUnderCursorIndex = grid.renderer.getColumnFromPixelX(x);
        var visibleColumns = grid.renderer.visibleColumns;

        var max = grid.getVisibleColumnsCount();
        var columnStartX = visibleColumns[Math.min(max, columnUnderCursorIndex)].left;
        var columnEndX = visibleColumns[Math.min(max, columnUnderCursorIndex)].right;

        var res = columnUnderCursorIndex;

        if (!(Math.abs(columnStartX - x) < Math.abs(columnEndX - x))) {
            res += 1;
        }

        if (res >= visibleColumns[visibleColumns.length - 1].columnIndex) {
            res = visibleColumns[visibleColumns.length - 2].columnIndex;
        }

        return res;
    },

    setProp: function setProp(element, property, value) {
        if (property in element.style) {
            element.style[property] = value;
        }
    }
});

module.exports = ColumnFixation;

},{"./Feature":75}],70:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

// This feature is responsible for column drag and drop reordering.
// This object is a mess and desperately needs a complete rewrite.....

var Feature = require('./Feature');

var GRAB = ['grab', '-moz-grab', '-webkit-grab'],
    GRABBING = ['grabbing', '-moz-grabbing', '-webkit-grabbing'],
    setName = function setName(name) {
    this.cursor = name;
};

var dragger = void 0,
    draggerCTX = void 0,
    placeholder = void 0,
    placeholderCTX = void 0;

/**
 * @constructor
 * @extends Feature
 */
var ColumnMoving = Feature.extend('ColumnMoving', {

    /**
     * queue up the animations that need to play so they are done synchronously
     * @type {Array}
     * @memberOf ColumnMoving.prototype
     */
    floaterAnimationQueue: [],

    /**
     * am I currently auto scrolling right
     * @type {boolean}
     * @memberOf ColumnMoving.prototype
     */
    columnDragAutoScrollingRight: false,

    /**
     * am I currently auto scrolling left
     * @type {boolean}
     * @memberOf ColumnMoving.prototype
     */
    columnDragAutoScrollingLeft: false,

    /**
     * am I dragging right now
     * @type {boolean}
     * @memberOf ColumnMoving.prototype
     */
    dragging: false,

    /**
     * the column index of the currently dragged column
     * @type {number}
     * @memberOf ColumnMoving.prototype
     */
    dragCol: -1,

    /**
     * an offset to position the dragged item from the cursor
     * @type {number}
     * @memberOf ColumnMoving.prototype
     */
    dragOffset: 0,

    minScrollDelay: 30,
    maxScrollDelay: 100,
    scrollAttempt: 0,

    /**
     * @memberOf ColumnMoving.prototype
     * @desc give me an opportunity to initialize stuff on the grid
     * @param {Hypergrid} grid
     */
    initializeOn: function initializeOn(grid) {
        this.initializeAnimationSupport(grid);
        if (this.next) {
            this.next.initializeOn(grid);
        }
    },

    /**
     * @memberOf ColumnMoving.prototype
     * @desc initialize animation support on the grid
     * @param {Hypergrid} grid
     */
    initializeAnimationSupport: function initializeAnimationSupport(grid) {
        if (!dragger) {
            dragger = document.createElement('canvas');
            dragger.setAttribute('width', '0px');
            dragger.setAttribute('height', '0px');
            dragger.style.position = 'fixed';

            document.body.appendChild(dragger);
            draggerCTX = dragger.getContext('2d', { alpha: true });
        }
        if (!placeholder) {
            placeholder = document.createElement('canvas');
            placeholder.setAttribute('width', '0px');
            placeholder.setAttribute('height', '0px');
            placeholder.style.position = 'fixed';

            document.body.appendChild(placeholder);
            placeholderCTX = placeholder.getContext('2d', { alpha: true });
        }
    },

    /**
     * @memberOf ColumnMoving.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function handleMouseDrag(grid, event) {

        if (event.isColumnFixed) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
            return;
        }

        if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }

        if (this.dragging) {
            this.dragColumn(grid, event);
        }
    },

    /**
     * @memberOf ColumnMoving.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function handleMouseDown(grid, event) {
        if (grid.behavior.isColumnReorderable() && !event.isColumnFixed && event.isHeaderCell && !event.isColumnFixed && !event.primitiveEvent.detail.isRightClick) {
            // start dragging
            var gridCell = event.gridCell;
            this.cursor = GRABBING;
            this.dragging = true;
            this.dragCol = gridCell.x;

            var firstSelectedColumn = grid.getSelectedColumns()[0] || grid.renderer.visibleColumns.findIndex(function (c) {
                return c.column === event.column;
            });
            var hScrollOffset = grid.getHScrollValue();
            var firstSelectedColumnX = grid.renderer.visibleColumns[Math.max(0, firstSelectedColumn - hScrollOffset)].left;

            this.dragOffset = event.primitiveEvent.detail.mouse.x - firstSelectedColumnX;

            this.detachChain();
            this.createDragColumn(grid, this.dragCol);
            this.createPlaceholder(grid, this.dragCol);
            this.dragColumn(grid, event);
        }
        if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf ColumnMoving.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function handleMouseUp(grid, event) {
        //var col = event.gridCell.x;
        if (this.dragging) {
            this.cursor = null;
            //delay here to give other events a chance to be dropped
            var self = this;
            this.endDragColumn(grid);
            setTimeout(function () {
                self.attachChain();
            }, 200);
        }
        this.dragCol = -1;
        this.dragging = false;
        this.cursor = null;
        grid.repaint();

        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf ColumnMoving.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function handleMouseMove(grid, event) {
        if (event.isColumnSelected && grid.behavior.isColumnReorderable() && !event.isColumnFixed && !this.dragging && event.isHeaderCell
        // && event.mousePoint.y < grid.properties.columnGrabMargin
        ) {
                this.cursor = GRAB;
            } else {
            this.cursor = null;
        }

        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }

        if (event.isHeaderCell && this.dragging) {
            this.cursor = GRABBING; //move';
        }
    },

    /**
     * @memberOf ColumnMoving.prototype
     * @desc this is the main event handler that manages the dragging of the column and moving of placeholder
     * @param {Hypergrid} grid
     */
    movePlaceholderTo: function movePlaceholderTo(grid, overCol) {
        var placeholderLineWidth = grid.properties.columnMoveInsertLineWidth;
        var visibleColumns = grid.renderer.visibleColumns;

        var d = placeholder;
        d.style.display = 'inline';

        var scrollLeft = grid.getHScrollValue();
        var fixedColumnCount = grid.getFixedColumnCount();
        if (overCol < fixedColumnCount) {
            scrollLeft = 0;
        }

        var x = void 0;
        if (overCol >= scrollLeft + visibleColumns.length) {
            var lastColumn = visibleColumns[visibleColumns.length - 1];
            x = lastColumn.left + lastColumn.width;
        } else {
            var supportingColumn = visibleColumns[overCol - scrollLeft];
            if (!supportingColumn) {
                return;
            }
            x = supportingColumn.left + placeholderLineWidth / 2;
        }

        this.setCrossBrowserProperty(d, 'transform', 'translate(' + x + 'px, ' + 0 + 'px)');
        grid.repaint();
    },

    /**
     * @memberOf ColumnMoving.prototype
     * @desc create the placeholder at columnIndex where column(s) should be moved to
     * @param {Hypergrid} grid
     * @param {number} columnIndex - the index of the column after which
     */
    createPlaceholder: function createPlaceholder(grid, columnIndex) {
        var fixedColumnCount = grid.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();

        if (columnIndex < fixedColumnCount) {
            scrollLeft = 0;
        }

        var width = grid.properties.columnMoveInsertLineWidth;
        var colHeight = grid.div.clientHeight;
        var d = placeholder;
        var style = d.style;
        var location = grid.div.getBoundingClientRect();

        var heightToSkip = 0;
        var rowsToSkip = grid.getHeaderRowCount();
        for (var i = 0; i < rowsToSkip; i++) {
            heightToSkip += grid.getRowHeight(i);
        }
        if (grid.properties.gridLinesH && grid.properties.gridLinesWidth) {
            heightToSkip += grid.properties.gridLinesWidth;
        }
        colHeight -= heightToSkip;

        style.top = location.top + heightToSkip + 'px';
        style.left = location.left - 2 + 'px';

        var hdpiRatio = grid.getHiDPI(placeholderCTX);

        d.setAttribute('width', Math.round(width * hdpiRatio) + 'px');
        d.setAttribute('height', Math.round(colHeight * hdpiRatio) + 'px');
        // style.boxShadow = '0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)';
        style.width = width + 'px'; //Math.round(columnWidth / hdpiRatio) + 'px';
        style.height = colHeight + 'px'; //Math.round(colHeight / hdpiRatio) + 'px';
        style.backgroundColor = grid.properties.columnMoveInsertLineColor;

        var startX = grid.renderer.visibleColumns[columnIndex - scrollLeft].left * hdpiRatio;

        placeholderCTX.scale(hdpiRatio, hdpiRatio);

        grid.renderOverridesCache.floater = {
            columnIndex: columnIndex,
            startX: startX
        };

        style.zIndex = '4';
        GRABBING.forEach(setName, style);
        grid.repaint();
    },

    /**
     * @memberOf ColumnMoving.prototype
     * @desc utility function for setting cross browser css properties
     * @param {HTMLElement} element - descripton
     * @param {string} property - the property
     * @param {string} value - the value to assign
     */
    setCrossBrowserProperty: function setCrossBrowserProperty(element, property, value) {
        var uProperty = property[0].toUpperCase() + property.substr(1);
        this.setProp(element, 'webkit' + uProperty, value);
        this.setProp(element, 'Moz' + uProperty, value);
        this.setProp(element, 'ms' + uProperty, value);
        this.setProp(element, 'O' + uProperty, value);
        this.setProp(element, property, value);
    },

    /**
     * @memberOf ColumnMoving.prototype
     * @desc utility function for setting properties on HTMLElements
     * @param {HTMLElement} element - descripton
     * @param {string} property - the property
     * @param {string} value - the value to assign
     */
    setProp: function setProp(element, property, value) {
        if (property in element.style) {
            element.style[property] = value;
        }
    },

    /**
     * @memberOf ColumnMoving.prototype
     * @desc create the dragged column at columnIndex above the floated column
     * @param {Hypergrid} grid
     * @param {number} columnIndex - the index of the column that will be floating
     */
    createDragColumn: function createDragColumn(grid, columnIndex) {
        var hdpiRatio = grid.getHiDPI(draggerCTX);
        var selectedColumns = grid.getSelectedColumns();
        var consequent = this._isConsequent(selectedColumns);
        var columns = consequent ? selectedColumns : [columnIndex];

        var columnWidth = 0;
        columns.forEach(function (col) {
            columnWidth += grid.getColumnWidth(col);
        });

        var colHeight = grid.div.clientHeight;
        var d = dragger;
        var location = grid.div.getBoundingClientRect();
        var style = d.style;
        // offset from top + header height
        var offsetY = grid.getFixedRowsHeight();
        style.top = location.top + offsetY + 'px';
        style.left = location.left + 'px';
        style.opacity = 0.15;
        style.border = '1px solid #4285F4';
        style.backgroundColor = 'rgb(0, 0, 0)';

        d.setAttribute('width', Math.round(columnWidth * hdpiRatio) + 'px');
        d.setAttribute('height', Math.round(colHeight * hdpiRatio) + 'px');

        style.width = columnWidth + 'px'; //Math.round(columnWidth / hdpiRatio) + 'px';
        style.height = colHeight - offsetY + 'px'; //Math.round(colHeight / hdpiRatio) + 'px';

        draggerCTX.scale(hdpiRatio, hdpiRatio);

        grid.renderOverridesCache.dragger = {
            columnIndex: columnIndex,
            startIndex: columnIndex
        };

        // this.setCrossBrowserProperty(d, 'transform', 'translate(' + x + 'px, -5px)');
        style.zIndex = '5';
        GRABBING.forEach(setName, style);
        grid.repaint();
    },

    /**
     * @memberOf ColumnMoving.prototype
     * @desc this function is the main dragging logic
     * @param {Hypergrid} grid
     * @param {Object} event - dragging event
     */
    dragColumn: function dragColumn(grid, event) {
        var x = event.primitiveEvent.detail.mouse.x;
        var distance = x - this.dragOffset;

        var autoScrollingNow = this.columnDragAutoScrollingRight || this.columnDragAutoScrollingLeft;
        var dragColumnIndex = grid.renderOverridesCache.dragger.startIndex;

        var minX = 0;
        var maxX = grid.renderer.getFinalVisibleColumnBoundary();

        var d = dragger;

        this.setCrossBrowserProperty(d, 'transform', 'translate(' + distance + 'px, ' + 0 + 'px)');
        requestAnimationFrame(function () {
            d.style.display = 'inline';
        });

        var threshold = 20;
        if (x < minX + threshold) {
            this.checkAutoScrollToLeft(grid, x);
        }
        if (x > minX + threshold) {
            this.columnDragAutoScrollingLeft = false;
            this.resetScrollDelay();
        }
        if (x > maxX - threshold) {
            this.checkAutoScrollToRight(grid, x);
        }
        if (x < maxX - threshold) {
            this.columnDragAutoScrollingRight = false;
            this.resetScrollDelay();
        }

        var overCol = grid.renderer.getColumnFromPixelX(x);
        var selectedColumns = grid.getSelectedColumns();
        var visibleColumns = grid.renderer.visibleColumns;
        var placeholderCol = -1;
        if (!autoScrollingNow) {
            if (!selectedColumns.slice(1).includes(overCol)) {
                grid.renderOverridesCache.dragger.columnIndex = overCol;
                var draggedToTheRight = dragColumnIndex < overCol;
                if (draggedToTheRight) {
                    overCol += 1;
                }
                placeholderCol = overCol;
            } else {
                var firstSelectedColumnIndex = selectedColumns[0];
                var firstVisibleColumnIndex = visibleColumns[0].columnIndex;
                var lastSelectedColumnIndex = selectedColumns[selectedColumns.length - 1] + 2;
                var lastVisibleColumnIndex = visibleColumns[visibleColumns.length - 1].columnIndex;
                if (firstVisibleColumnIndex < firstSelectedColumnIndex) {
                    placeholderCol = firstSelectedColumnIndex;
                } else if (lastVisibleColumnIndex > lastSelectedColumnIndex) {
                    placeholderCol = lastSelectedColumnIndex;
                }
            }
            if (placeholderCol > -1) {
                this.movePlaceholderTo(grid, placeholderCol);
            }
        }
    },

    /**
     * @memberOf ColumnMoving.prototype
     * @desc resets scroll delay to initial value
     */
    resetScrollDelay: function resetScrollDelay() {
        this.scrollAttempt = 0;
    },

    /**
     * @memberOf ColumnMoving.prototype
     * @desc returns delay between auto-scrolling by one step. Delay is decremented with each further step.
     */
    getScrollDelay: function getScrollDelay() {
        return Math.max(this.minScrollDelay, this.maxScrollDelay - this.scrollAttempt++ * 5);
    },

    /**
     * @memberOf ColumnMoving.prototype
     * @desc autoscroll to the right if necessary
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    checkAutoScrollToRight: function checkAutoScrollToRight(grid, x) {
        if (this.columnDragAutoScrollingRight) {
            return;
        }
        this.columnDragAutoScrollingRight = true;
        this._checkAutoScrollToRight(grid, x);
    },

    _checkAutoScrollToRight: function _checkAutoScrollToRight(grid, x) {
        if (!this.columnDragAutoScrollingRight) {
            return;
        }
        var scrollLeft = grid.getHScrollValue();
        if (!grid.dragging || scrollLeft > grid.sbHScroller.range.max - 2) {
            return;
        }
        grid.scrollBy(1, 0);

        var visibleColumns = grid.renderer.visibleColumns;
        var placeholderCol = visibleColumns[visibleColumns.length - 1].columnIndex + 1;
        this.movePlaceholderTo(grid, placeholderCol);

        grid.renderOverridesCache.dragger.columnIndex += 1;
        setTimeout(this._checkAutoScrollToRight.bind(this, grid, x), this.getScrollDelay());
    },

    /**
     * @memberOf ColumnMoving.prototype
     * @desc autoscroll to the left if necessary
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    checkAutoScrollToLeft: function checkAutoScrollToLeft(grid, x) {
        if (this.columnDragAutoScrollingLeft) {
            return;
        }
        this.columnDragAutoScrollingLeft = true;
        this._checkAutoScrollToLeft(grid, x);
    },

    _checkAutoScrollToLeft: function _checkAutoScrollToLeft(grid, x) {
        if (!this.columnDragAutoScrollingLeft) {
            return;
        }
        var scrollLeft = grid.getHScrollValue();
        if (!grid.dragging || scrollLeft < 1) {
            return;
        }
        grid.scrollBy(-1, 0);

        var visibleColumns = grid.renderer.visibleColumns;
        var placeholderCol = visibleColumns[0].columnIndex - 1;
        this.movePlaceholderTo(grid, placeholderCol);

        grid.renderOverridesCache.dragger.columnIndex -= 1;
        setTimeout(this._checkAutoScrollToLeft.bind(this, grid, x), this.getScrollDelay());
    },

    /**
     * @memberOf ColumnMoving.prototype
     * @desc a column drag has completed, update data and cleanup
     * @param {Hypergrid} grid
     */
    endDragColumn: function endDragColumn(grid) {
        var d = dragger;
        var changed = grid.renderOverridesCache.dragger.startIndex !== grid.renderOverridesCache.dragger.columnIndex;

        var selectedColumns = grid.getSelectedColumns();
        var consequent = this._isConsequent(selectedColumns);

        var placeholderIndex = grid.renderOverridesCache.dragger.columnIndex;
        var draggerIndex = grid.renderOverridesCache.dragger.startIndex;
        var from = consequent ? selectedColumns[0] : [draggerIndex];
        var len = consequent ? selectedColumns.length : 1;
        grid.moveColumns(from, len, placeholderIndex);

        var f = placeholder;
        requestAnimationFrame(function () {
            f.style.display = 'none';
        });

        grid.renderOverridesCache.dragger = null;
        grid.repaint();

        grid.clearSelections();
        var startNewSelectionFrom = void 0;
        if (from < placeholderIndex) {
            startNewSelectionFrom = placeholderIndex - (len - 1);
        } else {
            startNewSelectionFrom = placeholderIndex;
        }
        grid.selectColumn(startNewSelectionFrom, startNewSelectionFrom + (len - 1));

        requestAnimationFrame(function () {
            d.style.display = 'none';
            grid.endDragColumnNotification(); //internal notification
            if (changed) {
                grid.fireSyntheticOnColumnsChangedEvent(); //public notification
            }
        });
    },

    _isConsequent: function _isConsequent(arr) {
        var consequent = true;
        if (arr.length > 1) {
            arr.sort();
            for (var i = 0; i < arr.length - 1; i++) {
                if (arr[i + 1] - arr[i] !== 1) {
                    consequent = false;
                }
            }
        }
        return consequent;
    }

});

module.exports = ColumnMoving;

},{"./Feature":75}],71:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 * @extends Feature
 */
var ColumnResizing = Feature.extend('ColumnResizing', {

    /**
     * the pixel location of the where the drag was initiated
     * @type {number}
     * @default
     * @memberOf ColumnResizing.prototype
     */
    dragStart: -1,

    /**
     * the starting width/height of the row/column we are dragging
     * @type {number}
     * @default -1
     * @memberOf ColumnResizing.prototype
     */
    dragStartWidth: -1,

    /**
     * @memberOf ColumnResizing.prototype
     * @desc get the mouse x,y coordinate
     * @returns {number}
     * @param {MouseEvent} event - the mouse event to query
     */
    getMouseValue: function getMouseValue(event) {
        return event.primitiveEvent.detail.mouse.x;
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc returns the index of which divider I'm over
     * @returns {boolean}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    overAreaDivider: function overAreaDivider(grid, event) {
        var leftMostColumnIndex = grid.behavior.leftMostColIndex;

        // near left border of column
        if (event.gridCell.x !== leftMostColumnIndex && event.mousePoint.x <= 3) {
            var leftColumn = grid.behavior.getColumnShifted(event.gridCell.x, false);
            if (leftColumn && !leftColumn.properties.fixed) {
                return true;
            }
        }

        // near right border of column
        if (event.mousePoint.x >= event.bounds.width - 3) {
            var column = grid.behavior.getColumn(event.gridCell.x);
            if (column && !column.properties.fixed) {
                return true;
            }
        }

        return false;
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the cursor name
     * @returns {string}
     */
    getCursorName: function getCursorName() {
        return 'col-resize';
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function handleMouseDrag(grid, event) {
        if (this.dragColumn) {
            var delta = this.getMouseValue(event) - this.dragStart;
            grid.behavior.setColumnWidth(this.dragColumn, this.dragStartWidth + delta);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function handleMouseDown(grid, event) {
        if (event.isHeaderRow && this.overAreaDivider(grid, event)) {
            if (event.mousePoint.x <= 3) {
                var columnIndex = event.gridCell.x - 1;
                this.dragColumn = grid.behavior.getActiveColumn(columnIndex);
                //this.dragStartWidth = grid.renderer.visibleColumns[columnIndex].width;
                var visibleColIndex = grid.behavior.rowColumnIndex;
                var dragColumn = this.dragColumn;
                grid.renderer.visibleColumns.forEachWithNeg(function (vCol, vIndex) {
                    var col = vCol.column;
                    if (col.index === dragColumn.index) {
                        visibleColIndex = vIndex;
                    }
                });
                this.dragStartWidth = grid.renderer.visibleColumns[visibleColIndex].width;
            } else {
                this.dragColumn = event.column;
                this.dragStartWidth = event.bounds.width;
            }

            this.dragStart = this.getMouseValue(event);
            //this.detachChain();
        } else if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function handleMouseUp(grid, event) {
        if (this.dragColumn) {
            this.callCallbackIfNeeded(grid, this.dragColumn);

            this.cursor = null;
            this.dragColumn = false;

            event.primitiveEvent.stopPropagation();
            //delay here to give other events a chance to be dropped
            grid.behaviorShapeChanged();
        } else if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function handleMouseMove(grid, event) {
        if (!this.dragColumn) {
            this.cursor = null;

            if (this.next) {
                this.next.handleMouseMove(grid, event);
            }

            this.cursor = event.isHeaderRow && this.overAreaDivider(grid, event) ? this.getCursorName() : null;
        }
    },

    /**
     * @param {Hypergrid} grid
     * @param {CellEvent} cellEvent
     * @memberOf ColumnResizing.prototype
     */
    handleDoubleClick: function handleDoubleClick(grid, event) {
        if (event.isHeaderRow && this.overAreaDivider(grid, event)) {
            var column = event.mousePoint.x <= 3 ? grid.behavior.getActiveColumn(event.gridCell.x - 1) : event.column;
            grid.autosizeColumn(column);
            column.addProperties({
                columnAutosizing: true,
                columnAutosized: false // todo: columnAutosizing should be a setter that automatically resets columnAutosized on state change to true
            });
            if (column.colDef) {
                delete column.colDef.width;
            }
            this.callCallbackIfNeeded(grid, column);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    callCallbackIfNeeded: function callCallbackIfNeeded(grid, column) {
        if (grid.onColumnResized && this.dragStartWidth !== Math.round(column.getWidth())) {
            grid.onColumnResized(column);
        }
    }

});

module.exports = ColumnResizing;

},{"./Feature":75}],72:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 * @extends Feature
 */
var ColumnSelection = Feature.extend('ColumnSelection', {

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {Point}
     * @default null
     * @memberOf ColumnSelection.prototype
     */
    currentDrag: null,

    /**
     * The horizontal cell coordinate of the where the mouse pointer is during a drag operation.
     * @type {number}
     * @default null
     * @memberOf ColumnSelection.prototype
     */
    lastDragColumn: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf ColumnSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf ColumnSelection.prototype
     */
    sbAutoStart: 0,

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function handleMouseUp(grid, event) {
        if (this.dragging) {
            this.dragging = false;
        }
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    handleDoubleClick: function handleDoubleClick(grid, event) {
        if (this.doubleClickTimer) {
            clearTimeout(this.doubleClickTimer); // prevent mouseDown from continuing
            this.doubleClickTimer = undefined;
        }
        if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function handleMouseDown(grid, event) {
        if (this.doubleClickTimer) {
            return;
        }

        // todo: >= 5 depends on header being top-most row which is currently always true but we may allow header "section" to be arbitrary position within quadrant (see also handleMouseDown in ColumnMoving.js)
        if (!event.isColumnSelected && grid.properties.columnSelection && !event.primitiveEvent.detail.isRightClick && event.isHeaderCell) {
            this.dragging = true;
            this.extendSelection(grid, event.gridCell.x, event.primitiveEvent.detail.keys);
        } else if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function handleMouseDrag(grid, event) {
        if (grid.properties.columnSelection && !this.isColumnDragging(grid) && !event.primitiveEvent.detail.isRightClick && this.dragging) {
            //if we are in the fixed area do not apply the scroll values
            this.lastDragColumn = event.gridCell.x;
            this.currentDrag = event.primitiveEvent.detail.mouse;
            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, this.lastDragColumn, event.primitiveEvent.detail.keys);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function handleKeyDown(grid, event) {
        var detail = event.detail,
            handler = grid.getLastSelectionType() === 'column' && this['handle' + detail.char];

        if (handler) {
            handler.call(this, grid, detail);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Handle a mousedrag selection
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function handleMouseDragCellSelection(grid, x, keys) {
        var mouseX = grid.getMouseDown().x;

        grid.clearMostRecentColumnSelection();

        grid.selectColumn(mouseX, x);
        grid.setDragExtent(grid.newPoint(x - mouseX, 0));

        grid.repaint();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function checkDragScroll(grid, mouse) {
        if (grid.properties.scrollingEnabled && grid.getDataBounds().contains(mouse)) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else {
            if (!grid.isScrollingNow()) {
                grid.setScrollingNow(true);
                this.scrollDrag(grid);
            }
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function scrollDrag(grid) {
        if (!grid.isScrollingNow()) {
            return;
        }

        var b = grid.getDataBounds(),
            xOffset;

        if (this.currentDrag.x < b.origin.x) {
            xOffset = -1;
        } else if (this.currentDrag.x > b.origin.x + b.extent.x) {
            xOffset = 1;
        }

        if (xOffset) {
            if (this.lastDragColumn >= grid.getFixedColumnCount()) {
                this.lastDragColumn += xOffset;
            }
            grid.scrollBy(xOffset, 0);
        }

        this.handleMouseDragCellSelection(grid, this.lastDragColumn, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function extendSelection(grid, x, keys) {
        if (!grid.abortEditing()) {
            return;
        }

        var mouseX = grid.getMouseDown().x,
            hasSHIFT = keys.indexOf('SHIFT') > 0;

        if (x < 0) {
            // outside of the grid?
            return; // do nothing
        }

        if (hasSHIFT) {
            grid.clearMostRecentColumnSelection();
            grid.selectColumn(x, mouseX);
            grid.setDragExtent(grid.newPoint(x - mouseX, 0));
        } else {
            grid.toggleSelectColumn(x, keys);
            grid.setMouseDown(grid.newPoint(x, 0));
            grid.setDragExtent(grid.newPoint(0, 0));
        }

        grid.repaint();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function handleDOWNSHIFT(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function handleUPSHIFT(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function handleLEFTSHIFT(grid) {
        this.moveShiftSelect(grid, -1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function handleRIGHTSHIFT(grid) {
        this.moveShiftSelect(grid, 1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function handleDOWN(grid) {

        // var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());
        // var maxRows = grid.getRowCount() - 1;

        // var newX = mouseCorner.x;
        // var newY = grid.getHeaderRowCount() + grid.getVScrollValue();

        // newY = Math.min(maxRows, newY);

        // grid.clearSelections();
        // grid.select(newX, newY, 0, 0);
        // grid.setMouseDown(new grid.rectangular.Point(newX, newY));
        // grid.setDragExtent(new grid.rectangular.Point(0, 0));

        // grid.repaint();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function handleUP(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function handleLEFT(grid) {
        this.moveSingleSelect(grid, -1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function handleRIGHT(grid) {
        this.moveSingleSelect(grid, 1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function getAutoScrollAcceleration() {
        var elapsed = this.getAutoScrollDuration() / 2000;
        return Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function setAutoScrollStartTime() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function pingAutoScroll() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function getAutoScrollDuration() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function moveShiftSelect(grid, offsetX) {
        var origin = grid.getMouseDown(),
            extent = grid.getDragExtent(),
            newX = extent.x + offsetX,
            maxViewableColumns = grid.renderer.visibleColumns.length - 1,
            maxColumns = grid.getColumnCount() - 1;

        if (!grid.properties.scrollingEnabled) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
        }

        newX = Math.min(maxColumns - origin.x, Math.max(-origin.x, newX));

        grid.clearMostRecentColumnSelection();
        grid.selectColumn(origin.x, origin.x + newX);
        grid.setDragExtent(grid.newPoint(newX, 0));

        if (grid.insureModelColIsVisible(newX + origin.x, offsetX)) {
            this.pingAutoScroll();
        }

        grid.repaint();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveSingleSelect: function moveSingleSelect(grid, offsetX) {
        var extent = grid.getDragExtent(),
            mouseCorner = grid.getMouseDown().plus(extent),
            newX = mouseCorner.x + offsetX,
            maxColumns = grid.getColumnCount() - 1,
            maxViewableColumns = grid.getVisibleColumnsCount() - 1;

        if (!grid.properties.scrollingEnabled) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
        }

        newX = Math.min(maxColumns, Math.max(0, newX));

        grid.clearSelections();
        grid.selectColumn(newX);
        grid.setMouseDown(grid.newPoint(newX, 0));
        grid.setDragExtent(grid.newPoint(0, 0));

        if (grid.insureModelColIsVisible(newX, offsetX)) {
            this.pingAutoScroll();
        }

        grid.repaint();
    },

    isColumnDragging: function isColumnDragging(grid) {
        var dragger = grid.lookupFeature('ColumnMoving');
        return dragger && dragger.dragging && !this.dragging;
    }

});

module.exports = ColumnSelection;

},{"./Feature":75}],73:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 * @extends Feature
 */
var ColumnSorting = Feature.extend('ColumnSorting', {

    /**
     * @memberOf ColumnSorting.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleClick: function handleClick(grid, event) {
        sort.call(this, grid, event);
    },

    /**
     * @memberOf ColumnSorting.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDoubleClick: function handleDoubleClick(grid, event) {
        sort.call(this, grid, event, true);
    },

    /**
     * @memberOf ColumnSorting.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function handleMouseMove(grid, event) {
        var columnProperties;
        if (event.isRowFixed && event.isHeaderCell && (columnProperties = grid.behavior.getColumnProperties(event.gridCell.x)) && !columnProperties.unsortable) {
            this.cursor = 'pointer';
        } else {
            this.cursor = null;
        }
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    }

});

function sort(grid, event, onDoubleClick) {
    var columnProperties;
    if (event.isHeaderCell && !(columnProperties = event.columnProperties).unsortable && !(columnProperties.sortOnDoubleClick ^ onDoubleClick) // both same (true or falsy)?
    ) {
            grid.fireSyntheticColumnSortEvent(event.gridCell.x, event.primitiveEvent.detail.keys);
        }

    if (this.next) {
        this.next[onDoubleClick ? 'handleDoubleClick' : 'handleClick'](grid, event);
    }
}

module.exports = ColumnSorting;

},{"./Feature":75}],74:[function(require,module,exports){
/* eslint-env browser */
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Feature = require('./Feature');

var menuDiv;

var previousHoveredCellEvent;

/**
 * @constructor
 * @extends Feature
 */
var ContextMenu = Feature.extend('ContextMenu', {
    /**
     * @memberOf ContextMenu.prototype
     * @desc give me an opportunity to initialize stuff on the grid
     * @param {Hypergrid} grid
     */
    initializeOn: function initializeOn(grid) {
        if (!menuDiv) {
            menuDiv = this.initializeContextMenuDiv();
        }

        if (this.next) {
            this.next.initializeOn(grid);
        }
    },
    /**
     * @memberOf ContextMenu.prototype
     * @desc initialize context menu div
     */
    initializeContextMenuDiv: function initializeContextMenuDiv() {
        var menuHolderDiv = document.createElement('div');

        menuHolderDiv.style.display = 'none';
        menuHolderDiv.style.position = 'fixed';
        menuHolderDiv.setAttribute('class', 'ag-custom');

        document.body.appendChild(menuHolderDiv);

        return {
            element: menuHolderDiv,
            related: []
        };
    },

    /**
     * @memberOf ContextMenu.prototype
     * @param {Hypergrid} grid
     * @param {CellEvent} event
     */
    handleMouseDown: function handleMouseDown(grid, event) {
        this.hideContextMenu(menuDiv);
        if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    onApiDestroyCalled: function onApiDestroyCalled(grid, event) {
        this.hideContextMenu(menuDiv);

        if (this.next) {
            this.next.onApiDestroyCalled(grid, event);
        }
    },

    handleCanvasOutsideMouseDown: function handleCanvasOutsideMouseDown(grid, event) {
        this.hideContextMenu(menuDiv);

        if (this.next) {
            this.next.handleCanvasOutsideMouseDown(grid, event);
        }
    },

    /**
     * @memberOf ContextMenu.prototype
     * @param {Hypergrid} grid
     * @param {CellEvent} event
     */
    handleClick: function handleClick(grid, event) {
        this.hideContextMenu(menuDiv);

        var isCursorOverContextMenuIcon = this.overContextMenuCell(grid, event);

        var contextMenuIconRightX = event.bounds.x + event.bounds.width - grid.properties.contextMenuButtonRightMargin;
        var contextMenuIconLeftX = contextMenuIconRightX - grid.properties.contextMenuButtonIconPreferedWidth - grid.properties.contextMenuButtonPadding * 2;

        if (isCursorOverContextMenuIcon) {
            var contextMenu = grid.behavior.getCellProperties(event).cellContextMenu || grid.properties.cellContextMenu;
            if (event.isHeaderRow && grid.properties.headerContextMenu) {
                contextMenu = grid.properties.headerContextMenu;
            }

            var rightToLeft = event.primitiveEvent.detail.mouse.x + 200 >= window.innerWidth;
            var startX = rightToLeft ? contextMenuIconRightX : contextMenuIconLeftX;
            startX += grid.canvas.size.left;

            this.paintContextMenu(menuDiv, grid, event, contextMenu, startX, event.bounds.y + event.bounds.height + grid.canvas.size.top, rightToLeft);
        }

        if (this.next) {
            this.next.handleClick(grid, event);
        }
    },

    /**
     * @summary update selections if needed based on right click cell or header. if menu called on unselected item especially
     * @param {Hypergrid} grid
     * @param {CellEvent} event - the event details
     */
    updateSelections: function updateSelections(grid, event) {
        if (event.isHeaderRow && event.isHandleColumn && !event.isDataRow) {
            grid.clearSelections();
            grid.selectionModel.selectAllRows();
        } else if (event.isHeaderRow && !event.isColumnSelected) {
            // top row ow headers
            grid.clearSelections();
            grid.selectColumn(event.dataCell.x, event.dataCell.x);
        } else if (event.isHandleColumn && event.isDataRow && !event.isRowSelected) {
            // left row number headers
            grid.clearSelections();
            grid.selectRow(event.dataCell.y, event.dataCell.y);
        } else if (!event.isCellSelected) {
            // simple cell
            grid.clearSelections();
            grid.select(event.dataCell.x, event.dataCell.y, 0, 0);
        }
    },

    /**
     * @memberOf ContextMenu.prototype
     * @param {Hypergrid} grid
     * @param {CellEvent} event - the event details
     */
    handleContextMenu: function handleContextMenu(grid, event) {
        var contextMenu = void 0;
        if (event.isHeaderRow && grid.properties.headerContextMenu) {
            contextMenu = grid.properties.headerContextMenu;
        } else {
            contextMenu = grid.behavior.getCellProperties(event).cellContextMenu || grid.properties.cellContextMenu;
        }

        this.updateSelections(grid, event);

        // update cell menu for left column of row numbers
        if (event.isHandleColumn) {
            var point = grid.selectionModel.getFirstSelectedCellOfLastSelection();
            if (point) {
                contextMenu = grid.behavior.getCellProperties(point.x, point.y).cellContextMenu || grid.properties.cellContextMenu;
            }
        }

        var rightToLeft = event.primitiveEvent.detail.mouse.x + 200 >= window.innerWidth;
        this.paintContextMenu(menuDiv, grid, event, contextMenu, event.primitiveEvent.detail.mouse.x + grid.canvas.size.left, event.primitiveEvent.detail.mouse.y + grid.canvas.size.top + 25, rightToLeft);
        if (this.next) {
            this.next.handleContextMenu(grid, event);
        }
    },

    handleMouseMove: function handleMouseMove(grid, event) {
        // this.closeAllChilds(menuDiv);

        var stateChanged = false;
        var isCursorOverContextMenuIcon = this.overContextMenuCell(grid, event);
        var isPreviousCellEventExist = !!previousHoveredCellEvent;

        if (isCursorOverContextMenuIcon) {
            if (!previousHoveredCellEvent || event.bounds.x !== previousHoveredCellEvent.bounds.x || event.bounds.y !== previousHoveredCellEvent.bounds.y) {

                // CAUTION! If call setCellProperty method of cellEvent, renderer properties cache will not be
                // changed (so hover state of icon not be displayed before cell properties cache change)
                grid.behavior.setCellProperty(event.dataCell.x, event.dataCell.y, 'contextMenuIconIsHovered', true);
                event.contextMenuIconIsHovered = true;
                stateChanged = true;
                previousHoveredCellEvent = event;
                this.cursor = 'pointer';
            }
        } else {
            if (isPreviousCellEventExist) {

                // CAUTION! If call setCellProperty method of cellEvent, renderer properties cache will not be
                // changed (so hover state of icon not be displayed before cell properties cache change)
                grid.behavior.setCellProperty(previousHoveredCellEvent.dataCell.x, previousHoveredCellEvent.dataCell.y, 'contextMenuIconIsHovered', false);
                event.contextMenuIconIsHovered = false;
                previousHoveredCellEvent = null;
                stateChanged = true;
            }
            this.cursor = null;
        }

        if (stateChanged) {
            grid.repaint();
        }

        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle grid data added event
     * @param {Hypergrid} grid
     * @param {object} event
     * @private
     * @comment Not really private but was cluttering up all the feature doc pages.
     */
    handleDataAdded: function handleDataAdded(grid, event) {
        this.hideContextMenu(menuDiv);

        if (this.next) {
            this.next.handleDataAdded(grid, event);
        }
    },

    overContextMenuCell: function overContextMenuCell(grid, event) {
        var cellHasContextMenuItem = event.properties.showCellContextMenuIcon || event.rowProperties && event.rowProperties.showCellContextMenuIcon || event.cellOwnProperties && event.cellOwnProperties.showCellContextMenuIcon;

        if (!cellHasContextMenuItem) {
            return false;
        }

        var eventCellRightX = event.bounds.width;
        var contextMenuIconRightX = eventCellRightX - grid.properties.contextMenuButtonRightMargin;

        var typeSignWidth = 0;
        if (event.column.schema && event.column.schema.colTypeSign) {
            var gc = grid.canvas.gc,
                prevFontState = gc.cache.font,
                prevFillStyleState = gc.cache.fillStyle,
                config = event.properties;

            gc.cache.font = config.columnTypeSignFont;
            gc.cache.fillStyle = config.columnTypeSignColor;
            typeSignWidth = gc.measureText(event.column.schema.colTypeSign).width;
            typeSignWidth += config.contextMenuLeftSpaceToCutText;

            gc.cache.font = prevFontState;
            gc.cache.fillStyle = prevFillStyleState;
        }
        var contextMenuIconLeftX = contextMenuIconRightX - grid.properties.contextMenuButtonIconPreferedWidth - grid.properties.contextMenuButtonPadding * 2 - typeSignWidth;

        var contextMenuIconTopY = event.bounds.height / 2 - grid.properties.contextMenuButtonHeight / 2;
        var contextMenuIconBottomY = contextMenuIconTopY + grid.properties.contextMenuButtonHeight;

        return event.mousePoint.x <= contextMenuIconRightX && event.mousePoint.x >= contextMenuIconLeftX && event.mousePoint.y <= contextMenuIconBottomY && event.mousePoint.y >= contextMenuIconTopY;
    },

    /**
     * @memberOf ContextMenu.prototype
     * @desc utility method to paint context menu based on click event, and position params
     * @param {object} menuHolderDiv - object with Html element and related elements
     * @param {Hypergrid} grid
     * @param {CellEvent} event
     * @param {[]|function} items - menu items
     * @param {number} x - defines horizontal point of menu start
     * @param {number} y - defines vertical point of menu start
     * @param {boolean} rightToLeft - if true, menu will be displayed that way when it horizontally ends on X point
     */
    paintContextMenu: function paintContextMenu(menuHolderDiv, grid, event, items, x, y, rightToLeft) {
        var _this = this;

        this.hideContextMenu(menuHolderDiv);

        var menuListHolderDiv = document.createElement('div');

        menuListHolderDiv.setAttribute('class', 'ag-menu');

        menuHolderDiv.element.appendChild(menuListHolderDiv);

        if (typeof items === 'function') {
            items = items({ column: event.column, node: { data: event.dataRow, level: event.column.treeLevel }, value: event.value });
        }

        items.forEach(function (item) {
            _this.makeContextMenuItem(grid, event, menuHolderDiv, menuListHolderDiv, item);
        });

        if (grid.properties.applyContextMenuStyling) {
            if (grid.properties.contextMenuHolderStyle) {
                Object.assign(menuHolderDiv.element.style, grid.properties.contextMenuHolderStyle);
            }
            if (grid.properties.applyContextMenuStyling) {
                Object.assign(menuListHolderDiv.style, grid.properties.contextMenuListStyle);
            }
        }

        this.showContextMenu(menuHolderDiv, x, y, rightToLeft);
    },

    /**
     * @memberOf ContextMenu.prototype
     * @desc utility method to paint single menu item and append it to list that passed as param
     * @param {Hypergrid} grid
     * @param {CellEvent} event
     * @param {object} menuHolderDiv - object with Html element and related elements
     * @param {HTMLElement} menuListHolderDiv - HTML element that represents a list of menu items
     * @param {object} item - menu item object
     */
    makeContextMenuItem: function makeContextMenuItem(grid, event, menuHolderDiv, menuListHolderDiv, item) {
        if (item.hasOwnProperty('isShown')) {
            if (typeof item.isShown === 'function' && !item.isShown(event)) {
                return;
            } else if (!item.isShown) {
                return;
            }
        }

        var self = this;

        var menuOption = document.createElement('div');
        menuOption.style.display = 'block';

        menuOption.setAttribute('class', 'ag-menu-option');

        if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {
            var menuOptionIconSpan = document.createElement('span');
            menuOptionIconSpan.setAttribute('class', 'ag-menu-option-icon');
            menuOptionIconSpan.setAttribute('id', 'eIcon');
            menuOption.appendChild(menuOptionIconSpan);
            if (item.icon) {
                menuOptionIconSpan.innerHTML = item.icon;
            }

            var menuOptionNameSpan = document.createElement('span');
            menuOptionNameSpan.setAttribute('class', 'ag-menu-option-text');
            menuOptionNameSpan.setAttribute('id', 'eName');
            menuOptionNameSpan.innerHTML = item.title || item.name;
            menuOption.appendChild(menuOptionNameSpan);

            var menuOptionShortcutSpan = document.createElement('span');
            menuOptionShortcutSpan.setAttribute('class', 'context-menu-option-shortcut');
            menuOptionShortcutSpan.setAttribute('id', 'eShortcut');
            menuOption.appendChild(menuOptionShortcutSpan);

            var menuOptionPopupPointerSpan = document.createElement('span');
            menuOptionPopupPointerSpan.setAttribute('class', 'context-menu-option-popup-pointer');
            menuOptionPopupPointerSpan.setAttribute('id', 'ePopupPointer');

            if (item.childMenu && item.childMenu.length) {
                menuOptionPopupPointerSpan.innerHTML = grid.properties.contextMenuChildMenuArrowIconTag;
            }

            menuOption.appendChild(menuOptionPopupPointerSpan);

            menuOption.addEventListener('click', function (clickEvent) {
                if (item.action) {
                    grid.menuClick = true;
                    item.action(clickEvent, event);
                    delete grid.menuClick;
                }
                self.hideContextMenu(menuDiv);
            });

            if (grid.properties.applyContextMenuStyling) {
                if (grid.properties.contextMenuListOptionStyle) {
                    Object.assign(menuOption.style, grid.properties.contextMenuListOptionStyle);
                }

                if (grid.properties.contextMenuListOptionIconStyle) {
                    Object.assign(menuOptionIconSpan.style, grid.properties.contextMenuListOptionIconStyle);
                }

                if (grid.properties.contextMenuListOptionTextStyle) {
                    Object.assign(menuOptionNameSpan.style, grid.properties.contextMenuListOptionTextStyle);
                }

                if (grid.properties.contextMenuListOptionShortcutStyle) {
                    Object.assign(menuOptionShortcutSpan.style, grid.properties.contextMenuListOptionShortcutStyle);
                }

                if (grid.properties.contextMenuListOptionPopupPointerStyle) {
                    Object.assign(menuOptionPopupPointerSpan.style, grid.properties.contextMenuListOptionPopupPointerStyle);
                }
            }

            menuOption.addEventListener('mouseenter', function (event) {
                self.closeAllChilds(menuHolderDiv);
                if (item.childMenu && item.childMenu.length && !item.childMenuDiv) {
                    item.childMenuDiv = self.initializeContextMenuDiv();

                    menuHolderDiv.related.push(item.childMenuDiv);

                    var rectangle = menuOption.getBoundingClientRect();
                    var rightBorderX = rectangle.right;
                    if (rightBorderX + 200 > window.innerWidth) {
                        self.paintContextMenu(item.childMenuDiv, grid, event, item.childMenu, rectangle.left, rectangle.top, true);
                    } else {
                        self.paintContextMenu(item.childMenuDiv, grid, event, item.childMenu, rightBorderX, rectangle.top);
                    }
                }
            });

            menuOption.addEventListener('mouseover', function (event) {
                if (grid.properties.applyContextMenuStyling && grid.properties.contextMenuListOptionHoverStyle) {
                    Object.assign(menuOption.style, grid.properties.contextMenuListOptionHoverStyle);
                }
            });

            menuOption.addEventListener('mouseleave', function (event) {
                if (grid.properties.applyContextMenuStyling && grid.properties.contextMenuListOptionStyle) {
                    Object.assign(menuOption.style, grid.properties.contextMenuListOptionStyle);
                }

                if (item.childMenuDiv && !self.isElementContainsChild(item.childMenuDiv.element, event.relatedTarget)) {
                    self.hideContextMenu(item.childMenuDiv);
                    self.removeDOMElement(item.childMenuDiv.element);
                    item.childMenuDiv = null;
                }
            });
        } else if (item === 'separator') {
            menuOption.className = 'ag-menu-separator';

            var hrElement = document.createElement('hr');
            menuOption.appendChild(hrElement);

            if (grid.properties.applyContextMenuStyling) {
                if (grid.properties.contextMenuSeparatorStyle) {
                    Object.assign(hrElement.style, grid.properties.contextMenuSeparatorStyle);
                }
            }
        }

        menuListHolderDiv.appendChild(menuOption);
    },

    /**
     * @memberOf ContextMenu.prototype
     * @desc utility method to clear context menu HTML object and all related objects
     * @param {object} menuHolderDiv
     */
    clearContextMenu: function clearContextMenu(menuHolderDiv) {
        while (menuHolderDiv.element.firstChild) {
            menuHolderDiv.element.removeChild(menuHolderDiv.element.firstChild);
        }
        this.closeAllChilds(menuHolderDiv);
    },

    closeAllChilds: function closeAllChilds(menuHolderDiv) {
        while (menuHolderDiv.related.length) {
            this.hideContextMenu(menuHolderDiv.related[0]);
            menuHolderDiv.related.shift();
        }
    },

    /**
     * @memberOf ContextMenu.prototype
     * @desc utility method to start show context menu on defined point.
     * @desc Menu must be formed before it will be passed to this method
     * @param {object} menuHolderDiv - object with Html element and related elements
     * @param {number} x - defines horizontal point of menu start
     * @param {number} y - defines vertical point of menu start
     * @param {boolean} rightToLeft - if true, menu will be displayed that way when it horizontally ends on X point
     */
    showContextMenu: function showContextMenu(menuHolderDiv, x, y, rightToLeft) {
        menuHolderDiv.element.style.display = 'block';
        menuHolderDiv.element.style.top = y + 'px';

        var startX = x;
        if (rightToLeft) {
            startX = x - menuHolderDiv.element.offsetWidth;
        }
        menuHolderDiv.element.style.left = startX + 'px';
    },

    /**
     * @memberOf ContextMenu.prototype
     * @desc utility method to stop displaying context menu
     * @param {object} menuHolderDiv - object with Html element and related elements
     */
    hideContextMenu: function hideContextMenu(menuHolderDiv) {
        this.clearContextMenu(menuHolderDiv);
        menuHolderDiv.element.style.display = 'none';
    },

    /**
     * @memberOf ContextMenu.prototype
     * @desc utility method to remove HTML element from current DOM
     * @param {HTMLElement} element - HTML element that need to be removed from DOM
     */
    removeDOMElement: function removeDOMElement(element) {
        element.remove();
    },

    /**
     * @memberOf ContextMenu.prototype
     * @desc utility method to check is one HTML element contains another in any level
     * @param {HTMLElement} element - HTML element that need to be checked
     * @param {HTMLElement} concreteChild - HTML element that need to be found inside
     */
    isElementContainsChild: function isElementContainsChild(element, concreteChild) {
        if (element === concreteChild) {
            return true;
        }

        for (var child = element.firstChild; child; child = child.nextSibling) {
            if (child === concreteChild) {
                return true;
            }

            var isChildContainsElement = this.isElementContainsChild(child, concreteChild);
            if (isChildContainsElement) {
                return true;
            }
        }

        return false;
    }
});

module.exports = ContextMenu;

},{"./Feature":75}],75:[function(require,module,exports){
'use strict';

var Base = require('../Base');

/**
 * Instances of features are connected to one another to make a chain of responsibility for handling all the input to the hypergrid.
 * @constructor
 */
var Feature = Base.extend('Feature', {

    /**
     * the next feature to be given a chance to handle incoming events
     * @type {Feature}
     * @default null
     * @memberOf Feature.prototype
     */
    next: null,

    /**
     * a temporary holding field for my next feature when I'm in a disconnected state
     * @type {Feature}
     * @default null
     * @memberOf Feature.prototype
     */
    detached: null,

    /**
     * the cursor I want to be displayed
     * @type {string}
     * @default null
     * @memberOf Feature.prototype
     */
    cursor: null,

    /**
     * the cell location where the cursor is currently
     * @type {Point}
     * @default null
     * @memberOf Feature.prototype
     */
    currentHoverCell: null,

    /**
     * @memberOf Feature.prototype
     * @desc set my next field, or if it's populated delegate to the feature in my next field
     * @param {Feature} nextFeature - this is how we build the chain of responsibility
     * @private
     * @comment Not really private but was cluttering up all the feature doc pages.
     */
    setNext: function setNext(nextFeature) {
        if (this.next) {
            this.next.setNext(nextFeature);
        } else {
            this.next = nextFeature;
            this.detached = nextFeature;
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc disconnect my child
     */
    detachChain: function detachChain() {
        this.next = null;
    },

    /**
     * @memberOf Feature.prototype
     * @desc reattach my child from the detached reference
     */
    attachChain: function attachChain() {
        this.next = this.detached;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle mouse move down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private
     * @comment Not really private but was cluttering up all the feature doc pages.
     */
    handleMouseMove: function handleMouseMove(grid, event) {
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle grid data added event
     * @param {Hypergrid} grid
     * @param {object} event
     * @private
     * @comment Not really private but was cluttering up all the feature doc pages.
     */
    handleDataAdded: function handleDataAdded(grid, event) {
        if (this.next) {
            this.next.handleDataAdded(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private
     * @comment Not really private but was cluttering up all the feature doc pages.
     */
    handleMouseExit: function handleMouseExit(grid, event) {
        if (this.next) {
            this.next.handleMouseExit(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private
     * @comment Not really private but was cluttering up all the feature doc pages.
     */
    handleMouseEnter: function handleMouseEnter(grid, event) {
        if (this.next) {
            this.next.handleMouseEnter(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private
     * @comment Not really private but was cluttering up all the feature doc pages.
     */
    handleMouseDown: function handleMouseDown(grid, event) {
        if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private
     * @comment Not really private but was cluttering up all the feature doc pages.
     */
    onApiDestroyCalled: function onApiDestroyCalled(grid, event) {
        if (this.next) {
            this.next.onApiDestroyCalled(grid, event);
        }
    },

    handleCanvasOutsideMouseDown: function handleCanvasOutsideMouseDown(grid, event) {
        if (this.next) {
            this.next.handleCanvasOutsideMouseDown(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private
     * @comment Not really private but was cluttering up all the feature doc pages.
     */
    handleMouseUp: function handleMouseUp(grid, event) {
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private
     * @comment Not really private but was cluttering up all the feature doc pages.
     */
    handleKeyDown: function handleKeyDown(grid, event) {
        if (this.next) {
            this.next.handleKeyDown(grid, event);
        } else {
            return true;
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private
     * @comment Not really private but was cluttering up all the feature doc pages.
     */
    handleKeyUp: function handleKeyUp(grid, event) {
        if (this.next) {
            this.next.handleKeyUp(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private
     * @comment Not really private but was cluttering up all the feature doc pages.
     */
    handleWheelMoved: function handleWheelMoved(grid, event) {
        if (this.next) {
            this.next.handleWheelMoved(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private
     * @comment Not really private but was cluttering up all the feature doc pages.
     */
    handleDoubleClick: function handleDoubleClick(grid, event) {
        if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private
     * @comment Not really private but was cluttering up all the feature doc pages.
     */
    handleClick: function handleClick(grid, event) {
        if (this.next) {
            this.next.handleClick(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private
     * @comment Not really private but was cluttering up all the feature doc pages.
     */
    handleMouseDrag: function handleMouseDrag(grid, event) {
        if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private
     * @comment Not really private but was cluttering up all the feature doc pages.
     */
    handleContextMenu: function handleContextMenu(grid, event) {
        if (this.next) {
            this.next.handleContextMenu(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc toggle the column picker
     * @private
     * @comment Not really private but was cluttering up all the feature doc pages.
     */
    moveSingleSelect: function moveSingleSelect(grid, x, y) {
        if (this.next) {
            this.next.moveSingleSelect(grid, x, y);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedRow: function isFirstFixedRow(grid, event) {
        return event.gridCell.y < 1;
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedColumn: function isFirstFixedColumn(grid, event) {
        return event.gridCell.x === 0;
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private
     * @comment Not really private but was cluttering up all the feature doc pages.
     */
    setCursor: function setCursor(grid) {
        if (this.next) {
            this.next.setCursor(grid);
        }
        if (this.cursor) {
            grid.beCursor(this.cursor);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private
     * @comment Not really private but was cluttering up all the feature doc pages.
     */
    initializeOn: function initializeOn(grid) {
        if (this.next) {
            this.next.initializeOn(grid);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private
     * @comment Not really private but was cluttering up all the feature doc pages.
     */
    handleGridRendered: function handleGridRendered(grid, event) {
        if (this.next) {
            this.next.handleGridRendered(grid, event);
        }
    },

    handleDataShapeChanged: function handleDataShapeChanged(grid, event) {
        if (this.next) {
            this.next.handleGridRendered(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private
     */
    handleColumnResizedEvent: function handleColumnResizedEvent(grid, event) {
        if (this.next) {
            this.next.handleColumnResizedEvent(grid, event);
        }
    }
});

module.exports = Feature;

},{"../Base":17}],76:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 */
var Filters = Feature.extend('Filters', {

    /**
     * Navigate away from the filter cell when:
     * 1. Coming from a cell editor (`event.detail.editor` defined).
     * 2. The cell editor was for a filter cell.
     * 3. The key (`event.detail.char) maps (through {@link module:defaults.navKeyMap|navKeyMap}) to one of:
     *    * `'UP'` or `'DOWN'` - Selects first visible data cell under filter cell.
     *    * `'LEFT'` - Opens filter cell editor in previous filterable column; if nonesuch, selects first visible data cell under filter cell.
     *    * `'RIGHT'` - Opens filter cell editor in next filterable column; if nonesuch, selects first visible data cell under filter cell.
     */
    handleKeyDown: function handleKeyDown(grid, event) {
        var cellEvent,
            mappedNavKey,
            handler,
            detail = event.detail;

        if (detail.editor) {
            cellEvent = detail.editor.event;
            if (cellEvent.isFilterCell) {
                mappedNavKey = cellEvent.properties.mappedNavKey(detail.char);
                handler = this['handle' + mappedNavKey];
            }
        }

        if (handler) {
            handler.call(this, grid, detail);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    handleLEFT: function handleLEFT(grid, detail) {
        moveLaterally(grid, detail, -1);
    },
    handleRIGHT: function handleRIGHT(grid, detail) {
        moveLaterally(grid, detail, +1);
    },
    handleUP: moveDown,
    handleDOWN: moveDown,

    handleDoubleClick: function handleDoubleClick(grid, event) {
        if (event.isFilterCell) {
            grid.onEditorActivate(event);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    handleClick: function handleClick(grid, event) {
        if (event.isFilterCell) {
            grid.onEditorActivate(event);
        } else if (this.next) {
            this.next.handleClick(grid, event);
        }
    }

});

function moveLaterally(grid, detail, deltaX) {
    var cellEvent = detail.editor.event,
        gridX = cellEvent.visibleColumn.index,
        gridY = cellEvent.visibleRow.index,
        originX = gridX,
        C = grid.renderer.visibleColumns.length;

    cellEvent = new grid.behavior.CellEvent(); // redefine so we don't reset the original below

    while ((gridX = (gridX + deltaX + C) % C) !== originX && cellEvent.resetGridXY(gridX, gridY)) {
        if (cellEvent.properties.filterable) {
            // Select previous or next filterable column's filter cell
            grid.editAt(cellEvent);
            return;
        }
    }

    moveDown(grid, cellEvent);
}

function moveDown(grid, detail) {
    var cellEvent = detail.editor.event,
        gridX = cellEvent.visibleColumn.index;

    // Select first visible grid cell of this column
    grid.selectViewportCell(gridX, 0);
    grid.takeFocus();
}

module.exports = Filters;

},{"./Feature":75}],77:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

var commands = {
    PAGEDOWN: function PAGEDOWN(grid) {
        grid.pageDown();
    },
    PAGEUP: function PAGEUP(grid) {
        grid.pageUp();
    },
    PAGELEFT: function PAGELEFT(grid) {
        grid.pageLeft();
    },
    PAGERIGHT: function PAGERIGHT(grid) {
        grid.pageRight();
    }
};

/**
 * @constructor
 */
var KeyPaging = Feature.extend('KeyPaging', {

    /**
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf KeyPaging.prototype
     */
    handleKeyDown: function handleKeyDown(grid, event) {
        var func = commands[event.detail.char];
        if (func) {
            func(grid);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    }

});

module.exports = KeyPaging;

},{"./Feature":75}],78:[function(require,module,exports){
/* eslint-env browser */
'use strict';

var Feature = require('./Feature');

var detailsHolderElement;
var detailsShownOnDataCell = null;

var detailsHideTimeout = null;

/**
 * @constructor
 * @extends Feature
 */
var LinkDetails = Feature.extend('LinkDetails', {
    /**
     * @memberOf LinkDetails.prototype
     * @desc initial method of an feature
     * @param {Hypergrid} grid
     */
    initializeOn: function initializeOn(grid) {
        if (!detailsHolderElement) {
            detailsHolderElement = this.initializeLinkDetailsDiv();
        }

        if (this.next) {
            this.next.initializeOn(grid);
        }
    },
    /**
     * @memberOf LinkDetails.prototype
     * @desc utility method to initialize div, that contains link info
     */
    initializeLinkDetailsDiv: function initializeLinkDetailsDiv() {
        var holderElement = document.createElement('a');

        holderElement.style.display = 'none';
        holderElement.setAttribute('class', 'fin-link-details-div');

        document.body.appendChild(holderElement);

        return holderElement;
    },

    onApiDestroyCalled: function onApiDestroyCalled(grid, event) {
        this.hideLinkDetails(grid, detailsHolderElement);

        if (this.next) {
            this.next.onApiDestroyCalled(grid, event);
        }
    },

    handleCanvasOutsideMouseDown: function handleCanvasOutsideMouseDown(grid, event) {
        this.hideLinkDetails(grid, detailsHolderElement);

        if (this.next) {
            this.next.handleCanvasOutsideMouseDown(grid, event);
        }
    },

    /**
     * @memberOf LinkDetails.prototype
     * @param {Hypergrid} grid
     * @param {CellEvent} event
     */
    handleClick: function handleClick(grid, event) {
        if (detailsShownOnDataCell && (detailsShownOnDataCell.x !== event.gridCell.x || detailsShownOnDataCell.y !== event.gridCell.y)) {
            this.hideLinkDetails(grid, detailsHolderElement);
        }

        if (this.next) {
            this.next.handleClick(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private
     * @comment Not really private but was cluttering up all the feature doc pages.
     */
    handleWheelMoved: function handleWheelMoved(grid, event) {
        this.hideLinkDetails(grid, detailsHolderElement);

        if (this.next) {
            this.next.handleWheelMoved(grid, event);
        }
    },

    handleMouseMove: function handleMouseMove(grid, event) {
        if (!detailsShownOnDataCell || detailsShownOnDataCell.x !== event.gridCell.x || detailsShownOnDataCell.y !== event.gridCell.y) {
            if (event.properties.link || event.properties.detectLinksPermanently && event.isValueUrl) {
                this.hideLinkDetails(grid, detailsHolderElement);

                var linkToDisplay = event.properties.link ? event.properties.link : event.value;

                this.paintLinkDetails(detailsHolderElement, grid, linkToDisplay, event.bounds);

                detailsShownOnDataCell = event.gridCell;
            } else if (detailsShownOnDataCell) {
                this.hideLinkDetailsTimeouted(grid, detailsHolderElement);
            }
        }

        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    },

    /**
     * @memberOf LinkDetails.prototype
     * @desc utility method to paint context menu based on click event, and position params
     * @param {HTMLElement} linkDetailsHolderElement - Html element that contains details
     * @param {Hypergrid} grid
     * @param {array|string} linkValue - link that need to be detailed
     * @param {object} cellBounds - defines bounds of cell cell
     */
    paintLinkDetails: function paintLinkDetails(linkDetailsHolderElement, grid, linkValue, cellBounds) {
        var _this = this;

        this.hideLinkDetails(grid, linkDetailsHolderElement);

        var links = linkValue;
        if (!Array.isArray(linkValue)) {
            links = [linkValue];
        }

        links.forEach(function (l) {
            var outerDiv = document.createElement('div');
            var detailsLink = document.createElement('a');

            if (grid.properties.linkDetailsAnchorStyle) {
                Object.assign(detailsLink.style, grid.properties.linkDetailsAnchorStyle);
            }

            linkDetailsHolderElement.href = l;
            linkDetailsHolderElement.target = '_blank';

            detailsLink.href = l;
            var truncatedLink = _this.truncateString(l, grid.properties.linkDetailsMaxStringLength, '...');
            detailsLink.text = truncatedLink + '  ';
            detailsLink.target = '_blank';

            var detailsLinkIcon = document.createElement('i');
            detailsLinkIcon.setAttribute('class', 'fa fa-external-link');

            detailsLink.appendChild(detailsLinkIcon);

            outerDiv.appendChild(detailsLink);
            linkDetailsHolderElement.appendChild(outerDiv);
            linkDetailsHolderElement.onmouseover = function () {
                Object.assign(linkDetailsHolderElement.style, grid.properties.linkDetailsHoveredStyle);
            };
            linkDetailsHolderElement.onmouseout = function () {
                Object.assign(linkDetailsHolderElement.style, grid.properties.linkDetailsStyle);
            };
        });

        if (grid.properties.linkDetailsStyle) {
            Object.assign(linkDetailsHolderElement.style, grid.properties.linkDetailsStyle);
        }

        this.showLinkDetails(grid, linkDetailsHolderElement, cellBounds);
    },

    /**
     * @memberOf LinkDetails.prototype
     * @desc utility method to start show context menu on defined point.
     * @desc Menu must be formed before it will be passed to this method
     * @param {Hypergrid} grid
     * @param {HTMLElement} linkDetailsHolderElement - Html element that contains details
     * @param {object} cellBounds - defines bounds of cell cell
     */
    showLinkDetails: function showLinkDetails(grid, linkDetailsHolderElement, cellBounds) {
        linkDetailsHolderElement.style.display = 'block';

        var holderComputedStyles = window.getComputedStyle(linkDetailsHolderElement);

        var startY = void 0,
            startX = void 0,
            bottomToTop = true;

        var holderHeight = holderComputedStyles.height.replace('px', '');
        if (cellBounds.y < holderHeight && Number(cellBounds.y) + Number(holderHeight) < window.innerHeight) {
            bottomToTop = false;
        }

        if (bottomToTop) {
            startY = cellBounds.y + grid.canvas.size.top - holderComputedStyles.height.replace('px', '');
            startX = cellBounds.x + grid.canvas.size.left + grid.properties.gridLinesWidth;
        } else {
            startY = cellBounds.y + cellBounds.height + grid.canvas.size.top;
            startX = cellBounds.x + grid.canvas.size.left + grid.properties.gridLinesWidth;
        }

        linkDetailsHolderElement.style.top = startY + 'px';
        linkDetailsHolderElement.style.left = startX + 'px';
    },

    /**
     * @memberOf LinkDetails.prototype
     * @desc utility method to stop displaying context menu
     * @param {Hypergrid} grid
     * @param {object} detailsHolderElement - Html element that contains link info
     */
    hideLinkDetails: function hideLinkDetails(grid, detailsHolderElement) {
        detailsHolderElement.innerHTML = '';
        detailsHolderElement.style.display = 'none';
        detailsShownOnDataCell = null;
        if (detailsHideTimeout) {
            clearTimeout(detailsHideTimeout);
            detailsHideTimeout = null;
        }
    },

    /**
     * @memberOf LinkDetails.prototype
     * @desc utility method to stop displaying context menu
     * @param {Hypergrid} grid
     * @param {object} detailsHolderElement - Html element that contains link info
     */
    hideLinkDetailsTimeouted: function hideLinkDetailsTimeouted(grid, detailsHolderElement) {
        var _this2 = this;

        if (!detailsHideTimeout) {
            detailsHideTimeout = setTimeout(function () {
                _this2.hideLinkDetails(grid, detailsHolderElement);
            }, grid.properties.linkDetailsHideTimeout);
        }
    },

    /**
     * @memberOf LinkDetails.prototype
     * @desc utility method to remove HTML element from current DOM
     * @param {HTMLElement} element - HTML element that need to be removed from DOM
     */
    removeDOMElement: function removeDOMElement(element) {
        element.remove();
    },

    /**
     * @memberOf LinkDetails.prototype
     * @desc utility method to truncate string. If string greater, than value,
     * central part of string will be replaced with separator
     * @param fullStr
     * @param strLen
     * @param separator
     */
    truncateString: function truncateString(fullStr, strLen, separator) {
        if (fullStr.length <= strLen) {
            return fullStr;
        }

        separator = separator || '...';

        var sepLen = separator.length,
            charsToShow = strLen - sepLen,
            frontChars = Math.ceil(charsToShow / 2),
            backChars = Math.floor(charsToShow / 2);

        return fullStr.substr(0, frontChars) + separator + fullStr.substr(fullStr.length - backChars);
    }
});

module.exports = LinkDetails;

},{"./Feature":75}],79:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 */
var OnHover = Feature.extend('OnHover', {

    /**
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf OnHover.prototype
     */
    handleMouseMove: function handleMouseMove(grid, event) {
        var hoverCell = grid.hoverCell;
        if (!event.gridCell.equals(hoverCell)) {
            if (hoverCell) {
                this.handleMouseExit(grid, hoverCell);
            }
            this.handleMouseEnter(grid, event);
            grid.setHoverCell(event);
        } else if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    }

});

module.exports = OnHover;

},{"./Feature":75}],80:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

var Feature = require('./Feature');

var rowFixationDragger;
var rowFixationDraggerCTX;
var rowFixationPlaceholder;
var rowFixationPlaceholderCTX;

var GRAB = ['grab', '-moz-grab', '-webkit-grab'],
    GRABBING = ['grabbing', '-moz-grabbing', '-webkit-grabbing'];

/**
 * @constructor
 * @extends Feature
 */
var RowFixation = Feature.extend('RowFixation', {
    /**
     * @type {boolean}
     * @memberOf RowFixation.prototype
     */
    dragging: false,

    /**
     * an offset to position the dragger from the cursor
     * @type {number}
     * @memberOf RowFixation.prototype
     */
    dragOffset: 0,

    /**
     * current position (index) of an placeholder
     * @type {number}
     * @memberOf RowFixation.prototype
     */
    currentPlaceholderRowIndex: -1,

    /**
     * @memberOf RowFixation.prototype
     * @desc fired every time when grid rendered
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleGridRendered: function handleGridRendered(grid, event) {
        this.initializeAnimationSupport(grid);

        if (this.next) {
            this.next.handleGridRendered(grid);
        }
    },
    /**
     * @memberOf RowFixation.prototype
     * @desc initialize animation support on the grid
     * @param {Hypergrid} grid
     */
    initializeAnimationSupport: function initializeAnimationSupport(grid) {
        this.createOrUpdateDragger(grid);
        if (!rowFixationPlaceholder) {
            rowFixationPlaceholder = document.createElement('canvas');
            rowFixationPlaceholder.setAttribute('width', '0px');
            rowFixationPlaceholder.setAttribute('height', '0px');
            rowFixationPlaceholder.style.position = 'absolute';

            document.body.appendChild(rowFixationPlaceholder);
            rowFixationPlaceholderCTX = rowFixationPlaceholder.getContext('2d', { alpha: false });
        }
    },

    /**
     * @memberOf RowFixation.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function handleMouseDrag(grid, event) {
        if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf RowFixation.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function handleMouseDown(grid, event) {
        if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf RowFixation.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function handleMouseUp(grid, event) {
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf RowFixation.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function handleMouseMove(grid, event) {
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    },

    /**
     * @memberOf RowFixation.prototype
     * @desc utility function to move dragger based on current cursor position
     * @param {Hypergrid} grid
     * @param {number} x
     * @param {number} y
     * @param {boolean?} movePlaceholderNeeded
     */
    moveDragger: function moveDragger(grid, x, y, movePlaceholderNeeded) {
        movePlaceholderNeeded = typeof movePlaceholderNeeded !== 'undefined' ? movePlaceholderNeeded : true;
        grid.log(y + grid.canvas.size.top);
        rowFixationDragger.style.top = y + grid.canvas.size.top + 'px';

        if (movePlaceholderNeeded) {
            var nearestRowIndex = this.getNearestRowIndex(grid, x, y);
            if (typeof nearestRowIndex !== 'undefined' && nearestRowIndex !== this.currentPlaceholderRowIndex) {
                this.movePlaceholderTo(grid, nearestRowIndex);
                this.currentPlaceholderRowIndex = nearestRowIndex;
            }
        }
    },

    /**
     * @memberOf RowFixation.prototype
     * @desc utility function to move placeholder to the start coordinates of column
     * @param {Hypergrid} grid
     * @param {number} column
     */
    movePlaceholderTo: function movePlaceholderTo(grid, column) {
        var newStartY = this.getStartByRowIndex(grid, column);

        rowFixationPlaceholder.style.top = newStartY + 'px';
    },

    /**
     * @memberOf RowFixation.prototype
     * @desc create the placeholder based on current count of fixed columns
     * @param {Hypergrid} grid
     */
    createPlaceholder: function createPlaceholder(grid) {
        var fixationLineWidth = grid.properties.fixedLinesVWidth;
        var startY = this.getStartByFixedRowsCount(grid);
        var rowHeaderWidth = grid.renderer.visibleColumns[0].left;
        var gridWidth = grid.div.clientWidth;

        var hdpiRatio = grid.getHiDPI(rowFixationPlaceholderCTX);
        var location = grid.div.getBoundingClientRect();

        rowFixationPlaceholder.setAttribute('width', gridWidth * hdpiRatio + 'px');
        rowFixationPlaceholder.setAttribute('height', fixationLineWidth * hdpiRatio + 'px');
        rowFixationPlaceholder.style.position = 'fixed';
        rowFixationPlaceholder.style.top = startY + 'px';
        rowFixationPlaceholder.style.left = location.left + 'px';
        rowFixationPlaceholder.style.display = 'inline';

        rowFixationPlaceholderCTX.clearRect(0, 0, gridWidth, fixationLineWidth);
        rowFixationPlaceholderCTX.fillStyle = grid.properties.rowFixationPlaceholderHeaderColor;
        rowFixationPlaceholderCTX.fillRect(0, 0, rowHeaderWidth, fixationLineWidth);
        rowFixationPlaceholderCTX.fillStyle = grid.properties.rowFixationPlaceholderBodyColor;
        rowFixationPlaceholderCTX.fillRect(rowHeaderWidth, 0, gridWidth, fixationLineWidth);

        this.movePlaceholderTo(grid, grid.getFixedRowCount());
    },

    /**
     * @memberOf RowFixation.prototype
     * @desc utility function for setting cross browser css properties
     * @param {HTMLElement} element - descripton
     * @param {string} property - the property
     * @param {string} value - the value to assign
     */
    setCrossBrowserProperty: function setCrossBrowserProperty(element, property, value) {
        var uProperty = property[0].toUpperCase() + property.substr(1);
        this.setProp(element, 'webkit' + uProperty, value);
        this.setProp(element, 'Moz' + uProperty, value);
        this.setProp(element, 'ms' + uProperty, value);
        this.setProp(element, 'O' + uProperty, value);
        this.setProp(element, property, value);
    },

    /**
     * @memberOf RowFixation.prototype
     * @desc create the dragged column based on current count of fixed columns
     * @param {Hypergrid} grid
     */
    createOrUpdateDragger: function createOrUpdateDragger(grid) {
        if (this.dragging) {
            return;
        }

        if (!rowFixationDragger) {
            rowFixationDragger = document.createElement('canvas');
            rowFixationDraggerCTX = rowFixationDragger.getContext('2d', { alpha: false });
            document.body.appendChild(rowFixationDragger);
        }

        var fixationLineWidth = this.fixationLineWidth = grid.properties.fixedLinesVWidth;
        var startY = this.getStartByFixedRowsCount(grid);

        var rowHeaderWidth = grid.renderer.visibleColumns[0].left;
        var gridWidth = grid.div.clientWidth;

        var hdpiRatio = grid.getHiDPI(rowFixationDraggerCTX);
        var location = grid.div.getBoundingClientRect();

        rowFixationDragger.setAttribute('width', gridWidth * hdpiRatio + 'px');
        rowFixationDragger.setAttribute('height', fixationLineWidth * hdpiRatio + 'px');
        rowFixationDragger.style.position = 'fixed';
        rowFixationDragger.style.top = startY + 'px';
        rowFixationDragger.style.left = location.left + 'px';
        rowFixationDragger.style.display = 'inline';

        rowFixationDraggerCTX.clearRect(0, 0, gridWidth, fixationLineWidth);
        rowFixationDraggerCTX.fillStyle = grid.properties.rowFixationDraggerHeaderInactiveColor;
        rowFixationDraggerCTX.fillRect(0, 0, rowHeaderWidth, fixationLineWidth);

        var self = this;
        rowFixationDragger.onmouseenter = function (event) {
            if (!self.dragging) {
                event.stopImmediatePropagation();
                event.preventDefault();
                self.cursor = GRAB;

                rowFixationDraggerCTX.clearRect(0, 0, gridWidth, fixationLineWidth);
                rowFixationDraggerCTX.fillStyle = grid.properties.rowFixationDraggerHeaderHoveredColor;
                rowFixationDraggerCTX.fillRect(0, 0, rowHeaderWidth, fixationLineWidth);
            }
        };

        rowFixationDragger.onmouseleave = function () {
            if (!self.dragging) {
                event.stopImmediatePropagation();
                event.preventDefault();

                self.cursor = null;

                rowFixationDraggerCTX.clearRect(0, 0, gridWidth, fixationLineWidth);
                rowFixationDraggerCTX.fillStyle = grid.properties.rowFixationDraggerHeaderInactiveColor;
                rowFixationDraggerCTX.fillRect(0, 0, rowHeaderWidth, fixationLineWidth);
            }
        };

        rowFixationDragger.onmousedown = function (event) {
            event.stopImmediatePropagation();
            event.preventDefault();
            this.cursor = GRABBING;

            self.dragging = true;

            grid.scrollToMakeVisible(grid.getFixedColumnCount(), grid.getFixedRowCount() - 1);

            self.createPlaceholder(grid);
            self.dragOffset = rowFixationDragger.getBoundingClientRect().top;

            rowFixationDraggerCTX.clearRect(0, 0, gridWidth, fixationLineWidth);
            rowFixationDraggerCTX.fillStyle = grid.properties.rowFixationDraggerHeaderDraggingColor;
            rowFixationDraggerCTX.fillRect(0, 0, rowHeaderWidth, fixationLineWidth);
            rowFixationDraggerCTX.fillStyle = grid.properties.rowFixationDraggerBodyDraggingColor;
            rowFixationDraggerCTX.fillRect(rowHeaderWidth, 0, gridWidth, fixationLineWidth);

            document.onmousemove = function (e) {
                var newY = e.clientY - grid.properties.fixedLinesVWidth / 2 - grid.canvas.size.top;

                self.moveDragger(grid, e.clientX, newY);
            };
            document.onmouseup = function (e) {
                document.onmousemove = null;
                document.onmouseup = null;

                if (self.dragging) {
                    self.cursor = null;
                    self.performFixation(grid);
                    grid.paintNow();
                    self.moveDragger(grid, 0, self.getStartByFixedRowsCount(grid) - grid.canvas.size.top, false);
                }
                self.dragging = false;
                self.cursor = null;

                rowFixationDraggerCTX.clearRect(0, 0, gridWidth, fixationLineWidth);
                rowFixationDraggerCTX.fillStyle = grid.properties.rowFixationDraggerHeaderInactiveColor;
                rowFixationDraggerCTX.fillRect(0, 0, rowHeaderWidth, fixationLineWidth);
            };
        };
    },

    /**
     * @memberOf RowFixation.prototype
     * @desc utility method to get start position based on current fixed rows count
     * @param {Hypergrid} grid
     */
    getStartByFixedRowsCount: function getStartByFixedRowsCount(grid) {
        return this.getStartByRowIndex(grid, grid.properties.fixedRowCount + 1);
    },

    /**
     * @memberOf RowFixation.prototype
     * @desc utility method to get start position based on rowIndex
     * @param {Hypergrid} grid
     * @param {number} rowIndex
     */
    getStartByRowIndex: function getStartByRowIndex(grid, rowIndex) {
        var headerRowCount = grid.getHeaderRowCount();
        if (rowIndex < headerRowCount) {
            rowIndex = headerRowCount;
        }

        var res;
        if (rowIndex > 1) {
            // 1 because of headers
            var row = grid.renderer.visibleRows[rowIndex - 1];
            if (!row) {
                row = grid.renderer.visibleRows[0];
            }
            res = row ? row.bottom : 0;
        } else {
            res = grid.renderer.visibleRows[0].bottom - this.fixationLineWidth + 2;
        }

        return res + grid.canvas.size.top;
    },
    /**
     * @memberOf RowFixation.prototype
     * @desc utility method to set grid options when dragging ends
     * @param {Hypergrid} grid
     */
    performFixation: function performFixation(grid) {
        var currentFixedRowCount = grid.properties.fixedRowCount;
        rowFixationPlaceholder.style.display = 'none';

        if (this.currentPlaceholderRowIndex < 0) {
            return;
        }

        var newFixedRowValue = this.currentPlaceholderRowIndex - grid.getHeaderRowCount();

        grid.addProperties({
            fixedRowCount: newFixedRowValue
        });

        grid.fireSyntheticOnFixedRowCountChangedEvent(currentFixedRowCount, newFixedRowValue);
    },

    /**
     * @memberOf RowFixation.prototype
     * @desc utility function to get nearest possible index from an cursor position
     * @param {Hypergrid} grid
     * @param {number} x - horizontal cursor position
     * @param {number} y - horizontal cursor position
     */
    getNearestRowIndex: function getNearestRowIndex(grid, x, y) {
        var cellUnderCursor = grid.renderer.getGridCellFromMousePoint({ x: x, y: y });
        var rowUnderCursorIndex = cellUnderCursor.cellEvent.visibleRow.rowIndex;
        var visibleRows = grid.renderer.visibleRows;

        var max = grid.getVisibleRowsCount();
        var columnStartY = visibleRows[Math.min(max, rowUnderCursorIndex)].top;
        var columnEndY = visibleRows[Math.min(max, rowUnderCursorIndex)].bottom;

        var res = rowUnderCursorIndex;

        if (!(Math.abs(columnStartY - y) < Math.abs(columnEndY - y))) {
            res += 1;
        }

        if (res >= visibleRows[visibleRows.length - 2].columnIndex) {
            res = visibleRows[visibleRows.length - 3].columnIndex;
        }

        var headerRowCount = grid.getHeaderRowCount();

        if (res <= headerRowCount) {
            res = headerRowCount;
        }
        return res;
    },

    setProp: function setProp(element, property, value) {
        if (property in element.style) {
            element.style[property] = value;
        }
    }
});

module.exports = RowFixation;

},{"./Feature":75}],81:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 */
var RowSelection = Feature.extend('RowSelection', {

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {Point}
     * @default null
     * @memberOf RowSelection.prototype
     */
    currentDrag: null,

    /**
     * The cell coordinates of the where the mouse pointer is during a drag operation.
     * @type {Object}
     * @default null
     * @memberOf RowSelection.prototype
     */
    lastDragCell: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf RowSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf RowSelection.prototype
     */
    sbAutoStart: 0,

    dragArmed: false,

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function handleMouseUp(grid, event) {
        if (this.dragArmed) {
            this.dragArmed = false;
            grid.fireSyntheticRowSelectionChangedEvent();
        } else if (this.dragging) {
            this.dragging = false;
            grid.fireSyntheticRowSelectionChangedEvent();
        } else if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function handleMouseDown(grid, event) {
        var rowSelectable = grid.properties.rowSelection && !event.primitiveEvent.detail.isRightClick && grid.properties.showRowNumbers && event.isHandleColumn;

        if (rowSelectable && event.isHeaderHandle) {
            //global row selection
            grid.toggleSelectAllRows();
        } else if (rowSelectable && event.isDataRow) {
            // if we are in the fixed area, do not apply the scroll values
            this.dragArmed = true;
            this.extendSelection(grid, event.dataCell.y, event.primitiveEvent.detail.keys);
        } else if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function handleMouseDrag(grid, event) {
        if (this.dragArmed && grid.properties.rowSelection && !event.primitiveEvent.detail.isRightClick) {
            //if we are in the fixed area do not apply the scroll values
            this.lastDragRow = event.dataCell.y;
            this.dragging = true;
            this.currentDrag = event.primitiveEvent.detail.mouse;
            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, this.lastDragRow, event.primitiveEvent.detail.keys);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function handleKeyDown(grid, event) {
        var handler;
        if (grid.getLastSelectionType() === 'row' && (handler = this['handle' + event.detail.char])) {
            handler.call(this, grid, event.detail);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Handle a mousedrag selection
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function handleMouseDragCellSelection(grid, y, keys) {
        var mouseY = grid.getMouseDown().y;

        grid.clearMostRecentRowSelection();

        grid.selectRow(mouseY, y);
        grid.setDragExtent(grid.newPoint(0, y - mouseY));

        grid.repaint();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function checkDragScroll(grid, mouse) {
        if (grid.properties.scrollingEnabled && grid.getDataBounds().contains(mouse)) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else {
            if (!grid.isScrollingNow()) {
                grid.setScrollingNow(true);
                this.scrollDrag(grid);
            }
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function scrollDrag(grid) {
        if (!grid.isScrollingNow()) {
            return;
        }

        var b = grid.getDataBounds(),
            yOffset;

        if (this.currentDrag.y < b.origin.y) {
            yOffset = -1;
        } else if (this.currentDrag.y > b.origin.y + b.extent.y) {
            yOffset = 1;
        }

        if (yOffset) {
            if (this.lastDragRow >= grid.getFixedRowCount()) {
                this.lastDragRow += yOffset;
            }
            grid.scrollBy(0, yOffset);
        }

        this.handleMouseDragCellSelection(grid, this.lastDragRow, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function extendSelection(grid, y, keys) {
        if (!grid.abortEditing()) {
            return;
        }

        var mouseY = grid.getMouseDown().y,
            hasSHIFT = keys.indexOf('SHIFT') !== -1;

        if (y < 0) {
            // outside of the grid?
            return; // do nothing
        }

        if (hasSHIFT) {
            grid.clearMostRecentRowSelection();
            grid.selectRow(y, mouseY);
            grid.setDragExtent(grid.newPoint(0, y - mouseY));
        } else {
            grid.toggleSelectRow(y, keys);
            grid.setMouseDown(grid.newPoint(0, y));
            grid.setDragExtent(grid.newPoint(0, 0));
        }

        grid.repaint();
    },

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function handleDOWNSHIFT(grid) {
        this.moveShiftSelect(grid, 1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function handleUPSHIFT(grid) {
        this.moveShiftSelect(grid, -1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function handleLEFTSHIFT(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function handleRIGHTSHIFT(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function handleDOWN(grid) {
        this.moveSingleSelect(grid, 1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function handleUP(grid) {
        this.moveSingleSelect(grid, -1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function handleLEFT(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function handleRIGHT(grid) {
        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent()),
            maxColumns = grid.getColumnCount() - 1,
            newX = grid.getHScrollValue(),
            newY = mouseCorner.y;

        newX = Math.min(maxColumns, newX);

        grid.clearSelections();
        grid.select(newX, newY, 0, 0);
        grid.setMouseDown(grid.newPoint(newX, newY));
        grid.setDragExtent(grid.newPoint(0, 0));

        grid.repaint();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function getAutoScrollAcceleration() {
        var count = 1;
        var elapsed = this.getAutoScrollDuration() / 2000;
        count = Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
        return count;
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function setAutoScrollStartTime() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function pingAutoScroll() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function getAutoScrollDuration() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function moveShiftSelect(grid, offsetY) {
        var origin = grid.getMouseDown(),
            extent = grid.getDragExtent(),
            maxViewableRows = grid.renderer.visibleRows.length - 1,
            maxRows = grid.getRowCount() - 1;

        if (!grid.properties.scrollingEnabled) {
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var newY = extent.y + offsetY;

        newY = Math.min(maxRows - origin.y, Math.max(-origin.y, newY));

        grid.clearMostRecentRowSelection();
        grid.selectRow(origin.y, origin.y + newY);
        grid.setDragExtent(grid.newPoint(0, newY));

        if (grid.insureModelRowIsVisible(newY + origin.y, offsetY)) {
            this.pingAutoScroll();
        }

        grid.fireSyntheticRowSelectionChangedEvent();

        grid.repaint();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveSingleSelect: function moveSingleSelect(grid, offsetY) {
        var maxRows = grid.getRowCount() - 1,
            maxViewableRows = grid.getVisibleRowsCount() - 1,
            mouseCorner = grid.getMouseDown().plus(grid.getDragExtent()),
            newY = mouseCorner.y + offsetY;

        if (!grid.properties.scrollingEnabled) {
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        newY = Math.min(maxRows, Math.max(0, newY));

        grid.clearSelections();
        grid.selectRow(newY);
        grid.setMouseDown(grid.newPoint(0, newY));
        grid.setDragExtent(grid.newPoint(0, 0));

        if (grid.insureModelRowIsVisible(newY, offsetY)) {
            this.pingAutoScroll();
        }

        grid.fireSyntheticRowSelectionChangedEvent();
        grid.repaint();
    },

    isSingleRowSelection: function isSingleRowSelection() {
        return true;
    }

});

module.exports = RowSelection;

},{"./Feature":75}],82:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 */
var ThumbwheelScrolling = Feature.extend('ThumbwheelScrolling', {

    /**
     * @memberOf ThumbwheelScrolling.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleWheelMoved: function handleWheelMoved(grid, e) {
        if (!grid.properties.scrollingEnabled) {
            return;
        }

        var primEvent = e.primitiveEvent,
            deltaX = Math.sign(primEvent.wheelDeltaX || -primEvent.deltaX),
            deltaY = Math.sign(primEvent.wheelDeltaY || -primEvent.deltaY);

        if (deltaX || deltaY) {
            grid.scrollBy(-deltaX || 0, // 0 if NaN
            -deltaY || 0);
        }
    }

});

module.exports = ThumbwheelScrolling;

},{"./Feature":75}],83:[function(require,module,exports){
/* eslint-env browser */
'use strict';

var Feature = require('./Feature');

var tooltipDiv, fadeInInterval, fadeOutInterval;

/**
 * @constructor
 * @extends Feature
 */
var WarningTooltip = Feature.extend('WarningTooltip', {
    isMenuShown: false,

    /**
     * @memberOf WarningTooltip.prototype
     * @desc initialize context menu div
     */
    initializeWarningTooltipDiv: function initializeWarningTooltipDiv() {
        tooltipDiv = document.createElement('div');

        tooltipDiv.style.display = 'none';

        document.body.appendChild(tooltipDiv);

        return tooltipDiv;
    },

    handleMouseMove: function handleMouseMove(grid, event) {
        var stateChanged = false;
        var isCursorOverCollumnWarningIcon = this.overColumnWarningIcon(grid, event);
        var isCursorOverTotalWarningIcon = this.overTotalWarningIcon(grid, event);

        if (isCursorOverCollumnWarningIcon) {
            if (!this.isMenuShown) {
                var tooltipRightX = event.bounds.x + event.properties.cellPaddingLeft + grid.canvas.size.left + 8;
                var tooltipTopY = event.bounds.y + event.bounds.height + grid.canvas.size.top;
                this.paintWarningTooltip(grid, tooltipRightX, tooltipTopY, event.column.firstError.description, 'bottom');
            }
        } else if (isCursorOverTotalWarningIcon) {
            if (!this.isMenuShown) {
                var _tooltipRightX = event.bounds.x + event.bounds.width / 2 + event.properties.totalErrorsCountIconWidth / 2 + grid.canvas.size.left;
                var _tooltipTopY = event.bounds.y + event.bounds.height / 2 + grid.canvas.size.top;
                this.paintWarningTooltip(grid, _tooltipRightX, _tooltipTopY, grid.getFieldsErrorsMessage(), 'right');
            }
        } else {
            if (this.isMenuShown) {
                this.hideWarningTooltip(grid);
            }
        }

        if (stateChanged) {
            grid.repaint();
        }

        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle grid data added event
     * @param {Hypergrid} grid
     * @param {object} event
     * @private
     * @comment Not really private but was cluttering up all the feature doc pages.
     */
    handleDataAdded: function handleDataAdded(grid, event) {
        this.hideWarningTooltip(grid);

        if (this.next) {
            this.next.handleDataAdded(grid, event);
        }
    },

    overColumnWarningIcon: function overColumnWarningIcon(grid, event) {
        var columnHasError = event.column.hasError;
        var isHeaderRow = event.properties.headerRow || event.rowProperties.headerRow;

        if (!columnHasError || !isHeaderRow) {
            return false;
        }

        var warningIconLeftX = event.properties.cellPaddingLeft;
        var warningIconRightX = warningIconLeftX + 14 + event.properties.columnTitlePrefixRightSpace;

        var warningIconTopY = 5;
        var warningIconBottomY = event.bounds.height - 5;

        return event.mousePoint.x <= warningIconRightX && event.mousePoint.x >= warningIconLeftX && event.mousePoint.y <= warningIconBottomY && event.mousePoint.y >= warningIconTopY;
    },

    overTotalWarningIcon: function overTotalWarningIcon(grid, event) {
        var x = event.gridCell.x;
        var r = event.dataCell.y;

        var renderTotalErrorSignNeeded = x === grid.behavior.rowColumnIndex && r === 0 && event.isHeaderRow && grid.behavior.errorCount;

        if (!renderTotalErrorSignNeeded) {
            return false;
        }

        var totalErrorsCountIconStartY = event.bounds.height / 2 - event.properties.totalErrorsCountIconHeight / 2;
        var totalErrorsCountIconEndY = totalErrorsCountIconStartY + event.properties.totalErrorsCountIconHeight;
        var totalErrorsCountIconStartX = event.bounds.width / 2 - event.properties.totalErrorsCountIconWidth / 2;
        var totalErrorsCountIconEndX = totalErrorsCountIconStartX + event.properties.totalErrorsCountIconWidth;

        return event.mousePoint.x <= totalErrorsCountIconEndX && event.mousePoint.x >= totalErrorsCountIconStartX && event.mousePoint.y <= totalErrorsCountIconEndY && event.mousePoint.y >= totalErrorsCountIconStartY;
    },

    /**
     * @memberOf WarningTooltip.prototype
     * @desc utility method to paint context menu based on click event, and position params
     * @param {Hypergrid} grid
     * @param {number} x - defines horizontal point of menu start
     * @param {number} y - defines vertical point of menu start
     * @param {string} text - tooltip content
     * @param {string} placement - placement of an tooltip
     */
    paintWarningTooltip: function paintWarningTooltip(grid, x, y, text, placement) {
        this.hideWarningTooltip(grid);

        if (!tooltipDiv) {
            this.initializeWarningTooltipDiv();
        }

        // tooltipHolderDiv.setAttribute('class', 'tooltip bottom fade in main-page-tooltip');

        switch (placement) {
            case 'bottom':
                tooltipDiv.setAttribute('class', grid.properties.warningTooltipBottomClass);
                break;
            case 'right':
                tooltipDiv.setAttribute('class', grid.properties.warningTooltipRightClass);
                break;
        }

        var tooltipArrowDiv = document.createElement('div');
        tooltipArrowDiv.setAttribute('class', grid.properties.warningTooltipArrowClass);
        tooltipDiv.appendChild(tooltipArrowDiv);

        var tooltipInnerDiv = document.createElement('div');
        tooltipInnerDiv.setAttribute('class', grid.properties.warningTooltipInnerClass);
        tooltipInnerDiv.innerHTML = text;
        tooltipDiv.appendChild(tooltipInnerDiv);

        this.showWarningTooltip(grid);

        var leftX = void 0,
            topY = void 0;
        var tooltipWidth = tooltipDiv.offsetWidth,
            tooltipHeight = tooltipDiv.offsetHeight;

        switch (placement) {
            case 'bottom':
                leftX = x - tooltipWidth / 2;
                topY = y;
                break;
            case 'right':
                leftX = x;
                topY = y - tooltipHeight / 2;
                break;
        }

        this.moveWarningTooltip(leftX, topY);
    },

    /**
     * @memberOf WarningTooltip.prototype
     * @desc utility method to start show context menu on defined point.
     * @param {Hypergrid} grid
     */
    showWarningTooltip: function showWarningTooltip(grid) {
        var op = 0.1; // initial opacity
        tooltipDiv.style.opacity = op;
        tooltipDiv.style.display = 'block';
        this.isMenuShown = true;
        this.clearIntervals();
        fadeInInterval = setInterval(function () {
            if (op >= grid.properties.warningTooltipOpacity) {
                clearInterval(fadeInInterval);
            }
            if (!tooltipDiv) {
                return;
            }
            tooltipDiv.style.opacity = op;
            tooltipDiv.style.filter = 'alpha(opacity=' + op * 100 + ')';
            op += op * 0.2;
        }, 5);
    },

    /**
     * @memberOf WarningTooltip.prototype
     * @desc utility method to move tooltip to position
     * @desc Menu must be formed before it will be passed to this method
     * @param {number} x - defines horizontal point of tooltip start
     * @param {number} y - defines vertical point of tooltip start
     */
    moveWarningTooltip: function moveWarningTooltip(x, y) {
        tooltipDiv.style.top = y + 'px';
        tooltipDiv.style.left = x + 'px';
    },

    /**
     * @memberOf WarningTooltip.prototype
     * @desc utility method to stop displaying context menu
     * @param {Hypergrid} grid
     */
    hideWarningTooltip: function hideWarningTooltip(grid) {
        this.isMenuShown = false;

        if (!tooltipDiv) {
            return;
        }

        var op = grid.properties.warningTooltipOpacity; // initial opacity
        this.clearIntervals();
        fadeOutInterval = setInterval(function () {
            if (op <= 0.1) {
                clearInterval(fadeOutInterval);

                if (!tooltipDiv) {
                    return;
                }
                tooltipDiv.style.display = 'none';

                tooltipDiv.innerHTML = '';
                tooltipDiv.remove();
                tooltipDiv = null;
            }

            if (!tooltipDiv) {
                return;
            }

            tooltipDiv.style.opacity = op;
            tooltipDiv.style.filter = 'alpha(opacity=' + op * 100 + ')';
            op -= op * 0.2;
        }, 5);
    },

    clearIntervals: function clearIntervals() {
        if (fadeOutInterval) {
            clearInterval(fadeOutInterval);
        }
        if (fadeInInterval) {
            clearInterval(fadeInInterval);
        }
    }
});

module.exports = WarningTooltip;

},{"./Feature":75}],84:[function(require,module,exports){
'use strict';

var Registry = require('../lib/Registry');

/**
 * @classdesc Registry of feature constructors.
 * @param {boolean} [privateRegistry=false] - This instance will use a private registry.
 * @constructor
 */
var Features = Registry.extend('Features', {

    BaseClass: require('./Feature'), // abstract base class

    initialize: function initialize() {
        // preregister the standard cell renderers
        this.add(Features.CellClick);
        this.add(Features.CellEditing);
        this.add(Features.CellSelection);
        this.add(Features.ColumnMoving);
        this.add(Features.ColumnResizing);
        this.add(Features.ColumnSelection);
        this.add(Features.ColumnSorting);
        this.add(Features.Filters);
        this.add(Features.KeyPaging);
        this.add(Features.OnHover);
        // this.add(require('./RowResizing'));
        this.add(Features.RowSelection);
        this.add(Features.ThumbwheelScrolling);
        this.add(Features.ContextMenu);
        this.add(Features.ColumnFixation);
        this.add(Features.RowFixation);
        this.add(Features.LinkDetails);
        this.add(Features.WarningTooltip);
    }

});

// Following shared props provided solely in support of build file usage, e.g., `fin.Hypergrid.features.yada`,
// presumably for overriding built-in features, and are not meant to be used elsewhere.

Features.BaseClass = require('./Feature'); // abstract base class
Features.CellClick = require('./CellClick');
Features.CellEditing = require('./CellEditing');
Features.CellSelection = require('./CellSelection');
Features.ColumnMoving = require('./ColumnMoving');
Features.ColumnResizing = require('./ColumnResizing');
Features.ColumnSelection = require('./ColumnSelection');
Features.ColumnSorting = require('./ColumnSorting');
Features.Filters = require('./Filters');
Features.KeyPaging = require('./KeyPaging');
Features.OnHover = require('./OnHover');
// Features.RowResizing = require('./RowResizing');
Features.RowSelection = require('./RowSelection');
Features.ThumbwheelScrolling = require('./ThumbwheelScrolling');
Features.ContextMenu = require('./ContextMenu');
Features.ColumnFixation = require('./ColumnFixation');
Features.RowFixation = require('./RowFixation');
Features.LinkDetails = require('./LinkDetails');
Features.WarningTooltip = require('./WarningTooltip');

module.exports = new Features();

},{"../lib/Registry":90,"./CellClick":66,"./CellEditing":67,"./CellSelection":68,"./ColumnFixation":69,"./ColumnMoving":70,"./ColumnResizing":71,"./ColumnSelection":72,"./ColumnSorting":73,"./ContextMenu":74,"./Feature":75,"./Filters":76,"./KeyPaging":77,"./LinkDetails":78,"./OnHover":79,"./RowFixation":80,"./RowSelection":81,"./ThumbwheelScrolling":82,"./WarningTooltip":83}],85:[function(require,module,exports){
/* eslint-env browser */

'use strict';

/* NOTE
 *
 * What this file is:
 * * This file is browserify's entry point.
 * * This file creates the `window.fin.Hypergrid` object.
 * * Bundled file can be used as require module for creating new Hypergrid objects
 */

// Create the `fin` namespace if not already extant

var fin = window.fin = window.fin || {};

// Create the `fin.Hypergrid` object, which serves both as a "class" (constructor) and a namespace:
var Hypergrid = fin.Hypergrid = require('../Hypergrid');

// Install the module loader
Hypergrid.require = require('./module-loader');

// Install `src` the internal module namespace which is for the build file only
Hypergrid.src = {};

// Note: At this point, `Hypergrid.modules`, the external module namespace, has already
// been installed by ./Hypergrid/index.js (for both npm and build modules).

// Install implicit modules which are external modules but are not overridable so non-configurable, non-writable
Object.defineProperties(Hypergrid.modules, {
    'datasaur-base': { value: require('../DatasaurBase') }, // may be removed in a future release
    'datasaur-local': { value: require('../DatasaurLocal') }, // may be removed in a future release
    'extend-me': { value: require('extend-me') },
    'object-iterators': { value: require('object-iterators') },
    overrider: { value: require('overrider') },
    rectangular: { value: require('rectangular') },
    'sparse-boolean-array': { value: require('sparse-boolean-array') }
});

// Install internal modules may not be overridden so non-configurable, non-writable
Object.defineProperties(Hypergrid.src, {
    lib: { value: require('..//lib') },
    behaviors: { value: require('../behaviors') },
    dataModels: { value: require('../dataModels') },
    features: { value: require('../features') },
    Base: { value: require('../Base') },
    defaults: { value: require('../defaults') }
});

// Deprecate certain properties
Object.defineProperties(Hypergrid, {
    lib: { get: deprecated.bind(null, 'lib') },
    behaviors: { get: deprecated.bind(null, 'behaviors') },
    dataModels: { get: deprecated.bind(null, 'dataModels') },
    features: { get: deprecated.bind(null, 'features') },
    rectangular: { get: deprecated.bind(null, 'rectangular', 'modules') }
});

function deprecated(key, registry) {
    registry = registry || 'src';

    var requireString, warning;

    switch (registry) {
        case 'src':
            requireString = '../' + key;
            warning = 'Reference to ' + key + ' internal modules using' + ' `Hypergrid.' + key + '.modulename` has been deprecated as of v3.0.0 in favor of' + ' `Hypergrid.require(\'' + requireString + '/modulename\')` and will be removed in a future release.' + ' See https://github.com/fin-hypergrid/core/wiki/Client-Modules#predefined-modules.';
            break;

        case 'modules':
            requireString = key;
            warning = 'Reference to ' + key + ' external module using' + ' `Hypergrid.' + key + '.` has been deprecated as of v3.0.0 in favor of' + ' `Hypergrid.require(\'' + requireString + '\')` and will be removed in a future release.' + ' See https://github.com/fin-hypergrid/core/wiki/Client-Modules#external-modules.';
    }

    if (!deprecated.warned[key]) {
        console.warn(warning);
        deprecated.warned[key] = true;
    }

    return Hypergrid.require(requireString);
}

deprecated.warned = {};

module.exports = Hypergrid;

},{"..//lib":98,"../Base":17,"../DatasaurBase":18,"../DatasaurLocal":19,"../Hypergrid":28,"../behaviors":42,"../dataModels":64,"../defaults":65,"../features":84,"./module-loader":86,"extend-me":9,"object-iterators":12,"overrider":13,"rectangular":14,"sparse-boolean-array":15}],86:[function(require,module,exports){
'use strict';

var packageName = 'build';
var Hypergrid = require('../Hypergrid');

var REGEX_SRC_MODULES = new RegExp('^' + packageName + '/src/(Base|defaults)$'),
    REGEX_INTERNAL_MODULES = new RegExp('^' + packageName + '/src/(lib|behaviors|dataModels|features)(/(\\w+))?$');

function moduleLoader(path) {
    // See https://github.com/fin-hypergrid/core/wiki/Client-Modules
    var module, crumbs;

    switch (path) {
        case packageName:
            module = Hypergrid;
            break;
        case packageName + '/images':
            module = require('../../images');
            break;
        default:
            if (crumbs = path.match(REGEX_SRC_MODULES)) {
                module = Hypergrid.src[crumbs[1]];
            } else if (crumbs = path.match(REGEX_INTERNAL_MODULES)) {
                module = Hypergrid.src[crumbs[1]];
                if (crumbs[3]) {
                    module = module[crumbs[3]];
                }
            } else {
                module = Hypergrid.modules[path];
            }
    }

    if (!module) {
        var msg = 'Unknown module ' + path,
            match = path.match(/(\/(index(\.js)?)?|\.js)$/);

        if (match) {
            msg += ' (try omitting trailing "' + match[1] + '")';
        }

        throw msg;
    }

    return module;
}

module.exports = moduleLoader;

},{"../../images":3,"../Hypergrid":28}],87:[function(require,module,exports){
/* eslint-env browser */

'use strict';

if (typeof window.CustomEvent !== 'function') {
    window.CustomEvent = function (event, params) {
        params = params || { bubbles: false, cancelable: false, detail: undefined };
        var evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
    };

    window.CustomEvent.prototype = window.Event.prototype;
}

var rectangular = require('rectangular');

var RESIZE_POLLING_INTERVAL = 200,
    paintables = [],
    resizables = [],
    paintRequest,
    resizeInterval,
    charMap = makeCharMap();

function Canvas(div, component) {
    var self = this;

    // create the containing <div>...</div>
    this.div = div;
    this.component = component;

    this.dragEndtime = Date.now();

    // create and append the info <div>...</div> (to be displayed when there are no data rows)
    this.infoDiv = document.createElement('div');
    this.infoDiv.className = 'info';
    this.div.appendChild(this.infoDiv);

    // create and append the canvas
    this.gc = getCachedContext(this.canvas = document.createElement('canvas'));
    this.bc = getCachedContext(this.buffer = document.createElement('canvas'));

    this.div.appendChild(this.canvas);

    this.canvas.style.outline = 'none';
    this.canvas.style.background = this.component.properties.canvasBackgroundColor;

    this.mouseLocation = new rectangular.Point(-1, -1);
    this.dragstart = new rectangular.Point(-1, -1);
    //this.origin = new rectangular.Point(0, 0);
    this.bounds = new rectangular.Rectangle(0, 0, 0, 0);
    this.hasMouse = false;

    this.canvas.onmouseover = function () {
        self.hasMouse = true;
    };
    this.addEventListener('focus', function (e) {
        self.finfocusgained(e);
    });
    this.addEventListener('blur', function (e) {
        self.finfocuslost(e);
    });
    this.addEventListener('mousedown', function (e) {
        self.finmousedown(e);
    });
    this.addEventListener('mouseout', function (e) {
        self.hasMouse = false;
        self.finmouseout(e);
    });
    this.addEventListener('click', function (e) {
        self.finclick(e);
    });
    this.addEventListener('dblclick', function (e) {
        self.findblclick(e);
    });
    this.addEventListener('contextmenu', function (e) {
        self.fincontextmenu(e);
        e.preventDefault();
        return false;
    });

    this.canvas.setAttribute('tabindex', 0);

    this.resize();

    this.start();
    // this.beginResizing();
    // this.beginPainting();
}

Canvas.prototype = {
    constructor: Canvas.prototype.constructor,
    div: null,
    component: null,
    canvas: null,
    focuser: null,
    buffer: null,
    ctx: null,
    mouseLocation: null,
    dragstart: null,
    origin: null,
    bounds: null,
    dirty: false,
    size: null,
    mousedown: false,
    dragging: false,
    repeatKeyCount: 0,
    repeatKey: null,
    repeatKeyStartTime: 0,
    currentKeys: [],
    hasMouse: false,
    dragEndTime: 0,
    lastRepaintTime: 0,
    currentPaintCount: 0,
    currentFPS: 0,
    lastFPSComputeTime: 0,
    listeners: {},

    addEventListener: function addEventListener(name, callback) {
        this.canvas.addEventListener(name, callback);
    },

    toggleDocumentEventListeners: function toggleDocumentEventListeners(isEnable) {
        var _this = this;

        if (isEnable) {
            this.toggleDocumentEventListeners(false);
        }

        var listeners = {
            mousemove: function mousemove(e) {
                if (_this.hasMouse || _this.isDragging()) {
                    _this.finmousemove(e);
                }
            },
            mouseup: function mouseup(e) {
                _this.finmouseup(e);
            },
            wheel: function wheel(e) {
                _this.finwheelmoved(e);
            },
            keydown: function keydown(e) {
                _this.finkeydown(e);
            },
            keyup: function keyup(e) {
                _this.finkeyup(e);
            },
            mousedown: function mousedown(e) {
                if (_this.canvas) {
                    var canvasRect = _this.canvas.getBoundingClientRect();

                    if (canvasRect.x !== canvasRect.y && canvasRect.width !== canvasRect.height && !(event.clientX > canvasRect.x && event.clientY > canvasRect.y && event.clientX < canvasRect.x + canvasRect.width && event.clientY < canvasRect.y + canvasRect.height)) {
                        _this.finMouseDownOutside(e);
                    }
                }
            }
        };

        Object.keys(listeners).forEach(function (eventType) {
            if (!_this.listeners[eventType]) {
                _this.listeners[eventType] = listeners[eventType];
            }
            document[(isEnable ? 'add' : 'remove') + 'EventListener'](eventType, _this.listeners[eventType]);
            if (!isEnable) {
                delete _this.listeners[eventType];
            }
        });
    },

    removeEventListener: function removeEventListener(name, callback) {
        this.canvas.removeEventListener(name, callback);
    },

    stopPaintLoop: stopPaintLoop,
    restartPaintLoop: restartPaintLoop,

    stopResizeLoop: stopResizeLoop,
    restartResizeLoop: restartResizeLoop,

    detached: function detached() {
        this.stopPainting();
        this.stopResizing();
    },

    getCurrentFPS: function getCurrentFPS() {
        return this.currentFPS;
    },

    tickPaint: function tickPaint(now) {
        var isContinuousRepaint = this.component.properties.enableContinuousRepaint,
            fps = this.component.properties.repaintIntervalRate;
        if (fps === 0) {
            return;
        }
        var interval = 1000 / fps;

        var elapsed = now - this.lastRepaintTime;
        if (elapsed > interval && (isContinuousRepaint || this.dirty)) {
            this.paintNow();
            this.lastRepaintTime = now;
            /* - (elapsed % interval);*/
            if (isContinuousRepaint) {
                this.currentPaintCount++;
                if (now - this.lastFPSComputeTime >= 1000) {
                    this.currentFPS = this.currentPaintCount * 1000 / (now - this.lastFPSComputeTime);
                    this.currentPaintCount = 0;
                    this.lastFPSComputeTime = now;
                }
            }
        }
    },

    beginPainting: function beginPainting() {
        var self = this;
        this.dirty = true;
        this.tickPainter = function (now) {
            self.tickPaint(now);
        };
        paintables.push(this);
    },

    stopPainting: function stopPainting() {
        paintables.splice(paintables.indexOf(this), 1);
    },

    beginResizing: function beginResizing() {
        var self = this;
        this.tickResizer = function () {
            self.checksize();
        };
        resizables.push(this);
    },

    stopResizing: function stopResizing() {
        resizables.splice(resizables.indexOf(this), 1);
    },

    start: function start() {
        this.beginPainting();
        this.beginResizing();
        this.toggleDocumentEventListeners(true);
    },

    stop: function stop() {
        this.stopPainting();
        this.stopResizing();
    },

    getDivBoundingClientRect: function getDivBoundingClientRect() {
        // Make sure our canvas has integral dimensions
        var rect = this.div.getBoundingClientRect();
        var top = Math.floor(rect.top),
            left = Math.floor(rect.left),
            width = Math.ceil(rect.width),
            height = Math.ceil(rect.height);

        return {
            top: top,
            right: left + width,
            bottom: top + height,
            left: left,
            width: width,
            height: height,
            x: rect.x,
            y: rect.y
        };
    },

    checksize: function checksize() {
        //this is expensive lets do it at some modulo
        var sizeNow = this.getDivBoundingClientRect();
        if (sizeNow.width !== this.size.width || sizeNow.height !== this.size.height) {
            this.resize();
        }
    },

    refreshBounds: function refreshBounds() {
        var box = this.size = this.getDivBoundingClientRect();
        this.width = box.width - this.component.properties.canvasWidthOffset;
        this.height = box.height - this.component.properties.canvasHeightOffset;
        this.bounds = new rectangular.Rectangle(0, 0, this.width, this.height);
        this.component.setBounds(this.bounds);
        this.component.viewHeight = this.bounds.height;
    },

    resize: function resize(withNotification) {
        withNotification = typeof withNotification !== 'undefined' ? withNotification : true;
        var box = this.size = this.getDivBoundingClientRect();

        this.width = box.width - this.component.properties.canvasWidthOffset;
        this.height = box.height - this.component.properties.canvasHeightOffset;

        //fix ala sir spinka, see
        //http://www.html5rocks.com/en/tutorials/canvas/hidpi/
        //just add 'hdpi' as an attribute to the fin-canvas tag
        var ratio = 1;
        var isHIDPI = window.devicePixelRatio && this.component.properties.useHiDPI;
        if (isHIDPI) {
            var devicePixelRatio = window.devicePixelRatio || 1;
            var backingStoreRatio = this.gc.webkitBackingStorePixelRatio || this.gc.mozBackingStorePixelRatio || this.gc.msBackingStorePixelRatio || this.gc.oBackingStorePixelRatio || this.gc.backingStorePixelRatio || 1;

            ratio = devicePixelRatio / backingStoreRatio;
            //this.canvasCTX.scale(ratio, ratio);
        }

        this.buffer.width = this.canvas.width = this.width * ratio;
        this.buffer.height = this.canvas.height = this.height * ratio;

        // +2 and +1 because of some text render artifacts (sometimes not only text) (some vertical/horizontal broken lines)
        this.canvas.style.width = this.buffer.style.width = this.width + 2 + 'px';
        this.canvas.style.height = this.buffer.style.height = this.height + 1 + 'px';

        this.bc.scale(ratio, ratio);
        if (isHIDPI && !this.component.properties.useBitBlit) {
            this.gc.scale(ratio, ratio);
        }

        this.bounds = new rectangular.Rectangle(0, 0, this.width, this.height);
        this.component.setBounds(this.bounds);
        if (withNotification) {
            this.resizeNotification();
        }

        this.paintNow();
    },

    resizeNotification: function resizeNotification() {
        this.dispatchNewEvent(undefined, 'fin-canvas-resized', {
            width: this.width,
            height: this.height
        });
    },

    getBounds: function getBounds() {
        return this.bounds;
    },

    paintNow: function paintNow() {
        var useBitBlit = this.component.properties.useBitBlit,
            gc = useBitBlit ? this.bc : this.gc;

        try {
            gc.cache.save();
            this.component.paint(gc);
            this.dirty = false;
        } catch (e) {
            console.error(e);
        } finally {
            gc.cache.restore();
        }

        if (useBitBlit) {
            this.flushBuffer();
        }
    },

    flushBuffer: function flushBuffer() {
        if (this.buffer.width > 0 && this.buffer.height > 0) {
            this.gc.drawImage(this.buffer, 0, 0);
        }
    },

    newEvent: function newEvent(primitiveEvent, name, detail) {
        var event = {
            detail: detail || {}
        };
        if (primitiveEvent) {
            event.detail.primitiveEvent = primitiveEvent;
        }
        return new CustomEvent(name, event);
    },

    dispatchNewEvent: function dispatchNewEvent(primitiveEvent, name, detail) {
        return this.canvas.dispatchEvent(this.newEvent(primitiveEvent, name, detail));
    },

    dispatchNewMouseKeysEvent: function dispatchNewMouseKeysEvent(event, name, detail) {
        detail = detail || {};
        detail.mouse = this.mouseLocation;
        detail.keys = this.currentKeys;
        return this.dispatchNewEvent(event, name, detail);
    },

    finmousemove: function finmousemove(e) {
        if (!this.isDragging() && this.mousedown) {
            this.beDragging();
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dragstart', {
                isRightClick: this.isRightClick(e),
                dragstart: this.dragstart
            });
            this.dragstart = new rectangular.Point(this.mouseLocation.x, this.mouseLocation.y);
        }
        this.mouseLocation = this.getLocal(e);
        //console.log(this.mouseLocation);
        if (this.isDragging()) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-drag', {
                dragstart: this.dragstart,
                isRightClick: this.isRightClick(e)
            });
        }
        if (this.bounds.contains(this.mouseLocation)) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mousemove');
        }
    },

    finmousedown: function finmousedown(e) {
        this.mouseLocation = this.mouseDownLocation = this.getLocal(e);
        this.mousedown = true;

        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mousedown', {
            isRightClick: this.isRightClick(e)
        });
        this.takeFocus();

        // e.stopPropagation();
    },

    finMouseDownOutside: function finMouseDownOutside(e) {
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-outside-mousedown', {
            isRightClick: this.isRightClick(e)
        });
    },

    finmouseup: function finmouseup(e) {
        if (!this.mousedown) {
            // ignore document:mouseup unless preceded by a canvas:mousedown
            return;
        }
        if (this.isDragging()) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dragend', {
                dragstart: this.dragstart,
                isRightClick: this.isRightClick(e)
            });
            this.beNotDragging();
            this.dragEndtime = Date.now();
        }
        this.mousedown = false;
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mouseup', {
            dragstart: this.dragstart,
            isRightClick: this.isRightClick(e)
        });
        //this.mouseLocation = new rectangular.Point(-1, -1);
    },

    finmouseout: function finmouseout(e) {
        if (!this.mousedown) {
            this.mouseLocation = new rectangular.Point(-1, -1);
        }
        this.repaint();
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mouseout', {
            dragstart: this.dragstart
        });
    },

    finwheelmoved: function finwheelmoved(e) {
        if (this.isDragging() || !this.hasFocus()) {
            return;
        }
        e.preventDefault();
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-wheelmoved', {
            isRightClick: this.isRightClick(e)
        });
    },

    finclick: function finclick(e) {
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-click', {
            isRightClick: this.isRightClick(e)
        });
    },

    findblclick: function findblclick(e) {
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dblclick', {
            isRightClick: this.isRightClick(e)
        });
    },

    getCharMap: function getCharMap() {
        return charMap;
    },

    getKeyChar: function getKeyChar(e) {
        var key = e.keyCode || e.detail.key,
            shift = e.shiftKey || e.detail.shift;
        return charMap[key][shift ? 1 : 0];
    },

    finkeydown: function finkeydown(e) {
        if (!this.hasFocus()) {
            return;
        }

        // prevent TAB from moving focus off the canvas element
        if (e.keyCode === 9) {
            e.preventDefault();
        }

        // if (e.ctrlKey || e.metaKey) {
        //     e.preventDefault();
        // }

        var keyChar = this.getKeyChar(e);
        if (e.repeat) {
            if (this.repeatKey === keyChar) {
                this.repeatKeyCount++;
            } else {
                this.repeatKey = keyChar;
                this.repeatKeyStartTime = Date.now();
            }
        } else {
            this.repeatKey = null;
            this.repeatKeyCount = 0;
            this.repeatKeyStartTime = 0;
        }
        if (this.currentKeys.indexOf(keyChar) === -1) {
            this.currentKeys.push(keyChar);
        }

        this.dispatchNewEvent(e, 'fin-canvas-keydown', {
            alt: e.altKey,
            ctrl: e.ctrlKey,
            char: keyChar,
            code: e.charCode,
            key: e.keyCode,
            meta: e.metaKey,
            repeatCount: this.repeatKeyCount,
            repeatStartTime: this.repeatKeyStartTime,
            shift: e.shiftKey,
            identifier: e.key,
            currentKeys: this.currentKeys.slice(0),
            sourceEvent: e
        });
    },

    finkeyup: function finkeyup(e) {
        if (!this.hasFocus()) {
            return;
        }

        // prevent TAB from moving focus off the canvas element
        if (e.keyCode === 9) {
            e.preventDefault();
        }

        var keyChar = this.getKeyChar(e);
        this.currentKeys.splice(this.currentKeys.indexOf(keyChar), 1);
        this.repeatKeyCount = 0;
        this.repeatKey = null;
        this.repeatKeyStartTime = 0;
        this.dispatchNewEvent(e, 'fin-canvas-keyup', {
            alt: e.altKey,
            ctrl: e.ctrlKey,
            char: keyChar,
            code: e.charCode,
            key: e.keyCode,
            meta: e.metaKey,
            repeat: e.repeat,
            shift: e.shiftKey,
            identifier: e.key,
            currentKeys: this.currentKeys.slice(0)
        });
    },

    _clearCurrentKeys: function _clearCurrentKeys() {
        this.currentKeys = [];
    },

    finfocusgained: function finfocusgained(e) {
        this.dispatchNewEvent(e, 'fin-canvas-focus-gained');
    },

    finfocuslost: function finfocuslost(e) {
        this._clearCurrentKeys();
        this.dispatchNewEvent(e, 'fin-canvas-focus-lost');
    },

    fincontextmenu: function fincontextmenu(e) {
        if (e.ctrlKey && this.currentKeys.indexOf('CTRL') === -1) {
            this.currentKeys.push('CTRL');
        }

        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-context-menu', {
            isRightClick: this.isRightClick(e)
        });
    },

    repaint: function repaint() {
        this.dirty = true;
        if (!paintRequest || this.component.properties.repaintIntervalRate === 0) {
            this.paintNow();
        }
    },

    getMouseLocation: function getMouseLocation() {
        return this.mouseLocation;
    },

    getOrigin: function getOrigin() {
        var rect = this.canvas.getBoundingClientRect();
        var p = new rectangular.Point(rect.left, rect.top);
        return p;
    },

    getLocal: function getLocal(e) {
        var rect = this.canvas.getBoundingClientRect();
        var p = new rectangular.Point(e.clientX - rect.left, e.clientY - rect.top);
        return p;
    },

    hasFocus: function hasFocus() {
        return document.activeElement === this.canvas;
    },

    takeFocus: function takeFocus() {
        var self = this;
        if (!this.hasFocus()) {
            setTimeout(function () {
                self.canvas.focus();
            }, 10);
        }
    },

    beDragging: function beDragging() {
        this.dragging = true;
        this.disableDocumentElementSelection();
    },

    beNotDragging: function beNotDragging() {
        this.dragging = false;
        this.enableDocumentElementSelection();
    },

    isDragging: function isDragging() {
        return this.dragging;
    },

    disableDocumentElementSelection: function disableDocumentElementSelection() {
        var style = document.body.style;
        style.cssText = style.cssText + '-webkit-user-select: none';
    },

    enableDocumentElementSelection: function enableDocumentElementSelection() {
        var style = document.body.style;
        style.cssText = style.cssText.replace('-webkit-user-select: none', '');
    },

    setFocusable: function setFocusable(truthy) {
        this.focuser.style.display = truthy ? '' : 'none';
    },

    isRightClick: function isRightClick(e) {
        var isRightMB;
        e = e || window.event;

        if ('which' in e) {
            // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
            isRightMB = e.which === 3;
        } else if ('button' in e) {
            // IE, Opera
            isRightMB = e.button === 2;
        }
        return isRightMB;
    },

    dispatchEvent: function dispatchEvent(e) {
        return this.canvas.dispatchEvent(e);
    },

    setInfo: function setInfo(message, width) {
        if (message) {
            if (width !== undefined) {
                if (width && !isNaN(Number(width))) {
                    width += 'px';
                }
                this.infoDiv.style.width = width;
            }

            if (message.indexOf('<')) {
                this.infoDiv.innerHTML = message;
            } else {
                this.infoDiv.innerText = message;
            }
        }

        this.infoDiv.style.display = message ? 'block' : 'none';
    }
};

function paintLoopFunction(now) {
    if (paintRequest) {
        paintables.forEach(function (paintable) {
            try {
                paintable.tickPainter(now);
            } catch (e) {
                console.error(e);
            }

            if (paintable.component.tickNotification) {
                paintable.component.tickNotification();
            }
        });
        paintRequest = requestAnimationFrame(paintLoopFunction);
    }
}
function restartPaintLoop() {
    paintRequest = paintRequest || requestAnimationFrame(paintLoopFunction);
}
function stopPaintLoop() {
    if (paintRequest) {
        cancelAnimationFrame(paintRequest);
        paintRequest = undefined;
    }
}
restartPaintLoop();

function resizablesLoopFunction(now) {
    if (resizeInterval) {
        for (var i = 0; i < resizables.length; i++) {
            try {
                resizables[i].tickResizer(now);
            } catch (e) {
                console.error(e);
            }
        }
    }
}
function restartResizeLoop() {
    resizeInterval = resizeInterval || setInterval(resizablesLoopFunction, RESIZE_POLLING_INTERVAL);
}
function stopResizeLoop() {
    if (resizeInterval) {
        clearInterval(resizeInterval);
        resizeInterval = undefined;
    }
}
restartResizeLoop();

function makeCharMap() {
    var map = [];

    var empty = ['', ''];

    for (var i = 0; i < 256; i++) {
        map[i] = empty;
    }

    map[27] = ['ESC', 'ESCSHIFT'];
    map[192] = ['`', '~'];
    map[49] = ['1', '!'];
    map[50] = ['2', '@'];
    map[51] = ['3', '#'];
    map[52] = ['4', '$'];
    map[53] = ['5', '%'];
    map[54] = ['6', '^'];
    map[55] = ['7', '&'];
    map[56] = ['8', '*'];
    map[57] = ['9', '('];
    map[48] = ['0', ')'];
    map[189] = ['-', '_'];
    map[187] = ['=', '+'];
    map[8] = ['BACKSPACE', 'BACKSPACESHIFT'];
    map[46] = ['DELETE', 'DELETESHIFT'];
    map[9] = ['TAB', 'TABSHIFT'];
    map[81] = ['q', 'Q'];
    map[87] = ['w', 'W'];
    map[69] = ['e', 'E'];
    map[82] = ['r', 'R'];
    map[84] = ['t', 'T'];
    map[89] = ['y', 'Y'];
    map[85] = ['u', 'U'];
    map[73] = ['i', 'I'];
    map[79] = ['o', 'O'];
    map[80] = ['p', 'P'];
    map[219] = ['[', '{'];
    map[221] = [']', '}'];
    map[220] = ['\\', '|'];
    map[220] = ['CAPSLOCK', 'CAPSLOCKSHIFT'];
    map[65] = ['a', 'A'];
    map[83] = ['s', 'S'];
    map[68] = ['d', 'D'];
    map[70] = ['f', 'F'];
    map[71] = ['g', 'G'];
    map[72] = ['h', 'H'];
    map[74] = ['j', 'J'];
    map[75] = ['k', 'K'];
    map[76] = ['l', 'L'];
    map[186] = [';', ':'];
    map[222] = ['\'', '|'];
    map[13] = ['RETURN', 'RETURNSHIFT'];
    map[16] = ['SHIFT', 'SHIFT'];
    map[90] = ['z', 'Z'];
    map[88] = ['x', 'X'];
    map[67] = ['c', 'C'];
    map[86] = ['v', 'V'];
    map[66] = ['b', 'B'];
    map[78] = ['n', 'N'];
    map[77] = ['m', 'M'];
    map[188] = [',', '<'];
    map[190] = ['.', '>'];
    map[191] = ['/', '?'];
    map[16] = ['SHIFT', 'SHIFT'];
    map[17] = ['CTRL', 'CTRLSHIFT'];
    map[18] = ['ALT', 'ALTSHIFT'];
    map[91] = ['COMMANDLEFT', 'COMMANDLEFTSHIFT'];
    map[32] = ['SPACE', 'SPACESHIFT'];
    map[93] = ['COMMANDRIGHT', 'COMMANDRIGHTSHIFT'];
    map[18] = ['ALT', 'ALTSHIFT'];
    map[38] = ['UP', 'UPSHIFT'];
    map[37] = ['LEFT', 'LEFTSHIFT'];
    map[40] = ['DOWN', 'DOWNSHIFT'];
    map[39] = ['RIGHT', 'RIGHTSHIFT'];

    map[33] = ['PAGEUP', 'PAGEUPSHIFT'];
    map[34] = ['PAGEDOWN', 'PAGEDOWNSHIFT'];
    map[35] = ['PAGERIGHT', 'PAGERIGHTSHIFT']; // END
    map[36] = ['PAGELEFT', 'PAGELEFTSHIFT']; // HOME

    map[112] = ['F1', 'F1SHIFT'];
    map[113] = ['F2', 'F2SHIFT'];
    map[114] = ['F3', 'F3SHIFT'];
    map[115] = ['F4', 'F4SHIFT'];
    map[116] = ['F5', 'F5SHIFT'];
    map[117] = ['F6', 'F6SHIFT'];
    map[118] = ['F7', 'F7SHIFT'];
    map[119] = ['F8', 'F8SHIFT'];
    map[120] = ['F9', 'F9SHIFT'];
    map[121] = ['F10', 'F10SHIFT'];
    map[122] = ['F11', 'F11SHIFT'];
    map[123] = ['F12', 'F12SHIFT'];

    return map;
}

function getCachedContext(canvasElement, type) {
    var gc = canvasElement.getContext(type || '2d', { alpha: false }),
        props = {},
        values = {};

    // Stub out all the prototype members of the canvas 2D graphics context:
    Object.keys(Object.getPrototypeOf(gc)).forEach(makeStub);

    // Some older browsers (e.g., Chrome 40) did not have all members of canvas
    // 2D graphics context in the prototype so we make this additional call:
    Object.keys(gc).forEach(makeStub);

    function makeStub(key) {
        if (!(key in props) && !/^(webkit|moz|ms|o)[A-Z]/.test(key) && typeof gc[key] !== 'function') {
            Object.defineProperty(props, key, {
                get: function get() {
                    return values[key] = values[key] || gc[key];
                },
                set: function set(value) {
                    if (value !== values[key]) {
                        gc[key] = values[key] = value;
                    }
                }
            });
        }
    }

    gc.cache = props;

    gc.cache.save = function () {
        gc.save();
        values = Object.create(values);
    };

    gc.cache.restore = function () {
        gc.restore();
        values = Object.getPrototypeOf(values);
    };

    gc.conditionalsStack = [];

    Object.getOwnPropertyNames(Canvas.graphicsContextAliases).forEach(function (alias) {
        gc[alias] = gc[Canvas.graphicsContextAliases[alias]];
    });

    return Object.assign(gc, require('./graphics'));
}

Canvas.graphicsContextAliases = {
    simpleText: 'fillText'
};

module.exports = Canvas;

},{"./graphics":96,"rectangular":14}],88:[function(require,module,exports){
/* eslint-env browser */

/** @module effects */

/** @typedef {function} effectFunction
 * @desc Element to perform transitions upon is `options.el` if defined or `this.el`.
 * @param {object} [options]
 * @param {HTMLElement} [options.el=this.el]
 * @param {function} [options.callback] Function to call at conclusion of transitions.
 * @param {string} [options.duration='0.065s'] - Duration of each transition.
 * @param {object} [options.styles=defaultGlowerStyles] - Hash of CSS styles and values to transition. (For {@link effects~glower|glower} only.
 */

'use strict';

/**
 * Shake element back and fourth a few times as if to say, "Nope!"
 * @type {effectFunction}
 * @memberOf module:effects
 */

exports.shaker = function (options) {
    options = options || {};
    var context = this,
        el = options.el || context.el,
        duration = options.duration || '0.065s',
        computedStyle = window.getComputedStyle(el),
        transitions = computedStyle.transition.split(','),
        position = computedStyle.position,
        x = parseInt(computedStyle.left),
        dx = -3,
        shakes = 6;

    transitions.push('left ' + duration);
    el.style.transition = transitions.join(',');
    el.addEventListener('transitionend', shaker);
    shaker();
    function shaker(event) {
        if (!event || event.propertyName === 'left') {
            el.style.left = x + dx + 'px';
            if (!shakes--) {
                el.removeEventListener('transitionend', shaker);
                transitions.pop();
                el.style.transition = transitions.join(',');
                el.style.position = position;
                if (options.callback) {
                    options.callback.call(context, options);
                }
            }
            dx = shakes ? -dx : 0;
        }
    }
};

var defaultGlowerStyles = {
    'background-color': 'yellow',
    'box-shadow': '0 0 10px red'
};

/**
 * Transition styles on element for a moment and revert as if to say, "Whoa!."
 * @type {effectFunction}
 * @memberOf module:effects
 */
exports.glower = function (options) {
    options = options || {};
    var context = this,
        el = options.el || context.el,
        duration = options.duration || '0.25s',
        styles = options.styles || defaultGlowerStyles,
        values = styles.length,
        computedStyle = window.getComputedStyle(el),
        styleWas = {},
        transition = computedStyle.transition,
        transitions = transition.split(',');

    Object.keys(styles).forEach(function (style) {
        styleWas[style] = {
            style: computedStyle[style],
            undo: true
        };
        transitions.push(style + ' ' + duration);
    });

    el.style.transition = transitions.join(',');
    el.addEventListener('transitionend', glower);
    Object.keys(styles).forEach(function (style) {
        el.style[style] = styles[style];
    });

    function glower(event) {
        var was = styleWas[event.propertyName];
        if (was.undo) {
            el.style[event.propertyName] = was.style;
            was.undo = false;
        } else if (! --values) {
            el.removeEventListener('transitionend', glower);
            el.style.transition = transition;
            if (options.callback) {
                options.callback.call(context, options);
            }
        }
    }
};

},{}],89:[function(require,module,exports){
/* eslint-env browser */

/**
 * @module localization
 */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Base = require('../Base');

/**
 * @param {string} defaultLocale
 * @param {string} [locale=defaultlocale]
 * @param {object} [options]
 * @constructor
 */
var Formatter = Base.extend({
    initialize: function initialize(defaultLocale, locale, options) {
        if ((typeof locale === 'undefined' ? 'undefined' : _typeof(locale)) === 'object') {
            options = locale;
            locale = defaultLocale;
        }

        this.locale = locale;

        if (options) {
            if (typeof options.invalid === 'function') {
                this.invalid = options.invalid;
            }

            if (options.expectation) {
                this.expectation = options.expectation;
            }
        }
    }
});

// Safari has no Intl implementation
if (!window.Intl) {
    window.Intl = {
        NumberFormat: function NumberFormat(locale, options) {
            var digits = '0123456789';
            this.format = function (n) {
                var s = n.toString();
                if (!options || options.useGrouping === undefined || options.useGrouping) {
                    var dp = s.indexOf('.');
                    if (dp < 0) {
                        dp = s.length;
                    }
                    while ((dp -= 3) > 0 && digits.indexOf(s[dp - 1]) >= 0) {
                        s = s.substr(0, dp) + ',' + s.substr(dp);
                    }
                }
                return s;
            };
        },
        DateTimeFormat: function DateTimeFormat(locale, options) {
            this.format = function (date) {
                if (date != null) {
                    if ((typeof date === 'undefined' ? 'undefined' : _typeof(date)) !== 'object') {
                        date = new Date(date);
                    }
                    date = date.getMonth() + 1 + '-' + date.getDate() + '-' + date.getFullYear();
                } else {
                    date = null;
                }
                return date;
            };
        }
    };
}

/**
 * @summary Create a number localizer.
 * @implements localizerInterface
 * @desc Create an object conforming to {@link localizerInterface} for numbers, using {@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat|Intl.NumberFormat}.
 * @param {string} defaultLocale
 * @param {string} [locale=defaultLocale] - Passed to the {@link Intl.NumberFormat|https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat} constructor.
 * @param {object} [options] - Passed to the `Intl.NumberFormat` constructor.
 * @param {boolean} [options.acceptStandardDigits=false] - Accept standard digits and decimal point interchangeably with localized digits and decimal point. (This option is interpreted here; it is not used by `Intl.NumberFormat`.)
 * @constructor
 * @extends Formatter
 * @tutorial localization
 */
var NumberFormatter = Formatter.extend('NumberFormatter', {
    initialize: function initialize(defaultLocale, locale, options) {
        if ((typeof locale === 'undefined' ? 'undefined' : _typeof(locale)) === 'object') {
            options = locale;
        }

        options = options || {};

        this.format = new Intl.NumberFormat(this.locale, options).format;

        var mapperOptions = { useGrouping: false },
            mapper = new Intl.NumberFormat(this.locale, mapperOptions).format;

        this.demapper = demap.bind(this);

        /**
         * @summary A string containing the valid characters.
         * @desc Contains all localized digits + localized decimal point.
         * If we're accepting standard digits, will also contain all the standard digits + standard decimal point (if different than localized versions).
         * @type {string}
         * @private
         * @desc Localized digits and decimal point. Will also include standardized digits and decimal point if `options.acceptStandardDigits` is truthy.
         *
         * For internal use by the {@link NumberFormatter#parse|parse} method.
         * @memberOf NumberFormatter.prototype
         */
        this.map = mapper(10123456789.5).substr(1, 11); // localized '0123456789.'

        if (options.acceptStandardDigits && this.map !== '0123456789.') {
            this.map += '0123456789.'; // standard '0123456789.'
        }

        /** @summary A regex that tests `true` on first invalid character.
         * @type {RegExp}
         * @private
         * @desc Valid characters include:
         *
         * * Localized digits
         * * Localized decimal point
         * * Standard digits (when `options.acceptStandardDigits` is truthy)
         * * Standard decimal point (when `options.acceptStandardDigits` is truthy)
         * * Cosmetic characters added by formatter as per `options` (for human-friendly readability).
         *
         * Any characters outside this set are considered invalid.
         *
         * Set by the constructor; consumed by the {@link module:localization~NumberFormatter#invalid|invalid} method.
         *
         * Testing a string against this pattern yields `true` if at least one invalid character or `false` if all characters are valid.
         * @memberOf NumberFormatter.prototype
         */
        this.invalids = new RegExp('[^' + this.format(11111).replace(this.map[1], '') + // thousands separator if in use
        this.map + // digits + decimal point
        ']');
    },

    /** @summary Tests for invalid characters.
     * @desc Tests a localized string representation of a number that it contains any invalid characters.
     *
     * The number may be unformatted or it may be formatted with any of the permitted formatting characters, as implied by the constructor's `options` (passed to `Intl.NumberFormat`). Any other characters are considered invalid.
     *
     * However, standard digits and the standard decimal point are considered valid if the value of `options.acceptStandardDigits` as provided to the constructor was truthy. (Of course, these are always valid for locales that use them.)
     *
     * Use this method to:
     * 1. Filter out invalid characters on a `onkeydown` event; or
     * 2. Test an edited string prior to calling the {@link module:localization~NumberFormatter#parse|parse}.
     *
     * NOTE: This method does not check grammatical syntax; it only checks for invalid characters.
     *
     * @param number
     * @returns {boolean|string} Falsy means valid which in this case means contains only valid characters.
     * @memberOf NumberFormatter.prototype
     */
    invalid: function invalid(number) {
        return this.invalids.test(number);
    },

    expectation: 'Expected a number with optional commas (thousands grouping separator), optional decimal point, and an optional fractional part.\n' + 'Comma separators are part of the format and will always be displayed for values >= 1000.\n' + 'Edited values are always saved in their entirety even though the formatted value is rounded to the specified number of decimal places.',

    /**
     * This method will:
     * * Convert localized digits and decimal point characters to standard digits and decimal point characters.
     * * "Clean" the string by ignoring all other characters.
     * * Coerce the string to a number primitive.
     * @param {string} formattedLocalizedNumber - May or may not be formatted.
     * @returns {number} Number primitive.
     * @throws {string} Invalid number.
     * @memberOf NumberFormatter.prototype
     */
    parse: function parse(formattedLocalizedNumber) {
        var number = Number(formattedLocalizedNumber.split('').map(this.demapper).join(''));

        if (isNaN(number)) {
            throw 'Invalid Number';
        }

        return number;
    }
});

function demap(c) {
    var d = this.map.indexOf(c) % 11;
    return d < 0 ? '' : d < 10 ? d : '.';
}

/**
 * @implements localizerInterface
 * @param {string} defaultLocale
 * @param {string} [locale=defaultlocale] - Passed to the {@link Intl.DateFormat|https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/DateFormat} constructor.
 * @param {object} [options] - Passed to the `Intl.DateFormat` constructor.
 * @constructor
 * @extends Formatter
 */
var DateFormatter = Formatter.extend('DateFormatter', {
    initialize: function initialize(defaultLocale, locale, options) {
        if ((typeof locale === 'undefined' ? 'undefined' : _typeof(locale)) === 'object') {
            options = locale;
        }

        options = options || {};

        /** @summary Transform a date object into human-friendly string representation.
         * @method
         */
        this.format = new Intl.DateTimeFormat(this.locale, options).format;

        // Get digits because may be chinese or "real Arabic" numerals.
        var testOptions = { useGrouping: false, style: 'decimal' },
            localizeNumber = new Intl.NumberFormat(this.locale, testOptions).format,
            localizedDigits = this.localizedDigits = localizeNumber(10123456789).substr(1, 10); // all localized digits in numerical order

        this.digitFormatter = formatDigit.bind(this);
        this.digitParser = parseDigit.bind(this);

        // Localize a test date with the default numeric parts to find out the resulting order of these parts.
        var yy = 1987,
            mm = 12,
            dd = 30,
            YY = this.transformNumber(this.digitFormatter, yy),
            MM = this.transformNumber(this.digitFormatter, mm),
            DD = this.transformNumber(this.digitFormatter, dd),
            testDate = new Date(yy, mm - 1, dd),
            localizeDate = new Intl.DateTimeFormat(this.locale).format,
            localizedDate = localizeDate(testDate),
            // all localized digits + localized punctuation
        missingDigits = new Intl.NumberFormat(this.locale).format(456),
            localizedNumberPattern = this.localizedNumberPattern = new RegExp('[' + localizedDigits + ']+', 'g'),
            parts = localizedDate.match(localizedNumberPattern);

        this.partsMap = {
            yy: parts.indexOf(YY),
            mm: parts.indexOf(MM),
            dd: parts.indexOf(DD)
        };

        if (options.acceptStandardDigits) {
            missingDigits += '1234567890';
        }

        /** @summary A regex that tests `true` on first invalid character.
         * @type {RegExp}
         * @private
         * @desc Valid characters include:
         *
         * * Localized digits
         * * Standard digits (when `options.acceptStandardDigits` is truthy)
         * * Localized punctuation to delimit date parts
         *
         * Any characters outside this set are considered invalid. Note that this only currently implemented when all three date parts are numeric
         *
         * Set by the constructor; consumed by the {@link NumberFormatter#valid|valid} method.
         *
         * Testing a string against this pattern yields `true` if at least one invalid character or `false` if all characters are valid.
         * @memberOf DateFormatter.prototype
         */
        this.invalids = new RegExp('[^' + localizedDate.replace(/-/g, '\\-') + missingDigits + ']');
    },

    /** @summary Tests for invalid characters.
     * @desc Tests a localized string representation of a number that it contains any invalid characters.
     *
     * The date is assumed to contain localized digits and punctuation as would be returned by `Intl.DateFormat` with the given `locale` and `options`. Any other characters are considered invalid.
     *
     * However, standard digits and the standard decimal point are also considered valid if the value of `options.acceptStandardDigits` as provided to the constructor was truthy. (Of course, these are always valid for locales that use them.)
     *
     * Use this method to:
     * 1. Filter out invalid characters on a `onkeydown` event; or
     * 2. Test an edited string prior to calling the {@link module:localization~DateFormatter#parse|parse}.
     *
     * NOTE: The current implementation only supports date formats using all numerics (which is the default for `Intl.DateFormat`).
     *
     * NOTE: This method does not check grammatical syntax; it only checks for invalid characters.
     *
     * @param number
     * @returns {boolean} Contains only valid characters.
     * @memberOf DateFormatter.prototype
     */
    invalid: function invalid(number) {
        return this.invalids.test(number);
    },

    /**
     * This method will:
     * * Convert localized date to Date object.
     * * "Clean" the string by ignoring all other characters.
     * * Coerce the string to a number primitive.
     * @param {string} localizedDate
     * @returns {Date}
     * @throws {string} Invalid date.
     * @memberOf DateFormatter.prototype
     */
    parse: function parse(localizedDate) {
        var date,
            parts = localizedDate.match(this.localizedNumberPattern);

        if (parts && parts.length === 3) {
            var y = this.transformNumber(this.digitParser, parts[this.partsMap.yy]),
                m = this.transformNumber(this.digitParser, parts[this.partsMap.mm]) - 1,
                d = this.transformNumber(this.digitParser, parts[this.partsMap.dd]);

            date = new Date(y, m, d);
        } else {
            throw 'Invalid Date';
        }

        return date;
    },

    /**
     * Transform a number to or from a string representation with localized digits.
     * @param {function} digitTransformer - A function bound to `this`.
     * @param {number} number
     * @returns {string}
     * @private
     * @memberOf DateFormatter.prototype
     */
    transformNumber: function transformNumber(digitTransformer, number) {
        return number.toString().split('').map(digitTransformer).join('');
    }
});

function formatDigit(d) {
    return this.localizedDigits[d];
}

function parseDigit(c) {
    var d = this.localizedDigits.indexOf(c);
    if (d < 0) {
        d = '';
    }
    return d;
}

/**
 * All members are localizers (conform to {@link localizerInterface}) with exception of `get`, `set`, and localizer constructors which are named (by convention) ending in "Formmatter".
 *
 * The application developer is free to add localizers and localizer factory methods. See the {@link Localization#construct|construct} convenience method which may be helpful in this regard.
 * @param locale
 * @param {object} [numberOptions]
 * @param {object} [dateOptions]
 * @constructor
 */
function Localization(locale, numberOptions, dateOptions) {
    this.locale = locale;

    /**
     * @name number
     * @see The {@link NumberFormatter|NumberFormatter} class
     * @memberOf Localization.prototype
     */
    this.int = this.float = this.construct('number', NumberFormatter, numberOptions);

    /**
     * @see The {@link DateFormatter|DateFormatter} class
     * @memberOf Localization.prototype
     */
    this.construct('date', DateFormatter, dateOptions);
}

Localization.prototype = {
    constructor: Localization.prototype.constructor,
    $$CLASS_NAME: 'Localization',

    /** @summary Creates a localizer from a localizer factory object using the default locale.
     * @desc Performs the following actions:
     * 1. Binds `Constructor` to `locale`.
     * 2. Adds the newly bound constructor to this object (for future reference) with the key "NameFormatter" (where "Name" is the localizer name, all lower case but with an initial capital).
     * 3. Uses the newly bound constructor to create a new localized localizer with the provided options.
     * 4. Adds new localizer to this object via {@link Localization#add|add}.
     *
     * @param {string} localizerName
     * @param {Constructor
     * @param {object} {factoryOptions}
     * @returns {localizerInterface} The new localizer.
     */
    construct: function construct(localizerName, Constructor, factoryOptions) {
        var constructorName = localizerName[0].toUpperCase() + localizerName.substr(1).toLowerCase() + 'Formatter',
            BoundConstructor = Constructor.bind(null, this.locale),
            localizer = new BoundConstructor(factoryOptions);

        this[constructorName] = BoundConstructor;

        return this.add(localizerName, localizer);
    },

    /** @summary Register a localizer.
     * @desc Checks the provided localizer that it conforms to {@link localizerInterface}
     * and adds it to the object using localizerName all lower case as the key.
     * @param {string} name
     * @param {localizerInterface} localizer
     * @memberOf Localization.prototype
     * @returns {localizerInterface} The provided localizer.
     */
    add: function add(name, localizer) {
        if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
            localizer = name;
            name = undefined;
        }

        if ((typeof localizer === 'undefined' ? 'undefined' : _typeof(localizer)) !== 'object' || typeof localizer.format !== 'function' || typeof localizer.parse !== 'function' || localizer.invalid && typeof localizer.invalid !== 'function' || localizer.expectation && typeof localizer.expectation !== 'string') {
            throw 'Expected localizer object to conform to interface.';
        }

        name = name || localizer.name;
        name = name && name.toLowerCase();
        this[name] = localizer;

        return localizer;
    },

    /**
     *
     * @param localizerName
     * @returns {localizerInterface}
     * @memberOf Localization.prototype
     */
    get: function get(name) {
        return this[name && name.toLowerCase()] || this.string;
    },

    ///  ///  ///  ///  ///    LOCALIZERS    ///  ///  ///  ///  ///

    // Special localizer for use by Chrome's date input control.
    chromeDate: {
        format: function format(date) {
            if (date != null) {
                if ((typeof date === 'undefined' ? 'undefined' : _typeof(date)) !== 'object') {
                    date = new Date(date);
                }

                var yy = date.getFullYear(),
                    m = date.getMonth() + 1,
                    mm = m < 10 ? '0' + m : m,
                    d = date.getDate(),
                    dd = d < 10 ? '0' + d : d;

                date = yy + '-' + mm + '-' + dd;
            } else {
                date = null;
            }
            return date;
        },
        parse: function parse(str) {
            var date,
                parts = str.split('-');
            if (parts && parts.length === 3) {
                date = new Date(parts[0], parts[1] - 1, parts[2]);
            } else {
                date = null;
            }
            return date;
        }
    },

    null: {
        format: function format(value) {
            return value;
        },
        parse: function parse(str) {
            return str;
        }
    },

    string: {
        format: function format(value) {
            return value + '';
        },
        parse: function parse(str) {
            return str + '';
        }
    }
};

module.exports = Localization;

},{"../Base":17}],90:[function(require,module,exports){
'use strict';

var Base = require('../Base');

/**
 * @class
 */
var Registry = Base.extend('Registry', {
    /**
     * @summary Register an item and return it.
     * @desc Adds an item to the registry using the provided name (or the class name), converted to all lower case.
     * @param {string} [name] - Case-insensitive item key. If not given, fallsback to `item.prototype.$$CLASS_NAME` or `item.prototype.name` or `item.name`.
     * @param [item] - If unregistered or omitted, nothing is added and method returns `undefined`.
     *
     * > Note: `$$CLASS_NAME` is normally set by providing a string as the (optional) first parameter (`alias`) in your {@link https://www.npmjs.com/package/extend-me|extend} call.
     *
     * @returns Newly registered item or `undefined` if unregistered.
     *
     * @memberOf Registry#
     */
    add: function add(name, item) {
        if (typeof name === 'function') {
            item = name;
            name = undefined;
        }

        if (!item) {
            return;
        }

        name = name || item.getClassName && item.getClassName();

        if (!name) {
            throw new this.HypergridError('Cannot register a "' + this.friendlyName() + '" without a name.');
        }

        return this[name] = item;
    },

    /**
     * @summary Register a synonym for an existing item.
     * @param {string} synonymName
     * @param {string} existingName
     * @returns {function|Constructor} The previously registered item this new synonym points to.
     * @memberOf Registry#
     */
    addSynonym: function addSynonym(synonymName, existingName) {
        return this[synonymName] = this.get(existingName);
    },

    /**
     * Fetch a registered item.
     * @param {string} [name]
     * @returns {*|undefined} A registered item or `undefined` if unregistered.
     * @memberOf Registry#
     */
    get: function get(name) {
        if (!name) {
            return;
        }

        var result = this[name]; // for performance reasons, do not convert to lower case

        if (!result) {
            var lowerName = name.toLowerCase(); // name may differ in case only
            for (var keys = [], r = this; Object.getPrototypeOf(r) instanceof Registry; r = Object.getPrototypeOf(r)) {
                keys = keys.concat(Object.keys(r));
            }
            var existingName = keys.find(function (key) {
                return lowerName === key.toLowerCase();
            });
            if (existingName) {
                result = this[existingName];
                this.addSynonym(name, existingName); // register found name as a synonym for faster access next time
            }
        }

        if (!result) {
            throw new this.HypergridError('Expected "' + name + '" to be a registered ' + this.friendlyName() + '.');
        }

        return result;
    },

    friendlyName: function friendlyName() {
        if (this.BaseClass) {
            var name = this.BaseClass.getClassName();
            name = name && name.replace(/([A-Z])/g, ' $1').trim().toLowerCase();
        }
        return name || '[unnamed class]';
    }
});

module.exports = Registry;

},{"../Base":17}],91:[function(require,module,exports){
'use strict';

var RangeSelectionModel = require('sparse-boolean-array');

/**
 *
 * @constructor
 * @desc We represent selections as a list of rectangles because large areas can be represented and tested against quickly with a minimal amount of memory usage. Also we need to maintain the selection rectangles flattened counter parts so we can test for single dimension contains. This is how we know to highlight the fixed regions on the edges of the grid.
 */

function SelectionModel(grid) {
    this.grid = grid;
    this.reset();
}

SelectionModel.prototype = {

    constructor: SelectionModel.prototype.constructor,

    /**
     * @type {boolean}
     * @memberOf SelectionModel.prototype
     */
    allRowsSelected: false,

    reset: function reset() {
        /**
         * @name selections
         * @type {Rectangle[]}
         * @summary The selection rectangles.
         * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
         * @memberOf SelectionModel.prototype
         */
        this.selections = [];

        /**
         * @name flattenedX
         * @type {Rectangle[]}
         * @summary The selection rectangles flattened in the horizontal direction (no width).
         * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
         * @memberOf SelectionModel.prototype
         */
        this.flattenedX = [];

        /**
         * @name flattenedY
         * @type {Rectangle[]}
         * @summary The selection rectangles flattened in the vertical direction (no height).
         * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
         * @memberOf SelectionModel.prototype
         */
        this.flattenedY = [];

        /**
         * @name rowSelectionModel
         * @type {RangeSelectionModel}
         * @summary The selection rectangles.
         * @desc Created as a new RangeSelectionModel upon instantiation by the {@link SelectionModel|constructor}.
         * @memberOf SelectionModel.prototype
         */
        this.rowSelectionModel = new RangeSelectionModel();

        /**
         * @name columnSelectionModel
         * @type {RangeSelectionModel}
         * @summary The selection rectangles.
         * @desc Created as a new RangeSelectionModel upon instantiation by the {@link SelectionModel|constructor}.
         * @memberOf SelectionModel.prototype
         */
        this.columnSelectionModel = new RangeSelectionModel();

        this.setLastSelectionType('');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getLastSelection: function getLastSelection() {
        var sels = this.selections;
        var sel = sels[sels.length - 1];
        return sel;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getLastSelectionType: function getLastSelectionType() {
        return this.lastSelectionType;
    },

    /**
     * @param type
     * @memberOf SelectionModel.prototype
     */
    setLastSelectionType: function setLastSelectionType(type) {
        this.lastSelectionType = type;
    },

    checkCellTop: function checkCellTop(x, y1) {
        var dm = this.grid.behavior.dataModel;
        if (dm.isRenderSkipNeeded(x, y1) && dm.getRowspan(x, y1 - 1) > 0) {
            // check if expand available
            var yOffset = y1;
            while (dm.isRenderSkipNeeded(x, yOffset) && yOffset > 0) {
                --yOffset;
            }
            y1 = yOffset;
        }
        return y1;
    },

    checkCellBottom: function checkCellBottom(x, y2) {
        var span = this.grid.behavior.dataModel.getRowspan(x, y2);
        if (span > 0) {
            y2 += span; // just add rowspan if it available
        }
        return y2;
    },

    checkCellLeft: function checkCellLeft(x1, y) {
        var dm = this.grid.behavior.dataModel;
        if (dm.isRenderSkipNeeded(x1, y) && dm.getColspan(x1 - 1, y) > 0) {
            // check if expand available
            var xOffset = x1;
            while (dm.isRenderSkipNeeded(xOffset, y) && xOffset > 0) {
                --xOffset;
            }
            x1 = xOffset;
        }
        return x1;
    },

    checkCellRight: function checkCellRight(x2, y) {
        var span = this.grid.behavior.dataModel.getColspan(x2, y);
        if (span > 0) {
            x2 += span; // just add colspan if it available
        }
        return x2;
    },

    checkSelectionCorners: function checkSelectionCorners(ox, oy, ex, ey) {
        var x1 = ox,
            x2 = ox + ex,
            swapX = x1 > x2;
        var y1 = oy,
            y2 = oy + ey,
            swapY = y1 > y2;

        if (swapX) {
            x2 = [x1, x1 = x2][0];
        }
        if (swapY) {
            y2 = [y1, y1 = y2][0];
        }

        // check top cells
        for (var x = x1; x <= x2; ++x) {
            y1 = this.checkCellTop(x, y1);
        }

        // check bottom cells
        for (var _x = x1; _x <= x2; ++_x) {
            y2 = this.checkCellBottom(_x, y2);
        }

        // check left cells
        for (var y = y1; y <= y2; ++y) {
            x1 = this.checkCellLeft(x1, y);
        }

        // check right cells
        for (var _y = y1; _y <= y2; ++_y) {
            x2 = this.checkCellRight(x2, _y);
        }

        if (swapX) {
            x2 = [x1, x1 = x2][0];
        }
        if (swapY) {
            y2 = [y1, y1 = y2][0];
        }

        if (ox !== x1 || oy !== y1 || ex !== x2 - x1 || ey !== y2 - y1) {
            return this.checkSelectionCorners(x1, y1, x2 - x1, y2 - y1); // check one more time because of new included cells
        }

        return { ox: x1, oy: y1, ex: x2 - x1, ey: y2 - y1 };
    },

    /**
     * @memberOf SelectionModel.prototype
     * @description Select the region described by the given coordinates.
     *
     * @param {number} _ox - origin x coordinate
     * @param {number} _oy - origin y coordinate
     * @param {number} _ex - extent x coordinate
     * @param {number} _ey - extent y coordinate
     * @param {boolean} silent - whether to fire selection changed event
     */
    select: function select(_ox, _oy, _ex, _ey, silent) {
        if (isNaN(_ex)) {
            _ex = 0;
        }
        if (isNaN(_ey)) {
            _ey = 0;
        }

        var _checkSelectionCorner = this.checkSelectionCorners(_ox, _oy, _ex, _ey),
            ox = _checkSelectionCorner.ox,
            oy = _checkSelectionCorner.oy,
            ex = _checkSelectionCorner.ex,
            ey = _checkSelectionCorner.ey;

        var newSelection = this.grid.newRectangle(ox, oy, ex, ey);

        //Cache the first selected cell before it gets normalized to top-left origin
        newSelection.firstSelectedCell = this.grid.newPoint(this.checkCellLeft(_ox, _oy), this.checkCellTop(_ox, _oy));

        newSelection.lastSelectedCell = newSelection.firstSelectedCell.x === newSelection.origin.x && newSelection.firstSelectedCell.y === newSelection.origin.y ? newSelection.corner : newSelection.origin;

        if (this.grid.properties.multipleSelections) {
            this.selections.push(newSelection);
            this.flattenedX.push(newSelection.flattenXAt(0));
            this.flattenedY.push(newSelection.flattenYAt(0));
        } else {
            this.selections[0] = newSelection;
            this.flattenedX[0] = newSelection.flattenXAt(0);
            this.flattenedY[0] = newSelection.flattenYAt(0);
        }
        this.setLastSelectionType('cell');

        if (!silent) {
            this.grid.selectionChanged();
        }
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     */
    toggleSelect: function toggleSelect(ox, oy, ex, ey) {

        var selected, index;

        selected = this.selections.find(function (selection, idx) {
            index = idx;
            return selection.origin.x === ox && selection.origin.y === oy && selection.extent.x === ex && selection.extent.y === ey;
        });

        if (selected) {
            this.selections.splice(index, 1);
            this.flattenedX.splice(index, 1);
            this.flattenedY.splice(index, 1);
            this.grid.selectionChanged();
        } else {
            this.select(ox, oy, ex, ey);
        }
    },

    /**
     * @memberOf SelectionModel.prototype
     * @desc Remove the last selection that was created.
     */
    clearMostRecentSelection: function clearMostRecentSelection(keepRowSelections) {
        if (!keepRowSelections) {
            this.setAllRowsSelected(false);
        }
        if (this.selections.length) {
            --this.selections.length;
        }
        if (this.flattenedX.length) {
            --this.flattenedX.length;
        }
        if (this.flattenedY.length) {
            --this.flattenedY.length;
        }
        //this.getGrid().selectionChanged();
    },

    selectionModelClearMostRecent: function selectionModelClearMostRecent(selectionModel) {
        selectionModel.clearMostRecentSelection();
        this.clearMostRecentSelection();
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearMostRecentColumnSelection: function clearMostRecentColumnSelection() {
        this.selectionModelClearMostRecent(this.columnSelectionModel);
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearMostRecentRowSelection: function clearMostRecentRowSelection() {
        this.selectionModelClearMostRecent(this.rowSelectionModel);
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearRowSelection: function clearRowSelection() {
        this.rowSelectionModel.clear();
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getSelections: function getSelections() {
        return this.selections;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean} There are active selection(s).
     */
    hasSelections: function hasSelections() {
        return this.selections.length !== 0;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
    hasRowSelections: function hasRowSelections() {
        return !this.rowSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
    hasColumnSelections: function hasColumnSelections() {
        return !this.columnSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @return {boolean} Selection covers a specific column.
     * @param {number} y
     */
    isCellSelectedInRow: function isCellSelectedInRow(y) {
        return this._isCellSelected(this.flattenedX, 0, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns Selection covers a specific row.
     * @param {number} x
     */
    isCellSelectedInColumn: function isCellSelectedInColumn(x) {
        return this._isCellSelected(this.flattenedY, x, 0);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @summary Selection query function.
     * @returns {boolean} The given cell is selected (part of an active selection).
     * @param {Rectangle[]} selections - Selection rectangles to search through.
     * @param {number} x
     * @param {number} y
     */
    isSelected: function isSelected(x, y) {
        return this.isColumnSelected(x) || this.isRowSelected(y) || this._isCellSelected(this.selections, x, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    isCellSelected: function isCellSelected(x, y) {
        return this._isCellSelected(this.selections, x, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param selections
     * @param x
     * @param y
     * @returns {boolean}
     * @private
     */
    _isCellSelected: function _isCellSelected(selections, x, y) {
        var self = this;
        return !!selections.find(function (selection) {
            return self.rectangleContains(selection, x, y);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @desc empty out all our state
     *
     */
    clear: function clear(keepRowSelections) {
        this.selections.length = 0;
        this.flattenedX.length = 0;
        this.flattenedY.length = 0;
        this.columnSelectionModel.clear();
        if (!keepRowSelections) {
            this.setAllRowsSelected(false);
            this.rowSelectionModel.clear();
        }
        this.grid.selectionChanged();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     * @returns {boolean}
     */
    isRectangleSelected: function isRectangleSelected(ox, oy, ex, ey) {
        return !!this.selections.find(function (selection) {
            return selection.origin.x === ox && selection.origin.y === oy && selection.extent.x === ex && selection.extent.y === ey;
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @returns {*}
     */
    isColumnSelected: function isColumnSelected(x) {
        return this.columnSelectionModel.isSelected(x);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y
     * @returns {boolean|*}
     */
    isRowSelected: function isRowSelected(y) {
        return this.allRowsSelected || this.rowSelectionModel.isSelected(y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x1
     * @param x2
     */
    selectColumn: function selectColumn(x1, x2) {
        if (x2 === undefined) {
            x2 = x1;
        }

        // rewrite if merged cells will be not first cell in row
        if (x1 <= x2) {
            x1 = this.checkCellLeft(x1, 0);
            x2 = this.checkCellRight(x2, 0);
        } else {
            x1 = this.checkCellRight(x1, 0);
            x2 = this.checkCellLeft(x2, 0);
        }

        this.columnSelectionModel.select(x1, x2);
        this.select(x1, 0, x2 - x1, this.grid.getRowCount() - 1);
        this.grid.selectColDefsForApi();
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    selectAllRows: function selectAllRows() {
        this.clear();
        this.setAllRowsSelected(true);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */

    setAllRowsSelected: function setAllRowsSelected(isIt) {
        this.allRowsSelected = isIt;
        if (isIt) {
            this.select(0, 0, this.grid.getColumnCount() - 1, this.grid.getRowCount() - 1);
        }
    },

    areAllRowsSelected: function areAllRowsSelected() {
        return this.allRowsSelected;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y1
     * @param y2
     */
    selectRow: function selectRow(y1, y2) {
        if (y2 === undefined) {
            y2 = y1;
        }

        // rewrite if merged cells will be not first cell in row
        if (y1 <= y2) {
            y1 = this.checkCellTop(0, y1);
            y2 = this.checkCellBottom(0, y2);
        } else {
            y1 = this.checkCellBottom(0, y1);
            y2 = this.checkCellTop(0, y2);
        }

        this.rowSelectionModel.select(y1, y2);
        this.select(0, y1, this.grid.getColumnCount() - 1, y2 - y1);
        this.grid.selectColDefsForApi();
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x1
     * @param x2
     */
    deselectColumn: function deselectColumn(x1, x2) {
        this.columnSelectionModel.deselect(x1, x2);
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y1
     * @param y2
     */
    deselectRow: function deselectRow(y1, y2) {
        if (this.areAllRowsSelected()) {
            // To deselect a row, we must first remove the all rows flag...
            this.setAllRowsSelected(false);
            // ...and create a single range representing all rows
            this.rowSelectionModel.select(0, this.grid.getRowCount() - 1);
        }
        this.rowSelectionModel.deselect(y1, y2);
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getSelectedRows: function getSelectedRows() {
        if (this.areAllRowsSelected()) {
            var headerRows = this.grid.getHeaderRowCount();
            var rowCount = this.grid.getRowCount() - headerRows;
            var result = new Array(rowCount);
            for (var i = 0; i < rowCount; i++) {
                result[i] = i + headerRows;
            }
            return result;
        }
        return this.rowSelectionModel.getSelections();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*|Array.Array.number}
     */
    getSelectedColumns: function getSelectedColumns() {
        return this.columnSelectionModel.getSelections();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
    isColumnOrRowSelected: function isColumnOrRowSelected() {
        return !this.columnSelectionModel.isEmpty() || !this.rowSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {Array}
     */
    getFlattenedYs: function getFlattenedYs() {
        var result = [];
        var set = {};
        this.selections.forEach(function (selection) {
            var top = selection.origin.y;
            var size = selection.extent.y + 1;
            for (var r = 0; r < size; r++) {
                var ti = r + top;
                if (!set[ti]) {
                    result.push(ti);
                    set[ti] = true;
                }
            }
        });
        result.sort(function (x, y) {
            return x - y;
        });
        return result;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param offset
     */
    selectRowsFromCells: function selectRowsFromCells(offset, keepRowSelections) {
        offset = offset || 0;

        var sm = this.rowSelectionModel;

        if (!keepRowSelections) {
            this.setAllRowsSelected(false);
            sm.clear();
        }

        this.selections.forEach(function (selection) {
            var top = selection.origin.y,
                extent = selection.extent.y;
            top += offset;
            sm.select(top, top + extent);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param offset
     */
    selectColumnsFromCells: function selectColumnsFromCells(offset) {
        offset = offset || 0;

        var sm = this.columnSelectionModel;
        sm.clear();

        this.selections.forEach(function (selection) {
            var left = selection.origin.x,
                extent = selection.extent.x;
            left += offset;
            sm.select(left, left + extent);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    isInCurrentSelectionRectangle: function isInCurrentSelectionRectangle(x, y) {
        var last = this.selections[this.selections.length - 1];
        return last && this.rectangleContains(last, x, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    isFirstSelectedCell: function isFirstSelectedCell(x, y) {
        var firstSelectedCell = this.getFirstSelectedCellOfLastSelection();
        return firstSelectedCell && firstSelectedCell.x === x && firstSelectedCell.y === y;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @desc Returns first selected cell of last selection
     * @returns {*}
     */
    getFirstSelectedCellOfLastSelection: function getFirstSelectedCellOfLastSelection() {
        var last = this.selections[this.selections.length - 1];
        if (last) {
            return last.firstSelectedCell;
        }
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param rect
     * @param x
     * @param y
     * @returns {boolean}
     */
    rectangleContains: function rectangleContains(rect, x, y) {
        //TODO: explore why this works and contains on rectanglular does not
        var minX = rect.origin.x;
        var minY = rect.origin.y;
        var maxX = minX + rect.extent.x;
        var maxY = minY + rect.extent.y;

        if (rect.extent.x < 0) {
            minX = maxX;
            maxX = rect.origin.x;
        }

        if (rect.extent.y < 0) {
            minY = maxY;
            maxY = rect.origin.y;
        }

        var result = x >= minX && y >= minY && x <= maxX && y <= maxY;

        return result;
    }
};

module.exports = SelectionModel;

},{"sparse-boolean-array":15}],92:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var cellEventProperties = Object.defineProperties({}, { // all props non-enumerable
    /**
     * The raw value of the cell, unformatted.
     * @memberOf CellEvent#
     */
    value: {
        get: function get() {
            return this.subgrid.getValue(this.valueCell.x, this.valueCell.y);
        },
        set: function set(value) {
            this.subgrid.setValue(this.valueCell.x, this.valueCell.y, value);
        }
    },

    /**
     * Shows cell value is a http/https url value
     * @memberOf CellEvent#
     */
    isValueUrl: {
        get: function get() {
            return this.subgrid.isValueUrl(this.value);
        }
    },

    /**
     * An object representing the whole data row, including hidden columns.
     * @type {object}
     * @memberOf CellEvent#
     */
    dataRow: {
        get: function get() {
            return this.subgrid.getRow(this.dataCell.y, this.column.treeLevel);
        }
    },

    /**
     * The colspan value of the cell, unformatted.
     * @memberOf CellEvent#
     */
    colspan: {
        get: function get() {
            return this.subgrid.getColspan(this.dataCell.x, this.dataCell.y);
        }
    },

    /**
     * The rowspan value of the cell, unformatted.
     * @memberOf CellEvent#
     */
    rowspan: {
        get: function get() {
            return this.subgrid.getRowspan(this.dataCell.x, this.dataCell.y);
        }
    },

    /**
     * If true, cell will be ignored on render
     * @memberOf CellEvent#
     */
    isRenderSkipNeeded: {
        get: function get() {
            return this.subgrid.isRenderSkipNeeded(this.valueCell.x, this.valueCell.y);
        }
    },

    /**
     * Shows, is cell need to be hidden because of left column
     * @memberOf CellEvent#
     */
    isColspanedByLeftColumn: {
        get: function get() {
            return this.subgrid.isColspanedByLeftColumn(this.dataCell.x, this.dataCell.y);
        }
    },

    /**
     * Returns index of row, that overlaps current cell
     * @memberOf CellEvent#
     */
    rowspanMainRow: {
        get: function get() {
            return this.subgrid.getRowspanMainRow(this.dataCell.x, this.dataCell.y);
        }
    },

    cellData: {
        get: function get() {
            return this.subgrid._getDataRowObject(this.valueCell.x, this.valueCell.y);
        }
    },

    /**
     * Returns name of column, that overlaps current cell
     * @memberOf CellEvent#
     */
    colspanMainColumnName: {
        get: function get() {
            return this.subgrid.getColspanMainColumnName(this.dataCell.x, this.dataCell.y);
        }
    },

    /**
     * Returns child colDefs, if cell has it
     * @memberOf CellEvent#
     * @return {array}
     */
    childColumns: {
        get: function get() {
            return this.subgrid.getChildColumnsFromCell(this.dataCell.x, this.dataCell.y);
        }
    },

    /**
     * Returns boolean value, that shows, is cell has child colDefs
     * @memberOf CellEvent#
     * @return {boolean}
     */
    isExpandableColumn: {
        get: function get() {
            return this.subgrid.getHasChildColumnsFromCell(this.dataCell.x, this.dataCell.y);
        }
    },

    /**
     * Returns boolean value, that shows, is child columns needed to be shown by default
     * @memberOf CellEvent#
     * @return {boolean}
     */
    isColumnOpenByDefault: {
        get: function get() {
            return this.subgrid.getIsColumnOpenByDefaultFromCell(this.dataCell.x, this.dataCell.y);
        }
    },

    /**
     * Returns boolean value, that shows, is cell has child colDefs
     * @memberOf CellEvent#
     * @return {boolean}
     */
    isColumnExpanded: {
        get: function get() {
            return this.subgrid.getIsColumnGroupShowFromCell(this.dataCell.x, this.dataCell.y);
        }
    },

    /**
     * Returns boolean value, that shows, is cell was rowspaned by any row at left
     * @memberOf CellEvent#
     * @return {boolean}
     */
    isRowspanedByRow: {
        get: function get() {
            return this.subgrid.isRowspanedByRow(this.dataCell.x, this.dataCell.y);
        }
    },

    /**
     * Returns colDefs group id, if exist (if cell represent fictive header)
     * @memberOf CellEvent#
     * @return {number}
     */
    columnGroupId: {
        get: function get() {
            return this.subgrid.getColumnGroupIdFromCell(this.dataCell.x, this.dataCell.y);
        }
    },

    /**
     * The formatted value of the cell.
     * @memberOf CellEvent#
     */
    formattedValue: {
        get: function get() {
            return this._formattedValue || (this._formattedValue = this.grid.formatValue(this.properties.format, this.value, this.rowProperties.headerRow));
        }
    },

    /**
     * @summary The formatted and highlighted value of the cell.
     *  @memberOf CellEvent#
     */
    highlightedChars: {
        get: function get() {
            var highlights = [];

            var highLightText = this.properties.highLightText;

            if (!highLightText) {
                return highlights;
            }

            var searchType = this.column ? this.column.searchType : 'NONE';
            if (searchType === 'NONE' || searchType === undefined) {
                return highlights;
            }

            var str = this.formattedValue;
            if (!str) {
                return highlights;
            }

            var reg = this.subgrid.getHighlightRegex(highLightText, searchType);
            if (!reg) {
                return highlights;
            }

            var m = void 0;
            while ((m = reg.exec(str + '')) != null) {
                highlights.push({ from: m.index, to: m.index + m[0].length });
            }

            return highlights;
        }
    },

    /**
     * The bounds of the cell.
     * @property {number} left
     * @property {number} top
     * @property {number} width
     * @property {number} height
     * @memberOf CellEvent#
     */
    bounds: {
        get: function get() {
            return this._bounds || (this._bounds = {
                x: this.visibleColumn.left,
                y: this.visibleRow.top,
                width: this.visibleColumn.width + (this.colspan ? this.behavior.getAdditionalWidth(this.dataCell.x, this.dataCell.y) : 0),
                height: this.visibleRow.height + (this.rowspan ? this.behavior.getAdditionalHeight(this.dataCell.x, this.dataCell.y) : 0)
            });
        }
    },

    columnProperties: { get: function get() {
            var cp = this._columnProperties;
            if (!cp) {
                cp = this.column.properties;
                if (this.isHandleColumn) {
                    cp = cp.rowHeader;
                } else if (this.isTreeColumn) {
                    cp = cp.treeHeader;
                } else if (this.isDataRow) {
                    // cp already set to basic props
                } else if (this.isFilterRow) {
                    cp = cp.filterProperties;
                } else {
                    // unselected header, summary, etc., all have save look as unselected header
                    cp = cp.columnHeader;
                }
                this._columnProperties = cp;
            }
            return cp;
        } },
    cellOwnProperties: { get: function get() {
            // do not use for get/set prop because may return null; instead use .getCellProperty('prop') or .properties.prop (preferred) to get, setCellProperty('prop', value) to set
            if (this._cellOwnProperties === undefined) {
                this._cellOwnProperties = this.column.getCellOwnProperties(this.dataCell.y, this.subgrid);
            }

            // null return means there is no cell properties object
            return this._cellOwnProperties;
        } },
    /**
     * @returns {string} Cell properties object if it exists, else the column properties object it would have as a prototype if did exist.
     * @method* @memberOf CellEvent#
     */
    properties: {
        get: function get() {
            if (this._properties) {
                return this._properties;
            }

            var props = shallowClone(this.cellOwnProperties || this.columnProperties);

            this._cellOwnDefinedProperties = this._cellOwnDefinedProperties || this.subgrid.getDefinedCellProperties(this.valueCell.x, this.valueCell.y);

            if (props && (typeof props === 'undefined' ? 'undefined' : _typeof(props)) === 'object' && this._cellOwnDefinedProperties && _typeof(this._cellOwnDefinedProperties) === 'object' && Object.keys(this._cellOwnDefinedProperties).length) {
                Object.assign(props, this._cellOwnDefinedProperties);
            }

            return this._properties = props;
        }
    },
    /**
     * @param {string} key - Property name.
     * @returns {string} Property value.
     * @method
     * @memberOf CellEvent#
     */
    getCellProperty: { value: function value(key) {
            // included for completeness but `.properties[key]` is preferred
            return this.properties[key];
        } },
    /**
     * @param {string} key - Property name.
     * @param {string} value - Property value.
     * @method
     * @memberOf CellEvent#
     */
    setCellProperty: { value: function value(key, _value) {
            // do not use `.cellOwnProperties[key] = value` because object may be null (this method creates new object as needed)
            this._cellOwnProperties = this.column.setCellProperty(this.dataCell.y, key, _value, this.subgrid);
        } },

    rowOwnProperties: {
        // undefined return means there is no row properties object
        get: function get() {
            return this.behavior.getRowProperties(this, undefined, this.subgrid);
        }
    },
    rowProperties: {
        get: function get() {
            // use carefully! creates new object as needed; only use when object definitely needed: for setting prop with `.rowProperties[key] = value` or `Object.assign(.rowProperties, {...})`; use getRowProperty(key) instead for getting a property that may not exist because it will not create a new object
            return this.behavior.getRowProperties(this, null, this.subgrid);
        },
        set: function set(properties) {
            // for resetting whole row properties object: `.rowProperties = {...}`
            this.behavior.setRowProperties(this, properties, this.subgrid); // calls `stateChanged()`
        }
    },
    getRowProperty: { value: function value(key) {
            // undefined return means there is no row properties object OR no such row property `[key]`
            var rowProps = this.rowOwnProperties;
            return rowProps && rowProps[key];
        } },
    setRowProperty: { value: function value(key, _value2) {
            // creates new object as needed
            this.rowProperties[key] = _value2; // todo: call `stateChanged()` after refac-as-flags
        } },

    // special method for use by renderer which reuses cellEvent object for performance reasons
    reset: {
        value: function value(visibleColumn, visibleRow) {
            // getter caches
            this._columnProperties = undefined;
            this._cellOwnProperties = undefined;
            this._cellOwnDefinedProperties = undefined;
            this._bounds = undefined;
            this._formattedValue = undefined;
            this._properties = undefined;

            // partial render support
            this.snapshot = [];
            this.minWidth = undefined;
            // this.disabled = undefined;

            this.visibleColumn = visibleColumn;
            this.visibleRow = visibleRow;

            this.subgrid = visibleRow.subgrid;

            this.column = visibleColumn.column; // enumerable so will be copied to cell renderer object

            this.gridCell.x = visibleColumn.columnIndex;
            this.gridCell.y = visibleRow.index;

            this.valueCell.x = this.dataCell.x = this.column && this.column.index;
            this.valueCell.y = this.dataCell.y = visibleRow.rowIndex;

            if (this.isRenderSkipNeeded) {
                if (this.valueCell.x > 1 && !this.grid.isColumnVisible(this.valueCell.x - 1)) {
                    this.valueCell.x = this.grid.selectionModel.checkCellLeft(this.valueCell.x, this.valueCell.y);
                }
                if (this.valueCell.y > 0 && !this.grid.isDataRowVisible(this.valueCell.y - 1)) {
                    this.valueCell.y = this.grid.selectionModel.checkCellTop(this.valueCell.x, this.valueCell.y);
                }
            }
        }
    },

    /**
     * Set up this `CellEvent` instance to point to the cell at the given grid coordinates.
     * @desc If the requested cell is not be visible (due to being scrolled out of view or outside the bounds of the rendered grid), the instance is not reset.
     * @param {number} gridC - Horizontal grid cell coordinate adjusted for horizontal scrolling after fixed columns.
     * @param {number} gridY - Raw vertical grid cell coordinate.
     * @returns {boolean} Visibility.
     * @method
     * @memberOf CellEvent#
     */
    resetGridCY: { value: function value(gridC, gridY) {
            var vr,
                vc,
                visible = (vc = this.renderer.getVisibleColumn(gridC)) && (vr = this.renderer.getVisibleRow(gridY));
            if (visible) {
                this.reset(vc, vr);
            }
            return visible;
        } },

    /**
     * Set up this `CellEvent` instance to point to the cell at the given grid coordinates.
     * @desc If the requested cell is not be visible (due to being scrolled out of view or outside the bounds of the rendered grid), the instance is not reset.
     * @param {number} gridX - Raw horizontal grid cell coordinate.
     * @param {number} gridY - Raw vertical grid cell coordinate.
     * @returns {boolean} Visibility.
     * @method
     * @memberOf CellEvent#
     */
    resetGridXY: { value: function value(gridX, gridY) {
            var vr,
                vc,
                visible = (vc = this.renderer.visibleColumns[gridX]) && (vr = this.renderer.getVisibleRow(gridY));
            if (visible) {
                this.reset(vc, vr);
            }
            return visible;
        } },

    /**
     * @summary Set up this `CellEvent` instance to point to the cell at the given data coordinates.
     * @desc If the requested cell is not be visible (due to being scrolled out of view), the instance is not reset.
     * @param {number} dataX - Horizontal data cell coordinate.
     * @param {number} dataY - Vertical data cell coordinate.
     * @param {dataModelAPI} [subgrid=this.behavior.subgrids.data]
     * @returns {boolean} Visibility.
     * @method
     * @memberOf CellEvent#
     */
    resetDataXY: { value: function value(dataX, dataY, subgrid) {
            var vr,
                vc,
                visible = (vc = this.renderer.getVisibleDataColumn(dataX)) && (vr = this.renderer.getVisibleDataRow(dataY, subgrid));
            if (visible) {
                this.reset(vc, vr);
            }
            return visible;
        } },

    /**
     * Set up this `CellEvent` instance to point to the cell at the given grid column and data row coordinates.
     * @desc If the requested cell is not be visible (due to being scrolled out of view or outside the bounds of the rendered grid), the instance is not reset.
     * @param {number} gridX - Horizontal grid cell coordinate (adjusted for horizontal scrolling after fixed columns).
     * @param {number} dataY - Vertical data cell coordinate.
     * @param {dataModelAPI} [subgrid=this.behavior.subgrids.data]
     * @param {boolean} [useAllCells] - Search in all rows and columns instead of only rendered ones.
     * @returns {boolean} Visibility.
     * @method
     * @memberOf CellEvent#
     */
    resetGridXDataY: { value: function value(gridX, dataY, subgrid, useAllCells) {
            var visible, vc, vr;

            if (useAllCells) {
                // When expanding selections larger than the viewport, the origin/corner
                // points may not be rendered and would normally fail to reset cell's position.
                // Mock column and row objects for this.reset() to use:
                vc = {
                    column: this.behavior.getColumn(gridX),
                    columnIndex: gridX
                };
                vr = {
                    subgrid: subgrid || this.behavior.subgrids.lookup.data,
                    rowIndex: dataY
                };
                visible = true;
            } else {
                visible = (vc = this.renderer.getVisibleColumn(gridX)) && (vr = this.renderer.getVisibleDataRow(dataY, subgrid));
            }

            if (visible) {
                this.reset(vc, vr);
            }

            return visible && this;
        } },

    /**
     * Copy self with or without own properties
     * @param {boolan} [assign=false] - Copy the own properties to the clone.
     * @returns {CellEvent}
     * @method
     * @memberOf CellEvent#
     */
    clone: { value: function value(assign) {
            var cellEvent = new this.constructor();

            cellEvent.resetGridXY(this.visibleColumn.index, this.visibleRow.index);

            if (assign) {
                // copy own props
                Object.assign(cellEvent, this);
            }

            return cellEvent;
        } },

    editPoint: {
        get: function get() {
            throw 'The `.editPoint` property is no longer available as of v1.2.10. Use the following coordinates instead:\n' + '`.gridCell.x` - The active column index. (Adjusted for column scrolling after fixed columns.)\n' + '`.gridCell.y` - The vertical grid coordinate. (Unaffected by row scrolling.)\n' + '`.dataCell.x` - The data model\'s column index. (Unaffected by column scrolling.)\n' + '`.dataCell.y` - The data model\'s row index. (Adjusted for data row scrolling after fixed rows.)\n';
        }
    },

    /** "Visible" means scrolled into view.
     * @type {boolean}
     * @memberOf CellEvent#
     */
    isRowVisible: { get: function get() {
            return !!this.visibleRow;
        } },
    /** "Visible" means scrolled into view.
     * @type {boolean}
     * @memberOf CellEvent#
     */
    isColumnVisible: { get: function get() {
            return !!this.visibleColumn;
        } },
    /** "Visible" means scrolled into view.
     * @type {boolean}
     * @memberOf CellEvent#
     */
    isCellVisible: { get: function get() {
            return this.isRowVisible && this.isColumnVisible;
        } },

    /** A data row is any row in the data subgrid; all other rows (headers, footers, _etc._) are not data rows.
     * @type {boolean}
     * @memberOf CellEvent#
     */
    isDataRow: { get: function get() {
            return this.subgrid.isData;
        } },
    /** A data column is any column that is not the row number column or the tree column.
     * @type {boolean}
     * @memberOf CellEvent#
     */
    isDataColumn: { get: function get() {
            return this.gridCell.x >= 0;
        } },
    /** A data cell is a cell in both a data row and a data column.
     * @type {boolean}
     * @memberOf CellEvent#
     */
    isDataCell: { get: function get() {
            return this.isDataRow && this.isDataColumn;
        } },

    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isRowSelected: { get: function get() {
            return this.isDataRow && this.selectionModel.isRowSelected(this.dataCell.y);
        } },
    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isColumnSelected: { get: function get() {
            return this.isDataColumn && this.selectionModel.isColumnSelected(this.gridCell.x);
        } },
    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isCellSelected: { get: function get() {
            return this.selectionModel.isCellSelected(this.gridCell.x, this.dataCell.y);
        } },

    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isRowHovered: { get: function get() {
            return this.grid.canvas.hasMouse && this.isDataRow && this.grid.hoverCell && this.grid.hoverCell.y === this.gridCell.y;
        } },
    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isColumnHovered: { get: function get() {
            return this.grid.canvas.hasMouse && this.isDataColumn && this.grid.hoverCell && this.grid.hoverCell.x === this.gridCell.x;
        } },
    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isCellHovered: { get: function get() {
            return this.isRowHovered && this.isColumnHovered;
        } },

    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isRowFixed: { get: function get() {
            return this.isDataRow && this.dataCell.y < this.grid.properties.fixedRowCount;
        } },
    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isColumnFixed: { get: function get() {
            return this.isDataColumn && this.gridCell.x < this.grid.properties.fixedColumnCount;
        } },
    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isCellFixed: { get: function get() {
            return this.isRowFixed && this.isColumnFixed;
        } },

    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isHandleColumn: { get: function get() {
            return this.gridCell.x === this.behavior.rowColumnIndex && this.grid.properties.showRowNumbers;
        } },
    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isHandleCell: { get: function get() {
            return this.isHandleColumn && this.isDataRow;
        } },

    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isTreeColumn: { get: function get() {
            return this.gridCell.x === this.behavior.treeColumnIndex;
        } },

    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isHeaderRow: { get: function get() {
            return this.subgrid.isHeader;
        } },
    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isHeaderHandle: { get: function get() {
            return this.isHeaderRow && this.isHandleColumn;
        } },
    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isHeaderCell: { get: function get() {
            return this.isHeaderRow && this.isDataColumn;
        } },

    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isFilterRow: { get: function get() {
            return this.subgrid.isFilter;
        } },
    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isFilterHandle: { get: function get() {
            return this.isFilterRow && this.isHandleColumn;
        } },
    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isFilterCell: { get: function get() {
            return this.isFilterRow && this.isDataColumn;
        } },

    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isSummaryRow: { get: function get() {
            return this.subgrid.isSummary;
        } },
    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isSummaryHandle: { get: function get() {
            return this.isSummaryRow && this.isHandleColumn;
        } },
    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isSummaryCell: { get: function get() {
            return this.isSummaryRow && this.isDataColumn;
        } },

    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isTopTotalsRow: { get: function get() {
            return this.subgrid === this.behavior.subgrids.lookup.topTotals;
        } },
    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isTopTotalsHandle: { get: function get() {
            return this.isTopTotalsRow && this.isHandleColumn;
        } },
    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isTopTotalsCell: { get: function get() {
            return this.isTopTotalsRow && this.isDataColumn;
        } },

    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isBottomTotalsRow: { get: function get() {
            return this.subgrid === this.behavior.subgrids.lookup.bottomTotals;
        } },
    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isBottomTotalsHandle: { get: function get() {
            return this.isBottomTotalsRow && this.isHandleColumn;
        } },
    /** @type {boolean}
     * @memberOf CellEvent#
     */
    isBottomTotalsCell: { get: function get() {
            return this.isBottomTotalsRow && this.isDataColumn;
        } },

    /**
     * @desc shows, is cell located in aggregation column
     * @type {boolean}
     * @memberOf CellEvent#
     */
    isAggregationTreeColumn: {
        get: function get() {
            return !!this.column && this.column.name === '$$aggregation';
        }
    },

    /**
     * @desc shows, is cell located in aggregation column
     * @type {boolean}
     * @memberOf CellEvent#
     */
    isAggregationColumn: {
        get: function get() {
            return !!this.column && this.column.name.startsWith('$$aggregation');
        }
    },

    /**
     * @desc shows, is cell located in aggregation row
     * @type {boolean}
     * @memberOf CellEvent#
     */
    isAggregationRow: { get: function get() {
            return this.grid.behavior.isAggregationRow(this.dataRow);
        } },

    /**
     * @desc returns array of child rows of an current aggregated row
     * @type {array}
     * @memberOf CellEvent#
     */
    childRows: { get: function get() {
            return this.grid.behavior.getChildRows(this.dataRow);
        } },

    /**
     * @desc shows, is cell located in row, that has child rows
     * @type {boolean}
     * @memberOf CellEvent#
     */
    hasChildRows: { get: function get() {
            return this.grid.behavior.hasChildRows(this.dataRow);
        } },

    /**
     * @desc returns count of aggregated child rows
     * @type {number}
     * @memberOf CellEvent#
     */
    aggregationChildCount: { get: function get() {
            return this.grid.behavior.getAggregationChildCount(this.dataRow);
        } },

    /**
     * @desc shows, is row can be expanded
     * @type {boolean}
     * @memberOf CellEvent#
     */
    isExpandableRow: { get: function get() {
            return this.grid.behavior.isExpandableRow(this.dataRow);
        } },

    /**
     * @desc shows, is row already expanded
     * @type {boolean}
     * @memberOf CellEvent#
     */
    isRowExpanded: { get: function get() {
            return this.grid.behavior.isRowExpanded(this.dataRow);
        } },

    /**
     * @desc shows, is row contains grand total value
     * @type {boolean}
     * @memberOf CellEvent#
     */
    isGrandTotalRow: { get: function get() {
            return !!this.dataRow && !!this.dataRow.$$grand_total;
        } },

    /**
     * @desc tree level of an row
     * @type {number}
     * @memberOf CellEvent#
     */
    treeLevel: { get: function get() {
            return this.grid.behavior.getRowTreeLevel(this.dataRow);
        } },

    $$CLASS_NAME: { value: 'CellEvent' }
});

var Point = require('rectangular').Point;

/**
 * Variation of `rectangular.Point` but with writable `x` and `y`
 * @constructor
 */
function WritablePoint(x, y) {
    // skip x and y initialization here for performance
    // because typically reset after instantiation
}

WritablePoint.prototype = Point.prototype;

var writableDescriptor = { writable: true };
var eumerableDescriptor = { writable: true, enumerable: true };

/** @typedef {WritablePoint} dataCellCoords
 * @property {number} x - The data model's column index, unaffected by column scrolling; _i.e.,_
 * an index suitable for dereferencing the column object to which the cell belongs via {@link Behavior#getColumn}.
 * @property {number} y - The data model's row index, adjusted for data row scrolling after fixed rows.
 */

/** @typedef {WritablePoint} gridCellCoords
 * @property {number} x - The active column index, adjusted for column scrolling after fixed columns; _i.e.,_
 * an index suitable for dereferencing the column object to which the cell belongs via {@link Behavior#getActiveColumn}.
 * @property {number} y - The vertical grid coordinate, unaffected by subgrid, row scrolling, and fixed rows.
 */

/**
 * @name cellEventFactory
 *
 * @summary Create a custom `CellEvent` class.
 *
 * @desc Create a custom definition of `CellEvent` for each grid instance, setting the `grid`, `behavior`, and `dataModel` properties on the prototype. As this happens once per grid instantiation, it avoids having to perform this set up work on every `CellEvent` instantiation.
 *
 * @param {HyperGrid} grid
 *
 * @returns {function}
 */
function factory(grid) {

    /**
     * @summary Create a new CellEvent object.
     *
     * @classdesc `CellEvent` is a very low-level object that needs to be super-efficient. JavaScript objects are well known to be light weight in general, but at this level we need to be careful.
     *
     * These objects were originally only being created on mouse events. This was no big deal as mouse events are few and far between. However, as of v1.2.0, the renderer now also creates one for each visible cell on each and every grid paint.
     *
     * For this reason, to maintain performance, each grid gets a custom definition of `CellEvent`, created by this class factory, with the following optimizations:
     *
     * * Use of `extend-me` is avoided because its `initialize` chain is a bit too heavy here.
     * * Custom versions of `CellEvent` for each grid lightens the load on the constructor.
     *
     * @desc All own enumerable properties are mixed into cell editor:
     * * Includes `this.column` defined by constructor (as enumerable).
     * * Excludes all other properties defined by constructor and prototype, all of which are non-enumerable.
     * * Any additional (enumerable) members mixed in by application's `getCellEditorAt` override.
     *
     * Including the params calls {@link CellEvent#resetGridCY resetGridCY(gridX, gridY)}.
     * Alternatively, instantiate without params and/or later call one of these:
     * * {@link CellEvent#resetGridXY resetGridXY(...)}
     * * {@link CellEvent#resetDataXY resetDataXY(...)}
     * * {@link CellEvent#resetGridXDataY resetGridXDataY(...)}
     *
     * @param {number} [gridX] - grid cell coordinate (adjusted for horizontal scrolling after fixed columns).
     * @param {number} [gridY] - grid cell coordinate, adjusted (adjusted for vertical scrolling if data subgrid)
     * @constructor CellEvent
     */
    function CellEvent(gridX, gridY) {
        // remaining instance vars are non-enumerable so `CellEditor` constructor won't mix them in (for mustache use).
        Object.defineProperties(this, {
            /**
             * @name visibleColumn
             * @type {visibleColumnArray}
             * @memberOf CellEvent#
             */
            visibleColumn: writableDescriptor,

            /**
             * @name visibleRow
             * @type {visibleRowArray}
             * @memberOf CellEvent#
             */
            visibleRow: writableDescriptor,

            /**
             * @name subgrid
             * @type {dataModelAPI}
             * @memberOf CellEvent#
             */
            subgrid: writableDescriptor,

            /**
             * @name gridCell
             * @type {gridCellCoords}
             * @memberOf CellEvent#
             */
            gridCell: {
                value: new WritablePoint()
            },

            /**
             * @name dataCell
             * @type {dataCellCoords}
             * @memberOf CellEvent#
             */
            dataCell: {
                value: new WritablePoint()
            },

            /**
             * @name valueCell
             * @type {dataCellCoords}
             * @memberOf CellEvent#
             */
            valueCell: {
                value: new WritablePoint()
            },

            /**
             * A reference to the cell's {@link Column} object.
             *
             * This property is enumerable so that it will be copied to cell editor on {@link CellEditor} instantiation.
             * @name column
             * @type {Column}
             * @memberOf CellEvent#
             */
            column: eumerableDescriptor,

            // getter caches
            _columnProperties: writableDescriptor,
            _cellOwnProperties: writableDescriptor,
            _cellOwnDefinedProperties: writableDescriptor,
            _bounds: writableDescriptor,

            // Following supports cell renderers' "partial render" capability:
            snapshot: writableDescriptor,
            minWidth: writableDescriptor,
            disabled: writableDescriptor
        });

        if (arguments.length) {
            this.resetGridCY(gridX, gridY);
        }
    }

    CellEvent.prototype = Object.create(cellEventProperties, {
        constructor: { value: CellEvent },
        grid: { value: grid },
        renderer: { value: grid.renderer },
        selectionModel: { value: grid.selectionModel },
        behavior: { value: grid.behavior },
        dataModel: { value: grid.behavior.dataModel }
    });

    return CellEvent;
}

function shallowClone(obj) {
    var clone = Object.create(Object.getPrototypeOf(obj));
    Object.getOwnPropertyNames(obj).forEach(function (key) {
        return Object.defineProperty(clone, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return clone;
}

module.exports = factory;

},{"rectangular":14}],93:[function(require,module,exports){
'use strict';

// console.warn polyfill as needed
// used for deprecation warnings

if (!console.warn) {
    console.warn = function () {
        console.log.apply(console, ['WARNING:'].concat(Array.prototype.slice.call(arguments)));
    };
}

var regexIsMethod = /^[\w\.]+\(.*\)$/;

/**
 * User is warned and new property is returned or new method is called and the result is returned.
 * @param {string} methodName - Warning key paired with arbitrary warning in `dotProps` OR deprecated method name with parentheses containing optional argument list paired with replacement property or method in `dotProps`.
 * @param {string} dotProps - Arbitrary warning paired with warning key in `methodName` OR dot-separated new property name to invoke or method name to call. Method names are indicated by including parentheses with optional argument list. The arguments in each list are drawn from the arguments presented in the `methodName` parameter.
 * @param {string} since - Version in which the name was deprecated.
 * @param {Arguments|Array} [args] - The actual arguments in the order listed in `methodName`. Only needed when arguments need to be forwarded.
 * @param {string} [notes] - Notes to add to message.
 * @returns {*} Return value of new property or method call.
 */
var deprecated = function deprecated(methodName, dotProps, since, args, notes) {
    if (typeof args === 'string') {
        // `args` omitted
        notes = args;
        args = undefined;
    }

    var chain = dotProps.split('.'),
        warned = this.$$DEPRECATION_WARNED = this.$$DEPRECATION_WARNED || {},
        result = this,
        isSimpleWarning = dotProps.indexOf(' ') >= 0,
        isMethodCall = regexIsMethod.test(methodName),
        memberType,
        warning;

    if (!(methodName in warned)) {
        warned[methodName] = deprecated.warnings;
    }

    if (isMethodCall) {
        if (isSimpleWarning) {
            throw 'Expected replacement method or property in 2nd parameter of deprecated() call.';
        } else if (warned[methodName]) {
            --warned[methodName];
            memberType = regexIsMethod.test(dotProps) ? 'method' : 'property';
            warning = 'The .' + methodName + ' method has been deprecated as of v' + since + ' in favor of the .' + chain.join('.') + ' ' + memberType + '.' + ' (Will be removed in a future release.)';

            if (notes) {
                warning += ' ' + notes;
            }

            console.warn(warning);
        }
    } else if (isSimpleWarning) {
        if (warned[methodName]) {
            --warned[methodName];
            console.warn(dotProps);
        }
        return;
    } else {
        throw 'Expected method name with parentheses in 1st parameter OR simple warning (containing one or more spaces) in 2nd parameter of deprecated() call.';
    }

    var formalArgList = argList(methodName);

    function mapToFormalArg(argName) {
        var index = formalArgList.indexOf(argName);
        if (index === -1) {
            throw 'Actual arg "' + argName + '" not found in formal arg list ' + formalArgList;
        }
        return args[index];
    }

    for (var i = 0, last = chain.length - 1; i <= last; ++i) {
        var link = chain[i],
            name = link.match(/\w+/)[0],
            linkIsMethodCall = regexIsMethod.test(link),
            actualArgList = linkIsMethodCall ? argList(link) : undefined,
            actualArgs = [];

        if (actualArgList) {
            actualArgs = actualArgList.map(mapToFormalArg);
            result = result[name].apply(result, actualArgs);
        } else if (linkIsMethodCall) {
            result = result[name]();
        } else {
            result = result[name];
        }
    }

    return result;
};

deprecated.warnings = 1; // 3 or 5 would get more attention

function argList(s) {
    return s.match(/^\w+\((.*)\)$/)[1].match(/(\w+)/g);
}

module.exports = deprecated;

},{}],94:[function(require,module,exports){
'use strict';

var warnedDoubleClickDelay;

/**
 * @summary Dynamic grid property getter/setters.
 * @desc  Dynamic grid properties can make use of a _backing store._
 * This backing store is created in the same layer (the grid properties layer) by {@link Hypergrid#clearState|clearState} and backs grid-only properties. We currently do not create one for descendant objects, such as column and cell properties objects.
 * The members of the backing store have the same names as the dynamic properties that utilize them.
 * They are initialized by {@link Hypergrid#clearState|clearState} to the default values from {@link module:defaults|defaults} object members, (also) of the same name.
 *
 * Note that dynamic properties must enumerable to be visible to {@link Hypergrid#saveState}.
 * @name dynamicPropertyDescriptors
 * @module
 */
var dynamicPropertyDescriptors = {
    /**
     * @returns {string|undefined|object} One of:
     * * **string:** When theme name is registered (except 'default').
     * * **undefined:** When theme layer is empty (or theme name is 'default').
     * * **object:** When theme name is not registered.
     * @memberOf module:dynamicPropertyDescriptors
     */
    theme: {
        enumerable: true,
        get: function get() {
            return this.grid.getTheme();
        },
        set: function set(theme) {
            this.grid.applyTheme(theme);
        }
    },

    /**
     * @memberOf module:dynamicPropertyDescriptors
     */
    subgrids: {
        enumerable: true,
        get: function get() {
            return this.var.subgrids;
        },
        set: function set(subgrids) {
            this.var.subgrids = subgrids.slice();

            if (this.grid.behavior) {
                this.grid.behavior.subgrids = subgrids;
            }
        }
    },

    /**
     * @memberOf module:dynamicPropertyDescriptors
     */
    features: {
        enumerable: true,
        get: function get() {
            return this.var.features;
        },
        set: function set(features) {
            this.var.features = features.slice();
            if (this.grid.behavior) {
                this.grid.behavior.initializeFeatureChain(features);
                this.grid.allowEvents(this.grid.getRowCount());
            }
        }
    },

    /**
     * @memberOf module:dynamicPropertyDescriptors
     */
    gridRenderer: {
        enumerable: true,
        get: function get() {
            return this.var.gridRenderer;
        },
        set: function set(rendererName) {
            this.var.gridRenderer = rendererName;
            this.grid.renderer.setGridRenderer(rendererName);
        }
    },

    /**
     * @memberOf module:dynamicPropertyDescriptors
     */
    columnIndexes: {
        enumerable: true,
        get: function get() {
            return this.grid.behavior.getActiveColumns().map(function (column) {
                return column.index;
            });
        },
        set: function set(columnIndexes) {
            this.grid.behavior.setColumnOrder(columnIndexes);
            this.grid.behavior.changed();
        }
    },

    /**
     * @memberOf module:dynamicPropertyDescriptors
     */
    columnNames: {
        enumerable: true,
        get: function get() {
            return this.grid.behavior.getActiveColumns().map(function (column) {
                return column.name;
            });
        },
        set: function set(columnNames) {
            this.grid.behavior.setColumnOrderByName(columnNames);
            this.grid.behavior.changed();
        }
    },

    /**
     * @memberOf module:dynamicPropertyDescriptors
     */
    rows: {
        enumerable: true,
        get: getRowPropertiesBySubgridAndRowIndex,
        set: function set(rowsHash) {
            if (rowsHash) {
                setRowPropertiesBySubgridAndRowIndex.call(this, rowsHash);
                this.grid.behavior.changed();
            }
        }
    },

    /**
     * @memberOf module:dynamicPropertyDescriptors
     */
    columns: {
        enumerable: true,
        get: getColumnPropertiesByColumnName,
        set: function set(columnsHash) {
            if (columnsHash) {
                setColumnPropertiesByColumnName.call(this, columnsHash);
                this.grid.behavior.changed();
            }
        }
    },

    /**
     * @memberOf module:dynamicPropertyDescriptors
     */
    cells: {
        enumerable: true,
        get: getCellPropertiesByColumnNameAndRowIndex,
        set: function set(cellsHash) {
            if (cellsHash) {
                setCellPropertiesByColumnNameAndRowIndex.call(this, cellsHash);
                this.grid.behavior.changed();
            }
        }
    },

    /**
     * @memberOf module:dynamicPropertyDescriptors
     */
    rowHeaderCheckboxes: {
        enumerable: true,
        get: function get() {
            return this.var.rowHeaderCheckboxes;
        },
        set: function set(enabled) {
            this.var.rowHeaderCheckboxes = enabled;
            this.grid.renderer.resetRowHeaderColumnWidth();
        }
    },

    /**
     * @memberOf module:dynamicPropertyDescriptors
     */
    rowHeaderNumbers: {
        enumerable: true,
        get: function get() {
            return this.var.rowHeaderNumbers;
        },
        set: function set(enabled) {
            this.var.rowHeaderNumbers = enabled;
            this.grid.renderer.resetRowHeaderColumnWidth();
        }
    },

    /**
     * Legacy property; now points to both `rowHeaderFeatures` props.
     * @memberOf module:dynamicPropertyDescriptors
     */
    showRowNumbers: {
        enumerable: false,
        get: function get() {
            return this.rowHeaderCheckboxes || this.rowHeaderNumbers;
        },
        set: function set(enabled) {
            this.rowHeaderCheckboxes = this.rowHeaderNumbers = enabled;
        }
    },

    // remove to expire warning:
    doubleClickDelay: {
        enumerable: true,
        get: function get() {
            return this.var.doubleClickDelay;
        },
        set: function set(delay) {
            if (!warnedDoubleClickDelay) {
                warnedDoubleClickDelay = true;
                console.warn('The doubleClickDelay property has been deprecated as of v2.1.0. Setting this property no longer has any effect. Set double-click speed in your system\'s mouse preferences. (This warning will be removed in a future release.)');
            }
            this.var.doubleClickDelay = delay;
        }
    },

    // The following grid line props are now dynamic (as of v2.1.0).
    // They're non-enumerable so they will not be output with `grid.saveState()`.
    // The new (as of 2.1.0) props they refer to are output instead:
    // `gridLinesColor`, `gridLinesColor`, `gridLinesWidth`, and `gridLinesWidth`
    lineColor: {
        get: function get() {
            return this.gridLinesColor;
        },
        set: function set(color) {
            this.gridLinesColor = this.gridLinesColor = color;
        }
    },

    lineWidth: {
        get: function get() {
            return this.gridLinesWidth;
        },
        set: function set(width) {
            this.gridLinesWidth = this.gridLinesWidth = width;
        }
    },

    gridBorder: getGridBorderDescriptor(),
    gridBorderLeft: getGridBorderDescriptor('Left'),
    gridBorderRight: getGridBorderDescriptor('Right'),
    gridBorderTop: getGridBorderDescriptor('Top'),
    gridBorderBottom: getGridBorderDescriptor('Bottom')
};

function getRowPropertiesBySubgridAndRowIndex() {
    // to be called with grid.properties as context
    var subgrids = {};
    var behavior = this.grid.behavior;
    behavior.subgrids.forEach(function (dataModel) {
        var key = dataModel.name || dataModel.type;
        for (var rowIndex = 0, rowCount = dataModel.getRowCount(); rowIndex < rowCount; ++rowIndex) {
            var rowProps = behavior.getRowProperties(rowIndex, undefined, dataModel);
            if (rowProps) {
                var subgrid = subgrids[key] = subgrids[key] || {};
                subgrid[rowIndex] = rowProps;
            }
        }
    });
    return subgrids;
}

function setRowPropertiesBySubgridAndRowIndex(rowsHash) {
    // to be called with grid.properties as context
    var behavior = this.grid.behavior;
    for (var subgridName in rowsHash) {
        if (rowsHash.hasOwnProperty(subgridName)) {
            var subgrid = behavior.subgrids.lookup[subgridName];
            if (subgrid) {
                var subgridHash = rowsHash[subgridName];
                for (var rowIndex in subgridHash) {
                    if (subgridHash.hasOwnProperty(rowIndex)) {
                        var properties = subgridHash[rowIndex];
                        for (var propName in properties) {
                            if (properties.hasOwnProperty(propName)) {
                                var propValue = properties[propName];
                                switch (propName) {
                                    case 'height':
                                        behavior.setRowHeight(rowIndex, Number(propValue), subgrid);
                                        break;
                                    default:
                                        console.warn('Unexpected row property "' + propName + '" ignored. (The only row property currently implemented is "height").');
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

function getColumnPropertiesByColumnName() {
    // to be called with grid.properties as context
    var columns = this.grid.behavior.getColumns(),
        headerify = this.grid.headerify;
    return columns.reduce(function (obj, column) {
        var properties = Object.keys(column.properties).reduce(function (properties, key) {
            switch (key) {
                case 'preferredWidth':
                    // not a public property
                    break;
                case 'header':
                    if (headerify && column.properties.header === headerify(column.properties.name)) {
                        break;
                    }
                // fallthrough
                default:
                    var value = column.properties[key];
                    if (value !== undefined) {
                        properties[key] = value;
                    }
            }
            return properties;
        }, {});
        if (Object.keys(properties).length) {
            obj[column.name] = properties;
        }
        return obj;
    }, {});
}

function setColumnPropertiesByColumnName(columnsHash) {
    // to be called with grid.properties as context
    var columns = this.grid.behavior.getColumns();

    for (var columnName in columnsHash) {
        if (columnsHash.hasOwnProperty(columnName)) {
            var column = columns.find(nameMatches);
            if (column) {
                column.properties = columnsHash[columnName];
            }
        }
    }

    function nameMatches(column) {
        return column.name === columnName;
    }
}

function getCellPropertiesByColumnNameAndRowIndex() {
    var behavior = this.grid.behavior,
        columns = behavior.getColumns(),
        subgrids = {};

    behavior.subgrids.forEach(function (dataModel) {
        var key = dataModel.name || dataModel.type;

        for (var rowIndex = 0, rowCount = dataModel.getRowCount(); rowIndex < rowCount; ++rowIndex) {
            columns.forEach(copyCellOwnProperties);
        }

        function copyCellOwnProperties(column) {
            var properties = behavior.getCellOwnProperties(column.index, rowIndex, dataModel);
            if (properties) {
                var subgrid = subgrids[key] = subgrids[key] || {},
                    row = subgrid[rowIndex] = subgrid[rowIndex] = {};
                row[column.name] = Object.assign({}, properties);
            }
        }
    });

    return subgrids;
}

function setCellPropertiesByColumnNameAndRowIndex(cellsHash) {
    // to be called with grid.properties as context
    var subgrids = this.grid.behavior.subgrids,
        columns = this.grid.behavior.getColumns();

    for (var subgridName in cellsHash) {
        if (cellsHash.hasOwnProperty(subgridName)) {
            var subgrid = subgrids.lookup[subgridName];
            if (subgrid) {
                var subgridHash = cellsHash[subgridName];
                for (var rowIndex in subgridHash) {
                    if (subgridHash.hasOwnProperty(rowIndex)) {
                        var columnProps = subgridHash[rowIndex];
                        for (var columnName in columnProps) {
                            if (columnProps.hasOwnProperty(columnName)) {
                                var column = columns.find(nameMatches);
                                if (column) {
                                    var properties = columnProps[columnName];
                                    column.addCellProperties(rowIndex, properties, subgrid);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    function nameMatches(column) {
        return column.name === columnName;
    }
}

function getGridBorderDescriptor(edge) {
    var propName = 'gridBorder' + (edge || '');

    return {
        enumerable: true,
        get: function get() {
            return this.var[propName];
        },
        set: function set(border) {
            this.var[propName] = border;

            if (!edge) {
                this.var.gridBorderLeft = this.var.gridBorderRight = this.var.gridBorderTop = this.var.gridBorderBottom = border;
            }

            this.grid.resetGridBorder(edge);
        }
    };
}

module.exports = dynamicPropertyDescriptors;

},{}],95:[function(require,module,exports){
'use strict';

function HypergridError(message) {
    this.message = message;
}

// extend from `Error`
HypergridError.prototype = Object.create(Error.prototype);

// override error name displayed in console
HypergridError.prototype.name = 'HypergridError';

module.exports = HypergridError;

},{}],96:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var API;

function clearFill(x, y, width, height, color) {
    var a = alpha(color);
    if (a < 1) {
        // If background is translucent, we must clear the rect before the fillRect
        // below to prevent mixing with previous frame's render of this cell.
        this.clearRect(x, y, width, height);
    }
    if (a > 0) {
        this.cache.fillStyle = color;
        this.fillRect(x, y, width, height);
    }
}

var ALPHA_REGEX = /^(transparent|((RGB|HSL)A\(.*,\s*([\d\.]+)\)))$/i;
// Tried using an `alphaCache` here but it didn't make a measurable difference.
function alpha(cssColorSpec) {
    var matches, result;

    if (!cssColorSpec) {
        // undefined so not visible; treat as transparent
        result = 0;
    } else if ((matches = cssColorSpec.match(ALPHA_REGEX)) === null) {
        // an opaque color (a color spec with no alpha channel)
        result = 1;
    } else if (matches[4] === undefined) {
        // cssColorSpec must have been 'transparent'
        result = 0;
    } else {
        result = Number(matches[4]);
    }

    return result;
}

var fontMetrics = {};

/**
 * Accumulates width of string in pixels, character by character, by chaching character widths and reusing those values when previously cached.
 *
 * NOTE: There is a minor measuring error when taking the sum of the pixel widths of individual characters that make up a string vs. the pixel width of the string taken as a whole. This is possibly due to kerning or rounding. The error is typically about 0.1%.
 * @memberOf module:defaults
 * @param {CanvasRenderingContext2D} gc
 * @param {string} string - Text to measure.
 * @returns {nubmer} Width of string in pixels.
 */
function getTextWidth(string) {
    var metrics = fontMetrics[this.cache.font] = fontMetrics[this.cache.font] || {};
    string += '';
    for (var i = 0, sum = 0, len = string.length; i < len; ++i) {
        var c = string[i];
        sum += metrics[c] = metrics[c] || this.measureText(c).width;
    }
    return sum;
}

var ELLIPSIS = '\u2026'; // The "" (dot-dot-dot) character

/**
 * Similar to `getTextWidth` except:
 * 1. Aborts accumulating when sum exceeds given `width`.
 * 2. Returns an object containing both the truncated string and the sum (rather than a number primitive containing the sum alone).
 * @param {CanvasRenderingContext2D} gc
 * @param {string} string - Text to measure.
 * @param {number} width - Width of target cell; overflow point.
 * @param {boolean|null|undefined} truncateTextWithEllipsis - _Per {@link module:defaults.truncateTextWithEllipsis}._
 * @param {array} highlightChars - List of {from: {number}, to: {number}} object to detect highlighting of text
 * @param {boolean} [abort=false] - Abort measuring upon overflow. Returned `width` sum will reflect truncated string rather than untruncated string. Note that returned `string` is truncated in either case.
 * @returns {{string:string,width:number}}
 * * `object.string` - `undefined` if it fits; truncated version of provided `string` if it does not.
 * * `object.width` - Width of provided `string` if it fits; width of truncated string if it does not.
 */
function getTextWidthTruncated(string, width, truncateTextWithEllipsis, highlightChars, abort) {
    var metrics = fontMetrics[this.cache.font],
        truncating = truncateTextWithEllipsis !== undefined,
        truncString,
        truncWidth,
        truncAt;
    var highlights = [];

    if (!metrics) {
        metrics = fontMetrics[this.cache.font] = {};
    }

    if (!metrics[ELLIPSIS]) {
        metrics[ELLIPSIS] = this.measureText(ELLIPSIS).width;
    }

    var sum = 0;
    var highlightIndex = 0;
    var charWidth = 0;
    string = string + ''; // convert to string
    width += truncateTextWithEllipsis === false ? 2 : 0; // fudge for inequality
    for (var i = 0, len = string.length; i < len; ++i) {
        var char = string[i];
        charWidth = metrics[char] = metrics[char] || this.measureText(char).width;

        if (highlightChars) {
            var highlightObject = highlightChars[highlightIndex];
            if (highlightObject) {
                if (i === highlightObject.from) {
                    // save start width of text highlight
                    highlights[highlightIndex] = { x: sum };
                }
                if (i === highlightObject.to) {
                    // save end position of text highlight
                    highlights[highlightIndex].width = sum - highlights[highlightIndex].x;
                    ++highlightIndex;
                }
            }
        }

        sum += charWidth;
        if (!truncString && truncating && sum > width) {
            truncAt = i;
            switch (truncateTextWithEllipsis) {
                case true:
                    // truncate sufficient characters to fit ellipsis if possible
                    truncWidth = sum - charWidth + metrics[ELLIPSIS];
                    while (truncAt && truncWidth > width) {
                        truncWidth -= metrics[string[--truncAt]];
                    }
                    truncString = truncWidth > width ? '' // not enough room even for ellipsis
                    : truncString = string.substr(0, truncAt) + ELLIPSIS;
                    break;
                case false:
                    // truncate *before* last partially visible character
                    truncString = string.substr(0, truncAt);
                    break;
                default:
                    // truncate *after* partially visible character
                    if (++truncAt < string.length) {
                        truncString = string.substr(0, truncAt);
                    }
            }
            if (abort) {
                break;
            }
        }
    }

    // save end position of text highlight with corrections related to ellipsis
    if (highlights[highlightIndex] && !highlights[highlightIndex].width) {
        var _width = (truncWidth ? truncWidth - charWidth : sum) - highlights[highlightIndex].x;
        if (_width > 0) {
            highlights[highlightIndex].width = _width;
        } else {
            highlights.pop();
        }
    }

    return {
        string: truncString,
        width: sum,
        highlights: highlights
    };
}

var fontData = {};

/**
 * @memberOf module:defaults
 * @param font
 * @returns {*}
 */
function getTextHeight(font) {
    var result = fontData[font];

    if (!result) {
        result = {};

        var text = document.createElement('span');
        text.textContent = 'Hg';
        text.style.font = font;

        var block = document.createElement('div');
        block.style.display = 'inline-block';
        block.style.width = '1px';
        block.style.height = '0px';

        var div = document.createElement('div');
        div.appendChild(text);
        div.appendChild(block);

        div.style.position = 'absolute';
        document.body.appendChild(div);

        try {

            block.style.verticalAlign = 'baseline';

            var blockRect = block.getBoundingClientRect();
            var textRect = text.getBoundingClientRect();

            result.ascent = blockRect.top - textRect.top;

            block.style.verticalAlign = 'bottom';
            result.height = blockRect.top - textRect.top;

            result.descent = result.height - result.ascent;
            result.offset = text.offsetHeight;
        } finally {
            document.body.removeChild(div);
        }
        if (result.height !== 0) {
            fontData[font] = result;
        }
    }

    return result;
}

function clipSave(conditional, x, y, width, height) {
    this.conditionalsStack.push(conditional);
    if (conditional) {
        this.cache.save();
        this.beginPath();
        this.rect(x, y, width, height);
        this.clip();
    }
}

function clipRestore(conditional) {
    if (this.conditionalsStack.pop()) {
        this.cache.restore(); // Remove clip region
    }
}

API = {
    clearFill: clearFill,
    alpha: alpha,
    getTextWidth: getTextWidth,
    getTextWidthTruncated: getTextWidthTruncated,
    getTextHeight: getTextHeight,
    clipSave: clipSave,
    clipRestore: clipRestore,
    truncateTextWithEllipsis: true
};

module.exports = API;

},{}],97:[function(require,module,exports){
'use strict';

var REGEXP_WORD_SEPARATORS = /[\s\-_]*([^\s\-_])([^\s\-_]+)/g,
    REGEXP_CAPITAL_LETTERS = /[A-Z]/g,
    REGEXP_LOWER_CASE_LETTER = /[a-z]/,
    shortWords = ['of', 'at', 'by', 'from', 'and', 'but', 'for', 'a', 'an', 'the'];

// Replacement function for use in the default titleize function below.
// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace
function capitalize(a, b, c) {
    return b.toUpperCase() + c;
}

/**
 * * Separates camel case or white-space-, hyphen-, or underscore-separated "words' into true (truly separate) words.
 * * Capitalizes the first letter of each word (unless not first word and in `shortWords`).
 * @param string
 * @returns {string}
 * @memberOf namespace:fields
 */
exports.titleize = function (string) {
    var title = (REGEXP_LOWER_CASE_LETTER.test(string) ? string : string.toLowerCase()).replace(REGEXP_WORD_SEPARATORS, capitalize).replace(REGEXP_CAPITAL_LETTERS, ' $&').trim();

    shortWords.forEach(function (word) {
        word = ' ' + word + ' ';
        title = title.replace(new RegExp(word, 'gi'), word);
    });

    return title;
};

},{}],98:[function(require,module,exports){
'use strict';

module.exports = {
    cellEventFactory: require('./cellEventFactory'),
    dynamicPropertyDescriptors: require('./dynamicProperties'),
    graphics: require('./graphics'),
    Canvas: require('./Canvas')
};

var warned;

Object.defineProperty(module.exports, 'fields', {
    get: function get() {
        throw new Error('The `Hypergrid.lib.fields` module has been retired as of v3.0.0 and incorporated into schema enrichment (triggered by the new `data-schema-changed` data event), which is influenced by the new `headerify` grid property.');
    }
});

Object.defineProperty(module.exports, 'DataSourceOrigin', {
    get: function get() {
        if (!warned) {
            console.warn('The `DataSourceOrigin` module has been retired as of v3.0.0. The new default data model, `datasaur-local`, will be returned instead. Note, however, that it may be removed from the build in a future release. Developers are advised and encouraged to provide their own data model going forward. For example: `new Hypergrid({ DataSource: require(\'datasaur-local\') })`; or provide a live data model instance in the `dataSource` (small "d") option.');
            warned = true;
        }
        return require('../DatasaurLocal');
    }
});

},{"../DatasaurLocal":19,"./Canvas":87,"./cellEventFactory":92,"./dynamicProperties":94,"./graphics":96}],99:[function(require,module,exports){
'use strict';

/* IMPORTANT NOTE:
 * If any of the modules listed below is removed from Hypergrid, the polyfill(s) they define must be added here!!!
 *
 * 1. object-iterators defines Array.prototype.find
 */

/* eslint-disable no-extend-native */

// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill
// (Safari now supports Math.sign but IE still does not as of v11.)

Math.sign = Math.sign = function (x) {
    x = +x; // convert to a number
    if (x === 0 || isNaN(x)) {
        return x;
    }
    return x > 0 ? 1 : -1;
};

// Lite version of: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex#Polyfill
if (typeof Array.prototype.findIndex !== 'function') {
    Array.prototype.findIndex = function (predicate) {
        var context = arguments[1];
        for (var i = 0, len = this.length; i < len; i++) {
            if (predicate.call(context, this[i], i, this)) {
                return i;
            }
        }
        return -1;
    };
}

// Simpler version of: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#Polyfill
if (typeof Array.prototype.fill !== 'function') {
    Array.prototype.fill = function (value, start, end) {
        start = start === undefined ? 0 : start < 0 ? this.length + start : start;
        end = end === undefined ? this.length : end < 0 ? this.length + end : end;
        for (var i = start || 0; i < end; ++i) {
            this[i] = value;
        }
        return this;
    };
}

// Lite version of: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill
if (typeof Object.assign !== 'function') {
    Object.assign = function (target) {
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source != null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        target[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return target;
    };
}

if (typeof Object.getOwnPropertyDescriptors !== 'function') {
    Object.getOwnPropertyDescriptors = function (object) {
        return Object.getOwnPropertyNames(object).reduce(function (descriptors, key) {
            descriptors[key] = Object.getOwnPropertyDescriptor(object, key);
            return descriptors;
        }, {});
    };
}

},{}],100:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var HypergridError = require('./error');

/**
 * @param {function|string} string
 * @returns {function}
 * @private
 */
module.exports = function (string) {
    switch (typeof string === 'undefined' ? 'undefined' : _typeof(string)) {
        case 'undefined':
        case 'function':
            return string;
        case 'string':
            break;
        default:
            throw new HypergridError('Expected string, function, or undefined.');
    }

    var args = string.match(/^function\s*\w*\s*\(([^]*?)\)/);
    if (!args) {
        throw new HypergridError('Expected function keyword with formal parameter list.');
    }
    args = args[1].split(',').map(function (s, i) {
        s = s.match(/\s*(\w*)\s*/); // trim each argument
        if (!s && i) {
            throw new HypergridError('Expected formal parameter.');
        }
        return s[1];
    });

    var body = string.match(/{\s*([^]*?)\s*}\s*$/);
    if (!body) {
        throw new HypergridError('Expected function body.');
    }
    body = body[1];

    if (args.length === 1 && !args[0]) {
        args[0] = body;
    } else {
        args = args.concat(body);
    }

    return Function.apply(null, args);
};

},{"./error":95}],101:[function(require,module,exports){
'use strict';

function bundleColumns(resetCellEvents) {
    var gridProps = this.grid.properties,
        vr,
        visibleRows = this.visibleRows,
        r,
        R = visibleRows.length,
        pool;

    if (resetCellEvents) {
        pool = this.cellEventPool;
        var p = 0;
        this.visibleColumns.forEachWithNeg(function (vc) {
            for (r = 0; r < R; r++, p++) {
                vr = visibleRows[r];
                // reset pool member to reflect coordinates of cell in newly shaped grid
                pool[p].reset(vc, vr);
            }
        });
    }

    var bundle,
        columnBundles = [],
        gridPrefillColor = gridProps.backgroundColor,
        backgroundColor;

    this.visibleColumns.forEachWithNeg(function (vc) {
        backgroundColor = vc.column.properties.backgroundColor;
        if (bundle && bundle.backgroundColor === backgroundColor) {
            bundle.right = vc.right;
        } else if (backgroundColor === gridPrefillColor) {
            bundle = undefined;
        } else {
            bundle = {
                backgroundColor: backgroundColor,
                left: vc.left,
                right: vc.right
            };
            columnBundles.push(bundle);
        }
    });

    this.columnBundles = columnBundles;
}

module.exports = bundleColumns;

},{}],102:[function(require,module,exports){
'use strict';

function bundleRows(resetCellEvents) {
    var gridProps = this.grid.properties,
        vr,
        visibleRows = this.visibleRows,
        r,
        R = visibleRows.length,
        p,
        pool;

    if (resetCellEvents) {
        pool = this.cellEventPool;
        for (p = 0, r = 0; r < R; r++) {
            vr = visibleRows[r];
            this.visibleColumns.forEachWithNeg(function (vc) {
                // eslint-disable-line no-loop-func
                p++;
                // reset pool member to reflect coordinates of cell in newly shaped grid
                pool[p].reset(vc, vr);
            });
        }
    }

    var bundle,
        rowBundles = [],
        gridPrefillColor = gridProps.backgroundColor,
        rowStripes = gridProps.rowStripes,
        rowPrefillColors = Array(R),
        stripe,
        backgroundColor;

    for (r = 0; r < R; r++) {
        vr = visibleRows[r]; // first cell in row r
        stripe = vr.subgrid.isData && rowStripes && rowStripes[vr.rowIndex % rowStripes.length];
        backgroundColor = rowPrefillColors[r] = stripe && stripe.backgroundColor || gridPrefillColor;
        if (bundle && bundle.backgroundColor === backgroundColor) {
            bundle.bottom = vr.bottom;
        } else if (backgroundColor === gridPrefillColor) {
            bundle = undefined;
        } else {
            bundle = {
                backgroundColor: backgroundColor,
                top: vr.top,
                bottom: vr.bottom
            };
            rowBundles.push(bundle);
        }
    }

    this.rowBundles = rowBundles;
    this.rowPrefillColors = rowPrefillColors;
}

module.exports = bundleRows;

},{}],103:[function(require,module,exports){
'use strict';

var paintCellsByColumnsAndRows = require('./by-columns-and-rows');

/** @summary Render the grid only as needed ("partial render").
 * @desc Paints all the cells of a grid, one column at a time, but only as needed.
 *
 * #### On reset
 *
 * Defers to {@link Renderer#paintCellsByColumnsAndRows|paintCellsByColumnsAndRows}, which clears the canvas, draws the grid, and draws the grid lines.
 *
 * #### On the next call (after reset)
 *
 * First, a background rect is drawn using the grid background color.
 *
 * Then, each cell is drawn. If its background differs from the grid background, the background is repainted.
 *
 * `try...catch` surrounds each cell paint in case a cell renderer throws an error.
 * The error message is error-logged to console AND displayed in cell.
 *
 * #### On subsequent calls
 *
 * Iterates through each cell, calling `_paintCell` with `undefined` prefill color. This signifies partial render to the {@link SimpleCell} cell renderer, which only renders the cell when it's text, font, or colors have changed.
 *
 * Each cell to be rendered is described by a {@link CellEvent} object. For performance reasons, to avoid constantly instantiating these objects, we maintain a pool of these. When the grid shape changes, we reset their coordinates by setting {@link CellEvent#reset|reset} on each.
 *
 * See also the discussion of clipping in {@link Renderer#paintCellsByColumns|paintCellsByColumns}.
 * @this {Renderer}
 * @param {CanvasRenderingContext2D} gc
 * @memberOf Renderer.prototype
 */
function paintCellsAsNeeded(gc) {
    var cellEvent,
        visibleColumns = this.visibleColumns,
        visibleRows = this.visibleRows,
        C = visibleColumns.length,
        cLast = C - 1,
        r,
        R = visibleRows.length,
        p = 0,
        pool = this.cellEventPool,
        preferredWidth,
        columnClip,

    // clipToGrid,
    // viewWidth = C ? visibleColumns[cLast].right : 0,
    viewHeight = R ? visibleRows[R - 1].bottom : 0;

    if (!C || !R) {
        return;
    }

    if (this.gridRenderer.reset) {
        this.resetAllGridRenderers();
        paintCellsByColumnsAndRows.call(this, gc);
        this.gridRenderer.reset = false;
    }

    // gc.clipSave(clipToGrid, 0, 0, viewWidth, viewHeight);

    // For each column...
    this.visibleColumns.forEachWithNeg(function (vc, c) {
        cellEvent = pool[p]; // first cell in column c
        vc = cellEvent.visibleColumn;

        // Optionally clip to visible portion of column to prevent text from overflowing to right.
        columnClip = vc.column.properties.columnClip;
        gc.clipSave(columnClip || columnClip === null && c === cLast, 0, 0, vc.right, viewHeight);

        // For each row of each subgrid (of each column)...
        for (preferredWidth = r = 0; r < R; r++, p++) {
            cellEvent = pool[p]; // next cell down the column (redundant for first cell in column)

            try {
                preferredWidth = Math.max(preferredWidth, this._paintCell(gc, pool[p]));
            } catch (e) {
                this.renderErrorCell(e, gc, vc, pool[p].visibleRow);
            }
        }

        gc.clipRestore(columnClip);

        cellEvent.column.properties.preferredWidth = Math.round(preferredWidth);
    }.bind(this));

    // gc.clipRestore(clipToGrid);
}

paintCellsAsNeeded.key = 'by-cells';

paintCellsAsNeeded.partial = true; // skip painting selectionRegionOverlayColor

module.exports = paintCellsAsNeeded;

},{"./by-columns-and-rows":105}],104:[function(require,module,exports){
'use strict';

/** @summary Render the grid headers. Useful when need to avoid overlapping
 * @desc Paints all the header cells of a grid, one column at a time.
 *
 * Then, if there are any rows with their own background color _that differs from the grid background color,_ these are consolidated and the consolidated groups of row backgrounds are all drawn before iterating through cells. These row backgrounds get priority over column backgrounds.
 *
 * If there are no such row background rects to draw, the column rects are consolidated and drawn instead (again, before the cells). Note that these column rects are _not_ suitable for clipping overflow text from previous columns. If you have overflow text, either turn on clipping (big performance hit) or turn on one of the `truncateTextWithEllipsis` options.
 *
 * `try...catch` surrounds each cell paint in case a cell renderer throws an error.
 * The error message is error-logged to console AND displayed in cell.
 *
 * Each cell to be rendered is described by a {@link CellEvent} object. For performance reasons, to avoid constantly instantiating these objects, we maintain a pool of these. When the grid shape changes, we reset their coordinates by setting {@link CellEvent#reset|reset} on each.
 *
 * See also the discussion of clipping in {@link Renderer#paintCellsByColumns|paintCellsByColumns}.
 * @this {Renderer}
 * @param {CanvasRenderingContext2D} gc
 * @param {boolean} onlyHeaders
 * @memberOf Renderer.prototype
 */

function paintCellsByColumnsAndRowsHeaders(gc) {
    var prefillColor,
        rowPrefillColors,
        cellEvent,
        visibleColumns = this.visibleColumns,
        visibleRows = this.visibleRows,
        C = visibleColumns.length,

    // cLast = C - 1,
    rowIndex,
        R = visibleRows.length,
        pool = this.cellEventPool;

    if (!C || !R) {
        return;
    }

    // For each column...
    var poolIndex = 0;
    visibleColumns.forEachWithNeg(function (visibleColumn, columnIndex) {

        cellEvent = pool[poolIndex];
        visibleColumn = cellEvent.visibleColumn;

        if (!rowPrefillColors) {
            prefillColor = cellEvent.column.properties.backgroundColor;
        }

        // For each row of each subgrid (of each column)...
        for (rowIndex = 0; rowIndex < R; rowIndex++, poolIndex++) {
            if (rowPrefillColors) {
                prefillColor = rowPrefillColors[rowIndex];
            }

            try {
                var poolItem = pool[poolIndex];
                if (poolItem.isHeaderRow) {
                    this._paintCell(gc, poolItem, prefillColor);
                }
            } catch (e) {
                this.renderErrorCell(e, gc, visibleColumn, pool[poolIndex].visibleRow);
            }
        }
    }.bind(this));

    this.paintHeaderGridlines(gc);
}

paintCellsByColumnsAndRowsHeaders.key = 'by-columns-and-rows-headers';
paintCellsByColumnsAndRowsHeaders.rebundle = true;

module.exports = paintCellsByColumnsAndRowsHeaders;

},{}],105:[function(require,module,exports){
'use strict';

var bundleColumns = require('./bundle-columns');
var bundleRows = require('./bundle-rows');

/** @summary Render the grid with consolidated row OR column rects.
 * @desc Paints all the cells of a grid, one column at a time.
 *
 * First, a background rect is drawn using the grid background color.
 *
 * Then, if there are any rows with their own background color _that differs from the grid background color,_ these are consolidated and the consolidated groups of row backgrounds are all drawn before iterating through cells. These row backgrounds get priority over column backgrounds.
 *
 * If there are no such row background rects to draw, the column rects are consolidated and drawn instead (again, before the cells). Note that these column rects are _not_ suitable for clipping overflow text from previous columns. If you have overflow text, either turn on clipping (big performance hit) or turn on one of the `truncateTextWithEllipsis` options.
 *
 * `try...catch` surrounds each cell paint in case a cell renderer throws an error.
 * The error message is error-logged to console AND displayed in cell.
 *
 * Each cell to be rendered is described by a {@link CellEvent} object. For performance reasons, to avoid constantly instantiating these objects, we maintain a pool of these. When the grid shape changes, we reset their coordinates by setting {@link CellEvent#reset|reset} on each.
 *
 * See also the discussion of clipping in {@link Renderer#paintCellsByColumns|paintCellsByColumns}.
 * @this {Renderer}
 * @param {CanvasRenderingContext2D} gc
 * @memberOf Renderer.prototype
 */
function paintCellsByColumnsAndRows(gc) {
    var grid = this.grid,
        gridProps = grid.properties,
        prefillColor,
        rowPrefillColors,
        gridPrefillColor = gridProps.backgroundColor,
        cellEvent,
        rowBundle,
        rowBundles,
        columnBundle,
        columnBundles,
        visibleColumns = this.visibleColumns,
        visibleRows = this.visibleRows,
        c,
        C = visibleColumns.length,
        cLast = C - 1,
        rowIndex,
        R = visibleRows.length,
        pool = this.cellEventPool,
        columnClip,

    // clipToGrid,
    viewWidth = C ? visibleColumns[C - 1].right : 0,
        viewHeight = R ? visibleRows[R - 1].bottom : 0;

    gc.clearRect(0, 0, this.bounds.width, this.bounds.height);
    gc.fillStyle = gridProps.canvasBackgroundColor;
    gc.fillRect(0, 0, this.bounds.width, this.bounds.height);

    if (!C || !R) {
        return;
    }

    if (gc.alpha(gridPrefillColor) > 0) {
        gc.cache.fillStyle = gridPrefillColor;
        gc.fillRect(0, 0, viewWidth, viewHeight);
    }

    if (this.gridRenderer.reset) {
        this.resetAllGridRenderers();
        this.gridRenderer.reset = false;
        bundleRows.call(this, false);
        bundleColumns.call(this, true);
    } else if (this.gridRenderer.rebundle) {
        this.gridRenderer.rebundle = false;
        bundleColumns.call(this);
    }

    rowBundles = this.rowBundles;
    if (rowBundles.length) {
        rowPrefillColors = this.rowPrefillColors;
        for (rowIndex = rowBundles.length; rowIndex--;) {
            rowBundle = rowBundles[rowIndex];
            gc.clearFill(0, rowBundle.top, viewWidth, rowBundle.bottom - rowBundle.top, rowBundle.backgroundColor);
        }
    } else {
        for (columnBundles = this.columnBundles, c = columnBundles.length; c--;) {
            columnBundle = columnBundles[c];
            gc.clearFill(columnBundle.left, 0, columnBundle.right - columnBundle.left, viewHeight, columnBundle.backgroundColor);
        }
    }

    // gc.clipSave(clipToGrid, 0, 0, viewWidth, viewHeight);

    // For each column...
    var poolIndex = 0;
    visibleColumns.forEachWithNeg(function (visibleColumn, columnIndex) {

        cellEvent = pool[poolIndex];
        visibleColumn = cellEvent.visibleColumn;

        if (!rowPrefillColors) {
            prefillColor = cellEvent.column.properties.backgroundColor;
        }

        // Optionally clip to visible portion of column to prevent text from overflowing to right.
        columnClip = visibleColumn.column.properties.columnClip;
        gc.clipSave(columnClip || columnClip === null && columnIndex === cLast, 0, 0, visibleColumn.right, viewHeight);

        // For each row of each subgrid (of each column)...
        for (rowIndex = 0; rowIndex < R; rowIndex++, poolIndex++) {
            if (rowPrefillColors) {
                prefillColor = rowPrefillColors[rowIndex];
            }

            try {
                this._paintCell(gc, pool[poolIndex], prefillColor);
            } catch (e) {
                this.renderErrorCell(e, gc, visibleColumn, pool[poolIndex].visibleRow);
            }
        }

        gc.clipRestore(columnClip);
    }.bind(this));

    // gc.clipRestore(clipToGrid);

    this.paintGridlines(gc);
}

paintCellsByColumnsAndRows.key = 'by-columns-and-rows';
paintCellsByColumnsAndRows.rebundle = true; // see rebundleGridRenderers

module.exports = paintCellsByColumnsAndRows;

},{"./bundle-columns":101,"./bundle-rows":102}],106:[function(require,module,exports){
'use strict';

var bundleColumns = require('./bundle-columns');

/** @summary Render the grid with discrete column rects.
 * @desc Paints all the cells of a grid, one column at a time.
 *
 * In this grid renderer, a background rect is _not_ drawn using the grid background color.
 *
 * Rather, all columns paint their own background rects, with color defaulting to grid background color.
 *
 * The idea of painting each column rect is to "clip" text that might have overflowed from the previous column by painting over it with the background from this column. Only the last column will show overflowing text, and only if the canvas width exceeds the grid width. If this is the case, you can turn on clipping for the last column only by setting `columnClip` to `true` for the last column.
 *
 * NOTE: As a convenience feature, setting `columnClip` to `null` will clip only the last column, so simply setting it on the grid (rather than the last column) will have the same effect. This is much more convenient because you don't have to worry about the last column being redefined (moved, hidden, etc).
 *
 * `try...catch` surrounds each cell paint in case a cell renderer throws an error.
 * The error message is error-logged to console AND displayed in cell.
 *
 * Each cell to be rendered is described by a {@link CellEvent} object. For performance reasons, to avoid constantly instantiating these objects, we maintain a pool of these. When the grid shape changes, we reset their coordinates by setting {@link CellEvent#reset|reset} on each.
 *
 * See also the discussion of clipping in {@link Renderer#paintCellsByColumnsDiscrete|paintCellsByColumnsDiscrete}.

 * @this {Renderer}
 * @param {CanvasRenderingContext2D} gc
 * @memberOf Renderer.prototype
 */
function paintCellsByColumnsDiscrete(gc) {
    var prefillColor,
        cellEvent,
        visibleColumns = this.visibleColumns,
        visibleRows = this.visibleRows,
        C = visibleColumns.length,
        cLast = C - 1,
        r,
        R = visibleRows.length,
        pool = this.cellEventPool,
        preferredWidth,
        columnClip,

    // clipToGrid,
    // viewWidth = C ? visibleColumns[C - 1].right : 0,
    viewHeight = R ? visibleRows[R - 1].bottom : 0;

    gc.clearRect(0, 0, this.bounds.width, this.bounds.height);

    if (!C || !R) {
        return;
    }

    if (this.gridRenderer.reset) {
        this.resetAllGridRenderers(['by-columns']);
        this.gridRenderer.reset = false;
        bundleColumns.call(this, true);
    }

    // gc.clipSave(clipToGrid, 0, 0, viewWidth, viewHeight);

    // For each column...
    var p = 0;
    this.visibleColumns.forEachWithNeg(function (vc, c) {
        cellEvent = pool[p]; // first cell in column c
        vc = cellEvent.visibleColumn;

        prefillColor = cellEvent.column.properties.backgroundColor;
        gc.clearFill(vc.left, 0, vc.width, viewHeight, prefillColor);

        // Optionally clip to visible portion of column to prevent text from overflowing to right.
        columnClip = vc.column.properties.columnClip;
        gc.clipSave(columnClip || columnClip === null && c === cLast, 0, 0, vc.right, viewHeight);

        // For each row of each subgrid (of each column)...
        for (preferredWidth = r = 0; r < R; r++, p++) {
            cellEvent = pool[p]; // next cell down the column (redundant for first cell in column)

            try {
                preferredWidth = Math.max(preferredWidth, this._paintCell(gc, cellEvent, prefillColor));
            } catch (e) {
                this.renderErrorCell(e, gc, vc, cellEvent.visibleRow);
            }
        }

        gc.clipRestore(columnClip);

        cellEvent.column.properties.preferredWidth = Math.round(preferredWidth);
    }.bind(this));

    // gc.clipRestore(clipToGrid);

    this.paintGridlines(gc);
}

paintCellsByColumnsDiscrete.key = 'by-columns-discrete';

module.exports = paintCellsByColumnsDiscrete;

},{"./bundle-columns":101}],107:[function(require,module,exports){
'use strict';

var bundleColumns = require('./bundle-columns');

/** @summary Render the grid with consolidated column rects.
 * @desc Paints all the cells of a grid, one column at a time.
 *
 * First, a background rect is drawn using the grid background color.
 *
 * Then, if there are any columns with their own background color _that differs from the grid background color,_ these are consolidated and the consolidated groups of column backgrounds are all drawn before iterating through cells. Note that these column rects are _not_ suitable for clipping overflow text from previous columns. If you have overflow text, either turn on clipping (big performance hit) or turn on one of the `truncateTextWithEllipsis` options.
 *
 * `try...catch` surrounds each cell paint in case a cell renderer throws an error.
 * The error message is error-logged to console AND displayed in cell.
 *
 * Each cell to be rendered is described by a {@link CellEvent} object. For performance reasons, to avoid constantly instantiating these objects, we maintain a pool of these. When the grid shape changes, we reset their coordinates by setting {@link CellEvent#reset|reset} on each.
 *
 * **Regading clipping.** The reason for clipping is to prevent text from overflowing into the next column. However there is a serious performance cost.
 *
 * For performance reasons {@link Renderer#_paintCell|_paintCell} does not set up a clipping region for each cell. However, iff grid property `columnClip` is truthy, this grid renderer will set up a clipping region to prevent text overflow to right. If `columnClip` is `null`, a clipping region will only be set up on the last column. Otherwise, there will be no clipping region.
 *
 * The idea of clipping just the last column is because in addition to the optional graphics clipping, we also clip ("truncate") text. Text can be truncated conservatively so it will never overflow. The problem with this is that characters vanish as they hit the right cell boundary, which may or may be obvious depending on font size. Alternatively, text can be truncated so that the overflow will be a maximum of 1 character. This allows partial characters to be rendered. But this is where graphics clipping is required.
 *
 * When renderering column by column as this particular renderer does, _and_ when the background color _of the next cell to the right_ is opaque (alpha = 1), clipping can be turned off because each column will _overpaint_ any text that overflowed from the one before. However, any text that overflows the last column will paint into unused canvas region to the right of the grid. This is the _raison d'tre_ for "clip last column only" option mentioned above (when `columnClip` is set to `null`). To avoid even this performance cost (of clipping just the last column), column widths can be set to fill the available canvas.
 *
 * Note that text never overflows to left because text starting point is never < 0. The reason we don't clip to the left is for cell renderers that need to re-render to the left to produce a merged cell effect, such as grouped column header.

 * @this {Renderer}
 * @param {CanvasRenderingContext2D} gc
 * @memberOf Renderer.prototype
 */
function paintCellsByColumns(gc) {
    var grid = this.grid,
        gridProps = grid.properties,
        prefillColor,
        gridPrefillColor = gridProps.backgroundColor,
        cellEvent,
        columnBundle,
        columnBundles,
        visibleColumns = this.visibleColumns,
        visibleRows = this.visibleRows,
        c,
        C = visibleColumns.length,
        cLast = C - 1,
        r,
        R = visibleRows.length,
        pool = this.cellEventPool,
        preferredWidth,
        columnClip,

    // clipToGrid,
    viewWidth = C ? visibleColumns[cLast].right : 0,
        viewHeight = R ? visibleRows[R - 1].bottom : 0;

    gc.clearRect(0, 0, this.bounds.width, this.bounds.height);

    if (!C || !R) {
        return;
    }

    if (gc.alpha(gridPrefillColor) > 0) {
        gc.cache.fillStyle = gridPrefillColor;
        gc.fillRect(0, 0, viewWidth, viewHeight);
    }

    if (this.gridRenderer.reset) {
        this.resetAllGridRenderers(['by-columns-discrete']);
        this.gridRenderer.reset = false;
        bundleColumns.call(this, true);
    } else if (this.gridRenderer.rebundle) {
        this.gridRenderer.rebundle = false;
        bundleColumns.call(this);
    }

    for (columnBundles = this.columnBundles, c = columnBundles.length; c--;) {
        columnBundle = columnBundles[c];
        gc.clearFill(columnBundle.left, 0, columnBundle.right - columnBundle.left, viewHeight, columnBundle.backgroundColor);
    }

    // gc.clipSave(clipToGrid, 0, 0, viewWidth, viewHeight);

    // For each column...
    var p = 0;
    this.visibleColumns.forEachWithNeg(function (vc, c) {
        cellEvent = pool[p]; // first cell in column c
        vc = cellEvent.visibleColumn;

        prefillColor = cellEvent.column.properties.backgroundColor;

        // Optionally clip to visible portion of column to prevent text from overflowing to right.
        columnClip = vc.column.properties.columnClip;
        gc.clipSave(columnClip || columnClip === null && c === cLast, 0, 0, vc.right, viewHeight);

        // For each row of each subgrid (of each column)...
        for (preferredWidth = r = 0; r < R; r++, p++) {
            cellEvent = pool[p]; // next cell down the column (redundant for first cell in column)

            try {
                preferredWidth = Math.max(preferredWidth, this._paintCell(gc, cellEvent, prefillColor));
            } catch (e) {
                this.renderErrorCell(e, gc, vc, cellEvent.visibleRow);
            }
        }

        gc.clipRestore(columnClip);

        cellEvent.column.properties.preferredWidth = Math.round(preferredWidth);
    }.bind(this));

    // gc.clipRestore(clipToGrid);

    this.paintGridlines(gc);
}

paintCellsByColumns.key = 'by-columns';
paintCellsByColumns.rebundle = true; // see rebundleGridRenderers

module.exports = paintCellsByColumns;

},{"./bundle-columns":101}],108:[function(require,module,exports){
'use strict';

var bundleRows = require('./bundle-rows');

/** @summary Render the grid.
 * @desc _**NOTE:** This grid renderer is not as performant as the others and it's use is not recommended if you care about performance. The reasons for the wanting performance are unclear, possibly having to do with the way Chrome optimizes access to the column objects?_
 *
 * Paints all the cells of a grid, one row at a time.
 *
 * First, a background rect is drawn using the grid background color.
 *
 * Then, if there are any rows with their own background color _that differs from the grid background color,_ these are consolidated and the consolidated groups of row backgrounds are all drawn before iterating through cells.
 *
 * `try...catch` surrounds each cell paint in case a cell renderer throws an error.
 * The error message is error-logged to console AND displayed in cell.
 *
 * Each cell to be rendered is described by a {@link CellEvent} object. For performance reasons, to avoid constantly instantiating these objects, we maintain a pool of these. When the grid shape changes, we reset their coordinates by setting {@link CellEvent#reset|reset} on each.
 *
 * See also the discussion of clipping in {@link Renderer#paintCellsByColumns|paintCellsByColumns}.
 * @this {Renderer}
 * @param {CanvasRenderingContext2D} gc
 * @memberOf Renderer.prototype
 */
function paintCellsByRows(gc) {
    var grid = this.grid,
        gridProps = grid.properties,
        prefillColor,
        rowPrefillColors,
        gridPrefillColor = gridProps.backgroundColor,
        cellEvent,
        rowBundle,
        rowBundles = this.rowBundles,
        visibleColumns = this.visibleColumns,
        vr,
        visibleRows = this.visibleRows,
        c,
        C = visibleColumns.length,
        c0 = 0,
        cLast = C - 1,
        r,
        R = visibleRows.length,
        p,
        pool = this.cellEventPool,
        preferredWidth = Array(C - c0).fill(0),
        columnClip,

    // clipToGrid,
    viewWidth = C ? visibleColumns[C - 1].right : 0,
        viewHeight = R ? visibleRows[R - 1].bottom : 0,
        drawLines = gridProps.gridLinesH,
        lineWidth = gridProps.gridLinesWidth,
        lineColor = gridProps.gridLinesColor;

    gc.clearRect(0, 0, this.bounds.width, this.bounds.height);

    if (!C || !R) {
        return;
    }

    if (gc.alpha(gridPrefillColor) > 0) {
        gc.cache.fillStyle = gridPrefillColor;
        gc.fillRect(0, 0, viewWidth, viewHeight);
    }

    if (this.gridRenderer.reset) {
        this.resetAllGridRenderers();
        this.gridRenderer.reset = false;
        bundleRows.call(this, true);
    }

    rowPrefillColors = this.rowPrefillColors;

    for (r = rowBundles.length; r--;) {
        rowBundle = rowBundles[r];
        gc.clearFill(0, rowBundle.top, viewWidth, rowBundle.bottom - rowBundle.top, rowBundle.backgroundColor);
    }

    // gc.clipSave(clipToGrid, 0, 0, viewWidth, viewHeight);

    // For each row of each subgrid...
    for (p = 0, r = 0; r < R; r++) {
        prefillColor = rowPrefillColors[r];

        if (drawLines) {
            gc.cache.fillStyle = lineColor;
            gc.fillRect(0, pool[p].visibleRow.bottom, viewWidth, lineWidth);
        }

        // For each column (of each row)...
        this.visibleColumns.forEachWithNeg(function (vc) {
            // eslint-disable-line no-loop-func
            p++;
            cellEvent = pool[p]; // next cell across the row (redundant for first cell in row)
            vc = cellEvent.visibleColumn;

            // Optionally clip to visible portion of column to prevent text from overflowing to right.
            columnClip = vc.column.properties.columnClip;
            gc.clipSave(columnClip || columnClip === null && c === cLast, 0, 0, vc.right, viewHeight);

            try {
                preferredWidth[c] = Math.max(preferredWidth[c], this._paintCell(gc, cellEvent, prefillColor));
            } catch (e) {
                this.renderErrorCell(e, gc, vc, vr);
            }

            gc.clipRestore(columnClip);
        }.bind(this));
    }

    // gc.clipRestore(clipToGrid);

    this.paintGridlines(gc);

    this.visibleColumns.forEachWithNeg(function (vc, c) {
        vc.column.properties.preferredWidth = Math.round(preferredWidth[c]);
    });
}

paintCellsByRows.key = 'by-rows';

module.exports = paintCellsByRows;

},{"./bundle-rows":102}],109:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var Base = require('../Base');
var images = require('../../images');
var layerProps = require('./layer-props');

var visibleColumnPropertiesDescriptorFn = function visibleColumnPropertiesDescriptorFn(grid) {
    return {
        findWithNeg: {
            // Like the Array.prototype version except searches the negative indexes as well.
            value: function value(iteratee, context) {
                for (var i = grid.behavior.leftMostColIndex; i < 0; i++) {
                    if (!this[i]) {
                        continue;
                    }
                    if (iteratee.call(context, this[i], i, this)) {
                        return this[i];
                    }
                }
                return Array.prototype.find.call(this, iteratee, context);
            }
        },
        forEachWithNeg: {
            // Like the Array.prototype version except it iterates the negative indexes as well.
            value: function value(iteratee, context) {
                for (var i = grid.behavior.leftMostColIndex; i < 0; i++) {
                    if (!this[i]) {
                        continue;
                    }
                    iteratee.call(context, this[i], i, this);
                }
                return Array.prototype.forEach.call(this, iteratee, context);
            }

        },

        totalLength: {
            get: function get() {
                return Math.abs(grid.behavior.leftMostColIndex) + this.length;
            }
        }
    };
};

/**
 * @summary List of grid renderers available to new grid instances.
 * @desc Developer may augment this list with additional grid renderers before grid instantiation by calling @link {Renderer.registerGridRenderer}.
 * @memberOf Renderer~
 * @private
 * @type {function[]}
 */
var paintCellsFunctions = [];

/** @typedef {object} CanvasRenderingContext2D
 * @see [CanvasRenderingContext2D](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D)
 */

/** @typedef {object} visibleColumnArray
 * @property {number} index - A back reference to the element's array index in {@link Renderer#visibleColumns}.
 * @property {number} columnIndex - Dereferences {@link Behavior#columns}, the subset of _active_ columns, specifying which column to show in that position.
 * @property {number} left - Pixel coordinate of the left edge of this column, rounded to nearest integer.
 * @property {number} right - Pixel coordinate of the right edge of this column, rounded to nearest integer.
 * @property {number} width - Width of this column in pixels, rounded to nearest integer.
 */

/** @typedef {object} visibleRowArray
 * @property {number} index - A back reference to the element's array index in {@link Renderer#visibleRows}.
 * @property {number} rowIndex - Local vertical row coordinate within the subgrid to which the row belongs, adjusted for scrolling.
 * @property {dataModelAPI} subgrid - A reference to the subgrid to which the row belongs.
 * @property {number} top - Pixel coordinate of the top edge of this row, rounded to nearest integer.
 * @property {number} bottom - Pixel coordinate of the bottom edge of this row, rounded to nearest integer.
 * @property {number} height - Height of this row in pixels, rounded to nearest integer.
 */

/**
 * @constructor
 * @desc fin-hypergrid-renderer is the canvas enabled top level sub component that handles the renderering of the Grid.
 *
 * It relies on two other external subprojects
 *
 * 1. fin-canvas: a wrapper to provide a simpler interface to the HTML5 canvas component
 * 2. rectangular: a small npm module providing Point and Rectangle objects
 *
 * The fin-hypergrid-renderer is in a unique position to provide critical functionality to the fin-hypergrid in a hightly performant manner.
 * Because it MUST iterate over all the visible cells it can store various bits of information that can be encapsulated as a service for consumption by the fin-hypergrid component.
 *
 * Instances of this object have basically four main functions.
 *
 * 1. render fixed row headers
 * 2. render fixed col headers
 * 3. render main data cells
 * 4. render grid lines
 *
 * Same parameters as {@link Renderer#initialize|initialize}, which is called by this constructor.
 *
 */
var Renderer = Base.extend('Renderer', {

    //the shared single item "pooled" cell object for drawing each cell
    cell: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    },

    scrollHeight: 0,

    viewHeight: 0,

    /**
     * @summary Contains vertical view free space
     * @desc If visible rows not holds all the grid space, this variable will contain missing pixels count
     */
    bottomFreeSpace: 0,

    /**
     * @summary Count of rows, that was rendered partly
     * @desc used, when rendered on last page, and first row must be partly hidden, to avoid empty space on end
     */
    renderedCuttedRowsCount: 0,

    /**
     * @summary Number of pixels that was skipped on render to cut first row
     * @desc used, when rendered on last page, and first row must be partly hidden, to avoid empty space on end
     */
    skippedTopSpace: 0,

    reset: function reset() {
        this.bounds = {
            width: 0,
            height: 0
        };

        /**
         * Represents the ordered set of visible columns. Array size is always the exact number of visible columns, the last of which may only be partially visible.
         *
         * This sequence of elements' `columnIndex` values assumes one of three patterns. Which pattern is base on the following two questions:
         * * Are there "fixed" columns on the left?
         * * Is the grid horizontally scrolled?
         *
         * The set of `columnIndex` values consists of:
         * 1. The first element will be -1 if the row handle column is being rendered.
         * 2. A zero-based list of consecutive of integers representing the fixed columns (if any).
         * 3. An n-based list of consecutive of integers representing the scrollable columns (where n = number of fixed columns + the number of columns scrolled off to the left).
         * @type {visibleColumnArray}
         */
        this.visibleColumns = Object.defineProperties([], visibleColumnPropertiesDescriptorFn(this.grid));

        /**
         * Represents the ordered set of visible rows. Array size is always the exact number of visible rows.
         *
         * The sequence of elements' `rowIndex` values is local to each subgrid.
         * * **For each non-scrollable subgrid:** The sequence is a zero-based list of consecutive integers.
         * * **For the scrollable subgrid:**
         *   1. A zero-based list of consecutive of integers representing the fixed rows (if any).
         *   2. An n-based list of consecutive of integers representing the scrollable rows (where n = number of fixed rows + the number of rows scrolled off the top).
         *
         * Note that non-scrollable subgrids can come both before _and_ after the scrollable subgrid.
         * @type {visibleRowArray}
         */
        this.visibleRows = [];

        this.insertionBounds = [];

        this.cellEventPool = [];
    },

    /**
     * @summary Constructor logic
     * @desc This method will be called upon instantiation of this class or of any class that extends from this class.
     * > All `initialize()` methods in the inheritance chain are called, in turn, each with the same parameters that were passed to the constructor, beginning with that of the most "senior" class through that of the class of the new instance.
     * @memberOf Renderer.prototype
     */
    initialize: function initialize(grid) {
        this.grid = grid;

        this.gridRenderers = {};
        paintCellsFunctions.forEach(function (paintCellsFunction) {
            this.registerGridRenderer(paintCellsFunction);
        }, this);

        // typically grid properties won't exist yet
        this.setGridRenderer(this.properties.gridRenderer || 'by-columns-and-rows');

        this.reset();
    },

    registerGridRenderer: function registerGridRenderer(paintCellsFunction) {
        this.gridRenderers[paintCellsFunction.key] = {
            paintCells: paintCellsFunction
        };
    },

    setGridRenderer: function setGridRenderer(key) {
        var gridRenderer = this.gridRenderers[key];

        if (!gridRenderer) {
            throw new this.HypergridError('Unregistered grid renderer "' + key + '"');
        }

        if (gridRenderer !== this.gridRenderer) {
            this.gridRenderer = gridRenderer;
            this.gridRenderer.reset = true;
        }
    },

    resetAllGridRenderers: function resetAllGridRenderers(blackList) {
        // Notify renderers that grid shape has changed
        Object.keys(this.gridRenderers).forEach(function (key) {
            this.gridRenderers[key].reset = !blackList || blackList.indexOf(key) < 0;
        }, this);
    },

    /**
     * Certain renderers that pre-bundle column rects based on columns' background colors need to re-bundle when columns' background colors change. This method sets the `rebundle` property to `true` for those renderers that have that property.
     */
    rebundleGridRenderers: function rebundleGridRenderers() {
        Object.keys(this.gridRenderers).forEach(function (key) {
            if (this.gridRenderers[key].paintCells.rebundle) {
                this.gridRenderers[key].rebundle = true;
            }
        }, this);
    },

    resetRowHeaderColumnWidth: function resetRowHeaderColumnWidth() {
        this.lastKnowRowCount = undefined;
    },

    computeCellsBounds: function computeCellsBounds() {
        this.needsComputeCellsBounds = true;
    },

    /**
     * CAUTION: Keep in place! Used by {@link Canvas}.
     * @memberOf Renderer.prototype
     * @returns {Object} The current grid properties object.
     */
    get properties() {
        return this.grid.properties;
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Notify the fin-hypergrid every time we've repainted.
     * @desc This is the entry point from fin-canvas.
     * @param {CanvasRenderingContext2D} gc
     */
    paint: function paint(gc) {
        if (this.grid.canvas) {
            this.renderGrid(gc);
            this.grid.gridRenderedNotification();
        }
    },

    tickNotification: function tickNotification() {
        this.grid.tickNotification();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Answer how many rows we rendered
     */
    getVisibleRowsCount: function getVisibleRowsCount() {
        return this.visibleRows.length - 1;
    },

    getVisibleScrollHeight: function getVisibleScrollHeight() {
        return this.viewHeight - this.grid.getFixedRowsHeight();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Number of columns we just rendered.
     */
    getVisibleColumnsCount: function getVisibleColumnsCount() {
        return this.visibleColumns.length - 1;
    },

    /**
     * @memberOf Renderer.prototype
     * @param {CellEvent|number} x - CellEvent object or grid column coordinate.
     * @param {number} [y] - Grid row coordinate. Omit if `xOrCellEvent` is a CellEvent.
     * @returns {Rectangle} Bounding rect of cell with the given coordinates.
     */
    getBoundsOfCell: function getBoundsOfCell(x, y) {
        var vc = this.visibleColumns[x],
            vr = this.visibleRows[y];

        var event = this.cellEventPool.find(function (e) {
            return e.visibleColumn === vc && e.visibleRow === vr;
        });
        if (event) {
            return event.bounds;
        }

        return {
            x: vc.left,
            y: vr.top,
            width: vc.width + this.grid.behavior.getAdditionalWidth(x, y),
            height: vr.height + this.grid.behavior.getAdditionalHeight(x, y)
        };
    },

    /**
     * @memberOf Renderer.prototype
     * @desc answer the column index under the coordinate at pixelX
     * @param {number} pixelX - The horizontal coordinate.
     * @returns {number} The column index under the coordinate at pixelX.
     */
    getColumnFromPixelX: function getColumnFromPixelX(pixelX) {
        var width = 0,
            fixedColumnCount = this.grid.getFixedColumnCount(),
            scrollLeft = this.grid.getHScrollValue(),
            visibleColumns = this.visibleColumns;
        for (var c = 1; c < visibleColumns.length; c++) {
            width = visibleColumns[c].left;
            if (pixelX < width) {
                if (c > fixedColumnCount) {
                    c += scrollLeft;
                }
                return c - 1;
            }
        }
        if (c > fixedColumnCount) {
            c += scrollLeft;
        }
        return c - 1;
    },

    /**
     * @memberOf Renderer.prototype
     * @desc Answer specific data cell coordinates given mouse coordinates in pixels.
     * @param {Point} point
     * @returns {Point} Cell coordinates
     */
    getGridCellFromMousePoint: function getGridCellFromMousePoint(point) {
        if (!this.visibleColumns.length) {
            return null;
        }
        var x = point.x,
            y = point.y;
        var visibleRows = this.visibleRows,
            visibleColumns = this.visibleColumns;


        var firstColumn = visibleColumns[this.grid.behavior.leftMostColIndex];
        var inFirstColumn = x < firstColumn.right;

        var _visibleRows = _slicedToArray(visibleRows, 1),
            firstRow = _visibleRows[0];

        var behindFirstRow = y < firstRow.top;

        var isPseudoRow = false;
        var isPseudoCol = false;
        var result = { fake: false };

        var vc = inFirstColumn ? firstColumn : visibleColumns.findWithNeg(function (vc) {
            return x < vc.right;
        });

        var filtered = visibleRows.filter(function (vr) {
            return behindFirstRow ? vr.index !== vr.rowIndex : y <= vr.bottom && y >= vr.top;
        }).sort(function (vr1, vr2) {
            return vr2.rowIndex - vr1.rowIndex;
        });

        var vr = filtered[filtered.length - 1];

        // default to last row and col
        if (vr) {
            isPseudoRow = false;
        } else {
            vr = visibleRows[behindFirstRow ? 0 : visibleRows.length - 1];
            isPseudoRow = true;
        }

        if (vc) {
            isPseudoCol = false;
        } else {
            vc = visibleColumns[visibleColumns.length - 1];
            isPseudoCol = true;
        }

        var mousePoint = this.grid.newPoint(x - vc.left, y - vr.top),
            cellEvent = new this.grid.behavior.CellEvent(vc.columnIndex, vr.index);

        result.cellEvent = Object.defineProperty(cellEvent, 'mousePoint', { value: mousePoint });

        if (isPseudoCol || isPseudoRow) {
            result.fake = true;
            this.grid.beCursor(null);
        }

        return result;
    },

    /**
     * Matrix of unformatted values of visible cells.
     * @returns {Array<Array>}
     */
    getVisibleCellMatrix: function getVisibleCellMatrix() {
        var rows = Array(this.visibleRows.length);
        var adjust = this.grid.behavior.hasTreeColumn() ? 1 : 0;
        for (var y = 0; y < rows.length; ++y) {
            rows[y] = Array(this.visibleColumns.length);
        }
        this.cellEventPool.map(function (cell) {
            var x = cell.gridCell.x + adjust;
            if (x >= 0) {
                rows[cell.gridCell.y][x] = cell.value;
            }
        });
        return rows;
    },

    /**
     * @summary Get the visibility of the column matching the provided grid column index.
     * @desc Requested column may not be visible due to being scrolled out of view.
     * @memberOf Renderer.prototype
     * @summary Determines if a column is visible.
     * @param {number} columnIndex - the column index
     * @returns {boolean} The given column is visible.
     */
    isColumnVisible: function isColumnVisible(columnIndex) {
        return !!this.getVisibleColumn(columnIndex);
    },

    /**
     * @summary Get the "visible column" object matching the provided grid column index.
     * @desc Requested column may not be visible due to being scrolled out of view.
     * @memberOf Renderer.prototype
     * @summary Find a visible column object.
     * @param {number} columnIndex - The grid column index.
     * @returns {object|undefined} The given column if visible or `undefined` if not.
     */
    getVisibleColumn: function getVisibleColumn(columnIndex) {
        return this.visibleColumns.findWithNeg(function (vc) {
            return vc.columnIndex === columnIndex;
        });
    },

    /**
     * @desc Calculate the minimum left column index so the target column shows up in viewport (we need to be aware of viewport's width, number of fixed columns and each column's width)
     * @param {number} targetColIdx - Target column index
     * @returns {number} Minimum left column index so target column shows up
     */
    getMinimumLeftPositionToShowColumn: function getMinimumLeftPositionToShowColumn(targetColIdx) {
        var fixedColumnCount = this.grid.getFixedColumnCount();
        var fixedColumnsWidth = 0;
        var rowNumbersWidth = 0;
        var filtersWidth = 0;
        var viewportWidth = 0;
        var leftColIdx = 0;
        var targetRight = 0;
        var lastFixedColumn = null;
        var computedCols = [];
        var col = null;
        var i = 0;
        var left = 0;
        var right = 0;

        // 1) for each column, we'll compute left and right position in pixels (until target column)
        for (i = 0; i <= targetColIdx; i++) {
            left = right;
            right += Math.ceil(this.grid.getColumnWidth(i));

            computedCols.push({
                left: left,
                right: right
            });
        }

        targetRight = computedCols[computedCols.length - 1].right;

        // 2) calc usable viewport width
        lastFixedColumn = computedCols[fixedColumnCount - 1];

        if (this.properties.showRowNumbers) {
            rowNumbersWidth = this.grid.getColumnWidth(this.grid.behavior.rowColumnIndex);
        }

        if (this.grid.hasTreeColumn()) {
            filtersWidth = this.grid.getColumnWidth(this.grid.behavior.treeColumnIndex);
        }

        fixedColumnsWidth = lastFixedColumn ? lastFixedColumn.right : 0;
        viewportWidth = this.getBounds().width - fixedColumnsWidth - rowNumbersWidth - filtersWidth;

        // 3) from right to left, find the last column that can still render target column
        i = targetColIdx;

        do {
            leftColIdx = i;
            col = computedCols[i];
            i--;
        } while (col.left + viewportWidth > targetRight && i >= 0);

        return leftColIdx;
    },

    /**
     * @summary Get the visibility of the column matching the provided data column index.
     * @desc Requested column may not be visible due to being scrolled out of view or if the column is inactive.
     * @memberOf Renderer.prototype
     * @summary Determines if a column is visible.
     * @param {number} columnIndex - the column index
     * @returns {boolean} The given column is visible.
     */
    isDataColumnVisible: function isDataColumnVisible(columnIndex) {
        return !!this.getVisibleDataColumn(columnIndex);
    },

    /**
     * @summary Get the "visible column" object matching the provided data column index.
     * @desc Requested column may not be visible due to being scrolled out of view or if the column is inactive.
     * @memberOf Renderer.prototype
     * @summary Find a visible column object.
     * @param {number} columnIndex - The grid column index.
     * @returns {object|undefined} The given column if visible or `undefined` if not.
     */
    getVisibleDataColumn: function getVisibleDataColumn(columnIndex) {
        return this.visibleColumns.findWithNeg(function (vc) {
            return vc.column.index === columnIndex;
        });
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The width x coordinate of the last rendered column
     */
    getFinalVisibleColumnBoundary: function getFinalVisibleColumnBoundary() {
        var chop = this.isLastColumnVisible() ? 2 : 1;
        var colWall = this.visibleColumns[this.visibleColumns.length - chop].right;
        return Math.min(colWall, this.getBounds().width);
    },

    /**
     * @summary Get the visibility of the row matching the provided grid row index.
     * @desc Requested row may not be visible due to being outside the bounds of the rendered grid.
     * @memberOf Renderer.prototype
     * @summary Determines visibility of a row.
     * @param {number} rowIndex - The grid row index.
     * @returns {boolean} The given row is visible.
     */
    isRowVisible: function isRowVisible(rowIndex) {
        return !!this.visibleRows[rowIndex];
    },

    /**
     * @summary Get the "visible row" object matching the provided grid row index.
     * @desc Requested row may not be visible due to being outside the bounds of the rendered grid.
     * @memberOf Renderer.prototype
     * @summary Find a visible row object.
     * @param {number} rowIndex - The grid row index.
     * @returns {object|undefined} The given row if visible or `undefined` if not.
     */
    getVisibleRow: function getVisibleRow(rowIndex) {
        return this.visibleRows[rowIndex];
    },

    /**
     * @summary Get the visibility of the row matching the provided data row index.
     * @desc Requested row may not be visible due to being scrolled out of view.
     * @memberOf Renderer.prototype
     * @summary Determines visibility of a row.
     * @param {number} rowIndex - The data row index.
     * @param {dataModelAPI} [subgrid=this.behavior.subgrids.data]
     * @returns {boolean} The given row is visible.
     */
    isDataRowVisible: function isDataRowVisible(rowIndex, subgrid) {
        return !!this.getVisibleDataRow(rowIndex, subgrid);
    },

    /**
     * @summary Get the "visible row" object matching the provided data row index.
     * @desc Requested row may not be visible due to being scrolled out of view.
     * @memberOf Renderer.prototype
     * @summary Find a visible row object.
     * @param {number} rowIndex - The data row index within the given subgrid.
     * @param {dataModelAPI} [subgrid=this.behavior.subgrids.data]
     * @returns {object|undefined} The given row if visible or `undefined` if not.
     */
    getVisibleDataRow: function getVisibleDataRow(rowIndex, subgrid) {
        subgrid = subgrid || this.grid.behavior.subgrids.lookup.data;
        return this.visibleRows.find(function (vr) {
            return vr.subgrid === subgrid && vr.rowIndex === rowIndex;
        });
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Determines if a cell is selected.
     * @param {number} x - the x cell coordinate
     * @param {number} y - the y cell coordinate*
     * @returns {boolean} The given cell is fully visible.
     */
    isSelected: function isSelected(x, y) {
        return this.grid.isSelected(x, y);
    },

    /**
     * @memberOf Renderer.prototype
     * @desc This is the main forking of the renderering task.
     * @param {CanvasRenderingContext2D} gc
     */
    renderGrid: function renderGrid(gc) {
        this.grid.deferredBehaviorChange();

        gc.beginPath();

        this.buttonCells = {};

        var rowCount = this.grid.getRowCount();
        if (rowCount !== this.lastKnowRowCount) {
            var newWidth = resetRowHeaderColumnWidth.call(this, gc, rowCount);
            if (newWidth !== this.handleColumnWidth) {
                this.needsComputeCellsBounds = true;
                this.handleColumnWidth = newWidth;
            }
            this.lastKnowRowCount = rowCount;
        }

        if (this.needsComputeCellsBounds) {
            computeCellsBounds.call(this);
            this.needsComputeCellsBounds = false;
        }

        this.gridRenderer.paintCells.call(this, gc);
        //render header cells after all another cells to avoid overlapping
        this.gridRenderers['by-columns-and-rows-headers'].paintCells.call(this, gc);

        this.renderSelections(gc);
        this.renderFirstSelectedCell(gc);

        gc.closePath();
    },

    renderFirstSelectedCell: function renderFirstSelectedCell(gc) {
        var firstSelectedCell = this.grid.selectionModel.getFirstSelectedCellOfLastSelection();

        if (!firstSelectedCell) {
            return;
        }

        var x = firstSelectedCell.x,
            y = firstSelectedCell.y;


        if (!this.grid.isDataVisible(x, y) && this.visibleColumns.length > 0) {
            var firstVisibleColumnIndex = this.visibleColumns[0].columnIndex;
            var firstVisibleRowIndex = this.visibleRows[0].rowIndex + this.grid.getHeaderRowCount();
            var colspan = this.grid.behavior.getColspan(x, y);
            var rowspan = this.grid.behavior.getRowspan(x, y);
            if (colspan && x + colspan >= firstVisibleColumnIndex) {
                x = firstVisibleColumnIndex;
            }

            if (rowspan && y + rowspan + this.grid.getHeaderRowCount() >= firstVisibleRowIndex) {
                y = firstVisibleRowIndex;
            }
        }

        if (!this.grid.isDataVisible(x, y)) {
            return;
        }

        var fixedColumnsCount = this.grid.getFixedColumnCount();
        var newX = x >= fixedColumnsCount ? x - this.dataWindow.origin.x : x;

        newX = Math.max(0, newX);

        var pointWithHeaders = {
            x: newX,
            y: y + this.grid.getHeaderRowCount() - this.grid.getVScrollValue() + this.renderedCuttedRowsCount
        };

        var cellBounds = this.grid.getBoundsOfCell(pointWithHeaders);

        var headerRowsCount = this.grid.getHeaderRowCount();
        var headerHeight = headerRowsCount * this.properties.defaultHeaderRowHeight;
        if (!headerHeight) {
            for (var i = 0; i < headerRowsCount; i++) {
                headerHeight += this.grid.getRowHeight(i);
            }
        }

        var startX = cellBounds.left,
            startY = cellBounds.top,
            selectionWidth = cellBounds.width,
            selectionHeight = cellBounds.height;

        if (startY < headerHeight) {
            startY = headerHeight;
            selectionHeight -= this.skippedTopSpace;
        }

        gc.beginPath();
        gc.rect(startX, startY, selectionWidth, selectionHeight);
        gc.cache.lineWidth = 2;
        gc.cache.strokeStyle = this.grid.properties.selectionRegionOutlineColor;
        gc.stroke();
        gc.closePath();
    },

    renderSelections: function renderSelections(gc) {
        var _this = this;

        (this.grid.selectionModel.getSelections() || []).forEach(function (s, i, items) {
            return _this.renderSelectionRect(gc, s, i + 1 === items.length);
        });
    },

    renderSelectionRect: function renderSelectionRect(gc, selection) {
        var isLastSelection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (selection.origin.x === -1) {
            return;
        }

        var vci = this.visibleColumnsByIndex,
            vri = this.visibleRowsByDataRowIndex,
            lastColumn = this.visibleColumns[this.visibleColumns.length - 1],
            // last column in scrollable section
        lastRow = vri[this.dataWindow.corner.y]; // last row in scrollable data section

        if (lastColumn && selection.origin.x > lastColumn.columnIndex || lastRow && selection.origin.y > lastRow.rowIndex) {
            return;
        }

        var vcOrigin = vci[selection.origin.x],
            vcCorner = vci[selection.corner.x],
            vrOrigin = vri[selection.origin.y],
            vrCorner = vri[selection.corner.y];

        var gridProps = this.properties;
        vcOrigin = vcOrigin || this.visibleColumns[gridProps.fixedColumnCount];
        vrOrigin = vrOrigin || this.visibleRows[gridProps.fixedRowCount + this.grid.getHeaderRowCount()];

        if (!lastColumn) {
            var colOffset = 1;
            while (!lastColumn && this.dataWindow.corner.x > 0) {
                lastColumn = vci[this.dataWindow.corner.x - colOffset];
                colOffset++;
            }
        }
        if (!lastRow) {
            var rowOffset = 1;
            while (!lastRow && this.dataWindow.corner.y > 0) {
                lastRow = vri[this.dataWindow.corner.y - rowOffset];
                rowOffset++;
            }
        }
        vcCorner = vcCorner || (lastColumn && selection.corner.x > lastColumn.columnIndex ? lastColumn : vci[this.grid.getFixedColumnCount()]);
        vrCorner = vrCorner || (lastRow && selection.corner.y > lastRow.rowIndex ? lastRow : vri[this.grid.getFixedColumnCount()]);

        if (!(vcOrigin && vcCorner && vrOrigin && vrCorner)) {
            return;
        }

        var headerRowsCount = this.grid.getHeaderRowCount();
        var headerHeight = headerRowsCount * this.properties.defaultHeaderRowHeight;
        if (!headerHeight) {
            for (var i = 0; i < headerRowsCount; i++) {
                headerHeight += this.grid.getRowHeight(i);
            }
        }

        var startX = vcOrigin.left,
            startY = vrOrigin.top,
            width = vcCorner.right - vcOrigin.left,
            height = vrCorner.bottom - vrOrigin.top;
        if (startY < headerHeight) {
            startY = headerHeight;
            height -= this.skippedTopSpace;
        }

        // Render the selection model around the bounds
        var config = {
            bounds: {
                x: startX,
                y: startY,
                width: width,
                height: height
            },
            selectionRegionOverlayColor: this.gridRenderer.paintCells.partial || isLastSelection && selection.width === 0 && selection.height === 0 ? 'transparent' : gridProps.selectionRegionOverlayColor,
            selectionRegionOutlineColor: gridProps.selectionRegionOutlineColor,
            selectionRegionBorderWidth: gridProps.selectionRegionBorderWidth ? gridProps.selectionRegionBorderWidth : 1
        };
        this.grid.cellRenderers.get('lastselection').paint(gc, config);
        if (this.gridRenderer.paintCells.key === 'by-cells') {
            this.gridRenderer.reset = true; // fixes GRID-490
        }
    },

    /**
     * @memberOf Renderer.prototype
     * @desc iterate the renderering overrides and manifest each
     * @param {CanvasRenderingContext2D} gc
     */
    renderOverrides: function renderOverrides(gc) {
        var cache = this.grid.renderOverridesCache;
        for (var key in cache) {
            if (cache.hasOwnProperty(key)) {
                var override = cache[key];
                if (override) {
                    this.renderOverride(gc, override);
                }
            }
        }
    },

    /**
     * @memberOf Renderer.prototype
     * @desc copy each overrides specified area to it's target and blank out the source area
     * @param {CanvasRenderingContext2D} gc
     * @param {OverrideObject} override - an object with details contain an area and a target context
     */
    renderOverride: function renderOverride(gc, override) {
        //lets blank out the drag row
        var hdpiRatio = override.hdpiratio;
        var startX = override.startX; //hdpiRatio * edges[override.columnIndex];
        var width = override.width + 1;
        var height = override.height;
        var targetCTX = override.ctx;
        var imgData = gc.getImageData(startX, 0, Math.round(width * hdpiRatio), Math.round(height * hdpiRatio));
        targetCTX.putImageData(imgData, 0, 0);
        gc.cache.fillStyle = this.properties.backgroundColor2;
        gc.fillRect(Math.round(startX / hdpiRatio), 0, width, height);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Current vertical scroll value.
     */
    getScrollTop: function getScrollTop() {
        return this.grid.getVScrollValue();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Current horizontal scroll value.
     */
    getScrollLeft: function getScrollLeft() {
        return this.grid.getHScrollValue();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {boolean} The last col was rendered (is visible)
     */
    isLastColumnVisible: function isLastColumnVisible() {
        var lastColumnIndex = this.grid.getColumnCount() - 1;
        return !!this.visibleColumns.findWithNeg(function (vc) {
            return vc.columnIndex === lastColumnIndex;
        });
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The rendered column width at index
     */
    getRenderedWidth: function getRenderedWidth(index) {
        var result,
            columns = this.visibleColumns;

        if (index >= columns.length) {
            result = columns[columns.length - 1].right;
        } else {
            result = columns[index].left;
        }

        return result;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The rendered row height at index
     */
    getRenderedHeight: function getRenderedHeight(index) {
        var result,
            rows = this.visibleRows;

        if (index >= rows.length) {
            var last = rows[rows.length - 1];
            result = last.bottom;
        } else {
            result = rows[index].top;
        }

        return result;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {boolean} User is currently dragging a column for reordering.
     */
    isDraggingColumn: function isDraggingColumn() {
        return this.grid.isDraggingColumn();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row to go to for a page up.
     */
    getPageUpRow: function getPageUpRow() {
        var grid = this.grid,
            scrollHeight = this.getVisibleScrollHeight(),
            top = this.dataWindow.origin.y - this.properties.fixedRowCount - 1,
            scanHeight = 0;
        while (scanHeight < scrollHeight && top >= 0) {
            scanHeight += grid.getRowHeight(top);
            top--;
        }
        return top + 1;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row to goto for a page down.
     */
    getPageDownRow: function getPageDownRow() {
        return this.dataWindow.corner.y - this.properties.fixedRowCount + 1;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row to goto for a page right.
     */
    getPageRightColumn: function getPageRightColumn() {
        return this.dataWindow.corner.x - this.properties.fixedColumnCount + 1;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row to go to for a page left.
     */
    getPageLeftColumn: function getPageLeftColumn() {
        var widthLeft = this.bounds.width;
        var currentColumnToScrollIndex = this.dataWindow.origin.x - 1;

        while (currentColumnToScrollIndex >= 0) {
            widthLeft -= this.grid.getColumnWidth(currentColumnToScrollIndex);

            if (widthLeft < 0) {
                break;
            }

            currentColumnToScrollIndex -= 1;
        }

        var additionalColumns = this.grid.properties.rowHeaderNumbers ? 1 : 0;
        return currentColumnToScrollIndex + additionalColumns;
    },

    renderErrorCell: function renderErrorCell(err, gc, vc, vr) {
        var message = err && (err.message || err) || 'Unknown error.',
            bounds = { x: vc.left, y: vr.top, width: vc.width, height: vr.height },
            config = { bounds: bounds };

        console.error(message);

        gc.cache.save(); // define clipping region
        gc.beginPath();
        gc.rect(bounds.x, bounds.y, bounds.width, bounds.height);
        gc.clip();

        this.grid.cellRenderers.get('errorcell').paint(gc, config, message);

        gc.cache.restore(); // discard clipping region
    },

    drawLine: function drawLine(gc, x1, y1, width, height) {
        gc.fillRect(x1, y1, width, height);
    },

    /**
     * Draws a rounded rectangle using the current state of the canvas.
     * If you omit the last three params, it will draw a rectangle
     * outline with a 5 pixel border radius
     * @param {CanvasRenderingContext2D} gc
     * @param {Number} x The top left x coordinate
     * @param {Number} y The top left y coordinate
     * @param {Number} width The width of the rectangle
     * @param {Number} height The height of the rectangle
     * @param {Number} [radius = 5] The corner radius; It can also be an object
     *                 to specify different radii for corners
     * @param {Number} [radius.tl = 0] Top left
     * @param {Number} [radius.tr = 0] Top right
     * @param {Number} [radius.br = 0] Bottom right
     * @param {Number} [radius.bl = 0] Bottom left
     * @param {Boolean} [fill = false] Whether to fill the rectangle.
     * @param {Boolean} [stroke = true] Whether to stroke the rectangle.
     */
    renderRoundRect: function renderRoundRect(gc, x, y, width, height, radius, fill, stroke) {
        if (typeof stroke === 'undefined') {
            stroke = true;
        }
        if (typeof radius === 'undefined') {
            radius = 5;
        }
        if (typeof radius === 'number') {
            radius = { tl: radius, tr: radius, br: radius, bl: radius };
        } else {
            var defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
            for (var side in defaultRadius) {
                radius[side] = radius[side] || defaultRadius[side];
            }
        }
        gc.beginPath();
        gc.moveTo(x + radius.tl, y);
        gc.lineTo(x + width - radius.tr, y);
        gc.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
        gc.lineTo(x + width, y + height - radius.br);
        gc.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
        gc.lineTo(x + radius.bl, y + height);
        gc.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
        gc.lineTo(x, y + radius.tl);
        gc.quadraticCurveTo(x, y, x + radius.tl, y);
        gc.closePath();
        if (fill) {
            gc.fill();
        }
        if (stroke) {
            gc.stroke();
        }
    },

    /**
     * @memberOf Renderer.prototype
     * @desc We opted to not paint borders for each cell as that was extremely expensive. Instead we draw grid lines here.
     * @param {CanvasRenderingContext2D} gc
     */
    paintGridlines: function paintGridlines(gc) {
        var visibleColumns = this.visibleColumns,
            columnsLength = visibleColumns.length,
            visibleRows = this.visibleRows,
            rowsLength = visibleRows.length;

        if (columnsLength && rowsLength) {
            var gridProps = this.properties,
                viewWidth = visibleColumns[columnsLength - 1].right,
                viewHeight = visibleRows[rowsLength - 1].bottom;

            if (gridProps.gridLinesV) {
                gc.cache.fillStyle = gc.cache.strokeStyle = gridProps.gridLinesColor;

                for (var right, vc = visibleColumns[0], c = 0; c < columnsLength; c++) {
                    vc = visibleColumns[c];
                    if (!vc.gap) {
                        right = vc.right;

                        var shift = gridProps.defaultHeaderRowHeight - gridProps.gridLinesWidth;

                        for (var i = 0; i < rowsLength; ++i) {
                            var row = visibleRows[i];
                            if (row.subgrid.isData) {
                                if (this.grid.behavior.dataModel.isColspanedByLeftColumn(vc.columnIndex + 1, row.rowIndex)) {
                                    shift += row.height + gridProps.gridLinesWidth;
                                } else {
                                    break;
                                }
                            }
                        }
                        this.drawLine(gc, right, shift, gridProps.gridLinesWidth, viewHeight - shift);
                    }
                }
            }

            if (gridProps.gridLinesH) {
                gc.cache.fillStyle = gc.cache.strokeStyle = gridProps.gridLinesColor;
                for (var bottom, vr = visibleRows[0], r = 0; r < rowsLength; r++) {
                    vr = visibleRows[r];
                    bottom = vr.bottom;

                    for (var _i = 0; _i < columnsLength; ++_i) {
                        var column = visibleColumns[_i];
                        if (!vr.gap && !this.grid.behavior.dataModel.isRowspanedByRow(column.columnIndex, vr.rowIndex + 1)) {
                            this.drawLine(gc, column.left, bottom, column.width + (gridProps.gridLinesV ? gridProps.gridLinesWidth : 0), gridProps.gridLinesWidth);
                        }
                    }
                    // if (vr.rowIndex > gridProps.fictiveHeaderRowsCount) {
                    //     for (let i = 0; i < columnsLength; ++i) {
                    //         const column = visibleColumns[i];
                    //         if (!vr.gap && !this.grid.behavior.dataModel.isRowspanedByRow(column.columnIndex - 1, vr.rowIndex + 1)) {
                    //             this.drawLine(gc, column.left, bottom, column.width, gridProps.gridLinesWidth);
                    //         }
                    //     }
                    // } else if (!vr.gap) {
                    //     this.drawLine(gc, 0, bottom, viewWidth, gridProps.gridLinesWidth);
                    // }
                    // if (!vr.gap) {
                    //     this.drawLine(gc, 0, bottom, viewWidth, gridProps.gridLinesWidth);
                    // }
                }
            }

            var edgeWidth = void 0;
            var gap = visibleRows.gap;
            if (gap) {
                gc.cache.fillStyle = gc.cache.strokeStyle = gridProps.fixedLinesHColor || gridProps.gridLinesColor;
                edgeWidth = gridProps.fixedLinesHEdge;
                if (edgeWidth) {
                    this.drawLine(gc, 0, gap.top, viewWidth, edgeWidth);
                    this.drawLine(gc, 0, gap.bottom - edgeWidth, viewWidth, edgeWidth);
                } else if (gridProps.fixedRowCount > 0) {
                    this.drawLine(gc, 0, gap.top, viewWidth, gap.bottom - gap.top);
                }
            }

            gap = visibleColumns.gap;
            if (gap) {
                gc.cache.fillStyle = gc.cache.strokeStyle = gridProps.fixedLinesVColor || gridProps.gridLinesColor;
                edgeWidth = gridProps.fixedLinesVEdge;
                if (edgeWidth) {
                    this.drawLine(gc, gap.left, 0, edgeWidth, viewHeight);
                    this.drawLine(gc, gap.right - edgeWidth, 0, edgeWidth, viewHeight);
                } else {
                    this.drawLine(gc, gap.left, 0, gap.right - gap.left, viewHeight);
                }
            }
        }
    },

    /**
     * @memberOf Renderer.prototype
     * @desc function to render header grid lines separately
     * @param {CanvasRenderingContext2D} gc
     */
    paintHeaderGridlines: function paintHeaderGridlines(gc) {
        var visibleColumns = this.visibleColumns,
            columnsLength = visibleColumns.length,
            visibleRows = this.visibleRows,
            rowsLength = visibleRows.length;

        if (columnsLength && rowsLength) {
            var gridProps = this.properties,
                viewWidth = visibleColumns[columnsLength - 1].right,
                viewHeight = visibleRows[rowsLength - 1].bottom;
            var headerRowsCount = this.grid.getHeaderRowCount();

            if (gridProps.gridLinesV || gridProps.gridLinesHeaderColor) {
                var headerHeight = headerRowsCount * this.properties.defaultHeaderRowHeight;
                if (!headerHeight) {
                    for (var i = 0; i < headerRowsCount; i++) {
                        headerHeight += this.grid.getRowHeight(i);
                    }
                }

                gc.cache.fillStyle = gc.cache.strokeStyle = gridProps.gridLinesHeaderColor ? gridProps.gridLinesHeaderColor : gridProps.gridLinesColor;
                for (var headerRight, headerVc = visibleColumns[0], headerC = 0; headerC < columnsLength; headerC++) {
                    headerVc = visibleColumns[headerC];
                    headerRight = headerVc.right;
                    if (!headerVc.gap) {
                        this.drawLine(gc, headerRight, 0, gridProps.gridLinesWidth, headerHeight);
                    }
                }

                if (this.grid.properties.rowHeaderNumbers) {
                    var right = visibleColumns[this.grid.behavior.rowColumnIndex].right;
                    gc.cache.fillStyle = gc.cache.strokeStyle = gridProps.gridLinesHeaderColor || gridProps.gridLinesColor;
                    this.drawLine(gc, right, 0, gridProps.gridLinesWidth, viewHeight);
                }
            }

            if (gridProps.gridLinesH || gridProps.gridLinesHeaderColor) {
                gc.cache.fillStyle = gc.cache.strokeStyle = gridProps.gridLinesHeaderColor ? gridProps.gridLinesHeaderColor : gridProps.gridLinesColor;

                var additionalWidth = gridProps.gridLinesV ? gridProps.gridLinesWidth : 0;
                var firstRowWidth = this.grid.properties.rowHeaderNumbers ? visibleColumns[this.grid.behavior.rowColumnIndex].right + additionalWidth : 0;

                gc.cache.fillStyle = gc.cache.strokeStyle = gridProps.gridLinesHeaderColor;
                for (var headerBottom, headerVr = visibleRows[0], headerR = 0; headerR < rowsLength; headerR++) {
                    headerVr = visibleRows[headerR];
                    headerBottom = headerVr.bottom;
                    if (!headerVr.gap) {
                        if (headerR < headerRowsCount) {
                            this.drawLine(gc, 0, headerBottom, viewWidth, gridProps.gridLinesWidth);
                        } else {
                            this.drawLine(gc, 0, headerBottom, firstRowWidth, gridProps.gridLinesWidth);
                        }
                    }
                }
            }
        }
    },

    /**
     * @memberOf Renderer.prototype
     * @param {CanvasRenderingContext2D} gc
     * @param x
     * @param y
     */
    paintCell: function paintCell(gc, x, y) {
        gc.moveTo(0, 0);

        var c = this.visibleColumns[x].index,
            // todo refac
        r = this.visibleRows[y].index;

        if (c) {
            //something is being viewed at at the moment (otherwise returns undefined)
            this._paintCell(gc, c, r);
        }
    },

    /**
     * @summary Render a single cell.
     * @param {CanvasRenderingContext2D} gc
     * @param {CellEvent} cellEvent
     * @param {string} [prefillColor] If omitted, this is a partial renderer; all other renderers must provide this.
     * @returns {number} Preferred width of renndered cell.
     * @private
     * @memberOf Renderer
     */
    _paintCell: function _paintCell(gc, cellEvent, prefillColor) {
        if (cellEvent.isRenderSkipNeeded) {
            return;
        }

        var grid = this.grid,
            selectionModel = grid.selectionModel,
            behavior = grid.behavior,
            properties = cellEvent.properties,
            isHandleColumn = cellEvent.isHandleColumn,
            isTreeColumn = cellEvent.isTreeColumn,
            isColumnSelected = cellEvent.isColumnSelected,
            isDataRow = cellEvent.isDataRow,
            isRowSelected = cellEvent.isRowSelected,
            isCellSelected = cellEvent.isCellSelected,
            isHeaderRow = cellEvent.isHeaderRow,
            isFilterRow = cellEvent.isFilterRow,
            isRowHandleOrHierarchyColumn = isHandleColumn || isTreeColumn,
            isUserDataArea = !isRowHandleOrHierarchyColumn && isDataRow,
            config = this.assignProps(cellEvent),
            x = (config.gridCell = cellEvent.gridCell).x,
            r = (config.dataCell = cellEvent.dataCell).y,
            value,
            format,
            isSelected;

        if (isHandleColumn && isDataRow) {
            isSelected = isRowSelected || selectionModel.isCellSelectedInRow(r);
            config.halign = this.properties.columnHeaderHalign;
        } else if (isTreeColumn) {
            isSelected = isRowSelected || selectionModel.isCellSelectedInRow(r);
            config.halign = 'left';
        } else if (isDataRow) {
            isSelected = isCellSelected || isRowSelected || isColumnSelected;
            format = config.format;
        } else if (x === grid.behavior.rowColumnIndex && r === 0 && isHandleColumn && isHeaderRow && behavior.errorCount) {
            config.foregroundSelectionColor = config.color = properties.backgroundColor;
            // config.backgroundText = this.properties.errorTotalUnicodeChar;
            // config.backgroundTextFont = this.properties.errorIconFont;
            // config.backgroundTextColor = this.properties.errorIconColor;
            config.renderTotalErrorSignNeeded = true;
            config.renderTotalErrorCount = behavior.errorCount;
        } else {
            format = cellEvent.subgrid.format || config.format; // subgrid format can override column format
            if (isFilterRow) {
                isSelected = false;
            } else if (isColumnSelected) {
                isSelected = true;
            } else {
                isSelected = selectionModel.isCellSelectedInColumn(x); // header or summary or other non-meta
            }
        }

        // Set cell contents:
        // * For all cells: set `config.value` (writable property)
        // * For cells outside of row handle column: also set `config.dataRow` for use by valOrFunc

        if (!isHandleColumn) {
            //Including hierarchyColumn
            config.dataRow = cellEvent.dataRow;
            value = cellEvent.value;
            if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.type === 'ERROR') {
                config.foregroundSelectionColor = config.color = config.errorCellDataColor;
            }
            if (value === null) {
                config.foregroundSelectionColor = config.color = config.nullCellColor;
                value = config.nullCellPlaceholder;
            }
        } else {
            if (isDataRow) {
                // row handle for a data row
                if (config.rowHeaderNumbers) {
                    value = r + config.rowHeaderStartDisplayedIndex; // row number is 1-based
                }
            } else if (isHeaderRow) {
                // row handle for header row: gets "master" checkbox
                config.allRowsSelected = selectionModel.areAllRowsSelected();
            }
        }

        config.isSelected = isSelected;
        config.isDataColumn = !isRowHandleOrHierarchyColumn;
        config.isHandleColumn = isHandleColumn;
        config.isTreeColumn = isTreeColumn;
        config.isDataRow = isDataRow;
        config.isHeaderRow = isHeaderRow;
        config.isFilterRow = isFilterRow;
        config.isUserDataArea = isUserDataArea;
        config.isColumnHovered = cellEvent.isColumnHovered;
        config.isRowHovered = cellEvent.isRowHovered;
        config.isCellHovered = cellEvent.isCellHovered;
        config.bounds = cellEvent.bounds;
        config.isCellSelected = isCellSelected;
        config.isRowSelected = isRowSelected;
        config.isColumnSelected = isColumnSelected;
        config.isInCurrentSelectionRectangle = selectionModel.isInCurrentSelectionRectangle(x, r);
        config.isFirstSelectedCell = !isHeaderRow && selectionModel.isFirstSelectedCell(x, r);
        config.prefillColor = prefillColor;
        config.buttonCells = this.buttonCells; // allow the renderer to identify itself if it's a button
        config.subrow = 0;
        config.halign = isHeaderRow ? config.rowHeaderHalign : behavior.getCellProperty('halign') || config.halign;
        config.ignoreValuePrefix = properties.ignoreValuePrefix;
        config.highlightedChars = cellEvent.highlightedChars;

        config.isAggregationTreeColumn = cellEvent.isAggregationTreeColumn;
        if (config.isAggregationTreeColumn) {
            config.aggregationChildCount = cellEvent.aggregationChildCount;
            if (config.aggregationChildCount && !config.headerRow) {
                config.valuePostfix = '(' + config.aggregationChildCount + ')';
            }
        }

        config.isAggregationColumn = cellEvent.isAggregationColumn;
        if (config.isAggregationColumn) {
            config.hasChildRows = cellEvent.hasChildRows;
            config.isAggregationRow = cellEvent.isAggregationRow;
            config.isRowExpanded = cellEvent.isRowExpanded;
            config.treeLevel = cellEvent.treeLevel;

            config.isGrandTotalRow = cellEvent.isGrandTotalRow;
            if (config.isGrandTotalRow) {
                config.backgroundTextFont = this.properties.grandAggregationCellFont;
                config.foregroundSelectionFont = this.properties.grandAggregationCellFont;
                config.font = this.properties.grandAggregationCellFont;
            }

            config.isExpandableRow = cellEvent.isExpandableRow;
            if (config.isExpandableRow && value) {
                config.valuePrefix = config.isRowExpanded ? this.properties.aggregationGroupExpandIconCollapsedChar : this.properties.aggregationGroupExpandIconExpandedChar;
                config.valuePrefixFont = this.properties.aggregationGroupExpandIconFont;
                config.valuePrefixColor = this.properties.aggregationGroupExpandIconColor;
                config.prefixIgnoreUnderliningNeeded = true;
            }
        }

        if (cellEvent.isExpandableColumn) {
            config.valuePrefix = cellEvent.isColumnExpanded ? this.properties.aggregationGroupExpandIconCollapsedChar : this.properties.aggregationGroupExpandIconExpandedChar;
            config.valuePrefixFont = this.properties.aggregationGroupExpandIconFont;
            config.valuePrefixColor = this.properties.aggregationGroupExpandIconColor;
            config.prefixIgnoreUnderliningNeeded = true;
        }

        if (!config.valuePrefix && config.headerRow) {
            if (cellEvent.column.hasError) {
                config.valuePrefix = this.properties.errorIconUnicodeChar;
                config.valuePrefixFont = this.properties.errorIconFont;
                config.valuePrefixColor = this.properties.errorIconColor;
            } else {
                config.valuePrefix = cellEvent.column.schema ? cellEvent.column.schema.headerPrefix : undefined;
                config.valuePrefixFont = this.properties.columnTitlePrefixFont;
                config.valuePrefixColor = this.properties.columnTitlePrefixColor;
            }
        }

        if (!config.colTypeSign) {
            config.colTypeSign = cellEvent.column.schema ? cellEvent.column.schema.colTypeSign : undefined;
        }

        if (grid.mouseDownState) {
            config.mouseDown = grid.mouseDownState.gridCell.equals(cellEvent.gridCell);
        }

        // subrow logic - coded for efficiency when no subrows (!value.subrows)
        var isArray = isUserDataArea && value && value.constructor === Array,
            // fastest array determination
        subrows = isArray && value.subrows && value.length;

        if (subrows) {
            var bounds = config.bounds = Object.assign({}, config.bounds);
            bounds.height /= subrows;
            config.subrows = subrows;
            config.value = config.exec(value[0]);
        } else {
            subrows = 1;
            config.value = !isArray && isUserDataArea ? config.exec(value) : value;
        }

        if (config.isDataRow && !config.link && config.value && config.detectLinksPermanently && cellEvent.isValueUrl) {
            config.link = config.value;
        }

        while (true) {
            // eslint-disable-line
            // This call's dataModel.getCell which developer can override to:
            // * mutate the (writable) properties of `config` (including config.value)
            // * mutate cell renderer choice (instance of which is returned)
            var cellRenderer = cellEvent.subgrid.getCell(config, config.renderer);

            behavior.cellPropertiesPrePaintNotification(config);

            config.formatValue = grid.getFormatter(format);

            // Following supports partial render
            config.snapshot = cellEvent.snapshot;
            config.minWidth = cellEvent.minWidth; // in case `paint` aborts before setting `minWidth`

            // Render the cell
            cellRenderer.paint(gc, config);

            // Following supports partial render:
            cellEvent.snapshot[config.subrow] = config.snapshot;
            if (cellEvent.minWidth === undefined || config.minWidth > cellEvent.minWidth) {
                cellEvent.minWidth = config.minWidth;
            }

            if (++config.subrow === subrows) {
                break;
            }

            bounds.y += bounds.height;
            config.value = config.exec(value[config.subrow]);
        }

        return config.minWidth;
    },

    /**
     * Overridable for alternative or faster logic.
     * @param CellEvent
     * @returns {object} Layered config object.
     */
    assignProps: layerProps,

    /**
     * @param {number|CellEvent} colIndexOrCellEvent - This is the "data" x coordinate.
     * @param {number} [rowIndex] - This is the "data" y coordinate. Omit if `colIndexOrCellEvent` is a `CellEvent`.
     * @param {dataModelAPI} [dataModel=this.grid.behavior.dataModel] Omit if `colIndexOrCellEvent` is a `CellEvent`.
     * @returns {CellEvent} The matching `CellEvent` object from the renderer's pool. Returns `undefined` if the requested cell is not currently visible (due to being scrolled out of view).
     */
    findCell: function findCell(colIndexOrCellEvent, rowIndex, dataModel) {
        var colIndex,
            cellEvent,
            pool = this.cellEventPool;

        if ((typeof colIndexOrCellEvent === 'undefined' ? 'undefined' : _typeof(colIndexOrCellEvent)) === 'object') {
            // colIndexOrCellEvent is a cell event object
            dataModel = rowIndex;
            rowIndex = colIndexOrCellEvent.visibleRow.rowIndex;
            colIndex = colIndexOrCellEvent.column.index;
        } else {
            colIndex = colIndexOrCellEvent;
        }

        dataModel = dataModel || this.grid.behavior.dataModel;

        for (var p = 0, len = this.visibleColumns.length * this.visibleRows.length; p < len; ++p) {
            cellEvent = pool[p];
            if (cellEvent.subgrid === dataModel && cellEvent.column.index === colIndex && cellEvent.visibleRow.rowIndex === rowIndex) {
                return cellEvent;
            }
        }
    },

    /**
     * Resets the cell properties cache in the matching `CellEvent` object from the renderer's pool. This will insure that a new cell properties object will be known to the renderer. (Normally, the cache is not reset until the pool is updated by the next call to {@link Renderer#computeCellBounds}).
     * @param {number|CellEvent} xOrCellEvent
     * @param {number} [y]
     * @param {dataModelAPI} [dataModel=this.grid.behavior.dataModel]
     * @returns {CellEvent} The matching `CellEvent` object.
     */
    resetCellPropertiesCache: function resetCellPropertiesCache(xOrCellEvent, y, dataModel) {
        var cellEvent = this.findCell.apply(this, arguments);
        if (cellEvent) {
            cellEvent._cellOwnProperties = undefined;
        }
        return cellEvent;
    },

    resetAllCellPropertiesCaches: function resetAllCellPropertiesCaches() {
        this.cellEventPool.forEach(function (cellEvent) {
            cellEvent._cellOwnProperties = undefined;
        });
    },

    isViewableButton: function isViewableButton(c, r) {
        // Cell with 'button' renderer clicked returns an array; other cells return `undefined`.
        // The array contains bounding rect per subrow with a button. When no subrows array length is 1.
        return this.buttonCells[c + ',' + r];
    },

    getBounds: function getBounds() {
        return this.bounds;
    },

    setBounds: function setBounds(bounds) {
        return this.bounds = bounds;
    },

    setInfo: function setInfo(message) {
        var width;
        if (this.visibleColumns.length) {
            width = this.visibleColumns[this.visibleColumns.length - 1].right;
        }
        this.grid.canvas.setInfo(message, width);
    }
});

/**
 * This function creates several data structures:
 * * {@link Renderer#visibleColumns}
 * * {@link Renderer#visibleRows}
 *
 * Original comment:
 * "this function computes the grid coordinates used for extremely fast iteration over
 * painting the grid cells. this function is very fast, for thousand rows X 100 columns
 * on a modest machine taking usually 0ms and no more that 3 ms."
 *
 * @this {Renderer}
 */
function computeCellsBounds() {
    //var startTime = Date.now();

    var scrollTop = this.getScrollTop(),
        scrollLeft = this.getScrollLeft(),
        fixedColumnCount = this.grid.getFixedColumnCount(),
        fixedRowCount = this.grid.getFixedRowCount(),
        bounds = this.getBounds(),
        grid = this.grid,
        behavior = grid.behavior,
        noTreeColumn = !behavior.hasTreeColumn(),
        editorCellEvent = grid.cellEditor && grid.cellEditor.event,
        vcEd,
        xEd,
        vrEd,
        yEd,
        sgEd,
        isSubgridEd,
        insertionBoundsCursor = 0,
        previousInsertionBoundsCursorValue = 0,
        gridProps = grid.properties,
        lineWidthV = gridProps.gridLinesWidth,
        lineWidthH = gridProps.gridLinesWidth,
        fixedWidthV = gridProps.fixedLinesVWidth || gridProps.gridLinesWidth,
        fixedWidthH = gridProps.fixedLinesHWidth || gridProps.gridLinesWidth,
        hasFixedColumnGap = fixedWidthV && fixedColumnCount,
        hasFixedRowGap = fixedWidthH && fixedRowCount,
        start = 0,
        numOfInternalCols = 0,
        x,
        X,
        // horizontal pixel loop index and limit
    y,
        Y,
        // vertical pixel loop index and limit
    columnIndex,
        columnCount,
        // column loop index and limit
    currentSubgridIndex,
        subgridsSize,
        // subgrid loop index and limit
    r,
        R,
        // row loop index and limit
    subrows,
        // rows in subgrid g
    base,
        // sum of rows for all subgrids so far
    subgrids = behavior.subgrids,
        subgrid,
        rowIndex,
        scrollableSubgrid,
        footerHeight,
        vx,
        vy,
        visibleRow,
        vc,
        width,
        height,
        firstVX,
        lastVX,
        firstVY,
        lastVY,
        topR,
        gap,
        left,
        widthSpaced,
        heightSpaced; // adjusted for cell spacing

    if (editorCellEvent) {
        xEd = editorCellEvent.gridCell.x;
        yEd = editorCellEvent.dataCell.y;
        sgEd = editorCellEvent.subgrid;
    }

    if (noTreeColumn) {
        this.visibleColumns[behavior.treeColumnIndex] = undefined;
    } else {
        start = Math.min(start, behavior.treeColumnIndex);
        numOfInternalCols += 1;
    }

    if (gridProps.showRowNumbers) {
        start = Math.min(start, behavior.rowColumnIndex);
        numOfInternalCols += 1;
    }

    this.scrollHeight = 0;

    this.visibleColumns.length = 0;
    this.visibleColumns.gap = undefined;

    this.visibleRows.length = 0;
    this.visibleRows.gap = undefined;

    this.visibleColumnsByIndex = []; // array because number of columns will always be reasonable
    this.visibleRowsByDataRowIndex = {}; // hash because keyed by (fixed and) scrolled row indexes

    this.insertionBounds = [];

    var totalSpace = grid.renderer.bounds.width;
    var totalWidth = behavior.getColumnsWidth();
    var scrolledWidth = behavior.getColumnsWidth(scrollLeft);
    var visibleSpace = totalWidth - scrolledWidth + behavior.getColumnWidth(behavior.rowColumnIndex);
    var freeSpace = totalSpace - visibleSpace;
    var lastShift = 0;

    while (freeSpace > 0 && scrollLeft > 0) {
        scrollLeft--;
        var widthForSub = this.grid.getColumnWidth(scrollLeft);
        lastShift = widthForSub - freeSpace;
        freeSpace -= widthForSub;
    }

    lastShift = Math.round(lastShift);

    for (x = 0, columnIndex = start, columnCount = grid.getColumnCount(), X = (bounds.width || grid.canvas.width) + lastShift; columnIndex < columnCount && x <= X; columnIndex++) {
        if (noTreeColumn && columnIndex === behavior.treeColumnIndex) {
            continue;
        }

        vx = columnIndex;
        if (columnIndex >= fixedColumnCount) {
            lastVX = vx += scrollLeft;
            if (firstVX === undefined) {
                firstVX = lastVX;
            }
        }
        if (vx >= columnCount) {
            break; // scrolled beyond last column
        }

        width = Math.ceil(behavior.getColumnWidth(vx));

        if (x) {
            if (gap = hasFixedColumnGap && columnIndex === fixedColumnCount) {
                x += fixedWidthV - lineWidthV;
                this.visibleColumns.gap = {
                    left: vc.right,
                    right: undefined
                };
            }
            left = x + lineWidthV;
            widthSpaced = width - lineWidthV;
        } else {
            left = x;
            widthSpaced = width;
        }

        var column = behavior.getActiveColumn(vx);

        if (!column) {
            continue;
        }

        // if (column.index === undefined) {
        //     column.index = c;
        // }

        // todo probably need to be fixed with fixedColumnCount > 0
        // resize first column
        if (columnIndex === fixedColumnCount && lastShift) {
            widthSpaced -= lastShift;
            width -= lastShift;
        }

        this.visibleColumns[columnIndex] = this.visibleColumnsByIndex[vx] = vc = {
            index: columnIndex,
            columnIndex: vx,
            column: column,
            gap: gap,
            left: left,
            width: widthSpaced,
            right: left + widthSpaced
        };

        if (gap) {
            this.visibleColumns.gap.right = vc.left;
        }

        if (xEd === vx) {
            vcEd = vc;
        }

        x += width;

        insertionBoundsCursor += Math.round(width / 2) + previousInsertionBoundsCursorValue;
        this.insertionBounds.push(insertionBoundsCursor);
        previousInsertionBoundsCursorValue = Math.round(width / 2);
    }

    // get height of total number of rows in all subgrids following the data subgrid
    footerHeight = gridProps.defaultRowHeight * behavior.getFooterRowCount();

    for (base = r = currentSubgridIndex = y = 0, subgridsSize = subgrids.length, Y = bounds.height - footerHeight; currentSubgridIndex < subgridsSize; currentSubgridIndex++, base += subrows) {
        subgrid = subgrids[currentSubgridIndex];
        subrows = subgrid.getRowCount();
        scrollableSubgrid = subgrid.isData;
        isSubgridEd = sgEd === subgrid;
        topR = r;

        // For each row of each subgrid...
        var minVisibleRow = 0;
        for (R = r + subrows; r < R && y < Y; r++) {
            vy = r;

            if (minVisibleRow > vy && vy !== 0) {
                minVisibleRow = vy;
            }

            if (scrollableSubgrid) {
                if (gap = hasFixedRowGap && r === fixedRowCount && r !== 1) {
                    y += fixedWidthH - lineWidthH;
                    this.visibleRows.gap = {
                        top: visibleRow.bottom,
                        bottom: undefined
                    };
                }
                if (r >= fixedRowCount) {
                    vy += scrollTop;
                    lastVY = vy - base;
                    if (firstVY === undefined) {
                        firstVY = lastVY;
                    }
                    if (vy >= R) {
                        break; // scrolled beyond last row
                    }
                }
            }

            rowIndex = vy - base;
            height = behavior.getRowHeight(rowIndex, subgrid);

            heightSpaced = height - lineWidthH;
            this.visibleRows[r] = visibleRow = {
                index: r,
                subgrid: subgrid,
                gap: gap,
                rowIndex: rowIndex,
                top: y,
                height: heightSpaced,
                bottom: y + heightSpaced
            };

            if (gap) {
                this.visibleRows.gap.bottom = visibleRow.top;
            }

            if (scrollableSubgrid) {
                this.visibleRowsByDataRowIndex[vy - base] = visibleRow;
            }

            if (isSubgridEd && yEd === rowIndex) {
                vrEd = visibleRow;
            }

            y += height;
        }

        if (scrollableSubgrid) {
            subrows = r - topR;
            Y += footerHeight;
        }

        if (y < Y) {
            this.bottomFreeSpace = Y - y;
            if (this.bottomFreeSpace <= gridProps.defaultRowHeight) {
                var headerRowsCount = behavior.getHeaderRowCount();
                var previousFirstRow = this.visibleRows[headerRowsCount] || this.visibleRows[headerRowsCount - 1];

                this.skippedTopSpace = gridProps.defaultRowHeight - this.bottomFreeSpace + lineWidthH;
                var top = previousFirstRow.top - this.skippedTopSpace;
                var halfSizedRow = {
                    index: headerRowsCount,
                    subgrid: previousFirstRow.subgrid,
                    gap: false,
                    rowIndex: previousFirstRow.rowIndex - 1,
                    top: top,
                    height: gridProps.defaultRowHeight + lineWidthH,
                    bottom: top + gridProps.defaultRowHeight + lineWidthH,
                    skippedTopSpace: this.skippedTopSpace
                };

                for (var i = headerRowsCount; i < this.visibleRows.length; i++) {
                    this.visibleRows[i].top += this.bottomFreeSpace + lineWidthH;
                    this.visibleRows[i].index += 1;
                    this.visibleRows[i].bottom += this.bottomFreeSpace + lineWidthH;
                }
                this.visibleRows.splice(headerRowsCount, 0, halfSizedRow);

                if (scrollableSubgrid) {
                    this.visibleRowsByDataRowIndex[halfSizedRow.rowIndex] = halfSizedRow;
                }

                // this.visibleRows.unshift(halfSizedRow);
                this.renderedCuttedRowsCount = 1;
            } else {
                this.renderedCuttedRowsCount = 0;
                this.skippedTopSpace = 0;
            }
        } else {
            this.renderedCuttedRowsCount = 0;
            this.skippedTopSpace = 0;
        }
    }

    if (editorCellEvent) {
        editorCellEvent.visibleColumn = vcEd;
        editorCellEvent.visibleRow = vrEd;
        editorCellEvent.gridCell.y = vrEd && vrEd.index;
        editorCellEvent._bounds = null;
    }

    this.viewHeight = Y;

    this.dataWindow = this.grid.newRectangle(firstVX, firstVY, lastVX - firstVX, lastVY - firstVY);

    // Resize CellEvent pool
    var pool = this.cellEventPool,
        previousLength = pool.length,
        P = (this.visibleColumns.length + numOfInternalCols) * this.visibleRows.length;

    if (P > previousLength) {
        pool.length = P; // grow pool to accommodate more cells
    }
    for (var p = previousLength; p < P; p++) {
        pool[p] = new behavior.CellEvent(); // instantiate new members
    }

    this.resetAllGridRenderers();
}

/**
 * @summary Resize the handle column.
 * @desc Handle column width is sum of:
 * * Width of text the maximum row number, if visible, based on handle column's current font
 * * Width of checkbox, if visible
 * * Some padding
 *
 * @this {Renderer}
 * @param gc
 * @param rowCount
 */
function resetRowHeaderColumnWidth(gc, rowCount) {
    var columnProperties = this.grid.behavior.getColumnProperties(this.grid.behavior.rowColumnIndex),
        gridProps = this.grid.properties,

    // width = 2 * columnProperties.cellPadding;
    width = columnProperties.cellPaddingLeft + columnProperties.cellPaddingRight;

    // Checking images.checked also supports a legacy feature in which checkbox could be hidden by undefining the image.
    if (gridProps.rowHeaderCheckboxes && images.checked) {
        width += images.checked.width;
    }

    if (gridProps.rowHeaderNumbers) {
        var cellProperties = columnProperties.rowHeader;
        gc.cache.font = cellProperties.foregroundSelectionFont.indexOf('bold ') >= 0 ? cellProperties.foregroundSelectionFont : cellProperties.font;

        width += gc.getTextWidth(rowCount);
        width = width < cellProperties.minWidth ? cellProperties.minWidth : width;
    }

    columnProperties.preferredWidth = columnProperties.width = width;
}

function registerGridRenderer(paintCellsFunction) {
    if (paintCellsFunctions.indexOf(paintCellsFunction) < 0) {
        paintCellsFunctions.push(paintCellsFunction);
    }
}

registerGridRenderer(require('./by-cells'));
registerGridRenderer(require('./by-columns'));
registerGridRenderer(require('./by-columns-discrete'));
registerGridRenderer(require('./by-columns-and-rows'));
registerGridRenderer(require('./by-columns-and-rows-headers'));
registerGridRenderer(require('./by-rows'));

Renderer.registerGridRenderer = registerGridRenderer;

module.exports = Renderer;

},{"../../images":3,"../Base":17,"./by-cells":103,"./by-columns":107,"./by-columns-and-rows":105,"./by-columns-and-rows-headers":104,"./by-columns-discrete":106,"./by-rows":108,"./layer-props":110}],110:[function(require,module,exports){
'use strict';

var defaults = require('../defaults');

var COLUMNS = defaults.propClassEnum.COLUMNS,
    CELLS = defaults.propClassEnum.CELLS,
    propClassGet = [];

propClassGet[COLUMNS] = function (cellEvent) {
    return cellEvent.columnProperties;
};
propClassGet[CELLS] = function (cellEvent) {
    return cellEvent.cellOwnProperties;
};
propClassGet[defaults.propClassEnum.STRIPES] = function (cellEvent) {
    var rowStripes = cellEvent.isDataRow && cellEvent.columnProperties.rowStripes;
    return rowStripes && rowStripes[cellEvent.dataCell.y % rowStripes.length];
};
propClassGet[defaults.propClassEnum.ROWS] = function (cellEvent) {
    return cellEvent.rowOwnProperties;
};

function assignProps(cellEvent) {
    var i,
        base,
        assignments,
        props = cellEvent.properties,
        propLayers = props.propClassLayers;

    switch (propLayers[0]) {
        case COLUMNS:
            i = 1; // skip column prop layer
            base = cellEvent.columnProperties; // because column has grid props as prototype
            break;
        case CELLS:
            i = 1; // skip cell prop layer
            base = props; // because cell has column props as prototype
            break;
        default:
            i = 0; // all prop layers
            base = this.grid.properties;
    }

    for (assignments = [Object.create(base)]; i < propLayers.length; ++i) {
        assignments.push(propClassGet[propLayers[i]](cellEvent));
    }

    return Object.assign.apply(Object, assignments);
}

module.exports = assignProps;

},{"../defaults":65}]},{},[85])(85)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjc3MvaW5kZXguanMiLCJpbWFnZXMvaW1hZ2VzLmpzIiwiaW1hZ2VzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2F1dG9tYXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3NzLWluamVjdG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9saWIvaXNfYXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2tleXMuanMiLCJub2RlX21vZHVsZXMvZXh0ZW5kLW1lL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luamVjdC1zdHlsZXNoZWV0LXRlbXBsYXRlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL211c3RhY2hlL211c3RhY2hlLmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC1pdGVyYXRvcnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb3ZlcnJpZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlY3Rhbmd1bGFyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NwYXJzZS1ib29sZWFuLWFycmF5L2luZGV4LmpzIiwicGFja2FnZS5qc29uIiwic3JjL0Jhc2UuanMiLCJzcmMvRGF0YXNhdXJCYXNlL2luZGV4LmpzIiwic3JjL0RhdGFzYXVyTG9jYWwvaW5kZXguanMiLCJzcmMvRmluYmFycy9ldmVudHMuanMiLCJzcmMvRmluYmFycy9pbmRleC5qcyIsInNyYy9GaW5iYXJzL29yaWVudGF0aW9uSGFzaGVzLmpzIiwic3JjL0h5cGVyZ3JpZC9hcGkuanMiLCJzcmMvSHlwZXJncmlkL2NvbHVtbkFwaS5qcyIsInNyYy9IeXBlcmdyaWQvZGF0YU1vZGVsL2V2ZW50cy5qcyIsInNyYy9IeXBlcmdyaWQvZGF0YU1vZGVsL3NjaGVtYS5qcyIsInNyYy9IeXBlcmdyaWQvZXZlbnRzLmpzIiwic3JjL0h5cGVyZ3JpZC9pbmRleC5qcyIsInNyYy9IeXBlcmdyaWQvbW9kdWxlcy5qcyIsInNyYy9IeXBlcmdyaWQvc2Nyb2xsaW5nLmpzIiwic3JjL0h5cGVyZ3JpZC9zZWxlY3Rpb24uanMiLCJzcmMvSHlwZXJncmlkL3RoZW1lcy5qcyIsInNyYy9iZWhhdmlvcnMvQmVoYXZpb3IuanMiLCJzcmMvYmVoYXZpb3JzL0NvbHVtbi5qcyIsInNyYy9iZWhhdmlvcnMvTG9jYWwuanMiLCJzcmMvYmVoYXZpb3JzL2NlbGxQcm9wZXJ0aWVzLmpzIiwic3JjL2JlaGF2aW9ycy9jb2x1bW5FbnVtLmpzIiwic3JjL2JlaGF2aW9ycy9jb2x1bW5Qcm9wZXJ0aWVzLmpzIiwic3JjL2JlaGF2aW9ycy9kYXRhTW9kZWwvZGVjb3JhdG9ycy5qcyIsInNyYy9iZWhhdmlvcnMvZGF0YU1vZGVsL2ZhbGxiYWNrcy5qcyIsInNyYy9iZWhhdmlvcnMvZGF0YU1vZGVsL2luZGV4LmpzIiwic3JjL2JlaGF2aW9ycy9pbmRleC5qcyIsInNyYy9iZWhhdmlvcnMvcm93UHJvcGVydGllcy5qcyIsInNyYy9iZWhhdmlvcnMvc3ViZ3JpZHMuanMiLCJzcmMvY2VsbEVkaXRvcnMvQ2VsbEVkaXRvci5qcyIsInNyYy9jZWxsRWRpdG9ycy9Db2xvci5qcyIsInNyYy9jZWxsRWRpdG9ycy9EYXRlLmpzIiwic3JjL2NlbGxFZGl0b3JzL051bWJlci5qcyIsInNyYy9jZWxsRWRpdG9ycy9TbGlkZXIuanMiLCJzcmMvY2VsbEVkaXRvcnMvU3Bpbm5lci5qcyIsInNyYy9jZWxsRWRpdG9ycy9UZXh0ZmllbGQuanMiLCJzcmMvY2VsbEVkaXRvcnMvaW5kZXguanMiLCJzcmMvY2VsbFJlbmRlcmVycy9CdXR0b24uanMiLCJzcmMvY2VsbFJlbmRlcmVycy9DZWxsUmVuZGVyZXIuanMiLCJzcmMvY2VsbFJlbmRlcmVycy9FcnJvckNlbGwuanMiLCJzcmMvY2VsbFJlbmRlcmVycy9MYXN0U2VsZWN0aW9uLmpzIiwic3JjL2NlbGxSZW5kZXJlcnMvU2ltcGxlQ2VsbC5qcyIsInNyYy9jZWxsUmVuZGVyZXJzL1NsaWRlckNlbGwuanMiLCJzcmMvY2VsbFJlbmRlcmVycy9TcGFya0Jhci5qcyIsInNyYy9jZWxsUmVuZGVyZXJzL1NwYXJrTGluZS5qcyIsInNyYy9jZWxsUmVuZGVyZXJzL1RyZWVDZWxsLmpzIiwic3JjL2NlbGxSZW5kZXJlcnMvaW5kZXguanMiLCJzcmMvZGF0YU1vZGVscy9IZWFkZXJTdWJncmlkLmpzIiwic3JjL2RhdGFNb2RlbHMvaW5kZXguanMiLCJzcmMvZGVmYXVsdHMuanMiLCJzcmMvZmVhdHVyZXMvQ2VsbENsaWNrLmpzIiwic3JjL2ZlYXR1cmVzL0NlbGxFZGl0aW5nLmpzIiwic3JjL2ZlYXR1cmVzL0NlbGxTZWxlY3Rpb24uanMiLCJzcmMvZmVhdHVyZXMvQ29sdW1uRml4YXRpb24uanMiLCJzcmMvZmVhdHVyZXMvQ29sdW1uTW92aW5nLmpzIiwic3JjL2ZlYXR1cmVzL0NvbHVtblJlc2l6aW5nLmpzIiwic3JjL2ZlYXR1cmVzL0NvbHVtblNlbGVjdGlvbi5qcyIsInNyYy9mZWF0dXJlcy9Db2x1bW5Tb3J0aW5nLmpzIiwic3JjL2ZlYXR1cmVzL0NvbnRleHRNZW51LmpzIiwic3JjL2ZlYXR1cmVzL0ZlYXR1cmUuanMiLCJzcmMvZmVhdHVyZXMvRmlsdGVycy5qcyIsInNyYy9mZWF0dXJlcy9LZXlQYWdpbmcuanMiLCJzcmMvZmVhdHVyZXMvTGlua0RldGFpbHMuanMiLCJzcmMvZmVhdHVyZXMvT25Ib3Zlci5qcyIsInNyYy9mZWF0dXJlcy9Sb3dGaXhhdGlvbi5qcyIsInNyYy9mZWF0dXJlcy9Sb3dTZWxlY3Rpb24uanMiLCJzcmMvZmVhdHVyZXMvVGh1bWJ3aGVlbFNjcm9sbGluZy5qcyIsInNyYy9mZWF0dXJlcy9XYXJuaW5nVG9vbHRpcC5qcyIsInNyYy9mZWF0dXJlcy9pbmRleC5qcyIsInNyYy9mb3JCdWlsZC9pbmRleC5qcyIsInNyYy9mb3JCdWlsZC9tb2R1bGUtbG9hZGVyLmpzIiwic3JjL2xpYi9DYW52YXMuanMiLCJzcmMvbGliL0RPTS9lZmZlY3RzLmpzIiwic3JjL2xpYi9Mb2NhbGl6YXRpb24uanMiLCJzcmMvbGliL1JlZ2lzdHJ5LmpzIiwic3JjL2xpYi9TZWxlY3Rpb25Nb2RlbC5qcyIsInNyYy9saWIvY2VsbEV2ZW50RmFjdG9yeS5qcyIsInNyYy9saWIvZGVwcmVjYXRlZC5qcyIsInNyYy9saWIvZHluYW1pY1Byb3BlcnRpZXMuanMiLCJzcmMvbGliL2Vycm9yLmpzIiwic3JjL2xpYi9ncmFwaGljcy5qcyIsInNyYy9saWIvaGVhZGVyaWZpZXJzLmpzIiwic3JjL2xpYi9pbmRleC5qcyIsInNyYy9saWIvcG9seWZpbGxzLmpzIiwic3JjL2xpYi90b0Z1bmN0aW9uLmpzIiwic3JjL3JlbmRlcmVyL2J1bmRsZS1jb2x1bW5zLmpzIiwic3JjL3JlbmRlcmVyL2J1bmRsZS1yb3dzLmpzIiwic3JjL3JlbmRlcmVyL2J5LWNlbGxzLmpzIiwic3JjL3JlbmRlcmVyL2J5LWNvbHVtbnMtYW5kLXJvd3MtaGVhZGVycy5qcyIsInNyYy9yZW5kZXJlci9ieS1jb2x1bW5zLWFuZC1yb3dzLmpzIiwic3JjL3JlbmRlcmVyL2J5LWNvbHVtbnMtZGlzY3JldGUuanMiLCJzcmMvcmVuZGVyZXIvYnktY29sdW1ucy5qcyIsInNyYy9yZW5kZXJlci9ieS1yb3dzLmpzIiwic3JjL3JlbmRlcmVyL2luZGV4LmpzIiwic3JjL3JlbmRlcmVyL2xheWVyLXByb3BzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7O0FBRUEsUUFBUSxJQUFSLEdBQWUsQ0FDZix3QkFEZSxFQUVmLHNCQUZlLEVBR2YsaUJBSGUsRUFJZixHQUplLEVBS2YsMENBTGUsRUFNZixzQkFOZSxFQU9mLFdBUGUsRUFRZixVQVJlLEVBU2YsWUFUZSxFQVVmLGFBVmUsRUFXZixHQVhlLEVBWWYscURBWmUsRUFhZixzQkFiZSxFQWNmLHdDQWRlLEVBZWYsa0RBZmUsRUFnQmYsZUFoQmUsRUFpQmYsNkJBakJlLEVBa0JmLG1CQWxCZSxFQW1CZixx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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0bkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7Ozs7QUFRQSxJQUFJLE9BQU8sUUFBUSxXQUFSLEVBQXFCLElBQWhDOztBQUVBLE9BQU8sY0FBUCxDQUFzQixLQUFLLFNBQTNCLEVBQXNDLFNBQXRDLEVBQWlEO0FBQzdDLGdCQUFZLElBRGlDO0FBRTdDLGNBQVUsS0FGbUMsRUFFNUI7QUFDakIsa0JBQWMsS0FIK0I7QUFJN0MsV0FBTyxRQUFRLGlCQUFSLEVBQTJCO0FBSlcsQ0FBakQ7O0FBT0EsS0FBSyxTQUFMLENBQWUsVUFBZixHQUE0QixRQUFRLGtCQUFSLENBQTVCO0FBQ0EsS0FBSyxTQUFMLENBQWUsY0FBZixHQUFnQyxRQUFRLGFBQVIsQ0FBaEM7O0FBRUEsS0FBSyxTQUFMLENBQWUsTUFBZixHQUF3QixVQUFTLE9BQVQsRUFBa0IsT0FBbEIsRUFBMkI7QUFDL0MsWUFBUSxPQUFSO0FBQ0ksYUFBSyxNQUFMO0FBQWEsb0JBQVEsSUFBUixDQUFhLE9BQWIsRUFBdUI7QUFDcEMsYUFBSyxPQUFMO0FBQWMsa0JBQU0sT0FBTixFQUFnQixNQUZsQyxDQUV5QztBQUNyQztBQUFTLGtCQUFNLElBQUksS0FBSyxjQUFULENBQXdCLE9BQXhCLENBQU47QUFIYjtBQUtILENBTkQ7O0FBUUE7Ozs7O0FBS0EsS0FBSyxTQUFMLENBQWUsTUFBZixHQUF3QixVQUFTLEtBQVQsRUFBZ0I7QUFDcEMsUUFBSSxRQUFRLEtBQVIseUNBQVEsS0FBUixHQUFlLENBQWYsTUFBc0IsR0FBMUIsRUFBK0I7QUFDM0IsZ0JBQVEsT0FBUjtBQUNIO0FBQ0QsV0FBTyxLQUFQO0FBQ0gsQ0FMRDs7QUFPQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsS0FBSyxTQUFMLENBQWUsS0FBZixHQUF1QixRQUFRLFdBQVIsRUFBcUIsS0FBNUM7O0FBR0E7Ozs7Ozs7OztBQVNBLEtBQUssU0FBTCxDQUFlLFdBQWYsR0FBNkIsVUFBUyxXQUFULEVBQXNCLGdCQUF0QixFQUF3QyxZQUF4QyxFQUFzRDtBQUMvRSxRQUFJLG1CQUFtQixNQUFNLFNBQU4sQ0FBZ0IsS0FBaEIsQ0FBc0IsSUFBdEIsQ0FBMkIsU0FBM0IsRUFBc0MsQ0FBdEMsQ0FBdkI7QUFBQSxRQUNJLE9BQU8sQ0FBQyxJQUFELEVBQU87QUFBUCxLQUNGLE1BREUsQ0FDSyxnQkFETCxFQUN1QjtBQUR2QixLQUVGLE1BRkUsQ0FFSyxnQkFGTCxDQURYO0FBQUEsUUFHbUM7QUFDL0IsdUJBQW1CLFlBQVksSUFBWixDQUFpQixLQUFqQixDQUF1QixXQUF2QixFQUFvQyxJQUFwQyxDQUp2Qjs7QUFNQSxXQUFPLElBQUksZ0JBQUosRUFBUDtBQUNILENBUkQ7O0FBV0EsT0FBTyxPQUFQLEdBQWlCLElBQWpCOzs7QUNsRkE7O0FBRUEsU0FBUyxjQUFULEdBQTBCLENBQUU7O0FBRTVCLGVBQWUsTUFBZixHQUF3QixRQUFRLFdBQVIsQ0FBeEIsQyxDQUE4Qzs7QUFFOUMsZUFBZSxTQUFmLEdBQTJCO0FBQ3ZCLGlCQUFhLGVBQWUsU0FBZixDQUF5QixXQURmOztBQUd2QixrQkFBYyxnQkFIUzs7QUFLdkIsa0JBQWMsSUFMUzs7QUFPdkIsc0JBQWtCO0FBQ2QsY0FBTSxRQURRLEVBQ0U7QUFDaEIsZUFBTyxRQUZPLEVBRUc7QUFDakIsbUJBQVcsRUFIRyxFQUdDO0FBQ2YsY0FBTSxLQUpRLENBSUY7QUFKRSxLQVBLOztBQWN2QixxQkFBaUIsZUFkTTs7QUFnQnZCLGdCQUFZLG9CQUFTLGNBQVQsRUFBeUIsT0FBekIsRUFBa0M7QUFDMUMsWUFBSSxjQUFKLEVBQW9CO0FBQ2hCLGlCQUFLLElBQUwsR0FBWSxjQUFaO0FBQ0g7O0FBRUQsYUFBSyxPQUFMLENBQWEsT0FBTyxjQUFQLENBQXNCLElBQXRCLENBQWI7QUFDSCxLQXRCc0I7O0FBd0J2Qjs7OztBQUlBLFdBQU8sZUFBUyxHQUFULEVBQWM7QUFDakIsWUFBSSxjQUFjLElBQWxCO0FBQUEsWUFBd0IsTUFBeEI7QUFDQSxXQUFHO0FBQ0MsZ0JBQUksWUFBWSxHQUFaLEtBQW9CLFlBQVksR0FBWixNQUFxQixlQUFlLFNBQWYsQ0FBeUIsR0FBekIsQ0FBN0MsRUFBNEU7QUFDeEU7QUFDSDtBQUNELHFCQUFTLFdBQVQ7QUFDQSwwQkFBYyxZQUFZLElBQTFCO0FBQ0gsU0FORCxRQU1TLFdBTlQ7O0FBUUEsZUFBTyxNQUFQO0FBQ0gsS0F2Q3NCOztBQXlDdkI7Ozs7QUFJQSxhQUFTLGlCQUFTLEdBQVQsRUFBYyxRQUFkLEVBQXVCO0FBQzVCLFlBQUksWUFBWSxJQUFoQjtBQUFBLFlBQ0ksT0FBTyxnQkFBZ0IsTUFBTSxPQUFPLElBQTdCLENBRFg7O0FBR0EsYUFBSyxPQUFMLENBQWEsVUFBUyxHQUFULEVBQWM7QUFDdkIsZ0JBQUksUUFBSixFQUFhO0FBQ1Qsb0JBQUksU0FBUyxVQUFVLEtBQVYsQ0FBZ0IsSUFBaEIsQ0FBcUIsU0FBckIsRUFBZ0MsR0FBaEMsQ0FBYjtBQUNBLG9CQUFJLE1BQUosRUFBWTtBQUNSLDJCQUFPLEdBQVAsSUFBYyxJQUFJLEdBQUosQ0FBZDtBQUNIO0FBQ0o7O0FBRUQsZ0JBQUksQ0FBQyxlQUFlLFNBQWYsQ0FBeUIsR0FBekIsQ0FBTCxFQUFvQztBQUNoQywrQkFBZSxTQUFmLENBQXlCLEdBQXpCLElBQWdDLFlBQVc7QUFDdkMsd0JBQUksS0FBSyxJQUFULEVBQWU7QUFDWCwrQkFBTyxLQUFLLElBQUwsQ0FBVSxHQUFWLEVBQWUsS0FBZixDQUFxQixLQUFLLElBQTFCLEVBQWdDLFNBQWhDLENBQVA7QUFDSDtBQUNKLGlCQUpEO0FBS0g7QUFDSixTQWZEO0FBaUJILEtBbEVzQjs7QUFxRXZCOztBQUVBLFlBQVEsZ0JBQVMsQ0FBVCxFQUFZO0FBQ2hCLGVBQU8sS0FBSyxXQUFMLENBQWlCLENBQWpCLENBQVA7QUFDSCxLQXpFc0I7O0FBMkV2QixrQkFBYyxzQkFBUyxDQUFULEVBQVk7QUFDdEIsZUFBTyxLQUFLLFdBQUwsQ0FBaUIsQ0FBakIsQ0FBUDtBQUNILEtBN0VzQjs7QUFnRnZCOztBQUVBLFVBQU0sY0FBUyxHQUFULEVBQWM7QUFDaEIsY0FBTSxLQUFLLEdBQUwsQ0FBUyxLQUFLLFdBQUwsRUFBVCxFQUE2QixPQUFPLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxLQUFLLFdBQUwsRUFBZCxDQUFwQyxDQUFOO0FBQ0EsWUFBSSxPQUFPLEVBQVg7QUFDQSxZQUFJLFNBQVMsS0FBSyxTQUFMLEVBQWI7QUFDQSxZQUFJLFNBQVMsU0FBUyxPQUFPLEdBQVAsQ0FBVyxVQUFTLEVBQVQsRUFBYTtBQUFFLG1CQUFPLEdBQUcsSUFBVjtBQUFpQixTQUEzQyxDQUFULEdBQXdELEtBQUssVUFBTCxFQUFyRTtBQUNBLFlBQUksU0FBUyxLQUFLLGNBQUwsRUFBYjtBQUNBLFlBQUksaUJBQWlCLEtBQUssY0FBMUI7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksR0FBcEIsRUFBeUIsR0FBekIsRUFBOEI7QUFDMUIsZ0JBQUksTUFBTSxFQUFWO0FBQ0EsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFwQixFQUE0QixHQUE1QixFQUFpQztBQUM3QixvQkFBSSxNQUFNLEtBQUssUUFBTCxDQUFjLENBQWQsRUFBaUIsQ0FBakIsQ0FBVjtBQUNBLG9CQUFJLE1BQU0sQ0FBTixJQUFXLGNBQWYsRUFBK0I7QUFDM0IsMEJBQU0sS0FBSyx3QkFBTCxDQUE4QixHQUE5QixDQUFOO0FBQ0g7QUFDRCxvQkFBSSxPQUFPLENBQVAsQ0FBSixJQUFpQixHQUFqQjtBQUNIO0FBQ0QsaUJBQUssQ0FBTCxJQUFVLEdBQVY7QUFDSDtBQUNELGdCQUFRLEtBQVIsQ0FBYyxJQUFkO0FBQ0g7QUFyR3NCLENBQTNCOztBQXdHQTtBQUNBLFNBQVMsZUFBVCxDQUF5QixHQUF6QixFQUE4QjtBQUMxQixRQUFJLFlBQVksSUFBSSxjQUFKLENBQW1CLFFBQW5CLEtBQWdDLElBQUksUUFBSixDQUFoRDtBQUFBLFFBQ0ksWUFBWSxJQUFJLGNBQUosQ0FBbUIsT0FBbkIsS0FBK0IsSUFBSSxPQUFKLENBRC9DO0FBQUEsUUFFSSxPQUFPLE1BQU0sT0FBTixDQUFjLEdBQWQsSUFBcUIsR0FBckIsR0FBMkIsT0FBTyxJQUFQLENBQVksR0FBWixFQUFpQixNQUFqQixDQUF3QixVQUFTLEdBQVQsRUFBYztBQUNwRSxlQUFPLE9BQU8sSUFBSSxHQUFKLENBQVAsS0FBb0IsVUFBM0I7QUFDSCxLQUZpQyxDQUZ0Qzs7QUFNQSxXQUFPLEtBQUssTUFBTCxDQUFZLFVBQVMsR0FBVCxFQUFjO0FBQzdCLGdCQUFRLEdBQVI7QUFDSSxpQkFBSyxZQUFMO0FBQ0EsaUJBQUssYUFBTDtBQUNBLGlCQUFLLFFBQUw7QUFDQSxpQkFBSyxPQUFMO0FBQ0k7QUFMUjs7QUFRQSxlQUFPLEVBQ0gsYUFBYSxVQUFVLE9BQVYsQ0FBa0IsR0FBbEIsSUFBeUIsQ0FBdEMsSUFDQSxhQUFhLFVBQVUsT0FBVixDQUFrQixHQUFsQixLQUEwQixDQUZwQyxDQUFQO0FBSUgsS0FiTSxDQUFQO0FBY0g7O0FBR0Q7O0FBRUEsU0FBUyxlQUFULENBQXlCLE9BQXpCLEVBQWtDO0FBQzlCLFNBQUssT0FBTCxHQUFlLE9BQWY7QUFDSDs7QUFFRDtBQUNBLGdCQUFnQixTQUFoQixHQUE0QixPQUFPLE1BQVAsQ0FBYyxNQUFNLFNBQXBCLENBQTVCOztBQUVBO0FBQ0EsZ0JBQWdCLFNBQWhCLENBQTBCLElBQTFCLEdBQWlDLGlCQUFqQzs7QUFHQSxPQUFPLE9BQVAsR0FBaUIsY0FBakI7OztBQ3BKQTs7QUFFQTs7Ozs7Ozs7QUFFQSxJQUFJLGlCQUFpQixRQUFRLGlCQUFSLENBQXJCOztBQUVBOzs7Ozs7Ozs7O0FBV0E7Ozs7OztBQU1BLElBQUksa0JBQWtCLGVBQWUsTUFBZixDQUFzQixpQkFBdEIsRUFBeUM7O0FBRTNELGdCQUFZLG9CQUFTLGNBQVQsRUFBeUIsT0FBekIsRUFBa0M7QUFDMUM7Ozs7OztBQU1BLGFBQUssTUFBTCxHQUFjLEVBQWQ7O0FBRUE7Ozs7OztBQU1BLGFBQUssSUFBTCxHQUFZLEVBQVo7QUFDQSxhQUFLLEtBQUwsR0FBYSxFQUFiO0FBQ0gsS0FuQjBEOztBQXFCM0Q7Ozs7Ozs7O0FBUUEsYUFBUyxpQkFBUyxJQUFULEVBQWUsTUFBZixFQUF1QjtBQUM1Qjs7Ozs7O0FBTUEsYUFBSyxJQUFMLEdBQVksUUFBUSxFQUFwQjtBQUNBLGFBQUssUUFBTDs7QUFFQSxZQUFJLE1BQUosRUFBWTtBQUNSLGlCQUFLLFNBQUwsQ0FBZSxNQUFmO0FBQ0gsU0FGRCxNQUVPLElBQUksS0FBSyxJQUFMLENBQVUsTUFBVixJQUFvQixDQUFDLEtBQUssTUFBTCxDQUFZLE1BQXJDLEVBQTZDO0FBQ2hELGlCQUFLLFNBQUwsQ0FBZSxFQUFmO0FBQ0g7QUFDSixLQTVDMEQ7O0FBOEMzRDs7Ozs7Ozs7QUFRQSxhQUFTLGlCQUFTLElBQVQsRUFBZSxNQUFmLEVBQXVCO0FBQzVCLGFBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxLQUFmLENBQXFCLEtBQUssSUFBMUIsRUFBZ0MsUUFBUSxFQUF4QztBQUNBLGFBQUssUUFBTDs7QUFFQSxZQUFJLE1BQUosRUFBWTtBQUNSLGlCQUFLLFNBQUwsQ0FBZSxNQUFmO0FBQ0gsU0FGRCxNQUVPLElBQUksS0FBSyxJQUFMLENBQVUsTUFBVixJQUFvQixDQUFDLEtBQUssTUFBTCxDQUFZLE1BQXJDLEVBQTZDO0FBQ2hELGlCQUFLLFNBQUwsQ0FBZSxFQUFmO0FBQ0g7QUFDSixLQS9EMEQ7O0FBaUUzRDs7OztBQUlBLGVBQVcscUJBQVc7QUFDbEIsZUFBTyxLQUFLLE1BQVo7QUFDSCxLQXZFMEQ7QUF3RTNEOzs7O0FBSUEsZUFBVyxtQkFBUyxTQUFULEVBQW9CO0FBQzNCLFlBQUksQ0FBQyxVQUFVLE1BQWYsRUFBdUI7QUFDbkIsZ0JBQU0sVUFBVSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWU7QUFBQSx1QkFBVyxPQUFYO0FBQUEsYUFBZixDQUFoQjtBQUNBLGdCQUFJLE9BQUosRUFBYTtBQUNULDRCQUFZLE9BQU8sSUFBUCxDQUFZLE9BQVosQ0FBWjtBQUNIO0FBQ0o7O0FBRUQsYUFBSyxNQUFMLEdBQWMsU0FBZDtBQUNBLGFBQUssYUFBTCxDQUFtQixxQkFBbkI7QUFDSCxLQXRGMEQ7O0FBd0YzRDs7Ozs7O0FBTUEsWUFBUSxnQkFBUyxDQUFULEVBQVksU0FBWixFQUF1QjtBQUMzQixlQUFPLEtBQUssa0JBQUwsQ0FBd0IsS0FBSyxJQUFMLENBQVUsQ0FBVixDQUF4QixFQUFzQyxTQUF0QyxDQUFQO0FBQ0gsS0FoRzBEOztBQWtHM0Q7Ozs7Ozs7O0FBUUEsWUFBUSxnQkFBUyxDQUFULEVBQVksT0FBWixFQUFxQjtBQUN6QixhQUFLLElBQUwsQ0FBVSxDQUFWLElBQWUsV0FBVyxTQUExQjtBQUNBLGFBQUssUUFBTDtBQUNILEtBN0cwRDs7QUErRzNEOzs7O0FBSUEsb0JBQWdCLHdCQUFTLENBQVQsRUFBWSxTQUFaLEVBQXVCO0FBQ25DLFlBQUksVUFBVSxLQUFLLElBQUwsQ0FBVSxDQUFWLENBQWQ7QUFDQSxlQUFPLFlBQVksUUFBUSxNQUFSLElBQW1CLGNBQWMsU0FBZCxLQUE0QixRQUFRLE1BQVIsR0FBaUIsT0FBTyxNQUFQLENBQWMsU0FBZCxDQUE3QyxDQUEvQixDQUFQO0FBQ0gsS0F0SDBEOztBQXdIM0Q7Ozs7QUFJQSxvQkFBZ0Isd0JBQVMsQ0FBVCxFQUFZLFFBQVosRUFBc0I7QUFDbEMsWUFBSSxVQUFVLEtBQUssSUFBTCxDQUFVLENBQVYsQ0FBZDtBQUNBLFlBQUksT0FBSixFQUFhO0FBQ1QsZ0JBQUksUUFBSixFQUFjO0FBQ1Ysd0JBQVEsTUFBUixHQUFpQixRQUFqQjtBQUNILGFBRkQsTUFFTztBQUNILHVCQUFPLFFBQVEsTUFBZjtBQUNIO0FBQ0o7QUFDRCxlQUFPLENBQUMsQ0FBQyxPQUFUO0FBQ0gsS0F0STBEOztBQXdJM0Q7Ozs7Ozs7O0FBUUEsWUFBUSxnQkFBUyxPQUFULEVBQWtCLENBQWxCLEVBQXFCO0FBQ3pCLFlBQUksTUFBTSxTQUFOLElBQW1CLEtBQUssS0FBSyxXQUFMLEVBQTVCLEVBQWdEO0FBQzVDLGlCQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsT0FBZjtBQUNILFNBRkQsTUFFTztBQUNILGlCQUFLLElBQUwsQ0FBVSxNQUFWLENBQWlCLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCLE9BQXZCO0FBQ0g7QUFDRCxhQUFLLFFBQUw7QUFDQSxhQUFLLGFBQUwsQ0FBbUIsb0JBQW5CO0FBQ0gsS0F4SjBEOztBQTBKM0Q7Ozs7Ozs7O0FBUUEsYUFBUyxpQkFBUyxRQUFULEVBQW1CLENBQW5CLEVBQXNCO0FBQUE7O0FBQzNCLFlBQUksTUFBTSxTQUFOLElBQW1CLEtBQUssS0FBSyxXQUFMLEVBQTVCLEVBQWdEO0FBQzVDLGdCQUFJLEtBQUssV0FBTCxFQUFKO0FBQ0g7QUFDRCxzQkFBSyxJQUFMLEVBQVUsTUFBVixlQUFpQixDQUFqQixFQUFvQixDQUFwQiw0QkFBMEIsUUFBMUI7QUFDQSxhQUFLLFFBQUw7QUFDQSxhQUFLLGFBQUwsQ0FBbUIsb0JBQW5CO0FBQ0gsS0F6SzBEOztBQTJLM0Q7Ozs7Ozs7O0FBUUEsWUFBUSxnQkFBUyxDQUFULEVBQVksUUFBWixFQUFzQjtBQUMxQixZQUFJLE9BQU8sS0FBSyxJQUFMLENBQVUsTUFBVixDQUFpQixDQUFqQixFQUFvQixhQUFhLFNBQWIsR0FBeUIsQ0FBekIsR0FBNkIsUUFBakQsQ0FBWDtBQUNBLGFBQUssUUFBTDtBQUNBLFlBQUksS0FBSyxNQUFULEVBQWlCO0FBQ2IsaUJBQUssYUFBTCxDQUFtQixvQkFBbkI7QUFDSDtBQUNELGVBQU8sSUFBUDtBQUNILEtBMUwwRDs7QUE0TDNEOzs7Ozs7QUFNQSx1QkFBbUIsMkJBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUM5QixZQUFJLEtBQUssS0FBTCxJQUFlLEtBQUssS0FBSyxLQUF6QixJQUFvQyxLQUFLLEtBQUssS0FBTCxDQUFXLENBQVgsQ0FBN0MsRUFBNkQ7QUFDekQsbUJBQU8sS0FBSyxLQUFMLENBQVcsQ0FBWCxFQUFjLENBQWQsQ0FBUDtBQUNIOztBQUVELFlBQUksRUFBRSxLQUFLLEtBQUssS0FBWixDQUFKLEVBQXdCO0FBQ3BCLGlCQUFLLEtBQUwsQ0FBVyxDQUFYLElBQWdCLEVBQWhCO0FBQ0g7O0FBRUQsWUFBTSxNQUFNLEtBQUssSUFBTCxDQUFVLENBQVYsQ0FBWjs7QUFFQSxZQUFJLENBQUMsR0FBRCxJQUFRLElBQUksS0FBSyxjQUFMLEVBQWhCLEVBQXVDO0FBQ25DLG1CQUFPLEVBQVA7QUFDSDs7QUFFRCxlQUFRLEtBQUssS0FBTCxDQUFXLENBQVgsRUFBYyxDQUFkLElBQW1CLEtBQUssb0NBQUwsQ0FBMEMsR0FBMUMsRUFBK0MsQ0FBL0MsQ0FBM0I7QUFDSCxLQWxOMEQ7O0FBb04zRCxhQUFTLGlCQUFTLEdBQVQsRUFBYztBQUNuQixZQUFJLE9BQU8sS0FBSyxJQUFoQjs7QUFFQSxZQUFJLFFBQVEsS0FBSyxPQUFMLENBQWEsR0FBYixDQUFaOztBQUVBLGVBQU8sUUFBUSxDQUFSLElBQWEsS0FBSyxJQUFMLENBQVU7QUFBQSxtQkFBSyxDQUFMO0FBQUEsU0FBVixDQUFwQixFQUF1QztBQUNuQyxtQkFBTyxLQUFLLEdBQUwsQ0FBUztBQUFBLHVCQUFLLEVBQUUsVUFBRixJQUFnQixFQUFFLFVBQUYsQ0FBYSxDQUFiLENBQXJCO0FBQUEsYUFBVCxDQUFQO0FBQ0Esb0JBQVEsS0FBSyxPQUFMLENBQWEsR0FBYixDQUFSO0FBQ0g7O0FBRUQsZUFBTyxLQUFQO0FBQ0gsS0EvTjBEOztBQWlPM0Qsd0JBQW9CLDRCQUFTLEdBQVQsRUFBYyxTQUFkLEVBQXlCO0FBQ3pDLFlBQUksT0FBTyxJQUFJLFVBQVgsSUFBeUIsSUFBSSxXQUFKLEtBQW9CLFNBQWpELEVBQTREO0FBQ3hELG1CQUFPLElBQUksV0FBSixLQUFvQixTQUEzQixFQUFzQztBQUNsQyxvQkFBSSxJQUFJLFVBQUosQ0FBZSxNQUFmLEtBQTBCLENBQTlCLEVBQWlDO0FBQzdCO0FBQ0E7QUFDSCxpQkFIRCxNQUdPLElBQUksSUFBSSxNQUFSLEVBQWdCO0FBQ25CO0FBQ0EsMEJBQU0sSUFBSSxVQUFKLENBQWUsQ0FBZixDQUFOO0FBQ0gsaUJBSE0sTUFHQTtBQUNIO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7QUFDRCxlQUFPLEdBQVA7QUFDSCxLQWpQMEQ7O0FBbVAzRCwwQ0FBc0MsOENBQVMsR0FBVCxFQUFjLENBQWQsRUFBaUI7QUFDbkQsWUFBTSxhQUFhLEtBQUssYUFBTCxDQUFtQixDQUFuQixDQUFuQjtBQUNBLFlBQU0sWUFBWSxLQUFLLGtCQUFMLENBQXdCLENBQXhCLENBQWxCOztBQUVBLGNBQU0sS0FBSyxrQkFBTCxDQUF3QixHQUF4QixFQUE2QixTQUE3QixDQUFOOztBQUVBLFlBQUksY0FBYyxHQUFsQixFQUF1QjtBQUNuQixtQkFBTyxFQUFFLGNBQWMsSUFBSSxVQUFKLENBQWhCLEVBQVA7QUFDSDs7QUFFRDtBQUNBLFlBQUkscUJBQUo7QUFBQSxZQUFrQixhQUFhLEtBQS9CO0FBQ0EsdUJBQWUsSUFBSSxPQUFPLElBQVAsQ0FBWSxHQUFaLEVBQWlCLElBQWpCLENBQXNCLFVBQUMsR0FBRCxFQUFTO0FBQzlDLGdCQUFJLGtCQUFrQixJQUFJLEtBQUosQ0FBVSxHQUFWLENBQXRCO0FBQ0EseUJBQWEsY0FBYyxnQkFBZ0IsUUFBaEIsQ0FBeUIsVUFBekIsS0FBd0MsZ0JBQWdCLENBQWhCLE1BQXVCLFVBQTFGO0FBQ0EsbUJBQU8sZ0JBQWdCLENBQWhCLE1BQXVCLFVBQTlCO0FBQ0gsU0FKa0IsQ0FBSixDQUFmOztBQU1BLGVBQU8sRUFBRSwwQkFBRixFQUFnQixzQkFBaEIsRUFBUDtBQUNILEtBdFEwRDs7QUF3UTNEOzs7O0FBSUEsY0FBVSxrQkFBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQ3JCLFlBQUksTUFBTSxLQUFLLGlCQUFMLENBQXVCLENBQXZCLEVBQTBCLENBQTFCLEVBQTZCLFlBQXZDOztBQUVBLFlBQUksUUFBUSxTQUFaLEVBQXVCO0FBQ25CLG1CQUFPLE9BQU8sSUFBSSxLQUFYLElBQW9CLElBQUksS0FBSixLQUFjLElBQWxDLEdBQXlDLElBQUksS0FBN0MsR0FBcUQsU0FBNUQ7QUFDSDtBQUNKLEtBbFIwRDs7QUFvUjNELDZCQUF5QixpQ0FBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQ3BDLFlBQUksTUFBTSxLQUFLLGlCQUFMLENBQXVCLENBQXZCLEVBQTBCLENBQTFCLEVBQTZCLFlBQXZDOztBQUVBLGVBQU8sT0FDQSxJQUFJLGVBREosSUFFQSxJQUFJLGVBQUosS0FBd0IsSUFGeEIsSUFHQSxJQUFJLGVBQUosS0FBd0IsU0FIeEIsR0FHb0MsSUFBSSxlQUh4QyxHQUcwRCxFQUhqRTtBQUlILEtBM1IwRDs7QUE2UjNELGdDQUE0QixvQ0FBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQ3ZDLFlBQU0sb0JBQW9CLEtBQUssdUJBQUwsQ0FBNkIsQ0FBN0IsRUFBZ0MsQ0FBaEMsQ0FBMUI7O0FBRUEsZUFBTyxxQkFBcUIsa0JBQWtCLE1BQWxCLEtBQTZCLFNBQWxELEdBQThELGtCQUFrQixNQUFsQixHQUEyQixDQUF6RixHQUE2RixLQUFwRztBQUNILEtBalMwRDs7QUFtUzNELHNDQUFrQywwQ0FBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQzdDLFlBQUksTUFBTSxLQUFLLGlCQUFMLENBQXVCLENBQXZCLEVBQTBCLENBQTFCLEVBQTZCLFlBQXZDOztBQUVBLFlBQUksUUFBUSxTQUFaLEVBQXVCO0FBQ25CLG1CQUFPLE9BQU8sSUFBSSxtQkFBWCxJQUFrQyxJQUFJLG1CQUFKLEtBQTRCLElBQTlELEdBQXFFLElBQUksbUJBQXpFLEdBQStGLEtBQXRHO0FBQ0g7QUFDSixLQXpTMEQ7O0FBMlMzRCxrQ0FBOEIsc0NBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUN6QyxZQUFJLE1BQU0sS0FBSyxpQkFBTCxDQUF1QixDQUF2QixFQUEwQixDQUExQixFQUE2QixZQUF2Qzs7QUFFQSxZQUFNLGNBQWMsQ0FBQyxnQkFBRCxFQUFtQixNQUFuQixDQUFwQjs7QUFFQSxZQUFJLFFBQVEsU0FBWixFQUF1QjtBQUNuQixnQkFBSSxJQUFJLGVBQUosS0FBd0IsU0FBNUIsRUFBdUM7QUFDbkMsdUJBQU8sSUFBUDtBQUNIOztBQUVELG1CQUFPLE9BQU8sSUFBSSxlQUFYLEdBQ0QsWUFBWSxPQUFaLENBQW9CLElBQUksZUFBeEIsSUFBMkMsQ0FBQyxDQUQzQyxHQUVELEtBRk47QUFHSDtBQUNKLEtBelQwRDs7QUEyVDNELDhCQUEwQixrQ0FBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQ3JDLFlBQUksTUFBTSxLQUFLLGlCQUFMLENBQXVCLENBQXZCLEVBQTBCLENBQTFCLEVBQTZCLFlBQXZDOztBQUVBLFlBQUksUUFBUSxTQUFaLEVBQXVCO0FBQ25CLG1CQUFPLE9BQU8sSUFBSSxPQUFYLElBQXNCLElBQUksT0FBSixLQUFnQixJQUF0QyxHQUE2QyxJQUFJLE9BQWpELEdBQTJELFNBQWxFO0FBQ0g7QUFDSixLQWpVMEQ7O0FBbVUzRDs7OztBQUlBLGNBQVUsa0JBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUNyQixZQUFJLHNCQUFzQixLQUFLLGlCQUFMLENBQXVCLENBQXZCLEVBQTBCLENBQTFCLEVBQTZCLFlBQXZEOztBQUVBLFlBQUksd0JBQXdCLFNBQTVCLEVBQXVDO0FBQ25DLG1CQUFPLHVCQUF1QixvQkFBb0IsS0FBM0MsR0FBbUQsb0JBQW9CLEtBQXZFLEdBQStFLG1CQUF0RjtBQUNIO0FBQ0osS0E3VTBEOztBQStVM0Q7Ozs7QUFJQSxjQUFVLGtCQUFTLENBQVQsRUFBWSxDQUFaLEVBQWUsS0FBZixFQUFzQjtBQUM1QixZQUFJLHNCQUFzQixLQUFLLGlCQUFMLENBQXVCLENBQXZCLEVBQTBCLENBQTFCLEVBQTZCLFlBQXZEOztBQUVBLFlBQUksbUJBQUosRUFBeUI7QUFDckIsZ0JBQUksUUFBTyxtQkFBUCx5Q0FBTyxtQkFBUCxPQUErQixRQUEvQixJQUEyQyxDQUFDLENBQUMsb0JBQW9CLEtBQXJFLEVBQTRFO0FBQ3hFLG9DQUFvQixLQUFwQixHQUE0QixLQUE1QjtBQUNILGFBRkQsTUFFTztBQUNILHNDQUFzQixLQUF0QjtBQUNIO0FBQ0o7QUFDRCxhQUFLLElBQUwsQ0FBVSxDQUFWLEVBQWEsS0FBSyxhQUFMLENBQW1CLENBQW5CLENBQWIsSUFBc0MsbUJBQXRDO0FBQ0EsYUFBSyxRQUFMO0FBQ0gsS0EvVjBEOztBQWlXM0Q7Ozs7QUFJQSw4QkFBMEIsa0NBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUNyQyxZQUFJLHNCQUFzQixLQUFLLGlCQUFMLENBQXVCLENBQXZCLEVBQTBCLENBQTFCLEVBQTZCLFlBQXZEOztBQUVBLFlBQUksd0JBQXdCLElBQXhCLElBQWdDLFFBQU8sbUJBQVAseUNBQU8sbUJBQVAsT0FBK0IsUUFBL0QsSUFBMkUsQ0FBQyxDQUFDLG9CQUFvQixVQUFyRyxFQUFpSDtBQUM3RyxtQkFBTyxvQkFBb0IsVUFBM0I7QUFDSCxTQUZELE1BRU87QUFDSCxtQkFBTyxFQUFQO0FBQ0g7QUFDSixLQTdXMEQ7O0FBK1czRDs7Ozs7OztBQU9BLGdCQUFZLG9CQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDdkIsWUFBSSxnQkFBZ0IsS0FBSyxpQkFBTCxDQUF1QixDQUF2QixFQUEwQixDQUExQixDQUFwQjtBQUNBLFlBQU0sc0JBQXNCLGNBQWMsWUFBMUM7O0FBRUEsWUFBSSx1QkFBdUIsUUFBTyxtQkFBUCx5Q0FBTyxtQkFBUCxPQUErQixRQUExRCxFQUFvRTtBQUNoRSxnQkFBSSxvQkFBb0IsT0FBeEIsRUFBaUM7QUFDN0IsdUJBQU8sb0JBQW9CLE9BQTNCO0FBQ0g7QUFDSixTQUpELE1BSU8sSUFBSSxjQUFjLFVBQWxCLEVBQThCO0FBQ2pDLGdCQUFJLElBQUksQ0FBUjtBQUNBLG1CQUFPLGNBQWMsVUFBckIsRUFBaUM7QUFDN0IsZ0NBQWdCLEtBQUssaUJBQUwsQ0FBdUIsRUFBRSxDQUF6QixFQUE0QixDQUE1QixDQUFoQjtBQUNIO0FBQ0QsbUJBQU8sY0FBYyxZQUFkLEdBQTZCLGNBQWMsWUFBZCxDQUEyQixPQUEzQixJQUFzQyxJQUFJLENBQTFDLENBQTdCLEdBQTRFLENBQW5GO0FBQ0g7O0FBRUQsZUFBTyxDQUFQO0FBQ0gsS0F2WTBEOztBQXlZM0Q7Ozs7OztBQU1BLHdCQUFvQiw0QkFBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQy9CLFlBQUksYUFBYSxDQUFqQjtBQUNBLFlBQU0sVUFBVSxLQUFLLFVBQUwsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsQ0FBaEI7QUFDQSxhQUFLLElBQUksSUFBSSxJQUFJLENBQWpCLEVBQW9CLEtBQUssSUFBSSxPQUE3QixFQUFzQyxHQUF0QyxFQUEyQztBQUN2QywwQkFBYyxLQUFLLElBQUwsQ0FBVSxjQUFWLENBQXlCLENBQXpCLENBQWQ7QUFDSDtBQUNELGVBQU8sVUFBUDtBQUNILEtBdFowRDs7QUF3WjNEOzs7Ozs7O0FBT0EsZ0JBQVksb0JBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUN2QixZQUFJLHNCQUFzQixLQUFLLGlCQUFMLENBQXVCLENBQXZCLEVBQTBCLENBQTFCLEVBQTZCLFlBQXZEOztBQUVBLFlBQUksdUJBQXVCLFFBQU8sbUJBQVAseUNBQU8sbUJBQVAsT0FBK0IsUUFBdEQsSUFBa0UsQ0FBQyxDQUFDLG9CQUFvQixPQUE1RixFQUFxRztBQUNqRyxtQkFBTyxvQkFBb0IsT0FBM0I7QUFDSCxTQUZELE1BRU87QUFDSCxtQkFBTyxDQUFQO0FBQ0g7QUFDSixLQXZhMEQ7O0FBeWEzRDs7Ozs7O0FBTUEseUJBQXFCLDZCQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDaEMsWUFBSSxhQUFhLENBQWpCO0FBQ0EsWUFBTSxVQUFVLEtBQUssVUFBTCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixDQUFoQjtBQUNBLGFBQUssSUFBSSxJQUFJLElBQUksQ0FBakIsRUFBb0IsS0FBSyxJQUFJLE9BQTdCLEVBQXNDLEdBQXRDLEVBQTJDO0FBQ3ZDLDBCQUFjLEtBQUssSUFBTCxDQUFVLFlBQVYsQ0FBdUIsQ0FBdkIsQ0FBZDtBQUNIO0FBQ0QsZUFBTyxVQUFQO0FBQ0gsS0F0YjBEOztBQXdiM0Q7Ozs7OztBQU1BLDZCQUF5QixpQ0FBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQ3BDLFlBQUksV0FBVyxLQUFLLGlCQUFMLENBQXVCLENBQXZCLEVBQTBCLENBQTFCLENBQWY7O0FBRUEsZUFBTyxDQUFDLENBQUMsU0FBUyxZQUFYLElBQTJCLFNBQVMsWUFBVCxDQUFzQixtQkFBeEQ7QUFDQTtBQUNILEtBbmMwRDs7QUFxYzNEOzs7Ozs7QUFNQSx1QkFBbUIsMkJBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUM5QixZQUFJLFlBQVksS0FBSyxpQkFBTCxDQUF1QixDQUF2QixFQUEwQixDQUExQixDQUFoQjs7QUFFQSxlQUFPLENBQUMsQ0FBQyxVQUFVLFlBQVosSUFBNEIsVUFBVSxZQUFWLENBQXVCLGNBQXZCLEtBQTBDLFNBQXRFLEdBQ0QsVUFBVSxZQUFWLENBQXVCLGNBRHRCLEdBRUQsSUFGTjtBQUdILEtBamQwRDs7QUFtZDNEOzs7Ozs7QUFNQSw4QkFBMEIsa0NBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUNyQyxZQUFJLFlBQVksS0FBSyxpQkFBTCxDQUF1QixDQUF2QixFQUEwQixDQUExQixDQUFoQjs7QUFFQSxlQUFPLENBQUMsQ0FBQyxVQUFVLFlBQVosSUFBNEIsVUFBVSxZQUFWLENBQXVCLGlCQUFuRCxHQUF1RSxVQUFVLFlBQVYsQ0FBdUIsaUJBQTlGLEdBQWtILElBQXpIO0FBQ0gsS0E3ZDBEOztBQStkM0Q7Ozs7OztBQU1BLHNCQUFrQiwwQkFBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQzdCLFlBQUksWUFBWSxLQUFLLGlCQUFMLENBQXVCLENBQXZCLEVBQTBCLENBQTFCLENBQWhCOztBQUVBLGVBQU8sQ0FBQyxDQUFDLFVBQVUsWUFBWixJQUE0QixVQUFVLFlBQVYsQ0FBdUIsZ0JBQTFEO0FBQ0gsS0F6ZTBEOztBQTJlM0Qsd0JBQW9CLDRCQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDL0IsZUFBTyxLQUFLLGdCQUFMLENBQXNCLENBQXRCLEVBQXlCLENBQXpCLEtBQStCLEtBQUssdUJBQUwsQ0FBNkIsQ0FBN0IsRUFBZ0MsQ0FBaEMsQ0FBdEM7QUFDSCxLQTdlMEQ7O0FBK2UzRDs7OztBQUlBLGlCQUFhLHVCQUFXO0FBQ3BCLGVBQU8sS0FBSyxJQUFMLENBQVUsTUFBakI7QUFDSCxLQXJmMEQ7O0FBdWYzRDs7OztBQUlBLG9CQUFnQiwwQkFBVztBQUN2QixlQUFPLEtBQUssTUFBTCxDQUFZLE1BQW5CO0FBQ0gsS0E3ZjBEOztBQStmM0QsbUJBQWUsdUJBQVMsQ0FBVCxFQUFZO0FBQ3ZCLGVBQU8sUUFBUSxDQUFSLHlDQUFRLENBQVIsR0FBVyxDQUFYLE1BQWtCLEdBQWxCLElBQXlCLEtBQUssTUFBTCxDQUFZLENBQVosQ0FBekIsR0FBMEMsS0FBSyxNQUFMLENBQVksQ0FBWixFQUFlLElBQXpELEdBQWdFLENBQXZFO0FBQ0gsS0FqZ0IwRDs7QUFtZ0IzRCx3QkFBb0IsNEJBQVMsQ0FBVCxFQUFZO0FBQzVCLGVBQU8sUUFBUSxDQUFSLHlDQUFRLENBQVIsR0FBVyxDQUFYLE1BQWtCLEdBQWxCLElBQXlCLEtBQUssTUFBTCxDQUFZLENBQVosQ0FBekIsSUFBMkMsS0FBSyxNQUFMLENBQVksQ0FBWixFQUFlLE1BQTFELEdBQW1FLEtBQUssTUFBTCxDQUFZLENBQVosRUFBZSxNQUFmLENBQXNCLFNBQXpGLEdBQXFHLFNBQTVHO0FBQ0gsS0FyZ0IwRDs7QUF1Z0IzRCw0QkFBd0Isa0NBQVc7QUFDL0IsZUFBTyxLQUFLLElBQUwsQ0FBVSxNQUFWLENBQWlCO0FBQUEsbUJBQUssQ0FBQyxFQUFFLFlBQVI7QUFBQSxTQUFqQixFQUF1QyxNQUF2QyxHQUFnRCxLQUFLLElBQUwsQ0FBVSx5QkFBVixFQUF2RDtBQUNILEtBemdCMEQ7O0FBMmdCM0QsK0JBQTJCLHFDQUFXO0FBQ2xDLGVBQU8sS0FBSyxJQUFMLENBQVUsUUFBVixDQUFtQixPQUFuQixDQUEyQixNQUEzQixDQUFrQztBQUFBLG1CQUFLLENBQUMsQ0FBQyxFQUFFLE1BQVQ7QUFBQSxTQUFsQyxFQUFtRCxNQUExRDtBQUNILEtBN2dCMEQ7O0FBK2dCM0Q7Ozs7O0FBS0EsY0FwaEIyRCxzQkFvaEJoRCxLQXBoQmdELEVBb2hCekM7QUFDZCxZQUFJLFNBQVMsS0FBYjtBQUNBLFlBQUksTUFBTSxPQUFOLENBQWMsS0FBZCxDQUFKLEVBQTBCO0FBQ3RCLGtCQUFNLE9BQU4sQ0FBYyxhQUFLO0FBQ2Ysb0JBQUksWUFBWSxDQUFaLENBQUosRUFBb0I7QUFDaEIsNkJBQVMsSUFBVDtBQUNIO0FBQ0osYUFKRDtBQUtILFNBTkQsTUFNTztBQUNILHFCQUFTLFlBQVksS0FBWixDQUFUO0FBQ0g7O0FBRUQsZUFBTyxNQUFQO0FBQ0gsS0FqaUIwRDs7O0FBbWlCM0Q7QUFDQSxxQkFwaUIyRCw2QkFvaUJ6QyxLQXBpQnlDLEVBb2lCbEMsVUFwaUJrQyxFQW9pQnRCO0FBQ2pDLFlBQU0sUUFBUSxNQUFNLEtBQU4sQ0FBWSxpQkFBWixFQUErQixNQUEvQixDQUFzQztBQUFBLG1CQUFLLENBQUMsQ0FBQyxDQUFQO0FBQUEsU0FBdEMsRUFBZ0QsSUFBaEQsQ0FBcUQsR0FBckQsQ0FBZDtBQUNBLFlBQU0sUUFBUSxJQUFkO0FBQ0EsWUFBTSxnQkFBZ0IsK0JBQXRCO0FBQ0EsWUFBSSxlQUFlLGFBQW5CLEVBQWtDO0FBQzlCLG1CQUFPLElBQUksTUFBSixDQUFXLFFBQVEsS0FBUixHQUFnQixLQUFoQixHQUF3QixhQUFuQyxFQUFrRCxLQUFsRCxDQUFQO0FBQ0gsU0FGRCxNQUVPLElBQUksZUFBZSxNQUFuQixFQUEyQjtBQUM5QixtQkFBTyxJQUFJLE1BQUosQ0FBVyxRQUFRLEtBQVIsR0FBZ0IsYUFBM0IsRUFBMEMsS0FBMUMsQ0FBUDtBQUNILFNBRk0sTUFFQSxJQUFJLGVBQWUsTUFBbkIsRUFBMkI7QUFDOUIsbUJBQU8sSUFBSSxNQUFKLENBQVcsUUFBUSxhQUFuQixFQUFrQyxLQUFsQyxDQUFQO0FBQ0g7QUFDSixLQS9pQjBEO0FBaWpCM0QsdUJBampCMkQsK0JBaWpCdkMsR0FqakJ1QyxFQWlqQmxDLEtBampCa0MsRUFpakIzQixVQWpqQjJCLEVBaWpCZjtBQUN4QyxZQUFJLENBQUMsS0FBRCxJQUFVLENBQUMsR0FBWCxJQUFrQixlQUFlLE1BQWpDLElBQTJDLGVBQWUsU0FBOUQsRUFBeUU7QUFDckUsbUJBQU8sRUFBUDtBQUNIOztBQUVELFlBQU0sTUFBTSxLQUFLLGlCQUFMLENBQXVCLEtBQXZCLEVBQThCLFVBQTlCLENBQVo7O0FBRUEsWUFBSSxDQUFDLEdBQUwsRUFBVTtBQUNOLG1CQUFPLEdBQVA7QUFDSDs7QUFFRCxlQUFPLENBQUMsTUFBTSxFQUFQLEVBQVcsT0FBWCxDQUFtQixHQUFuQixFQUF3QixpQkFBeEIsQ0FBUDtBQUNILEtBN2pCMEQ7QUErakIzRCxZQS9qQjJELHNCQStqQmhEO0FBQ1AsYUFBSyxLQUFMLEdBQWEsRUFBYjtBQUNBLGFBQUssS0FBTCxHQUFhLEtBQUssS0FBTCxDQUFXLE1BQVgsQ0FBa0I7QUFBQSxtQkFBSyxDQUFDLEVBQUUsWUFBUjtBQUFBLFNBQWxCLENBQWI7QUFDQSxZQUFNLGtCQUFrQixLQUFLLElBQUwsSUFBYSxLQUFLLElBQUwsQ0FBVSxVQUFWLENBQXFCLGVBQWxDLElBQXFELEVBQTdFO0FBQ0EsZUFBTyxLQUFLLEtBQUwsQ0FBVyxNQUFYLEdBQW9CLGVBQTNCLEVBQTRDO0FBQ3hDLGlCQUFLLEtBQUwsQ0FBVyxJQUFYLHFCQUFtQixjQUFuQixFQUFvQyxJQUFwQztBQUNIO0FBQ0osS0F0a0IwRDs7O0FBd2tCM0QsUUFBSSxJQUFKLEdBQVc7QUFDUCxlQUFPLEtBQUssS0FBWjtBQUNILEtBMWtCMEQ7QUEya0IzRCxRQUFJLElBQUosQ0FBUyxJQUFULEVBQWU7QUFDWCxhQUFLLEtBQUwsR0FBYSxJQUFiO0FBQ0EsYUFBSyxLQUFMLEdBQWEsRUFBYjtBQUNIO0FBOWtCMEQsQ0FBekMsQ0FBdEI7O0FBaWxCQSxTQUFTLFdBQVQsQ0FBcUIsTUFBckIsRUFBNkI7QUFDekIsUUFBSSxDQUFDLE1BQUwsRUFBYTtBQUNULGVBQU8sS0FBUDtBQUNIO0FBQ0QsUUFBTSxhQUFhLHVGQUFuQixDQUp5QixDQUltRjtBQUM1RyxXQUFPLFdBQVcsSUFBWCxDQUFnQixNQUFoQixDQUFQO0FBQ0g7O0FBRUQsT0FBTyxPQUFQLEdBQWlCLGVBQWpCOzs7QUNobkJBOztBQUVBOztBQUVBOzs7Ozs7OztBQUVBLElBQU0sb0JBQW9CLFFBQVEscUJBQVIsQ0FBMUI7O0FBRUE7Ozs7Ozs7SUFNTSxXO0FBQ0YseUJBQVksTUFBWixFQUFvQjtBQUFBOztBQUNoQixhQUFLLE1BQUwsR0FBYyxNQUFkOztBQUVBOzs7OztBQUtBLGFBQUssa0JBQUwsR0FBMEIsS0FBMUI7O0FBRUE7Ozs7O0FBS0EsYUFBSyx3QkFBTCxHQUFnQyxLQUFoQzs7QUFFQTs7Ozs7QUFLQSxhQUFLLHFCQUFMLEdBQTZCLElBQTdCOztBQUVBOzs7OztBQUtBLGFBQUssc0JBQUwsR0FBOEIsSUFBOUI7O0FBRUE7Ozs7O0FBS0EsYUFBSyxzQkFBTCxHQUE4QixDQUE5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBLGFBQUssdUJBQUwsR0FBK0IsQ0FBL0I7O0FBRUE7Ozs7O0FBS0EsYUFBSyw0QkFBTCxHQUFvQyxDQUFwQzs7QUFFQTs7Ozs7QUFLQSxhQUFLLDBCQUFMLEdBQWtDLElBQWxDOztBQUVBOzs7OztBQUtBLGFBQUssMEJBQUwsR0FBa0MsSUFBbEM7O0FBRUEsYUFBSyxrQkFBTCxHQUEwQixJQUExQjs7QUFFQTs7Ozs7O0FBTUEsYUFBSyw0QkFBTCxHQUFvQyxFQUFwQzs7QUFFQTs7Ozs7O0FBTUEsYUFBSyx3QkFBTCxHQUFnQyxDQUFoQzs7QUFFQSxhQUFLLHdDQUFMLEdBQWdELElBQWhEOztBQUVBOzs7Ozs7QUFNQSxhQUFLLHVCQUFMLEdBQStCLENBQS9COztBQUVBOzs7Ozs7QUFNQSxhQUFLLGVBQUwsR0FBdUIsSUFBdkI7O0FBRUE7Ozs7OztBQU1BLGFBQUssb0JBQUwsR0FBNEIsS0FBNUI7O0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBY0EsYUFBSyxNQUFMLEdBQWMsSUFBZDtBQUVIOztBQUVEOzs7Ozs7Ozs7O3FEQU02QjtBQUN6QixpQkFBSyxrQkFBTCxHQUEwQixLQUExQjtBQUNBLGlCQUFLLHdDQUFMLEdBQWdELElBQWhEO0FBQ0EsZ0JBQUksS0FBSyx3QkFBVCxFQUFtQztBQUMvQiw4QkFBYyxLQUFLLHdCQUFuQjtBQUNBLHFCQUFLLHdCQUFMLEdBQWdDLENBQWhDO0FBQ0g7O0FBRUQsaUJBQUsscUJBQUw7QUFDSDs7QUFFRDs7Ozs7Ozs7OztnREFPd0I7QUFDcEIsZ0JBQUksS0FBSyx1QkFBVCxFQUFrQztBQUM5Qiw2QkFBYSxLQUFLLHVCQUFsQjtBQUNBLHFCQUFLLHVCQUFMLEdBQStCLENBQS9CO0FBQ0g7QUFDSjs7O2dDQUVPLE8sRUFBUztBQUNiLGdCQUFNLE1BQU0sS0FBSyxhQUFMLElBQXNCLEtBQUssYUFBTCxDQUFtQixPQUFuQixDQUFsQztBQUNBLGdCQUFJLEdBQUosRUFBUztBQUNMLG9CQUFJLFNBQUosQ0FBYyxHQUFkLENBQWtCLFdBQWxCO0FBQ0g7QUFDRCxtQkFBTyxnQkFBUCxDQUF3QixPQUF4QixFQUFpQyxLQUFLLE9BQU8sT0FBWixDQUFqQztBQUNIOzs7bUNBRVUsTyxFQUFTO0FBQ2hCLGdCQUFNLE1BQU0sS0FBSyxhQUFMLElBQXNCLEtBQUssYUFBTCxDQUFtQixPQUFuQixDQUFsQztBQUNBLGdCQUFJLEdBQUosRUFBUztBQUNMLG9CQUFJLFNBQUosQ0FBYyxNQUFkLENBQXFCLFdBQXJCO0FBQ0g7QUFDRCxtQkFBTyxtQkFBUCxDQUEyQixPQUEzQixFQUFvQyxLQUFLLE9BQU8sT0FBWixDQUFwQztBQUNIOzs7a0NBRVMsRyxFQUFLO0FBQ1gsZ0JBQUksZUFBSjtBQUNIOzs7Z0NBRU8sRyxFQUFLO0FBQ1QsZ0JBQUksTUFBTSxLQUFLLFNBQWY7QUFDQTtBQUNBLGdCQUFJLElBQUksUUFBUixFQUFrQjtBQUNkLHNCQUFNLGtCQUFrQixRQUFRLGtCQUFrQixVQUFsQixDQUE2QixLQUFyQyxHQUE2QyxVQUE3QyxHQUEwRCxZQUE1RSxFQUEwRixLQUFoRztBQUNIO0FBQ0QsaUJBQUssS0FBTCxJQUFjLElBQUksR0FBSixDQUFkO0FBQ0EsZ0JBQUksZUFBSjtBQUNBLGdCQUFJLGNBQUo7QUFDSDs7O2dDQUVPLEcsRUFBSztBQUNULGlCQUFLLEtBQUwsQ0FBVyxnQkFBWCxDQUE0QixlQUE1QixFQUE2QyxTQUFTLFNBQVQsR0FBcUI7QUFDOUQscUJBQUssbUJBQUwsQ0FBeUIsZUFBekIsRUFBMEMsU0FBMUM7QUFDQSxxQkFBSyxTQUFMLENBQWUsR0FBZjtBQUNILGFBSDRDLENBRzNDLElBSDJDLENBR3RDLElBSHNDLENBQTdDOztBQUtBLGdCQUFJLGVBQUo7QUFDSDs7O21DQUVVLEcsRUFBSztBQUNaLGlCQUFLLDBCQUFMO0FBQ0g7OztvQ0FFVyxHLEVBQUs7QUFDYixnQkFBTSxXQUFXLEtBQUssS0FBTCxDQUFXLHFCQUFYLEVBQWpCO0FBQ0EsaUJBQUssU0FBTCxHQUFpQixJQUFJLEtBQUssRUFBTCxDQUFRLElBQVosSUFBb0IsU0FBUyxLQUFLLEVBQUwsQ0FBUSxPQUFqQixDQUFwQixHQUFnRCxLQUFLLEdBQUwsQ0FBUyxxQkFBVCxHQUFpQyxLQUFLLEVBQUwsQ0FBUSxPQUF6QyxDQUFoRCxHQUFvRyxLQUFLLGtCQUExSDtBQUNBLHFCQUFTLGVBQVQsQ0FBeUIsS0FBekIsQ0FBK0IsTUFBL0IsR0FBd0MsU0FBeEM7O0FBRUEsaUJBQUssT0FBTCxDQUFhLFdBQWI7QUFDQSxpQkFBSyxPQUFMLENBQWEsU0FBYjs7QUFFQSxpQkFBSyxrQkFBTCxDQUF3QixHQUF4Qjs7QUFFQSxnQkFBSSxlQUFKO0FBQ0EsZ0JBQUksY0FBSjtBQUNIOzs7d0NBRWUsRyxFQUFLO0FBQ2pCLGdCQUFNLFdBQVcsS0FBSyxLQUFMLENBQVcscUJBQVgsRUFBakI7QUFDQSxpQkFBSyxTQUFMLEdBQWlCLElBQUksT0FBSixDQUFZLENBQVosRUFBZSxLQUFLLEVBQUwsQ0FBUSxVQUF2QixJQUFxQyxTQUFTLEtBQUssRUFBTCxDQUFRLE9BQWpCLENBQXJDLEdBQWlFLEtBQUssR0FBTCxDQUFTLHFCQUFULEdBQWlDLEtBQUssRUFBTCxDQUFRLE9BQXpDLENBQWpFLEdBQXFILEtBQUssa0JBQTNJO0FBQ0EscUJBQVMsZUFBVCxDQUF5QixLQUF6QixDQUErQixNQUEvQixHQUF3QyxTQUF4Qzs7QUFFQSxpQkFBSyxPQUFMLENBQWEsVUFBYjtBQUNBLGlCQUFLLE9BQUwsQ0FBYSxXQUFiOztBQUVBLGlCQUFLLGtCQUFMLENBQXdCLElBQUksT0FBSixDQUFZLENBQVosQ0FBeEI7QUFDQSxpQkFBSyxrQkFBTCxHQUEwQixJQUExQjs7QUFFQSxnQkFBSSxlQUFKO0FBQ0EsZ0JBQUksY0FBSjtBQUNIOzs7MkNBRWtCLFksRUFBYztBQUFBOztBQUM3QixnQkFBSSxXQUFXLEtBQUssS0FBTCxDQUFXLHFCQUFYLEVBQWY7QUFDQSxnQkFBSSxpQkFBaUIsU0FBUyxJQUFULElBQWlCLGFBQWEsT0FBOUIsSUFBeUMsYUFBYSxPQUFiLElBQXdCLFNBQVMsS0FBMUUsSUFDakIsU0FBUyxHQUFULElBQWdCLGFBQWEsT0FEWixJQUN1QixhQUFhLE9BQWIsSUFBd0IsU0FBUyxNQUQ3RTtBQUFBLGdCQUVJLHVCQUF1QixLQUYzQjtBQUFBLGdCQUdJLFVBQVUsS0FIZDtBQUFBLGdCQUlJLGlCQUFpQixDQUpyQjs7QUFNQSxnQkFBSSxDQUFDLGNBQUwsRUFBcUI7QUFDakIsMEJBQVUsYUFBYSxLQUFLLEVBQUwsQ0FBUSxVQUFyQixJQUFtQyxTQUFTLEtBQUssRUFBTCxDQUFRLE9BQWpCLENBQTdDOztBQUVBLG9CQUFJLFFBQU8sS0FBSyxNQUFaLE1BQXVCLFFBQTNCLEVBQXFDO0FBQ2pDLHlCQUFLLEtBQUwsR0FBYSxLQUFLLE1BQUwsQ0FBWSxVQUFVLElBQVYsR0FBaUIsTUFBN0IsRUFBcUMsS0FBSyxLQUFMLENBQVcsS0FBSyxLQUFoQixDQUFyQyxDQUFiO0FBQ0gsaUJBRkQsTUFFTztBQUNILHlCQUFLLEtBQUwsSUFBYyxVQUFVLENBQUMsS0FBSyxTQUFoQixHQUE0QixLQUFLLFNBQS9DO0FBQ0g7O0FBRUQscUJBQUsscUJBQUw7QUFDQSxxQkFBSyx1QkFBTCxHQUErQixXQUFXLFlBQU07QUFDNUMsMEJBQUssa0JBQUwsR0FBMEIsSUFBMUI7QUFDQSwwQkFBSyxlQUFMLEdBQXVCLEtBQXZCOztBQUVBLDBCQUFLLHdDQUFMLEdBQWdELFlBQWhEOztBQUVBLDBCQUFLLHdCQUFMLEdBQWdDLFlBQVksWUFBTTtBQUM5Qyw0QkFBTSxLQUFLLE1BQUssd0NBQWhCO0FBQ0EsbUNBQVcsTUFBSyxLQUFMLENBQVcscUJBQVgsRUFBWDtBQUNBLHlDQUFpQixTQUFTLElBQVQsSUFBaUIsR0FBRyxPQUFwQixJQUErQixHQUFHLE9BQUgsSUFBYyxTQUFTLEtBQXRELElBQ2IsU0FBUyxHQUFULElBQWdCLEdBQUcsT0FETixJQUNpQixHQUFHLE9BQUgsSUFBYyxTQUFTLE1BRHpEOztBQUdBLDRCQUFNLHlCQUEwQixTQUFTLE1BQUssRUFBTCxDQUFRLE9BQWpCLElBQTRCLFNBQVMsTUFBSyxFQUFMLENBQVEsSUFBakIsSUFBeUIsQ0FBckY7QUFDQSw0QkFBTSwwQkFBMkIsU0FBUyxNQUFLLEVBQUwsQ0FBUSxRQUFqQixJQUE2QixTQUFTLE1BQUssRUFBTCxDQUFRLElBQWpCLElBQXlCLENBQXZGO0FBQ0EsK0NBQXVCLGtCQUNmLDBCQUEwQixHQUFHLE1BQUssRUFBTCxDQUFRLFVBQVgsQ0FEWCxJQUVmLDJCQUEyQixHQUFHLE1BQUssRUFBTCxDQUFRLFVBQVgsQ0FGbkM7O0FBSUE7QUFDQTtBQUNBLDRCQUFJLENBQUMsY0FBTCxFQUFxQjtBQUNqQixzQ0FBVSxHQUFHLE1BQUssRUFBTCxDQUFRLFVBQVgsSUFBeUIsU0FBUyxNQUFLLEVBQUwsQ0FBUSxPQUFqQixDQUFuQztBQUNIOztBQUVELHlDQUFpQixVQUFVLENBQUMsTUFBSyxTQUFoQixHQUE0QixNQUFLLFNBQWxEOztBQUVBLDRCQUFJLE1BQUssa0JBQUwsSUFBMkIsQ0FBQyxvQkFBaEMsRUFBc0Q7QUFDbEQsZ0NBQUksV0FBWSxHQUFHLE1BQUssRUFBTCxDQUFRLFVBQVgsS0FBMEIsc0JBQXRDLElBQ0ssTUFBSyxLQUFMLEdBQWEsY0FBZCxJQUFpQyxDQUR6QyxFQUM2QztBQUN6QyxzQ0FBSyxLQUFMLEdBQWEsQ0FBYjtBQUNILDZCQUhELE1BR087QUFDSCxzQ0FBSyxLQUFMLElBQWMsY0FBZDtBQUNIO0FBQ0o7O0FBRUQsNEJBQUksTUFBSyxrQkFBTCxJQUEyQixvQkFBL0IsRUFBcUQ7QUFDakQsa0NBQUssMEJBQUw7QUFDSDtBQUNKLHFCQWhDK0IsRUFnQzdCLE1BQUssNEJBaEN3QixDQUFoQztBQWlDSCxpQkF2QzhCLEVBdUM1QixHQXZDNEIsQ0FBL0I7QUF3Q0gsYUFsREQsTUFrRE8sSUFBSSxDQUFDLEtBQUssa0JBQVYsRUFBOEI7QUFDakMscUJBQUssZUFBTCxHQUF1QixJQUF2QjtBQUNIO0FBQ0o7OztvQ0FFVyxHLEVBQUs7QUFDYixnQkFBSSxLQUFLLGVBQVQsRUFBMEI7QUFDdEIsb0JBQU0sU0FBUyxLQUFLLEdBQUwsQ0FBUyxLQUFLLFFBQWQsRUFBd0IsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLElBQUksS0FBSyxFQUFMLENBQVEsSUFBWixJQUFvQixLQUFLLFNBQXJDLENBQXhCLENBQWY7QUFDQSxvQkFBTSxNQUFNLFNBQVMsS0FBSyxRQUFkLElBQTBCLEtBQUssR0FBTCxHQUFXLEtBQUssR0FBMUMsSUFBaUQsS0FBSyxHQUFsRTs7QUFFQSxxQkFBSyxVQUFMLENBQWdCLEdBQWhCLEVBQXFCLE1BQXJCO0FBQ0g7O0FBRUQsZ0JBQUksS0FBSyxrQkFBVCxFQUE2QjtBQUN6QixxQkFBSyx3Q0FBTCxHQUFnRCxHQUFoRDtBQUNIOztBQUVELGdCQUFJLGVBQUo7QUFDQSxnQkFBSSxjQUFKO0FBQ0g7OztrQ0FFUyxHLEVBQUs7QUFDWCxpQkFBSywwQkFBTDtBQUNBLGlCQUFLLGVBQUwsR0FBdUIsS0FBdkI7O0FBRUEsaUJBQUssVUFBTCxDQUFnQixXQUFoQjtBQUNBLGlCQUFLLFVBQUwsQ0FBZ0IsU0FBaEI7O0FBRUEscUJBQVMsZUFBVCxDQUF5QixLQUF6QixDQUErQixNQUEvQixHQUF3QyxNQUF4Qzs7QUFFQSxnQkFBSSxlQUFKO0FBQ0EsZ0JBQUksY0FBSjtBQUNIOzs7MkNBRWtCO0FBQ2YsZ0JBQU0sbUJBQW1CLEtBQUssR0FBTCxFQUF6QjtBQUNBLGdCQUFNLFVBQVUsbUJBQW1CLEtBQUssc0JBQXhDO0FBQ0EsaUJBQUssc0JBQUwsR0FBOEIsZ0JBQTlCO0FBQ0EsZ0JBQU0sUUFBUSxLQUFLLDBCQUFMLEdBQWtDLEtBQUssaUJBQXJEO0FBQ0EsaUJBQUssaUJBQUwsR0FBeUIsS0FBSywwQkFBOUI7QUFDQSxnQkFBTSxJQUFJLE9BQU8sS0FBUCxJQUFnQixJQUFJLE9BQXBCLENBQVY7QUFDQSxpQkFBSyxzQkFBTCxHQUE4QixLQUFLLEVBQUwsQ0FBUSw4QkFBUixHQUF5QyxDQUF6QyxHQUE2QyxNQUFNLEtBQUssc0JBQXRGO0FBQ0E7QUFDQSxnQkFBSSxLQUFLLHNCQUFMLEdBQThCLENBQUMsS0FBSyxFQUFMLENBQVEseUJBQTNDLEVBQXNFO0FBQ2xFLHFCQUFLLHNCQUFMLEdBQThCLENBQUMsS0FBSyxFQUFMLENBQVEseUJBQXZDO0FBQ0g7QUFDRCxnQkFBSSxLQUFLLHNCQUFMLEdBQThCLEtBQUssRUFBTCxDQUFRLHlCQUExQyxFQUFxRTtBQUNqRSxxQkFBSyxzQkFBTCxHQUE4QixLQUFLLEVBQUwsQ0FBUSx5QkFBdEM7QUFDSDtBQUNKOzs7cUNBRVksRyxFQUFLO0FBQ2QsaUJBQUssd0JBQUwsR0FBZ0MsSUFBaEM7QUFDQSxpQkFBSyxvQkFBTCxHQUE0QixLQUE1QjtBQUNBLGlCQUFLLHFCQUFMLEdBQTZCLElBQUksT0FBSixDQUFZLENBQVosRUFBZSxLQUFLLEVBQUwsQ0FBUSxVQUF2QixDQUE3QjtBQUNBLGlCQUFLLHNCQUFMLEdBQThCLEtBQUssR0FBTCxFQUE5Qjs7QUFFQSxpQkFBSyxpQkFBTCxHQUF5QixLQUFLLDBCQUE5QjtBQUNBLGlCQUFLLHNCQUFMLEdBQThCLEtBQUssdUJBQUwsR0FBK0IsQ0FBN0Q7O0FBRUEsaUJBQUssa0JBQUwsR0FBMEIsS0FBMUI7QUFDQSxpQkFBSywwQkFBTCxHQUFrQyxLQUFLLEtBQXZDO0FBQ0EsaUJBQUssNEJBQUwsR0FBb0MsWUFBWSxLQUFLLGdCQUFqQixFQUFtQyxHQUFuQyxDQUFwQzs7QUFFQSxnQkFBSSxjQUFKO0FBQ0EsZ0JBQUksZUFBSjtBQUNIOzs7K0JBRU0sQyxFQUFHO0FBQ047QUFDQSxnQkFBSSxFQUFFLGFBQUYsSUFBb0IsRUFBRSxhQUFGLENBQWdCLE1BQWhCLElBQTBCLENBQWxELEVBQXNEO0FBQ2xELHVCQUFPLEVBQUUsYUFBRixDQUFnQixDQUFoQixFQUFtQixLQUFLLEVBQUwsQ0FBUSxVQUEzQixDQUFQO0FBQ0g7QUFDRCxnQkFBSSxFQUFFLE9BQUYsSUFBYyxFQUFFLE9BQUYsQ0FBVSxNQUFWLElBQW9CLENBQXRDLEVBQTBDO0FBQ3RDLHVCQUFPLEVBQUUsT0FBRixDQUFVLENBQVYsRUFBYSxLQUFLLEVBQUwsQ0FBUSxVQUFyQixDQUFQO0FBQ0g7O0FBRUQ7QUFDQSxtQkFBTyxFQUFFLEtBQUssRUFBTCxDQUFRLFVBQVYsQ0FBUDtBQUNIOzs7MENBRWlCLEcsRUFBSztBQUNuQixnQkFBTSxXQUFXLEtBQUssS0FBTCxDQUFXLHFCQUFYLEVBQWpCO0FBQ0EsZ0JBQUksaUJBQWlCLEtBQUssTUFBTCxDQUFZLEdBQVosQ0FBckI7QUFDQSxpQkFBSyxTQUFMLEdBQWlCLGlCQUFpQixTQUFTLEtBQUssRUFBTCxDQUFRLE9BQWpCLENBQWpCLEdBQTZDLEtBQUssR0FBTCxDQUFTLHFCQUFULEdBQWlDLEtBQUssRUFBTCxDQUFRLE9BQXpDLENBQTdDLEdBQWlHLEtBQUssa0JBQXZIOztBQUVBLGlCQUFLLG9CQUFMLEdBQTRCLElBQTVCO0FBQ0EsaUJBQUsscUJBQUwsR0FBNkIsSUFBN0I7O0FBRUEsaUJBQUssT0FBTCxDQUFhLFVBQWI7QUFDQSxpQkFBSyxPQUFMLENBQWEsV0FBYjs7QUFFQSxnQkFBSSxlQUFKO0FBQ0EsZ0JBQUksY0FBSjtBQUNIOzs7bUNBRVUsRyxFQUFLO0FBQ1osZ0JBQUksS0FBSyx3QkFBVCxFQUFtQztBQUMvQixxQkFBSyx3QkFBTCxHQUFnQyxLQUFoQztBQUNBLDhCQUFjLEtBQUssNEJBQW5CO0FBQ0EscUJBQUssZ0JBQUw7QUFDQSxvQkFBSSxLQUFLLHNCQUFMLEdBQThCLEVBQTlCLElBQW9DLEtBQUssc0JBQUwsR0FBOEIsQ0FBQyxFQUF2RSxFQUEyRTtBQUN2RSx5QkFBSyx1QkFBTCxHQUErQixNQUFNLEtBQUssc0JBQTFDO0FBQ0EseUJBQUssMEJBQUwsR0FBa0MsS0FBSyxLQUFMLENBQVcsS0FBSywwQkFBTCxHQUFrQyxLQUFLLHVCQUFsRCxDQUFsQztBQUNBLHlCQUFLLHNCQUFMLEdBQThCLEtBQUssR0FBTCxFQUE5QjtBQUNBLDBDQUFzQixLQUFLLHVCQUEzQjtBQUNIO0FBQ0o7O0FBR0QsaUJBQUssb0JBQUwsR0FBNEIsS0FBNUI7QUFDQSxpQkFBSyx3QkFBTCxHQUFnQyxLQUFoQztBQUNBLGlCQUFLLHFCQUFMLEdBQTZCLElBQTdCOztBQUVBLGlCQUFLLDBCQUFMOztBQUVBLGlCQUFLLFVBQUwsQ0FBZ0IsVUFBaEI7QUFDQSxpQkFBSyxVQUFMLENBQWdCLFdBQWhCOztBQUVBLGdCQUFJLGVBQUo7QUFDQSxnQkFBSSxjQUFKO0FBQ0g7OztrREFFeUI7QUFDdEIsZ0JBQUksS0FBSyx1QkFBVCxFQUFrQztBQUM5QixvQkFBTSxVQUFVLEtBQUssR0FBTCxLQUFhLEtBQUssc0JBQWxDO0FBQ0Esb0JBQU0sUUFBUSxDQUFDLEtBQUssdUJBQU4sR0FBZ0MsS0FBSyxHQUFMLENBQVMsQ0FBQyxPQUFELEdBQVcsR0FBcEIsQ0FBOUM7QUFDQSxvQkFBSSxRQUFRLEdBQVIsSUFBZSxRQUFRLENBQUMsR0FBNUIsRUFBaUM7QUFDN0IseUJBQUssbUJBQUwsQ0FBeUIsS0FBSywwQkFBTCxHQUFrQyxLQUEzRDtBQUNBLDBDQUFzQixLQUFLLHVCQUEzQjtBQUNILGlCQUhELE1BR087QUFDSCx5QkFBSyxtQkFBTCxDQUF5QixLQUFLLDBCQUE5QjtBQUNIO0FBQ0o7QUFDSjs7OzRDQUVtQixDLEVBQUc7QUFDbkIsZ0JBQU0sWUFBYSxJQUFJLEtBQUssR0FBVixHQUFpQixLQUFLLEdBQXRCLEdBQTZCLElBQUksS0FBSyxHQUFWLEdBQWlCLEtBQUssR0FBdEIsR0FBNEIsQ0FBMUU7QUFDQSxnQkFBSSxjQUFjLEtBQUssMEJBQXZCLEVBQW1EO0FBQy9DLHFCQUFLLDBCQUFMLEdBQWtDLFNBQWxDO0FBQ0EscUJBQUssVUFBTCxDQUFnQixLQUFLLDBCQUFyQjtBQUNIO0FBQ0o7OztvQ0FFVyxHLEVBQUs7QUFDYixnQkFBSSxLQUFLLG9CQUFULEVBQStCO0FBQzNCLG9CQUFJLGlCQUFpQixLQUFLLE1BQUwsQ0FBWSxHQUFaLENBQXJCOztBQUVBLG9CQUFJLFNBQVMsS0FBSyxHQUFMLENBQVMsS0FBSyxRQUFkLEVBQXdCLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxpQkFBaUIsS0FBSyxTQUFsQyxDQUF4QixDQUFiO0FBQ0Esb0JBQUksTUFBTSxTQUFTLEtBQUssUUFBZCxJQUEwQixLQUFLLEdBQUwsR0FBVyxLQUFLLEdBQTFDLElBQWlELEtBQUssR0FBaEU7O0FBRUEscUJBQUssVUFBTCxDQUFnQixHQUFoQixFQUFxQixNQUFyQjtBQUNILGFBUEQsTUFPTyxJQUFJLEtBQUssd0JBQVQsRUFBbUM7QUFDdEMsb0JBQU0sTUFBTSxLQUFLLE1BQUwsQ0FBWSxHQUFaLENBQVo7QUFDQSxvQkFBSSxRQUFRLEtBQUsscUJBQUwsR0FBNkIsR0FBekM7QUFDQSx3QkFBUSxRQUFRLEtBQUssRUFBTCxDQUFRLDhCQUF4QjtBQUNBLG9CQUFJLFFBQVEsSUFBSSxLQUFLLEVBQUwsQ0FBUSw4QkFBcEIsSUFBc0QsUUFBUSxDQUFDLENBQUQsR0FBSyxLQUFLLEVBQUwsQ0FBUSw4QkFBL0UsRUFBK0c7QUFDM0cseUJBQUsscUJBQUwsR0FBNkIsR0FBN0I7QUFDQSx5QkFBSyxtQkFBTCxDQUF5QixLQUFLLDBCQUFMLEdBQWtDLEtBQTNEO0FBQ0g7QUFDSixhQVJNLE1BUUEsSUFBSSxLQUFLLGtCQUFULEVBQTZCO0FBQ2hDLG9CQUFNLFlBQVksS0FBSyxHQUFMLENBQVMscUJBQVQsRUFBbEI7QUFDQSxvQkFBTSxlQUFlLFVBQVUsSUFBVixJQUFrQixJQUFJLE9BQUosQ0FBWSxDQUFaLEVBQWUsT0FBakMsSUFBNEMsSUFBSSxPQUFKLENBQVksQ0FBWixFQUFlLE9BQWYsSUFBMEIsVUFBVSxLQUFoRixJQUNqQixVQUFVLEdBQVYsSUFBaUIsSUFBSSxPQUFKLENBQVksQ0FBWixFQUFlLE9BRGYsSUFDMEIsSUFBSSxPQUFKLENBQVksQ0FBWixFQUFlLE9BQWYsSUFBMEIsVUFBVSxNQURuRjs7QUFHQSxvQkFBSSxDQUFDLFlBQUwsRUFBbUI7QUFDZix5QkFBSywwQkFBTDtBQUNIO0FBQ0o7O0FBRUQsZ0JBQUksS0FBSyx3Q0FBVCxFQUFtRDtBQUMvQyxxQkFBSyx3Q0FBTCxHQUFnRCxJQUFJLE9BQUosQ0FBWSxDQUFaLENBQWhEO0FBQ0g7O0FBRUQsZ0JBQUksZUFBSjtBQUNBLGdCQUFJLGNBQUo7QUFDSDs7O21DQUVVLEcsRUFBSyxNLEVBQVE7QUFDcEIsaUJBQUssTUFBTCxDQUFZLFVBQVosQ0FBdUIsR0FBdkIsRUFBNEIsTUFBNUI7QUFDSDs7OzRCQUVTO0FBQ04sbUJBQU8sS0FBSyxNQUFMLENBQVksR0FBbkI7QUFDSDs7OzRCQUVTO0FBQ04sbUJBQU8sS0FBSyxNQUFMLENBQVksR0FBbkI7QUFDSDs7OzRCQUVTO0FBQ04sbUJBQU8sS0FBSyxNQUFMLENBQVksR0FBbkI7QUFDSDs7OzRCQUVXO0FBQ1IsbUJBQU8sS0FBSyxNQUFMLENBQVksS0FBbkI7QUFDSDs7OzRCQUVjO0FBQ1gsbUJBQU8sS0FBSyxNQUFMLENBQVksUUFBbkI7QUFDSDs7OzRCQUVRO0FBQ0wsbUJBQU8sS0FBSyxNQUFMLENBQVksRUFBbkI7QUFDSDs7OzRCQUVlO0FBQ1osbUJBQU8sS0FBSyxNQUFMLENBQVksU0FBbkI7QUFDSDs7OzRCQUV3QjtBQUNyQixtQkFBTyxLQUFLLE1BQUwsQ0FBWSxrQkFBbkI7QUFDSDs7OzRCQUVtQjtBQUNoQixtQkFBTyxLQUFLLE1BQUwsQ0FBWSxhQUFuQjtBQUNIOzs7MEJBRVMsRyxFQUFLO0FBQ1gsaUJBQUssTUFBTCxDQUFZLEtBQVosR0FBb0IsR0FBcEI7QUFDSCxTOzRCQUVXO0FBQ1IsbUJBQU8sS0FBSyxNQUFMLENBQVksS0FBbkI7QUFDSDs7OzRCQUVlO0FBQ1osbUJBQU8sS0FBSyxNQUFMLENBQVksU0FBbkI7QUFDSDs7Ozs7O0FBR0w7OztBQUNBLE9BQU8sT0FBUCxHQUFpQixXQUFqQjs7O0FDMWlCQTs7QUFFQTtBQUNBOzs7O0FBRUEsSUFBTSxjQUFjLFFBQVEsY0FBUixDQUFwQjtBQUNBLElBQU0sU0FBUyxRQUFRLFVBQVIsQ0FBZjtBQUNBLElBQU0sb0JBQW9CLFFBQVEscUJBQVIsQ0FBMUI7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkEsU0FBUyxNQUFULENBQWdCLE9BQWhCLEVBQXlCO0FBQ3JCLFFBQU0sUUFBUSxLQUFLLE1BQUwsR0FBYyxJQUFJLE1BQUosQ0FBVyxJQUFYLENBQTVCO0FBQ0EsV0FBTyxtQkFBUCxDQUEyQixPQUFPLGNBQVAsQ0FBc0IsS0FBdEIsQ0FBM0IsRUFDSyxNQURMLENBQ1k7QUFBQSxlQUFLLE9BQU8sTUFBTSxDQUFOLENBQVAsS0FBb0IsVUFBekI7QUFBQSxLQURaLEVBRUssT0FGTCxDQUVhO0FBQUEsZUFBSyxNQUFNLENBQU4sSUFBVyxNQUFNLENBQU4sRUFBUyxJQUFULENBQWMsS0FBZCxDQUFoQjtBQUFBLEtBRmI7O0FBSUE7Ozs7Ozs7OztBQVNBLFFBQU0sUUFBUSxLQUFLLEtBQUwsR0FBYSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBM0I7QUFDQSxVQUFNLFNBQU4sQ0FBZ0IsR0FBaEIsQ0FBb0IsT0FBcEI7QUFDQSxVQUFNLE9BQU4sR0FBZ0IsTUFBTSxTQUF0QjtBQUNBLFVBQU0sWUFBTixHQUFxQixNQUFNLGlCQUEzQjs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7QUFjQSxRQUFNLE1BQU0sS0FBSyxHQUFMLEdBQVcsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQXZCO0FBQ0EsUUFBSSxTQUFKLENBQWMsR0FBZCxDQUFrQixpQkFBbEI7QUFDQSxRQUFJLFdBQUosR0FBa0IsTUFBTSxXQUF4QjtBQUNBLFFBQUksS0FBSyxNQUFULEVBQWlCO0FBQ2IsWUFBSSxPQUFKLEdBQWMsTUFBTSxPQUFwQjtBQUNIO0FBQ0QsUUFBSSxXQUFKLENBQWdCLEtBQWhCO0FBQ0EsUUFBSSxZQUFKLEdBQW1CLE1BQU0sZUFBekI7QUFDQSxRQUFJLFVBQUosR0FBaUIsTUFBTSxVQUF2QjtBQUNBLGNBQVUsV0FBVyxFQUFyQjs7QUFFQTs7Ozs7OztBQU9BLFFBQU0sV0FBVyxLQUFLLFFBQUwsR0FBZ0IsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQWpDO0FBQ0EsYUFBUyxXQUFULENBQXFCLEdBQXJCOztBQUVBO0FBQ0EsU0FBSyxXQUFMLEdBQW1CLFVBQW5CO0FBQ0EsU0FBSyxHQUFMLEdBQVcsS0FBSyxNQUFMLEdBQWMsQ0FBekI7QUFDQSxTQUFLLEdBQUwsR0FBVyxHQUFYOztBQUVBO0FBQ0EsU0FBSyxJQUFNLEdBQVgsSUFBa0IsT0FBbEIsRUFBMkI7QUFDdkIsWUFBSSxRQUFRLGNBQVIsQ0FBdUIsR0FBdkIsQ0FBSixFQUFpQztBQUM3QixnQkFBTSxTQUFTLFFBQVEsR0FBUixDQUFmO0FBQ0Esb0JBQVEsR0FBUjs7QUFFSSxxQkFBSyxPQUFMO0FBQ0kseUJBQUssTUFBTCxHQUFjLE1BQWQ7QUFDQTs7QUFFSixxQkFBSyxPQUFMO0FBQ0ksK0JBQVcsTUFBWDtBQUNBLHlCQUFLLEdBQUwsR0FBVyxPQUFPLEdBQWxCO0FBQ0EseUJBQUssR0FBTCxHQUFXLE9BQU8sR0FBbEI7QUFDQSx5QkFBSyxXQUFMLEdBQW1CLE9BQU8sR0FBUCxHQUFhLE9BQU8sR0FBcEIsR0FBMEIsQ0FBN0M7QUFDQTs7QUFFSixxQkFBSyx3QkFBTDtBQUNJLHlCQUFLLHNCQUFMLEdBQThCLE1BQTlCO0FBQ0E7O0FBRUo7QUFDSSx3QkFDSSxJQUFJLE1BQUosQ0FBVyxDQUFYLE1BQWtCLEdBQWxCLElBQ0EsT0FBTyxPQUFPLFNBQVAsQ0FBaUIsR0FBakIsQ0FBUCxLQUFpQyxVQUZyQyxFQUdFO0FBQ0U7QUFDQTtBQUNBLDZCQUFLLEdBQUwsSUFBWSxNQUFaO0FBQ0g7QUFDRDs7QUExQlI7QUE2Qkg7QUFDSjs7QUFFRCxnQkFBWSxVQUFaLEVBQXdCLGFBQXhCLEVBQXVDLFFBQVEsNkJBQS9DOztBQUVBLFFBQUksS0FBSyxzQkFBVCxFQUFpQztBQUM3QixhQUFLLHNCQUFMLENBQTRCLElBQTVCO0FBQ0g7QUFDSjs7QUFFRCxPQUFPLFNBQVAsR0FBbUI7O0FBRWY7Ozs7Ozs7Ozs7O0FBV0EsUUFBSSxXQUFKLENBQWdCLFdBQWhCLEVBQTZCO0FBQ3pCLFlBQUksZ0JBQWdCLEtBQUssWUFBekIsRUFBdUM7QUFDbkM7QUFDSDs7QUFFRCxhQUFLLFlBQUwsR0FBb0IsV0FBcEI7O0FBRUE7Ozs7Ozs7Ozs7OztBQVlBLGFBQUssRUFBTCxHQUFVLGtCQUFrQixLQUFLLFlBQXZCLENBQVY7O0FBRUEsWUFBSSxDQUFDLEtBQUssRUFBVixFQUFjO0FBQ1Ysa0JBQU0sMENBQU47QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7OztBQWNBLGFBQUssU0FBTCxHQUFpQixLQUFLLEVBQUwsQ0FBUSxLQUF6Qjs7QUFFQSxhQUFLLEdBQUwsQ0FBUyxTQUFULEdBQXFCLEtBQUssR0FBTCxDQUFTLFNBQVQsQ0FBbUIsT0FBbkIsQ0FBMkIsd0JBQTNCLEVBQXFELFdBQXJELENBQXJCOztBQUVBLFlBQUksS0FBSyxHQUFMLENBQVMsS0FBVCxDQUFlLE9BQWYsSUFBMEIsS0FBSyxLQUFMLENBQVcsS0FBWCxDQUFpQixPQUEvQyxFQUF3RDtBQUNwRCxpQkFBSyxHQUFMLENBQVMsZUFBVCxDQUF5QixPQUF6QjtBQUNBLGlCQUFLLEtBQUwsQ0FBVyxlQUFYLENBQTJCLE9BQTNCO0FBQ0EsaUJBQUssTUFBTDtBQUNIO0FBQ0osS0E3RGM7QUE4RGYsUUFBSSxXQUFKLEdBQWtCO0FBQ2QsZUFBTyxLQUFLLFlBQVo7QUFDSCxLQWhFYzs7QUFrRWY7Ozs7Ozs7Ozs7QUFVQSxjQUFVLElBNUVLOztBQThFZiw0QkFBd0Isa0NBQVcsQ0FDbEMsQ0EvRWM7O0FBaUZmOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLFFBQUksV0FBSixDQUFnQixNQUFoQixFQUF3QjtBQUNwQixZQUFJLEtBQUssWUFBVCxFQUF1QjtBQUNuQixpQkFBSyxHQUFMLENBQVMsU0FBVCxDQUFtQixNQUFuQixDQUEwQixLQUFLLFlBQUwsR0FBb0IsS0FBSyxXQUFuRDtBQUNIOztBQUVELGFBQUssWUFBTCxHQUFvQixNQUFwQjs7QUFFQSxZQUFJLE1BQUosRUFBWTtBQUNSLGlCQUFLLEdBQUwsQ0FBUyxTQUFULENBQW1CLEdBQW5CLENBQXVCLFNBQVMsR0FBVCxHQUFlLEtBQUssV0FBM0M7QUFDSDtBQUNKLEtBM0djO0FBNEdmLFFBQUksV0FBSixHQUFrQjtBQUNkLGVBQU8sS0FBSyxZQUFaO0FBQ0gsS0E5R2M7O0FBZ0hmOzs7Ozs7Ozs7OztBQVdBLGVBQVcsQ0EzSEk7O0FBNkhmOzs7Ozs7Ozs7OztBQVdBLGVBQVcsSUF4SUk7O0FBMElmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkEsUUFBSSxLQUFKLENBQVUsTUFBVixFQUFrQjtBQUNkLFlBQU0sT0FBTyxPQUFPLElBQVAsQ0FBWSxTQUFTLE9BQU8sRUFBUCxFQUFXLE1BQVgsRUFBbUIsS0FBSyxVQUF4QixDQUFyQixDQUFiOztBQUVBLFlBQUksS0FBSyxNQUFULEVBQWlCO0FBQ2IsZ0JBQU0sTUFBTSxLQUFLLEdBQWpCO0FBQUEsZ0JBQ0ksVUFBVSxJQUFJLHFCQUFKLEVBRGQ7QUFBQSxnQkFFSSxZQUFZLElBQUksYUFGcEI7QUFBQSxnQkFHSSxnQkFBZ0IsVUFBVSxxQkFBVixFQUhwQjtBQUFBLGdCQUlJLEtBQUssS0FBSyxFQUpkOztBQU1BO0FBQ0E7O0FBRUEsaUJBQUssT0FBTCxDQUFhLFVBQVMsR0FBVCxFQUFjO0FBQ3ZCLG9CQUFJLE1BQU0sT0FBTyxHQUFQLENBQVY7QUFDQSxvQkFBSSxPQUFPLEVBQVgsRUFBZTtBQUNYLDBCQUFNLEdBQUcsR0FBSCxDQUFOO0FBQ0g7O0FBRUQsb0JBQUksQ0FBQyxNQUFNLE9BQU8sR0FBUCxDQUFOLENBQUwsRUFBeUI7QUFDckIsMEJBQU0sQ0FBQyxPQUFPLENBQVIsSUFBYSxJQUFuQjtBQUNILGlCQUZELE1BRU8sSUFBSSxLQUFLLElBQUwsQ0FBVSxHQUFWLENBQUosRUFBb0I7QUFDdkI7QUFDQTtBQUNBLHdCQUFNLFdBQVcsS0FBSyxHQUFMLENBQWpCO0FBQUEsd0JBQ0ksVUFBVSxRQUFRLFNBQVMsYUFBakIsSUFBa0MsUUFBUSxTQUFTLGNBQWpCLENBRGhEO0FBRUEsd0JBQUksT0FBSixFQUFhO0FBQ1QsOEJBQU0sU0FBUyxHQUFULEVBQWMsRUFBZCxJQUFvQixHQUFwQixHQUEwQixjQUFjLFNBQVMsSUFBdkIsQ0FBMUIsR0FBeUQsT0FBekQsR0FBbUUsSUFBekU7QUFDSDtBQUNKOztBQUVELG9CQUFJLEtBQUosQ0FBVSxHQUFWLElBQWlCLEdBQWpCO0FBQ0gsYUFuQkQ7QUFvQkg7O0FBRUQsYUFBSyxlQUFMO0FBQ0gsS0F0TWM7O0FBd01mLFFBQUksVUFBSixDQUFlLE1BQWYsRUFBdUI7QUFDbkIsWUFBTSxRQUFRLEtBQUssS0FBbkI7QUFDQSxZQUFNLE9BQU8sT0FBTyxJQUFQLENBQVksU0FBUyxPQUFPLEVBQVAsRUFBVyxNQUFYLENBQXJCLENBQWI7O0FBRUEsWUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDYixpQkFBSyxPQUFMLENBQWEsVUFBUyxHQUFULEVBQWM7QUFDdkIsb0JBQUksTUFBTSxPQUFPLEdBQVAsQ0FBVjs7QUFFQSxvQkFBSSxDQUFDLE1BQU0sT0FBTyxHQUFQLENBQU4sQ0FBTCxFQUF5QjtBQUNyQiwwQkFBTSxDQUFDLE9BQU8sQ0FBUixJQUFhLElBQW5CO0FBQ0g7O0FBRUQsc0JBQU0sS0FBTixDQUFZLEdBQVosSUFBbUIsR0FBbkI7QUFDSCxhQVJEO0FBU0g7O0FBRUQsY0FBTSxLQUFOLENBQVksT0FBWixHQUFzQixLQUF0Qjs7QUFFQSxhQUFLLGFBQUw7QUFDSCxLQTNOYzs7QUE2TmYsUUFBSSxVQUFKLENBQWUsTUFBZixFQUF1QjtBQUNuQixZQUFNLE9BQU8sT0FBTyxJQUFQLENBQVksU0FBUyxPQUFPLEVBQVAsRUFBVyxNQUFYLENBQXJCLENBQWI7O0FBRUEsWUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDYixnQkFBTSxRQUFRLEtBQUssUUFBbkI7O0FBRUEsaUJBQUssT0FBTCxDQUFhLFVBQVMsR0FBVCxFQUFjO0FBQ3ZCLG9CQUFJLE1BQU0sT0FBTyxHQUFQLENBQVY7O0FBRUEsb0JBQUksQ0FBQyxNQUFNLE9BQU8sR0FBUCxDQUFOLENBQUwsRUFBeUI7QUFDckIsMEJBQU0sQ0FBQyxPQUFPLENBQVIsSUFBYSxJQUFuQjtBQUNIOztBQUVELHNCQUFNLEtBQU4sQ0FBWSxHQUFaLElBQW1CLEdBQW5CO0FBQ0gsYUFSRDtBQVNIO0FBQ0osS0E3T2M7O0FBK09mOzs7Ozs7Ozs7Ozs7OztBQWNBLFlBQVEsSUE3UE87O0FBK1BmOzs7Ozs7Ozs7Ozs7QUFZQSxRQUFJLEtBQUosQ0FBVSxLQUFWLEVBQWlCO0FBQ2IsbUJBQVcsS0FBWDtBQUNBLGFBQUssR0FBTCxHQUFXLE1BQU0sR0FBakI7QUFDQSxhQUFLLEdBQUwsR0FBVyxNQUFNLEdBQWpCO0FBQ0EsYUFBSyxXQUFMLEdBQW1CLE1BQU0sR0FBTixHQUFZLE1BQU0sR0FBbEIsR0FBd0IsQ0FBM0M7QUFDQSxhQUFLLEtBQUwsR0FBYSxLQUFLLEtBQWxCLENBTGEsQ0FLWTtBQUM1QixLQWpSYztBQWtSZixRQUFJLEtBQUosR0FBWTtBQUNSLGVBQU8sRUFBRSxLQUFLLEtBQUssR0FBWixFQUFpQixLQUFLLEtBQUssR0FBM0IsRUFBUDtBQUNILEtBcFJjOztBQXNSZjs7Ozs7Ozs7Ozs7Ozs7QUFjQSxRQUFJLEtBQUosQ0FBVSxHQUFWLEVBQWU7QUFDWCxjQUFNLEtBQUssR0FBTCxDQUFTLEtBQUssR0FBZCxFQUFtQixLQUFLLEdBQUwsQ0FBUyxLQUFLLEdBQWQsRUFBbUIsR0FBbkIsQ0FBbkIsQ0FBTixDQURXLENBQ3dDO0FBQ25ELGFBQUssVUFBTCxDQUFnQixHQUFoQjtBQUNILEtBdlNjO0FBd1NmLFFBQUksS0FBSixHQUFZO0FBQ1IsZUFBTyxLQUFLLE1BQVo7QUFDSCxLQTFTYzs7QUE0U2Y7Ozs7Ozs7O0FBUUEsZ0JBQVksb0JBQVMsR0FBVCxFQUFjLE1BQWQsRUFBc0I7QUFDOUIsYUFBSyxNQUFMLEdBQWMsR0FBZDs7QUFFQTtBQUNBLFlBQUksS0FBSyxhQUFMLElBQXNCLEtBQUssYUFBTCxDQUFtQixLQUFuQixZQUFvQyxPQUE5RCxFQUF1RTtBQUNuRSxpQkFBSyxhQUFMLENBQW1CLEtBQW5CLENBQXlCLFNBQXpCLEdBQXFDLEtBQUssS0FBTCxDQUFXLEdBQVgsQ0FBckM7QUFDSDs7QUFFRDtBQUNBLFlBQUksS0FBSyxRQUFULEVBQW1CO0FBQ2YsaUJBQUssUUFBTCxDQUFjLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUIsS0FBSyxLQUFMLENBQVcsR0FBWCxDQUF6QjtBQUNIOztBQUVEO0FBQ0EsWUFBSSxXQUFXLFNBQWYsRUFBMEI7QUFDdEIscUJBQVMsQ0FBQyxNQUFNLEtBQUssR0FBWixLQUFvQixLQUFLLEdBQUwsR0FBVyxLQUFLLEdBQXBDLElBQTJDLEtBQUssUUFBekQ7QUFDSDtBQUNELGFBQUssS0FBTCxDQUFXLEtBQVgsQ0FBaUIsS0FBSyxFQUFMLENBQVEsT0FBekIsSUFBb0MsU0FBUyxJQUE3QztBQUNILEtBdFVjOztBQXdVZix1QkFBbUIsMkJBQVMsR0FBVCxFQUFjO0FBQzdCLFlBQU0sZ0JBQWdCLEtBQUssT0FBTCxDQUFhLGFBQWIsQ0FBMkIscUJBQTNCLEVBQXRCO0FBQUEsWUFDSSxXQUFXLEtBQUssRUFBTCxDQUFRLElBRHZCO0FBQUEsWUFFSSxZQUFZLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxLQUFLLE9BQUwsQ0FBYSxRQUFiLElBQXlCLGNBQWMsUUFBZCxDQUFyQyxDQUZoQjtBQUFBLFlBR0ksU0FBUyxDQUFDLE1BQU0sS0FBSyxHQUFaLEtBQW9CLEtBQUssR0FBTCxHQUFXLEtBQUssR0FBcEMsSUFBMkMsU0FIeEQ7O0FBS0EsYUFBSyxPQUFMLENBQWEsS0FBYixDQUFtQixLQUFLLEVBQUwsQ0FBUSxPQUEzQixJQUFzQyxDQUFDLE1BQUQsR0FBVSxJQUFoRDtBQUNILEtBL1VjOztBQWlWZjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQSxZQUFRLGdCQUFTLFNBQVQsRUFBb0IsU0FBcEIsRUFBK0IsZ0JBQS9CLEVBQWlEO0FBQ3JELFlBQUkscUJBQXFCLFNBQXpCLEVBQW9DO0FBQ2hDLGlCQUFLLFdBQUwsR0FBbUIsZ0JBQW5CO0FBQ0g7O0FBRUQsWUFBTSxNQUFNLEtBQUssR0FBakI7O0FBRUEsWUFBSSxDQUFDLElBQUksVUFBVCxFQUFxQjtBQUNqQixtQkFEaUIsQ0FDVDtBQUNYOztBQUVELFlBQU0sWUFBWSxLQUFLLFFBQUwsQ0FBYyxhQUFoQztBQUFBLFlBQ0ksZ0JBQWdCLFVBQVUscUJBQVYsRUFEcEI7O0FBR0E7QUFDQSxZQUFJLFFBQU8sU0FBUCx5Q0FBTyxTQUFQLE9BQXFCLFFBQXpCLEVBQW1DO0FBQy9CLHdCQUFZLFNBQVo7QUFDSDs7QUFFRCxhQUFLLEtBQUwsR0FBYSxLQUFLLFNBQUwsR0FBaUIsYUFBYSxLQUFLLFNBQWhEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQUksS0FBSyxPQUFULEVBQWtCO0FBQ2QsZ0JBQUksQ0FBQyxLQUFLLFFBQVYsRUFBb0I7QUFDaEIscUJBQUssUUFBTCxHQUFnQixLQUFLLGlCQUFyQjtBQUNBLHFCQUFLLFdBQUwsR0FBbUIsS0FBSyxPQUFMLENBQWEsS0FBSyxFQUFMLENBQVEsSUFBckIsQ0FBbkI7QUFDQSxxQkFBSyxHQUFMLEdBQVcsQ0FBWDtBQUNBLHFCQUFLLEdBQUwsR0FBVyxLQUFLLFdBQUwsR0FBbUIsQ0FBOUI7QUFDSDtBQUNKOztBQUVELGFBQUssYUFBTCxHQUFxQixjQUFjLEtBQUssRUFBTCxDQUFRLElBQXRCLENBQXJCO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLEtBQUssYUFBTCxHQUFxQixDQUF0Qzs7QUFFQSxZQUFNLFFBQVEsS0FBSyxLQUFuQjtBQUNBLGFBQUssYUFBTCxHQUFxQixLQUFLLGFBQUwsSUFBc0IsS0FBSyxpQkFBTCxFQUEzQztBQUNBLGFBQUssYUFBTDtBQUNBLGFBQUssS0FBTCxHQUFhLEtBQWI7QUFDQSxhQUFLLGVBQUw7O0FBRUEsWUFBSSxLQUFLLFNBQUwsS0FBbUIsSUFBdkIsRUFBNkI7QUFDekIsc0JBQVUsZ0JBQVYsQ0FBMkIsT0FBM0IsRUFBb0MsS0FBSyxNQUFMLENBQVksT0FBaEQ7QUFDQSxzQkFBVSxnQkFBVixDQUEyQixZQUEzQixFQUF5QyxLQUFLLE1BQUwsQ0FBWSxZQUFyRDtBQUNBLHNCQUFVLGdCQUFWLENBQTJCLFdBQTNCLEVBQXdDLEtBQUssTUFBTCxDQUFZLFdBQXBEO0FBQ0Esc0JBQVUsZ0JBQVYsQ0FBMkIsVUFBM0IsRUFBdUMsS0FBSyxNQUFMLENBQVksVUFBbkQ7QUFDSDs7QUFFRCxlQUFPLElBQVA7QUFDSCxLQXRaYzs7QUF3WmYscUJBQWlCLDJCQUFXO0FBQ3hCLFlBQU0saUJBQWlCLE9BQU8sZ0JBQVAsQ0FBd0IsS0FBSyxHQUE3QixDQUF2Qjs7QUFFQSxZQUFJLEtBQUssV0FBTCxLQUFxQixZQUF6QixFQUF1QztBQUNuQyxpQkFBSyxRQUFMLENBQWMsS0FBZCxDQUFvQixNQUFwQixHQUE2QixlQUFlLE1BQTVDO0FBQ0EsaUJBQUssUUFBTCxDQUFjLEtBQWQsQ0FBb0IsS0FBcEIsR0FBNEIsTUFBNUI7QUFDQSxpQkFBSyxRQUFMLENBQWMsS0FBZCxDQUFvQixNQUFwQixHQUE2QixHQUE3QjtBQUNILFNBSkQsTUFJTztBQUNILGlCQUFLLFFBQUwsQ0FBYyxLQUFkLENBQW9CLE1BQXBCLEdBQTZCLE1BQTdCO0FBQ0EsaUJBQUssUUFBTCxDQUFjLEtBQWQsQ0FBb0IsS0FBcEIsR0FBNEIsZUFBZSxLQUEzQztBQUNBLGlCQUFLLFFBQUwsQ0FBYyxLQUFkLENBQW9CLEtBQXBCLEdBQTRCLEdBQTVCO0FBQ0g7QUFDSixLQXBhYzs7QUFzYWY7Ozs7Ozs7Ozs7O0FBV0EsZUFBVyxtQkFBUyxXQUFULEVBQXNCO0FBQzdCLGVBQU8sS0FBSyxZQUFMLENBQWtCLFVBQWxCLEVBQThCLFdBQTlCLENBQVA7QUFDSCxLQW5iYzs7QUFxYmY7Ozs7Ozs7QUFPQSxtQkFBZSx1QkFBUyxXQUFULEVBQXNCO0FBQ2pDLGVBQU8sS0FBSyxZQUFMLENBQWtCLFNBQWxCLEVBQTZCLFdBQTdCLENBQVA7QUFDSCxLQTliYzs7QUFnY2Y7Ozs7Ozs7O0FBUUEsa0JBQWMsc0JBQVMsUUFBVCxFQUFtQixXQUFuQixFQUFnQztBQUMxQyxZQUFJLENBQUMsV0FBTCxFQUFrQjtBQUNkLG1CQUFPLEtBQUssVUFBWjtBQUNILFNBRkQsTUFFTyxJQUFJLHVCQUF1QixNQUF2QixJQUFpQyxZQUFZLFdBQVosS0FBNEIsS0FBSyxXQUF0RSxFQUFtRjtBQUN0RixnQkFBTSxhQUFhLE9BQU8sZ0JBQVAsQ0FBd0IsWUFBWSxHQUFwQyxDQUFuQjtBQUFBLGdCQUNJLE1BQU0sa0JBQWtCLFlBQVksV0FBOUIsQ0FEVjtBQUVBLGlCQUFLLFVBQUwsR0FBa0IsRUFBbEI7QUFDQSxpQkFBSyxVQUFMLENBQWdCLFFBQWhCLElBQTRCLFdBQVcsSUFBSSxTQUFmLElBQTRCLENBQXhEO0FBQ0g7QUFDRCxlQUFPLElBQVAsQ0FUMEMsQ0FTN0I7QUFDaEIsS0FsZGM7O0FBb2RmLHVCQUFtQiwyQkFBUyxRQUFULEVBQW1CLFlBQW5CLEVBQWlDO0FBQ2hELGFBQUssVUFBTCxHQUFrQixLQUFLLFVBQUwsR0FBa0IsS0FBSyxVQUF2QixHQUFvQyxFQUF0RDtBQUNBLGFBQUssVUFBTCxDQUFnQixRQUFoQixJQUE0QixlQUFlLElBQTNDO0FBQ0EsZUFBTyxJQUFQO0FBQ0gsS0F4ZGM7O0FBMGRmOzs7Ozs7QUFNQSxtQkFBZSx5QkFBVztBQUN0QixZQUFNLEtBQUssS0FBSyxFQUFoQjtBQUFBLFlBQ0ksWUFBWSxPQUFPLGdCQUFQLENBQXdCLEtBQUssS0FBN0IsQ0FEaEI7QUFBQSxZQUVJLHFCQUFxQixTQUFTLFVBQVUsR0FBRyxhQUFiLENBQVQsQ0FGekI7QUFBQSxZQUdJLHNCQUFzQixTQUFTLFVBQVUsR0FBRyxjQUFiLENBQVQsQ0FIMUI7QUFBQSxZQUlJLGVBQWUscUJBQXFCLG1CQUp4QztBQUFBLFlBS0ksVUFBVSxLQUFLLEdBQUwsQ0FBUyxxQkFBVCxHQUFpQyxHQUFHLElBQXBDLElBQTRDLFlBTDFEO0FBQUEsWUFNSSxZQUFZLEtBQUssR0FBTCxDQUFTLEVBQVQsRUFBYSxVQUFVLEtBQUssYUFBZixHQUErQixLQUFLLFdBQWpELENBTmhCOztBQVFBLFlBQU0sZ0JBQWdCLEtBQUssUUFBTCxDQUFjLEtBQWQsQ0FBb0IsVUFBMUM7QUFDQSxZQUFJLEtBQUssYUFBTCxHQUFxQixLQUFLLFdBQTlCLEVBQTJDO0FBQ3ZDLGlCQUFLLFFBQUwsQ0FBYyxLQUFkLENBQW9CLFVBQXBCLEdBQWlDLFNBQWpDO0FBQ0EsaUJBQUssS0FBTCxDQUFXLEtBQVgsQ0FBaUIsR0FBRyxJQUFwQixJQUE0QixZQUFZLElBQXhDO0FBQ0gsU0FIRCxNQUdPO0FBQ0gsaUJBQUssUUFBTCxDQUFjLEtBQWQsQ0FBb0IsVUFBcEIsR0FBaUMsUUFBakM7QUFDSDs7QUFFRCxZQUFJLGtCQUFrQixLQUFLLFFBQUwsQ0FBYyxLQUFkLENBQW9CLFVBQXRDLElBQW9ELEtBQUssc0JBQTdELEVBQXFGO0FBQ2pGLGlCQUFLLHNCQUFMLENBQTRCLEtBQUssUUFBTCxDQUFjLEtBQWQsQ0FBb0IsVUFBcEIsS0FBbUMsU0FBL0Q7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7O0FBWUEsYUFBSyxRQUFMLEdBQWdCLFVBQVUsU0FBVixHQUFzQixZQUF0Qzs7QUFFQSxhQUFLLGtCQUFMLEdBQTBCLGtCQUExQixDQW5Dc0IsQ0FtQ3dCO0FBQ2pELEtBcGdCYzs7QUFzZ0JmOzs7OztBQUtBLFlBQVEsa0JBQVc7QUFDZixhQUFLLEdBQUwsQ0FBUyxXQUFULEdBQXVCLElBQXZCO0FBQ0EsYUFBSyxVQUFMLENBQWdCLFdBQWhCO0FBQ0EsYUFBSyxVQUFMLENBQWdCLFNBQWhCOztBQUVBLFlBQU0sWUFBWSxLQUFLLFFBQUwsQ0FBYyxhQUFoQztBQUNBLFlBQUksVUFBVSxVQUFkLEVBQTBCO0FBQ3RCLHNCQUFVLFVBQVYsQ0FBcUIsT0FBckIsRUFBOEIsS0FBSyxNQUFMLENBQVksT0FBMUM7QUFDSDs7QUFFRCxhQUFLLEdBQUwsQ0FBUyxPQUFULEdBQ0ksS0FBSyxLQUFMLENBQVcsT0FBWCxHQUNJLEtBQUssS0FBTCxDQUFXLGFBQVgsR0FDSSxLQUFLLEtBQUwsQ0FBVyxVQUFYLEdBQXdCLElBSHBDOztBQUtBLGFBQUssR0FBTCxDQUFTLE1BQVQ7QUFDSCxLQTNoQmM7O0FBNmhCZjs7Ozs7Ozs7Ozs7O0FBWUEsdUJBQW1CLDZCQUFXO0FBQzFCLFlBQUksc0JBQUo7QUFBQSxZQUNJLG1CQUFtQixTQUFTLGFBQVQsT0FBMkIsS0FBSyxZQUFoQyxxQkFBOEQsU0FBUyxhQUFULENBQXVCLGFBQXZCLENBRHJGOztBQUdBLFlBQUksZ0JBQUosRUFBc0I7QUFDbEIsZ0JBQU0seUJBQXlCLENBQUMsV0FBRCxFQUFjLFdBQWQsRUFBMkIsU0FBM0IsRUFBc0MsT0FBdEMsQ0FBL0I7QUFBQSxnQkFDSSxPQUFPLFNBQVMsYUFBVCxDQUF1QixJQUF2QixDQURYOztBQUdBLG1DQUF1QixPQUF2QixDQUErQixVQUFTLFFBQVQsRUFBbUI7QUFDOUMscUJBQUssU0FBTCxJQUFrQixrQkFBa0IsUUFBbEIsR0FBNkIsSUFBN0IsR0FBb0MsU0FBUyxPQUFULENBQWlCLE9BQWpCLEVBQTBCLEVBQTFCLENBQXBDLEdBQW9FLFNBQXRGO0FBQ0gsYUFGRDs7QUFJQSw2QkFBaUIsV0FBakIsQ0FBNkIsSUFBN0I7O0FBRUEsNEJBQWdCLEVBQWhCO0FBQ0EsbUNBQXVCLE9BQXZCLENBQStCLFVBQVMsUUFBVCxFQUFtQjtBQUM5Qyw4QkFBYyxRQUFkLElBQTBCLEtBQUssc0JBQUwsQ0FBNEIsUUFBNUIsRUFBc0MsQ0FBdEMsQ0FBMUI7QUFDSCxhQUZEO0FBR0g7O0FBRUQsZUFBTyxhQUFQO0FBQ0gsS0E5akJjOztBQWdrQmYsZ0JBQVksb0JBQVMsT0FBVCxFQUFrQjtBQUMxQixhQUFLLE1BQUwsQ0FBWSxVQUFaLENBQXVCLE9BQXZCO0FBQ0g7QUFsa0JjLENBQW5COztBQXFrQkEsU0FBUyxNQUFULENBQWdCLEdBQWhCLEVBQXFCO0FBQ2pCLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxVQUFVLE1BQTlCLEVBQXNDLEVBQUUsQ0FBeEMsRUFBMkM7QUFDdkMsWUFBTSxPQUFPLFVBQVUsQ0FBVixDQUFiO0FBQ0EsWUFBSSxJQUFKLEVBQVU7QUFDTixpQkFBSyxJQUFNLEdBQVgsSUFBa0IsSUFBbEIsRUFBd0I7QUFDcEIsb0JBQUksR0FBSixJQUFXLEtBQUssR0FBTCxDQUFYO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsV0FBTyxHQUFQO0FBQ0g7O0FBRUQsU0FBUyxVQUFULENBQW9CLEtBQXBCLEVBQTJCO0FBQ3ZCLFFBQU0sT0FBTyxPQUFPLElBQVAsQ0FBWSxLQUFaLENBQWI7QUFBQSxRQUNJLFFBQVEsS0FBSyxNQUFMLEtBQWdCLENBQWhCLElBQ0osT0FBTyxNQUFNLEdBQWIsS0FBcUIsUUFEakIsSUFFSixPQUFPLE1BQU0sR0FBYixLQUFxQixRQUZqQixJQUdKLE1BQU0sR0FBTixJQUFhLE1BQU0sR0FKM0I7O0FBTUEsUUFBSSxDQUFDLEtBQUwsRUFBWTtBQUNSLGNBQU0sd0JBQU47QUFDSDtBQUNKOztBQUVELElBQU0sT0FBTztBQUNULFNBQUssVUFESTtBQUVULFlBQVEsVUFGQztBQUdULFlBQVEsVUFIQztBQUlULFVBQU0sWUFKRztBQUtULFdBQU8sWUFMRTtBQU1ULFdBQU87QUFORSxDQUFiOztBQVNBLElBQUksbUJBQUosQyxDQUFnQjtBQUNoQjtBQUNBLGFBQWEsZ29CQUFiOztBQUVBOztBQUVBLFNBQVMsS0FBVCxDQUFlLEdBQWYsRUFBb0I7QUFDaEIsVUFBTSxjQUFjLEdBQXBCO0FBQ0g7O0FBRUQ7QUFDQSxPQUFPLE9BQVAsR0FBaUIsTUFBakI7OztBQ3B2QkE7O0FBRUE7O0FBRUEsT0FBTyxPQUFQLEdBQWlCO0FBQ2IsY0FBVTtBQUNOLG9CQUFZLFNBRE47QUFFTixjQUFNLE9BRkE7QUFHTixjQUFNLFFBSEE7QUFJTixpQkFBUyxPQUpIO0FBS04sZ0JBQVEsTUFMRjtBQU1OLGlCQUFTLEtBTkg7QUFPTixrQkFBVSxRQVBKO0FBUU4sdUJBQWUsV0FSVDtBQVNOLHdCQUFnQixjQVRWO0FBVU4sbUJBQVcsT0FWTDtBQVdOLGVBQU8sUUFYRDtBQVlOO0FBQ0Esd0NBQWdDLEdBYjFCO0FBY04sbUNBQTJCLEtBZHJCO0FBZU4sd0NBQWdDO0FBZjFCLEtBREc7QUFrQmIsZ0JBQVk7QUFDUixvQkFBWSxTQURKO0FBRVIsY0FBTSxPQUZFO0FBR1IsY0FBTSxPQUhFO0FBSVIsaUJBQVMsUUFKRDtBQUtSLGdCQUFRLEtBTEE7QUFNUixpQkFBUyxNQU5EO0FBT1Isa0JBQVUsT0FQRjtBQVFSLHVCQUFlLFlBUlA7QUFTUix3QkFBZ0IsYUFUUjtBQVVSLG1CQUFXLFFBVkg7QUFXUixlQUFPLFFBWEM7QUFZUjtBQUNBLHdDQUFnQyxDQWJ4QjtBQWNSLG1DQUEyQixLQWRuQjtBQWVSLHdDQUFnQztBQWZ4QjtBQWxCQyxDQUFqQjs7O0FDSkE7QUFDQTs7Ozs7O0FBRUEsSUFBTSxRQUFRLFFBQVEsWUFBUixDQUFkOztBQUVBOztBQUVBLFNBQVMsS0FBVCxDQUFlLEtBQWYsRUFBc0IsSUFBdEIsRUFBNEI7QUFDeEIsUUFBTSxTQUFTLEVBQWY7QUFDQSxTQUFLLElBQUksTUFBTSxNQUFNLFVBQU4sQ0FBaUIsQ0FBakIsQ0FBVixFQUErQixNQUFNLEtBQUssVUFBTCxDQUFnQixDQUFoQixDQUExQyxFQUE4RCxPQUFPLEdBQXJFLEVBQTBFLEVBQUUsR0FBNUUsRUFBaUY7QUFDN0UsZUFBTyxJQUFQLENBQVksT0FBTyxZQUFQLENBQW9CLEdBQXBCLENBQVo7QUFDSDtBQUNELFdBQU8sTUFBUDtBQUNIOztBQUVELElBQU0sS0FBSyxNQUFNLEdBQU4sRUFBVyxHQUFYLENBQVg7O0FBRUEsU0FBUyxJQUFULENBQWMsQ0FBZCxFQUFpQjtBQUNiLFdBQU8sQ0FBQyxLQUFLLEVBQUwsR0FBVSxLQUFLLEVBQUwsRUFBUyxDQUFDLElBQUksRUFBSixJQUFVLENBQVgsSUFBZ0IsQ0FBekIsQ0FBVixHQUF3QyxFQUF6QyxJQUErQyxHQUFHLElBQUksRUFBSixJQUFVLENBQWIsQ0FBdEQ7QUFDSDs7QUFFRCxTQUFTLFlBQVQsQ0FBc0IsTUFBdEIsRUFBOEI7QUFDMUIsUUFBTSxrQkFBa0IsU0FBbEIsZUFBa0IsQ0FBQyxDQUFELEVBQU87QUFDM0IsWUFBSSxZQUFZLENBQWhCO0FBQ0EsWUFBSSxhQUFhLE9BQU8sU0FBUCxLQUFxQixRQUF0QyxFQUFnRDtBQUM1QyxnQkFBTSxTQUFTLFVBQVUsU0FBVixDQUFvQixNQUFwQixHQUE2QixVQUFVLFNBQVYsQ0FBb0IsTUFBakQsR0FBMEQsU0FBekU7QUFDQSx3QkFBWTtBQUFBLHVCQUFTLE9BQU8sRUFBRSxjQUFGLEVBQVUsWUFBVixFQUFpQixRQUFRLE1BQXpCLEVBQVAsQ0FBVDtBQUFBLGFBQVo7QUFDSDtBQUNELGVBQU8sU0FBUDtBQUNILEtBUEQ7O0FBU0EsUUFBSSxnQkFBZ0IsZ0JBQWdCLFVBQVUsT0FBTyxZQUFqQyxDQUFwQjtBQUNBLFFBQUksa0JBQWtCLGdCQUFnQixVQUFVLE9BQU8sa0JBQWpDLENBQXRCOztBQUVBLFFBQU0sVUFBVSxTQUFWLE9BQVUsQ0FBQyxJQUFEO0FBQUEsMENBQVUsSUFBVjtBQUFVLGdCQUFWO0FBQUE7O0FBQUEsZUFBb0IsUUFBUSxPQUFPLElBQVAsS0FBZ0IsVUFBekIsR0FBdUMsc0JBQVEsSUFBUixDQUF2QyxHQUF1RCxLQUFLLENBQUwsQ0FBMUU7QUFBQSxLQUFoQjs7QUFFQSxXQUFPLFVBQUMsS0FBRCxFQUFRLFFBQVIsRUFBcUI7QUFDeEIsWUFBSSxRQUFPLFFBQVAseUNBQU8sUUFBUCxPQUFvQixRQUF4QixFQUFrQztBQUM5Qix1QkFBVyxTQUFTLGFBQVQsR0FBeUIsU0FBUyxhQUFULENBQXVCLFNBQWhELEdBQTRELFNBQVMsU0FBaEY7QUFDSDtBQUNELFlBQUksT0FBTyxRQUFQLEtBQW9CLFNBQXhCLEVBQW1DO0FBQy9CLHVCQUFXLEtBQVg7QUFDSDtBQUNELGVBQU8sUUFBUSxXQUFXLGVBQVgsR0FBNkIsYUFBckMsRUFBb0QsS0FBcEQsQ0FBUDtBQUNILEtBUkQ7QUFTSDs7QUFFRCxTQUFTLGNBQVQsQ0FBd0IsT0FBeEIsRUFBaUM7QUFDN0IsUUFBTSxTQUFTLEVBQWY7O0FBRUEsUUFBTSxjQUFjLEtBQUssVUFBTCxDQUFnQixvQkFBcEM7QUFDQSxRQUFNLHFCQUFxQixLQUFLLFVBQUwsQ0FBZ0Isa0JBQTNDOztBQUVBLFFBQU0sc0JBQXNCLEtBQUssbUJBQWpDOztBQUVBLFFBQU0scUJBQXFCLEtBQUssVUFBTCxDQUFnQixrQkFBM0M7O0FBRUEsUUFBTSxPQUFPLElBQWI7O0FBRUEsUUFBTSxPQUFPLEVBQWI7O0FBRUEsUUFBTSxLQUFLLE1BQU0sR0FBTixFQUFXLEdBQVgsQ0FBWDs7QUFFQSxRQUFJLHFCQUFxQixDQUF6QjtBQUNBLFFBQUksZUFBZSxDQUFuQjs7QUFFQSxhQUFTLGlCQUFULENBQTJCLFNBQTNCLEVBQXNDLGVBQXRDLEVBQW9GO0FBQUEsWUFBN0IsbUJBQTZCLHVFQUFQLEtBQU87O0FBQ2hGLFlBQUksZUFBZSxZQUFZLENBQS9CO0FBQ0EsWUFBSSxvQkFBb0IsS0FBeEI7O0FBRUEsd0JBQWdCLE9BQWhCLENBQXdCLFVBQUMsRUFBRCxFQUFRO0FBQzVCLGdCQUFNLDBCQUEwQixHQUFHLG1CQUFILElBQTBCLEdBQUcsT0FBN0Q7O0FBRUEsZ0JBQU0sa0JBQWtCLENBQUMsbUJBQUQsSUFBd0IsdUJBQWhEO0FBQ0EsZ0JBQUksZUFBSixFQUFxQjtBQUNqQixvQ0FBb0IsSUFBcEI7QUFDQSxvQkFBTSxpQkFBaUIsR0FBRyxlQUFILEtBQXVCLFNBQXZCLElBQ2hCLEdBQUcsZUFBSCxLQUF1QixNQURQLElBRWhCLEdBQUcsZUFBSCxLQUF1QixnQkFGOUI7O0FBSUEsb0JBQUksR0FBRyxRQUFILElBQWUsR0FBRyxRQUFILENBQVksTUFBWixHQUFxQixDQUF4QyxFQUEyQztBQUN2QyxzQ0FBa0IsWUFBbEIsRUFBZ0MsR0FBRyxRQUFuQyxFQUE2QyxjQUE3QztBQUNIO0FBQ0o7QUFDSixTQWREOztBQWdCQSxZQUFJLGVBQWUsWUFBZixJQUErQixpQkFBbkMsRUFBc0Q7QUFDbEQsMkJBQWUsWUFBZjtBQUNIO0FBQ0o7O0FBRUQsYUFBUyxpQkFBVCxHQUE2QjtBQUN6QixlQUFPO0FBQ0gsb0JBQVE7QUFDSix1QkFBTztBQUNILCtCQUFXLElBRFIsRUFDYztBQUNqQiwwQkFBTSxXQUZILEVBRWdCO0FBQ25CLDZDQUF5QixXQUh0QixFQUdtQztBQUN0Qyw4QkFBVSxJQUpQLEVBSWE7QUFDaEIscUNBQWlCLEtBQUssZ0JBQUwsR0FBd0IsS0FBSyxnQkFBN0IsR0FBZ0QsS0FBSyxVQUFMLENBQWdCLGlCQUw5RSxFQUtpRztBQUNwRyw0QkFBUSxNQU5MO0FBT0gsNkNBQXlCLGtCQVB0QjtBQVFILG9DQUFnQjtBQVJiO0FBREg7QUFETCxTQUFQO0FBY0g7O0FBRUQsc0JBQWtCLENBQWxCLEVBQXFCLE9BQXJCOztBQUVBLGFBQVMsWUFBVCxDQUFzQixZQUF0QixFQUFtRztBQUFBLFlBQS9ELFdBQStELHVFQUFqRCxDQUFpRDtBQUFBLFlBQTlDLGlCQUE4Qyx1RUFBMUIsS0FBMEI7QUFBQSxZQUFuQixZQUFtQix1RUFBSixFQUFJOztBQUMvRixZQUFNLFNBQVMsS0FBSyxrQkFBTCxDQUFmOztBQUVBLFlBQU0sZUFBZSxTQUFmLFlBQWUsQ0FBQyxNQUFELEVBQVMsSUFBVDtBQUFBLG1CQUFtQjtBQUNwQyw4QkFEb0M7QUFFcEMsMEJBRm9DO0FBR3BDLDBDQUhvQztBQUlwQyx1QkFBTyxhQUFhLEtBSmdCO0FBS3BDLHdCQUFRLGFBQWEsTUFMZTtBQU1wQyw2QkFBYSxhQUFhLFdBTlU7QUFPcEMsMkJBQVcsYUFBYSxZQUFiLEtBQThCLFNBUEw7QUFRcEMsd0JBQVEsSUFSNEI7QUFTcEMsOEJBQWMsYUFBYSxZQVRTO0FBVXBDLGlDQUFpQixtQkFWbUI7QUFXcEMsd0JBQVE7QUFYNEIsYUFBbkI7QUFBQSxTQUFyQjs7QUFjQSxZQUFJLFlBQUosRUFBa0I7QUFDZCxnQkFBSSxxQkFBcUIsQ0FBQyxhQUFhLG1CQUFuQyxJQUEwRCxDQUFDLGFBQWEsT0FBNUUsRUFBcUY7QUFDakYsdUJBQU8sRUFBUDtBQUNIOztBQUVELGdCQUFJLENBQUMsQ0FBQyxhQUFhLFFBQWYsSUFBMkIsYUFBYSxRQUFiLENBQXNCLE1BQXRCLEdBQStCLENBQTlELEVBQWlFO0FBQzdELG9CQUFJLHNCQUFzQixFQUExQjtBQUNBLG9CQUFNLGlCQUFpQixhQUFhLGVBQWIsSUFDaEIsYUFBYSxlQUFiLEtBQWlDLE1BRGpCLElBRWhCLGFBQWEsZUFBYixLQUFpQyxnQkFGeEM7QUFHQSw2QkFBYSxRQUFiLENBQXNCLE9BQXRCLENBQThCLFVBQUMsRUFBRCxFQUFRO0FBQ2xDLHdCQUFNLGlEQUF3QixZQUF4QixJQUFzQyxhQUFhLE9BQW5ELEVBQU47QUFDQSx1RUFBMEIsbUJBQTFCLHNCQUFrRCxhQUFhLEVBQWIsRUFBaUIsY0FBYyxDQUEvQixFQUFrQyxjQUFsQyxFQUFrRCxpQkFBbEQsQ0FBbEQ7QUFDSCxpQkFIRDs7QUFLQSxvQkFBSSxvQkFBb0IsTUFBcEIsS0FBK0IsQ0FBbkMsRUFBc0M7QUFDbEMsd0JBQU0sZ0JBQWdCLGFBQWEsVUFBYixHQUEwQixpQkFBaEQ7QUFDQSx3QkFBTSxRQUFPLGlCQUFpQixNQUE5Qjs7QUFFQSxnRUFBbUIsWUFBbkIsSUFBaUMsYUFBYSxPQUE5QztBQUNBLDJCQUFPLElBQVAsQ0FBWSxhQUFhLFVBQVUsRUFBdkIsRUFBMkIsS0FBM0IsQ0FBWjtBQUNBOztBQUVBLHdCQUFJLGFBQUosRUFBbUI7QUFDZiw0QkFBSSxDQUFDLEtBQUssV0FBTCxDQUFMLEVBQXdCO0FBQ3BCLGlDQUFLLFdBQUwsSUFBb0IsbUJBQXBCO0FBQ0g7QUFDRCw0QkFBSSxVQUFVLGVBQWUsV0FBZixHQUE2QixDQUEzQztBQUNBLDRCQUFJLGFBQWMscUJBQXFCLGFBQWEsbUJBQWxDLElBQXlELGFBQWEsbUJBQWIsQ0FBaUMsTUFBM0YsR0FDWCxhQUFhLG1CQURGLEdBRVgsYUFBYSxVQUFiLElBQTJCLEVBRmpDO0FBR0EsNkJBQUssV0FBTCxFQUFrQixhQUFsQixJQUFtQztBQUMvQixxQ0FBUyxDQURzQjtBQUUvQixtQ0FBTyxVQUZ3QjtBQUcvQixtQ0FBTyxhQUFhLEtBSFc7QUFJL0IsNkNBQWlCLGFBQWEsUUFKQztBQUsvQixxQ0FBUyxhQUFhLE9BTFM7QUFNL0IsaURBQXFCLGFBQWEsYUFOSDtBQU8vQiw2Q0FBaUIsYUFBYTtBQVBDLHlCQUFuQzs7QUFVQSw0QkFBSSxVQUFVLENBQWQsRUFBaUI7QUFDYjtBQUNBLGlDQUFLLGNBQWMsQ0FBbkIsRUFBc0IsYUFBdEIsSUFBdUM7QUFDbkMseUNBQVMsT0FEMEI7QUFFbkMsdUNBQU8sT0FGNEI7QUFHbkMsdUNBQU8sYUFBYTtBQUhlLDZCQUF2QztBQUtIOztBQUVELDRCQUFJLFVBQVUsQ0FBZCxFQUFpQjtBQUNiLGlDQUFLLElBQUksSUFBSSxjQUFjLENBQTNCLEVBQThCLElBQUksWUFBbEMsRUFBZ0QsR0FBaEQsRUFBcUQ7QUFDakQsb0NBQUksQ0FBQyxLQUFLLENBQUwsQ0FBTCxFQUFjO0FBQ1YseUNBQUssQ0FBTCxJQUFVLG1CQUFWO0FBQ0g7QUFDRCxxQ0FBSyxDQUFMLEVBQVEsYUFBUixJQUF5QjtBQUNyQiw2Q0FBUyxVQUFVLENBREU7QUFFckIsc0RBQWtCLElBRkc7QUFHckIsb0RBQWdCLFdBSEs7QUFJckIsMkNBQU8sYUFBYTtBQUpDLGlDQUF6QjtBQU1IO0FBQ0o7QUFDSjs7QUFFRCwyQkFBTyxDQUFDLEtBQUQsQ0FBUDtBQUNILGlCQW5ERCxNQW1ETztBQUNILHdCQUFJLENBQUMsS0FBSyxXQUFMLENBQUwsRUFBd0I7QUFDcEIsNkJBQUssV0FBTCxJQUFvQixtQkFBcEI7QUFDSDs7QUFFRCx3QkFBTSxVQUFVLG9CQUFvQixNQUFwQixHQUE2QixDQUE3Qzs7QUFFQSx3QkFBSSxjQUFjLHFCQUFxQixhQUFhLG1CQUFsQyxJQUF5RCxhQUFhLG1CQUFiLENBQWlDLE1BQTNGLEdBQ1gsYUFBYSxtQkFERixHQUVYLGFBQWEsVUFBYixJQUEyQixFQUZqQzs7QUFJQSx5QkFBSyxXQUFMLEVBQWtCLG9CQUFvQixDQUFwQixDQUFsQixJQUE0QztBQUN4QyxpQ0FBUyxPQUQrQjtBQUV4QywrQkFBTyxXQUZpQztBQUd4QyxvQ0FBWTtBQUNSLCtDQUFtQjtBQURYLHlCQUg0QjtBQU14QywrQkFBTyxhQUFhLEtBTm9CO0FBT3hDLHlDQUFpQixhQUFhLFFBUFU7QUFReEMsaUNBQVMsYUFBYSxPQVJrQjtBQVN4Qyw2Q0FBcUIsYUFBYSxhQVRNO0FBVXhDLHlDQUFpQixhQUFhO0FBVlUscUJBQTVDOztBQWFBLHlCQUFLLElBQUksS0FBSSxDQUFiLEVBQWdCLEtBQUksb0JBQW9CLE1BQXhDLEVBQWdELElBQWhELEVBQXFEO0FBQ2pELDZCQUFLLFdBQUwsRUFBa0Isb0JBQW9CLEVBQXBCLENBQWxCLElBQTRDO0FBQ3hDLHFDQUFTLFVBQVUsRUFEcUI7QUFFeEMsaURBQXFCLElBRm1CO0FBR3hDLCtDQUFtQixvQkFBb0IsQ0FBcEIsQ0FIcUI7QUFJeEMsbUNBQU8sYUFBYSxLQUpvQjtBQUt4Qyw2Q0FBaUIsYUFBYSxRQUxVO0FBTXhDLHFDQUFTLGFBQWEsT0FOa0I7QUFPeEMsaURBQXFCLGFBQWEsYUFQTTtBQVF4Qyw2Q0FBaUIsYUFBYTtBQVJVLHlCQUE1QztBQVVIOztBQUVELDJCQUFPLG1CQUFQO0FBQ0g7QUFFSixhQXJHRCxNQXFHTztBQUNILG9CQUFNLGlCQUFnQixhQUFhLEtBQW5DO0FBQ0Esb0JBQU0sU0FBTyxrQkFBaUIsTUFBOUI7O0FBRUEsdUJBQU8sSUFBUCxDQUFZLGFBQWEsVUFBVSxFQUF2QixFQUEyQixNQUEzQixDQUFaO0FBQ0E7O0FBRUEsb0JBQUksY0FBSixFQUFtQjtBQUNmLHdCQUFJLENBQUMsS0FBSyxXQUFMLENBQUwsRUFBd0I7QUFDcEIsNkJBQUssV0FBTCxJQUFvQixtQkFBcEI7QUFDSDtBQUNELHdCQUFNLFdBQVUsZUFBZSxXQUFmLEdBQTZCLENBQTdDO0FBQ0Esd0JBQUksZUFBYyxxQkFBcUIsYUFBYSxtQkFBbEMsSUFBeUQsYUFBYSxtQkFBYixDQUFpQyxNQUEzRixHQUNYLGFBQWEsbUJBREYsR0FFWCxhQUFhLFVBQWIsSUFBMkIsRUFGakM7QUFHQSx5QkFBSyxXQUFMLEVBQWtCLGNBQWxCLElBQW1DO0FBQy9CLGlDQUFTLFFBRHNCO0FBRS9CLCtCQUFPLFlBRndCO0FBRy9CLCtCQUFPLGFBQWE7QUFIVyxxQkFBbkM7QUFLQSx5QkFBSyxJQUFJLE1BQUksY0FBYyxDQUF0QixFQUF5QixLQUFLLENBQW5DLEVBQXNDLE1BQUksWUFBMUMsRUFBd0QsT0FBSyxJQUE3RCxFQUFtRTtBQUMvRCw0QkFBSSxDQUFDLEtBQUssR0FBTCxDQUFMLEVBQWM7QUFDVixpQ0FBSyxHQUFMLElBQVUsbUJBQVY7QUFDSDtBQUNELDZCQUFLLEdBQUwsRUFBUSxjQUFSLElBQXlCO0FBQ3JCLHFDQUFTLFdBQVUsR0FERTtBQUVyQiw4Q0FBa0IsSUFGRztBQUdyQiw0Q0FBZ0IsV0FISztBQUlyQixtQ0FBTyxhQUFhO0FBSkMseUJBQXpCO0FBTUg7QUFDSjtBQUNELHVCQUFPLENBQUMsTUFBRCxDQUFQO0FBQ0g7QUFDSixTQTVJRCxNQTRJTztBQUNILG1CQUFPLElBQVAsQ0FBWTtBQUNSLHdCQUFRLFVBQVUsRUFEVjtBQUVSLHNCQUFNLE1BRkU7QUFHUiwwQkFBVSxrQkFIRjtBQUlSLHdCQUFRLElBSkE7QUFLUixpQ0FBaUI7QUFMVCxhQUFaO0FBT0E7QUFDQSxtQkFBTyxDQUFDLE1BQUQsQ0FBUDtBQUNIO0FBQ0o7QUFDRCxZQUFRLE9BQVIsQ0FBZ0I7QUFBQSxlQUFnQixhQUFhLFlBQWIsQ0FBaEI7QUFBQSxLQUFoQjs7QUFFQSxRQUFJLHFCQUFxQixHQUFHLE1BQTVCLEVBQW9DO0FBQ2hDLGFBQUssSUFBSSxJQUFJLGtCQUFiLEVBQWlDLElBQUksR0FBRyxNQUF4QyxFQUFnRCxFQUFFLENBQWxELEVBQXFEO0FBQ2pEO0FBQ0g7QUFDSjs7QUFFRCxXQUFPLEVBQUUsUUFBUSxNQUFWLEVBQWtCLE1BQU0sSUFBeEIsRUFBOEIsd0JBQXdCLFlBQXRELEVBQVA7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQU0sV0FBVztBQUNiLHNCQUFrQjtBQUNkLGdDQUF3QixrQ0FBVyxDQUVsQztBQUhhLEtBREw7QUFNYixpQkFBYSxxQkFBUyxFQUFULEVBQWEsUUFBYixFQUF1QixDQUVuQztBQVJZLENBQWpCOztBQVdBLElBQU0sa0JBQWtCO0FBQ3BCLHFCQUFpQixLQURHO0FBRXBCLGtCQUFjLEVBRk07QUFHcEIsb0JBQWdCLDBCQUFXLENBRTFCLENBTG1CO0FBTXBCLGVBQVcscUJBQVcsQ0FFckI7QUFSbUIsQ0FBeEI7O0FBV0EsSUFBTSxZQUFZO0FBQ2QsaUNBQTZCLHVDQUFXO0FBQ3BDLGFBQUssR0FBTCxDQUFTLDZCQUFUO0FBQ0EsYUFBSyxZQUFMLEdBQW9CLENBQXBCO0FBQ0gsS0FKYTtBQUtkLCtCQUEyQixtQ0FBUyxLQUFULEVBQWdCO0FBQ3ZDLGFBQUssR0FBTCxDQUFTLDJCQUFUO0FBQ0EsYUFBSyxZQUFMLEdBQW9CLEtBQXBCO0FBQ0gsS0FSYTtBQVNkLCtCQUEyQixxQ0FBVztBQUNsQyxhQUFLLEdBQUwsQ0FBUywyQkFBVDtBQUNBLGVBQU8sS0FBSyxZQUFaO0FBQ0gsS0FaYTtBQWFkLG1DQUErQix5Q0FBVztBQUN0QyxhQUFLLEdBQUwsQ0FBUywrQkFBVDtBQUNBLGFBQUssWUFBTCxHQUFvQixDQUFwQjtBQUNILEtBaEJhO0FBaUJkLGlDQUE2QixxQ0FBUyxLQUFULEVBQWdCO0FBQ3pDLGFBQUssR0FBTCxDQUFTLDZCQUFUO0FBQ0EsYUFBSyxZQUFMLEdBQW9CLEtBQXBCO0FBQ0gsS0FwQmE7QUFxQmQsaUNBQTZCLHVDQUFXO0FBQ3BDLGFBQUssR0FBTCxDQUFTLDZCQUFUO0FBQ0EsZUFBTyxLQUFLLFlBQVo7QUFDSDtBQXhCYSxDQUFsQjs7QUEyQkEsSUFBTSxtQkFBbUI7QUFDckIsdUJBQW1CLDZCQUFXO0FBQzFCLGFBQUssR0FBTCxDQUFTLG1CQUFUO0FBQ0EsZUFBTyxLQUFLLGdCQUFMLEVBQVA7QUFDSCxLQUpvQjtBQUtyQiw0QkFBd0Isa0NBQVc7QUFDL0IsYUFBSyxHQUFMLENBQVMsd0JBQVQ7QUFDSDtBQVBvQixDQUF6Qjs7QUFVQSxJQUFNLG1CQUFtQjtBQUNyQixxQkFBaUIsRUFESTtBQUVyQixrQkFBYztBQUNWLGlCQUFTLGlCQUFTLFFBQVQsRUFBbUI7QUFDeEIsaUJBQUssR0FBTCxDQUFTLFFBQVQ7QUFDSDtBQUhTLEtBRk87QUFPckIsaUJBQWEscUJBQVMsRUFBVCxFQUFhLFFBQWIsRUFBdUI7QUFDaEMsYUFBSyxHQUFMLENBQVMsRUFBVCxFQUFhLFFBQWI7QUFDSDtBQVRvQixDQUF6Qjs7QUFZQSxJQUFNLHNCQUFzQjtBQUN4QixzQkFBa0I7QUFDZCxvQ0FBNEIsc0NBQVc7QUFDbkMsaUJBQUssR0FBTCxDQUFTLDRCQUFUO0FBQ0g7QUFIYSxLQURNO0FBTXhCLFlBQVEsZ0JBQVMsUUFBVCxFQUFtQixjQUFuQixFQUFtQztBQUN2QyxhQUFLLEdBQUwsQ0FBUyxRQUFULEVBQW1CLFFBQW5CLEVBQTZCLGNBQTdCO0FBQ0g7QUFSdUIsQ0FBNUI7O0FBV0EsU0FBUyxpQkFBVCxDQUEyQixPQUEzQixFQUFvQztBQUNoQyxRQUFNLE1BQU0sUUFBUSxNQUFSLENBQWUsVUFBQyxFQUFEO0FBQUEsZUFBUSxDQUFDLEdBQUcsUUFBWjtBQUFBLEtBQWYsQ0FBWjs7QUFFQSxRQUFJLE1BQUosQ0FBVztBQUFBLGVBQU0sR0FBRyxRQUFUO0FBQUEsS0FBWCxFQUE4QixPQUE5QixDQUFzQyxjQUFNO0FBQ3hDLFdBQUcsUUFBSCxHQUFjLGtCQUFrQixHQUFHLFFBQXJCLENBQWQ7QUFDSCxLQUZEOztBQUlBLFdBQU8sR0FBUDtBQUNIOztBQUVELFNBQVMsYUFBVCxDQUF1QixPQUF2QixFQUFnQztBQUFBOztBQUM1QixTQUFLLEdBQUwsQ0FBUyxlQUFULEVBQTBCLE9BQTFCOztBQUVBLFNBQUssVUFBTCxHQUFrQixPQUFsQjtBQUNBLFNBQUssaUJBQUwsR0FBeUIsa0JBQWtCLEtBQUssVUFBdkIsQ0FBekI7O0FBRUEsUUFBTSxTQUFTLGVBQWUsSUFBZixDQUFvQixJQUFwQixFQUEwQixLQUFLLGlCQUEvQixDQUFmO0FBQ0EsU0FBSyxHQUFMLENBQVMsUUFBVCxFQUFtQixNQUFuQjtBQUNBLFFBQU0sZ0JBQWdCLE9BQU8sSUFBN0I7QUFDQSxRQUFJLE9BQU8sS0FBSyxRQUFMLENBQWMsT0FBZCxFQUFYOztBQUVBLFFBQUksS0FBSyxnQkFBVCxFQUEyQjtBQUN2QixhQUFLLFFBQUwsQ0FBYyxJQUFkLENBQW1CLFVBQW5CLENBQThCLGlCQUE5QixHQUFrRCxLQUFLLGdCQUF2RDtBQUNIOztBQUVEO0FBQ0EsUUFBSSxLQUFLLFFBQUwsQ0FBYyxJQUFkLENBQW1CLFVBQW5CLENBQThCLFVBQWxDLEVBQThDO0FBQzFDLFlBQUksQ0FBQyxJQUFELElBQVMsS0FBSyxNQUFMLEtBQWdCLENBQTdCLEVBQWdDO0FBQzVCLGdEQUFXLGFBQVg7QUFDSCxTQUZELE1BRU87QUFDSCxnQkFBSSxPQUFPLHNCQUFQLEdBQWdDLEtBQUssUUFBTCxDQUFjLElBQWQsQ0FBbUIsVUFBbkIsQ0FBOEIsc0JBQWxFLEVBQTBGO0FBQ3RGLG9CQUFNLE9BQU8sS0FBSyxRQUFMLENBQWMsSUFBZCxDQUFtQixVQUFuQixDQUE4QixzQkFBOUIsR0FBdUQsT0FBTyxzQkFBM0U7QUFDQSxxQkFBSyxNQUFMLENBQVksT0FBTyxzQkFBUCxHQUFnQyxDQUE1QyxFQUErQyxJQUEvQztBQUNIO0FBQ0QsaUJBQUssUUFBTCxDQUFjLElBQWQsQ0FBbUIsVUFBbkIsQ0FBOEIsc0JBQTlCLEdBQXVELE9BQU8sc0JBQTlEO0FBQ0EsMEJBQWMsT0FBZCxDQUFzQixVQUFDLENBQUQsRUFBSSxDQUFKLEVBQVU7QUFDNUIsb0JBQUksQ0FBQyxNQUFNLEtBQUssQ0FBTCxDQUFOLEVBQWUsQ0FBZixDQUFMLEVBQXdCO0FBQ3BCLHdCQUFJLE1BQUssUUFBTCxDQUFjLGdCQUFkLENBQStCLENBQS9CLEVBQWtDLFNBQXRDLEVBQWlEO0FBQzdDLDZCQUFLLENBQUwsSUFBVSxDQUFWO0FBQ0gscUJBRkQsTUFFTztBQUNILDZCQUFLLE1BQUwsQ0FBWSxDQUFaLEVBQWUsQ0FBZixFQUFrQixDQUFsQjtBQUNIO0FBQ0o7QUFDSixhQVJEO0FBU0g7QUFDRCxhQUFLLEdBQUwsQ0FBUyxnQkFBVCxHQUE0QixJQUE1QjtBQUNIOztBQUVELFNBQUssR0FBTCxDQUFTLGVBQVQsRUFBMEIsT0FBTyxNQUFqQzs7QUFFQSxTQUFLLFFBQUwsQ0FBYyxPQUFkLENBQXNCO0FBQ2xCLGNBQU0sSUFEWTtBQUVsQixnQkFBUSxPQUFPO0FBRkcsS0FBdEI7QUFJQSxTQUFLLFdBQUwsQ0FBaUIsSUFBakI7QUFDQSxTQUFLLFFBQUwsQ0FBYyxTQUFkLENBQXdCLFNBQXhCLENBQWtDLE9BQU8sTUFBekM7QUFDQSxTQUFLLGVBQUw7QUFDSDs7QUFFRCxTQUFTLFVBQVQsQ0FBb0IsT0FBcEIsRUFBNkI7QUFDekIsU0FBSyxHQUFMLENBQVMsWUFBVCxFQUF1QixPQUF2Qjs7QUFFQTtBQUNBLFFBQUksUUFBUSxNQUFSLEtBQW1CLElBQW5CLElBQTJCLEtBQUssUUFBTCxDQUFjLElBQWQsQ0FBbUIsVUFBbkIsQ0FBOEIsVUFBN0QsRUFBeUU7QUFDckUsZ0JBQVEsR0FBUjtBQUNIOztBQUVELFNBQUssSUFBTCxHQUFZLE9BQVo7O0FBRUEsU0FBSyxPQUFMLENBQWEsRUFBRSxNQUFNLE9BQVIsRUFBYjtBQUNBLFNBQUssUUFBTCxDQUFjLGFBQWQ7O0FBRUEsUUFBSSxLQUFLLFVBQVQsRUFBcUI7QUFDakIsYUFBSyxHQUFMLENBQVMsYUFBVCxDQUF1QixLQUFLLFVBQTVCO0FBQ0g7QUFDSjs7QUFFRCxTQUFTLGdCQUFULEdBQTRCO0FBQ3hCLFNBQUssR0FBTCxDQUFTLGtCQUFUOztBQUVBLFFBQUksS0FBSyxHQUFMLENBQVMsZ0JBQWIsRUFBK0I7QUFDM0IsYUFBSyxRQUFMLENBQWMsVUFBZDtBQUNBLGFBQUssTUFBTCxDQUFZLE1BQVosQ0FBbUIsS0FBbkI7QUFDQSxhQUFLLGdCQUFMLENBQXNCLG1CQUF0QixFQUEyQyxZQUFXO0FBQ2xELGdCQUFJLEtBQUssR0FBTCxDQUFTLGdCQUFiLEVBQStCO0FBQzNCLHFCQUFLLE1BQUwsQ0FBWSxrQkFBWjtBQUNBLHFCQUFLLEdBQUwsQ0FBUyxnQkFBVCxHQUE0QixLQUE1QjtBQUNIO0FBQ0osU0FMMEMsQ0FLekMsSUFMeUMsQ0FLcEMsSUFMb0MsQ0FBM0M7QUFNSDtBQUNKOztBQUVELFNBQVMsT0FBVCxDQUFpQixLQUFqQixFQUF3QjtBQUNwQixTQUFLLEdBQUwsQ0FBUyxTQUFULEVBQW9CLEtBQXBCOztBQUVBLFNBQUssZ0JBQUwsQ0FBc0IsRUFBdEI7O0FBRUEsU0FBSyxhQUFMOztBQUVBLFNBQUssa0JBQUwsR0FBMEIsSUFBMUI7QUFDQSxTQUFLLGtCQUFMLEdBQTBCLElBQTFCO0FBQ0EsU0FBSyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsU0FBSyxZQUFMLEdBQW9CLEtBQXBCOztBQUVBLFNBQUssUUFBTCxDQUFjLEtBQWQ7QUFDQSxTQUFLLGNBQUwsQ0FBb0IsS0FBcEI7QUFDQSxTQUFLLFFBQUwsQ0FBYyxLQUFkOztBQUVBLFNBQUssR0FBTCxDQUFTLGVBQVQsQ0FBeUIsWUFBekIsR0FBd0MsRUFBeEM7O0FBRUEsUUFBSSxTQUFTLENBQUMsS0FBSyxPQUFMLEVBQWQsRUFBOEI7QUFDMUIsYUFBSyxpQkFBTDtBQUNILEtBRkQsTUFFTztBQUNILGFBQUssTUFBTCxDQUFZLE1BQVo7QUFDQSxhQUFLLGVBQUw7QUFDQSxhQUFLLGlCQUFMO0FBQ0EsWUFBSSxLQUFLLEdBQVQsRUFBYztBQUNWLGlCQUFLLFVBQUwsQ0FBZ0IsS0FBSyxHQUFyQjtBQUNBLGlCQUFLLE1BQUwsQ0FBWSxLQUFaO0FBQ0g7QUFDSjs7QUFFRCxTQUFLLFFBQUwsQ0FBYyxJQUFkLENBQW1CLDZCQUFuQixDQUFpRCxLQUFqRDtBQUNIOztBQUVELFNBQVMsa0JBQVQsR0FBOEI7QUFDMUIsU0FBSyxHQUFMLENBQVMsb0JBQVQ7QUFDQSxXQUFPLEtBQUssYUFBTCxFQUFQO0FBQ0g7O0FBRUQsU0FBUyw0QkFBVCxDQUFzQyxjQUF0QyxFQUFzRDtBQUNsRCxTQUFLLEdBQUwsQ0FBUyw4QkFBVCxFQUF5QyxjQUF6QztBQUNBLFNBQUssa0JBQUwsR0FBMEIsY0FBMUI7QUFDQSxhQUFTLFdBQVQsQ0FBcUIsTUFBckI7QUFDQSxXQUFPLEtBQUssa0JBQVo7QUFDSDs7QUFFRCxTQUFTLGtCQUFULEdBQThCO0FBQzFCLFNBQUssR0FBTCxDQUFTLG9CQUFUO0FBQ0EsV0FBTyxLQUFLLEdBQUwsQ0FBUyxlQUFULENBQXlCLFlBQWhDO0FBQ0g7O0FBRUQsU0FBUyxRQUFULEdBQW9CO0FBQ2hCLFNBQUssR0FBTCxDQUFTLFVBQVQ7QUFDQSxXQUFPO0FBQ0gsdUJBQWUsRUFEWjtBQUVILGdCQUFRLGtCQUFXO0FBQ2YsaUJBQUssR0FBTCxDQUFTLFFBQVQ7QUFDSDtBQUpFLEtBQVA7QUFNSDs7QUFFRCxTQUFTLGVBQVQsQ0FBeUIsUUFBekIsRUFBbUM7QUFDL0IsV0FBTyxNQUFQLENBQWMsS0FBSyxVQUFuQixFQUErQixRQUEvQjtBQUNBLFNBQUssT0FBTDtBQUNIOztBQUVELFNBQVMsV0FBVCxHQUF1QjtBQUNuQixTQUFLLEdBQUwsQ0FBUyxhQUFUO0FBQ0EsU0FBSyxPQUFMO0FBQ0g7O0FBRUQsU0FBUyxXQUFULENBQXFCLFFBQXJCLEVBQStCO0FBQzNCLFNBQUssR0FBTCxDQUFTLGFBQVQsRUFBd0IsUUFBeEI7QUFFSDs7QUFFRCxTQUFTLGtCQUFULENBQTRCLEtBQTVCLEVBQW1DLEtBQW5DLEVBQTBDO0FBQ3RDLFNBQUssR0FBTCxDQUFTLG9CQUFULEVBQStCLEtBQS9CLEVBQXNDLEtBQXRDO0FBQ0g7O0FBRUQsU0FBUyxtQkFBVCxHQUErQjtBQUMzQixTQUFLLEdBQUwsQ0FBUyxxQkFBVDtBQUNBLFNBQUssZUFBTDtBQUNBLFNBQUssT0FBTDtBQUNIOztBQUVELFNBQVMsZ0JBQVQsR0FBNEI7QUFDeEIsU0FBSyxHQUFMLENBQVMsa0JBQVQ7QUFDQSxTQUFLLHdCQUFMO0FBQ0EsU0FBSyxPQUFMO0FBQ0g7O0FBRUQsU0FBUyxxQkFBVCxHQUFpQztBQUM3QixTQUFLLEdBQUwsQ0FBUyx1QkFBVDtBQUNIOztBQUVELFNBQVMsc0JBQVQsR0FBa0M7QUFDOUIsU0FBSyxHQUFMLENBQVMsd0JBQVQ7QUFDSDs7QUFFRCxTQUFTLGlCQUFULEdBQTZCO0FBQ3pCLFNBQUssR0FBTCxDQUFTLG1CQUFUO0FBQ0g7O0FBRUQsU0FBUyxXQUFULEdBQXVCO0FBQ25CLFNBQUssR0FBTCxDQUFTLGFBQVQ7QUFDSDs7QUFFRCxTQUFTLFlBQVQsQ0FBc0IsUUFBdEIsRUFBZ0MsTUFBaEMsRUFBd0MsT0FBeEMsRUFBaUQ7QUFDN0MsU0FBSyxHQUFMLENBQVMsY0FBVCxFQUF5QixRQUF6QixFQUFtQyxNQUFuQyxFQUEyQyxPQUEzQztBQUNIOztBQUVELFNBQVMsYUFBVCxDQUF1QixVQUF2QixFQUFtQztBQUFBOztBQUMvQixTQUFLLEdBQUwsQ0FBUyxlQUFULEVBQTBCLFVBQTFCO0FBQ0EsU0FBSyxHQUFMLENBQVMsVUFBVCxHQUFzQixVQUF0Qjs7QUFFQSxTQUFLLGdCQUFMLENBQXNCLFdBQVcsTUFBWCxJQUFxQixFQUEzQzs7QUFFQSxRQUFNLFdBQVcsS0FBSyxJQUFMLENBQVUsTUFBVixJQUFvQixDQUFyQzs7QUFFQSxRQUFJLFdBQVcsV0FBVyxTQUF0QixJQUFtQyxhQUFhLENBQXBELEVBQXVEO0FBQ25ELFlBQU0sU0FBUztBQUNYLHNCQUFVLFFBREMsRUFDUztBQUNwQixvQkFBUSxXQUFXLEtBQUssa0JBRmIsRUFFaUM7QUFDNUMsNkJBQWlCLHlCQUFDLElBQUQsRUFBTyxZQUFQLEVBQXdCO0FBQ3JDLHVCQUFLLEdBQUwsQ0FBUyxpQkFBVCxFQUE0QixJQUE1QixFQUFrQyxZQUFsQzs7QUFFQTtBQUNBLG9CQUFJLGFBQWEsQ0FBYixJQUFrQixLQUFLLE1BQUwsS0FBZ0IsSUFBdEMsRUFBNEM7QUFDeEMseUJBQUssR0FBTDtBQUNIOztBQUVELG1CQUFHLElBQUgsQ0FBUSxLQUFSLENBQWMsT0FBSyxJQUFuQixFQUF5QixJQUF6QjtBQUNBLHVCQUFLLE9BQUwsQ0FBYSxFQUFFLE1BQU0sSUFBUixFQUFiO0FBQ0EsdUJBQUssUUFBTCxDQUFjLGFBQWQ7QUFDSCxhQWRVO0FBZVgsMEJBQWMsd0JBQVc7QUFDckIscUJBQUssR0FBTCxDQUFTLGNBQVQ7QUFDQSxxQkFBSyxPQUFMLENBQWEsRUFBRSxNQUFNLEVBQVIsRUFBYjtBQUNILGFBbEJVO0FBbUJYLHVCQUFXLFdBQVcsU0FuQlg7QUFvQlgseUJBQWEsRUFwQkY7QUFxQlgscUJBQVM7QUFyQkUsU0FBZjs7QUF3QkEsbUJBQVcsT0FBWCxDQUFtQixNQUFuQjtBQUNIO0FBQ0o7O0FBRUQsU0FBUywwQkFBVCxDQUFvQyxnQkFBcEMsRUFBc0Q7QUFDbEQsU0FBSyxHQUFMLENBQVMsNEJBQVQsRUFBdUMsZ0JBQXZDO0FBQ0g7O0FBRUQsU0FBUyxZQUFULEdBQXdCO0FBQ3BCLFNBQUssR0FBTCxDQUFTLGNBQVQ7QUFDQSxXQUFPLEVBQVA7QUFDSDs7QUFFRCxTQUFTLFFBQVQsR0FBb0I7QUFDaEI7QUFDSDs7QUFFRCxTQUFTLHVCQUFULEdBQW1DO0FBQy9CLFNBQUssR0FBTCxDQUFTLHlCQUFUO0FBQ0g7O0FBRUQsU0FBUyxvQkFBVCxDQUE4QixDQUE5QixFQUFpQyxDQUFqQyxFQUFvQyxJQUFwQyxFQUEwQztBQUN0QyxTQUFLLFFBQUwsQ0FBYyxlQUFkLENBQThCLENBQTlCLEVBQWlDLENBQWpDLEVBQW9DLE1BQXBDLEVBQTRDLElBQTVDO0FBQ0g7O0FBRUQsU0FBUywrQkFBVCxDQUF5QyxRQUF6QyxFQUFtRDtBQUMvQyxTQUFLLHdCQUFMLENBQThCLHFCQUE5QixFQUFxRCxRQUFyRDtBQUNIOztBQUVELE9BQU8sT0FBUCxHQUFpQjtBQUNiO0FBQ0EsY0FBVSxRQUZHO0FBR2IscUJBQWlCLGVBSEo7QUFJYixlQUFXLFNBSkU7QUFLYixzQkFBa0IsZ0JBTEw7QUFNYixzQkFBa0IsZ0JBTkw7QUFPYix5QkFBcUIsbUJBUFI7O0FBU2I7QUFDQSxtQkFBZSxhQVZGO0FBV2IsZ0JBQVksVUFYQztBQVliLHNCQUFrQixnQkFaTDtBQWFiLGFBQVMsT0FiSTtBQWNiLHdCQUFvQixrQkFkUDtBQWViLGtDQUE4Qiw0QkFmakI7QUFnQmIsd0JBQW9CLGtCQWhCUDtBQWlCYixjQUFVLFFBakJHO0FBa0JiLGlCQUFhLFdBbEJBO0FBbUJiLGlCQUFhLFdBbkJBO0FBb0JiLHdCQUFvQixrQkFwQlA7QUFxQmIseUJBQXFCLG1CQXJCUjtBQXNCYixzQkFBa0IsZ0JBdEJMO0FBdUJiLDJCQUF1QixxQkF2QlY7QUF3QmIsNEJBQXdCLHNCQXhCWDtBQXlCYix1QkFBbUIsaUJBekJOO0FBMEJiLGlCQUFhLFdBMUJBO0FBMkJiLGtCQUFjLFlBM0JEO0FBNEJiLG1CQUFlLGFBNUJGO0FBNkJiLGdDQUE0QiwwQkE3QmY7QUE4QmIsa0JBQWMsWUE5QkQ7QUErQmIsY0FBVSxRQS9CRztBQWdDYiw2QkFBeUIsdUJBaENaO0FBaUNiLDBCQUFzQixvQkFqQ1Q7QUFrQ2IscUNBQWlDLCtCQWxDcEI7QUFtQ2IscUJBQWlCO0FBbkNKLENBQWpCOzs7QUNyb0JBOztBQUVBLFNBQVMsaUJBQVQsR0FBNkI7QUFDekIsU0FBSyxHQUFMLENBQVMsbUJBQVQ7QUFDQSxXQUFPLEtBQUssZ0JBQUwsRUFBUDtBQUNIOztBQUVELFNBQVMsZ0JBQVQsQ0FBMEIsR0FBMUIsRUFBK0IsT0FBL0IsRUFBd0M7QUFDcEMsU0FBSyxHQUFMLENBQVMsa0JBQVQsRUFBNkIsR0FBN0IsRUFBa0MsT0FBbEM7O0FBRUEsc0JBQWtCLElBQWxCLENBQXVCLElBQXZCLEVBQTZCLENBQUMsR0FBRCxDQUE3QixFQUFvQyxPQUFwQztBQUNIOztBQUVELFNBQVMsaUJBQVQsQ0FBMkIsSUFBM0IsRUFBaUMsT0FBakMsRUFBMEM7QUFBQTs7QUFDdEMsU0FBSyxHQUFMLENBQVMsbUJBQVQsRUFBOEIsSUFBOUIsRUFBb0MsT0FBcEM7QUFDQSxRQUFJLFNBQVMsS0FBSyxVQUFsQjtBQUNBLFFBQUksc0JBQXNCLEtBQTFCO0FBQ0EsU0FBSyxPQUFMLENBQWEsVUFBQyxHQUFELEVBQVM7QUFDbEIsY0FBSyxVQUFMLENBQWdCLEdBQWhCLEVBQXFCLE9BQXJCLENBQTZCLGNBQU07QUFDL0IsZUFBRyxRQUFILEdBQWMsQ0FBQyxPQUFmO0FBQ0Esa0NBQXNCLElBQXRCO0FBQ0gsU0FIRDtBQUlILEtBTEQ7O0FBT0EsUUFBSSxtQkFBSixFQUF5QjtBQUNyQixhQUFLLEdBQUwsQ0FBUyxhQUFULENBQXVCLE1BQXZCO0FBQ0EsYUFBSyxHQUFMLENBQVMsZ0JBQVQsR0FBNEIsSUFBNUI7QUFDSDtBQUNKOztBQUVELFNBQVMsaUJBQVQsQ0FBMkIsVUFBM0IsRUFBdUM7QUFDbkMsU0FBSyxHQUFMLENBQVMsbUJBQVQsRUFBOEIsVUFBOUI7QUFDSDs7QUFFRCxTQUFTLGFBQVQsR0FBeUI7QUFDckIsU0FBSyxHQUFMLENBQVMsZUFBVDtBQUNBLFdBQU8sS0FBSyxnQkFBTCxHQUF3QixNQUF4QixDQUErQjtBQUFBLGVBQUssRUFBRSxNQUFQO0FBQUEsS0FBL0IsQ0FBUDtBQUNIOztBQUVELFNBQVMsZ0JBQVQsR0FBNEI7QUFDeEIsU0FBSyxHQUFMLENBQVMsa0JBQVQ7QUFDSDs7QUFFRCxTQUFTLFNBQVQsQ0FBbUIsR0FBbkIsRUFBd0I7QUFDcEIsU0FBSyxHQUFMLENBQVMsV0FBVCxFQUFzQixHQUF0QjtBQUVIOztBQUVELFNBQVMsVUFBVCxDQUFvQixTQUFwQixFQUErQixPQUEvQixFQUF3QztBQUNwQyxTQUFLLFdBQUwsQ0FBaUIsU0FBakIsRUFBNEIsQ0FBNUIsRUFBK0IsT0FBL0IsRUFBd0MsS0FBeEMsRUFBK0MsSUFBL0M7QUFDQSxTQUFLLEdBQUwsQ0FBUyxZQUFULEVBQXVCLFNBQXZCLEVBQWtDLE9BQWxDO0FBQ0g7O0FBRUQsU0FBUyw2QkFBVCxHQUF5QztBQUNyQyxTQUFLLEdBQUwsQ0FBUywrQkFBVDtBQUNBLFdBQU8sS0FBSyxnQkFBTCxFQUFQO0FBQ0g7O0FBRUQsU0FBUyxlQUFULENBQXlCLE9BQXpCLEVBQWtDLEtBQWxDLEVBQXlDO0FBQUE7O0FBQ3JDLFNBQUssR0FBTCxDQUFTLGlCQUFULEVBQTRCLE9BQTVCLEVBQXFDLEtBQXJDO0FBQ0EsWUFBUSxPQUFSLENBQWdCO0FBQUEsZUFBSyxPQUFLLFFBQUwsQ0FBYyxTQUFkLENBQXdCLENBQXhCLEVBQTJCLEtBQTNCLENBQUw7QUFBQSxLQUFoQjtBQUNIOztBQUVELE9BQU8sT0FBUCxHQUFpQjtBQUNiO0FBQ0EsdUJBQW1CLGlCQUZOO0FBR2Isc0JBQWtCLGdCQUhMO0FBSWIsdUJBQW1CLGlCQUpOO0FBS2IsdUJBQW1CLGlCQUxOO0FBTWIsbUJBQWUsYUFORjtBQU9iLHNCQUFrQixnQkFQTDtBQVFiLGVBQVcsU0FSRTtBQVNiLGdCQUFZLFVBVEM7QUFVYixtQ0FBK0IsNkJBVmxCO0FBV2IscUJBQWlCO0FBWEosQ0FBakI7OztBQy9EQTs7QUFFQSxJQUFJLGdCQUFnQixRQUFRLGNBQVIsRUFBd0IsYUFBNUM7QUFDQSxJQUFJLFNBQVMsUUFBUSxVQUFSLENBQWI7O0FBRUEsSUFBSSxxQkFBSjs7QUFFQTs7OztBQUlBLElBQUksUUFBUTs7QUFFUjs7Ozs7QUFLQSx5Q0FBcUMsNkNBQVMsS0FBVCxFQUFnQjtBQUNqRCxlQUFPLE1BQVAsQ0FBYyxJQUFkLENBQW1CLElBQW5CLEVBQXlCLFNBQVMsTUFBTSxNQUF4QztBQUNBLGVBQU8sY0FBYyxJQUFkLENBQW1CLElBQW5CLEVBQXlCLHlCQUF6QixFQUFvRCxLQUFwRCxDQUFQO0FBQ0gsS0FWTzs7QUFZUjs7Ozs7QUFLQSxtQ0FBK0IsdUNBQVMsS0FBVCxFQUFnQjtBQUMzQyxhQUFLLE9BQUw7QUFDQSxlQUFPLGNBQWMsSUFBZCxDQUFtQixJQUFuQixFQUF5QixrQkFBekIsRUFBNkMsS0FBN0MsQ0FBUDtBQUNILEtBcEJPOztBQXNCUjs7Ozs7QUFLQSx3Q0FBb0MsNENBQVMsS0FBVCxFQUFnQjtBQUNoRCxhQUFLLG9CQUFMO0FBQ0EsZUFBTyxjQUFjLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUIsd0JBQXpCLEVBQW1ELEtBQW5ELENBQVA7QUFDSCxLQTlCTzs7QUFnQ1I7Ozs7O0FBS0Esc0NBQWtDLDBDQUFTLEtBQVQsRUFBZ0I7QUFDOUMsYUFBSyx3QkFBTCxHQUFnQyxtQ0FBbUMsSUFBbkMsQ0FBd0MsSUFBeEMsQ0FBaEM7QUFDQSxlQUFPLGNBQWMsSUFBZCxDQUFtQixJQUFuQixFQUF5QixxQkFBekIsRUFBZ0QsS0FBaEQsQ0FBUDtBQUNILEtBeENPOztBQTBDUjs7Ozs7QUFLQSx1Q0FBbUMsMkNBQVMsS0FBVCxFQUFnQjtBQUMvQyxZQUFJLEtBQUssd0JBQVQsRUFBbUM7QUFDL0IsZ0JBQUksS0FBSyx3QkFBTCxDQUE4QixNQUFsQyxFQUEwQztBQUN0QyxnREFBZ0MsSUFBaEMsQ0FBcUMsSUFBckMsRUFBMkMsS0FBSyx3QkFBaEQ7QUFDSDtBQUNELG1CQUFPLEtBQUssd0JBQVo7QUFDSDtBQUNELGVBQU8sY0FBYyxJQUFkLENBQW1CLElBQW5CLEVBQXlCLHNCQUF6QixFQUFpRCxLQUFqRCxLQUNILEtBQUssa0NBQUwsQ0FBd0MsS0FBeEMsQ0FESjtBQUVILEtBeERPOztBQTBEUix3QkFBb0IsOEJBQVc7QUFDM0IsZUFBTyxJQUFQLENBQVkscUJBQVosRUFBbUMsT0FBbkMsQ0FBMkMsVUFBUyxXQUFULEVBQXNCO0FBQzdELGlCQUFLLG9CQUFMLENBQTBCLFdBQTFCLEVBQXVDLHNCQUFzQixXQUF0QixDQUF2QztBQUNILFNBRkQsRUFFRyxJQUZIO0FBR0gsS0E5RE87O0FBZ0VSLDBCQUFzQiw4QkFBUyxXQUFULEVBQXNCLE9BQXRCLEVBQStCO0FBQ2pELFlBQUksT0FBTyxJQUFYOztBQUVBLGFBQUssd0JBQUwsQ0FBOEIsZ0JBQWdCLFdBQTlDLEVBQTJELFVBQVMsS0FBVCxFQUFnQjtBQUN2RSxvQkFBUSxJQUFSLENBQWEsSUFBYixFQUFtQixTQUFTLEVBQTVCO0FBQ0gsU0FGRDtBQUdIOztBQXRFTyxDQUFaOztBQTJFQSx3QkFBd0I7QUFDcEIsMkJBQXVCLE1BQU0sbUNBRFQ7QUFFcEIsb0JBQWdCLE1BQU0sNkJBRkY7QUFHcEIsMEJBQXNCLE1BQU0sa0NBSFI7QUFJcEIsdUJBQW1CLE1BQU0sZ0NBSkw7QUFLcEIsd0JBQW9CLE1BQU07QUFMTixDQUF4Qjs7QUFTQTs7Ozs7O0FBTUEsU0FBUyxrQ0FBVCxHQUE4QztBQUMxQyxRQUFJLGdCQUFnQixFQUFwQjtBQUFBLFFBQ0ksWUFBWSxLQUFLLFNBRHJCOztBQUdBLFFBQUksS0FBSyxVQUFMLENBQWdCLGlCQUFwQixFQUF1QztBQUNuQyxhQUFLLGVBQUwsR0FBdUIsT0FBdkIsQ0FBK0IsVUFBUyxnQkFBVCxFQUEyQjtBQUN0RCwwQkFBYyxJQUFkLENBQW1CLFVBQVUsV0FBVixDQUFzQixnQkFBdEIsQ0FBbkI7QUFDSCxTQUZEO0FBR0g7O0FBRUQsV0FBTyxhQUFQO0FBQ0g7O0FBRUQ7Ozs7O0FBS0EsU0FBUywrQkFBVCxDQUF5QyxhQUF6QyxFQUF3RDtBQUNwRCxRQUFJLENBQUo7QUFBQSxRQUFPLENBQVA7QUFBQSxRQUNJLFlBQVksS0FBSyxTQURyQjtBQUFBLFFBRUksV0FBVyxVQUFVLFdBQVYsRUFGZjtBQUFBLFFBR0ksbUJBQW1CLGNBQWMsTUFIckM7QUFBQSxRQUlJLGFBQWEsRUFKakI7QUFBQSxRQUtJLGlCQUFpQixLQUFLLGNBTDFCOztBQU9BLG1CQUFlLGlCQUFmOztBQUVBLFFBQUksS0FBSyxVQUFMLENBQWdCLGlCQUFwQixFQUF1QztBQUNuQyxhQUFLLElBQUksQ0FBVCxFQUFZLG9CQUFvQixJQUFJLFFBQXBDLEVBQThDLEVBQUUsQ0FBaEQsRUFBbUQ7QUFDL0MsZ0JBQUksY0FBYyxPQUFkLENBQXNCLFVBQVUsV0FBVixDQUFzQixDQUF0QixDQUF0QixDQUFKO0FBQ0EsZ0JBQUksS0FBSyxDQUFULEVBQVk7QUFDUiwyQkFBVyxJQUFYLENBQWdCLENBQWhCO0FBQ0EsdUJBQU8sY0FBYyxDQUFkLENBQVAsQ0FGUSxDQUVpQjtBQUN6QixtQ0FIUSxDQUdZO0FBQ3ZCO0FBQ0o7O0FBRUQsbUJBQVcsT0FBWCxDQUFtQixVQUFTLFFBQVQsRUFBbUI7QUFDbEMsMkJBQWUsU0FBZixDQUF5QixRQUF6QjtBQUNILFNBRkQ7QUFHSDs7QUFFRCxXQUFPLFdBQVcsTUFBbEI7QUFDSDs7QUFFRCxPQUFPLE9BQVAsR0FBaUI7QUFDYixXQUFPLEtBRE07QUFFYixjQUFVO0FBRkcsQ0FBakI7OztBQ25KQTs7QUFFQTs7OztBQUlBLElBQUksZUFBZSxRQUFRLHdCQUFSLENBQW5COztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkEsUUFBUSxNQUFSLEdBQWlCLFVBQVMsTUFBVCxFQUFpQjtBQUM5QixRQUFJLFlBQVksS0FBSyxRQUFMLENBQWMsU0FBOUI7O0FBRUEsYUFBUyxVQUFVLFVBQVUsU0FBVixFQUFuQjs7QUFFQTtBQUNBLFdBQU8sT0FBUCxDQUFlLFVBQVMsWUFBVCxFQUF1QixLQUF2QixFQUE4QjtBQUN6QyxZQUFJLE9BQU8sWUFBUCxLQUF3QixRQUE1QixFQUFzQztBQUNsQyxtQkFBTyxLQUFQLElBQWdCLEVBQUUsTUFBTSxZQUFSLEVBQWhCO0FBQ0g7QUFDSixLQUpEOztBQU1BO0FBQ0EsYUFBUyxPQUFPLE1BQVAsQ0FBYyxVQUFTLFlBQVQsRUFBdUI7QUFDMUMsZUFBTyxhQUFhLElBQWIsQ0FBa0IsTUFBbEIsQ0FBeUIsQ0FBekIsRUFBNEIsQ0FBNUIsTUFBbUMsSUFBMUM7QUFDSCxLQUZRLENBQVQ7O0FBSUE7QUFDQSxXQUFPLE9BQVAsQ0FBZSxVQUFTLFlBQVQsRUFBdUIsS0FBdkIsRUFBOEI7QUFDekMscUJBQWEsS0FBYixHQUFxQixLQUFyQjtBQUNILEtBRkQ7O0FBSUE7QUFDQSxRQUFJLGNBQWMsYUFBYSxLQUFLLFVBQUwsQ0FBZ0IsU0FBN0IsQ0FBbEI7QUFDQSxRQUFJLFdBQUosRUFBaUI7QUFDYixlQUFPLE9BQVAsQ0FBZSxVQUFTLFlBQVQsRUFBdUI7QUFDbEMsZ0JBQUksQ0FBQyxhQUFhLE1BQWxCLEVBQTBCO0FBQ3RCLDZCQUFhLE1BQWIsR0FBc0IsWUFBWSxhQUFhLElBQXpCLENBQXRCO0FBQ0g7QUFDSixTQUpEO0FBS0g7O0FBRUQsbUJBQWUsSUFBZixDQUFvQixTQUFwQjs7QUFFQSxxQkFBaUIsSUFBakIsQ0FBc0IsU0FBdEI7QUFDSCxDQW5DRDs7QUFxQ0E7O0FBRUE7QUFDQSxJQUFJLGlDQUFpQyxvQkFBckM7QUFDQSxJQUFJLHFCQUFxQixjQUF6Qjs7QUFFQTtBQUNBLElBQUksbUNBQW1DLHlCQUF2QztBQUNBLFNBQVMsZUFBVCxDQUF5QixLQUF6QixFQUFnQyxJQUFoQyxFQUFzQztBQUFFLFdBQU8sU0FBUyxTQUFULEdBQXFCLEVBQXJCLEdBQTBCLEtBQUssV0FBTCxFQUFqQztBQUFzRDs7QUFFOUYsSUFBSSxzQkFBc0IsT0FBMUI7QUFDQSxJQUFJLHFCQUFxQixNQUF6Qjs7QUFFQSxJQUFJLHdCQUF3QixVQUE1QjtBQUNBLFNBQVMsZUFBVCxDQUF5QixLQUF6QixFQUFnQyxJQUFoQyxFQUFzQztBQUFFLFdBQU8sS0FBSyxXQUFMLEVBQVA7QUFBNEI7O0FBRXBFO0FBQ0EsU0FBUyxXQUFULENBQXFCLEdBQXJCLEVBQTBCO0FBQ3RCLFdBQU8sR0FBUDtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVCxDQUFxQixHQUFyQixFQUEwQjtBQUN0QixXQUFPLElBQ0YsT0FERSxDQUNNLGdDQUROLEVBQ3dDLGVBRHhDLEVBRUYsT0FGRSxDQUVNLG1CQUZOLEVBRTJCLGtCQUYzQixFQUdGLE9BSEUsQ0FHTSxxQkFITixFQUc2QixlQUg3QixDQUFQO0FBSUg7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFULENBQW1CLEdBQW5CLEVBQXdCO0FBQ3BCLFdBQU8sSUFDRixPQURFLENBQ00sa0JBRE4sRUFDMEIsR0FEMUIsRUFFRixPQUZFLENBRU0sOEJBRk4sRUFFc0MsT0FGdEMsRUFHRixPQUhFLENBR00sbUJBSE4sRUFHMkIsa0JBSDNCLEVBSUYsV0FKRSxFQUFQO0FBS0g7O0FBRUQsSUFBSSxhQUFhLENBQUMsV0FBRCxFQUFjLFdBQWQsRUFBMkIsU0FBM0IsQ0FBakI7O0FBRUE7Ozs7Ozs7Ozs7QUFVQSxTQUFTLGNBQVQsR0FBMEI7QUFDdEIsUUFBSSxTQUFTLEtBQUssU0FBTCxFQUFiOztBQUVBLFdBQU8sT0FBUCxDQUFlLFVBQVMsWUFBVCxFQUF1QixXQUF2QixFQUFvQztBQUMvQyxtQkFBVyxPQUFYLENBQW1CLFVBQVMsU0FBVCxFQUFvQjtBQUNuQyxnQkFBSSxlQUFlLFVBQVUsYUFBYSxJQUF2QixDQUFuQjtBQUNBLGdCQUFJLEVBQUUsZ0JBQWdCLE1BQWxCLENBQUosRUFBK0I7QUFDM0IsdUJBQU8sWUFBUCxJQUF1QixPQUFPLFdBQVAsQ0FBdkI7QUFDSDtBQUNKLFNBTEQ7QUFNSCxLQVBEO0FBUUg7O0FBR0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkEsU0FBUyxnQkFBVCxHQUE0QjtBQUN4QixRQUFJLFlBQVksSUFBaEI7QUFBQSxRQUNJLGVBQWUsRUFEbkI7O0FBR0EsV0FBTyxjQUFQLENBQXNCLFlBQXRCLEVBQW9DLEtBQXBDLEVBQTJDO0FBQ3ZDLG9CQUFZLEtBRDJCLEVBQ3BCO0FBQ25CLGtCQUFVLElBRjZCLENBRXhCO0FBRndCLEtBQTNDOztBQUtBLGNBQVUsU0FBVixHQUFzQixPQUF0QixDQUE4QixVQUFTLFlBQVQsRUFBdUIsV0FBdkIsRUFBb0M7QUFDOUQsZUFBTyxjQUFQLENBQXNCLFlBQXRCLEVBQW9DLGFBQWEsSUFBakQsRUFBdUQ7QUFDbkQsd0JBQVksSUFEdUMsRUFDakM7QUFDbEIsaUJBQUssZUFBVztBQUNaLHVCQUFPLFVBQVUsUUFBVixDQUFtQixXQUFuQixFQUFnQyxLQUFLLEdBQXJDLENBQVA7QUFDSCxhQUprRDtBQUtuRCxpQkFBSyxhQUFTLEtBQVQsRUFBZ0I7QUFDakIsdUJBQU8sVUFBVSxRQUFWLENBQW1CLFdBQW5CLEVBQWdDLEtBQUssR0FBckMsRUFBMEMsS0FBMUMsQ0FBUDtBQUNIO0FBUGtELFNBQXZEO0FBU0gsS0FWRDs7QUFZQSxjQUFVLFlBQVYsR0FBeUIsWUFBekI7QUFDSDs7O0FDbExEOztBQUVBOztBQUVBLElBQUksSUFBSSxRQUFRLGtCQUFSLENBQVI7O0FBRUE7Ozs7QUFJQSxJQUFJLFFBQVE7O0FBRVI7Ozs7Ozs7O0FBUUEsc0JBQWtCLDBCQUFTLFNBQVQsRUFBb0IsUUFBcEIsRUFBOEIsUUFBOUIsRUFBd0M7QUFDdEQsWUFBSSxPQUFPLElBQVg7QUFBQSxZQUNJLFlBQVksS0FBSyxTQUFMLENBQWUsU0FBZixJQUE0QixLQUFLLFNBQUwsQ0FBZSxTQUFmLEtBQTZCLEVBRHpFO0FBQUEsWUFFSSxrQkFBa0IsVUFBVSxJQUFWLENBQWUsVUFBUyxJQUFULEVBQWU7QUFBRSxtQkFBTyxLQUFLLFFBQUwsS0FBa0IsUUFBekI7QUFBb0MsU0FBcEUsQ0FGdEI7O0FBSUEsWUFBSSxDQUFDLGVBQUwsRUFBc0I7QUFDbEIsZ0JBQUksT0FBTztBQUNQLDBCQUFVLFFBREg7QUFFUCwwQkFBVSxRQUZIO0FBR1AsMkJBQVcsbUJBQVMsQ0FBVCxFQUFZO0FBQ25CLHdCQUFJLEtBQUssa0JBQVQsRUFBNkI7QUFDekIsaUNBQVMsQ0FBVDtBQUNIO0FBQ0o7QUFQTSxhQUFYO0FBU0Esc0JBQVUsSUFBVixDQUFlLElBQWY7QUFDQSxpQkFBSyxNQUFMLENBQVksZ0JBQVosQ0FBNkIsU0FBN0IsRUFBd0MsS0FBSyxTQUE3QztBQUNIO0FBQ0osS0E1Qk87O0FBOEJSOzs7Ozs7Ozs7QUFTQSw4QkFBMEIsa0NBQVMsU0FBVCxFQUFvQixRQUFwQixFQUE4QjtBQUNwRCxhQUFLLGdCQUFMLENBQXNCLFNBQXRCLEVBQWlDLFFBQWpDLEVBQTJDLElBQTNDO0FBQ0gsS0F6Q087O0FBMkNSOzs7Ozs7O0FBT0EseUJBQXFCLDZCQUFTLFNBQVQsRUFBb0IsUUFBcEIsRUFBOEI7QUFDL0MsWUFBSSxlQUFlLEtBQUssU0FBTCxDQUFlLFNBQWYsQ0FBbkI7O0FBRUEsWUFBSSxZQUFKLEVBQWtCO0FBQ2QseUJBQWEsSUFBYixDQUFrQixVQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ3BDLG9CQUFJLEtBQUssUUFBTCxLQUFrQixRQUF0QixFQUFnQztBQUM1Qix3QkFBSSxhQUFhLE1BQWIsS0FBd0IsQ0FBNUIsRUFBK0I7QUFDM0IsK0JBQU8sS0FBSyxTQUFMLENBQWUsU0FBZixDQUFQO0FBQ0gscUJBRkQsTUFFTztBQUNILHFDQUFhLE1BQWIsQ0FBb0IsS0FBcEIsRUFBMkIsQ0FBM0IsRUFERyxDQUM0QjtBQUNsQztBQUNELHlCQUFLLE1BQUwsQ0FBWSxtQkFBWixDQUFnQyxTQUFoQyxFQUEyQyxLQUFLLFNBQWhEO0FBQ0EsMkJBQU8sSUFBUDtBQUNIO0FBQ0osYUFWRCxFQVVHLElBVkg7QUFXSDtBQUNKLEtBbEVPOztBQW9FUjs7Ozs7O0FBTUEsNkJBQXlCLGlDQUFTLFFBQVQsRUFBbUI7QUFDeEMsVUFBRSxLQUFLLFNBQVAsRUFBa0IsSUFBbEIsQ0FBdUIsVUFBUyxZQUFULEVBQXVCLEdBQXZCLEVBQTRCO0FBQy9DLHlCQUFhLEtBQWIsR0FBcUIsT0FBckIsQ0FBNkIsVUFBUyxJQUFULEVBQWU7QUFDeEMsb0JBQUksWUFBWSxDQUFDLEtBQUssUUFBdEIsRUFBZ0M7QUFDNUIseUJBQUssbUJBQUwsQ0FBeUIsR0FBekIsRUFBOEIsS0FBSyxRQUFuQztBQUNIO0FBQ0osYUFKRCxFQUlHLElBSkg7QUFLSCxTQU5ELEVBTUcsSUFOSDtBQU9ILEtBbEZPOztBQW9GUixpQkFBYSxxQkFBUyxLQUFULEVBQWU7QUFDeEIsYUFBSyxrQkFBTCxHQUEwQixDQUFDLENBQUMsS0FBNUI7O0FBRUEsWUFBSSxLQUFLLFFBQUwsQ0FBYyxZQUFsQixFQUFnQztBQUM1QixnQkFBSSxLQUFKLEVBQVU7QUFDTixxQkFBSyxRQUFMLENBQWMsWUFBZCxDQUEyQixXQUEzQjtBQUNILGFBRkQsTUFFTztBQUNILHFCQUFLLFFBQUwsQ0FBYyxZQUFkLENBQTJCLFdBQTNCO0FBQ0g7QUFDSjs7QUFFRCxhQUFLLFFBQUwsQ0FBYyxPQUFkO0FBQ0gsS0FoR087O0FBa0dSOzs7OztBQUtBLGtDQUE4QixzQ0FBUyxDQUFULEVBQVksSUFBWixFQUFrQjtBQUM1QyxlQUFPLGNBQWMsSUFBZCxDQUFtQixJQUFuQixFQUF5QixpQkFBekIsRUFBNEM7QUFDL0Msb0JBQVEsQ0FEdUM7QUFFL0Msa0JBQU07QUFGeUMsU0FBNUMsQ0FBUDtBQUlILEtBNUdPOztBQThHUixtQ0FBK0IsdUNBQVMsWUFBVCxFQUF1QixRQUF2QixFQUFpQztBQUM1RCxlQUFPLGNBQWMsSUFBZCxDQUFtQixJQUFuQixFQUF5QixrQkFBekIsRUFBNkM7QUFDaEQsbUJBQU8sWUFEeUM7QUFFaEQsc0JBQVUsUUFGc0M7QUFHaEQsa0JBQU0sS0FBSyxNQUFMLENBQVksVUFBWixHQUF5QixTQUFTLE9BQWxDLEVBQTJDLFNBQVMsUUFBVCxHQUFvQixDQUFwQixHQUF3QixDQUFuRTtBQUgwQyxTQUE3QyxDQUFQO0FBS0gsS0FwSE87O0FBc0hSLG1DQUErQix1Q0FBUyxLQUFULEVBQWdCO0FBQzNDLGVBQU8sY0FBYyxJQUFkLENBQW1CLElBQW5CLEVBQXlCLHdCQUF6QixFQUFtRCxFQUFDLFlBQUQsRUFBbkQsQ0FBUDtBQUNILEtBeEhPOztBQTJIUixxQ0FBaUMseUNBQVMsWUFBVCxFQUF1QixRQUF2QixFQUFpQztBQUM5RCxlQUFPLGNBQWMsSUFBZCxDQUFtQixJQUFuQixFQUF5QixvQkFBekIsRUFBK0M7QUFDbEQsbUJBQU8sWUFEMkM7QUFFbEQsc0JBQVUsUUFGd0M7QUFHbEQsa0JBQU0sS0FBSyxNQUFMLENBQVksVUFBWixHQUF5QixTQUFTLE9BQWxDLEVBQTJDLFNBQVMsUUFBVCxHQUFvQixDQUFwQixHQUF3QixDQUFuRTtBQUg0QyxTQUEvQyxDQUFQO0FBS0gsS0FqSU87O0FBbUlSLHNDQUFrQywwQ0FBUyxZQUFULEVBQXVCLFFBQXZCLEVBQWlDO0FBQy9ELGVBQU8sY0FBYyxJQUFkLENBQW1CLElBQW5CLEVBQXlCLHFCQUF6QixFQUFnRDtBQUNuRCxtQkFBTyxZQUQ0QztBQUVuRCxzQkFBVSxRQUZ5QztBQUduRCxrQkFBTSxDQUFDLEtBQUssTUFBTCxDQUFZLFVBQVosR0FBeUIsU0FBUyxPQUFsQyxLQUE4QyxFQUEvQyxFQUFtRCxTQUFTLFFBQVQsR0FBb0IsQ0FBcEIsR0FBd0IsQ0FBM0U7QUFINkMsU0FBaEQsQ0FBUDtBQUtILEtBeklPOztBQTJJUix3Q0FBb0MsNENBQVMsWUFBVCxFQUF1QixRQUF2QixFQUFpQyxRQUFqQyxFQUEyQztBQUMzRSxlQUFPLGNBQWMsSUFBZCxDQUFtQixJQUFuQixFQUF5Qix3QkFBekIsRUFBbUQsSUFBbkQsRUFBeUQ7QUFDNUQsbUJBQU8sWUFEcUQ7QUFFNUQsc0JBQVUsUUFGa0Q7QUFHNUQsc0JBQVU7QUFIa0QsU0FBekQsQ0FBUDtBQUtILEtBakpPOztBQW1KUixvQ0FBZ0Msd0NBQVMsT0FBVCxFQUFrQixPQUFsQixFQUEyQjtBQUN2RCxlQUFPLGNBQWMsSUFBZCxDQUFtQixJQUFuQixFQUF5QixtQkFBekIsRUFBOEMsSUFBOUMsRUFBb0Q7QUFDdkQscUJBQVMsT0FEOEM7QUFFdkQscUJBQVM7QUFGOEMsU0FBcEQsQ0FBUDtBQUlILEtBeEpPOztBQTBKUjs7OztBQUlBLDJDQUF1QyxpREFBVztBQUM5QyxlQUFPLGNBQWMsSUFBZCxDQUFtQixJQUFuQixFQUF5QiwyQkFBekIsRUFBc0QsS0FBSyxzQkFBM0QsQ0FBUDtBQUNILEtBaEtPOztBQWtLUjs7OztBQUlBLDhDQUEwQyxvREFBVztBQUNqRCxlQUFPLGNBQWMsSUFBZCxDQUFtQixJQUFuQixFQUF5Qiw4QkFBekIsRUFBeUQsS0FBSyxzQkFBOUQsQ0FBUDtBQUNILEtBeEtPOztBQTBLUjs7Ozs7QUFLQSxxQ0FBaUMseUNBQVMsUUFBVCxFQUFtQjtBQUNoRCxlQUFPLGNBQWMsSUFBZCxDQUFtQixJQUFuQixFQUF5QixxQkFBekIsRUFBZ0QsSUFBaEQsRUFBc0Q7QUFDekQsc0JBQVU7QUFEK0MsU0FBdEQsQ0FBUDtBQUdILEtBbkxPOztBQXFMUjs7Ozs7QUFLQSxtQ0FBK0IsdUNBQVMsS0FBVCxFQUFnQjtBQUMzQyxlQUFPLGdCQUFQLENBQXdCLEtBQXhCLEVBQStCLEtBQUssZ0NBQXBDO0FBQ0EsZUFBTyxjQUFjLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUIsa0JBQXpCLEVBQTZDLEVBQTdDLEVBQWlELEtBQWpELENBQVA7QUFDSCxLQTdMTzs7QUErTFIsK0JBQTJCLG1DQUFTLEtBQVQsRUFBZ0I7QUFDdkMsZUFBTyxnQkFBUCxDQUF3QixLQUF4QixFQUErQixLQUFLLGdDQUFwQztBQUNBLGVBQU8sY0FBYyxJQUFkLENBQW1CLElBQW5CLEVBQXlCLGFBQXpCLEVBQXdDLEVBQXhDLEVBQTRDLEtBQTVDLENBQVA7QUFDSCxLQWxNTzs7QUFvTVIsaUNBQTZCLHFDQUFTLEtBQVQsRUFBZ0I7QUFDekMsZUFBTyxnQkFBUCxDQUF3QixLQUF4QixFQUErQixLQUFLLGdDQUFwQztBQUNBLGVBQU8sY0FBYyxJQUFkLENBQW1CLElBQW5CLEVBQXlCLGVBQXpCLEVBQTBDLEVBQTFDLEVBQThDLEtBQTlDLENBQVA7QUFDSCxLQXZNTzs7QUF5TVIsaUNBQTZCLHFDQUFTLEtBQVQsRUFBZ0I7QUFDekMsZUFBTyxjQUFjLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUIsZUFBekIsRUFBMEMsRUFBMUMsRUFBOEMsS0FBOUMsQ0FBUDtBQUNILEtBM01POztBQTZNUixxQ0FBaUMseUNBQVMsS0FBVCxFQUFnQjtBQUM3QyxZQUFJLFdBQVcsS0FBSyxnQkFBTCxDQUFzQixNQUFNLFFBQU4sQ0FBZSxDQUFyQyxFQUF3QyxNQUFNLFFBQU4sQ0FBZSxDQUF2RCxDQUFmO0FBQ0EsWUFBSSxRQUFKLEVBQWM7QUFDVixnQkFBSSxTQUFTLFNBQVMsU0FBVCxDQUFtQixVQUFTLE1BQVQsRUFBaUI7QUFDN0Msb0JBQUksUUFBUSxNQUFNLGNBQU4sQ0FBcUIsTUFBckIsQ0FBNEIsS0FBeEM7QUFDQSx1QkFBTyxPQUFPLENBQVAsSUFBWSxNQUFNLENBQWxCLElBQXVCLE1BQU0sQ0FBTixHQUFVLE9BQU8sQ0FBUCxHQUFXLE9BQU8sTUFBMUQ7QUFDSCxhQUhZLENBQWI7QUFJQSxnQkFBSSxVQUFVLENBQWQsRUFBaUI7QUFDYixzQkFBTSxNQUFOLEdBQWUsTUFBZjtBQUNBLHVCQUFPLGNBQWMsSUFBZCxDQUFtQixJQUFuQixFQUF5QixvQkFBekIsRUFBK0MsRUFBL0MsRUFBbUQsS0FBbkQsQ0FBUDtBQUNIO0FBQ0o7QUFDSixLQXpOTzs7QUEyTlI7Ozs7QUFJQSx3Q0FBb0MsOENBQVc7QUFDM0MsZUFBTyxjQUFjLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUIsMEJBQXpCLEVBQXFELEVBQXJELENBQVA7QUFDSCxLQWpPTzs7QUFtT1I7Ozs7QUFJQSx1Q0FBbUMsMkNBQVMsYUFBVCxFQUF3QixLQUF4QixFQUErQjtBQUM5RCxZQUFJLFFBQVE7QUFDUiwyQkFBZSxhQURQO0FBRVIsbUJBQU87QUFGQyxTQUFaO0FBSUEsZUFBTyxjQUFjLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUIsMEJBQXpCLEVBQXFELEVBQXJELEVBQXlELEtBQXpELENBQVA7QUFDSCxLQTdPTzs7QUErT1I7Ozs7QUFJQSxpREFBNkMscURBQVMsYUFBVCxFQUF3QixhQUF4QixFQUF1QztBQUNoRixZQUFJLFFBQVE7QUFDUiwyQkFBZSxhQURQO0FBRVIsMkJBQWU7QUFGUCxTQUFaO0FBSUEsZUFBTyxjQUFjLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUIsZ0NBQXpCLEVBQTJELEVBQTNELEVBQStELEtBQS9ELENBQVA7QUFDSCxLQXpQTzs7QUEyUFI7Ozs7QUFJQSw4Q0FBMEMsa0RBQVMsYUFBVCxFQUF3QixhQUF4QixFQUF1QztBQUM3RSxZQUFJLFFBQVE7QUFDUiwyQkFBZSxhQURQO0FBRVIsMkJBQWU7QUFGUCxTQUFaO0FBSUEsZUFBTyxjQUFjLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUIsNkJBQXpCLEVBQXdELEVBQXhELEVBQTRELEtBQTVELENBQVA7QUFDSCxLQXJRTzs7QUF1UVI7Ozs7O0FBS0EsK0JBQTJCLG1DQUFTLFFBQVQsRUFBbUI7QUFDMUMsZUFBTyxjQUFjLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUIsYUFBekIsRUFBd0MsU0FBUyxNQUFqRCxDQUFQO0FBQ0gsS0E5UU87O0FBZ1JSOzs7OztBQUtBLDZCQUF5QixpQ0FBUyxRQUFULEVBQW1CO0FBQ3hDLGVBQU8sY0FBYyxJQUFkLENBQW1CLElBQW5CLEVBQXlCLFdBQXpCLEVBQXNDLFNBQVMsTUFBL0MsQ0FBUDtBQUNILEtBdlJPOztBQXlSUixxQ0FBaUMsMkNBQVc7QUFDeEMsZUFBTyxjQUFjLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUIsb0JBQXpCLEVBQStDLEVBQS9DLENBQVA7QUFDSCxLQTNSTzs7QUE2UlI7Ozs7OztBQU1BLG1DQUErQix1Q0FBUyxTQUFULEVBQW9CO0FBQy9DLGVBQU8sY0FBYyxJQUFkLENBQW1CLElBQW5CLEVBQXlCLGdCQUF6QixFQUEyQyxTQUEzQyxDQUFQO0FBQ0gsS0FyU087O0FBdVNSOzs7Ozs7QUFNQSxrQ0FBOEIsc0NBQVMsU0FBVCxFQUFvQjtBQUM5QyxlQUFPLGNBQWMsSUFBZCxDQUFtQixJQUFuQixFQUF5QixlQUF6QixFQUEwQyxTQUExQyxDQUFQO0FBQ0gsS0EvU087O0FBaVRSOzs7Ozs7QUFNQSw2QkFBeUIsaUNBQVMsU0FBVCxFQUFvQjtBQUN6QyxlQUFPLGNBQWMsSUFBZCxDQUFtQixJQUFuQixFQUF5QixXQUF6QixFQUFzQyxFQUF0QyxFQUEwQyxTQUExQyxDQUFQO0FBQ0gsS0F6VE87O0FBMlRSOzs7OztBQUtBLG1DQUErQix1Q0FBUyxTQUFULEVBQW9CO0FBQy9DLFlBQUksQ0FBQyxLQUFLLFlBQUwsRUFBTCxFQUEwQjtBQUFFO0FBQVM7O0FBRXJDLGVBQU8sY0FBYyxJQUFkLENBQW1CLElBQW5CLEVBQXlCLGtCQUF6QixFQUE2QyxFQUE3QyxFQUFpRCxTQUFqRCxDQUFQO0FBQ0gsS0FwVU87O0FBc1VSOzs7O0FBSUEsb0NBQWdDLDBDQUFXO0FBQ3hDLGVBQU8sY0FBYyxJQUFkLENBQW1CLElBQW5CLEVBQXlCLG1CQUF6QixFQUE4QyxFQUFFLFFBQVEsSUFBVixFQUE5QyxDQUFQO0FBQ0YsS0E1VU87O0FBOFVSLDRCQUF3QixrQ0FBVztBQUMvQixlQUFPLGNBQWMsSUFBZCxDQUFtQixJQUFuQixFQUF5QixVQUF6QixFQUFxQyxFQUFFLFFBQVEsSUFBVixFQUFyQyxDQUFQO0FBQ0gsS0FoVk87O0FBa1ZSLG1DQUErQix1Q0FBUyxDQUFULEVBQVk7QUFDdkMsZUFBTyxjQUFjLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUIsa0JBQXpCLEVBQTZDLENBQTdDLENBQVA7QUFDSCxLQXBWTzs7QUFzVlI7Ozs7Ozs7QUFPQSxxQkFBaUIseUJBQVMsU0FBVCxFQUFvQixRQUFwQixFQUE4QixRQUE5QixFQUF3QztBQUNyRCxlQUFPLGNBQWMsSUFBZCxDQUFtQixJQUFuQixFQUF5QixTQUF6QixFQUFvQztBQUN2QyxzQkFBVSxRQUQ2QjtBQUV2QyxtQkFBTztBQUZnQyxTQUFwQyxDQUFQO0FBSUgsS0FsV087O0FBb1dSLHlCQUFxQiw2QkFBUyxTQUFULEVBQW9CLEtBQXBCLEVBQTJCO0FBQzVDLGVBQU8sY0FBYyxJQUFkLENBQW1CLElBQW5CLEVBQXlCLHVCQUF6QixFQUFrRCxJQUFsRCxFQUF3RCxFQUFFLE9BQU8sS0FBVCxFQUF4RCxFQUEwRSxTQUExRSxDQUFQO0FBQ0gsS0F0V087O0FBd1dSOzs7Ozs7O0FBT0Esd0JBQW9CLDRCQUFTLFNBQVQsRUFBb0IsUUFBcEIsRUFBOEIsUUFBOUIsRUFBd0MsT0FBeEMsRUFBaUQ7QUFDakUsZUFBTyxjQUFjLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUIsc0JBQXpCLEVBQWlELElBQWpELEVBQXVEO0FBQzFELHNCQUFVLFFBRGdEO0FBRTFELHNCQUFVLFFBRmdEO0FBRzFELG1CQUFPO0FBSG1ELFNBQXZELEVBSUosU0FKSSxDQUFQO0FBS0gsS0FyWE87O0FBdVhSOzs7Ozs7O0FBT0EsdUJBQW1CLDJCQUFTLFNBQVQsRUFBb0IsUUFBcEIsRUFBOEIsUUFBOUIsRUFBd0MsT0FBeEMsRUFBaUQ7QUFDaEUsZUFBTyxjQUFjLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUIscUJBQXpCLEVBQWdEO0FBQ25ELHNCQUFVLFFBRHlDO0FBRW5ELHNCQUFVLFFBRnlDO0FBR25ELG1CQUFPO0FBSDRDLFNBQWhELEVBSUosU0FKSSxDQUFQO0FBS0gsS0FwWU87O0FBc1lSOzs7Ozs7O0FBT0EsNkJBQXlCLGlDQUFTLFNBQVQsRUFBb0IsUUFBcEIsRUFBOEIsUUFBOUIsRUFBd0MsT0FBeEMsRUFBaUQ7QUFDdEUsZUFBTyxjQUFjLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUIsNEJBQXpCLEVBQXVEO0FBQzFELHNCQUFVLFFBRGdEO0FBRTFELHNCQUFVLFFBRmdEO0FBRzFELG1CQUFPO0FBSG1ELFNBQXZELEVBSUosU0FKSSxDQUFQO0FBS0gsS0FuWk87O0FBcVpSLDBCQUFzQixnQ0FBVztBQUM3QixZQUFJLE9BQU8sSUFBWDs7QUFFQSxpQkFBUyxnQkFBVCxDQUEwQixDQUExQixFQUE2QixFQUE3QixFQUFpQztBQUM3QixnQkFBSSxLQUFLLGtCQUFMLE9BQThCLENBQWxDLEVBQXFDO0FBQ2pDO0FBQ0g7O0FBRUQsZ0JBQUksSUFBSSxLQUFLLHlCQUFMLENBQStCLEVBQUUsTUFBRixDQUFTLEtBQXhDLENBQVI7QUFBQSxnQkFDSSxjQURKO0FBQUEsZ0JBRUksY0FGSjs7QUFJQTtBQUNBLGdCQUFJLE1BQU0sQ0FBQyxFQUFFLElBQUgsSUFBVyxFQUFFLE1BQUYsQ0FBUyxTQUExQixDQUFKLEVBQTBDO0FBQ3RDLGlDQUFpQixFQUFFLFNBQW5CO0FBQ0g7O0FBRUQsZ0JBQUksY0FBSixFQUFvQjtBQUNoQixpQ0FBaUIsT0FBTyxjQUFQLENBQ2IsY0FEYSxFQUViLGdCQUZhLEVBR2I7QUFDSSwyQkFBTyxDQURYO0FBRUksZ0NBQVksS0FGaEI7QUFHSSxrQ0FBYyxJQUhsQjtBQUlJLDhCQUFVO0FBSmQsaUJBSGEsQ0FBakI7QUFVQSxtQkFBRyxJQUFILENBQVEsSUFBUixFQUFjLGNBQWQ7QUFDSDtBQUNKOztBQUVELGFBQUssd0JBQUwsQ0FBOEIsb0JBQTlCLEVBQW9ELFVBQVMsQ0FBVCxFQUFZO0FBQzVELGlCQUFLLE9BQUw7QUFDQSxpQkFBSyw2QkFBTCxDQUFtQyxDQUFuQztBQUNILFNBSEQ7O0FBS0EsYUFBSyx3QkFBTCxDQUE4QixzQkFBOUIsRUFBc0QsVUFBUyxDQUFULEVBQVk7QUFDOUQsZ0JBQUksS0FBSyxVQUFMLENBQWdCLFFBQXBCLEVBQThCO0FBQzFCO0FBQ0g7QUFDRCw2QkFBaUIsQ0FBakIsRUFBb0IsVUFBUyxVQUFULEVBQXFCO0FBQ3JDLHFCQUFLLGlCQUFMLENBQXVCLFVBQXZCO0FBQ0EscUJBQUssMkJBQUwsQ0FBaUMsVUFBakM7QUFDSCxhQUhEO0FBSUgsU0FSRDs7QUFVQSxhQUFLLHdCQUFMLENBQThCLHNCQUE5QixFQUFzRCxVQUFTLENBQVQsRUFBWTtBQUM5RCxnQkFBSSxLQUFLLFVBQUwsQ0FBZ0IsUUFBcEIsRUFBOEI7QUFDMUI7QUFDSDtBQUNELGdCQUFJLENBQUMsS0FBSyxZQUFMLEVBQUwsRUFBMEI7QUFDdEIsc0JBQU0sZUFBTjtBQUNBO0FBQ0g7O0FBRUQsNkJBQWlCLENBQWpCLEVBQW9CLFVBQVMsVUFBVCxFQUFxQjtBQUNyQywyQkFBVyxJQUFYLEdBQWtCLEVBQUUsTUFBRixDQUFTLElBQTNCO0FBQ0EscUJBQUssY0FBTCxHQUFzQixVQUF0QjtBQUNBLHFCQUFLLGlCQUFMLENBQXVCLFVBQXZCO0FBQ0EscUJBQUssMkJBQUwsQ0FBaUMsVUFBakM7QUFDQSxxQkFBSyxPQUFMO0FBQ0gsYUFORDtBQU9ILFNBaEJEOztBQWtCQSxhQUFLLHdCQUFMLENBQThCLDhCQUE5QixFQUE4RCxVQUFTLENBQVQsRUFBWTtBQUN0RSxpQkFBSyw4QkFBTCxDQUFvQyxLQUFwQztBQUNILFNBRkQ7O0FBSUEsYUFBSyx3QkFBTCxDQUE4QixrQkFBOUIsRUFBa0QsVUFBUyxDQUFULEVBQVk7QUFDMUQsZ0JBQUksS0FBSyxVQUFMLENBQWdCLFFBQXBCLEVBQThCO0FBQzFCO0FBQ0g7QUFDRCw2QkFBaUIsQ0FBakIsRUFBb0IsVUFBUyxVQUFULEVBQXFCO0FBQ3JDLDJCQUFXLElBQVgsR0FBa0IsRUFBRSxNQUFGLENBQVMsSUFBM0IsQ0FEcUMsQ0FDSjtBQUNqQyxxQkFBSyx1QkFBTCxDQUE2QixVQUE3QjtBQUNBLHFCQUFLLGFBQUwsQ0FBbUIsVUFBbkI7QUFDSCxhQUpEO0FBS0gsU0FURDs7QUFXQSxhQUFLLHdCQUFMLENBQThCLG9CQUE5QixFQUFvRCxVQUFTLENBQVQsRUFBWTtBQUM1RCxnQkFBSSxLQUFLLFVBQUwsQ0FBZ0IsUUFBcEIsRUFBOEI7QUFDMUI7QUFDSDtBQUNELGlCQUFLLFFBQUwsR0FBZ0IsS0FBaEI7QUFDQSxnQkFBSSxLQUFLLGNBQUwsRUFBSixFQUEyQjtBQUN2QixxQkFBSyxlQUFMLENBQXFCLEtBQXJCO0FBQ0g7QUFDRCxnQkFBSSxLQUFLLHVCQUFULEVBQWtDO0FBQzlCLHFCQUFLLHVCQUFMLEdBQStCLEtBQS9CO0FBQ0g7QUFDRCw2QkFBaUIsQ0FBakIsRUFBb0IsVUFBUyxVQUFULEVBQXFCO0FBQ3JDLHFCQUFLLGVBQUwsQ0FBcUIsVUFBckI7QUFDQSxvQkFBSSxLQUFLLGNBQVQsRUFBeUI7QUFDckIseUJBQUssK0JBQUwsQ0FBcUMsS0FBSyxjQUExQztBQUNIO0FBQ0QscUJBQUssY0FBTCxHQUFzQixJQUF0QjtBQUNBLHFCQUFLLHlCQUFMLENBQStCLFVBQS9CO0FBQ0gsYUFQRDtBQVFILFNBbkJEOztBQXFCQSxhQUFLLHdCQUFMLENBQThCLHFCQUE5QixFQUFxRCxVQUFTLENBQVQsRUFBWTtBQUM3RCxnQkFBSSxLQUFLLFVBQUwsQ0FBZ0IsUUFBcEIsRUFBOEI7QUFDMUI7QUFDSDtBQUNELDZCQUFpQixDQUFqQixFQUFvQixVQUFTLFVBQVQsRUFBcUI7QUFDckMscUJBQUssNkJBQUwsQ0FBbUMsVUFBbkMsRUFBK0MsQ0FBL0M7QUFDQSxxQkFBSyxtQkFBTCxDQUF5QixVQUF6QjtBQUNILGFBSEQ7QUFJSCxTQVJEOztBQVVBLGFBQUssd0JBQUwsQ0FBOEIsaUJBQTlCLEVBQWlELFVBQVMsQ0FBVCxFQUFZO0FBQ3pELGdCQUFJLEtBQUssVUFBTCxDQUFnQixRQUFwQixFQUE4QjtBQUMxQjtBQUNIO0FBQ0QsaUJBQUssUUFBTCxHQUFnQixJQUFoQjtBQUNBLDZCQUFpQixDQUFqQixFQUFvQixLQUFLLGlCQUF6QjtBQUNILFNBTkQ7O0FBUUEsYUFBSyx3QkFBTCxDQUE4QixvQkFBOUIsRUFBb0QsVUFBUyxDQUFULEVBQVk7QUFDNUQsZ0JBQUksS0FBSyxVQUFMLENBQWdCLFFBQXBCLEVBQThCO0FBQzFCO0FBQ0g7QUFDRCxpQkFBSyx5QkFBTCxDQUErQixDQUEvQjtBQUNBLGlCQUFLLGVBQUwsQ0FBcUIsQ0FBckI7QUFDSCxTQU5EOztBQVFBLGFBQUssd0JBQUwsQ0FBOEIsd0JBQTlCLEVBQXdELFVBQVMsQ0FBVCxFQUFZO0FBQ2hFLGlCQUFLLHdCQUFMLENBQThCLENBQTlCO0FBQ0gsU0FGRDs7QUFJQSxhQUFLLHdCQUFMLENBQThCLGtCQUE5QixFQUFrRCxVQUFTLENBQVQsRUFBWTtBQUMxRCxnQkFBSSxLQUFLLFVBQUwsQ0FBZ0IsUUFBcEIsRUFBOEI7QUFDMUI7QUFDSDtBQUNELGlCQUFLLHVCQUFMLENBQTZCLENBQTdCO0FBQ0EsaUJBQUssYUFBTCxDQUFtQixDQUFuQjtBQUNILFNBTkQ7O0FBUUEsYUFBSyx3QkFBTCxDQUE4Qix1QkFBOUIsRUFBdUQsVUFBUyxDQUFULEVBQVk7QUFDL0QsNkJBQWlCLENBQWpCLEVBQW9CLEtBQUssa0JBQXpCO0FBQ0gsU0FGRDs7QUFJQSxhQUFLLHdCQUFMLENBQThCLHFCQUE5QixFQUFxRCxVQUFTLENBQVQsRUFBWTtBQUM3RCxnQkFBSSxLQUFLLFVBQUwsQ0FBZ0IsUUFBcEIsRUFBOEI7QUFDMUI7QUFDSDtBQUNELDZCQUFpQixDQUFqQixFQUFvQixLQUFLLGlCQUF6QjtBQUNILFNBTEQ7O0FBT0EsYUFBSyx3QkFBTCxDQUE4Qix5QkFBOUIsRUFBeUQsVUFBUyxDQUFULEVBQVk7QUFDakUsNkJBQWlCLENBQWpCLEVBQW9CLFVBQVMsVUFBVCxFQUFvQjtBQUNwQyxxQkFBSyxtQkFBTCxDQUF5QixVQUF6QjtBQUNBLHFCQUFLLDZCQUFMLENBQW1DLFVBQW5DO0FBQ0gsYUFIRDtBQUlILFNBTEQ7O0FBT0EsYUFBSyx3QkFBTCxDQUE4QixtQkFBOUIsRUFBbUQsVUFBUyxDQUFULEVBQVk7QUFDM0QsaUJBQUssb0JBQUwsQ0FBMEIsS0FBMUI7QUFDSCxTQUZEOztBQUlBO0FBQ0EsaUJBQVMsSUFBVCxDQUFjLGdCQUFkLENBQStCLE1BQS9CLEVBQXVDLFVBQVMsR0FBVCxFQUFjO0FBQ2pELGlCQUFLLGtCQUFMLENBQXdCLEdBQXhCO0FBQ0gsU0FGRDs7QUFJQSxpQkFBUyxJQUFULENBQWMsZ0JBQWQsQ0FBK0IsT0FBL0IsRUFBd0MsVUFBUyxHQUFULEVBQWM7QUFDbEQsb0JBQVEsR0FBUixDQUFZLElBQUksYUFBSixDQUFrQixPQUFsQixDQUEwQixXQUExQixDQUFaO0FBQ0gsU0FGRDs7QUFJQSxhQUFLLHdCQUFMLENBQThCLDBCQUE5QixFQUEwRCxVQUFTLENBQVQsRUFBWTtBQUNsRSxpQkFBSywwQkFBTCxDQUFnQyxLQUFoQzs7QUFFQSxpQkFBSyxrQ0FBTDtBQUNILFNBSkQ7O0FBTUEsYUFBSyx3QkFBTCxDQUE4QixnQ0FBOUIsRUFBZ0UsVUFBUyxDQUFULEVBQVk7QUFDeEUsaUJBQUssa0NBQUw7QUFDSCxTQUZEOztBQUlBLGFBQUssd0JBQUwsQ0FBOEIsNkJBQTlCLEVBQTZELFVBQVMsQ0FBVCxFQUFZO0FBQ3JFLGlCQUFLLGtDQUFMO0FBQ0gsU0FGRDs7QUFJQSxhQUFLLHdCQUFMLENBQThCLHFCQUE5QixFQUFxRCxVQUFTLENBQVQsRUFBWTtBQUM3RCxnQkFBSSxhQUFhLEtBQUssVUFBTCxDQUFnQixVQUFoQixHQUE2QixLQUFLLHlCQUFMLEVBQTdCLEdBQWdFLENBQWpGO0FBQ0EsZ0JBQUksRUFBRSxNQUFGLENBQVMsY0FBVCxDQUF3QixDQUF4QixJQUE2QixVQUFqQyxFQUE2QztBQUN6QyxxQkFBSyx1QkFBTCxDQUE2QixFQUFFLE1BQUYsQ0FBUyxjQUF0QyxFQUFzRCxFQUFFLE1BQUYsQ0FBUyxRQUEvRCxFQUF5RSxFQUFFLE1BQUYsQ0FBUyxRQUFsRixFQUE0RixFQUFFLE1BQUYsQ0FBUyxLQUFyRztBQUNIO0FBQ0osU0FMRDs7QUFPQSxhQUFLLHdCQUFMLENBQThCLDRCQUE5QixFQUE0RCxVQUFTLENBQVQsRUFBWTtBQUNwRSxnQkFBSSxFQUFFLE1BQUYsQ0FBUyxRQUFULEtBQXNCLEVBQUUsTUFBRixDQUFTLFFBQW5DLEVBQTZDO0FBQ3pDLG9CQUFNLFNBQVMsS0FBSyxRQUFMLENBQWMsZUFBZCxDQUE4QixFQUFFLE1BQUYsQ0FBUyxjQUFULENBQXdCLENBQXRELENBQWY7QUFDQSxxQkFBSyxRQUFMLENBQWMsU0FBZCxDQUF3QixNQUF4QixFQUZ5QyxDQUVSO0FBQ2pDLG9CQUFJLEtBQUssa0JBQVQsRUFBNkI7QUFDekIsd0JBQUksTUFBSixFQUFZO0FBQ1IsNkJBQUssa0JBQUwsQ0FBd0IsTUFBeEIsRUFBZ0MsRUFBRSxNQUFGLENBQVMsUUFBekM7O0FBRUE7QUFDQSw0QkFBTSxXQUFXLEtBQUssUUFBTCxDQUFjLGdCQUFkLENBQStCLENBQS9CLENBQWpCO0FBQ0EsNEJBQUksWUFBWSxTQUFTLFNBQXpCLEVBQW9DO0FBQ2hDLGdDQUFNLE1BQU0sS0FBSyxNQUFMLENBQVksQ0FBWixDQUFaOztBQUVBLGlDQUFLLFVBQUwsR0FBa0IsT0FBbEIsQ0FBMEIsYUFBSztBQUMzQixvQ0FBSSxFQUFFLE1BQUYsSUFBWSxJQUFJLEVBQUUsSUFBTixNQUFnQixFQUFFLE1BQUYsQ0FBUyxVQUF6QyxFQUFxRDtBQUNqRCx3Q0FBSSxFQUFFLElBQU4sSUFBYyxFQUFFLE1BQUYsQ0FBUyxVQUF2QjtBQUNIO0FBQ0osNkJBSkQ7QUFLSDtBQUNKO0FBQ0o7QUFDSjtBQUNKLFNBdEJEOztBQXdCQSxhQUFLLHdCQUFMLENBQThCLHFCQUE5QixFQUFxRCxVQUFTLENBQVQsRUFBWTtBQUM3RCxpQkFBSyxxQkFBTCxDQUEyQixDQUEzQjtBQUNILFNBRkQ7QUFHSCxLQS9tQk87O0FBaW5CUjs7Ozs7QUFLQSx3QkFBb0IsNEJBQVMsS0FBVCxFQUFnQjtBQUNoQyxhQUFLLFFBQUwsQ0FBYyxZQUFkLENBQTJCLElBQTNCLEVBQWlDLEtBQWpDO0FBQ0gsS0F4bkJPOztBQTBuQlI7Ozs7O0FBS0EsdUJBQW1CLDJCQUFTLEtBQVQsRUFBZ0I7QUFDL0IsYUFBSyxRQUFMLENBQWMsZUFBZCxDQUE4QixJQUE5QixFQUFvQyxLQUFwQztBQUNILEtBam9CTzs7QUFtb0JSOzs7OztBQUtBLHlCQUFxQiw2QkFBUyxLQUFULEVBQWdCO0FBQ2pDLGFBQUssUUFBTCxDQUFjLGFBQWQsQ0FBNEIsSUFBNUIsRUFBa0MsS0FBbEM7QUFDSCxLQTFvQk87O0FBNG9CUjs7Ozs7QUFLQSwwQkFBc0IsOEJBQVMsS0FBVCxFQUFnQjtBQUNsQyxhQUFLLFFBQUwsQ0FBYyxjQUFkLENBQTZCLElBQTdCLEVBQW1DLEtBQW5DO0FBQ0gsS0FucEJPOztBQXFwQlIsZ0NBQTRCLG9DQUFTLEtBQVQsRUFBZ0I7QUFDeEMsYUFBSyxRQUFMLENBQWMsb0JBQWQsQ0FBbUMsSUFBbkMsRUFBeUMsS0FBekM7QUFDSCxLQXZwQk87O0FBeXBCUjs7Ozs7QUFLQSx1QkFBbUIsMkJBQVMsWUFBVCxFQUF1QjtBQUN0QyxhQUFLLFFBQUwsQ0FBYyxXQUFkLENBQTBCLElBQTFCLEVBQWdDLFlBQWhDO0FBQ0gsS0FocUJPOztBQWtxQlI7Ozs7O0FBS0EsdUJBQW1CLDJCQUFTLFlBQVQsRUFBdUI7QUFDdEMsYUFBSyxRQUFMLENBQWMsZUFBZCxDQUE4QixJQUE5QixFQUFvQyxZQUFwQztBQUNILEtBenFCTzs7QUEycUJSOzs7OztBQUtBLG9DQUFnQyx3Q0FBUyxZQUFULEVBQXVCO0FBQ25ELGFBQUssUUFBTCxDQUFjLDRCQUFkLENBQTJDLElBQTNDLEVBQWlELFlBQWpEO0FBQ0gsS0FsckJPOztBQW9yQlI7Ozs7O0FBS0EscUJBQWlCLHlCQUFTLFlBQVQsRUFBdUI7QUFDcEMsYUFBSyxRQUFMLENBQWMsU0FBZCxDQUF3QixJQUF4QixFQUE4QixZQUE5QjtBQUNILEtBM3JCTzs7QUE2ckJSOzs7OztBQUtBLG1CQUFlLHVCQUFTLFlBQVQsRUFBdUI7QUFDbEMsYUFBSyxRQUFMLENBQWMsT0FBZCxDQUFzQixJQUF0QixFQUE0QixZQUE1QjtBQUNILEtBcHNCTzs7QUFzc0JSOzs7OztBQUtBLHVCQUFtQiwyQkFBUyxZQUFULEVBQXVCO0FBQ3RDLGFBQUssUUFBTCxDQUFjLFdBQWQsQ0FBMEIsSUFBMUIsRUFBZ0MsWUFBaEM7QUFDSCxLQTdzQk87O0FBK3NCUjs7Ozs7QUFLQSx5QkFBcUIsNkJBQVMsWUFBVCxFQUF1QjtBQUN4QyxhQUFLLFFBQUwsQ0FBYyxhQUFkLENBQTRCLElBQTVCLEVBQWtDLFlBQWxDO0FBQ0gsS0F0dEJPOztBQXd0QlI7Ozs7OztBQU1BLHFCQUFpQix5QkFBUyxLQUFULEVBQWdCO0FBQzdCLGFBQUssUUFBTCxDQUFjLFNBQWQsQ0FBd0IsSUFBeEIsRUFBOEIsS0FBOUI7QUFDSCxLQWh1Qk87O0FBa3VCUjs7Ozs7O0FBTUEsOEJBQTBCLGtDQUFTLEtBQVQsRUFBZ0I7QUFDdEMsYUFBSyxRQUFMLENBQWMsa0JBQWQsQ0FBaUMsSUFBakMsRUFBdUMsS0FBdkM7QUFDSCxLQTF1Qk87O0FBNHVCUjs7Ozs7O0FBTUEsbUJBQWUsdUJBQVMsS0FBVCxFQUFnQjtBQUMzQixhQUFLLFFBQUwsQ0FBYyxPQUFkLENBQXNCLElBQXRCLEVBQTRCLEtBQTVCO0FBQ0gsS0FwdkJPOztBQXN2QlI7Ozs7OztBQU1BLDJCQUF1QiwrQkFBUyxLQUFULEVBQWdCO0FBQ25DLGFBQUssUUFBTCxDQUFjLFdBQWQsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBaEM7QUFDSDtBQTl2Qk8sQ0FBWjs7QUFpd0JBLElBQUksVUFBVSxDQUNWLFVBRFUsRUFFVixVQUZVLEVBR1YsWUFIVSxFQUlWLE1BSlUsRUFLVixLQUxVLENBQWQ7O0FBUUE7Ozs7Ozs7O0FBUUEsU0FBUyxhQUFULENBQXVCLFNBQXZCLEVBQWtDLFVBQWxDLEVBQThDLEtBQTlDLEVBQXFELGNBQXJELEVBQXFFO0FBQ2pFLFFBQUksTUFBSixFQUFZLE1BQVo7O0FBRUEsUUFBSSxDQUFDLEtBQUssTUFBVixFQUFrQjtBQUNkO0FBQ0g7O0FBRUQsUUFBSSxPQUFPLFVBQVAsS0FBc0IsU0FBMUIsRUFBcUM7QUFDakMseUJBQWlCLEtBQWpCLENBRGlDLENBQ1Q7QUFDeEIsZ0JBQVEsVUFBUixDQUZpQyxDQUViO0FBQ3BCLHFCQUFhLEtBQWIsQ0FIaUMsQ0FHYjtBQUN2Qjs7QUFFRCxRQUFJLENBQUMsTUFBTSxNQUFYLEVBQW1CO0FBQ2YsZ0JBQVEsRUFBRSxRQUFRLEtBQVYsRUFBUjtBQUNIOztBQUVELGFBQVMsTUFBTSxNQUFmOztBQUVBLFFBQUksQ0FBQyxPQUFPLElBQVosRUFBa0I7QUFBRTtBQUNoQixlQUFPLElBQVAsR0FBYyxJQUFkO0FBQ0g7O0FBRUQsV0FBTyxJQUFQLEdBQWMsS0FBSyxHQUFMLEVBQWQ7O0FBRUEsUUFBSSxjQUFKLEVBQW9CO0FBQ2hCLFlBQUksQ0FBQyxPQUFPLGNBQVosRUFBNEI7QUFDeEIsbUJBQU8sY0FBUCxHQUF3QixjQUF4QjtBQUNIO0FBQ0QsZ0JBQVEsT0FBUixDQUFnQixVQUFTLEdBQVQsRUFBYztBQUMxQixnQkFBSSxPQUFPLGNBQVAsSUFBeUIsRUFBRSxPQUFPLE1BQVQsQ0FBN0IsRUFBK0M7QUFDM0MsdUJBQU8sR0FBUCxJQUFjLGVBQWUsR0FBZixDQUFkO0FBQ0g7QUFDSixTQUpEO0FBS0EsWUFBSSxhQUFhLGNBQWpCLEVBQWlDO0FBQzdCO0FBQ0EsbUJBQU8sY0FBUCxDQUFzQixNQUF0QixFQUE4QixLQUE5QixFQUFxQyxFQUFFLEtBQUssZUFBVztBQUFFLDJCQUFPLGVBQWUsT0FBdEI7QUFBZ0MsaUJBQXBELEVBQXJDO0FBQ0g7QUFDSjs7QUFFRCxRQUFJLFVBQUosRUFBZ0I7QUFDWixjQUFNLFVBQU4sR0FBbUIsSUFBbkI7QUFDSDs7QUFFRCxhQUFTLEtBQUssTUFBTCxDQUFZLGFBQVosQ0FBMEIsSUFBSSxXQUFKLENBQWdCLFNBQWhCLEVBQTJCLEtBQTNCLENBQTFCLENBQVQ7O0FBRUEsV0FBTyxDQUFDLFVBQUQsSUFBZSxNQUF0QjtBQUNIOztBQUVELE9BQU8sT0FBUCxHQUFpQjtBQUNiLFdBQU8sS0FETTtBQUViLG1CQUFlO0FBRkYsQ0FBakI7OztBQzUwQkE7O0FBRUE7Ozs7QUFFQSxRQUFRLGtCQUFSLEUsQ0FBNkI7O0FBRTdCLElBQUksUUFBUSxRQUFRLGFBQVIsRUFBdUIsS0FBbkM7QUFDQSxJQUFJLFlBQVksUUFBUSxhQUFSLEVBQXVCLFNBQXZDO0FBQ0EsSUFBSSxJQUFJLFFBQVEsa0JBQVIsQ0FBUixDLENBQXFDO0FBQ3JDLElBQUksWUFBWSxRQUFRLDRCQUFSLEVBQXNDLElBQXRDLENBQTJDLFFBQVEsV0FBUixDQUEzQyxDQUFoQjs7QUFFQSxJQUFJLE9BQU8sUUFBUSxTQUFSLENBQVg7QUFDQSxJQUFJLFdBQVcsUUFBUSxhQUFSLENBQWY7QUFDQSxJQUFJLDZCQUE2QixRQUFRLDBCQUFSLENBQWpDO0FBQ0EsSUFBSSxTQUFTLFFBQVEsZUFBUixDQUFiO0FBQ0EsSUFBSSxXQUFXLFFBQVEsYUFBUixDQUFmO0FBQ0EsSUFBSSxpQkFBaUIsUUFBUSx1QkFBUixDQUFyQjtBQUNBLElBQUksZUFBZSxRQUFRLHFCQUFSLENBQW5CO0FBQ0EsSUFBSSxXQUFXLFFBQVEsdUJBQVIsQ0FBZjtBQUNBLElBQUksZUFBZSxRQUFRLG9CQUFSLENBQW5CO0FBQ0EsSUFBSSxnQkFBZ0IsUUFBUSxrQkFBUixDQUFwQjtBQUNBLElBQUksY0FBYyxRQUFRLGdCQUFSLENBQWxCO0FBQ0EsSUFBSSxVQUFVLFFBQVEsV0FBUixDQUFkOztBQUVBLElBQUksY0FBYyxDQUFDLEtBQUQsRUFBUSxRQUFSLEVBQWtCLE1BQWxCLEVBQTBCLE9BQTFCLENBQWxCO0FBQUEsSUFDSSxjQUFjLFlBQVksTUFBWixDQUFtQixDQUFDLE9BQUQsRUFBVSxRQUFWLEVBQW9CLFVBQXBCLENBQW5CLENBRGxCOztBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkNBLElBQUksWUFBWSxLQUFLLE1BQUwsQ0FBWSxXQUFaLEVBQXlCO0FBQ3JDLGdCQUFZLG9CQUFTLFNBQVQsRUFBb0IsT0FBcEIsRUFBNkI7QUFBQTs7QUFDckMsYUFBSyxtQkFBTDs7QUFFQTtBQUNBLFlBQUksRUFBRSxPQUFPLFNBQVAsS0FBcUIsUUFBdkIsS0FBb0MsRUFBRSxxQkFBcUIsV0FBdkIsQ0FBeEMsRUFBNkU7QUFDekUsc0JBQVUsU0FBVjtBQUNBLHdCQUFZLElBQVo7QUFDSDs7QUFFRCxrQkFBVSxXQUFXLEVBQXJCOztBQUVBLGFBQUssVUFBTDs7QUFFQTtBQUNBLGFBQUssWUFBTCxDQUNJLGFBQ0EsUUFBUSxTQURSLElBRUEsc0JBQXNCLFFBQVEsWUFBOUIsQ0FISjs7QUFNQTtBQUNBLGtCQUFVLFNBQVYsQ0FBb0IsY0FBcEIsQ0FBbUMsUUFBUSxPQUEzQzs7QUFFQSxhQUFLLGlCQUFMLEdBQXlCLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBekI7QUFDQSxhQUFLLFFBQUwsR0FBZ0IsVUFBVSxTQUFWLENBQW9CLFdBQXBCLEdBQWtDLE9BQWxDLENBQTBDLFFBQTFDLElBQXNELENBQUMsQ0FBdkU7QUFDQSxZQUFJLEtBQUssY0FBVCxFQUF5QjtBQUNyQixpQkFBSyxjQUFMLENBQW9CLEtBQXBCO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsaUJBQUssY0FBTCxHQUFzQixJQUFJLGNBQUosQ0FBbUIsSUFBbkIsQ0FBdEI7QUFDSDs7QUFFRCxhQUFLLG9CQUFMLEdBQTRCLEVBQTVCO0FBQ0EsYUFBSyxrQkFBTCxHQUEwQixJQUExQjtBQUNBLGFBQUssVUFBTCxHQUFrQixJQUFJLEtBQUosQ0FBVSxDQUFWLEVBQWEsQ0FBYixDQUFsQjtBQUNBLGFBQUssT0FBTCxHQUFlLENBQWY7QUFDQSxhQUFLLFVBQUwsR0FBa0IsQ0FBbEI7QUFDQSxhQUFLLGNBQUw7QUFDQSxhQUFLLFlBQUwsQ0FBa0IsUUFBUSxZQUExQjtBQUNBLGFBQUssU0FBTCxHQUFpQixFQUFqQjs7QUFFQTs7Ozs7QUFLQSxhQUFLLGFBQUwsR0FBcUIsYUFBckI7O0FBRUE7Ozs7OztBQU1BLGFBQUssV0FBTCxHQUFtQixPQUFPLE1BQVAsQ0FBYyxXQUFkLENBQW5CO0FBQ0EsZUFBTyxjQUFQLENBQXNCLEtBQUssV0FBM0IsRUFBd0MsUUFBeEMsRUFBa0QsRUFBRSxPQUFPLGlCQUFpQixJQUFqQixDQUFzQixJQUF0QixDQUFULEVBQWxEOztBQUVBLGFBQUssVUFBTCxDQUFnQixPQUFoQjs7QUFFQSxZQUFJLFFBQVEsSUFBWixFQUFrQjtBQUNkLGlCQUFLLE9BQUwsQ0FBYSxRQUFRLElBQXJCLEVBQTJCLE9BQTNCLEVBRGMsQ0FDdUI7QUFDeEMsU0FGRCxNQUVPO0FBQ0g7QUFDQSxnQkFBSSxDQUFDLEtBQUssUUFBVixFQUFvQjtBQUNoQixxQkFBSyxXQUFMLENBQWlCLE9BQWpCO0FBQ0g7QUFDRCxpQkFBSyxjQUFMO0FBQ0g7O0FBRUQsWUFBSSxRQUFRLEtBQVosRUFBbUI7QUFDZixpQkFBSyxTQUFMLENBQWUsUUFBUSxLQUF2QjtBQUNIOztBQUVELFlBQUksUUFBUSxLQUFaLEVBQW1CO0FBQ2YsaUJBQUssVUFBTCxDQUFnQixRQUFRLEtBQXhCO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0EsYUFBSyxHQUFMLEdBQVcsUUFBUSxHQUFSLElBQWUsRUFBMUI7QUFDQSxhQUFLLFNBQUwsR0FBaUIsUUFBUSxTQUFSLElBQXFCLEVBQXRDO0FBQ0E7QUFDQSxZQUFJLG1CQUFtQixTQUFuQixnQkFBbUIsQ0FBUyxJQUFULEVBQWUsRUFBZixFQUFtQixPQUFuQixFQUE0QjtBQUMvQyxpQkFBSyxJQUFJLENBQVQsSUFBYyxJQUFkLEVBQW9CO0FBQ2hCLG9CQUFJLEtBQUssY0FBTCxDQUFvQixDQUFwQixDQUFKLEVBQTRCO0FBQ3hCLHdCQUFJLE9BQU8sS0FBSyxDQUFMLENBQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDL0IsMkJBQUcsQ0FBSCxJQUFRLEtBQUssQ0FBTCxFQUFRLElBQVIsQ0FBYSxPQUFiLENBQVI7QUFDSCxxQkFGRCxNQUVPLElBQUksUUFBTyxJQUFQLHlDQUFPLElBQVAsT0FBZ0IsUUFBcEIsRUFBOEI7QUFDakMsNEJBQUksTUFBTSxPQUFOLENBQWMsS0FBSyxDQUFMLENBQWQsQ0FBSixFQUE0QjtBQUN4QiwrQkFBRyxDQUFILElBQVEsRUFBUjtBQUNILHlCQUZELE1BRU87QUFDSCwrQkFBRyxDQUFILElBQVEsS0FBSyxDQUFMLENBQVI7QUFDQSw2Q0FBaUIsR0FBRyxDQUFILENBQWpCLEVBQXdCLEtBQUssQ0FBTCxDQUF4QixFQUFpQyxPQUFqQztBQUNIO0FBQ0o7QUFDSjtBQUNKO0FBQ0osU0FmRDs7QUFpQkEseUJBQWlCLFFBQVEsT0FBUixDQUFqQixFQUFtQyxLQUFLLEdBQXhDLEVBQTZDLElBQTdDO0FBQ0EseUJBQWlCLFFBQVEsYUFBUixDQUFqQixFQUF5QyxLQUFLLFNBQTlDLEVBQXlELElBQXpEOztBQUVBLGFBQUssVUFBTCxHQUFrQixRQUFRLFVBQVIsSUFBc0IsRUFBeEM7QUFDQSxhQUFLLGlCQUFMLEdBQXlCLEtBQUssVUFBTCxDQUFnQixNQUFoQixDQUF1QixVQUFDLEVBQUQ7QUFBQSxtQkFBUSxDQUFDLEdBQUcsUUFBWjtBQUFBLFNBQXZCLENBQXpCO0FBQ0EsYUFBSyxJQUFMLEdBQVksUUFBUSxJQUFSLElBQWdCLEVBQTVCO0FBQ0EsYUFBSyxPQUFMLEdBQWUsUUFBUSxPQUFSLElBQW1CLEVBQWxDO0FBQ0EsYUFBSyxrQkFBTCxHQUEwQixRQUFRLGtCQUFSLElBQThCLEtBQUssa0JBQW5DLElBQXlELElBQW5GOztBQUVBLFNBQUU7QUFDRSx5QkFESixFQUVJLG9CQUZKLEVBR0ksZ0JBSEosRUFJSSxrQkFKSixFQUtJLHFCQUxKLEVBTUksdUJBTkosRUFPSSxZQVBKLEVBUUksaUJBUkosRUFTSSxXQVRKLEVBVUUsT0FWRixDQVVVLGFBQUs7QUFDWCxrQkFBSyxDQUFMLElBQVUsUUFBUSxDQUFSLEtBQWMsTUFBSyxDQUFMLENBQXhCO0FBQ0gsU0FaRDs7QUFjQSxZQUFJLEtBQUssY0FBVCxFQUF5QjtBQUNyQixpQkFBSyx3QkFBTCxDQUE4QixtQkFBOUIsRUFBbUQsVUFBQyxDQUFELEVBQU87QUFDdEQsc0JBQUssY0FBTCxDQUFvQixFQUFFLE1BQUYsQ0FBUyxPQUE3QixFQUFzQyxFQUFFLE1BQUYsQ0FBUyxPQUEvQztBQUNILGFBRkQ7QUFHSDs7QUFFRDs7Ozs7Ozs7Ozs7OztBQWFBLGFBQUssT0FBTCxHQUFlLEVBQWY7O0FBRUE7QUFDQSxhQUFLLGNBQUwsQ0FBb0IsUUFBUSxPQUE1Qjs7QUFFQTtBQUNBLGlCQUFTLGdCQUFULENBQTBCLFdBQTFCLEVBQXVDLEtBQUssWUFBTCxHQUFvQixZQUFXO0FBQ2xFLGlCQUFLLFlBQUw7QUFDSCxTQUYwRCxDQUV6RCxJQUZ5RCxDQUVwRCxJQUZvRCxDQUEzRDs7QUFJQSxtQkFBVyxLQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLElBQWxCLENBQVg7O0FBRUEsa0JBQVUsS0FBVixDQUFnQixJQUFoQixDQUFxQixJQUFyQjs7QUFFQSxhQUFLLGVBQUwsQ0FBcUIsS0FBckI7QUFDQSxhQUFLLGVBQUwsQ0FBcUIsT0FBckI7QUFDQSxhQUFLLGVBQUwsQ0FBcUIsUUFBckI7QUFDQSxhQUFLLGVBQUwsQ0FBcUIsTUFBckI7QUFDSCxLQXBLb0M7O0FBc0tyQzs7O0FBR0EsZUFBVyxxQkFBVztBQUNsQixpQkFBUyxtQkFBVCxDQUE2QixXQUE3QixFQUEwQyxLQUFLLFlBQS9DO0FBQ0EsYUFBSyxNQUFMLENBQVksSUFBWjtBQUNBLFlBQUksS0FBSyxLQUFULEVBQWdCO0FBQ1osc0JBQVUsS0FBVixDQUFnQixNQUFoQixDQUF1QixLQUFLLEtBQUwsQ0FBVyxPQUFYLENBQW1CLElBQW5CLENBQXZCLEVBQWlELENBQWpEO0FBQ0g7QUFDSixLQS9Lb0M7O0FBaUxyQzs7O0FBR0EsYUFBUyxtQkFBVztBQUNoQjtBQUNBLFlBQUksQ0FBQyxTQUFTLElBQVQsQ0FBYyxRQUFkLENBQXVCLEtBQUssR0FBNUIsQ0FBTCxFQUF1QztBQUNuQyxpQkFBSyxTQUFMO0FBQ0EsaUJBQUssR0FBTCxHQUFXLFNBQVg7QUFDQSxtQkFBTyxLQUFQO0FBQ0g7QUFDRCxlQUFPLElBQVA7QUFDSCxLQTVMb0M7O0FBOExyQyxxQkFBaUIseUJBQVMsSUFBVCxFQUFlO0FBQzVCLGVBQU8sUUFBUSxFQUFmOztBQUVBLFlBQUksV0FBVyxlQUFlLElBQTlCO0FBQUEsWUFDSSxZQUFZLFdBQVcsSUFEM0I7QUFBQSxZQUVJLFFBQVEsS0FBSyxVQUZqQjtBQUFBLFlBR0ksU0FBUyxNQUFNLFFBQU4sQ0FIYjs7QUFLQSxnQkFBUSxNQUFSO0FBQ0ksaUJBQUssSUFBTDtBQUNJLHlCQUFTLE1BQU0sU0FBTixHQUFrQixXQUFsQixHQUFnQyxNQUFNLFNBQS9DO0FBQ0E7QUFDSixpQkFBSyxLQUFMO0FBQ0kseUJBQVMsSUFBVDtBQUNBO0FBTlI7QUFRQSxhQUFLLE1BQUwsQ0FBWSxNQUFaLENBQW1CLEtBQW5CLENBQXlCLFNBQXpCLElBQXNDLE1BQXRDO0FBQ0gsS0EvTW9DOztBQWlOckMsYUFBUyxPQWpONEIsRUFpTm5COztBQUVsQjs7Ozs7O0FBTUEsY0FBVSxJQXpOMkI7O0FBMk5yQzs7OztBQUlBLGNBQVUsSUEvTjJCOztBQWlPckM7Ozs7O0FBS0EsZUFBVyxFQXRPMEI7O0FBd09yQzs7Ozs7O0FBTUEsZ0JBQVksSUE5T3lCOztBQWdQckM7Ozs7QUFJQSxvQkFBZ0IsSUFwUHFCOztBQXNQckM7Ozs7QUFJQSxnQkFBWSxJQTFQeUI7O0FBNFByQzs7OztBQUlBLGlCQUFhLElBaFF3Qjs7QUFrUXJDOzs7Ozs7QUFNQSwwQkFBc0IsRUF4UWU7O0FBMFFyQzs7Ozs7O0FBTUEsZUFBVyxJQWhSMEI7O0FBa1JyQyx1QkFBbUIsSUFsUmtCOztBQW9SckM7OztBQUdBLGtCQUFjLHNCQUFTLFNBQVQsRUFBb0IsS0FBcEIsRUFBMkI7QUFDckMsYUFBSyxHQUFMLENBQVMsWUFBVCxDQUFzQixTQUF0QixFQUFpQyxLQUFqQztBQUNILEtBelJvQzs7QUEyUnJDOzs7QUFHQSxnQkFBWSxzQkFBVztBQUNuQjs7Ozs7Ozs7Ozs7OztBQWFBLGFBQUssVUFBTCxHQUFrQixPQUFPLGdCQUFQLENBQXdCLEtBQUssY0FBTCxFQUF4QixFQUErQztBQUM3RCxrQkFBTSxFQUFFLE9BQU8sSUFBVCxFQUR1RDtBQUU3RCxpQkFBSyxFQUFFLE9BQU8sSUFBSSxHQUFKLEVBQVQ7QUFGd0QsU0FBL0MsQ0FBbEI7O0FBS0E7QUFDQTtBQUNBLGVBQU8sSUFBUCxDQUFZLFFBQVosRUFBc0IsT0FBdEIsQ0FBOEIsVUFBUyxHQUFULEVBQWM7QUFDeEMsZ0JBQUksUUFBUSxTQUFTLEdBQVQsQ0FBWjtBQUNBLGdCQUFJLFFBQU8sS0FBUCx5Q0FBTyxLQUFQLE9BQWlCLFFBQXJCLEVBQStCO0FBQzNCLG9CQUFJLDJCQUEyQixHQUEzQixDQUFKLEVBQXFDO0FBQ2pDLHlCQUFLLEdBQUwsSUFBWSxLQUFaLENBRGlDLENBQ2Q7QUFDdEIsaUJBRkQsTUFFTztBQUNILHlCQUFLLEdBQUwsSUFBWSxVQUFVLEtBQVYsQ0FBWixDQURHLENBQzJCO0FBQ2pDO0FBQ0o7QUFDSixTQVRELEVBU0csS0FBSyxVQVRSO0FBVUgsS0E3VG9DOztBQStUckM7Ozs7Ozs7QUFPQSxXQUFPLGVBQVMsT0FBVCxFQUFrQjtBQUNyQixhQUFLLFVBQUw7O0FBRUEsYUFBSyx1QkFBTDs7QUFFQSxhQUFLLGlCQUFMLEdBQXlCLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBekI7QUFDQSxhQUFLLGNBQUwsQ0FBb0IsS0FBcEI7QUFDQSxhQUFLLG9CQUFMLEdBQTRCLEVBQTVCO0FBQ0EsYUFBSyxjQUFMO0FBQ0EsYUFBSyxVQUFMLEdBQWtCLElBQUksS0FBSixDQUFVLENBQVYsRUFBYSxDQUFiLENBQWxCOztBQUVBLGFBQUssT0FBTCxHQUFlLENBQWY7QUFDQSxhQUFLLFVBQUwsR0FBa0IsQ0FBbEI7O0FBRUEsYUFBSyxZQUFMLEdBQW9CLENBQXBCO0FBQ0EsYUFBSyxZQUFMLEdBQW9CLENBQXBCOztBQUVBLGFBQUssYUFBTDs7QUFFQSxhQUFLLGtCQUFMLEdBQTBCLElBQTFCO0FBQ0EsYUFBSyxrQkFBTCxHQUEwQixJQUExQjs7QUFFQSxhQUFLLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxhQUFLLFlBQUwsR0FBb0IsS0FBcEI7QUFDQSxhQUFLLGlCQUFMLEdBQXlCLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBekI7O0FBRUEsYUFBSyxRQUFMLENBQWMsS0FBZCxDQUFvQjtBQUNoQixzQkFBVSxXQUFXLFFBQVE7QUFEYixTQUFwQjs7QUFJQSxhQUFLLFFBQUwsQ0FBYyxLQUFkO0FBQ0EsYUFBSyxNQUFMLENBQVksTUFBWjtBQUNBLGFBQUssZUFBTDs7QUFFQSxhQUFLLGlCQUFMO0FBQ0gsS0F6V29DOztBQTJXckM7Ozs7Ozs7Ozs7OztBQVlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBLG9CQUFnQix3QkFBUyxPQUFULEVBQWtCO0FBQzlCLFlBQUksU0FBUyxTQUFTLFVBQVUsU0FBaEMsQ0FEOEIsQ0FDYTs7QUFFM0MsWUFBSSxDQUFDLE9BQUwsRUFBYztBQUNWO0FBQ0gsU0FGRCxNQUVPLElBQUksQ0FBQyxNQUFNLE9BQU4sQ0FBYyxPQUFkLENBQUwsRUFBNkI7QUFDaEMsc0JBQVUsQ0FBQyxPQUFELENBQVY7QUFDSDs7QUFFRCxnQkFBUSxPQUFSLENBQWdCLFVBQVMsTUFBVCxFQUFpQjtBQUM3QixnQkFBSSxJQUFKLEVBQVUsSUFBVixFQUFnQixJQUFoQjs7QUFFQSxnQkFBSSxDQUFDLE1BQUwsRUFBYTtBQUNULHVCQURTLENBQ0Q7QUFDWDs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxtQkFBTyxDQUFDLElBQUQsQ0FBUDtBQUNBLGdCQUFJLE1BQUosRUFBWTtBQUNSLHFCQUFLLElBQUwsQ0FBVSxTQUFTLFNBQW5CO0FBQ0g7O0FBRUQsZ0JBQUksTUFBTSxPQUFOLENBQWMsTUFBZCxDQUFKLEVBQTJCO0FBQ3ZCLG9CQUFJLENBQUMsT0FBTyxNQUFaLEVBQW9CO0FBQ2hCLDZCQUFTLFNBQVQ7QUFDSCxpQkFGRCxNQUVPLElBQUksT0FBTyxPQUFPLENBQVAsQ0FBUCxLQUFxQixRQUF6QixFQUFtQztBQUN0QywyQkFBTyxLQUFLLE1BQUwsQ0FBWSxPQUFPLEtBQVAsQ0FBYSxDQUFiLENBQVosQ0FBUDtBQUNBLDZCQUFTLE9BQU8sQ0FBUCxDQUFUO0FBQ0gsaUJBSE0sTUFHQSxJQUFJLE9BQU8sTUFBUCxJQUFpQixDQUFyQixFQUF3QjtBQUMzQiwyQkFBTyxLQUFLLE1BQUwsQ0FBWSxPQUFPLEtBQVAsQ0FBYSxDQUFiLENBQVosQ0FBUDtBQUNBLDJCQUFPLE9BQU8sQ0FBUCxDQUFQO0FBQ0EsNkJBQVMsT0FBTyxDQUFQLENBQVQ7QUFDSCxpQkFKTSxNQUlBO0FBQ0gsNkJBQVMsU0FBVDtBQUNIO0FBQ0o7O0FBRUQsZ0JBQUksQ0FBQyxNQUFMLEVBQWE7QUFDVCx1QkFEUyxDQUNEO0FBQ1g7O0FBRUQ7QUFDQSxtQkFBTyxRQUFRLE9BQU8sSUFBZixJQUF1QixPQUFPLFlBQXJDO0FBQ0EsZ0JBQUksSUFBSixFQUFVO0FBQ047QUFDQSx1QkFBTyxLQUFLLE1BQUwsQ0FBWSxDQUFaLEVBQWUsQ0FBZixFQUFrQixXQUFsQixLQUFrQyxLQUFLLE1BQUwsQ0FBWSxDQUFaLENBQXpDO0FBQ0g7O0FBRUQsZ0JBQUksTUFBSixFQUFZO0FBQ1I7QUFDQSx1QkFBTyxLQUFLLFdBQUwsQ0FBaUIsT0FBeEI7QUFDQSxvQkFBSSxPQUFPLFVBQVAsSUFBcUIsQ0FBQyxLQUFLLElBQUwsQ0FBMUIsRUFBc0M7QUFDbEMsMkJBQU8sVUFBUCxDQUFrQixLQUFsQixDQUF3QixNQUF4QixFQUFnQyxJQUFoQztBQUNIO0FBQ0osYUFORCxNQU1PO0FBQUU7QUFDTCx1QkFBTyxLQUFLLE9BQVo7QUFDQSxvQkFBSSxPQUFPLE1BQVAsS0FBa0IsVUFBdEIsRUFBa0M7QUFDOUI7QUFDQSw2QkFBUyxLQUFLLFdBQUwsQ0FBaUIsTUFBakIsRUFBeUIsSUFBekIsQ0FBVDtBQUNILGlCQUhELE1BR08sSUFBSSxPQUFPLE9BQVgsRUFBb0I7QUFDdkI7QUFDQSwyQkFBTyxPQUFQLENBQWUsS0FBZixDQUFxQixNQUFyQixFQUE2QixJQUE3QjtBQUNILGlCQUhNLE1BR0EsSUFBSSxDQUFDLE9BQU8sVUFBWixFQUF3QjtBQUMzQiwwQkFBTSxJQUFJLEtBQUssU0FBTCxDQUFlLGNBQW5CLENBQWtDLG1HQUFsQyxDQUFOO0FBQ0g7QUFDSjs7QUFFRCxnQkFBSSxJQUFKLEVBQVU7QUFDTixxQkFBSyxJQUFMLElBQWEsTUFBYjtBQUNIO0FBRUosU0FoRUQsRUFnRUcsSUFoRUg7QUFpRUgsS0ExZG9DOztBQTRkckM7Ozs7Ozs7Ozs7Ozs7O0FBY0Esc0JBQWtCLDBCQUFTLFdBQVQsRUFBc0I7QUFDcEMsWUFBSSxDQUFDLFdBQUwsRUFBa0I7QUFDZCwwQkFBYyxFQUFkO0FBQ0gsU0FGRCxNQUVPLElBQUksQ0FBQyxNQUFNLE9BQU4sQ0FBYyxXQUFkLENBQUwsRUFBaUM7QUFDcEMsMEJBQWMsQ0FBQyxXQUFELENBQWQ7QUFDSDtBQUNELFVBQUUsS0FBSyxPQUFQLEVBQWdCLElBQWhCLENBQXFCLFVBQVMsTUFBVCxFQUFpQixHQUFqQixFQUFzQixPQUF0QixFQUErQjtBQUNoRCxnQkFDSSxRQUFRLGNBQVIsQ0FBdUIsR0FBdkIsS0FDQSxZQUFZLE9BQVosQ0FBb0IsR0FBcEIsS0FBNEIsQ0FENUIsSUFFQSxPQUFPLFNBSFgsRUFJRTtBQUNFLHVCQUFPLFNBQVAsQ0FBaUIsSUFBakIsRUFBdUIsR0FBdkIsRUFBNEIsT0FBNUI7QUFDSDtBQUNKLFNBUkQsRUFRRyxJQVJIO0FBU0gsS0F6Zm9DOztBQTJmckMsd0JBQW9CLDhCQUFXO0FBQzNCLGFBQUssUUFBTCxDQUFjLGtCQUFkO0FBQ0gsS0E3Zm9DOztBQStmckMsa0JBQWMsc0JBQVMsT0FBVCxFQUFrQjtBQUM1QixrQkFBVSxXQUFXLEVBQXJCO0FBQ0EsYUFBSyxZQUFMLEdBQW9CLElBQUksWUFBSixDQUNoQixRQUFRLE1BQVIsSUFBa0IsVUFBVSxZQUFWLENBQXVCLE1BRHpCLEVBRWhCLFFBQVEsYUFBUixJQUF5QixVQUFVLFlBQVYsQ0FBdUIsYUFGaEMsRUFHaEIsUUFBUSxXQUFSLElBQXVCLFVBQVUsWUFBVixDQUF1QixXQUg5QixDQUFwQjtBQUtILEtBdGdCb0M7O0FBd2dCckMsa0JBQWMsc0JBQVMsYUFBVCxFQUF3QjtBQUNsQyxlQUFPLEtBQUssWUFBTCxDQUFrQixHQUFsQixDQUFzQixhQUF0QixFQUFxQyxNQUE1QztBQUNILEtBMWdCb0M7O0FBNGdCckMsaUJBQWEscUJBQVMsYUFBVCxFQUF3QixLQUF4QixFQUErQixRQUEvQixFQUF5QztBQUNsRCxlQUFPLFVBQVUsU0FBVixHQUFzQixLQUFLLFlBQUwsQ0FBa0IsYUFBbEIsRUFBaUMsS0FBakMsRUFBd0MsUUFBeEMsQ0FBdEIsR0FBMEUsRUFBakY7QUFDSCxLQTlnQm9DOztBQWdoQnJDOzs7OztBQUtBLGtCQUFjLHNCQUFTLFNBQVQsRUFBb0I7QUFDOUIsWUFBSSxZQUFZLEtBQUssU0FBckI7QUFDQSxZQUFJLENBQUMsU0FBRCxJQUFjLENBQUMsVUFBVSxNQUFWLENBQWlCLFVBQVUsUUFBM0IsQ0FBbkIsRUFBeUQ7QUFDckQsaUJBQUssU0FBTCxHQUFpQixVQUFVLFFBQTNCO0FBQ0EsZ0JBQUksU0FBSixFQUFlO0FBQ1gscUJBQUssNEJBQUwsQ0FBa0MsU0FBbEM7QUFDSDtBQUNELGlCQUFLLDZCQUFMLENBQW1DLFNBQW5DO0FBQ0EsaUJBQUssT0FBTDtBQUNIO0FBQ0osS0EvaEJvQzs7QUFpaUJyQzs7Ozs7QUFLQSxtQkFBZSx1QkFBUyxVQUFULEVBQXFCO0FBQ2hDLGVBQU8sTUFBUCxDQUFjLEtBQUssVUFBbkIsRUFBK0IsVUFBL0I7QUFDQSxhQUFLLGlCQUFMO0FBQ0gsS0F6aUJvQzs7QUEyaUJyQzs7Ozs7O0FBTUEsdUJBQW1CLDZCQUFXO0FBQzFCLGFBQUssb0JBQUw7QUFDQSxhQUFLLFFBQUwsQ0FBYyxnQkFBZCxHQUFpQyxJQUFqQztBQUNBLGFBQUssUUFBTCxDQUFjLGtCQUFkO0FBQ0gsS0FyakJvQzs7QUF1akJyQzs7Ozs7O0FBTUEsY0FBVSxrQkFBUyxLQUFULEVBQWdCO0FBQ3RCLGFBQUssUUFBTCxDQUFjLFFBQWQsQ0FBdUIsS0FBdkI7QUFDQSxhQUFLLGlCQUFMO0FBQ0EsYUFBSyxlQUFMO0FBQ0gsS0Fqa0JvQzs7QUFta0JyQyxjQUFVLG9CQUFXO0FBQ2pCLGVBQU8sS0FBSyxRQUFMLENBQWMsUUFBZCxFQUFQO0FBQ0gsS0Fya0JvQzs7QUF1a0JyQyxlQUFXLG1CQUFTLEtBQVQsRUFBZ0I7QUFDdkIsYUFBSyxRQUFMLENBQWMsUUFBZCxDQUF1QixLQUF2QjtBQUNILEtBemtCb0M7O0FBMmtCckM7Ozs7Ozs7OztBQVNBLGVBQVcsbUJBQVMsT0FBVCxFQUFrQjtBQUN6QixrQkFBVSxXQUFXLEVBQXJCOztBQUVBLFlBQUksUUFBUSxRQUFRLEtBQVIsS0FBa0IsU0FBbEIsR0FBOEIsSUFBOUIsR0FBcUMsUUFBUSxLQUF6RDtBQUFBLFlBQ0ksYUFBYSxLQUFLLFVBRHRCO0FBQUEsWUFFSSxjQUFjLFdBQVcsV0FGN0I7O0FBSUEsWUFBSSxXQUFKLEVBQWlCO0FBQ2IsZ0JBQUksUUFBUSxPQUFaLEVBQXFCO0FBQ2pCLG9CQUFJLFVBQVUsS0FBSyxRQUFMLENBQWMsVUFBZCxFQUFkO0FBQ0EsdUJBQU8sSUFBUCxDQUFZLFdBQVosRUFBeUIsT0FBekIsQ0FBaUMsVUFBUyxHQUFULEVBQWM7QUFDM0Msd0JBQUksQ0FBQyxRQUFRLElBQVIsQ0FBYSxVQUFTLE1BQVQsRUFBaUI7QUFDM0IsK0JBQU8sT0FBTyxVQUFQLENBQWtCLFVBQWxCLEtBQWlDLFlBQVksR0FBWixDQUF4QztBQUNILHFCQUZBLENBQUwsRUFFUTtBQUNKLCtCQUFPLFlBQVksR0FBWixDQUFQO0FBQ0g7QUFDSixpQkFORDtBQU9IO0FBQ0Qsd0JBQVksTUFBWixHQUFxQixrQkFBckI7QUFDSDs7QUFFRDtBQUNBLGFBQUssU0FBTCxHQUFpQixRQUFRLFNBQXpCOztBQUVBLFlBQUksT0FBTyxLQUFLLFNBQUwsQ0FBZSxVQUFmLEVBQTJCLFVBQVMsR0FBVCxFQUFjLEtBQWQsRUFBcUI7QUFDdkQsZ0JBQUksUUFBUSxTQUFSLElBQXFCLFNBQVMsVUFBOUIsSUFBNEMsUUFBUSxTQUFSLENBQWtCLE9BQWxCLENBQTBCLEdBQTFCLEtBQWtDLENBQWxGLEVBQXFGO0FBQ2pGLHdCQUFRLFNBQVI7QUFDSCxhQUZELE1BRU8sSUFBSSxRQUFRLFlBQVosRUFBMEI7QUFDN0Isb0JBQUksV0FBSixFQUFpQjtBQUNiO0FBQ0EsNEJBQVEsT0FBTyxJQUFQLENBQVksV0FBWixFQUF5QixJQUF6QixDQUE4QixVQUFTLEdBQVQsRUFBYztBQUNoRCwrQkFBTyxZQUFZLEdBQVosTUFBcUIsS0FBNUI7QUFDSCxxQkFGTyxDQUFSO0FBR0gsaUJBTEQsTUFLTztBQUNIO0FBQ0EsNEJBQVEsTUFBTSxRQUFOLEVBQVI7QUFDSDtBQUNKO0FBQ0QsbUJBQU8sS0FBUDtBQUNILFNBZlUsRUFlUixLQWZRLENBQVg7O0FBaUJBO0FBQ0EsZUFBTyxLQUFLLFNBQVo7O0FBRUEsZUFBTyxJQUFQO0FBQ0gsS0Fqb0JvQzs7QUFtb0JyQzs7Ozs7QUFLQSxrQkFBYyx3QkFBVztBQUNyQixZQUFJLEtBQUssU0FBTCxDQUFlLE1BQW5CLEVBQTJCO0FBQ3ZCLG1CQUFPLEtBQUssU0FBTCxDQUFlLEtBQUssU0FBTCxDQUFlLE1BQWYsR0FBd0IsQ0FBdkMsQ0FBUDtBQUNIO0FBQ0osS0E1b0JvQzs7QUE4b0JyQzs7OztBQUlBLGtCQUFjLHdCQUFXO0FBQ3JCLFlBQUksTUFBSjtBQUNBLFlBQUksS0FBSyxTQUFMLENBQWUsTUFBbkIsRUFBMkI7QUFDdkIscUJBQVMsS0FBSyxTQUFMLENBQWUsR0FBZixFQUFUO0FBQ0g7QUFDRCxlQUFPLE1BQVA7QUFDSCxLQXhwQm9DOztBQTBwQnJDOzs7O0FBSUEsb0JBQWdCLDBCQUFXO0FBQ3ZCLGFBQUssU0FBTCxHQUFpQixDQUFDLElBQUksS0FBSixDQUFVLENBQUMsQ0FBWCxFQUFjLENBQUMsQ0FBZixDQUFELENBQWpCO0FBQ0EsYUFBSyxVQUFMLEdBQWtCLElBQWxCO0FBQ0gsS0FqcUJvQzs7QUFtcUJyQzs7Ozs7QUFLQSxrQkFBYyxzQkFBUyxLQUFULEVBQWdCO0FBQzFCLGFBQUssU0FBTCxDQUFlLElBQWYsQ0FBb0IsS0FBcEI7QUFDSCxLQTFxQm9DOztBQTRxQnJDOzs7O0FBSUEsbUJBQWUseUJBQVc7QUFDdEIsZUFBTyxLQUFLLFVBQVo7QUFDSCxLQWxyQm9DOztBQW9yQnJDOzs7OztBQUtBLG1CQUFlLHVCQUFTLEtBQVQsRUFBZ0I7QUFDM0IsYUFBSyxVQUFMLEdBQWtCLEtBQWxCO0FBQ0gsS0EzckJvQzs7QUE2ckJyQzs7OztBQUlBLDhCQUEwQixvQ0FBVztBQUNqQyxZQUFJLEtBQUssVUFBVCxFQUFxQjtBQUNqQixpQkFBSyxVQUFMLENBQWdCLHdCQUFoQjtBQUNIO0FBQ0QsYUFBSyxxQkFBTDtBQUNBLGFBQUssOEJBQUw7QUFDSCxLQXZzQm9DOztBQXlzQnJDLHNCQUFrQiw0QkFBVztBQUN6QixhQUFLLHNCQUFMO0FBQ0gsS0Ezc0JvQzs7QUE2c0JyQzs7OztBQUlBLDJCQUF1QixpQ0FBVztBQUM5QixhQUFLLFFBQUwsQ0FBYyx1QkFBZDtBQUNBLFlBQUksS0FBSyxRQUFMLENBQWMscUJBQWQsQ0FBb0MsS0FBcEMsQ0FBSixFQUFnRDtBQUM1QyxpQkFBSyxvQkFBTDtBQUNIO0FBQ0osS0F0dEJvQzs7QUF3dEJyQzs7Ozs7O0FBTUEsd0JBQW9CLDRCQUFTLEtBQVQsRUFBZ0I7QUFDaEMsWUFBSSxLQUFLLFFBQUwsTUFBbUIsS0FBSyxTQUE1QixFQUF1QztBQUNuQyxrQkFBTSxjQUFOO0FBQ0EsZ0JBQUksVUFBVSxLQUFLLGlCQUFMLEVBQWQ7QUFDQSxrQkFBTSxhQUFOLENBQW9CLE9BQXBCLENBQTRCLFlBQTVCLEVBQTBDLFFBQVEsSUFBbEQ7QUFDQSxrQkFBTSxhQUFOLENBQW9CLE9BQXBCLENBQTRCLFdBQTVCLEVBQXlDLFFBQVEsSUFBakQ7QUFDSDtBQUNKLEtBcnVCb0M7O0FBdXVCckM7Ozs7QUFJQSxjQUFVLG9CQUFXO0FBQ2pCLGVBQU8sS0FBSyxNQUFMLENBQVksUUFBWixFQUFQO0FBQ0gsS0E3dUJvQzs7QUErdUJyQzs7Ozs7Ozs7Ozs7Ozs7QUFjQSxpQkFBYSxxQkFBUyxPQUFULEVBQWtCO0FBQzNCLFlBQUksV0FBVyxXQUFXLFFBQVEsUUFBbkIsSUFBK0IsWUFBOUM7QUFDQSxhQUFLLFFBQUwsR0FBZ0IsSUFBSSxRQUFKLENBQWEsSUFBYixFQUFtQixPQUFuQixDQUFoQjtBQUNBLGFBQUssY0FBTDtBQUNBLGFBQUssaUJBQUw7QUFDQSxhQUFLLFFBQUwsQ0FBYyxPQUFkO0FBQ0gsS0Fud0JvQzs7QUFxd0JyQzs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsYUFBUyxpQkFBUyxRQUFULEVBQW1CLE9BQW5CLEVBQTRCO0FBQ2pDLFlBQUksQ0FBQyxLQUFLLFFBQVYsRUFBb0I7QUFDaEIsaUJBQUssV0FBTCxDQUFpQixPQUFqQjtBQUNIO0FBQ0QsYUFBSyxRQUFMLENBQWMsT0FBZCxDQUFzQixRQUF0QixFQUFnQyxPQUFoQztBQUNBLGFBQUssT0FBTCxDQUFhLFNBQVMsTUFBVCxHQUFrQixFQUFsQixHQUF1QixLQUFLLFVBQUwsQ0FBZ0IsYUFBcEQ7QUFDQSxhQUFLLFFBQUwsQ0FBYyxPQUFkO0FBQ0EsYUFBSywrQkFBTCxDQUFxQyxRQUFyQztBQUNILEtBNXhCb0M7O0FBOHhCckM7Ozs7Ozs7Ozs7Ozs7OztBQWVBLGFBQVMsaUJBQVMsUUFBVCxFQUFtQixPQUFuQixFQUE0QjtBQUNqQyxZQUFJLENBQUMsT0FBTCxFQUFjO0FBQ1Ysc0JBQVUsRUFBVjtBQUNIO0FBQ0QsWUFBSSxDQUFDLEtBQUssUUFBVixFQUFvQjtBQUNoQixpQkFBSyxXQUFMLENBQWlCLE9BQWpCO0FBQ0g7QUFDRCxZQUFJLENBQUMsUUFBUSxNQUFiLEVBQXFCO0FBQ2pCLG9CQUFRLE1BQVIsR0FBaUIsS0FBSyxRQUFMLENBQWMsU0FBZCxDQUF3QixTQUF4QixFQUFqQjtBQUNIO0FBQ0QsYUFBSyxRQUFMLENBQWMsT0FBZCxDQUFzQixRQUF0QixFQUFnQyxPQUFoQztBQUNBLGFBQUssT0FBTCxDQUFhLEtBQUssUUFBTCxDQUFjLFNBQWQsQ0FBd0IsT0FBeEIsR0FBa0MsTUFBbEMsR0FBMkMsRUFBM0MsR0FBZ0QsS0FBSyxVQUFMLENBQWdCLGFBQTdFO0FBQ0EsYUFBSyxRQUFMLENBQWMsT0FBZDtBQUNBLGFBQUssK0JBQUwsQ0FBcUMsUUFBckM7QUFDSCxLQTN6Qm9DOztBQTZ6QnJDLGFBQVMsaUJBQVMsUUFBVCxFQUFtQjtBQUN4QixhQUFLLFFBQUwsQ0FBYyxPQUFkLENBQXNCLFFBQXRCO0FBQ0gsS0EvekJvQzs7QUFpMEJyQzs7OztBQUlBLHFCQUFpQiwyQkFBVztBQUN4QixZQUFJLEtBQUssU0FBVCxFQUFvQjtBQUNoQixnQkFBSSxLQUFLLFVBQUwsS0FBb0IsS0FBSyxjQUFMLEVBQXBCLElBQTZDLEtBQUssT0FBTCxLQUFpQixLQUFLLFdBQUwsRUFBbEUsRUFBc0Y7QUFDbEYscUJBQUssVUFBTCxHQUFrQixLQUFLLGNBQUwsRUFBbEI7QUFDQSxxQkFBSyxPQUFMLEdBQWUsS0FBSyxXQUFMLEVBQWY7QUFDQSxxQkFBSyxvQkFBTDtBQUNILGFBSkQsTUFJTztBQUNILHFCQUFLLG9CQUFMO0FBQ0g7QUFDSjtBQUNKLEtBLzBCb0M7O0FBaTFCckM7Ozs7QUFJQSwwQkFBc0IsZ0NBQVc7QUFDN0IsYUFBSyxpQkFBTCxHQUF5QixJQUF6QjtBQUNBLGFBQUssT0FBTDtBQUNILEtBeDFCb0M7O0FBMDFCckM7Ozs7QUFJQSwwQkFBc0IsZ0NBQVc7QUFDN0IsYUFBSyxpQkFBTCxHQUF5QixJQUF6QjtBQUNBLGFBQUssT0FBTDtBQUNILEtBajJCb0M7O0FBbTJCckM7OztBQUdBLDRCQUF3QixrQ0FBVztBQUMvQixZQUFJLEtBQUssaUJBQVQsRUFBNEI7QUFDeEIsZ0JBQUksS0FBSyxTQUFULEVBQW9CO0FBQ2hCLHFCQUFLLE1BQUwsQ0FBWSxhQUFaO0FBQ0EscUJBQUssOEJBQUwsR0FGZ0IsQ0FFdUI7QUFDMUM7QUFDSixTQUxELE1BS08sSUFBSSxLQUFLLGlCQUFULEVBQTRCO0FBQy9CLGdCQUFJLEtBQUssU0FBVCxFQUFvQjtBQUNoQixxQkFBSyxrQkFBTDtBQUNIO0FBQ0o7O0FBRUQsYUFBSyxpQkFBTCxHQUF5QixLQUFLLGlCQUFMLEdBQXlCLEtBQWxEO0FBQ0gsS0FuM0JvQzs7QUFxM0JyQzs7OztBQUlBLGVBQVcscUJBQVc7QUFDbEIsZUFBTyxLQUFLLFFBQUwsQ0FBYyxTQUFkLEVBQVA7QUFDSCxLQTMzQm9DOztBQTYzQnJDLGFBQVMsbUJBQVc7QUFDaEIsWUFBSSxNQUFNLEtBQUssVUFBTCxDQUFnQixrQkFBMUI7QUFDQSxZQUFJLFNBQVMsS0FBSyxNQUFsQjtBQUNBLFlBQUksTUFBSixFQUFZO0FBQ1IsZ0JBQUksUUFBUSxJQUFaLEVBQWtCO0FBQ2QsdUJBQU8sUUFBUDtBQUNILGFBRkQsTUFFTztBQUNILHVCQUFPLE9BQVA7QUFDSDtBQUNKO0FBQ0osS0F2NEJvQzs7QUF5NEJyQzs7OztBQUlBLGNBQVUsb0JBQVc7QUFDakIsYUFBSyxNQUFMLENBQVksUUFBWjtBQUNILEtBLzRCb0M7O0FBaTVCckM7Ozs7O0FBS0Esa0JBQWMsc0JBQVMsR0FBVCxFQUFjO0FBQ3hCLGFBQUssYUFBTCxDQUFtQixHQUFuQjtBQUNBLGFBQUssWUFBTDtBQUNBO0FBQ0gsS0ExNUJvQzs7QUE0NUJyQzs7Ozs7QUFLQSxtQkFBZSx1QkFBUyxHQUFULEVBQWM7QUFDekIsWUFBSSxPQUFPLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUN6QixrQkFBTSxTQUFTLGFBQVQsQ0FBdUIsR0FBdkIsQ0FBTjtBQUNIOztBQUVEO0FBQ0EsWUFBSSxDQUFDLElBQUksS0FBSixDQUFVLFFBQWYsRUFBeUI7QUFDckIsZ0JBQUksS0FBSixDQUFVLFFBQVYsR0FBcUIsSUFBckIsQ0FEcUIsQ0FDTTtBQUM5Qjs7QUFFRCxZQUFJLElBQUksWUFBSixHQUFtQixDQUF2QixFQUEwQjtBQUN0QixnQkFBSSxLQUFKLENBQVUsTUFBVixHQUFtQixJQUFuQixDQURzQixDQUNHO0FBQzVCOztBQUVELGtCQUFVLE1BQVY7O0FBRUE7QUFDQSxZQUFJLGFBQUosR0FBb0IsVUFBUyxLQUFULEVBQWdCO0FBQ2hDLGtCQUFNLGVBQU47QUFDQSxrQkFBTSxjQUFOO0FBQ0EsbUJBQU8sS0FBUDtBQUNILFNBSkQ7O0FBTUEsWUFBSSxlQUFKLENBQW9CLFVBQXBCOztBQUVBLFlBQUksU0FBSixDQUFjLEdBQWQsQ0FBa0IscUJBQWxCO0FBQ0EsWUFBSSxFQUFKLEdBQVMsSUFBSSxFQUFKLElBQVUsZUFBZSxTQUFTLGdCQUFULENBQTBCLHNCQUExQixFQUFrRCxNQUFsRCxHQUEyRCxDQUEzRCxJQUFnRSxFQUEvRSxDQUFuQjs7QUFFQSxhQUFLLEdBQUwsR0FBVyxHQUFYO0FBQ0gsS0E5N0JvQzs7QUFnOEJyQzs7Ozs7Ozs7Ozs7QUFXQSxnQkFBWSxvQkFBUyxPQUFULEVBQWtCO0FBQzFCLFlBQUksQ0FBQyxLQUFLLFNBQVYsRUFBcUI7QUFDakIsZ0JBQUksWUFBWSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBaEI7O0FBRUEsc0JBQVUsU0FBVixFQUFxQixXQUFXLFFBQVEsTUFBeEMsRUFBZ0QsV0FBaEQ7O0FBRUEsaUJBQUssR0FBTCxDQUFTLFdBQVQsQ0FBcUIsU0FBckI7O0FBRUEsZ0JBQUksU0FBUyxJQUFJLE1BQUosQ0FBVyxTQUFYLEVBQXNCLEtBQUssUUFBM0IsQ0FBYjtBQUNBLG1CQUFPLE1BQVAsQ0FBYyxTQUFkLENBQXdCLEdBQXhCLENBQTRCLFdBQTVCOztBQUVBLGlCQUFLLFNBQUwsR0FBaUIsU0FBakI7QUFDQSxpQkFBSyxNQUFMLEdBQWMsTUFBZDs7QUFFQSxpQkFBSyxvQkFBTDtBQUNBLGlCQUFLLGtCQUFMO0FBQ0g7QUFDSixLQTU5Qm9DOztBQTg5QnJDLGlDQUE2QixxQ0FBUyxVQUFULEVBQXFCO0FBQzlDLGVBQU8sS0FBSyxRQUFMLENBQWMsMkJBQWQsQ0FBMEMsVUFBMUMsQ0FBUDtBQUNILEtBaCtCb0M7O0FBaytCckMsaUNBQTZCLHFDQUFTLFNBQVQsRUFBb0I7QUFDN0MsZUFBTyxLQUFLLFFBQUwsQ0FBYywyQkFBZCxDQUEwQyxTQUExQyxDQUFQO0FBQ0gsS0FwK0JvQzs7QUFzK0JyQzs7Ozs7O0FBTUEsY0FBVSxrQkFBUyxVQUFULEVBQXFCO0FBQzNCLFlBQUksQ0FBQyxVQUFMLEVBQWlCO0FBQ2IseUJBQWEsQ0FBQyxTQUFELENBQWI7QUFDSCxTQUZELE1BRU8sSUFBSSxDQUFDLE1BQU0sT0FBTixDQUFjLFVBQWQsQ0FBTCxFQUFnQztBQUNuQyx5QkFBYSxDQUFDLFVBQUQsQ0FBYjtBQUNIO0FBQ0QsWUFBSSxLQUFLLEdBQVQsRUFBYztBQUNWLHVCQUFXLE9BQVgsQ0FBbUIsVUFBUyxJQUFULEVBQWU7QUFDOUIscUJBQUssTUFBTCxHQUFjLElBQWQ7QUFDSCxhQUZELEVBRUcsS0FBSyxHQUFMLENBQVMsS0FGWjtBQUdIO0FBQ0osS0F2L0JvQzs7QUF5L0JyQzs7Ozs7OztBQU9BLGlCQUFhLHVCQUFXO0FBQ3BCLGVBQU8sQ0FBQyxLQUFLLFVBQU4sSUFBb0IsS0FBSyxVQUFMLENBQWdCLFdBQWhCLEVBQTNCO0FBQ0gsS0FsZ0NvQzs7QUFvZ0NyQzs7Ozs7OztBQU9BLG1CQUFlLHlCQUFXO0FBQ3RCLGVBQU8sQ0FBQyxLQUFLLFVBQU4sSUFBb0IsS0FBSyxVQUFMLENBQWdCLGFBQWhCLEVBQTNCO0FBQ0gsS0E3Z0NvQzs7QUErZ0NyQzs7Ozs7OztBQU9BLGtCQUFjLHdCQUFXO0FBQ3JCLGVBQU8sQ0FBQyxLQUFLLFVBQU4sS0FDSCxLQUFLLFVBQUwsQ0FBZ0IsWUFBaEIsR0FBK0IsS0FBSyxVQUFMLENBQWdCLFlBQWhCLEVBQS9CLEdBQWdFLEtBQUssVUFBTCxDQUFnQixXQUFoQixFQUQ3RCxDQUFQO0FBR0gsS0ExaENvQzs7QUE0aENyQzs7OztBQUlBLG1CQUFlLHlCQUFXO0FBQ3RCLFlBQUksSUFBSSxLQUFLLE1BQUwsQ0FBWSxNQUFwQjtBQUNBLGVBQU8sSUFBSSxTQUFKLENBQWMsQ0FBZCxFQUFpQixDQUFqQixFQUFvQixFQUFFLE1BQUYsQ0FBUyxDQUFULEdBQWEsRUFBRSxNQUFGLENBQVMsQ0FBMUMsRUFBNkMsRUFBRSxNQUFGLENBQVMsQ0FBVCxHQUFhLEVBQUUsTUFBRixDQUFTLENBQW5FLENBQVA7QUFDSCxLQW5pQ29DOztBQXFpQ3JDOzs7Ozs7QUFNQSxZQUFRLGdCQUFTLEtBQVQsRUFBZ0I7QUFDcEIsWUFBSSxVQUFKOztBQUVBLGFBQUssWUFBTCxHQUhvQixDQUdDOztBQUVyQixZQUFJLFlBQVksTUFBTSxRQUFOLENBQWUsQ0FBL0I7QUFBQSxZQUFrQyxZQUFZLE1BQU0sUUFBTixDQUFlLENBQTdEOztBQUVBLFlBQUksTUFBTSx1QkFBTixJQUFpQyxNQUFNLHFCQUEzQyxFQUFrRTtBQUM5RCxnQkFBSSxhQUFhLEtBQUssUUFBTCxDQUFjLHFCQUFkLENBQW9DLE1BQU0scUJBQTFDLENBQWpCO0FBQ0EsZ0JBQUksa0JBQWtCLEtBQUssUUFBTCxDQUFjLE9BQWQsQ0FBc0IsT0FBdEIsQ0FBOEIsVUFBOUIsQ0FBdEI7O0FBRUEsZ0JBQUksY0FBYyxlQUFsQixFQUFtQztBQUMvQiw0QkFBWSxlQUFaO0FBQ0g7QUFDSjtBQUNELFlBQUksTUFBTSxjQUFOLEtBQXlCLFNBQXpCLElBQXNDLE1BQU0sY0FBTixLQUF5QixJQUFuRSxFQUF5RTtBQUNyRSx3QkFBWSxNQUFNLGNBQWxCO0FBQ0g7O0FBRUQsWUFBSSxjQUFjLE1BQU0sUUFBTixDQUFlLENBQTdCLElBQWtDLGNBQWMsTUFBTSxRQUFOLENBQWUsQ0FBbkUsRUFBc0U7QUFDbEUsaUJBQUssbUJBQUwsQ0FBeUIsU0FBekIsRUFBb0MsU0FBcEM7QUFDQSxpQkFBSyxRQUFMO0FBQ0Esb0JBQVEsSUFBSSxLQUFLLFFBQUwsQ0FBYyxTQUFsQixDQUE0QixTQUE1QixFQUF1QyxZQUFZLEtBQUssaUJBQUwsRUFBbkQsQ0FBUjtBQUNIOztBQUVELFlBQ0ksTUFBTSxZQUFOLEtBQ0MsYUFBYSxLQUFLLGVBQUwsQ0FBcUIsS0FBckIsQ0FEZCxDQURKLEVBR0U7QUFDRSxnQkFBSSx1QkFBdUIsTUFBTSxTQUFOLEdBQWtCLFVBQWxCLEdBQStCLFlBQTFEO0FBQ0EsZ0JBQUksYUFBYSxNQUFNLGFBQU4sQ0FBb0Isb0JBQXBCLElBQ2IsTUFBTSxhQUFOLENBQW9CLG9CQUFwQixDQURhLEdBRWIsTUFBTSxVQUFOLENBQWlCLG9CQUFqQixDQUZKOztBQUlBLGdCQUFJLFVBQUosRUFBZ0I7QUFDWiwyQkFBVyxZQUFYO0FBQ0gsYUFGRCxNQUVPO0FBQ0gsMkJBQVcsZ0JBQVg7QUFDSDtBQUNKOztBQUVELGVBQU8sVUFBUDtBQUNILEtBcmxDb0M7O0FBdWxDckM7Ozs7O0FBS0EscUJBQWlCLHlCQUFTLFdBQVQsRUFBc0I7QUFDbkMsZUFBTyxLQUFLLFFBQUwsQ0FBYyxlQUFkLENBQThCLFdBQTlCLENBQVA7QUFDSCxLQTlsQ29DOztBQWdtQ3JDOzs7OztBQUtBLHNCQUFrQiwwQkFBUyxDQUFULEVBQVk7QUFDMUIsZUFBTyxLQUFLLFFBQUwsQ0FBYyxnQkFBZCxDQUErQixDQUEvQixDQUFQO0FBQ0gsS0F2bUNvQzs7QUF5bUNyQzs7Ozs7O0FBTUEsbUJBQWUsdUJBQVMsQ0FBVCxFQUFZLEVBQVosRUFBZ0I7QUFDM0IsZUFBTyxLQUFLLGdCQUFMLENBQXNCLEVBQXRCLEtBQTZCLEtBQUssZUFBTCxDQUFxQixDQUFyQixDQUFwQztBQUNILEtBam5Db0M7O0FBbW5DckM7Ozs7Ozs7QUFPQSw2QkFBeUIsaUNBQVMsUUFBVCxFQUFtQixPQUFuQixFQUE0QjtBQUNqRCxZQUFNLFVBQVUsS0FBSyxjQUFMLEtBQXdCLENBQXhDLENBRGlELENBQ047QUFDM0MsWUFBTSxlQUFlLFdBQVcsS0FBSyxJQUFMLENBQVUsT0FBVixDQUFoQztBQUNBLGVBQU8sQ0FBQyxLQUFLLGVBQUwsQ0FBcUIsWUFBckIsQ0FBRCxJQUF1QyxhQUFhLE9BQTNEO0FBQ0gsS0E5bkNvQzs7QUFnb0NyQzs7Ozs7OztBQU9BLDZCQUF5QixpQ0FBUyxRQUFULEVBQW1CLE9BQW5CLEVBQTRCO0FBQ2pELFlBQU0sVUFBVSxLQUFLLFdBQUwsS0FBcUIsQ0FBckMsQ0FEaUQsQ0FDVDtBQUN4QyxZQUFNLGVBQWdCLFVBQVUsQ0FBQyxDQUFaLEdBQWlCLENBQWpCLEdBQXFCLENBQTFDLENBRmlELENBRUo7QUFDN0MsWUFBTSxlQUFlLFdBQVcsWUFBaEM7QUFDQSxlQUFPLENBQUMsS0FBSyxnQkFBTCxDQUFzQixZQUF0QixDQUFELElBQXdDLGFBQWEsT0FBNUQ7QUFDSCxLQTVvQ29DOztBQThvQ3JDOzs7Ozs7QUFNQSxjQUFVLGtCQUFTLE9BQVQsRUFBa0IsT0FBbEIsRUFBMkI7QUFDakM7QUFDQSxhQUFLLFNBQUwsQ0FBZSxPQUFmO0FBQ0EsYUFBSyxTQUFMLENBQWUsT0FBZjtBQUNILEtBeHBDb0M7O0FBMHBDckM7Ozs7O0FBS0EsZUFBVyxtQkFBUyxPQUFULEVBQWtCO0FBQ3pCO0FBQ0EsWUFBSSxNQUFNLEtBQUssV0FBTCxDQUFpQixLQUFqQixDQUF1QixHQUFqQztBQUNBLFlBQUksV0FBVyxLQUFLLFlBQXBCO0FBQ0EsWUFBSSxZQUFZLEtBQUssZUFBTCxFQUFoQjtBQUNBLFlBQUksV0FBVyxLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsV0FBVyxVQUFVLEtBQUssUUFBTCxDQUFjLFlBQWQsQ0FBMkIsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLFlBQVksT0FBeEIsQ0FBM0IsQ0FBbkMsQ0FBZjtBQUNBLFlBQUksYUFBYSxRQUFqQixFQUEyQjtBQUN2QixpQkFBSyxlQUFMLENBQXFCLFFBQXJCO0FBQ0g7QUFDSixLQXhxQ29DOztBQTBxQ3JDOzs7OztBQUtBLGVBQVcsbUJBQVMsT0FBVCxFQUFrQjtBQUN6QjtBQUNBLFlBQUksTUFBTSxLQUFLLFdBQUwsQ0FBaUIsS0FBakIsQ0FBdUIsR0FBakM7QUFDQSxZQUFJLFdBQVcsS0FBSyxZQUFwQjtBQUNBLFlBQUksWUFBWSxLQUFLLGVBQUwsRUFBaEI7QUFDQSxZQUFJLFdBQVcsS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLFdBQVcsVUFBVSxLQUFLLFFBQUwsQ0FBYyxjQUFkLENBQTZCLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxZQUFZLE9BQXhCLENBQTdCLENBQW5DLENBQWY7QUFDQSxZQUFJLGFBQWEsUUFBakIsRUFBMkI7QUFDdkIsaUJBQUssZUFBTCxDQUFxQixRQUFyQjtBQUNIO0FBQ0osS0F4ckNvQzs7QUEwckNyQyx5QkFBcUIsNkJBQVMsTUFBVCxFQUFpQixHQUFqQixFQUFzQjtBQUN2QyxZQUFJLEtBQUo7QUFBQSxZQUNJLEtBQUssS0FBSyxRQUFMLENBQWMsVUFEdkI7QUFBQSxZQUVJLG1CQUFtQixLQUFLLFVBQUwsQ0FBZ0IsZ0JBRnZDO0FBQUEsWUFHSSxnQkFBZ0IsS0FBSyxVQUFMLENBQWdCLGFBSHBDOztBQUtBO0FBQ0EsWUFBSSxVQUFVLGdCQUFkLEVBQWdDO0FBQzVCO0FBQ0EsZ0JBQUksQ0FBQyxRQUFRLFNBQVMsR0FBRyxNQUFILENBQVUsQ0FBNUIsSUFBaUMsQ0FBckMsRUFBd0M7QUFDcEMscUJBQUssV0FBTCxDQUFpQixLQUFqQixJQUEwQixLQUExQjs7QUFFQTtBQUNBO0FBQ0gsYUFMRCxNQUtPLElBQUssU0FBUyxHQUFHLE1BQUgsQ0FBVSxDQUFuQixHQUF1QixDQUF4QixHQUE2QixDQUFqQyxFQUFvQztBQUN2QyxxQkFBSyxXQUFMLENBQWlCLEtBQWpCLEdBQXlCLEtBQUssUUFBTCxDQUFjLGtDQUFkLENBQWlELE1BQWpELENBQXpCO0FBQ0g7QUFDSjs7QUFFRCxZQUNJLE9BQU8sYUFBUCxNQUF3Qjs7QUFFcEI7QUFDQSxTQUFDLFFBQVEsTUFBTSxHQUFHLE1BQUgsQ0FBVSxDQUF6QixJQUE4QixDQUE5Qjs7QUFFQTtBQUNBLFNBQUMsUUFBUSxNQUFNLEdBQUcsTUFBSCxDQUFVLENBQXpCLElBQThCLENBTmxDLENBREosRUFTRTtBQUNFLGlCQUFLLFdBQUwsQ0FBaUIsS0FBakIsSUFBMEIsS0FBMUI7QUFDSDtBQUNKLEtBenRDb0M7O0FBMnRDckMsc0NBQWtDLDBDQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDN0MsYUFBSyxtQkFBTCxDQUF5QixDQUF6QixFQUE0QixDQUE1QjtBQUNBLGFBQUssVUFBTCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixJQUF0QjtBQUNILEtBOXRDb0M7O0FBZ3VDckM7Ozs7OztBQU1BLCtCQUEyQixtQ0FBUyxLQUFULEVBQWdCO0FBQ3ZDLGVBQU8sS0FBSyxRQUFMLENBQWMseUJBQWQsQ0FBd0MsS0FBeEMsQ0FBUDtBQUNILEtBeHVDb0M7O0FBMHVDckM7Ozs7O0FBS0EscUJBQWlCLHlCQUFTLFFBQVQsRUFBbUI7QUFDaEMsWUFBSSxJQUFJLEtBQUssUUFBTCxDQUFjLGVBQWQsQ0FBOEIsU0FBUyxDQUF2QyxFQUEwQyxTQUFTLENBQW5ELENBQVI7O0FBRUE7QUFDQSxlQUFPLElBQUksU0FBSixDQUFjLEVBQUUsQ0FBaEIsRUFBbUIsRUFBRSxDQUFyQixFQUF3QixFQUFFLEtBQTFCLEVBQWlDLEVBQUUsTUFBbkMsQ0FBUDtBQUNILEtBcHZDb0M7O0FBc3ZDckM7Ozs7QUFJQSxhQUFTLG1CQUFXO0FBQ2hCLGFBQUssb0JBQUw7QUFDSCxLQTV2Q29DOztBQTh2Q3JDOzs7O0FBSUEsZ0JBQVksb0JBQVMsR0FBVCxFQUFjLElBQWQsRUFBb0IsUUFBcEIsRUFBOEIsT0FBOUIsRUFBdUM7QUFDL0MsZUFBTyxPQUFPLElBQVAsQ0FBWSxLQUFaLENBQWtCLE1BQWxCLEVBQTBCLFNBQTFCLENBQVA7QUFDSCxLQXB3Q29DOztBQXN3Q3JDOzs7OztBQUtBLGdCQUFZLG9CQUFTLEtBQVQsRUFBZ0IsR0FBaEIsRUFBcUI7QUFDN0IsWUFBSSxVQUFVLEtBQUssUUFBTCxDQUFjLFVBQWQsRUFBZDtBQUNBLGVBQU8sUUFBUSxLQUFSLENBQWMsS0FBZCxDQUFvQixPQUFwQixFQUE2QixTQUE3QixDQUFQO0FBQ0gsS0E5d0NvQzs7QUFneENyQzs7Ozs7QUFLQSxzQkFBa0IsMEJBQVMsS0FBVCxFQUFnQixHQUFoQixFQUFxQjtBQUNuQyxZQUFJLFVBQVUsS0FBSyxRQUFMLENBQWMsZ0JBQWQsRUFBZDtBQUNBLGVBQU8sUUFBUSxLQUFSLENBQWMsS0FBZCxDQUFvQixPQUFwQixFQUE2QixTQUE3QixDQUFQO0FBQ0gsS0F4eENvQzs7QUEweENyQyxzQkFBa0IsNEJBQVc7QUFDekI7QUFDQSxlQUFPLEtBQUssUUFBTCxDQUFjLGdCQUFkLEVBQVA7QUFDSCxLQTd4Q29DOztBQSt4Q3JDLHNCQUFrQiwwQkFBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQzdCLGVBQU8sS0FBSyxRQUFMLENBQWMsZ0JBQWQsQ0FBK0IsQ0FBL0IsRUFBa0MsQ0FBbEMsQ0FBUDtBQUNILEtBanlDb0M7O0FBbXlDckM7Ozs7QUFJQSxlQUFXLHFCQUFXO0FBQ2xCLFlBQUksZ0JBQWdCLEtBQUssVUFBekI7QUFDQSxhQUFLLFdBQUw7QUFDQSxZQUFJLENBQUMsYUFBTCxFQUFvQjtBQUNoQixpQkFBSyxNQUFMLENBQVksU0FBWjtBQUNIO0FBQ0osS0E3eUNvQzs7QUEreUNyQzs7OztBQUlBLHFCQUFpQiwyQkFBVztBQUN4QixZQUFJLEtBQUssVUFBVCxFQUFxQjtBQUNqQixtQkFBTyxLQUFLLFVBQUwsQ0FBZ0IsU0FBaEIsRUFBUDtBQUNIO0FBQ0osS0F2ekNvQzs7QUF5ekNyQzs7OztBQUlBLG9CQUFnQiwwQkFBVztBQUN2QixZQUFJLEtBQUssV0FBTCxJQUFvQixLQUFLLFdBQTdCLEVBQTBDO0FBQ3RDO0FBQ0g7O0FBRUQsWUFBSSxZQUFZLFVBQVUsT0FBVixDQUFrQixTQUFsQzs7QUFFQSxZQUFJLFVBQVUsSUFBSSxTQUFKLENBQWM7QUFDeEIseUJBQWEsWUFEVztBQUV4QixzQkFBVSxLQUFLLGVBQUwsQ0FBcUIsSUFBckIsQ0FBMEIsSUFBMUIsQ0FGYztBQUd4QiwyQ0FBK0IsS0FBSztBQUhaLFNBQWQsQ0FBZDs7QUFNQSxZQUFJLFVBQVUsSUFBSSxTQUFKLENBQWM7QUFDeEIseUJBQWEsVUFEVztBQUV4QixzQkFBVSxLQUFLLGVBQUwsQ0FBcUIsSUFBckIsQ0FBMEIsSUFBMUIsQ0FGYztBQUd4QixvQkFBUTtBQUNKLG9CQUFJLEtBQUssTUFBTCxDQUFZLElBQVosQ0FBaUIsSUFBakIsQ0FEQTtBQUVKLHNCQUFNLEtBQUssUUFBTCxDQUFjLElBQWQsQ0FBbUIsSUFBbkI7QUFGRjtBQUhnQixTQUFkLENBQWQ7O0FBU0EsYUFBSyxXQUFMLEdBQW1CLE9BQW5CO0FBQ0EsYUFBSyxXQUFMLEdBQW1CLE9BQW5COztBQUVBLFlBQUksVUFBVSxLQUFLLFVBQUwsQ0FBZ0IscUJBQTlCO0FBQ0EsWUFBSSxVQUFVLEtBQUssVUFBTCxDQUFnQixxQkFBOUI7O0FBRUEsWUFBSSxXQUFXLFlBQVksRUFBM0IsRUFBK0I7QUFDM0IsaUJBQUssV0FBTCxDQUFpQixXQUFqQixHQUErQixPQUEvQjtBQUNIOztBQUVELFlBQUksV0FBVyxZQUFZLEVBQTNCLEVBQStCO0FBQzNCLGlCQUFLLFdBQUwsQ0FBaUIsV0FBakIsR0FBK0IsT0FBL0I7QUFDSDs7QUFFRCxhQUFLLEdBQUwsQ0FBUyxXQUFULENBQXFCLFFBQVEsR0FBN0I7QUFDQSxhQUFLLEdBQUwsQ0FBUyxXQUFULENBQXFCLFFBQVEsR0FBN0I7O0FBRUEsYUFBSyxrQ0FBTDtBQUNILEtBcjJDb0M7O0FBdTJDckMsd0NBQW9DLDhDQUFXO0FBQzNDLGFBQUssV0FBTCxDQUFpQixTQUFqQixDQUEyQixLQUFLLFdBQWhDLEVBQTZDLE1BQTdDO0FBQ0E7QUFDQSxhQUFLLFdBQUwsQ0FBaUIsTUFBakI7QUFDSCxLQTMyQ29DOztBQTYyQ3JDOzs7O0FBSUEseUJBQXFCLDZCQUFTLEdBQVQsRUFBYztBQUMvQixhQUFLLFdBQUwsQ0FBaUIsS0FBakIsR0FBeUI7QUFDckIsaUJBQUssQ0FEZ0I7QUFFckIsaUJBQUs7QUFGZ0IsU0FBekI7QUFJSCxLQXQzQ29DOztBQXczQ3JDLHlCQUFxQiw2QkFBUyxHQUFULEVBQWM7QUFDL0IsYUFBSyxXQUFMLENBQWlCLEtBQWpCLEdBQXlCO0FBQ3JCLGlCQUFLLENBRGdCO0FBRXJCLGlCQUFLO0FBRmdCLFNBQXpCO0FBSUgsS0E3M0NvQzs7QUErM0NyQyxvQ0FBZ0MsMENBQVc7QUFDdkMsWUFDSSxLQUFLLFlBQUwsS0FBc0IsS0FBSyxrQkFBM0IsSUFDQSxLQUFLLFlBQUwsS0FBc0IsS0FBSyxrQkFGL0IsRUFHRTtBQUNFLGlCQUFLLGtCQUFMLEdBQTBCLEtBQUssWUFBL0I7QUFDQSxpQkFBSyxrQkFBTCxHQUEwQixLQUFLLFlBQS9COztBQUVBLGdCQUFJLEtBQUssVUFBVCxFQUFxQjtBQUNqQixxQkFBSyxVQUFMLENBQWdCLDhCQUFoQjtBQUNIOztBQUVELGlCQUFLLGtCQUFMO0FBQ0g7QUFDSixLQTc0Q29DOztBQSs0Q3JDOzs7Ozs7QUFNQSxjQUFVLGtCQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDckIsZUFBTyxLQUFLLFFBQUwsQ0FBYyxRQUFkLENBQXVCLEtBQXZCLENBQTZCLEtBQUssUUFBbEMsRUFBNEMsU0FBNUMsQ0FBUCxDQURxQixDQUMwQztBQUNsRSxLQXY1Q29DOztBQXk1Q3JDOzs7Ozs7O0FBT0EsY0FBVSxrQkFBUyxDQUFULEVBQVksQ0FBWixFQUFlLEtBQWYsRUFBc0I7QUFDNUIsYUFBSyxRQUFMLENBQWMsUUFBZCxDQUF1QixLQUF2QixDQUE2QixLQUFLLFFBQWxDLEVBQTRDLFNBQTVDLEVBRDRCLENBQzRCO0FBQzNELEtBbDZDb0M7O0FBbzZDckM7Ozs7O0FBS0EsdUJBQW1CLDZCQUFXO0FBQzFCLGVBQU8sS0FBSyxRQUFMLENBQWMsaUJBQWQsRUFBUDtBQUNILEtBMzZDb0M7O0FBNjZDckM7Ozs7QUFJQSxrQkFBYyx3QkFBVztBQUNyQixhQUFLLFFBQUwsR0FBZ0IsS0FBSyxRQUFMLElBQWlCLElBQUksUUFBSixDQUFhLElBQWIsQ0FBakM7QUFDSCxLQW43Q29DOztBQXE3Q3JDOzs7OztBQUtBLG9CQUFnQix3QkFBUyxXQUFULEVBQXNCO0FBQ2xDLGVBQU8sS0FBSyxRQUFMLENBQWMsY0FBZCxDQUE2QixXQUE3QixDQUFQO0FBQ0gsS0E1N0NvQzs7QUE4N0NyQzs7Ozs7O0FBTUEsb0JBQWdCLHdCQUFTLFdBQVQsRUFBc0IsV0FBdEIsRUFBbUM7QUFDL0MsWUFBSSxLQUFLLFlBQUwsRUFBSixFQUF5QjtBQUNyQixpQkFBSyxRQUFMLENBQWMsY0FBZCxDQUE2QixXQUE3QixFQUEwQyxXQUExQztBQUNIO0FBQ0osS0F4OENvQzs7QUEwOENyQzs7OztBQUlBLDBCQUFzQixnQ0FBVztBQUM3QixlQUFPLEtBQUssUUFBTCxDQUFjLG9CQUFkLEVBQVA7QUFDSCxLQWg5Q29DOztBQWs5Q3JDOzs7OztBQUtBLGtCQUFjLHNCQUFTLFFBQVQsRUFBbUIsU0FBbkIsRUFBOEI7QUFDeEMsZUFBTyxLQUFLLFFBQUwsQ0FBYyxZQUFkLENBQTJCLFFBQTNCLEVBQXFDLFNBQXJDLENBQVA7QUFDSCxLQXo5Q29DOztBQTI5Q3JDOzs7O0FBSUEsK0JBQTJCLHFDQUFXO0FBQ2xDLGVBQU8sS0FBSyxRQUFMLENBQWMseUJBQWQsRUFBUDtBQUNILEtBaitDb0M7O0FBbStDckM7Ozs7OztBQU1BLGtCQUFjLHNCQUFTLFFBQVQsRUFBbUIsU0FBbkIsRUFBOEIsU0FBOUIsRUFBeUM7QUFDbkQsWUFBSSxLQUFLLFlBQUwsRUFBSixFQUF5QjtBQUNyQixpQkFBSyxRQUFMLENBQWMsWUFBZCxDQUEyQixRQUEzQixFQUFxQyxTQUFyQyxFQUFnRCxTQUFoRDtBQUNIO0FBQ0osS0E3K0NvQzs7QUErK0NyQzs7OztBQUlBLHdCQUFvQiw4QkFBVztBQUMzQixlQUFPLEtBQUssUUFBTCxDQUFjLGtCQUFkLEVBQVA7QUFDSCxLQXIvQ29DOztBQXUvQ3JDOzs7OztBQUtBLG9CQUFnQiwwQkFBVztBQUN2QixlQUFPLEtBQUssUUFBTCxDQUFjLG9CQUFkLEVBQVA7QUFDSCxLQTkvQ29DOztBQWdnRHJDOzs7O0FBSUEsaUJBQWEsdUJBQVc7QUFDcEIsZUFBTyxLQUFLLFFBQUwsQ0FBYyxXQUFkLEVBQVA7QUFDSCxLQXRnRG9DOztBQXdnRHJDOzs7O0FBSUEseUJBQXFCLCtCQUFXO0FBQzVCLGVBQU8sS0FBSyxRQUFMLENBQWMsbUJBQWQsRUFBUDtBQUNILEtBOWdEb0M7O0FBZ2hEckM7Ozs7QUFJQSxzQkFBa0IsNEJBQVc7QUFDekIsZUFBTyxLQUFLLFFBQUwsQ0FBYyxnQkFBZCxFQUFQO0FBQ0gsS0F0aERvQzs7QUF3aERyQzs7Ozs7O0FBTUEsb0JBQWdCLHdCQUFTLEtBQVQsRUFBZ0I7QUFDNUIsYUFBSyxRQUFMLENBQWMsY0FBZCxDQUE2QixJQUE3QixFQUFtQyxLQUFuQztBQUNILEtBaGlEb0M7O0FBa2lEckM7Ozs7OztBQU1BLHNCQUFrQiwwQkFBUyxLQUFULEVBQWdCO0FBQzlCLGFBQUssUUFBTCxDQUFjLGdCQUFkLENBQStCLElBQS9CLEVBQXFDLEtBQXJDO0FBQ0gsS0ExaURvQzs7QUE0aURyQzs7Ozs7O0FBTUEseUJBQXFCLDZCQUFTLEtBQVQsRUFBZ0I7QUFDakMsYUFBSyxRQUFMLENBQWMsbUJBQWQsQ0FBa0MsSUFBbEMsRUFBd0MsS0FBeEM7QUFDSCxLQXBqRG9DOztBQXNqRHJDOzs7Ozs7OztBQVFBLHNCQUFrQiwwQkFBUyxLQUFULEVBQWdCO0FBQzlCLGVBQU8sS0FBSyxNQUFMLENBQVksS0FBWixDQUFQO0FBQ0gsS0Foa0RvQzs7QUFra0RyQzs7Ozs7OztBQU9BLHFCQUFpQix5QkFBUyxLQUFULEVBQWdCO0FBQzdCLGVBQU8sS0FBSyxRQUFMLENBQWMsZUFBZCxDQUE4QixLQUE5QixDQUFQO0FBQ0gsS0Eza0RvQzs7QUE2a0RyQzs7Ozs7O0FBTUEsaUJBQWEsdUJBQVc7QUFDcEIsWUFBSSxLQUFLLFVBQUwsQ0FBZ0IsUUFBcEIsRUFBOEI7QUFDMUIsaUJBQUssZUFBTCxDQUFxQixPQUFyQjtBQUNILFNBRkQsTUFFTztBQUNILGlCQUFLLFlBQUwsQ0FBa0IsT0FBbEIsRUFBMkIsSUFBM0I7QUFDSDtBQUNELGFBQUssTUFBTCxDQUFZLE1BQVo7QUFDSCxLQTFsRG9DOztBQTRsRHJDOzs7O0FBSUEsY0FBVSxrQkFBUyxHQUFULEVBQWM7QUFDcEIsWUFBSSxPQUFPLGdCQUFQLElBQTJCLEtBQUssVUFBTCxDQUFnQixRQUEvQyxFQUF5RDtBQUNyRCxnQkFBSSxtQkFBbUIsT0FBTyxnQkFBUCxJQUEyQixDQUFsRDtBQUFBLGdCQUNJLG9CQUFvQixJQUFJLDRCQUFKLElBQ2hCLElBQUkseUJBRFksSUFFaEIsSUFBSSx3QkFGWSxJQUdoQixJQUFJLHVCQUhZLElBSWhCLElBQUksc0JBSlksSUFJYyxDQUx0QztBQUFBLGdCQU1JLFNBQVMsbUJBQW1CLGlCQU5oQztBQU9ILFNBUkQsTUFRTztBQUNILHFCQUFTLENBQVQ7QUFDSDtBQUNELGVBQU8sTUFBUDtBQUNILEtBN21Eb0M7O0FBK21EckM7Ozs7O0FBS0Esc0JBQWtCLDBCQUFTLFFBQVQsRUFBbUI7QUFDakMsZUFBTyxLQUFLLFFBQUwsQ0FBYyxnQkFBZCxDQUErQixRQUEvQixDQUFQO0FBQ0gsS0F0bkRvQzs7QUF3bkRyQzs7Ozs7QUFLQSx1QkFBbUIsMkJBQVMsUUFBVCxFQUFtQjtBQUNsQyxlQUFPLEtBQUssUUFBTCxDQUFjLGlCQUFkLENBQWdDLFFBQWhDLENBQVA7QUFDSCxLQS9uRG9DOztBQWlvRHJDOzs7O0FBSUEsa0JBQWMsd0JBQVc7QUFDckIsWUFBSSxTQUFTLEtBQUssUUFBTCxDQUFjLFdBQWQsQ0FBMEIsQ0FBQyxDQUEzQixFQUE4QixDQUFDLENBQS9CLENBQWI7QUFDQSxZQUFJLFlBQVksS0FBSyxTQUFyQjtBQUNBLFlBQ0ksYUFDQSxVQUFVLENBQVYsR0FBYyxDQUFDLENBRGYsSUFFQSxVQUFVLENBQVYsR0FBYyxDQUFDLENBSG5CLEVBSUU7QUFDRSxnQkFBSSxJQUFJLFVBQVUsQ0FBVixHQUFjLEtBQUssZUFBTCxFQUF0QjtBQUNBLHFCQUFTLEtBQUssUUFBTCxDQUFjLFdBQWQsQ0FBMEIsQ0FBMUIsRUFBNkIsVUFBVSxDQUFWLEdBQWMsS0FBSyxlQUFMLEVBQTNDLENBQVQ7QUFDSDtBQUNELGFBQUssUUFBTCxDQUFjLE1BQWQ7QUFDSCxLQWpwRG9DOztBQW1wRHJDOzs7Ozs7QUFNQSxpQkFBYSxxQkFBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQ3hCLGFBQUssUUFBTCxDQUFjLFdBQWQsQ0FBMEIsQ0FBMUIsRUFBNkIsQ0FBN0I7QUFDSCxLQTNwRG9DOztBQTZwRHJDOzs7O0FBSUEsc0JBQWtCLDRCQUFXO0FBQ3pCLGVBQU8sQ0FBQyxDQUFDLEtBQUssb0JBQUwsQ0FBMEIsT0FBbkM7QUFDSCxLQW5xRG9DOztBQXFxRHJDOzs7O0FBSUEscUJBQWlCLDJCQUFXO0FBQ3hCLGVBQU8sS0FBSyxRQUFMLENBQWMsb0JBQWQsRUFBUDtBQUNILEtBM3FEb0M7O0FBNnFEckM7Ozs7O0FBS0Esb0JBQWdCLHdCQUFTLGFBQVQsRUFBd0I7QUFDcEMsWUFBSSxTQUFTLGlCQUFpQixDQUFDLENBQWxCLEdBQXNCLEtBQUssUUFBTCxDQUFjLGVBQWQsQ0FBOEIsYUFBOUIsQ0FBdEIsR0FBcUUsYUFBbEY7QUFDQSxlQUFPLHFCQUFQLENBQTZCLElBQTdCO0FBQ0EsYUFBSyxRQUFMLENBQWMsU0FBZCxDQUF3QixNQUF4QixFQUFnQyxJQUFoQztBQUNBLGFBQUssa0JBQUw7QUFDSCxLQXZyRG9DOztBQXlyRHJDOzs7OztBQUtBLGtCQUFjLHNCQUFTLGVBQVQsRUFBMEI7QUFDcEMsYUFBSyxNQUFMLENBQVksWUFBWixDQUF5QixlQUF6QjtBQUNILEtBaHNEb0M7O0FBa3NEckM7Ozs7QUFJQSw0QkFBd0Isa0NBQVc7QUFDL0IsZUFBTyxLQUFLLFFBQUwsQ0FBYyxzQkFBZCxFQUFQO0FBQ0gsS0F4c0RvQzs7QUEwc0RyQzs7OztBQUlBLHlCQUFxQiwrQkFBVztBQUM1QixlQUFPLEtBQUssUUFBTCxDQUFjLG1CQUFkLEVBQVA7QUFDSCxLQWh0RG9DOztBQWt0RHJDOzs7O0FBSUEsZ0JBQVksc0JBQVc7QUFDbkIsYUFBSyxNQUFMLENBQVksU0FBWjtBQUNILEtBeHREb0M7O0FBMnREckM7Ozs7QUFJQSxxQkFBaUIsMkJBQVc7QUFDeEIsYUFBSyxNQUFMLENBQVksZUFBWjtBQUNILEtBanVEb0M7O0FBbXVEckM7Ozs7QUFJQSxzQkFBa0IsNEJBQVc7QUFDekIsYUFBSyxNQUFMLENBQVksZ0JBQVo7QUFDSCxLQXp1RG9DOztBQTJ1RHJDOzs7O0FBSUEseUJBQXFCLCtCQUFXO0FBQzVCLGFBQUssTUFBTCxDQUFZLG1CQUFaO0FBQ0gsS0FqdkRvQzs7QUFtdkRyQzs7OztBQUlBLHdCQUFvQiw4QkFBVztBQUMzQixhQUFLLE1BQUwsQ0FBWSxrQkFBWjtBQUNILEtBenZEb0M7O0FBMnZEckM7OztBQUdBLGlCQUFhLHFCQUFTLE1BQVQsRUFBaUIsTUFBakIsRUFBeUI7QUFDbEM7QUFDQTtBQUNBLGFBQUssUUFBTCxDQUFjLFdBQWQsQ0FBMEIsTUFBMUIsRUFBa0MsTUFBbEM7QUFDSCxLQWx3RG9DOztBQW93RHJDOzs7Ozs7Ozs7O0FBVUEsaUJBQWEscUJBQVMsSUFBVCxFQUFlLEdBQWYsRUFBb0IsTUFBcEIsRUFBNEIsY0FBNUIsRUFBNEMsa0JBQTVDLEVBQWdFO0FBQ3pFLGFBQUssUUFBTCxDQUFjLFdBQWQsQ0FBMEIsSUFBMUIsRUFBZ0MsR0FBaEMsRUFBcUMsTUFBckMsRUFBNkMsY0FBN0MsRUFBNkQsa0JBQTdEO0FBQ0gsS0FoeERvQzs7QUFreERyQyx3QkFBb0IsOEJBQVc7QUFDM0IsZUFBTyxLQUFLLFFBQUwsQ0FBYyxrQkFBZCxFQUFQO0FBQ0gsS0FweERvQzs7QUFzeERyQywrQkFBMkIscUNBQVc7QUFDbEMsYUFBSyxRQUFMLENBQWMseUJBQWQ7QUFDSCxLQXh4RG9DOztBQTB4RHJDLDZCQUF5QixtQ0FBVztBQUNoQyxlQUFPLEtBQUssUUFBTCxDQUFjLHVCQUFkLEVBQVA7QUFDSCxLQTV4RG9DOztBQTh4RHJDLDZCQUF5QixtQ0FBVztBQUNoQyxZQUFJLGlCQUFpQixLQUFLLGlCQUFMLEVBQXJCO0FBQ0EsWUFBSSxZQUFZLEtBQUssWUFBTCxFQUFoQjtBQUNBLGVBQU8sVUFBVSxDQUFWLEdBQWMsQ0FBZCxJQUFtQixVQUFVLENBQVYsR0FBYyxjQUF4QztBQUNILEtBbHlEb0M7O0FBb3lEckM7Ozs7O0FBS0EseUJBQXFCLDZCQUFTLENBQVQsRUFBWTtBQUM3QixlQUFPLEtBQUssUUFBTCxDQUFjLG1CQUFkLENBQWtDLENBQWxDLENBQVA7QUFDSCxLQTN5RG9DOztBQTZ5RHJDOzs7OztBQUtBLHlCQUFxQiw2QkFBUyxDQUFULEVBQVksVUFBWixFQUF3QjtBQUN6QyxhQUFLLFFBQUwsQ0FBYyxtQkFBZCxDQUFrQyxDQUFsQyxFQUFxQyxVQUFyQztBQUNILEtBcHpEb0M7O0FBc3pEckM7Ozs7O0FBS0EsNEJBQXdCLGdDQUFTLENBQVQsRUFBWTtBQUNoQyxhQUFLLFFBQUwsQ0FBYyxzQkFBZCxDQUFxQyxDQUFyQztBQUNBLGFBQUssUUFBTCxDQUFjLDRCQUFkO0FBQ0gsS0E5ekRvQzs7QUFnMERyQzs7Ozs7QUFLQSxlQUFXLG1CQUFTLENBQVQsRUFBWTtBQUNuQixlQUFPLElBQUksS0FBSyxRQUFMLENBQWMsU0FBbEIsQ0FBNEIsQ0FBNUIsRUFBK0IsQ0FBL0IsRUFBa0MsU0FBekM7QUFDSCxLQXYwRG9DOztBQXkwRHJDOzs7O0FBSUEsdUJBQW1CLDZCQUFXO0FBQzFCLGVBQU8sS0FBSyxRQUFMLENBQWMsaUJBQWQsRUFBUDtBQUNILEtBLzBEb0M7O0FBaTFEckM7Ozs7QUFJQSx1QkFBbUIsNkJBQVc7QUFDMUIsZUFBTyxLQUFLLFFBQUwsQ0FBYyxpQkFBZCxFQUFQO0FBQ0gsS0F2MURvQzs7QUF5MURyQzs7OztBQUlBLHdCQUFvQiw4QkFBVztBQUMzQixlQUFPLEtBQUssUUFBTCxDQUFjLGtCQUFkLEVBQVA7QUFDSCxLQS8xRG9DOztBQWkyRHJDLG1CQUFlLHVCQUFTLFdBQVQsRUFBc0I7QUFDakMsZUFBTyxLQUFLLFFBQUwsQ0FBYyxhQUFkLENBQTRCLFdBQTVCLENBQVA7QUFDSCxLQW4yRG9DO0FBbzJEckMsbUJBQWUsdUJBQVMsR0FBVCxFQUFjO0FBQ3pCLGVBQU8sS0FBSyxRQUFMLENBQWMsYUFBZCxDQUE0QixHQUE1QixDQUFQO0FBQ0gsS0F0MkRvQztBQXUyRHJDLFlBQVEsZ0JBQVMsQ0FBVCxFQUFZO0FBQ2hCLGVBQU8sS0FBSyxRQUFMLENBQWMsTUFBZCxDQUFxQixDQUFyQixDQUFQO0FBQ0gsS0F6MkRvQzs7QUEyMkRyQyxjQUFVLGtCQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDckIsZUFBTyxJQUFJLEtBQUosQ0FBVSxDQUFWLEVBQWEsQ0FBYixDQUFQO0FBQ0gsS0E3MkRvQztBQTgyRHJDLGtCQUFjLHNCQUFTLENBQVQsRUFBWSxDQUFaLEVBQWUsS0FBZixFQUFzQixNQUF0QixFQUE4QjtBQUN4QyxlQUFPLElBQUksU0FBSixDQUFjLENBQWQsRUFBaUIsQ0FBakIsRUFBb0IsS0FBcEIsRUFBMkIsTUFBM0IsQ0FBUDtBQUNILEtBaDNEb0M7O0FBazNEckMsUUFBSSxPQUFKLEdBQWM7QUFDVixlQUFPLEtBQUssUUFBTCxDQUFjLE9BQXJCO0FBQ0gsS0FwM0RvQzs7QUFzM0RyQzs7Ozs7QUFLQSxnQkFBWSxvQkFBUyxJQUFULEVBQTZDO0FBQUE7O0FBQUEsWUFBOUIsVUFBOEIsdUVBQWpCLEtBQUssVUFBWTs7QUFDckQsWUFBSSxDQUFDLFVBQUwsRUFBaUI7QUFDYixtQkFBTyxFQUFQO0FBQ0g7QUFDRCxZQUFNLFFBQVEsV0FBVyxNQUFYLENBQWtCO0FBQUEsbUJBQU0sR0FBRyxLQUFILEtBQWEsSUFBYixJQUFxQixHQUFHLEtBQUgsS0FBYSxJQUFsQyxJQUEwQyxHQUFHLGFBQUgsS0FBcUIsSUFBckU7QUFBQSxTQUFsQixDQUFkOztBQUVBLG1CQUFXLE1BQVgsQ0FBa0I7QUFBQSxtQkFBTSxHQUFHLFFBQVQ7QUFBQSxTQUFsQixFQUFxQyxPQUFyQyxDQUE2QztBQUFBLG1CQUFNLEdBQUcsSUFBSCxDQUFRLEtBQVIsQ0FBYyxLQUFkLEVBQXFCLE9BQUssVUFBTCxDQUFnQixJQUFoQixFQUFzQixHQUFHLFFBQXpCLENBQXJCLENBQU47QUFBQSxTQUE3Qzs7QUFFQSxlQUFPLEtBQVA7QUFDSCxLQXA0RG9DOztBQXM0RHJDLHFCQUFpQix5QkFBUyxJQUFULEVBQWU7QUFDNUIsZUFBTyxLQUFLLGdCQUFMLEdBQXdCLElBQXhCLENBQTZCO0FBQUEsbUJBQUssRUFBRSxJQUFGLEtBQVcsSUFBaEI7QUFBQSxTQUE3QixDQUFQO0FBQ0gsS0F4NERvQzs7QUEwNERyQyw0QkFBd0Isa0NBQVc7QUFDL0IsWUFBTSxTQUFTLE9BQU8sSUFBUCxDQUFZLEtBQUssUUFBTCxDQUFjLGdCQUFkLEVBQVosQ0FBZjtBQUNBLCtEQUFxRCxPQUFPLElBQVAsQ0FBWSxJQUFaLENBQXJEO0FBQ0gsS0E3NERvQzs7QUErNERyQyxPQS80RHFDLGlCQSs0RC9CO0FBQ0YsWUFBSSxLQUFLLFNBQVQsRUFBb0I7QUFBQTs7QUFDaEIsaUNBQVEsR0FBUixpQkFBZSxTQUFmO0FBQ0g7QUFDSixLQW41RG9DOzs7QUFxNURyQzs7OztBQUlBLG9CQXo1RHFDLDRCQXk1RHBCLElBejVEb0IsRUF5NURkO0FBQ25CLGFBQUssVUFBTCxDQUFnQixhQUFoQixHQUFnQyxJQUFoQztBQUNIO0FBMzVEb0MsQ0FBekIsQ0FBaEI7O0FBKzVEQTs7Ozs7O0FBTUEsU0FBUyxHQUFULEdBQWU7QUFDWCxTQUFLLFlBQUwsR0FBb0IsU0FBUyxZQUE3QjtBQUNBLFNBQUssbUJBQUwsR0FBMkIsU0FBUyxtQkFBcEM7QUFDQSxTQUFLLGdCQUFMLEdBQXdCLFNBQVMsZ0JBQWpDO0FBQ0EsU0FBSyxVQUFMLEdBQWtCLFNBQVMsVUFBM0I7QUFDQSxTQUFLLGFBQUwsR0FBcUIsU0FBUyxhQUE5QjtBQUNBLFNBQUssZUFBTCxHQUF1QixTQUFTLGVBQWhDO0FBQ0EsU0FBSyxnQkFBTCxHQUF3QixTQUFTLGdCQUFqQztBQUNBLFNBQUssY0FBTCxHQUFzQixTQUFTLGNBQS9CO0FBQ0g7O0FBRUQsU0FBUyxxQkFBVCxDQUErQixZQUEvQixFQUE2QztBQUN6QyxRQUFJLE1BQU0sU0FBUyxjQUFULENBQXdCLFdBQXhCLENBQVY7QUFBQSxRQUNJLE9BQU8sT0FBTyxDQUFDLElBQUksaUJBRHZCOztBQUdBLFFBQUksQ0FBQyxJQUFMLEVBQVc7QUFDUCxjQUFNLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUFOO0FBQ0Esa0JBQVUsR0FBVixFQUFlLFlBQWYsRUFBNkIsV0FBN0I7QUFDQSxpQkFBUyxJQUFULENBQWMsV0FBZCxDQUEwQixHQUExQjtBQUNIOztBQUVELFdBQU8sR0FBUDtBQUNIOztBQUVELFNBQVMsU0FBVCxDQUFtQixFQUFuQixFQUF1QixLQUF2QixFQUE4QixJQUE5QixFQUFvQztBQUNoQyxRQUFJLEtBQUosRUFBVztBQUNQLFlBQUksVUFBVSxHQUFHLEtBQWpCO0FBQ0EsYUFBSyxPQUFMLENBQWEsVUFBUyxHQUFULEVBQWM7QUFDdkIsZ0JBQUksTUFBTSxHQUFOLE1BQWUsU0FBbkIsRUFBOEI7QUFDMUIsd0JBQVEsR0FBUixJQUFlLE1BQU0sR0FBTixDQUFmO0FBQ0g7QUFDSixTQUpEO0FBS0g7QUFDSjs7QUFFRCxTQUFTLGtCQUFULEdBQThCO0FBQzFCLFFBQUksT0FBTyxJQUFYO0FBQ0EsV0FBTyxPQUFPLElBQVAsQ0FBWSxJQUFaLEVBQWtCLE1BQWxCLENBQXlCLFVBQVMsR0FBVCxFQUFjLEdBQWQsRUFBbUI7QUFDL0MsWUFBSSxRQUFRLFFBQVosRUFBc0I7QUFDbEIsZ0JBQUksR0FBSixJQUFXLGFBQWEsSUFBYixDQUFrQixHQUFsQixJQUNMLElBREssQ0FDQTtBQURBLGNBRUwsS0FBSyxHQUFMLEVBQVUsUUFBVixHQUFxQjtBQUFyQixhQUNHLE9BREgsQ0FDVyx1QkFEWCxFQUNvQyxXQURwQyxFQUNpRDtBQURqRCxhQUVHLE9BRkgsQ0FFVyxXQUZYLEVBRXdCLEdBRnhCLENBRk4sQ0FEa0IsQ0FLa0I7QUFDdkM7QUFDRCxlQUFPLEdBQVA7QUFDSCxLQVRNLEVBU0osRUFUSSxDQUFQO0FBVUg7O0FBRUQsU0FBUyxLQUFULENBQWUsS0FBZixFQUFzQjtBQUNsQixRQUFJLE1BQU0sT0FBTixDQUFjLEtBQWQsQ0FBSixFQUEwQjtBQUN0QixlQUFPLE1BQU0sS0FBTixFQUFQLENBRHNCLENBQ0E7QUFDekIsS0FGRCxNQUVPLElBQUksUUFBTyxLQUFQLHlDQUFPLEtBQVAsT0FBaUIsUUFBckIsRUFBK0I7QUFDbEMsZUFBTyxPQUFPLGdCQUFQLENBQXdCLEVBQXhCLEVBQTRCLE9BQU8seUJBQVAsQ0FBaUMsS0FBakMsQ0FBNUIsQ0FBUDtBQUNILEtBRk0sTUFFQTtBQUNILGVBQU8sS0FBUDtBQUNIO0FBQ0o7O0FBRUQsU0FBUyxTQUFULENBQW1CLE1BQW5CLEVBQTJCO0FBQ3ZCLFFBQUksU0FBUyxNQUFNLE1BQU4sQ0FBYjtBQUNBLFdBQU8sSUFBUCxDQUFZLE1BQVosRUFBb0IsT0FBcEIsQ0FBNEIsVUFBUyxHQUFULEVBQWM7QUFDdEMsWUFBSSxhQUFhLE9BQU8sd0JBQVAsQ0FBZ0MsTUFBaEMsRUFBd0MsR0FBeEMsQ0FBakI7QUFDQSxZQUFJLFFBQU8sV0FBVyxLQUFsQixNQUE0QixRQUFoQyxFQUEwQztBQUN0QyxtQkFBTyxHQUFQLElBQWMsVUFBVSxXQUFXLEtBQXJCLENBQWQ7QUFDSDtBQUNKLEtBTEQ7QUFNQSxXQUFPLE1BQVA7QUFDSDs7QUFFRCxTQUFTLGdCQUFULENBQTBCLElBQTFCLEVBQWdDLEtBQWhDLEVBQXVDO0FBQ25DLFFBQUksYUFBYSxZQUFZLEdBQVosQ0FBZ0IsSUFBaEIsQ0FBakI7QUFDQSxRQUFJLFVBQUosRUFBZ0I7QUFDWixlQUFPLElBQUksVUFBSixDQUFlLElBQWYsRUFBcUIsS0FBckIsQ0FBUDtBQUNIO0FBQ0o7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQSxVQUFVLE9BQVYsR0FBb0IsRUFBcEI7O0FBRUE7Ozs7Ozs7Ozs7QUFVQSxVQUFVLFlBQVYsR0FBeUI7QUFDckIsWUFBUSxPQURhO0FBRXJCLG1CQUFlLEVBQUUsdUJBQXVCLENBQXpCO0FBRk0sQ0FBekI7O0FBTUE7O0FBRUEsVUFBVSxLQUFWLEdBQWtCLFVBQVUsU0FBVixDQUFvQixLQUF0QztBQUNBLFVBQVUsS0FBVixDQUFnQixRQUFRLFVBQVIsRUFBb0IsV0FBcEM7O0FBRUEsVUFBVSxTQUFWLENBQW9CLEtBQXBCLENBQTBCLFFBQVEsVUFBUixFQUFvQixLQUE5QztBQUNBLFVBQVUsU0FBVixDQUFvQixLQUFwQixDQUEwQixRQUFRLFVBQVIsRUFBb0IsS0FBOUM7QUFDQSxVQUFVLFNBQVYsQ0FBb0IsS0FBcEIsQ0FBMEIsUUFBUSxvQkFBUixFQUE4QixLQUF4RDtBQUNBLFVBQVUsU0FBVixDQUFvQixLQUFwQixDQUEwQixRQUFRLGFBQVIsRUFBdUIsS0FBakQ7QUFDQSxVQUFVLFNBQVYsQ0FBb0IsS0FBcEIsQ0FBMEIsUUFBUSxhQUFSLEVBQXVCLEtBQWpEOztBQUdBOztBQUVBLFNBQVMsU0FBVCxDQUFtQixhQUFuQixFQUFrQyxNQUFsQyxFQUEwQztBQUN0QyxRQUFJLENBQUMsVUFBVSxNQUFWLENBQWlCLGFBQWpCLENBQUwsRUFBc0M7QUFDbEMsWUFBSSxNQUFNLGNBQWMsS0FBZCxDQUFvQixNQUFwQixFQUE0QixDQUE1QixDQUFWO0FBQ0EsZ0JBQVEsSUFBUixDQUFhLGtCQUFrQixHQUFsQixHQUF3Qix3QkFBeEIsR0FDVCxjQURTLEdBQ1EsR0FEUixHQUNjLGlEQURkLEdBRVQsY0FGUyxHQUVRLGFBRlIsR0FFd0IsNENBRnhCLEdBR1Qsb0ZBSFMsR0FJVCxrRkFKSjtBQUtBLGtCQUFVLE1BQVYsQ0FBaUIsYUFBakIsSUFBa0MsSUFBbEM7QUFDSDtBQUNELFdBQU8sTUFBUDtBQUNIOztBQUVELFVBQVUsTUFBVixHQUFtQixFQUFuQjs7QUFHQSxPQUFPLGdCQUFQLENBQXdCLFNBQXhCLEVBQW1DO0FBQy9CLFVBQU07QUFDRixhQUFLLGVBQVc7QUFDWixtQkFBTyxVQUFVLHdCQUFWLEVBQW9DLFFBQVEsU0FBUixDQUFwQyxDQUFQO0FBQ0g7QUFIQyxLQUR5QjtBQU0vQixZQUFRO0FBQ0osYUFBSyxlQUFXO0FBQ1osbUJBQU8sVUFBVSxzQkFBVixFQUFrQyxRQUFRLGNBQVIsQ0FBbEMsQ0FBUDtBQUNIO0FBSEc7QUFOdUIsQ0FBbkM7O0FBY0E7Ozs7OztBQU1BLFVBQVUsS0FBVixHQUFrQixFQUFsQjs7QUFHQTs7Ozs7Ozs7Ozs7QUFXQSxVQUFVLFFBQVYsR0FBcUIsVUFBVSxVQUFWLEdBQXVCLFFBQTVDOztBQUdBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBVixHQUFvQixPQUFwQjs7QUFHQSxPQUFPLE9BQVAsR0FBaUIsU0FBakI7OztBQ3hxRUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBY0EsT0FBTyxPQUFQLEdBQWlCO0FBQ2IsYUFBVyxRQUFRLGtCQUFSLENBREU7QUFFYixhQUFXLFFBQVEsVUFBUixDQUZFLENBRWtCO0FBRmxCLENBQWpCOzs7QUNoQkE7QUFDQTs7QUFFQSxJQUFNLFlBQVksUUFBUSxXQUFSLEVBQXFCLFNBQXZDOztBQUVBOzs7OztBQUtBLFFBQVEsS0FBUixHQUFnQjs7QUFFWjs7Ozs7QUFLQSxrQkFBYyxDQVBGOztBQVNaOzs7OztBQUtBLGtCQUFjLENBZEY7O0FBZ0JaOzs7O0FBSUEsaUJBQWEsSUFwQkQ7O0FBc0JaOzs7OztBQUtBLHdCQUFvQixDQTNCUjs7QUE2Qlo7Ozs7O0FBS0Esd0JBQW9CLENBbENSOztBQW9DWixrQkFBYyxLQXBDRjs7QUFzQ1o7Ozs7O0FBS0EscUJBQWlCLHlCQUFTLE9BQVQsRUFBa0I7QUFDL0IsYUFBSyxZQUFMLEdBQW9CLE9BQXBCO0FBQ0gsS0E3Q1c7O0FBK0NaOzs7O0FBSUEsb0JBQWdCLDBCQUFXO0FBQ3ZCLGVBQU8sS0FBSyxZQUFaO0FBQ0gsS0FyRFc7O0FBdURaOzs7Ozs7QUFNQSxjQUFVLGtCQUFTLE9BQVQsRUFBa0IsT0FBbEIsRUFBMkI7QUFDakMsYUFBSyxTQUFMLENBQWUsT0FBZjtBQUNBLGFBQUssU0FBTCxDQUFlLE9BQWY7QUFDSCxLQWhFVzs7QUFrRVo7Ozs7O0FBS0EsZUFBVyxtQkFBUyxPQUFULEVBQWtCO0FBQ3pCLFlBQU0sTUFBTSxLQUFLLFdBQUwsQ0FBaUIsS0FBakIsQ0FBdUIsR0FBbkM7QUFDQSxZQUFNLFdBQVcsS0FBSyxZQUF0QjtBQUNBLFlBQU0sWUFBWSxLQUFLLGVBQUwsRUFBbEI7QUFDQSxZQUFNLFlBQVksS0FBSyxRQUFMLENBQWMsWUFBZCxDQUEyQixLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksWUFBWSxPQUF4QixDQUEzQixDQUFsQjtBQUNBLFlBQU0sV0FBVyxLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsV0FBVyxVQUFVLFNBQW5DLENBQWpCO0FBQ0EsWUFBSSxhQUFhLFFBQWpCLEVBQTJCO0FBQ3ZCLGlCQUFLLGVBQUwsQ0FBcUIsUUFBckI7QUFDSDtBQUNKLEtBaEZXOztBQWtGWjs7Ozs7QUFLQSxlQUFXLG1CQUFTLE9BQVQsRUFBa0I7QUFDekIsWUFBTSxNQUFNLEtBQUssV0FBTCxDQUFpQixLQUFqQixDQUF1QixHQUFuQztBQUNBLFlBQU0sV0FBVyxLQUFLLFlBQXRCO0FBQ0EsWUFBTSxZQUFZLEtBQUssZUFBTCxFQUFsQjtBQUNBLFlBQU0sV0FBVyxLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsV0FBVyxVQUFVLEtBQUssUUFBTCxDQUFjLGNBQWQsQ0FBNkIsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLFlBQVksT0FBeEIsQ0FBN0IsQ0FBbkMsQ0FBakI7QUFDQSxZQUFJLGFBQWEsUUFBakIsRUFBMkI7QUFDdkIsaUJBQUssZUFBTCxDQUFxQixRQUFyQjtBQUNIO0FBQ0osS0EvRlc7O0FBaUdaLHlCQUFxQiw2QkFBUyxNQUFULEVBQWlCLEdBQWpCLEVBQXNCO0FBQUEsbUNBQ1osS0FBSyxRQUFMLENBQWMsVUFERjtBQUFBLFlBQy9CLE1BRCtCLHdCQUMvQixNQUQrQjtBQUFBLFlBQ3ZCLE1BRHVCLHdCQUN2QixNQUR1QjtBQUFBLDBCQUVLLEtBQUssVUFGVjtBQUFBLFlBRS9CLGdCQUYrQixlQUUvQixnQkFGK0I7QUFBQSxZQUViLGFBRmEsZUFFYixhQUZhOzs7QUFJdkMsWUFBSSxjQUFKO0FBQ0EsWUFBSSxVQUFVLENBQWQ7O0FBRUE7QUFDQSxZQUFJLFVBQVUsZ0JBQWQsRUFBZ0M7QUFDNUIsb0JBQVEsU0FBUyxPQUFPLENBQXhCO0FBQ0E7QUFDQSxnQkFBSSxRQUFRLENBQVosRUFBZTtBQUNYLDBCQUFVLENBQVY7QUFDQSxxQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixLQUFLLEtBQUssR0FBTCxDQUFTLEtBQVQsSUFBa0IsQ0FBdkMsRUFBMEMsR0FBMUMsRUFBK0M7QUFDM0MsK0JBQVcsS0FBSyxjQUFMLENBQW9CLE9BQU8sQ0FBUCxHQUFXLENBQS9CLENBQVg7QUFDSDs7QUFFRCxxQkFBSyxXQUFMLENBQWlCLEtBQWpCLElBQTBCLE9BQTFCO0FBQ0g7O0FBRUQsb0JBQVEsU0FBUyxPQUFPLENBQXhCO0FBQ0EsZ0JBQUksU0FBUyxDQUFiLEVBQWdCO0FBQ1osMEJBQVUsQ0FBVjtBQUNBO0FBQ0EscUJBQUssSUFBSSxLQUFJLENBQWIsRUFBZ0IsTUFBSyxLQUFLLEdBQUwsQ0FBUyxLQUFULElBQWtCLENBQXZDLEVBQTBDLElBQTFDLEVBQStDO0FBQzNDLCtCQUFXLEtBQUssY0FBTCxDQUFvQixPQUFPLENBQVAsR0FBVyxFQUEvQixDQUFYO0FBQ0g7O0FBRUQscUJBQUssV0FBTCxDQUFpQixLQUFqQixJQUEwQixPQUExQjtBQUNIO0FBQ0o7O0FBRUQsWUFBSSxLQUFLLFdBQUwsQ0FBaUIsS0FBakIsSUFBMEIsS0FBSyxjQUFMLENBQW9CLENBQXBCLENBQTlCLEVBQXNEO0FBQ2xELGlCQUFLLFdBQUwsQ0FBaUIsS0FBakIsR0FBeUIsQ0FBekI7QUFDSDs7QUFFRDtBQUNBLFlBQUksT0FBTyxhQUFYLEVBQTBCO0FBQ3RCLG9CQUFRLE1BQU0sT0FBTyxDQUFyQjtBQUNBO0FBQ0EsZ0JBQUksUUFBUSxDQUFaLEVBQWU7QUFDWCxvQkFBTSxlQUFlLENBQUMsS0FBSyxHQUFMLENBQVMsS0FBVCxJQUFrQixDQUFuQixJQUF3QixLQUFLLFdBQUwsRUFBN0M7QUFDQSwwQkFBVSxLQUFLLFdBQUwsQ0FBaUIsR0FBakIsR0FBdUIsWUFBakM7O0FBRUEsb0JBQUksVUFBVSxLQUFLLFVBQUwsQ0FBZ0IsZ0JBQWhCLEdBQW1DLENBQWpELEVBQW9EO0FBQ2hELHlCQUFLLFdBQUwsQ0FBaUIsS0FBakIsSUFBMEIsT0FBMUI7QUFDSCxpQkFGRCxNQUVPO0FBQ0gsNEJBQVEsTUFBTSxPQUFPLENBQXJCOztBQUVBLHdCQUFNLGdCQUFlLENBQUMsS0FBSyxHQUFMLENBQVMsS0FBVCxJQUFrQixDQUFuQixJQUF3QixLQUFLLFdBQUwsRUFBN0M7QUFDQSw4QkFBVSxLQUFLLFdBQUwsQ0FBaUIsR0FBakIsR0FBdUIsYUFBakM7QUFDQSx5QkFBSyxXQUFMLENBQWlCLEtBQWpCLElBQTBCLE9BQTFCO0FBQ0g7QUFDSjs7QUFFRCxvQkFBUSxNQUFNLE9BQU8sQ0FBckI7QUFDQSxnQkFBSSxTQUFTLENBQWIsRUFBZ0I7QUFDWixvQkFBTSxpQkFBZSxDQUFDLFFBQVEsQ0FBVCxJQUFjLEtBQUssV0FBTCxFQUFuQztBQUNBLDBCQUFVLEtBQUssV0FBTCxDQUFpQixHQUFqQixHQUF1QixjQUFqQzs7QUFFQSxvQkFBSSxVQUFVLEtBQUssVUFBTCxDQUFnQixnQkFBaEIsR0FBbUMsQ0FBakQsRUFBb0Q7QUFDaEQseUJBQUssV0FBTCxDQUFpQixLQUFqQixJQUEwQixPQUExQjtBQUNILGlCQUZELE1BRU87QUFDSCw0QkFBUSxPQUFPLENBQVAsR0FBVyxHQUFuQjs7QUFFQSx3QkFBTSxpQkFBZSxDQUFDLEtBQUssR0FBTCxDQUFTLEtBQVQsSUFBa0IsQ0FBbkIsSUFBd0IsS0FBSyxXQUFMLEVBQTdDO0FBQ0EsOEJBQVUsS0FBSyxXQUFMLENBQWlCLEdBQWpCLEdBQXVCLGNBQWpDO0FBQ0EseUJBQUssV0FBTCxDQUFpQixLQUFqQixJQUEwQixPQUExQjtBQUNIO0FBQ0o7QUFDSjs7QUFFRCxZQUFJLEtBQUssV0FBTCxDQUFpQixLQUFqQixJQUEwQixLQUFLLFlBQUwsQ0FBa0IsQ0FBbEIsQ0FBOUIsRUFBb0Q7QUFDaEQsaUJBQUssV0FBTCxDQUFpQixLQUFqQixHQUF5QixDQUF6QjtBQUNIO0FBQ0osS0E1S1c7O0FBOEtaLHNDQUFrQywwQ0FBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQzdDLGFBQUssbUJBQUwsQ0FBeUIsQ0FBekIsRUFBNEIsQ0FBNUI7QUFDQSxhQUFLLFVBQUwsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBc0IsSUFBdEI7QUFDSCxLQWpMVzs7QUFtTFo7Ozs7Ozs7QUFPQSwyQkFBdUIsK0JBQVMsV0FBVCxFQUFzQixJQUF0QixFQUE0QixFQUE1QixFQUFnQyxhQUFoQyxFQUErQztBQUNsRSxZQUFNLFNBQVMsS0FBSyxLQUFMLENBQVcsQ0FBQyxPQUFPLEVBQVIsSUFBYyxDQUF6QixDQUFmOztBQUVBLFlBQUksV0FBVyxJQUFYLElBQW1CLFdBQVcsRUFBbEMsRUFBc0M7QUFDbEMsbUJBQU8sSUFBUDtBQUNIOztBQUVELFlBQU0sZ0JBQWdCLGNBQWMsSUFBZCxDQUFtQixLQUFLLFFBQXhCLEVBQWtDLE1BQWxDLENBQXRCOztBQUVBLFlBQUksZ0JBQWdCLFdBQXBCLEVBQWlDO0FBQzdCLG1CQUFPLEtBQUsscUJBQUwsQ0FBMkIsV0FBM0IsRUFBd0MsSUFBeEMsRUFBOEMsTUFBOUMsRUFBc0QsYUFBdEQsQ0FBUDtBQUNILFNBRkQsTUFFTztBQUNILG1CQUFPLEtBQUsscUJBQUwsQ0FBMkIsV0FBM0IsRUFBd0MsTUFBeEMsRUFBZ0QsRUFBaEQsRUFBb0QsYUFBcEQsQ0FBUDtBQUNIO0FBQ0osS0F4TVc7O0FBME1aOzs7OztBQUtBLHFCQUFpQix5QkFBUyxRQUFULEVBQW1CO0FBQUE7O0FBQ2hDLG1CQUFXLEtBQUssR0FBTCxDQUFTLEtBQUssV0FBTCxDQUFpQixLQUFqQixDQUF1QixHQUFoQyxFQUFxQyxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksS0FBSyxLQUFMLENBQVcsUUFBWCxDQUFaLENBQXJDLENBQVg7QUFDQSxZQUFJLGFBQWEsS0FBSyxZQUF0QixFQUFvQztBQUNoQyxpQkFBSyxRQUFMLENBQWMsa0JBQWQsQ0FBaUMsUUFBakM7QUFDQSxpQkFBSyxRQUFMLENBQWMsT0FBZDtBQUNBLGdCQUFNLE9BQU8sS0FBSyxZQUFsQjs7QUFFQSxpQkFBSyxZQUFMLEdBQW9CLFFBQXBCO0FBQ0EsaUJBQUssOEJBQUw7QUFDQSx1QkFBVyxZQUFLO0FBQ1o7QUFDQSxzQkFBSyxlQUFMLENBQXFCLGNBQXJCLEVBQXFDLElBQXJDLEVBQTJDLFFBQTNDO0FBQ0gsYUFIRDtBQUlIO0FBQ0Q7QUFDQSxZQUFJLEtBQUssV0FBTCxDQUFpQixLQUFqQixLQUEyQixRQUEvQixFQUF5QztBQUNyQyxpQkFBSyxXQUFMLENBQWlCLEtBQWpCLEdBQXlCLFFBQXpCO0FBQ0g7QUFDSixLQWpPVzs7QUFtT1o7Ozs7QUFJQSxxQkFBaUIsMkJBQVc7QUFDeEIsZUFBTyxLQUFLLHFCQUFMLENBQTJCLEtBQUssWUFBaEMsRUFBOEMsQ0FBOUMsRUFBaUQsS0FBSyxXQUFMLEVBQWpELEVBQXFFLEtBQUssUUFBTCxDQUFjLGFBQW5GLENBQVA7QUFDSCxLQXpPVzs7QUEyT1o7Ozs7O0FBS0EscUJBQWlCLHlCQUFTLFFBQVQsRUFBbUI7QUFDaEMsWUFBTSxPQUFPLElBQWI7QUFDQSxtQkFBVyxLQUFLLEdBQUwsQ0FBUyxLQUFLLFdBQUwsQ0FBaUIsS0FBakIsQ0FBdUIsR0FBaEMsRUFBcUMsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLEtBQUssS0FBTCxDQUFXLFFBQVgsQ0FBWixDQUFyQyxDQUFYO0FBQ0EsWUFBSSxhQUFhLEtBQUssWUFBdEIsRUFBb0M7QUFDaEMsaUJBQUssUUFBTCxDQUFjLGtCQUFkLENBQWlDLFFBQWpDO0FBQ0EsaUJBQUssUUFBTCxDQUFjLE9BQWQ7QUFDQSxnQkFBTSxPQUFPLEtBQUssWUFBbEI7QUFDQSxpQkFBSyxZQUFMLEdBQW9CLFFBQXBCO0FBQ0EsaUJBQUssOEJBQUw7O0FBRUEsZ0JBQUksS0FBSyxXQUFULEVBQXNCO0FBQ2xCLHFCQUFLLFdBQUwsQ0FBaUIsS0FBakIsR0FBeUIsUUFBekI7QUFDSDs7QUFFRCx1QkFBVyxZQUFXO0FBQ2xCO0FBQ0EscUJBQUssZUFBTCxDQUFxQixjQUFyQixFQUFxQyxJQUFyQyxFQUEyQyxRQUEzQztBQUNBO0FBQ0gsYUFKRDtBQUtIO0FBQ0Q7QUFDQSxZQUFJLEtBQUssV0FBTCxDQUFpQixLQUFqQixLQUEyQixRQUEvQixFQUF5QztBQUNyQyxpQkFBSyxXQUFMLENBQWlCLEtBQWpCLEdBQXlCLFFBQXpCO0FBQ0g7QUFDSixLQXhRVzs7QUEwUVo7Ozs7QUFJQSxxQkFBaUIsMkJBQVc7QUFDeEIsZUFBTyxLQUFLLHFCQUFMLENBQTJCLEtBQUssWUFBaEMsRUFBOEMsQ0FBOUMsRUFBaUQsS0FBSyxjQUFMLEVBQWpELEVBQXdFLEtBQUssUUFBTCxDQUFjLGVBQXRGLENBQVA7QUFDSCxLQWhSVzs7QUFrUlo7Ozs7QUFJQSxvQkFBZ0IsMEJBQVc7QUFDdkIsWUFBSSxLQUFLLFdBQUwsSUFBb0IsS0FBSyxXQUE3QixFQUEwQztBQUN0QztBQUNIOztBQUVELFlBQU0sT0FBTyxJQUFiOztBQUVBLFlBQU0sVUFBVSxJQUFJLFNBQUosQ0FBYztBQUMxQix5QkFBYSxZQURhO0FBRTFCLG9DQUF3QixnQ0FBUyxTQUFULEVBQW9CO0FBQ3hDLHFCQUFLLFVBQUwsQ0FBZ0Isa0JBQWhCLEdBQXFDLFlBQy9CLE9BQU8sT0FBTyxnQkFBUCxDQUF3QixLQUFLLFFBQTdCLEVBQXVDLE1BQXZDLENBQThDLE9BQTlDLENBQXNELElBQXRELEVBQTRELEVBQTVELENBQVAsQ0FEK0IsR0FFL0IsQ0FGTjtBQUdBLHFCQUFLLE1BQUwsQ0FBWSxNQUFaLENBQW1CLEtBQW5CO0FBQ0gsYUFQeUI7QUFRMUIsc0JBQVUsS0FBSyxlQUFMLENBQXFCLElBQXJCLENBQTBCLElBQTFCLENBUmdCO0FBUzFCLDJDQUErQixLQUFLLEdBVFY7QUFVMUIsb0JBQVE7QUFDSixvQkFBSSxLQUFLLFFBQUwsQ0FBYyxJQUFkLENBQW1CLElBQW5CLENBREE7QUFFSixzQkFBTSxLQUFLLFNBQUwsQ0FBZSxJQUFmLENBQW9CLElBQXBCO0FBRkY7QUFWa0IsU0FBZCxDQUFoQjs7QUFnQkEsWUFBTSxVQUFVLElBQUksU0FBSixDQUFjO0FBQzFCLHlCQUFhLFVBRGE7QUFFMUIsb0NBQXdCLGdDQUFTLFNBQVQsRUFBb0I7QUFDeEMscUJBQUssVUFBTCxDQUFnQixpQkFBaEIsR0FBb0MsWUFDOUIsT0FBTyxPQUFPLGdCQUFQLENBQXdCLEtBQUssUUFBN0IsRUFBdUMsS0FBdkMsQ0FBNkMsT0FBN0MsQ0FBcUQsSUFBckQsRUFBMkQsRUFBM0QsQ0FBUCxDQUQ4QixHQUU5QixDQUZOO0FBR0EscUJBQUssTUFBTCxDQUFZLE1BQVosQ0FBbUIsS0FBbkI7QUFDSCxhQVB5QjtBQVExQixzQkFBVSxLQUFLLGVBQUwsQ0FBcUIsSUFBckIsQ0FBMEIsSUFBMUIsQ0FSZ0I7QUFTMUIsb0JBQVE7QUFDSixvQkFBSSxLQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWlCLElBQWpCLENBREE7QUFFSixzQkFBTSxLQUFLLFFBQUwsQ0FBYyxJQUFkLENBQW1CLElBQW5CO0FBRkY7QUFUa0IsU0FBZCxDQUFoQjs7QUFlQSxhQUFLLFdBQUwsR0FBbUIsT0FBbkI7QUFDQSxhQUFLLFdBQUwsR0FBbUIsT0FBbkI7O0FBRUEsWUFBTSxVQUFVLEtBQUssVUFBTCxDQUFnQixxQkFBaEM7QUFDQSxZQUFNLFVBQVUsS0FBSyxVQUFMLENBQWdCLHFCQUFoQzs7QUFFQSxZQUFJLFdBQVcsWUFBWSxFQUEzQixFQUErQjtBQUMzQixpQkFBSyxXQUFMLENBQWlCLFdBQWpCLEdBQStCLE9BQS9CO0FBQ0g7O0FBRUQsWUFBSSxXQUFXLFlBQVksRUFBM0IsRUFBK0I7QUFDM0IsaUJBQUssV0FBTCxDQUFpQixXQUFqQixHQUErQixPQUEvQjtBQUNIOztBQUVELGFBQUssR0FBTCxDQUFTLFdBQVQsQ0FBcUIsUUFBUSxRQUE3QjtBQUNBLGFBQUssR0FBTCxDQUFTLFdBQVQsQ0FBcUIsUUFBUSxRQUE3Qjs7QUFFQSxhQUFLLGtDQUFMO0FBQ0gsS0E5VVc7O0FBZ1ZaLHVCQUFtQiw2QkFBVztBQUMxQixZQUFJLEtBQUssV0FBVCxFQUFzQjtBQUNsQixpQkFBSyxXQUFMLENBQWlCLE1BQWpCO0FBQ0EsbUJBQU8sS0FBSyxXQUFaO0FBQ0g7QUFDRCxZQUFJLEtBQUssV0FBVCxFQUFzQjtBQUNsQixpQkFBSyxXQUFMLENBQWlCLE1BQWpCO0FBQ0EsbUJBQU8sS0FBSyxXQUFaO0FBQ0g7QUFDSixLQXpWVzs7QUEyVlosd0NBQW9DLDhDQUFXO0FBQzNDLFlBQUksS0FBSyxXQUFULEVBQXNCO0FBQ2xCLGlCQUFLLFdBQUwsQ0FDSyxpQkFETCxDQUN1QixTQUR2QixFQUNrQyxLQUFLLHVCQUFMLEVBRGxDLEVBRUssaUJBRkwsQ0FFdUIsVUFGdkIsRUFFbUMsS0FBSyx3QkFBTCxLQUFrQyxDQUZyRSxFQUdLLE1BSEwsQ0FHWSxJQUhaLEVBR2tCLElBSGxCLEVBR3dCLEtBQUssbUJBQUwsRUFIeEI7O0FBS0EsaUJBQUssV0FBTCxDQUFpQixLQUFqQixHQUF5QixLQUFLLFVBQUwsQ0FBZ0IsZUFBekM7QUFDQSxpQkFBSyxXQUFMLENBQWlCLFVBQWpCLEdBQThCLEtBQUssVUFBTCxDQUFnQixvQkFBOUM7QUFDQSxpQkFBSyxXQUFMLENBQWlCLFVBQWpCLEdBQThCLEtBQUssVUFBTCxDQUFnQixvQkFBOUM7QUFDSDtBQUNELFlBQUksS0FBSyxXQUFULEVBQXNCO0FBQ2xCLGlCQUFLLFdBQUwsQ0FDSyxpQkFETCxDQUN1QixTQUR2QixFQUNrQyxLQUFLLHNCQUFMLEVBRGxDLEVBRUssaUJBRkwsQ0FFdUIsVUFGdkIsRUFFbUMsS0FBSyx5QkFBTCxLQUFtQyxDQUZ0RSxFQUdLLE1BSEwsQ0FHWSxJQUhaLEVBR2tCLElBSGxCLEVBR3dCLEtBQUssb0JBQUwsRUFIeEI7O0FBS0EsaUJBQUssV0FBTCxDQUFpQixLQUFqQixHQUF5QixLQUFLLFVBQUwsQ0FBZ0IsZUFBekM7QUFDQSxpQkFBSyxXQUFMLENBQWlCLFVBQWpCLEdBQThCLEtBQUssVUFBTCxDQUFnQixvQkFBOUM7QUFDQSxpQkFBSyxXQUFMLENBQWlCLFVBQWpCLEdBQThCLEtBQUssVUFBTCxDQUFnQixvQkFBOUM7QUFDSDtBQUNKLEtBaFhXOztBQWtYWiw2QkFBeUIsbUNBQVc7QUFDaEMsWUFBSSxNQUFNLENBQVY7QUFDQSxZQUFNLGlCQUFpQixLQUFLLFFBQUwsQ0FBYyxjQUFyQztBQUNBLGVBQU8sS0FBSyxVQUFMLENBQWdCLFVBQWhCLEdBQTZCLEtBQUssVUFBTCxDQUFnQixjQUE3QyxHQUE4RCxDQUFyRTtBQUNBLGVBQU8sS0FBSyxVQUFMLENBQWdCLGNBQWhCLEdBQWlDLEtBQUssVUFBTCxDQUFnQixjQUFqRCxHQUFrRSxDQUF6RTs7QUFFQSxZQUFNLGVBQWUsZUFBZSxLQUFLLFFBQUwsQ0FBYyxjQUE3QixDQUFyQjtBQUNBLGVBQU8sS0FBSyxVQUFMLENBQWdCLGdCQUFoQixJQUFvQyxZQUFwQyxHQUNELGFBQWEsS0FEWixHQUVELENBRk47O0FBSUEsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssVUFBTCxDQUFnQixnQkFBcEMsRUFBc0QsR0FBdEQsRUFBMkQ7QUFDdkQsZ0JBQUksTUFBTSxLQUFLLFFBQUwsQ0FBYyxjQUF4QixFQUF3QztBQUNwQyx1QkFBTyxLQUFLLGNBQUwsQ0FBb0IsQ0FBcEIsQ0FBUDtBQUNIO0FBQ0o7O0FBRUQsZUFBTyxLQUFLLFVBQUwsQ0FBZ0IsZ0JBQWhCLEdBQW1DLEtBQUssVUFBTCxDQUFnQixnQkFBbkQsR0FBc0UsQ0FBN0U7O0FBRUEsZUFBTyxHQUFQO0FBQ0gsS0F0WVc7O0FBd1laLDhCQUEwQixvQ0FBVztBQUNqQyxZQUFJLE1BQU0sQ0FBQyxDQUFYOztBQUVBLFlBQUksS0FBSyxVQUFMLENBQWdCLGVBQWhCLElBQW1DLEtBQUssVUFBTCxDQUFnQixlQUFoQixDQUFnQyxLQUF2RSxFQUE4RTtBQUMxRSxtQkFBTyxLQUFLLFVBQUwsQ0FBZ0IsZUFBaEIsQ0FBZ0MsS0FBdkM7QUFDSDs7QUFFRCxlQUFPLEdBQVA7QUFDSCxLQWhaVzs7QUFrWlosNEJBQXdCLGtDQUFXO0FBQy9CLFlBQUksWUFBSjtBQUNBLFlBQU0sV0FBVyxLQUFLLFVBQUwsQ0FBZ0IsYUFBakM7O0FBRUEsWUFBSSxNQUFNLEtBQUssUUFBTCxDQUFjLFdBQWQsQ0FBMEIsUUFBMUIsQ0FBVjtBQUNBLFlBQUksQ0FBQyxHQUFMLEVBQVU7QUFDTixrQkFBTSxLQUFLLFFBQUwsQ0FBYyxXQUFkLENBQTBCLENBQTFCLENBQU47QUFDSDtBQUNELGNBQU0sTUFBTSxJQUFJLE1BQVYsR0FBbUIsQ0FBekI7O0FBRUEsZUFBTyxLQUFLLFVBQUwsQ0FBZ0IsVUFBaEIsR0FBNkIsS0FBSyxVQUFMLENBQWdCLGNBQTdDLEdBQThELENBQXJFOztBQUVBLGVBQU8sS0FBSyxVQUFMLENBQWdCLGFBQWhCLEdBQWdDLEtBQUssVUFBTCxDQUFnQixnQkFBaEQsR0FBbUUsQ0FBMUU7O0FBRUEsZUFBTyxLQUFLLFVBQUwsQ0FBZ0IsYUFBaEIsR0FBZ0MsS0FBSyxVQUFMLENBQWdCLGdCQUFoRCxHQUFtRSxDQUExRTs7QUFFQTtBQUNBLGVBQU8sQ0FBUDs7QUFFQSxlQUFPLEdBQVA7QUFDSCxLQXRhVzs7QUF3YVosK0JBQTJCLHFDQUFXO0FBQ2xDLFlBQUksTUFBTSxDQUFDLENBQVg7O0FBRUEsWUFBSSxLQUFLLFVBQUwsQ0FBZ0IsZUFBaEIsSUFBbUMsS0FBSyxVQUFMLENBQWdCLGVBQWhCLENBQWdDLE1BQXZFLEVBQStFO0FBQzNFLG1CQUFPLEtBQUssVUFBTCxDQUFnQixlQUFoQixDQUFnQyxNQUF2QztBQUNIOztBQUVELGVBQU8sR0FBUDtBQUNILEtBaGJXOztBQWtiWix5QkFBcUIsK0JBQVc7QUFDNUIsWUFBSSxNQUFNLENBQVY7O0FBRUEsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixLQUFLLEtBQUssY0FBTCxFQUFyQixFQUE0QyxHQUE1QyxFQUFnRDtBQUM1QyxtQkFBTyxLQUFLLGNBQUwsQ0FBb0IsQ0FBcEIsQ0FBUDtBQUNIOztBQUVELGVBQU8sR0FBUDtBQUNILEtBMWJXO0FBMmJaLDBCQUFzQixnQ0FBVztBQUM3QixZQUFJLE1BQU0sQ0FBVjs7QUFFQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLEtBQUssS0FBSyxXQUFMLEVBQXJCLEVBQXlDLEdBQXpDLEVBQTZDO0FBQ3pDLG1CQUFPLEtBQUssWUFBTCxDQUFrQixDQUFsQixDQUFQO0FBQ0g7O0FBRUQsZUFBTyxHQUFQO0FBQ0gsS0FuY1c7QUFvY1o7Ozs7QUFJQSx5QkFBcUIsNkJBQVMsR0FBVCxFQUFjO0FBQy9CLGFBQUssV0FBTCxDQUFpQixLQUFqQixHQUF5QjtBQUNyQixpQkFBSyxDQURnQjtBQUVyQixpQkFBSztBQUZnQixTQUF6QjtBQUlILEtBN2NXOztBQStjWix5QkFBcUIsNkJBQVMsR0FBVCxFQUFjO0FBQy9CLGFBQUssV0FBTCxDQUFpQixLQUFqQixHQUF5QjtBQUNyQixpQkFBSyxDQURnQjtBQUVyQixpQkFBSztBQUZnQixTQUF6QjtBQUlILEtBcGRXOztBQXNkWixvQ0FBZ0MsMENBQVc7QUFDdkMsWUFDSSxLQUFLLFlBQUwsS0FBc0IsS0FBSyxrQkFBM0IsSUFDQSxLQUFLLFlBQUwsS0FBc0IsS0FBSyxrQkFGL0IsRUFHRTtBQUNFLGlCQUFLLGtCQUFMLEdBQTBCLEtBQUssWUFBL0I7QUFDQSxpQkFBSyxrQkFBTCxHQUEwQixLQUFLLFlBQS9COztBQUVBLGdCQUFJLEtBQUssVUFBVCxFQUFxQjtBQUNqQixxQkFBSyxVQUFMLENBQWdCLDhCQUFoQjtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFLLGtCQUFMO0FBQ0g7QUFDSixLQS9lVzs7QUFpZlo7Ozs7O0FBS0Esb0NBQWdDLDBDQUFXO0FBQ3ZDLFlBQU0sYUFBYSxLQUFLLGNBQUwsRUFBbkI7QUFDQSxZQUFNLFVBQVUsS0FBSyxXQUFMLEVBQWhCOztBQUVBLFlBQU0sU0FBUyxLQUFLLFNBQUwsRUFBZjtBQUNBLFlBQUksQ0FBQyxNQUFMLEVBQWE7QUFDVDtBQUNIOztBQUVELFlBQU0sa0JBQWtCLE9BQU8sS0FBUCxHQUFlLEtBQUssUUFBTCxDQUFjLHVCQUFkLEVBQXZDO0FBQ0EsYUFDSSxJQUFJLGVBQWUsQ0FBbkIsRUFBc0Isc0JBQXNCLENBRGhELEVBRUksc0JBQXNCLFVBQXRCLElBQW9DLGVBQWUsZUFGdkQsRUFHSSxxQkFISixFQUlFO0FBQ0UsNEJBQWdCLEtBQUssY0FBTCxDQUFvQixhQUFhLG1CQUFiLEdBQW1DLENBQXZELENBQWhCO0FBQ0g7QUFDRCxZQUFJLGVBQWUsZUFBbkIsRUFBb0M7QUFDaEM7QUFDSDs7QUFFRCxZQUFNLG1CQUFtQixLQUFLLFFBQUwsQ0FBYyxzQkFBZCxFQUF6QjtBQUNBLGFBQ0ksSUFBSSxhQUFhLENBQWpCLEVBQW9CLG1CQUFtQixDQUQzQyxFQUVJLG1CQUFtQixPQUFuQixJQUE4QixhQUFhLGdCQUYvQyxFQUdJLGtCQUhKLEVBSUU7QUFDRSwwQkFBYyxLQUFLLFlBQUwsQ0FBa0IsVUFBVSxnQkFBVixHQUE2QixDQUEvQyxDQUFkO0FBQ0g7QUFDRCxZQUFJLGFBQWEsZ0JBQWpCLEVBQW1DO0FBQy9CO0FBQ0g7O0FBRUQ7QUFDQSxZQUFJLEtBQUssV0FBVCxFQUFzQjtBQUNsQixnQkFBSSxPQUFPLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxLQUFLLFFBQUwsQ0FBYyxlQUFkLENBQThCLEtBQUssUUFBTCxDQUFjLG9CQUFkLEtBQXVDLG1CQUF2QyxHQUE2RCxDQUEzRixJQUFnRyxLQUFLLFFBQUwsQ0FBYyxvQkFBZCxFQUE1RyxDQUFYO0FBQ0Esb0JBQVEsS0FBSyxRQUFMLENBQWMsY0FBZCxDQUE2QixLQUFLLFFBQUwsQ0FBYyxvQkFBZCxFQUE3QixDQUFSO0FBQ0EsaUJBQUssbUJBQUwsQ0FBeUIsSUFBekI7QUFDQSxpQkFBSyxlQUFMLENBQXFCLEtBQUssR0FBTCxDQUFTLEtBQUssWUFBZCxFQUE0QixJQUE1QixDQUFyQjtBQUNIO0FBQ0QsWUFBSSxLQUFLLFdBQVQsRUFBc0I7QUFDbEIsZ0JBQU0sT0FBTyxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksS0FBSyxRQUFMLENBQWMsYUFBZCxDQUE0QixLQUFLLFFBQUwsQ0FBYyxXQUFkLEtBQThCLGdCQUE5QixHQUFpRCxDQUE3RSxJQUFrRixLQUFLLFFBQUwsQ0FBYyxrQkFBZCxFQUE5RixDQUFiLENBRGtCLENBQzhIO0FBQ2hKLGlCQUFLLG1CQUFMLENBQXlCLElBQXpCO0FBQ0EsaUJBQUssZUFBTCxDQUFxQixLQUFLLEdBQUwsQ0FBUyxLQUFLLFlBQWQsRUFBNEIsSUFBNUIsQ0FBckI7QUFDSDs7QUFFRCxhQUFLLGtCQUFMOztBQUVBO0FBQ0EsbUJBQVcsS0FBSyxrQ0FBTCxDQUF3QyxJQUF4QyxDQUE2QyxJQUE3QyxDQUFYO0FBQ0gsS0F4aUJXOztBQTBpQlo7Ozs7O0FBS0EsWUFBUSxrQkFBVztBQUNmLFlBQU0sU0FBUyxLQUFLLFFBQUwsQ0FBYyxZQUFkLEVBQWY7QUFDQSxZQUFNLGVBQWUsS0FBSyxRQUFMLENBQWMsYUFBZCxDQUE0QixNQUE1QixDQUFyQjtBQUNBLGFBQUssZUFBTCxDQUFxQixZQUFyQjtBQUNBLGVBQU8sWUFBUDtBQUNILEtBcGpCVzs7QUFzakJaOzs7OztBQUtBLGNBQVUsb0JBQVc7QUFDakIsWUFBTSxTQUFTLEtBQUssUUFBTCxDQUFjLGNBQWQsRUFBZjtBQUNBLFlBQU0sZUFBZSxLQUFLLFFBQUwsQ0FBYyxhQUFkLENBQTRCLE1BQTVCLENBQXJCO0FBQ0EsYUFBSyxlQUFMLENBQXFCLFlBQXJCO0FBQ0EsZUFBTyxZQUFQO0FBQ0gsS0Foa0JXOztBQWtrQlo7Ozs7O0FBS0EsY0FBVSxvQkFBVztBQUNqQixZQUFNLFNBQVMsS0FBSyxTQUFMLEVBQWY7QUFDQSxZQUFNLGdCQUFnQixLQUFLLFFBQUwsQ0FBYyxrQkFBZCxFQUF0QjtBQUNBLFlBQU0sa0JBQWtCLE9BQU8sS0FBUCxHQUFlLEtBQUssUUFBTCxDQUFjLHVCQUFkLEVBQXZDO0FBQ0EsWUFBTSxZQUFZLGdCQUFnQixlQUFsQztBQUNBLGFBQUssZUFBTCxDQUFxQixTQUFyQjtBQUNBLGVBQU8sU0FBUDtBQUNILEtBOWtCVzs7QUFnbEJaOzs7OztBQUtBLGVBQVcscUJBQVc7QUFDbEIsWUFBTSxTQUFTLEtBQUssU0FBTCxFQUFmO0FBQ0EsWUFBTSxnQkFBZ0IsS0FBSyxRQUFMLENBQWMsa0JBQWQsRUFBdEI7QUFDQSxZQUFNLGtCQUFrQixPQUFPLEtBQVAsR0FBZSxLQUFLLFFBQUwsQ0FBYyx1QkFBZCxFQUF2QztBQUNBLFlBQU0sYUFBYSxnQkFBZ0IsZUFBbkM7QUFDQSxhQUFLLGVBQUwsQ0FBcUIsVUFBckI7QUFDQSxlQUFPLFVBQVA7QUFDSDtBQTVsQlcsQ0FBaEI7OztBQ1ZBOztBQUVBOzs7O0FBRUEsSUFBSSxZQUFZLFFBQVEsYUFBUixFQUF1QixTQUF2Qzs7QUFFQTs7OztBQUlBLFFBQVEsS0FBUixHQUFnQjtBQUNaLHlCQUFxQiwrQkFBVztBQUM1QixZQUFJLE9BQU8sSUFBWDs7QUFFQTs7OztBQUlBLGFBQUssc0JBQUwsR0FBOEI7QUFDMUIsZ0JBQUksSUFBSixHQUFXO0FBQ1AsdUJBQU8sS0FBSyxlQUFMLEVBQVA7QUFDSCxhQUh5QjtBQUkxQixnQkFBSSxPQUFKLEdBQWM7QUFDVix1QkFBTyxLQUFLLGtCQUFMLEVBQVA7QUFDSCxhQU55QjtBQU8xQixnQkFBSSxVQUFKLEdBQWlCO0FBQ2IsdUJBQU8sS0FBSyxjQUFMLENBQW9CLGFBQXBCLEVBQVA7QUFDSDtBQVR5QixTQUE5Qjs7QUFZQTs7Ozs7QUFLQSxhQUFLLGdDQUFMLEdBQXdDLE9BQU8seUJBQVAsQ0FBaUMsS0FBSyxzQkFBdEMsQ0FBeEM7QUFDSCxLQTFCVzs7QUE0Qlo7Ozs7QUFJQSxtQkFBZSx5QkFBVztBQUN0QixZQUFJLENBQUMsS0FBSyxpQkFBVixFQUE2QjtBQUN6QixtQkFEeUIsQ0FDakI7QUFDWDtBQUNELGVBQU8sS0FBSyxjQUFMLENBQW9CLGFBQXBCLEVBQVA7QUFDSCxLQXJDVzs7QUF1Q1o7Ozs7QUFJQSx1QkFBbUIsNkJBQVc7QUFDMUIsWUFBSSxLQUFLLEtBQUssY0FBZDtBQUNBLFlBQUksR0FBRyxhQUFILEVBQUosRUFBd0I7QUFDcEIsbUJBQU8sS0FBSyx1QkFBTCxDQUE2QixLQUFLLGtCQUFMLEVBQTdCLENBQVA7QUFDSCxTQUZELE1BRU8sSUFBSSxHQUFHLGdCQUFILEVBQUosRUFBMkI7QUFDOUIsbUJBQU8sS0FBSyx1QkFBTCxDQUE2QixLQUFLLHFCQUFMLEVBQTdCLENBQVA7QUFDSCxTQUZNLE1BRUEsSUFBSSxHQUFHLG1CQUFILEVBQUosRUFBOEI7QUFDakMsbUJBQU8sS0FBSyx1QkFBTCxDQUE2QixLQUFLLHdCQUFMLEVBQTdCLENBQVA7QUFDSDtBQUNKLEtBcERXOztBQXNEWixrQ0FBOEIsc0NBQVMsS0FBVCxFQUFnQjtBQUMxQyw0SkFNRSxNQUFNLGNBTlIsaUJBTWtDLE1BQU0sY0FOeEMsc0JBT0ssTUFBTSxrQkFQWCxzQkFRRyxNQUFNLFdBUlQsV0FRMEIsTUFBTSxlQVJoQyw0QkFXQyxNQUFNLFNBWFAsNERBZUEsTUFBTSxvQkFmTiwrQkFrQkEsTUFBTSxxQkFsQk4sa0JBbUJDLE1BQU0sc0JBbkJQLDBCQW9CUyxNQUFNLDJCQXBCZixtQ0F1QkMsTUFBTSxxQkF2QlAsaUJBd0JBLE1BQU0sb0JBeEJOLHlCQXlCUSxNQUFNLDBCQXpCZCwwQ0E0QlksTUFBTSxjQTVCbEI7QUErQkgsS0F0Rlc7O0FBd0ZaLDZCQUF5QixpQ0FBUyxVQUFULEVBQXFCO0FBQzFDLFlBQUksT0FBTyxFQUFYO0FBQ0EsWUFBSSxPQUFPLEVBQVg7O0FBRUE7QUFDQSxZQUFJLFdBQVcsTUFBZixFQUF1Qjs7QUFFbkIsZ0JBQU0sUUFBUSxLQUFLLFVBQW5COztBQUVBLG1CQUFPLEtBQUssNEJBQUwsQ0FBa0MsS0FBbEMsSUFBMkMsU0FBbEQ7O0FBRUEsZ0JBQUksUUFBUSxXQUFXLE1BQXZCO0FBQUEsZ0JBQ0ksU0FBUyxXQUFXLENBQVgsRUFBYyxNQUQzQjtBQUFBLGdCQUVJLFVBQVUsUUFBUSxDQUZ0Qjs7QUFHSTtBQUNBLHdDQUE2QixTQUFTLENBQVQsR0FBYSxJQUFiLEdBQW9CLEVBSnJEOztBQU1BLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksTUFBcEIsRUFBNEIsR0FBNUIsRUFBaUM7QUFDN0IscUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFwQixFQUEyQixHQUEzQixFQUFnQztBQUM1Qix3QkFBTSxNQUFNLFdBQVcsQ0FBWCxFQUFjLENBQWQsQ0FBWjs7QUFFQSx3QkFBTSxRQUFRLFFBQU8sR0FBUCx5Q0FBTyxHQUFQLE9BQWUsUUFBZixHQUEwQixJQUFJLElBQTlCLEdBQXFDLEdBQW5EO0FBQ0EsNEJBQVEsQ0FBQyxTQUFTLEVBQVYsS0FBaUIsSUFBSSxPQUFKLEdBQWMsSUFBZCxHQUFxQix5QkFBdEMsQ0FBUjs7QUFFQSx3QkFBSSxNQUFNLENBQVYsRUFBYTtBQUNULGdDQUFRLE1BQVI7QUFDSDtBQUNELHdCQUFNLFFBQVEsUUFBTyxHQUFQLHlDQUFPLEdBQVAsT0FBZSxRQUFmLEdBQTBCLElBQUksSUFBOUIsR0FBcUMsR0FBbkQ7QUFDQSx3QkFBSSxVQUFVLFNBQWQsRUFBeUI7QUFDckIsMENBQWUsSUFBSSxPQUFKLGtCQUEwQixJQUFJLE9BQUosR0FBYyxDQUF4QyxVQUErQyxFQUE5RCxXQUFvRSxJQUFJLE9BQUosa0JBQTBCLElBQUksT0FBSixHQUFjLENBQXhDLFVBQStDLEVBQW5ILFdBQXlILFNBQVMsRUFBbEk7QUFDQSw0QkFBSSxNQUFNLE9BQVYsRUFBbUI7QUFDZixvQ0FBUSxPQUFSO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7O0FBRUQsb0JBQVEsVUFBUjtBQUNIOztBQUVELGVBQU8sRUFBRSxNQUFNLElBQVIsRUFBYyxNQUFNLElBQXBCLEVBQVA7QUFDSCxLQWpJVzs7QUFtSVo7Ozs7QUFJQSxxQkFBaUIsMkJBQVc7QUFDeEIsYUFBSyxjQUFMLENBQW9CLEtBQXBCLENBQTBCLEtBQUssVUFBTCxDQUFnQixpQkFBMUM7QUFDQSxhQUFLLGNBQUw7QUFDSCxLQTFJVzs7QUE0SVo7Ozs7QUFJQSw4QkFBMEIsb0NBQVc7QUFDakMsYUFBSyxjQUFMLENBQW9CLHdCQUFwQixDQUE2QyxLQUFLLFVBQUwsQ0FBZ0IsaUJBQTdEO0FBQ0gsS0FsSlc7O0FBb0paOzs7O0FBSUEsb0NBQWdDLDBDQUFXO0FBQ3ZDLGFBQUssY0FBTCxDQUFvQiw4QkFBcEI7QUFDSCxLQTFKVzs7QUE0Slo7Ozs7QUFJQSxpQ0FBNkIsdUNBQVc7QUFDcEMsYUFBSyxjQUFMLENBQW9CLDJCQUFwQjtBQUNILEtBbEtXOztBQW9LWix1QkFBbUIsNkJBQVc7QUFDMUIsYUFBSyxjQUFMLENBQW9CLGlCQUFwQjtBQUNILEtBdEtXOztBQXdLWjs7Ozs7Ozs7QUFRQSxZQUFRLGdCQUFTLEVBQVQsRUFBYSxFQUFiLEVBQWlCLEVBQWpCLEVBQXFCLEVBQXJCLEVBQXlCO0FBQzdCLFlBQUksS0FBSyxDQUFMLElBQVUsS0FBSyxDQUFuQixFQUFzQjtBQUNsQjtBQUNBO0FBQ0E7QUFDSDtBQUNELGFBQUssY0FBTCxDQUFvQixNQUFwQixDQUEyQixFQUEzQixFQUErQixFQUEvQixFQUFtQyxFQUFuQyxFQUF1QyxFQUF2QztBQUNILEtBdkxXOztBQXlMWjs7Ozs7O0FBTUEsZ0JBQVksb0JBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUN2QixlQUFPLEtBQUssY0FBTCxDQUFvQixVQUFwQixDQUErQixDQUEvQixFQUFrQyxDQUFsQyxDQUFQO0FBQ0gsS0FqTVc7O0FBbU1aOzs7OztBQUtBLHlCQUFxQiw2QkFBUyxDQUFULEVBQVk7QUFDN0IsZUFBTyxLQUFLLGNBQUwsQ0FBb0IsbUJBQXBCLENBQXdDLENBQXhDLENBQVA7QUFDSCxLQTFNVzs7QUE0TVo7Ozs7O0FBS0EsNEJBQXdCLGdDQUFTLENBQVQsRUFBWTtBQUNoQyxlQUFPLEtBQUssY0FBTCxDQUFvQixzQkFBcEIsQ0FBMkMsQ0FBM0MsQ0FBUDtBQUNILEtBbk5XOztBQXFOWjs7Ozs7QUFLQSxxQkFBaUIseUJBQVMsYUFBVCxFQUF3QjtBQUNyQyxZQUFJLFlBQVksS0FBSyxRQUFMLENBQWMsU0FBOUI7QUFBQSxZQUNJLHFCQUFxQixLQUFLLGNBQUwsQ0FBb0IsZUFBcEIsRUFEekI7QUFBQSxZQUVJLFVBQVUsV0FBVyxJQUFYLENBQWdCLElBQWhCLEVBQXNCLGFBQXRCLENBRmQ7QUFBQSxZQUdJLFNBQVMsRUFIYjs7QUFLQSxhQUFLLElBQUksSUFBSSxDQUFSLEVBQVcsSUFBSSxRQUFRLE1BQTVCLEVBQW9DLElBQUksQ0FBeEMsRUFBMkMsR0FBM0MsRUFBZ0Q7QUFDNUMsZ0JBQUksU0FBUyxRQUFRLENBQVIsQ0FBYjtBQUFBLGdCQUNJLE9BQU8sT0FBTyxPQUFPLElBQWQsSUFBc0IsSUFBSSxLQUFKLENBQVUsbUJBQW1CLE1BQTdCLENBRGpDO0FBRUEsK0JBQW1CLE9BQW5CLENBQTJCLFFBQTNCO0FBQ0g7O0FBRUQsaUJBQVMsUUFBVCxDQUFrQixnQkFBbEIsRUFBb0MsQ0FBcEMsRUFBdUM7QUFDbkMsZ0JBQUksVUFBVSxVQUFVLE1BQVYsQ0FBaUIsZ0JBQWpCLENBQWQ7QUFDQSxpQkFBSyxDQUFMLElBQVUsVUFBVSxPQUFWLEVBQW1CLE1BQW5CLENBQVY7QUFDSDs7QUFFRCxlQUFPLE1BQVA7QUFDSCxLQTVPVzs7QUE4T1o7Ozs7O0FBS0EsMkJBQXVCLCtCQUFTLGFBQVQsRUFBd0I7QUFDM0MsWUFBSSxZQUFZLEtBQUssUUFBTCxDQUFjLFNBQTlCO0FBQUEsWUFDSSxxQkFBcUIsS0FBSyxjQUFMLENBQW9CLGVBQXBCLEVBRHpCO0FBQUEsWUFFSSxVQUFVLFdBQVcsSUFBWCxDQUFnQixJQUFoQixFQUFzQixhQUF0QixDQUZkO0FBQUEsWUFHSSxTQUFTLElBQUksS0FBSixDQUFVLFFBQVEsTUFBbEIsQ0FIYjs7QUFLQSxhQUFLLElBQUksSUFBSSxDQUFSLEVBQVcsSUFBSSxRQUFRLE1BQTVCLEVBQW9DLElBQUksQ0FBeEMsRUFBMkMsR0FBM0MsRUFBZ0Q7QUFDNUMsZ0JBQUksU0FBUyxRQUFRLENBQVIsQ0FBYjtBQUNBLG1CQUFPLENBQVAsSUFBWSxJQUFJLEtBQUosQ0FBVSxtQkFBbUIsTUFBN0IsQ0FBWjtBQUNBLCtCQUFtQixPQUFuQixDQUEyQixRQUEzQjtBQUNIOztBQUVELGlCQUFTLFFBQVQsQ0FBa0IsZ0JBQWxCLEVBQW9DLENBQXBDLEVBQXVDO0FBQ25DLGdCQUFJLFVBQVUsVUFBVSxNQUFWLENBQWlCLGdCQUFqQixDQUFkO0FBQ0EsbUJBQU8sQ0FBUCxFQUFVLENBQVYsSUFBZSxVQUFVLE9BQVYsRUFBbUIsTUFBbkIsQ0FBZjtBQUNIOztBQUVELGVBQU8sTUFBUDtBQUNILEtBclFXOztBQXVRWiw4QkFBMEIsb0NBQVc7QUFDakMsWUFBSSxXQUFXLEtBQUssUUFBcEI7QUFBQSxZQUNJLFlBQVksU0FBUyxTQUR6QjtBQUFBLFlBRUksaUJBQWlCLEtBQUssaUJBQUwsRUFGckI7QUFBQSxZQUdJLHdCQUF3QixLQUFLLGtCQUFMLEVBSDVCO0FBQUEsWUFJSSxVQUFVLEtBQUssV0FBTCxFQUpkO0FBQUEsWUFLSSxTQUFTLElBQUksS0FBSixDQUFVLHNCQUFzQixNQUFoQyxDQUxiOztBQU9BLDhCQUFzQixPQUF0QixDQUE4QixVQUFTLG1CQUFULEVBQThCLENBQTlCLEVBQWlDO0FBQzNELGdCQUFJLFNBQVMsU0FBUyxlQUFULENBQXlCLG1CQUF6QixDQUFiO0FBQUEsZ0JBQ0ksU0FBUyxPQUFPLENBQVAsSUFBWSxJQUFJLEtBQUosQ0FBVSxPQUFWLENBRHpCOztBQUdBLGlCQUFLLElBQUksSUFBSSxjQUFiLEVBQTZCLElBQUksT0FBakMsRUFBMEMsR0FBMUMsRUFBK0M7QUFDM0Msb0JBQUksVUFBVSxVQUFVLE1BQVYsQ0FBaUIsQ0FBakIsQ0FBZDtBQUNBLHVCQUFPLENBQVAsSUFBWSxVQUFVLE9BQVYsRUFBbUIsTUFBbkIsQ0FBWjtBQUNIO0FBQ0osU0FSRDs7QUFVQSxlQUFPLE1BQVA7QUFDSCxLQTFSVzs7QUE0Ulosd0JBQW9CLDhCQUFXO0FBQzNCLFlBQUksV0FBVyxLQUFLLFFBQXBCO0FBQUEsWUFDSSxZQUFZLFNBQVMsU0FEekI7QUFBQSxZQUVJLGlCQUFpQixLQUFLLGlCQUFMLEVBRnJCO0FBQUEsWUFHSSx3QkFBd0IsS0FBSyxrQkFBTCxFQUg1QjtBQUFBLFlBSUksU0FBUyxFQUpiO0FBQUEsWUFLSSxXQUFXLEtBQUssV0FBTCxFQUxmOztBQU9BLDhCQUFzQixPQUF0QixDQUE4QixVQUFTLG1CQUFULEVBQThCO0FBQ3hELGdCQUFJLFNBQVMsU0FBUyxlQUFULENBQXlCLG1CQUF6QixDQUFiO0FBQUEsZ0JBQ0ksU0FBUyxPQUFPLE9BQU8sSUFBZCxJQUFzQixJQUFJLEtBQUosQ0FBVSxRQUFWLENBRG5DOztBQUdBLGlCQUFLLElBQUksSUFBSSxjQUFiLEVBQTZCLElBQUksUUFBakMsRUFBMkMsR0FBM0MsRUFBZ0Q7QUFDNUMsb0JBQUksVUFBVSxVQUFVLE1BQVYsQ0FBaUIsQ0FBakIsQ0FBZDtBQUNBLHVCQUFPLENBQVAsSUFBWSxVQUFVLE9BQVYsRUFBbUIsTUFBbkIsQ0FBWjtBQUNIO0FBQ0osU0FSRDs7QUFVQSxlQUFPLE1BQVA7QUFDSCxLQS9TVzs7QUFpVFosa0JBQWMsd0JBQVc7QUFDckIsWUFBSSxXQUFXLEtBQUssUUFBcEI7QUFBQSxZQUNJLFlBQVksU0FBUyxTQUR6QjtBQUFBLFlBRUksYUFBYSxLQUFLLGFBQUwsRUFGakI7QUFBQSxZQUdJLFFBQVEsSUFBSSxLQUFKLENBQVUsV0FBVyxNQUFyQixDQUhaOztBQUtBLG1CQUFXLE9BQVgsQ0FBbUIsT0FBbkI7O0FBRUEsaUJBQVMsT0FBVCxDQUFpQixhQUFqQixFQUFnQyxDQUFoQyxFQUFtQztBQUMvQixnQkFBSSxPQUFPLGNBQWMsYUFBZCxDQUFYO0FBQUEsZ0JBQ0ksV0FBVyxLQUFLLE1BQUwsQ0FBWSxDQUFaLEdBQWdCLENBRC9CO0FBQUEsZ0JBRUksV0FBVyxLQUFLLE1BQUwsQ0FBWSxDQUFaLEdBQWdCLENBRi9CO0FBQUEsZ0JBR0ksVUFBVSxFQUhkOztBQUtBLGlCQUFLLElBQUksSUFBSSxDQUFSLEVBQVcsSUFBSSxLQUFLLE1BQUwsQ0FBWSxDQUFoQyxFQUFtQyxJQUFJLFFBQXZDLEVBQWlELEtBQUssR0FBdEQsRUFBMkQ7QUFDdkQsb0JBQUksU0FBUyxTQUFTLGVBQVQsQ0FBeUIsQ0FBekIsQ0FBYjtBQUFBLG9CQUNJLFNBQVMsUUFBUSxPQUFPLElBQWYsSUFBdUIsSUFBSSxLQUFKLENBQVUsUUFBVixDQURwQzs7QUFHQSxxQkFBSyxJQUFJLElBQUksQ0FBUixFQUFXLElBQUksS0FBSyxNQUFMLENBQVksQ0FBaEMsRUFBbUMsSUFBSSxRQUF2QyxFQUFpRCxLQUFLLEdBQXRELEVBQTJEO0FBQ3ZELHdCQUFJLFVBQVUsVUFBVSxNQUFWLENBQWlCLENBQWpCLENBQWQ7QUFDQSwyQkFBTyxDQUFQLElBQVksVUFBVSxPQUFWLEVBQW1CLE1BQW5CLENBQVo7QUFDSDtBQUNKOztBQUVELGtCQUFNLENBQU4sSUFBVyxPQUFYO0FBQ0g7O0FBRUQsZUFBTyxLQUFQO0FBQ0gsS0E3VVc7O0FBK1VaLHdCQUFvQiw4QkFBVztBQUFBOztBQUFBLFlBQ25CLFFBRG1CLEdBQ21CLElBRG5CLENBQ25CLFFBRG1CO0FBQUEsWUFDRyxTQURILEdBQ21CLElBRG5CLENBQ1QsUUFEUyxDQUNHLFNBREg7O0FBRTNCLFlBQU0sYUFBYSxLQUFLLGFBQUwsRUFBbkI7O0FBRUEsWUFBTSxnQkFBZ0IsY0FBYyxXQUFXLFdBQVcsTUFBWCxHQUFvQixDQUEvQixDQUFkLENBQXRCOztBQUVBLFlBQU0sV0FBVyxjQUFjLE1BQWQsQ0FBcUIsQ0FBckIsR0FBeUIsQ0FBMUM7QUFDQSxZQUFNLFdBQVcsY0FBYyxNQUFkLENBQXFCLENBQXJCLEdBQXlCLENBQTFDO0FBQ0EsWUFBTSxPQUFPLEVBQWI7O0FBUjJCLG1DQVVsQixDQVZrQixFQVVYLENBVlc7QUFXdkIsZ0JBQU0sV0FBVyxTQUFTLG1CQUFULENBQTZCLENBQTdCLENBQWpCO0FBQ0EsZ0JBQU0sYUFBYSxVQUFVLGFBQVYsQ0FBd0IsQ0FBeEIsQ0FBbkI7QUFDQSxnQkFBTSxhQUFhLFNBQVMsU0FBVCxDQUFtQixDQUFuQixFQUFzQixVQUF6QztBQUNBLGdCQUFNLDBCQUEwQixlQUFlLGVBQS9DO0FBQ0EsZ0JBQUksU0FBUyxLQUFLLENBQUwsSUFBVSxJQUFJLEtBQUosQ0FBVSxRQUFWLENBQXZCO0FBQ0EsZ0JBQU0sZ0JBQWdCLEVBQXRCOztBQUVBLGdCQUFNLGlCQUFpQixTQUFqQixjQUFpQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQVU7QUFDN0IsOEJBQWMsSUFBZCxDQUFtQixDQUFuQjtBQUNBLG9CQUFJLFVBQVUsa0JBQVYsQ0FBNkIsQ0FBN0IsRUFBZ0MsQ0FBaEMsQ0FBSixFQUF3QztBQUNwQywyQkFBTyxFQUFFLE1BQU0sRUFBUixFQUFQLENBRG9DLENBQ2Y7QUFDeEIsaUJBRkQsTUFFTztBQUNILHdCQUFJLE9BQU8sRUFBWDtBQUNBLHdCQUFJLE9BQU8sRUFBWDs7QUFFQTtBQUNBLHdCQUFJLFNBQVMsTUFBVCxJQUFtQixTQUFTLE1BQVQsQ0FBZ0IsWUFBbkMsSUFBbUQsQ0FBQyxVQUFVLHdCQUFWLENBQW1DLENBQW5DLEVBQXNDLENBQXRDLEVBQXlDLGlCQUFqRyxFQUFvSDtBQUNoSCxnQ0FBUSxTQUFTLE1BQVQsQ0FBZ0IsWUFBaEIsR0FBK0IsR0FBdkM7QUFDQSwwREFBZ0MsU0FBUyxNQUFULENBQWdCLFlBQWhEO0FBQ0g7O0FBRUQ7QUFDQSx3QkFBSSxNQUFNLENBQUMsVUFBVSxRQUFWLENBQW1CLENBQW5CLEVBQXNCLENBQXRCLEtBQTRCLEVBQTdCLEVBQWlDLElBQWpDLEVBQVY7QUFDQSw0QkFBUSxHQUFSO0FBQ0Esc0RBQWdDLEdBQWhDOztBQUVBO0FBQ0Esd0JBQU0sVUFBVSxVQUFVLFFBQVYsQ0FBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsQ0FBaEI7QUFDQSx3QkFBSSxPQUFKLEVBQWE7QUFDVCx1Q0FBYSxPQUFiO0FBQ0EsNkRBQW1DLE9BQW5DO0FBQ0g7O0FBRUQsMkJBQU87QUFDSCw4QkFBTSxLQUFLLElBQUwsRUFESDtBQUVILHdDQUFjLElBQWQsV0FGRztBQUdILGlDQUFTLFVBQVUsVUFBVixDQUFxQixDQUFyQixFQUF3QixDQUF4QixDQUhOO0FBSUgsaUNBQVMsVUFBVSxVQUFWLENBQXFCLENBQXJCLEVBQXdCLENBQXhCO0FBSk4scUJBQVA7QUFNSDtBQUNKLGFBakNEOztBQW1DQSxpQkFBSyxJQUFJLElBQUksQ0FBUixFQUFXLElBQUksY0FBYyxNQUFkLENBQXFCLENBQXpDLEVBQTRDLElBQUksUUFBaEQsRUFBMEQsS0FBSyxHQUEvRCxFQUFvRTtBQUNoRSxvQkFBSSxTQUFTLGdCQUFULENBQTBCLENBQTFCLEVBQTZCLFNBQWpDLEVBQTRDO0FBQ3hDLDJCQUFPLENBQVAsSUFBWSxlQUFlLENBQWYsRUFBa0IsQ0FBbEIsQ0FBWjtBQUNILGlCQUZELE1BRU87QUFDSCx3QkFBSSxNQUFNLFVBQVUsUUFBVixDQUFtQixDQUFuQixFQUFzQixDQUF0QixDQUFWOztBQUVBLHdCQUFJLE9BQU8sUUFBUSxLQUFmLElBQXdCLFFBQVEsQ0FBaEMsSUFBcUMsUUFBUSxJQUFqRCxFQUF1RDtBQUNuRCw0QkFBSSxRQUFRLE1BQUssVUFBTCxDQUFnQiwwQkFBMEIsV0FBMUIsR0FBd0MsT0FBeEQsQ0FBWjs7QUFFQSw0QkFBSSxPQUFPLEVBQVg7QUFDQSw0QkFBSSxPQUFPLEVBQVg7O0FBRUE7QUFDQSw0QkFBTSxhQUFhLFVBQVUsVUFBVixDQUFxQixHQUFyQixDQUFuQjtBQUNBLDhCQUFNLE1BQUssV0FBTCxDQUFpQixVQUFqQixFQUE2QixHQUE3QixFQUFrQyxLQUFsQyxDQUFOO0FBQ0EsNEJBQUksTUFBSyxVQUFMLENBQWdCLGFBQWhCLElBQWlDLFVBQXJDLEVBQWlEO0FBQzdDLGtDQUFNLFVBQVUsbUJBQVYsQ0FBOEIsR0FBOUIsRUFBbUMsTUFBSyxVQUFMLENBQWdCLGFBQW5ELEVBQWtFLFVBQWxFLENBQU47QUFDSDtBQUNELGdDQUFRLEdBQVI7QUFDQSx5REFBK0IsS0FBL0IsV0FBeUMsMEJBQTBCLDZCQUExQixHQUEwRCxFQUFuRyxZQUEwRywyQkFBeUIsR0FBekIsVUFBaUMsR0FBakMsWUFBNkMsR0FBdko7O0FBRUE7QUFDQSw0QkFBSSxVQUFVLDBCQUEwQixTQUFTLCtCQUFULENBQXlDLENBQXpDLENBQTFCLEdBQXdFLFVBQVUsUUFBVixDQUFtQixDQUFuQixFQUFzQixDQUF0QixDQUF0RjtBQUNBLDRCQUFJLE9BQUosRUFBYTtBQUNULDJDQUFhLE9BQWI7QUFDQSxnRUFBa0MsT0FBbEM7QUFDSDs7QUFFRCwrQkFBTyxDQUFQLElBQVk7QUFDUixrQ0FBTSxLQUFLLElBQUwsRUFERTtBQUVSLGdFQUFpQyxTQUFTLE1BQVQsSUFBbUIsTUFBcEQsV0FBK0QsSUFBL0Q7QUFGUSx5QkFBWjtBQUlILHFCQTFCRCxNQTBCTztBQUNILCtCQUFPLENBQVAsSUFBWSxFQUFaO0FBQ0g7QUFDSjtBQUNKOztBQUVELGdCQUFJLE1BQUssa0JBQVQsRUFBNkI7QUFDekIsb0JBQUksS0FBSSxDQUFSO0FBQ0Esb0JBQU0sZUFBZSxFQUFyQjs7QUFFQSx1QkFBTyxTQUFTLGdCQUFULENBQTBCLEVBQTFCLEVBQTZCLFNBQXBDLEVBQStDO0FBQzNDLHdCQUFJLENBQUMsY0FBYyxRQUFkLENBQXVCLEVBQXZCLENBQUwsRUFBZ0M7QUFDNUIscUNBQWEsSUFBYixDQUFrQixlQUFlLENBQWYsRUFBa0IsRUFBbEIsQ0FBbEI7QUFDSDtBQUNELHNCQUFFLEVBQUY7QUFDSDs7QUFFRCxvQkFBSSxhQUFhLE1BQWIsR0FBc0IsQ0FBMUIsRUFBNkI7QUFDekIsdUJBQUcsT0FBSCxDQUFXLEtBQVgsQ0FBaUIsTUFBakIsRUFBeUIsWUFBekI7QUFDSDtBQUNKO0FBekdzQjs7QUFVM0IsYUFBSyxJQUFJLElBQUksQ0FBUixFQUFXLElBQUksY0FBYyxNQUFkLENBQXFCLENBQXpDLEVBQTRDLElBQUksUUFBaEQsRUFBMEQsS0FBSyxHQUEvRCxFQUFvRTtBQUFBLGtCQUEzRCxDQUEyRCxFQUFwRCxDQUFvRDtBQWdHbkU7O0FBRUQsZUFBTyxJQUFQO0FBQ0gsS0E1Ylc7O0FBOGJaLGdCQUFZLG9CQUFTLENBQVQsRUFBWSxDQUFaLEVBQWUsTUFBZixFQUF1QjtBQUMvQixhQUFLLGNBQUwsQ0FBb0IsS0FBcEIsQ0FBMEIsS0FBSyxVQUFMLENBQWdCLGlCQUExQztBQUNBLGFBQUssY0FBTCxDQUFvQixNQUFwQixDQUEyQixDQUEzQixFQUE4QixDQUE5QixFQUFpQyxDQUFqQyxFQUFvQyxDQUFwQyxFQUF1QyxNQUF2QztBQUNILEtBamNXOztBQW1jWix3QkFBb0IsNEJBQVMsQ0FBVCxFQUFZLElBQVosRUFBa0I7QUFDbEMsZUFBTyxRQUFRLEVBQWY7QUFDQSxZQUFJLFFBQVEsS0FBSyxjQUFqQjtBQUNBLFlBQUksa0JBQWtCLE1BQU0sZ0JBQU4sQ0FBdUIsQ0FBdkIsQ0FBdEI7QUFDQSxZQUFJLFVBQVUsS0FBSyxPQUFMLENBQWEsTUFBYixJQUF1QixDQUFDLENBQXRDO0FBQ0EsWUFBSSxXQUFXLEtBQUssT0FBTCxDQUFhLE9BQWIsSUFBd0IsQ0FBQyxDQUF4Qzs7QUFFQSxZQUFJLENBQUMsT0FBRCxJQUFZLENBQUMsUUFBakIsRUFBMkI7QUFDdkIsa0JBQU0sS0FBTjtBQUNBLGdCQUFJLENBQUMsZUFBTCxFQUFzQjtBQUNsQixzQkFBTSxZQUFOLENBQW1CLENBQW5CO0FBQ0g7QUFDSixTQUxELE1BS087QUFDSCxnQkFBSSxPQUFKLEVBQWE7QUFDVCxvQkFBSSxlQUFKLEVBQXFCO0FBQ2pCLDBCQUFNLGNBQU4sQ0FBcUIsQ0FBckI7QUFDSCxpQkFGRCxNQUVPO0FBQ0gsMEJBQU0sWUFBTixDQUFtQixDQUFuQjtBQUNIO0FBQ0o7O0FBRUQsZ0JBQUksUUFBSixFQUFjO0FBQ1Ysc0JBQU0sS0FBTjtBQUNBLHNCQUFNLFlBQU4sQ0FBbUIsS0FBSyxpQkFBTCxDQUF1QixDQUF2QixDQUFuQixFQUE4QyxDQUE5QztBQUNIO0FBQ0o7QUFDRCxZQUFJLENBQUMsZUFBRCxJQUFvQixDQUFDLFFBQXpCLEVBQW1DO0FBQy9CLGlCQUFLLGlCQUFMLENBQXVCLENBQXZCLElBQTRCLENBQTVCO0FBQ0g7QUFDRCxhQUFLLE9BQUw7QUFDQSxhQUFLLHdDQUFMO0FBQ0gsS0FsZVc7O0FBb2VaLHFCQUFpQix5QkFBUyxDQUFULEVBQVksSUFBWixFQUFrQjtBQUMvQjtBQUNBLGVBQU8sUUFBUSxFQUFmOztBQUVBLFlBQU0sUUFBUSxLQUFLLGNBQW5CO0FBQ0EsWUFBTSxXQUFXLEtBQUssT0FBTCxDQUFhLE9BQWIsSUFBd0IsQ0FBQyxDQUExQztBQUNBLFlBQU0sVUFBVSxLQUFLLE9BQUwsQ0FBYSxNQUFiLElBQXVCLENBQUMsQ0FBeEM7O0FBRUEsWUFBSSxDQUFDLE9BQUQsSUFBWSxDQUFDLFFBQWpCLEVBQTJCO0FBQ3ZCLGtCQUFNLEtBQU47O0FBRUEsa0JBQU0sU0FBTixDQUFnQixDQUFoQjtBQUNILFNBSkQsTUFJTztBQUNILGdCQUFJLE9BQUosRUFBYTtBQUNULHNCQUFNLFNBQU4sQ0FBZ0IsQ0FBaEI7QUFFSDs7QUFFRCxnQkFBSSxRQUFKLEVBQWM7QUFDVixzQkFBTSxLQUFOO0FBQ0Esc0JBQU0sU0FBTixDQUFnQixLQUFLLGlCQUFMLENBQXVCLENBQXZCLENBQWhCLEVBQTJDLENBQTNDO0FBQ0g7QUFDSjs7QUFFRCxZQUFJLENBQUMsUUFBTCxFQUFlO0FBQ1gsaUJBQUssaUJBQUwsQ0FBdUIsQ0FBdkIsSUFBNEIsQ0FBNUI7QUFDSDs7QUFFRCxhQUFLLE9BQUw7QUFDQSxhQUFLLHFDQUFMO0FBQ0gsS0FsZ0JXOztBQW9nQlosa0JBQWMsd0JBQVc7QUFDckIsWUFBSSxTQUFTLEtBQUssVUFBTCxDQUFnQixzQkFBN0I7O0FBRUEsWUFBSSxNQUFKLEVBQVk7QUFDUixpQkFBSyxjQUFMLENBQW9CLGlCQUFwQjtBQUNIOztBQUVELGVBQU8sTUFBUDtBQUNILEtBNWdCVzs7QUE4Z0JaLHdCQUFvQiw0QkFBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQy9CLFlBQUksRUFBSixFQUFRLEVBQVI7QUFDQSxZQUNJLEtBQUssV0FBTCxPQUNDLEtBQUssS0FBSyxRQUFMLENBQWMsY0FBZCxDQUE2QixDQUE3QixDQUROLE1BRUMsS0FBSyxLQUFLLFFBQUwsQ0FBYyxXQUFkLENBQTBCLElBQUksS0FBSyxpQkFBTCxFQUE5QixDQUZOLENBREosRUFJRTtBQUNFLGdCQUFJLEdBQUcsV0FBUDtBQUNBLGdCQUFJLEdBQUcsUUFBUDtBQUNBLGlCQUFLLGVBQUw7QUFDQSxpQkFBSyxNQUFMLENBQVksQ0FBWixFQUFlLENBQWYsRUFBa0IsQ0FBbEIsRUFBcUIsQ0FBckI7QUFDQSxpQkFBSyxZQUFMLENBQWtCLEtBQUssUUFBTCxDQUFjLENBQWQsRUFBaUIsQ0FBakIsQ0FBbEI7QUFDQSxpQkFBSyxhQUFMLENBQW1CLEtBQUssUUFBTCxDQUFjLENBQWQsRUFBaUIsQ0FBakIsQ0FBbkI7QUFDQSxpQkFBSyxPQUFMO0FBQ0g7QUFDSixLQTdoQlc7O0FBK2hCWiwwQkFBc0IsOEJBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUNqQyxZQUFJLFVBQUosRUFBZ0IsRUFBaEIsRUFBb0IsRUFBcEI7QUFDQSxZQUNJLENBQUMsYUFBYSxLQUFLLGFBQUwsRUFBZCxLQUF1QyxXQUFXLE1BQWxELEtBQ0MsS0FBSyxLQUFLLFFBQUwsQ0FBYyxjQUFkLENBQTZCLENBQTdCLENBRE4sTUFFQyxLQUFLLEtBQUssUUFBTCxDQUFjLFdBQWQsQ0FBMEIsSUFBSSxLQUFLLGlCQUFMLEVBQTlCLENBRk4sQ0FESixFQUlFO0FBQ0UsZ0JBQUksU0FBUyxXQUFXLENBQVgsRUFBYyxNQUEzQjtBQUNBLGdCQUFJLEdBQUcsV0FBUDtBQUNBLGdCQUFJLEdBQUcsUUFBUDtBQUNBLGlCQUFLLGFBQUwsQ0FBbUIsS0FBSyxRQUFMLENBQWMsSUFBSSxPQUFPLENBQXpCLEVBQTRCLElBQUksT0FBTyxDQUF2QyxDQUFuQjtBQUNBLGlCQUFLLE1BQUwsQ0FBWSxPQUFPLENBQW5CLEVBQXNCLE9BQU8sQ0FBN0IsRUFBZ0MsSUFBSSxPQUFPLENBQTNDLEVBQThDLElBQUksT0FBTyxDQUF6RDtBQUNBLGlCQUFLLE9BQUw7QUFDSDtBQUNKLEtBN2lCVzs7QUEraUJaLG1DQUErQix5Q0FBVztBQUN0QyxhQUFLLDJCQUFMLENBQWlDLElBQWpDO0FBQ0gsS0FqakJXOztBQW1qQlosaUNBQTZCLHFDQUFTLEVBQVQsRUFBYTtBQUN0QyxZQUFJLENBQUMsS0FBSyxXQUFMLEVBQUwsRUFBeUI7QUFDckI7QUFDSDtBQUNELFlBQUksYUFBYSxLQUFLLGFBQUwsRUFBakI7QUFDQSxZQUFJLGNBQWMsV0FBVyxNQUE3QixFQUFxQztBQUNqQyxnQkFBSSxZQUFZLFdBQVcsQ0FBWCxDQUFoQjtBQUFBLGdCQUNJLFNBQVMsVUFBVSxNQUR2QjtBQUFBLGdCQUVJLFNBQVMsVUFBVSxNQUZ2QjtBQUFBLGdCQUdJLGNBQWMsS0FBSyxjQUFMLEVBSGxCOztBQUtBLGlCQUFLLFFBQUwsQ0FBYyxXQUFkLEVBQTJCLENBQTNCOztBQUVBLGlCQUFLLGVBQUw7QUFDQSxnQkFBSSxFQUFKLEVBQVE7QUFDSixxQkFBSyxNQUFMLENBQVksT0FBTyxDQUFuQixFQUFzQixPQUFPLENBQTdCLEVBQWdDLGNBQWMsT0FBTyxDQUFyQixHQUF5QixDQUF6RCxFQUE0RCxPQUFPLENBQW5FO0FBQ0gsYUFGRCxNQUVPO0FBQ0gscUJBQUssTUFBTCxDQUFZLGNBQWMsQ0FBMUIsRUFBNkIsT0FBTyxDQUFwQyxFQUF1QyxDQUF2QyxFQUEwQyxDQUExQztBQUNIOztBQUVELGlCQUFLLE9BQUw7QUFDSDtBQUNKLEtBemtCVzs7QUEya0JaLG1DQUErQix5Q0FBVztBQUN0QyxhQUFLLDJCQUFMLENBQWlDLElBQWpDO0FBQ0gsS0E3a0JXOztBQStrQlosaUNBQTZCLHFDQUFTLEVBQVQsRUFBYTtBQUN0QyxZQUFJLENBQUMsS0FBSyxXQUFMLEVBQUwsRUFBeUI7QUFDckI7QUFDSDtBQUNELFlBQUksYUFBYSxLQUFLLGFBQUwsRUFBakI7QUFDQSxZQUFJLGNBQWMsV0FBVyxNQUE3QixFQUFxQztBQUNqQyxnQkFBSSxZQUFZLFdBQVcsQ0FBWCxDQUFoQjtBQUFBLGdCQUNJLFNBQVMsVUFBVSxNQUR2QjtBQUFBLGdCQUVJLFNBQVMsVUFBVSxNQUZ2Qjs7QUFJQSxpQkFBSyxlQUFMO0FBQ0EsZ0JBQUksRUFBSixFQUFRO0FBQ0oscUJBQUssTUFBTCxDQUFZLE9BQU8sQ0FBbkIsRUFBc0IsT0FBTyxDQUE3QixFQUFnQyxDQUFDLE9BQU8sQ0FBeEMsRUFBMkMsT0FBTyxDQUFsRDtBQUNILGFBRkQsTUFFTztBQUNILHFCQUFLLE1BQUwsQ0FBWSxDQUFaLEVBQWUsT0FBTyxDQUF0QixFQUF5QixDQUF6QixFQUE0QixDQUE1QjtBQUNIOztBQUVELGlCQUFLLGVBQUwsQ0FBcUIsQ0FBckI7QUFDQSxpQkFBSyxPQUFMO0FBQ0g7QUFDSixLQW5tQlc7O0FBcW1CWixxQkFBaUIsMkJBQVc7QUFDeEIsWUFBSSxDQUFDLEtBQUssV0FBTCxFQUFMLEVBQXlCO0FBQ3JCO0FBQ0g7QUFDRCxhQUFLLGdDQUFMLENBQXNDLEtBQUssY0FBTCxLQUF3QixDQUE5RCxFQUFpRSxLQUFLLFdBQUwsS0FBcUIsQ0FBdEY7QUFDQSxhQUFLLE9BQUw7QUFDSCxLQTNtQlc7O0FBNm1CWix1QkFBbUIsNkJBQVc7QUFDMUIsWUFBSSxDQUFDLEtBQUssV0FBTCxFQUFMLEVBQXlCO0FBQ3JCO0FBQ0g7QUFDRCxZQUFJLGFBQWEsS0FBSyxhQUFMLEVBQWpCO0FBQ0EsWUFBSSxjQUFjLFdBQVcsTUFBN0IsRUFBcUM7QUFDakMsZ0JBQUksWUFBWSxXQUFXLENBQVgsQ0FBaEI7QUFBQSxnQkFDSSxTQUFTLFVBQVUsTUFEdkI7QUFBQSxnQkFFSSxjQUFjLEtBQUssY0FBTCxFQUZsQjtBQUFBLGdCQUdJLFdBQVcsS0FBSyxXQUFMLEVBSGY7O0FBS0EsaUJBQUssZUFBTDtBQUNBLGlCQUFLLE1BQUwsQ0FBWSxPQUFPLENBQW5CLEVBQXNCLE9BQU8sQ0FBN0IsRUFBZ0MsY0FBYyxPQUFPLENBQXJCLEdBQXlCLENBQXpELEVBQTRELFdBQVcsT0FBTyxDQUFsQixHQUFzQixDQUFsRjtBQUNBO0FBQ0EsaUJBQUssT0FBTDtBQUNIO0FBQ0osS0E3bkJXOztBQStuQlo7Ozs7QUFJQSxvQkFBZ0IsMEJBQVc7QUFDdkIsWUFBSSxPQUFPLEtBQUssY0FBTCxDQUFvQixhQUFwQixFQUFYO0FBQ0EsWUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDYixnQkFBSSxXQUFXLEtBQUssUUFBcEI7QUFBQSxnQkFDSSxXQUFXLEtBQUssY0FBTCxFQURmO0FBQUEsZ0JBRUksU0FBUyxLQUFLLENBQUwsRUFBUSxNQUFSLENBQWUsQ0FGNUI7QUFBQSxnQkFHSSxNQUFNO0FBQ0Y7QUFERSxhQUhWOztBQU9BLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksUUFBcEIsRUFBOEIsR0FBOUIsRUFBbUM7QUFDL0Isb0JBQUksU0FBUyxlQUFULENBQXlCLENBQXpCLEVBQTRCLE1BQWhDLElBQTBDLFNBQVMsUUFBVCxDQUFrQixDQUFsQixFQUFxQixNQUFyQixDQUExQztBQUNIOztBQUVELG1CQUFPLEdBQVA7QUFDSDtBQUNKLEtBbnBCVzs7QUFxcEJaOzs7O0FBSUEsc0JBQWtCLDRCQUFXO0FBQ3pCO0FBQ0EsYUFBSyxtQkFBTDs7QUFFQTtBQUNBLGFBQUssc0JBQUw7O0FBRUE7QUFDQSxhQUFLLG1CQUFMOztBQUVBLFlBQUksaUJBQWlCLElBQUksV0FBSixDQUFnQix1QkFBaEIsRUFBeUM7QUFDMUQsb0JBQVEsS0FBSztBQUQ2QyxTQUF6QyxDQUFyQjtBQUdBLGFBQUssTUFBTCxDQUFZLGFBQVosQ0FBMEIsY0FBMUI7QUFFSCxLQXhxQlc7O0FBMHFCWix5QkFBcUIsK0JBQVc7QUFDNUIsWUFBSSxLQUFLLGlCQUFULEVBQTRCO0FBQ3hCLGdCQUFNLGtCQUFrQixLQUFLLGtCQUFMLE1BQTZCLEVBQXJEO0FBQ0EsZ0JBQU0sYUFBYSxLQUFLLGFBQUwsRUFBbkI7O0FBRUEsdUJBQVcsT0FBWCxDQUFtQixhQUFLO0FBQ3BCLHFCQUFLLElBQUksSUFBSSxFQUFFLElBQWYsRUFBcUIsS0FBSyxFQUFFLEtBQTVCLEVBQW1DLEVBQUUsQ0FBckMsRUFBd0M7QUFDcEMsd0JBQUksQ0FBQyxXQUFXLFFBQVgsQ0FBb0IsQ0FBcEIsQ0FBTCxFQUE2QjtBQUN6Qix3Q0FBZ0IsSUFBaEIsQ0FBcUIsQ0FBckI7QUFDSDtBQUNKO0FBQ0osYUFORDs7QUFRQSxnQkFBSSxnQkFBZ0IsTUFBcEIsRUFBNEI7QUFDeEIscUJBQUssR0FBTCxDQUFTLGVBQVQsQ0FBeUIsWUFBekIsR0FBd0MsS0FBSyxRQUFMLENBQWMsZ0JBQWQsR0FBaUMsTUFBakMsQ0FBd0M7QUFBQSwyQkFBSyxFQUFFLE1BQUYsSUFBWSxnQkFBZ0IsUUFBaEIsQ0FBeUIsRUFBRSxLQUEzQixDQUFqQjtBQUFBLGlCQUF4QyxDQUF4QztBQUNILGFBRkQsTUFFTztBQUNILHFCQUFLLEdBQUwsQ0FBUyxlQUFULENBQXlCLFlBQXpCLEdBQXdDLEVBQXhDO0FBQ0g7QUFDSixTQWpCRCxNQWlCTztBQUNILGlCQUFLLEdBQUwsQ0FBUyxlQUFULENBQXlCLFlBQXpCLEdBQXdDLEVBQXhDO0FBQ0g7QUFDSixLQS9yQlc7O0FBaXNCWiwyQkFBdUIsaUNBQVc7QUFDOUIsZUFBTyxLQUFLLGNBQUwsQ0FBb0IscUJBQXBCLEVBQVA7QUFDSCxLQW5zQlc7QUFvc0JaLGtCQUFjLHNCQUFTLEVBQVQsRUFBYSxFQUFiLEVBQWlCO0FBQzNCLGFBQUssY0FBTCxDQUFvQixZQUFwQixDQUFpQyxFQUFqQyxFQUFxQyxFQUFyQztBQUNILEtBdHNCVztBQXVzQlosZUFBVyxtQkFBUyxFQUFULEVBQWEsRUFBYixFQUFpQjtBQUN4QixZQUFJLEtBQUssWUFBTCxFQUFKLEVBQXlCO0FBQ3JCLGlCQUFLLEVBQUw7QUFDSCxTQUZELE1BRU8sSUFBSSxPQUFPLFNBQVgsRUFBc0I7QUFDekI7QUFDQSxpQkFBSyxFQUFMO0FBQ0g7O0FBRUQsYUFBSyxjQUFMLENBQW9CLFNBQXBCLENBQThCLEVBQTlCLEVBQWtDLEVBQWxDO0FBQ0gsS0FodEJXOztBQWt0QloseUJBQXFCLCtCQUFXO0FBQzVCLFlBQUksQ0FBQyxLQUFLLFVBQUwsQ0FBZ0IsaUJBQWpCLElBQXNDLEtBQUssVUFBTCxDQUFnQixjQUExRCxFQUEwRTtBQUN0RSxnQkFBSSxJQUFKOztBQUVBLGdCQUFJLENBQUMsS0FBSyxVQUFMLENBQWdCLHNCQUFyQixFQUE2QztBQUN6QyxxQkFBSyxjQUFMLENBQW9CLG1CQUFwQixDQUF3QyxDQUF4QyxFQUEyQyxJQUEzQztBQUNILGFBRkQsTUFFTyxJQUFLLE9BQU8sS0FBSyxjQUFMLENBQW9CLGdCQUFwQixFQUFaLEVBQXFEO0FBQ3hELHFCQUFLLFNBQUwsQ0FBZSxJQUFmLEVBQXFCLEtBQUssTUFBTCxDQUFZLENBQWpDO0FBQ0gsYUFGTSxNQUVBO0FBQ0gscUJBQUssaUJBQUw7QUFDSDtBQUNELGlCQUFLLHFDQUFMO0FBQ0g7QUFDSixLQS90Qlc7QUFndUJaLDRCQUF3QixrQ0FBVztBQUMvQixZQUFJLEtBQUssVUFBTCxDQUFnQixpQkFBcEIsRUFBdUM7QUFDbkMsaUJBQUssY0FBTCxDQUFvQixzQkFBcEI7QUFDSDtBQUNKLEtBcHVCVztBQXF1QloscUJBQWlCLDJCQUFXO0FBQ3hCLGVBQU8sS0FBSyxRQUFMLENBQWMsZUFBZCxFQUFQO0FBQ0gsS0F2dUJXO0FBd3VCWix3QkFBb0IsOEJBQVc7QUFDM0IsZUFBTyxLQUFLLFFBQUwsQ0FBYyxrQkFBZCxFQUFQO0FBQ0gsS0ExdUJXO0FBMnVCWixtQkFBZSx5QkFBVztBQUN0QixlQUFPLEtBQUssUUFBTCxDQUFjLGFBQWQsRUFBUDtBQUNILEtBN3VCVztBQTh1QlosMEJBQXNCLGdDQUFXO0FBQzdCLGVBQU8sS0FBSyxjQUFMLENBQW9CLG9CQUFwQixFQUFQO0FBQ0gsS0FodkJXO0FBaXZCWixtQ0FBK0IsdUNBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUMxQyxlQUFPLEtBQUssY0FBTCxDQUFvQiw2QkFBcEIsQ0FBa0QsQ0FBbEQsRUFBcUQsQ0FBckQsQ0FBUDtBQUNILEtBbnZCVztBQW92QlosbUJBQWUseUJBQVc7QUFDdEIsYUFBSyxjQUFMLENBQW9CLGFBQXBCO0FBQ0gsS0F0dkJXO0FBdXZCWix3QkFBb0IsOEJBQVc7QUFDM0IsZUFBTyxLQUFLLGNBQUwsQ0FBb0Isa0JBQXBCLEVBQVA7QUFDSCxLQXp2Qlc7QUEwdkJaLHlCQUFxQiwrQkFBVztBQUM1QixZQUFJLEtBQUssa0JBQUwsRUFBSixFQUErQjtBQUMzQixpQkFBSyxjQUFMLENBQW9CLEtBQXBCO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsaUJBQUssYUFBTDtBQUNIO0FBQ0QsYUFBSyxPQUFMO0FBQ0gsS0Fqd0JXOztBQW13Qlo7Ozs7Ozs7QUFPQSxzQkFBa0IsMEJBQVMsT0FBVCxFQUFrQixPQUFsQixFQUEyQjtBQUN6QztBQUNBLFlBQUksY0FBYyxLQUFLLFlBQUwsRUFBbEIsQ0FGeUMsQ0FFSDtBQUN0QyxhQUFLLGtCQUFMLENBQ0ksWUFBWSxDQUFaLEdBQWdCLE9BRHBCLEVBRUksWUFBWSxDQUFaLEdBQWdCLE9BRnBCO0FBSUgsS0FqeEJXOztBQW14Qlo7Ozs7Ozs7QUFPQSx3QkFBb0IsNEJBQVMsSUFBVCxFQUFlLElBQWYsRUFBcUI7QUFDckMsWUFBSSxhQUFhLEtBQUssY0FBTCxLQUF3QixDQUF6QztBQUFBLFlBQ0ksVUFBVSxLQUFLLFdBQUwsS0FBcUIsQ0FEbkM7QUFBQSxZQUdJLHFCQUFxQixLQUFLLHNCQUFMLEtBQWdDLENBSHpEO0FBQUEsWUFJSSxrQkFBa0IsS0FBSyxtQkFBTCxLQUE2QixDQUpuRDs7QUFNQSxZQUFJLENBQUMsS0FBSyxVQUFMLENBQWdCLGdCQUFyQixFQUF1QztBQUNuQyx5QkFBYSxLQUFLLEdBQUwsQ0FBUyxVQUFULEVBQXFCLGtCQUFyQixDQUFiO0FBQ0Esc0JBQVUsS0FBSyxHQUFMLENBQVMsT0FBVCxFQUFrQixlQUFsQixDQUFWO0FBQ0g7O0FBRUQsZUFBTyxLQUFLLEdBQUwsQ0FBUyxVQUFULEVBQXFCLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxJQUFaLENBQXJCLENBQVA7QUFDQSxlQUFPLEtBQUssR0FBTCxDQUFTLE9BQVQsRUFBa0IsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLElBQVosQ0FBbEIsQ0FBUDs7QUFFQSxhQUFLLGVBQUw7QUFDQSxhQUFLLE1BQUwsQ0FBWSxJQUFaLEVBQWtCLElBQWxCLEVBQXdCLENBQXhCLEVBQTJCLENBQTNCO0FBQ0EsYUFBSyxZQUFMLENBQWtCLEtBQUssUUFBTCxDQUFjLElBQWQsRUFBb0IsSUFBcEIsQ0FBbEI7QUFDQSxhQUFLLGFBQUwsQ0FBbUIsS0FBSyxRQUFMLENBQWMsQ0FBZCxFQUFpQixDQUFqQixDQUFuQjs7QUFFQSxhQUFLLGdDQUFMLENBQXNDLElBQXRDLEVBQTRDLElBQTVDOztBQUVBLGFBQUssT0FBTDtBQUNILEtBanpCVzs7QUFtekJaOzs7Ozs7QUFNQSxrQkFBYyxzQkFBUyxPQUFULEVBQWtCLE9BQWxCLEVBQTJCO0FBQ3JDLFlBQUksYUFBYSxLQUFLLGNBQUwsS0FBd0IsQ0FBekM7QUFBQSxZQUNJLFVBQVUsS0FBSyxXQUFMLEtBQXFCLENBRG5DO0FBQUEsWUFHSSxxQkFBcUIsS0FBSyxRQUFMLENBQWMsY0FBZCxDQUE2QixNQUE3QixHQUFzQyxDQUgvRDtBQUFBLFlBSUksa0JBQWtCLEtBQUssUUFBTCxDQUFjLFdBQWQsQ0FBMEIsTUFBMUIsR0FBbUMsQ0FKekQ7QUFBQSxZQU1JLFNBQVMsS0FBSyxZQUFMLEVBTmI7QUFBQSxZQU9JLFNBQVMsS0FBSyxhQUFMLEVBUGI7QUFBQSxZQVNJLE9BQU8sT0FBTyxDQUFQLEdBQVcsT0FUdEI7QUFBQSxZQVVJLE9BQU8sT0FBTyxDQUFQLEdBQVcsT0FWdEI7O0FBWUEsWUFBSSxDQUFDLEtBQUssVUFBTCxDQUFnQixnQkFBckIsRUFBdUM7QUFDbkMseUJBQWEsS0FBSyxHQUFMLENBQVMsVUFBVCxFQUFxQixrQkFBckIsQ0FBYjtBQUNBLHNCQUFVLEtBQUssR0FBTCxDQUFTLE9BQVQsRUFBa0IsZUFBbEIsQ0FBVjtBQUNIOztBQUVELGVBQU8sS0FBSyxHQUFMLENBQVMsYUFBYSxPQUFPLENBQTdCLEVBQWdDLEtBQUssR0FBTCxDQUFTLENBQUMsT0FBTyxDQUFqQixFQUFvQixJQUFwQixDQUFoQyxDQUFQO0FBQ0EsZUFBTyxLQUFLLEdBQUwsQ0FBUyxVQUFVLE9BQU8sQ0FBMUIsRUFBNkIsS0FBSyxHQUFMLENBQVMsQ0FBQyxPQUFPLENBQWpCLEVBQW9CLElBQXBCLENBQTdCLENBQVA7O0FBRUEsYUFBSyx3QkFBTDs7QUFFQSxhQUFLLE1BQUwsQ0FBWSxPQUFPLENBQW5CLEVBQXNCLE9BQU8sQ0FBN0IsRUFBZ0MsSUFBaEMsRUFBc0MsSUFBdEM7QUFDQSxhQUFLLGFBQUwsQ0FBbUIsS0FBSyxRQUFMLENBQWMsSUFBZCxFQUFvQixJQUFwQixDQUFuQjs7QUFFQSxZQUFJLGNBQWMsS0FBSyx1QkFBTCxDQUE2QixPQUFPLE9BQU8sQ0FBM0MsRUFBOEMsT0FBOUMsQ0FBbEI7QUFBQSxZQUNJLGNBQWMsS0FBSyx1QkFBTCxDQUE2QixPQUFPLE9BQU8sQ0FBM0MsRUFBOEMsT0FBOUMsQ0FEbEI7O0FBR0EsYUFBSyxPQUFMOztBQUVBLFlBQU0sYUFBYSxlQUFlLFdBQWxDOztBQUVBLFlBQUksVUFBSixFQUFnQjtBQUNaLGlCQUFLLG1CQUFMLENBQXlCLE9BQU8sT0FBTyxDQUF2QyxFQUEwQyxPQUFPLE9BQU8sQ0FBeEQ7QUFDSDs7QUFFRCxlQUFPLFVBQVA7QUFDSCxLQS8xQlc7O0FBaTJCWjs7Ozs7QUFLQSxrQ0FBOEIsc0NBQVMsV0FBVCxFQUFzQjtBQUNoRCxZQUFJLE1BQU0sS0FBSyxjQUFMLENBQW9CLGdCQUFwQixFQUFWO0FBQ0EsZUFBTyxPQUFRLElBQUksS0FBSyxRQUFMLENBQWMsU0FBbEIsRUFBRCxDQUE4QixlQUE5QixDQUE4QyxJQUFJLE1BQUosQ0FBVyxDQUF6RCxFQUE0RCxJQUFJLE1BQUosQ0FBVyxDQUF2RSxFQUEwRSxJQUExRSxFQUFnRixXQUFoRixDQUFkO0FBQ0g7QUF6MkJXLENBQWhCOztBQTQyQkE7Ozs7Ozs7Ozs7QUFVQSxTQUFTLFVBQVQsQ0FBb0IsYUFBcEIsRUFBbUM7QUFDL0IsUUFBSSxPQUFKO0FBQUEsUUFDSSxhQUFhLEtBQUssUUFBTCxDQUFjLFVBQWQsRUFEakI7QUFBQSxRQUVJLGdCQUFnQixLQUFLLFFBQUwsQ0FBYyxnQkFBZCxFQUZwQjs7QUFJQSxRQUFJLE1BQU0sT0FBTixDQUFjLGFBQWQsQ0FBSixFQUFrQztBQUM5QixrQkFBVSxFQUFWO0FBQ0Esc0JBQWMsT0FBZCxDQUFzQixVQUFTLEtBQVQsRUFBZ0I7QUFDbEMsZ0JBQUksTUFBTSxPQUFPLEtBQVAsS0FBaUIsUUFBakIsR0FBNEIsT0FBNUIsR0FBc0MsTUFBaEQ7QUFBQSxnQkFDSSxTQUFTLFdBQVcsSUFBWCxDQUFnQjtBQUFBLHVCQUFVLE9BQU8sR0FBUCxNQUFnQixLQUExQjtBQUFBLGFBQWhCLENBRGI7QUFFQSxnQkFBSSxjQUFjLE9BQWQsQ0FBc0IsTUFBdEIsSUFBZ0MsQ0FBcEMsRUFBdUM7QUFDbkMsd0JBQVEsSUFBUixDQUFhLE1BQWI7QUFDSDtBQUNKLFNBTkQ7QUFPQSxrQkFBVSxRQUFRLE1BQVIsQ0FBZSxhQUFmLENBQVY7QUFDSCxLQVZELE1BVU87QUFDSCxrQkFBVSxnQkFBZ0IsVUFBaEIsR0FBNkIsYUFBdkM7QUFDSDs7QUFFRCxXQUFPLE9BQVA7QUFDSDs7QUFFRCxTQUFTLGFBQVQsQ0FBdUIsSUFBdkIsRUFBNkI7QUFDekIsUUFBSSxJQUFJLEtBQUssTUFBYjtBQUFBLFFBQ0ksSUFBSSxLQUFLLE1BRGI7QUFBQSxRQUdJLEtBQUssS0FBSyxHQUFMLENBQVMsRUFBRSxDQUFYLEVBQWMsRUFBRSxDQUFoQixDQUhUO0FBQUEsUUFJSSxLQUFLLEtBQUssR0FBTCxDQUFTLEVBQUUsQ0FBWCxFQUFjLEVBQUUsQ0FBaEIsQ0FKVDtBQUFBLFFBTUksS0FBSyxLQUFLLEdBQUwsQ0FBUyxFQUFFLENBQVgsRUFBYyxFQUFFLENBQWhCLENBTlQ7QUFBQSxRQU9JLEtBQUssS0FBSyxHQUFMLENBQVMsRUFBRSxDQUFYLEVBQWMsRUFBRSxDQUFoQixDQVBUOztBQVNBLFdBQU8sSUFBSSxTQUFKLENBQWMsRUFBZCxFQUFrQixFQUFsQixFQUFzQixLQUFLLEVBQTNCLEVBQStCLEtBQUssRUFBcEMsQ0FBUDtBQUNIOztBQUVEOzs7OztBQUtBLFNBQVMsU0FBVCxDQUFtQixPQUFuQixFQUE0QixNQUE1QixFQUFvQztBQUNoQyxRQUFJLE1BQUosRUFBWSxVQUFaO0FBQ0EsUUFBSSxPQUFKLEVBQWE7QUFDVCxpQkFBUyxRQUFRLE9BQU8sSUFBZixDQUFUO0FBQ0EscUJBQWEsUUFBUSxNQUFSLHlDQUFRLE1BQVIsR0FBZ0IsQ0FBaEIsTUFBdUIsR0FBdkIsSUFBOEIsTUFBOUIsSUFBd0MsT0FBTyxVQUE1RDtBQUNBLFlBQUksVUFBSixFQUFnQjtBQUNaLHFCQUFTLFdBQVcsT0FBWCxFQUFvQixPQUFPLElBQTNCLENBQVQ7QUFDSDtBQUNKO0FBQ0QsUUFBSSxPQUFPLEtBQVgsRUFBa0I7QUFDZCxlQUFPLE9BQU8sS0FBZDtBQUNIO0FBQ0QsV0FBTyxVQUFVLFdBQVcsQ0FBckIsSUFBMEIsV0FBVyxLQUFyQyxHQUE2QyxNQUE3QyxHQUFzRCxFQUE3RDtBQUNIOzs7QUNyN0JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFFQSxJQUFJLElBQUksUUFBUSxrQkFBUixDQUFSLEMsQ0FBcUM7O0FBRXJDLElBQUksV0FBVyxRQUFRLGFBQVIsQ0FBZjtBQUNBLElBQUksNkJBQTZCLFFBQVEsMEJBQVIsQ0FBakM7QUFDQSxJQUFJLGlCQUFpQixRQUFRLGNBQVIsQ0FBckI7O0FBRUEsSUFBSSxTQUFTLENBQ1QsaUJBRFMsRUFFVCxPQUZTLEVBR1QsTUFIUyxDQUFiOztBQU1BLElBQUksbUJBQW1CLE9BQU8sTUFBUCxDQUFjLENBQ2pDLFFBRGlDLENBQWQsQ0FBdkI7O0FBSUEsSUFBSSxpQkFBaUIsaUJBQWlCLE1BQWpCLENBQXdCLENBQ3pDLGFBRHlDLEVBRXpDLGFBRnlDLENBQXhCLENBQXJCOztBQUtBLElBQUksVUFBVSxDQUNWLEVBQUUsUUFBUSxFQUFWLEVBQTZDLE9BQU8sY0FBcEQsRUFEVSxFQUVWLEVBQUUsUUFBUSxxQkFBVixFQUE2QyxPQUFPLE1BQXBELEVBRlUsRUFHVixFQUFFLFFBQVEsY0FBVixFQUE2QyxPQUFPLGdCQUFwRCxFQUhVLEVBSVYsRUFBRSxRQUFRLGlDQUFWLEVBQTZDLE9BQU8sTUFBcEQsRUFKVSxFQUtWLEVBQUUsUUFBUSxXQUFWLEVBQTZDLE9BQU8sTUFBcEQsRUFMVSxFQU1WLEVBQUUsUUFBUSw4QkFBVixFQUE2QyxPQUFPLE1BQXBELEVBTlUsQ0FBZDs7QUFTQSxJQUFJLG1CQUFtQjtBQUNuQix5QkFBcUIsU0FBUyxtQkFEWDtBQUVuQixzQkFBa0IsU0FBUyxnQkFGUjtBQUduQixnQkFBWSxTQUFTLFVBSEY7QUFJbkIsbUJBQWUsU0FBUyxhQUpMO0FBS25CLHFCQUFpQixTQUFTLGVBTFA7QUFNbkIsc0JBQWtCLFNBQVMsZ0JBTlI7QUFPbkIsb0JBQWdCLFNBQVMsY0FQTjtBQVFuQixrQkFBYyxTQUFTO0FBUkosQ0FBdkI7O0FBV0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxlQUFlLE9BQU8sTUFBUCxDQUFjLEVBQWQsRUFBa0IsZ0JBQWxCLEVBQW9DO0FBQ25ELGVBQVcsU0FBUztBQUQrQixDQUFwQyxDQUFuQjs7QUFJQTtBQUNBO0FBQ0EsUUFBUSxNQUFSLENBQWUsVUFBUyxLQUFULEVBQWdCLE1BQWhCLEVBQXdCO0FBQ25DLFdBQU8sT0FBTyxLQUFQLENBQWEsTUFBYixDQUFvQixVQUFTLEtBQVQsRUFBZ0IsSUFBaEIsRUFBc0I7QUFDN0MsZUFBTyxPQUFPLE1BQVAsR0FBZ0IsSUFBdkI7QUFDQSxlQUFPLEtBQUssT0FBTCxDQUFhLCtCQUFiLEVBQThDLHFCQUE5QyxDQUFQLENBRjZDLENBRWdDO0FBQzdFLGVBQU8sS0FBSyxDQUFMLEVBQVEsV0FBUixLQUF3QixLQUFLLE1BQUwsQ0FBWSxDQUFaLENBQS9CO0FBQ0EsY0FBTSxJQUFOLElBQWMsU0FBUyxJQUFULENBQWQ7QUFDQSxlQUFPLEtBQVA7QUFDSCxLQU5NLEVBTUosS0FOSSxDQUFQO0FBT0gsQ0FSRCxFQVFHLFlBUkg7O0FBVUE7Ozs7QUFJQSxJQUFJLFdBQVcsT0FBTyxNQUFQLENBQWMsSUFBZCxFQUFvQjtBQUMvQixhQUFTLEVBQUUsT0FBTyxZQUFUO0FBRHNCLENBQXBCLENBQWY7QUFHQSxJQUFJLG1CQUFtQjtBQUNuQixvQkFBZ0IsMENBREc7QUFFbkIsZUFBVyxtQ0FGUTtBQUduQixlQUFXLG1DQUhRO0FBSW5CLGdCQUFZO0FBSk8sQ0FBdkI7O0FBT0EsU0FBUyxVQUFULENBQW9CLEtBQXBCLEVBQTJCO0FBQ3ZCLFFBQUksVUFBSixFQUFnQixLQUFoQixFQUF1QixLQUF2Qjs7QUFFQSxRQUFJLFNBQVMsUUFBTyxLQUFQLHlDQUFPLEtBQVAsT0FBaUIsUUFBMUIsSUFBc0MsQ0FBQyxPQUFPLG1CQUFQLENBQTJCLEtBQTNCLEVBQWtDLE1BQTdFLEVBQXFGO0FBQ2pGLGdCQUFRLElBQVI7QUFDSDs7QUFFRCxRQUFJLEtBQUssTUFBVCxFQUFpQjtBQUNiLGdCQUFRLENBQUMsSUFBRCxDQUFSO0FBQ0EscUJBQWEsS0FBSyxNQUFsQjtBQUNBLGdCQUFRLEtBQUssVUFBYjs7QUFFQTtBQUNBLFlBQUksQ0FBQyxLQUFMLEVBQVk7QUFDUjtBQUNBLG1CQUFPLElBQVAsQ0FBWSxVQUFaLEVBQXdCLE9BQXhCLENBQWdDLFVBQVMsR0FBVCxFQUFjO0FBQzFDLG9CQUFJLEVBQUUsT0FBTywwQkFBVCxDQUFKLEVBQTBDO0FBQ3RDLDJCQUFPLE1BQU0sR0FBTixDQUFQO0FBQ0g7QUFDSixhQUpEOztBQU1BO0FBQ0EsbUJBQU8sSUFBUCxDQUFZLGdCQUFaLEVBQThCLE9BQTlCLENBQXNDLFVBQVMsR0FBVCxFQUFjO0FBQ2hELHNCQUFNLEdBQU4sQ0FBVSxHQUFWLElBQWlCLFNBQVMsR0FBVCxDQUFqQjtBQUNILGFBRkQ7QUFHSDs7QUFFRDtBQUNBLGVBQU8sSUFBUCxDQUFZLFVBQVosRUFBd0IsT0FBeEIsQ0FBZ0MsVUFBUyxHQUFULEVBQWM7QUFDMUMsbUJBQU8sV0FBVyxHQUFYLENBQVA7QUFDSCxTQUZEO0FBR0gsS0F4QkQsTUF3Qk87QUFDSCxnQkFBUSxLQUFLLEtBQWI7QUFDQSxxQkFBYSxRQUFiLENBRkcsQ0FFb0I7QUFDdkIsZ0JBQVEsU0FBUyxTQUFqQjtBQUNIOztBQUVELFFBQUksT0FBTyxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzNCLFlBQUksQ0FBQyxTQUFTLEtBQVQsQ0FBTCxFQUFzQjtBQUNsQixrQkFBTSxJQUFJLGNBQUosQ0FBbUIsb0JBQW9CLEtBQXBCLEdBQTRCLEdBQS9DLENBQU47QUFDSDtBQUNELGdCQUFRLFNBQVMsS0FBVCxDQUFSO0FBQ0g7O0FBRUQsUUFBSSxLQUFKLEVBQVc7QUFDUDtBQUNBLFlBQUksQ0FBQyxNQUFNLFNBQVgsRUFBc0I7QUFDbEIsa0JBQU0sU0FBTixHQUFrQixTQUFsQjtBQUNIOztBQUVELGVBQU8sSUFBUCxDQUFZLEtBQVosRUFBbUIsT0FBbkIsQ0FBMkIsVUFBUyxHQUFULEVBQWM7QUFDckMsZ0JBQUksT0FBTywwQkFBWCxFQUF1QztBQUNuQyxvQkFBSSxPQUFPLGdCQUFYLEVBQTZCO0FBQ3pCLDBCQUFNLE9BQU4sQ0FBYyxVQUFTLElBQVQsRUFBZTtBQUN6Qiw2QkFBSyxVQUFMLENBQWdCLEdBQWhCLElBQXVCLE1BQU0sR0FBTixDQUF2QjtBQUNILHFCQUZEO0FBR0gsaUJBSkQsTUFJTztBQUNIO0FBQ0E7QUFDQSx3QkFBSSxVQUFVLGlCQUFpQixHQUFqQixDQUFkO0FBQ0EsOEJBQVUsVUFDSixxQ0FBcUMsR0FBckMsR0FBMkMscUNBQTNDLEdBQW1GLE9BQW5GLEdBQTZGLFdBRHpGLEdBRUosK0JBQStCLEdBQS9CLEdBQXFDLG1CQUYzQztBQUdBLDRCQUFRLElBQVIsQ0FBYSxPQUFiO0FBQ0EsMkJBQU8sTUFBTSxHQUFOLENBQVA7QUFDSDtBQUNKO0FBQ0osU0FqQkQ7O0FBbUJBO0FBQ0EsZUFBTyxnQkFBUCxDQUF3QixVQUF4QixFQUFvQyxPQUFPLHlCQUFQLENBQWlDLEtBQWpDLENBQXBDO0FBQ0g7O0FBRUQsVUFBTSxPQUFOLENBQWMsVUFBUyxJQUFULEVBQWU7QUFDekIsYUFBSyxPQUFMO0FBQ0gsS0FGRDtBQUdIOztBQUdEOzs7OztBQUtBLElBQUksUUFBUTtBQUNSLG9CQUFnQiwwQkFBVztBQUN2Qjs7Ozs7QUFLQSxhQUFLLE1BQUwsR0FBYyxPQUFPLE1BQVAsQ0FBYyxRQUFkLENBQWQ7O0FBRUEsZUFBTyxPQUFPLE1BQVAsQ0FBYyxLQUFLLE1BQW5CLEVBQTJCLDBCQUEzQixDQUFQO0FBQ0gsS0FWTzs7QUFZUjs7Ozs7Ozs7Ozs7O0FBWUEsZ0JBQVksVUF4Qko7O0FBMEJSOzs7Ozs7Ozs7QUFTQSxjQUFVLG9CQUFXO0FBQ2pCLFlBQUksYUFBYSxLQUFLLE1BQXRCO0FBQUEsWUFDSSxZQUFZLFdBQVcsU0FEM0I7QUFFQSxlQUFPLGNBQWMsU0FBZCxJQUEyQixDQUFDLE9BQU8sbUJBQVAsQ0FBMkIsVUFBM0IsRUFBdUMsTUFBbkUsR0FDRCxTQURDLENBQ1M7QUFEVCxVQUVELGFBQWEsUUFBYixHQUNJLFNBREosQ0FDYztBQURkLFVBRUksVUFKVixDQUhpQixDQU9LO0FBQ3pCO0FBM0NPLENBQVo7QUE2Q0EsT0FBTyxjQUFQLENBQXNCLEtBQXRCLEVBQTZCLE9BQTdCLEVBQXNDO0FBQ2xDLGdCQUFZLElBRHNCO0FBRWxDLFNBQUssTUFBTSxVQUZ1QjtBQUdsQyxTQUFLLE1BQU07QUFIdUIsQ0FBdEM7O0FBT0E7Ozs7O0FBS0EsSUFBSSxjQUFjO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7QUFhQSxtQkFBZSx1QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNqQyxZQUFJLFFBQU8sSUFBUCx5Q0FBTyxJQUFQLE9BQWdCLFFBQXBCLEVBQThCO0FBQzFCLG9CQUFRLElBQVI7QUFDQSxtQkFBTyxNQUFNLFNBQWI7QUFDSDs7QUFFRCxZQUFJLENBQUMsSUFBTCxFQUFXO0FBQ1Asa0JBQU0sSUFBSSxjQUFKLENBQW1CLHFDQUFuQixDQUFOO0FBQ0g7O0FBRUQsWUFBSSxTQUFTLFNBQWIsRUFBd0I7QUFDcEIsa0JBQU0sSUFBSSxjQUFKLENBQW1CLG9EQUFuQixDQUFOO0FBQ0g7O0FBRUQsWUFBSSxLQUFKLEVBQVc7QUFDUCxrQkFBTSxTQUFOLEdBQWtCLElBQWxCO0FBQ0EscUJBQVMsSUFBVCxJQUFpQixLQUFqQjtBQUNILFNBSEQsTUFHTztBQUNILG1CQUFPLFNBQVMsSUFBVCxDQUFQO0FBQ0g7QUFDSixLQWxDYTs7QUFvQ2Q7Ozs7Ozs7O0FBUUEsb0JBQWdCLHdCQUFTLGVBQVQsRUFBMEI7QUFDdEMsWUFBSSxlQUFKLEVBQXFCO0FBQ2pCLGNBQUUsZUFBRixFQUFtQixJQUFuQixDQUF3QixVQUFTLEtBQVQsRUFBZ0IsSUFBaEIsRUFBc0I7QUFDMUMscUJBQUssYUFBTCxDQUFtQixJQUFuQixFQUF5QixLQUF6QjtBQUNILGFBRkQsRUFFRyxJQUZIO0FBR0gsU0FKRCxNQUlPO0FBQ0gsbUJBQU8sSUFBUCxDQUFZLFFBQVosRUFBc0IsT0FBdEIsQ0FBOEIsVUFBUyxTQUFULEVBQW9CO0FBQzlDLHFCQUFLLGFBQUwsQ0FBbUIsU0FBbkI7QUFDSCxhQUZELEVBRUcsSUFGSDtBQUdIO0FBQ0osS0F0RGE7O0FBd0RkOzs7Ozs7Ozs7Ozs7QUFZQSxnQkFBWTtBQXBFRSxDQUFsQjtBQXNFQSxPQUFPLGNBQVAsQ0FBc0IsV0FBdEIsRUFBbUMsT0FBbkMsRUFBNEMsRUFBRTtBQUMxQyxnQkFBWSxJQUQ0QjtBQUV4QyxTQUFLLFVBRm1DO0FBR3hDLFNBQUssZUFBVztBQUFFLGVBQU8sUUFBUDtBQUFrQixLQUhJLENBR0g7QUFIRyxDQUE1Qzs7QUFPQSxPQUFPLE9BQVAsR0FBaUI7QUFDYixXQUFPLEtBRE07QUFFYixpQkFBYTtBQUZBLENBQWpCOzs7QUM1U0E7Ozs7QUFFQSxJQUFJLFFBQVEsUUFBUSxhQUFSLEVBQXVCLEtBQW5DOztBQUVBLElBQUksT0FBTyxRQUFRLFNBQVIsQ0FBWDtBQUNBLElBQUksU0FBUyxRQUFRLFVBQVIsQ0FBYjtBQUNBLElBQUksbUJBQW1CLFFBQVEseUJBQVIsQ0FBdkI7QUFDQSxJQUFJLGtCQUFrQixRQUFRLGFBQVIsQ0FBdEI7QUFDQSxJQUFJLGdCQUFnQixRQUFRLGdCQUFSLEVBQTBCLGFBQTlDOztBQUdBLElBQUkscUJBQXFCLENBQ3JCLGNBRHFCLEVBRXJCLDZCQUZxQixFQUdyQixrQkFIcUIsRUFJckIsV0FKcUIsRUFLckIsdUJBTHFCLEVBTXJCLHNCQU5xQixFQU9yQixzQkFQcUIsRUFRckIscUNBUnFCLENBQXpCOztBQVdBLE1BQU0sU0FBTixDQUFnQixJQUFoQixHQUF1QixVQUFTLFFBQVQsRUFBbUIsR0FBbkIsRUFBd0IsUUFBeEIsRUFBa0M7QUFBRTtBQUN2RCxXQUFPLFdBQVcsQ0FBbEIsRUFBcUI7QUFDakIsb0JBQVksS0FBSyxNQUFqQjtBQUNIO0FBQ0QsV0FBTyxXQUFXLENBQWxCLEVBQXFCO0FBQ2pCLG9CQUFZLEtBQUssTUFBakI7QUFDSDtBQUNELFFBQUksWUFBWSxLQUFLLE1BQXJCLEVBQTZCO0FBQ3pCLFlBQUksSUFBSSxXQUFXLEtBQUssTUFBeEI7QUFDQSxlQUFRLEdBQUQsR0FBUSxDQUFmLEVBQWtCO0FBQ2QsaUJBQUssSUFBTCxDQUFVLFNBQVY7QUFDSDtBQUNKO0FBQ0QsUUFBSSxXQUFXLFFBQWYsRUFBd0I7QUFDcEIsb0JBQVksTUFBTSxDQUFsQjtBQUNIO0FBQ0QsU0FBSyxNQUFMLENBQVksS0FBWixDQUFrQixJQUFsQixFQUF3QixDQUFDLFFBQUQsRUFBVyxDQUFYLEVBQWMsTUFBZCxDQUFxQixLQUFLLE1BQUwsQ0FBWSxRQUFaLEVBQXNCLEdBQXRCLENBQXJCLENBQXhCO0FBQ0EsV0FBTyxJQUFQO0FBQ0gsQ0FsQkQ7O0FBb0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkEsSUFBSSxXQUFXLEtBQUssTUFBTCxDQUFZLFVBQVosRUFBd0I7O0FBRW5DLGdCQUFZLG9CQUFTLElBQVQsRUFBZSxPQUFmLEVBQXdCO0FBQ2hDOzs7O0FBSUEsYUFBSyxJQUFMLEdBQVksSUFBWjs7QUFFQSxhQUFLLHNCQUFMOztBQUVBLGFBQUssSUFBTCxDQUFVLFFBQVYsR0FBcUIsSUFBckI7QUFDQSxhQUFLLEtBQUwsQ0FBVyxPQUFYO0FBQ0gsS0Fia0M7O0FBZW5DOzs7OztBQUtBLDRCQUF3QixnQ0FBUyxJQUFULEVBQWU7QUFDbkMsWUFBSSxZQUFKOztBQUVBOzs7Ozs7QUFNQSxhQUFLLFlBQUwsR0FBb0IsU0FBcEI7O0FBRUE7Ozs7OztBQU1BLGFBQUssVUFBTCxHQUFrQixFQUFsQjs7QUFFQSxhQUFLLGVBQUwsR0FBdUIsS0FBSyxlQUFMLElBQXdCLGVBQS9DOztBQUVBLFlBQUksS0FBSyxJQUFMLENBQVUsVUFBVixDQUFxQixRQUF6QixFQUFtQztBQUMvQixnQkFBSSx3QkFBd0IsS0FBSyxlQUFMLENBQXFCLEdBQXJCLENBQXlCLElBQXpCLENBQThCLEtBQUssZUFBbkMsQ0FBNUI7QUFDQSwyQkFBZSxLQUFLLElBQUwsQ0FBVSxVQUFWLENBQXFCLFFBQXJCLENBQThCLEdBQTlCLENBQWtDLHFCQUFsQyxDQUFmO0FBQ0gsU0FIRCxNQUdPLElBQUksS0FBSyxRQUFULEVBQW1CO0FBQ3RCLDJCQUFlLEtBQUssUUFBcEI7QUFDQSw0Q0FBZ0MsSUFBaEMsQ0FBcUMsSUFBckM7QUFDSDs7QUFFRCxxQkFBYSxPQUFiLENBQXFCLFVBQVMsa0JBQVQsRUFBNkIsQ0FBN0IsRUFBZ0M7QUFDakQsZ0JBQUksVUFBVSxJQUFJLGtCQUFKLEVBQWQ7O0FBRUEsaUJBQUssVUFBTCxDQUFnQixRQUFRLFlBQXhCLElBQXdDLE9BQXhDOztBQUVBLGdCQUFJLENBQUosRUFBTztBQUNILHFCQUFLLFlBQUwsQ0FBa0IsT0FBbEIsQ0FBMEIsT0FBMUI7QUFDSCxhQUZELE1BRU87QUFDSCxxQkFBSyxZQUFMLEdBQW9CLE9BQXBCO0FBQ0g7QUFDSixTQVZELEVBVUcsSUFWSDs7QUFZQSxZQUFJLEtBQUssWUFBVCxFQUF1QjtBQUNuQixpQkFBSyxZQUFMLENBQWtCLFlBQWxCLENBQStCLEtBQUssSUFBcEM7QUFDSDtBQUNKLEtBaEVrQzs7QUFrRW5DLGNBQVUsRUFsRXlCLEVBa0VyQjs7QUFFZDs7Ozs7O0FBTUEsV0FBTyxlQUFTLE9BQVQsRUFBa0I7QUFDckIsYUFBSyxTQUFMLEdBQWlCLEtBQUssTUFBdEI7O0FBRUEsWUFBSSxtQkFBbUIsS0FBSyxjQUFMLENBQW9CLE9BQXBCLENBQXZCOztBQUVBLFlBQUksZ0JBQUosRUFBc0I7QUFDbEI7QUFDQSxpQkFBSyxTQUFMLEdBQWlCLGlCQUFpQixLQUFLLElBQXRCLENBQWpCO0FBQ0g7O0FBRUQsYUFBSyxlQUFMLEdBQXVCLEtBQUssZUFBTCxHQUF1QixDQUE5Qzs7QUFFQSxhQUFLLGFBQUw7O0FBRUE7Ozs7O0FBS0EsYUFBSyxRQUFMLEdBQWdCLFdBQVcsUUFBUSxRQUFuQixJQUNaLENBQUMsZ0JBQUQsSUFBcUIsS0FBSyxRQURkLElBRVosS0FBSyxJQUFMLENBQVUsVUFBVixDQUFxQixRQUZ6Qjs7QUFJQSxhQUFLLE9BQUwsQ0FBYSxPQUFiO0FBQ0gsS0FsR2tDOztBQW9HbkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBLGFBQVMsaUJBQVMsUUFBVCxFQUFtQixPQUFuQixFQUE0QixDQUNwQyxDQTVIa0M7O0FBOEhuQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkEsYUFBUyxpQkFBUyxRQUFULEVBQW1CLE9BQW5CLEVBQTRCLENBQ3BDLENBdEprQzs7QUF3Sm5DLFFBQUksbUJBQUosR0FBMEI7QUFDdEIsZUFBTyxLQUFLLElBQUwsQ0FBVSxRQUFWLENBQW1CLGNBQW5CLENBQWtDLE1BQXpDO0FBQ0gsS0ExSmtDOztBQTRKbkMsUUFBSSxnQkFBSixHQUF1QjtBQUNuQixlQUFPLEtBQUssSUFBTCxDQUFVLFFBQVYsQ0FBbUIsV0FBbkIsQ0FBK0IsTUFBdEM7QUFDSCxLQTlKa0M7O0FBZ0tuQyxRQUFJLGdCQUFKLEdBQXVCO0FBQ25CLGVBQU8sS0FBSyxJQUFMLENBQVUsVUFBVixDQUFxQixjQUFyQixHQUFzQyxLQUFLLGNBQTNDLEdBQTZELEtBQUssYUFBTCxLQUF1QixLQUFLLGVBQTVCLEdBQThDLENBQWxIO0FBQ0gsS0FsS2tDOztBQW9LbkMsa0JBQWMsd0JBQVc7QUFDckIsWUFBSSxTQUFTLEtBQUssTUFBbEI7QUFBQSxZQUNJLGtCQUFrQixLQUFLLGVBRDNCO0FBQUEsWUFFSSxpQkFBaUIsS0FBSyxjQUYxQjs7QUFJQSxlQUFPLGVBQVAsSUFBMEIsT0FBTyxlQUFQLEtBQTJCO0FBQ2pELG1CQUFPLGVBRDBDO0FBRWpELGtCQUFNLE1BRjJDO0FBR2pELG9CQUFRO0FBSHlDLFNBQXJEOztBQU1BLGVBQU8sY0FBUCxJQUF5QixPQUFPLGNBQVAsS0FBMEI7QUFDL0MsbUJBQU8sY0FEd0M7QUFFL0Msa0JBQU0sRUFGeUM7QUFHL0Msb0JBQVE7QUFIdUMsU0FBbkQ7O0FBTUEsWUFBSSxnQkFBaUIsS0FBSyxVQUFMLElBQW1CLEtBQUssVUFBTCxDQUFnQixlQUFoQixDQUFwQixJQUEwRCxLQUFLLE9BQUwsSUFBZ0IsS0FBSyxPQUFMLENBQWEsZUFBYixDQUE5RjtBQUNBLFlBQUksZUFBZ0IsS0FBSyxVQUFMLElBQW1CLEtBQUssVUFBTCxDQUFnQixjQUFoQixDQUFwQixJQUF5RCxLQUFLLE9BQUwsSUFBZ0IsS0FBSyxPQUFMLENBQWEsY0FBYixDQUE1Rjs7QUFFQTs7OztBQUlBLGFBQUssT0FBTCxHQUFlLEVBQWY7O0FBRUE7Ozs7QUFJQSxhQUFLLFVBQUwsR0FBa0IsRUFBbEI7O0FBRUEsYUFBSyxVQUFMLENBQWdCLGVBQWhCLElBQW1DLEtBQUssT0FBTCxDQUFhLGVBQWIsSUFBZ0MsS0FBSyxTQUFMLENBQWUsaUJBQWlCLGNBQWMsVUFBL0IsR0FBNEMsY0FBYyxVQUExRCxHQUF1RTtBQUNySixtQkFBTyxlQUQ4STtBQUVySixvQkFBUSxPQUFPLGVBQVAsRUFBd0IsTUFGcUg7QUFHckosa0JBQU0sT0FBTyxlQUFQLEVBQXdCLElBSHVIO0FBSXJKLG1CQUFPO0FBSjhJLFNBQXRGLENBQW5FO0FBTUEsYUFBSyxVQUFMLENBQWdCLGNBQWhCLElBQWtDLEtBQUssT0FBTCxDQUFhLGNBQWIsSUFBK0IsS0FBSyxTQUFMLENBQWUsZ0JBQWdCLGFBQWEsVUFBN0IsR0FBMEMsYUFBYSxVQUF2RCxHQUFvRTtBQUNoSixtQkFBTyxjQUR5STtBQUVoSixvQkFBUSxPQUFPLGNBQVAsRUFBdUIsTUFGaUg7QUFHaEosa0JBQU0sT0FBTyxjQUFQLEVBQXVCLElBSG1IO0FBSWhKLDhCQUFrQixLQUo4SDtBQUtoSixzQkFBVSxLQUFLLElBQUwsQ0FBVSxVQUFWLENBQXFCLHFCQUxpSDtBQU1oSixtQkFBTztBQU55SSxTQUFuRixDQUFqRTs7QUFTQSxhQUFLLE9BQUwsQ0FBYSxlQUFiLEVBQThCLFVBQTlCLENBQXlDLGVBQXpDLEdBQTJELEtBQUssT0FBTCxDQUFhLGNBQWIsRUFBNkIsVUFBN0IsQ0FBd0MsZUFBeEMsR0FBMEQsQ0FBQyxjQUFjLE9BQWYsQ0FBckg7O0FBRUE7QUFDQSxhQUFLLElBQUwsQ0FBVSxRQUFWLENBQW1CLHlCQUFuQjtBQUNILEtBdk5rQzs7QUF5Tm5DLHFCQUFpQix5QkFBUyxDQUFULEVBQVk7QUFDekIsZUFBTyxLQUFLLE9BQUwsQ0FBYSxDQUFiLEtBQW1CLEtBQUssT0FBTCxDQUFhLFNBQVMsQ0FBVCxFQUFZLEVBQVosQ0FBYixDQUExQjtBQUNILEtBM05rQzs7QUE2Tm5DOzs7Ozs7QUFNQSwwQkFBc0IsOEJBQVMsYUFBVCxFQUF3QjtBQUMxQyxZQUFJLFFBQVEseUJBQXlCLE1BQXpCLEdBQWtDLGNBQWMsS0FBaEQsR0FBd0QsYUFBcEU7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxPQUFMLENBQWEsTUFBakMsRUFBeUMsRUFBRSxDQUEzQyxFQUE4QztBQUMxQyxnQkFBSSxLQUFLLE9BQUwsQ0FBYSxDQUFiLEVBQWdCLEtBQWhCLEtBQTBCLEtBQTlCLEVBQXFDO0FBQ2pDLHVCQUFPLENBQVA7QUFDSDtBQUNKO0FBQ0osS0ExT2tDOztBQTRPbkMsZUFBVyxtQkFBUyxDQUFULEVBQVk7QUFDbkIsZUFBTyxLQUFLLFVBQUwsQ0FBZ0IsQ0FBaEIsQ0FBUDtBQUNILEtBOU9rQzs7QUFnUG5DOzs7Ozs7QUFNQSxzQkFBa0IsMEJBQVMsQ0FBVCxFQUFZLFVBQVosRUFBd0I7QUFDdEMsWUFBSSxVQUFKLEVBQWdCO0FBQ1osY0FBRSxDQUFGO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsY0FBRSxDQUFGO0FBQ0g7O0FBRUQsWUFBSSxNQUFNLEtBQUssZUFBWCxJQUE4QixDQUFDLEtBQUssSUFBTCxDQUFVLFVBQVYsQ0FBcUIsY0FBeEQsRUFBd0U7QUFDcEUsbUJBQU8sS0FBSyxnQkFBTCxDQUFzQixDQUF0QixFQUF5QixVQUF6QixDQUFQO0FBQ0g7O0FBRUQsWUFBSSxNQUFNLEtBQUssY0FBWCxJQUE2QixDQUFDLEtBQUssSUFBTCxDQUFVLFVBQVYsQ0FBcUIsZ0JBQXZELEVBQXlFO0FBQ3JFLG1CQUFPLEtBQUssZ0JBQUwsQ0FBc0IsQ0FBdEIsRUFBeUIsVUFBekIsQ0FBUDtBQUNIOztBQUVELGVBQU8sS0FBSyxTQUFMLENBQWUsQ0FBZixDQUFQO0FBQ0gsS0F0UWtDOztBQXdRbkMsZUFBVyxtQkFBUyxPQUFULEVBQWtCO0FBQ3pCLGVBQU8sSUFBSSxNQUFKLENBQVcsSUFBWCxFQUFpQixPQUFqQixDQUFQO0FBQ0gsS0ExUWtDOztBQTRRbkMsZUFBVyxtQkFBUyxPQUFULEVBQWtCO0FBQ3pCLFlBQUksU0FBUyxLQUFLLFNBQUwsQ0FBZSxPQUFmLENBQWI7QUFDQSxhQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLE1BQWxCO0FBQ0EsYUFBSyxVQUFMLENBQWdCLElBQWhCLENBQXFCLE1BQXJCO0FBQ0EsZUFBTyxNQUFQO0FBQ0gsS0FqUmtDOztBQW1SbkMsbUJBQWUseUJBQVc7QUFDdEIsYUFBSyxZQUFMO0FBQ0E7QUFDSCxLQXRSa0M7O0FBd1JuQyxvQkFBZ0Isd0JBQVMsQ0FBVCxFQUFZO0FBQ3hCLFlBQUksU0FBUyxLQUFLLGVBQUwsQ0FBcUIsQ0FBckIsQ0FBYjtBQUNBLFlBQUksQ0FBQyxNQUFMLEVBQWE7QUFDVCxtQkFBTyxLQUFLLElBQUwsQ0FBVSxVQUFWLENBQXFCLGtCQUE1QjtBQUNIO0FBQ0QsZUFBTyxPQUFPLFFBQVAsTUFBcUIsS0FBSyxJQUFMLENBQVUsVUFBVixDQUFxQixVQUFyQixHQUFrQyxLQUFLLElBQUwsQ0FBVSxVQUFWLENBQXFCLGNBQXZELEdBQXdFLENBQTdGLENBQVA7QUFDSCxLQTlSa0M7O0FBZ1NuQzs7Ozs7QUFLQSxvQkFBZ0Isd0JBQVMsYUFBVCxFQUF3QixLQUF4QixFQUErQjtBQUMzQyxZQUFJLFNBQVMsaUJBQWlCLENBQUMsQ0FBbEIsR0FBc0IsS0FBSyxlQUFMLENBQXFCLGFBQXJCLENBQXRCLEdBQTRELGFBQXpFO0FBQ0EsZUFBTyxRQUFQLENBQWdCLEtBQWhCO0FBQ0EsYUFBSyxZQUFMO0FBQ0EsYUFBSyxJQUFMLENBQVUsaUNBQVYsQ0FBNEMsYUFBNUMsRUFBMkQsS0FBM0Q7QUFDSCxLQTFTa0M7O0FBNFNuQzs7Ozs7Ozs7O0FBU0EsMkJBQXVCLCtCQUFTLEdBQVQsRUFBYyxXQUFkLEVBQTJCO0FBQzlDLGFBQUssSUFBSSxHQUFULElBQWdCLEdBQWhCLEVBQXFCO0FBQ2pCLGdCQUNJLElBQUksY0FBSixDQUFtQixHQUFuQixNQUNJLGdCQUFnQixTQUFoQixJQUNBLENBQUMsV0FBRCxJQUFnQixtQkFBbUIsT0FBbkIsQ0FBMkIsR0FBM0IsS0FBbUMsQ0FEbkQsSUFFQSxlQUFlLG1CQUFtQixPQUFuQixDQUEyQixHQUEzQixJQUFrQyxDQUhyRCxDQURKLEVBTUU7QUFDRSx1QkFBTyxJQUFJLEdBQUosQ0FBUDtBQUNIO0FBQ0o7QUFDSixLQWpVa0M7O0FBbVVuQztBQUNBLGNBQVUsb0JBQVc7QUFDakIsWUFBSSxPQUFPLEtBQUssS0FBTCxDQUFXLEtBQUssU0FBTCxDQUFlLEtBQUssSUFBTCxDQUFVLFVBQXpCLENBQVgsQ0FBWDtBQUNBLGFBQUsscUJBQUwsQ0FBMkIsS0FBSyxnQkFBaEMsRUFBa0QsS0FBbEQ7QUFDQSxlQUFPLElBQVA7QUFDSCxLQXhVa0M7QUF5VW5DOzs7O0FBSUEsZ0JBQVksc0JBQVc7QUFDbkIsYUFBSyxJQUFMLENBQVUsVUFBVjtBQUNBLGFBQUssYUFBTDtBQUNILEtBaFZrQzs7QUFrVm5DOzs7Ozs7QUFNQSxjQUFVLGtCQUFTLE9BQVQsRUFBa0I7QUFDeEIsYUFBSyxVQUFMO0FBQ0EsYUFBSyxRQUFMLENBQWMsT0FBZDtBQUNILEtBM1ZrQzs7QUE2Vm5DOzs7OztBQUtBLGNBQVUsa0JBQVMsVUFBVCxFQUFxQjtBQUMzQixlQUFPLE1BQVAsQ0FBYyxLQUFLLElBQUwsQ0FBVSxVQUF4QixFQUFvQyxVQUFwQztBQUNBLGFBQUssc0JBQUwsQ0FBNEIsV0FBVyxnQkFBdkM7QUFDQSxhQUFLLE9BQUw7QUFDSCxLQXRXa0M7O0FBd1duQzs7Ozs7OztBQU9BLDRCQUF3QixnQ0FBUyxnQkFBVCxFQUEyQjtBQUMvQyxZQUFJLGdCQUFKLEVBQXNCO0FBQ2xCLDZCQUFpQixPQUFqQixDQUF5QixVQUFTLFVBQVQsRUFBcUIsQ0FBckIsRUFBd0I7QUFDN0Msb0JBQUksVUFBSixFQUFnQjtBQUNaLHlCQUFLLFNBQUwsQ0FBZSxDQUFmLEVBQWtCLFVBQWxCLEdBQStCLFVBQS9CO0FBQ0g7QUFDSixhQUpELEVBSUcsSUFKSDtBQUtIO0FBQ0osS0F2WGtDOztBQXlYbkMsb0JBQWdCLHdCQUFTLGFBQVQsRUFBd0I7QUFDcEMsWUFBSSxNQUFNLE9BQU4sQ0FBYyxhQUFkLENBQUosRUFBaUM7QUFDN0IsaUJBQUssT0FBTCxDQUFhLE1BQWIsR0FBc0IsY0FBYyxNQUFwQztBQUNBLDBCQUFjLE9BQWQsQ0FBc0IsVUFBUyxLQUFULEVBQWdCLENBQWhCLEVBQW1CO0FBQ3JDLHFCQUFLLE9BQUwsQ0FBYSxDQUFiLElBQWtCLEtBQUssVUFBTCxDQUFnQixLQUFoQixDQUFsQjtBQUNILGFBRkQsRUFFRyxJQUZIO0FBR0g7QUFDSixLQWhZa0M7O0FBa1luQywwQkFBc0IsOEJBQVMsV0FBVCxFQUFzQjtBQUN4QyxZQUFJLE1BQU0sT0FBTixDQUFjLFdBQWQsQ0FBSixFQUErQjtBQUMzQixpQkFBSyxPQUFMLENBQWEsTUFBYixHQUFzQixZQUFZLE1BQWxDO0FBQ0Esd0JBQVksT0FBWixDQUFvQixVQUFTLFVBQVQsRUFBcUIsQ0FBckIsRUFBd0I7QUFDeEMscUJBQUssT0FBTCxDQUFhLENBQWIsSUFBa0IsS0FBSyxVQUFMLENBQWdCLElBQWhCLENBQXFCLFVBQVMsTUFBVCxFQUFpQjtBQUNwRCwyQkFBTyxPQUFPLElBQVAsS0FBZ0IsVUFBdkI7QUFDSCxpQkFGaUIsQ0FBbEI7QUFHSCxhQUpELEVBSUcsSUFKSDtBQUtIO0FBQ0osS0EzWWtDOztBQTZZbkM7Ozs7OztBQU1BLHNCQUFrQiwwQkFBUyxhQUFULEVBQXdCLE1BQXhCLEVBQWdDO0FBQzlDLGFBQUssSUFBTCxDQUFVLFVBQVYsQ0FBcUIsYUFBckIsR0FBcUMsYUFBckM7QUFDQSxZQUFJLENBQUMsTUFBTCxFQUFhO0FBQ1QsaUJBQUssSUFBTCxDQUFVLGtDQUFWO0FBQ0g7QUFDSixLQXhaa0M7O0FBMFpuQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQSxpQkFBYSxxQkFBUyxxQkFBVCxFQUFnQyxhQUFoQyxFQUErQyxjQUEvQyxFQUErRCxxQkFBL0QsRUFBc0Y7QUFDL0Y7QUFDQSxZQUFJLE9BQU8scUJBQVAsS0FBaUMsUUFBakMsSUFBNkMsTUFBTSxPQUFOLENBQWMscUJBQWQsQ0FBakQsRUFBdUY7QUFDbkYsb0NBQXdCLGNBQXhCO0FBQ0EsNkJBQWlCLGFBQWpCO0FBQ0EsNEJBQWdCLHFCQUFoQjtBQUNBLG9DQUF3QixLQUF4QjtBQUNIOztBQUVELFlBQUksZ0JBQWdCLEtBQUssT0FBekI7QUFBQSxZQUNJLG1CQUFtQix3QkFBd0IsYUFBeEIsR0FBd0MsS0FBSyxVQURwRTs7QUFHQTtBQUNBLFlBQUksT0FBTyxhQUFQLEtBQXlCLFFBQTdCLEVBQXVDO0FBQ25DLDRCQUFnQixDQUFDLGFBQUQsQ0FBaEI7QUFDSDs7QUFFRCxZQUFJLGFBQWE7QUFDYjtBQURhLFNBRVosR0FGWSxDQUVSLFVBQVMsS0FBVCxFQUFnQjtBQUFFLG1CQUFPLGlCQUFpQixLQUFqQixDQUFQO0FBQWlDLFNBRjNDO0FBR2I7QUFIYSxTQUlaLE1BSlksQ0FJTCxVQUFTLE1BQVQsRUFBaUI7QUFBRSxtQkFBTyxNQUFQO0FBQWdCLFNBSjlCLENBQWpCOztBQU1BO0FBQ0EsWUFBSSxPQUFPLGNBQVAsS0FBMEIsUUFBOUIsRUFBd0M7QUFDcEMsb0NBQXdCLGNBQXhCLENBRG9DLENBQ0k7QUFDeEMsNkJBQWlCLGNBQWMsTUFBL0I7QUFDSDs7QUFFRDtBQUNBLFlBQUksQ0FBQyxxQkFBTCxFQUE0QjtBQUN4Qix1QkFBVyxPQUFYLENBQW1CLFVBQVMsTUFBVCxFQUFpQjtBQUNoQyxvQkFBSSxJQUFJLGNBQWMsT0FBZCxDQUFzQixNQUF0QixDQUFSO0FBQ0Esb0JBQUksS0FBSyxDQUFULEVBQVk7QUFDUixrQ0FBYyxNQUFkLENBQXFCLENBQXJCLEVBQXdCLENBQXhCO0FBQ0Esd0JBQUksaUJBQWlCLENBQXJCLEVBQXdCO0FBQ3BCLDBCQUFFLGNBQUY7QUFDSDtBQUNKO0FBQ0osYUFSRDtBQVNIOztBQUVEO0FBQ0EsWUFBSSxrQkFBa0IsQ0FBdEIsRUFBeUI7QUFDckIsMEJBQWMsTUFBZCxDQUFxQixLQUFyQixDQUEyQixhQUEzQixFQUEwQyxDQUFDLGNBQUQsRUFBaUIsQ0FBakIsRUFBb0IsTUFBcEIsQ0FBMkIsVUFBM0IsQ0FBMUM7QUFDSDs7QUFFRCxhQUFLLElBQUwsQ0FBVSxVQUFWLENBQXFCLGFBQXJCLEdBQXFDLGNBQWMsR0FBZCxDQUFrQixVQUFTLE1BQVQsRUFBaUI7QUFBRSxtQkFBTyxPQUFPLEtBQWQ7QUFBc0IsU0FBM0QsQ0FBckM7QUFDSCxLQW5la0M7O0FBcWVuQzs7Ozs7Ozs7Ozs7OztBQWFBLGlCQUFhLHFCQUFTLHFCQUFULEVBQWdDLGFBQWhDLEVBQStDO0FBQ3hELFlBQUksT0FBTyxNQUFNLFNBQU4sQ0FBZ0IsS0FBaEIsQ0FBc0IsSUFBdEIsQ0FBMkIsU0FBM0IsQ0FBWCxDQUR3RCxDQUNOO0FBQ2xELGFBQUssSUFBTCxDQUFVLENBQUMsQ0FBWCxFQUZ3RCxDQUV6QztBQUNmLGFBQUssV0FBTCxDQUFpQixLQUFqQixDQUF1QixJQUF2QixFQUE2QixJQUE3QjtBQUNILEtBdGZrQzs7QUF3Zm5DOzs7Ozs7QUFNQSxxQkFBaUIseUJBQVMsR0FBVCxFQUFjO0FBQzNCO0FBQ0EsZUFBTyxLQUFLLElBQUwsQ0FBVSxlQUFWLENBQTBCLEdBQTFCLENBQVA7QUFDSCxLQWpnQmtDOztBQW1nQm5DLG1CQUFlLHVCQUFTLEdBQVQsRUFBYztBQUN6QixlQUFPLEtBQUssVUFBTCxDQUFnQixHQUFoQixDQUFQO0FBQ0gsS0FyZ0JrQzs7QUF1Z0JuQzs7Ozs7O0FBTUEsY0FBVSxrQkFBUyxZQUFULEVBQXVCLENBQXZCLEVBQTBCLFNBQTFCLEVBQXFDO0FBQzNDLFlBQUksUUFBTyxZQUFQLHlDQUFPLFlBQVAsT0FBd0IsUUFBNUIsRUFBc0M7QUFDbEMsZ0JBQUksSUFBSSxZQUFSO0FBQ0EsMkJBQWUsSUFBSSxLQUFLLFNBQVQsRUFBZjtBQUNBLGdCQUFJLFNBQUosRUFBZTtBQUNYLDZCQUFhLFdBQWIsQ0FBeUIsQ0FBekIsRUFBNEIsQ0FBNUIsRUFBK0IsU0FBL0I7QUFDSCxhQUZELE1BRU87QUFDSCw2QkFBYSxXQUFiLENBQXlCLENBQXpCLEVBQTRCLENBQTVCO0FBQ0g7QUFDSjtBQUNELGVBQU8sYUFBYSxLQUFwQjtBQUNILEtBeGhCa0M7O0FBMGhCbkM7Ozs7Ozs7Ozs7QUFVQSxjQUFVLGtCQUFTLFlBQVQsRUFBdUIsQ0FBdkIsRUFBMEIsS0FBMUIsRUFBaUMsU0FBakMsRUFBNEM7QUFDbEQsWUFBSSxRQUFPLFlBQVAseUNBQU8sWUFBUCxPQUF3QixRQUE1QixFQUFzQztBQUNsQyxvQkFBUSxDQUFSO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsZ0JBQUksSUFBSSxZQUFSO0FBQ0EsMkJBQWUsSUFBSSxLQUFLLFNBQVQsRUFBZjtBQUNBLGdCQUFJLFNBQUosRUFBZTtBQUNYLDZCQUFhLFdBQWIsQ0FBeUIsQ0FBekIsRUFBNEIsQ0FBNUIsRUFBK0IsU0FBL0I7QUFDSCxhQUZELE1BRU87QUFDSCw2QkFBYSxXQUFiLENBQXlCLENBQXpCLEVBQTRCLENBQTVCO0FBQ0g7QUFDSjtBQUNELHFCQUFhLEtBQWIsR0FBcUIsS0FBckI7QUFDSCxLQWpqQmtDOztBQW1qQm5DOzs7O0FBSUEsMEJBQXNCLGdDQUFXO0FBQzdCLFlBQUksUUFBUSxLQUFLLG1CQUFMLEVBQVo7QUFBQSxZQUNJLFFBQVEsQ0FEWjtBQUFBLFlBRUksSUFBSSxLQUFLLGdCQUZiOztBQUlBLGVBQU8sSUFBSSxLQUFYLEVBQWtCLEdBQWxCLEVBQXVCO0FBQ25CLHFCQUFTLEtBQUssY0FBTCxDQUFvQixDQUFwQixDQUFUO0FBQ0g7QUFDRCxlQUFPLEtBQVA7QUFDSCxLQWhrQmtDOztBQWtrQm5DOzs7O0FBSUEscUJBQWlCLHlCQUFTLEdBQVQsRUFBYztBQUMzQixZQUFJLFFBQVEsUUFBUSxTQUFSLEdBQW9CLEtBQUssb0JBQUwsRUFBcEIsR0FBa0QsR0FBOUQ7QUFBQSxZQUNJLFFBQVEsQ0FEWjtBQUFBLFlBRUksSUFBSSxLQUFLLGdCQUZiOztBQUlBLGVBQU8sSUFBSSxLQUFYLEVBQWtCLEdBQWxCLEVBQXVCO0FBQ25CLHFCQUFTLEtBQUssY0FBTCxDQUFvQixDQUFwQixDQUFUO0FBQ0g7QUFDRCxlQUFPLEtBQVA7QUFDSCxLQS9rQmtDOztBQWlsQm5DOzs7OztBQUtBLDZCQUF5QixtQ0FBVztBQUNoQyxlQUFPLEtBQUssb0JBQUwsRUFBUDtBQUNILEtBeGxCa0M7O0FBMGxCbkM7Ozs7O0FBS0EsZUFBVyxtQkFBUyxJQUFULEVBQWU7QUFDdEIsYUFBSyxZQUFMO0FBQ0EsYUFBSyxZQUFMLENBQWtCLFNBQWxCLENBQTRCLElBQTVCO0FBQ0gsS0FsbUJrQzs7QUFvbUJuQzs7Ozs7O0FBTUEsaUJBQWEscUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDL0IsWUFBSSxLQUFLLFlBQVQsRUFBdUI7QUFDbkIsaUJBQUssWUFBTCxDQUFrQixlQUFsQixDQUFrQyxJQUFsQyxFQUF3QyxLQUF4QztBQUNBLGlCQUFLLFNBQUwsQ0FBZSxJQUFmO0FBQ0g7QUFDSixLQS9tQmtDOztBQWluQm5DOzs7Ozs7QUFNQSxhQUFTLGlCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQzNCLFlBQUksS0FBSyxZQUFULEVBQXVCO0FBQ25CLGlCQUFLLFlBQUwsQ0FBa0IsV0FBbEIsQ0FBOEIsSUFBOUIsRUFBb0MsS0FBcEM7QUFDQSxpQkFBSyxTQUFMLENBQWUsSUFBZjtBQUNIO0FBQ0osS0E1bkJrQzs7QUE4bkJuQzs7Ozs7O0FBTUEsbUJBQWUsdUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDakMsWUFBSSxLQUFLLFlBQVQsRUFBdUI7QUFDbkIsaUJBQUssWUFBTCxDQUFrQixpQkFBbEIsQ0FBb0MsSUFBcEMsRUFBMEMsS0FBMUM7QUFDQSxpQkFBSyxTQUFMLENBQWUsSUFBZjtBQUNIO0FBQ0osS0F6b0JrQzs7QUEyb0JuQzs7Ozs7O0FBTUEsa0JBQWMsc0JBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDaEMsWUFBSSxLQUFLLFlBQVQsRUFBdUI7QUFDbkIsaUJBQUssWUFBTCxDQUFrQixnQkFBbEIsQ0FBbUMsSUFBbkMsRUFBeUMsS0FBekM7QUFDQSxpQkFBSyxTQUFMLENBQWUsSUFBZjtBQUNIO0FBQ0osS0F0cEJrQzs7QUF3cEJuQzs7Ozs7O0FBTUEsb0JBQWdCLHdCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ2xDLFlBQUksS0FBSyxZQUFULEVBQXVCO0FBQ25CLGlCQUFLLFlBQUwsQ0FBa0Isa0JBQWxCLENBQXFDLElBQXJDLEVBQTJDLEtBQTNDO0FBQ0EsaUJBQUssU0FBTCxDQUFlLElBQWY7QUFDSDtBQUNKLEtBbnFCa0M7O0FBcXFCbkMsMEJBQXNCLDhCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ3hDLFlBQUksS0FBSyxZQUFULEVBQXVCO0FBQ25CLGlCQUFLLFlBQUwsQ0FBa0Isd0JBQWxCLENBQTJDLElBQTNDLEVBQWlELEtBQWpEO0FBQ0g7QUFDSixLQXpxQmtDOztBQTJxQm5DOzs7Ozs7QUFNQSxlQUFXLG1CQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQzdCLFlBQUksS0FBSyxZQUFULEVBQXVCO0FBQ25CLGlCQUFLLFlBQUwsQ0FBa0IsYUFBbEIsQ0FBZ0MsSUFBaEMsRUFBc0MsS0FBdEM7QUFDQSxpQkFBSyxTQUFMLENBQWUsSUFBZjtBQUNIO0FBQ0osS0F0ckJrQzs7QUF3ckJuQzs7Ozs7O0FBTUEsaUJBQWEscUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDL0IsWUFBSSxLQUFLLFlBQVQsRUFBdUI7QUFDbkIsaUJBQUssWUFBTCxDQUFrQixlQUFsQixDQUFrQyxJQUFsQyxFQUF3QyxLQUF4QztBQUNBLGlCQUFLLFNBQUwsQ0FBZSxJQUFmO0FBQ0g7QUFDSixLQW5zQmtDOztBQXFzQm5DOzs7Ozs7QUFNQSxlQUFXLG1CQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQzdCLFlBQUksS0FBSyxZQUFULEVBQXVCO0FBQ25CLGlCQUFLLFlBQUwsQ0FBa0IsYUFBbEIsQ0FBZ0MsSUFBaEMsRUFBc0MsS0FBdEM7QUFDQSxpQkFBSyxTQUFMLENBQWUsSUFBZjtBQUNIO0FBQ0QsWUFBSSxLQUFLLGVBQUwsSUFBd0IsTUFBTSxNQUFOLENBQWEsSUFBYixLQUFzQixHQUE5QyxJQUFxRCxNQUFNLE1BQU4sQ0FBYSxJQUFsRSxJQUEwRSxNQUFNLE1BQU4sQ0FBYSxLQUEzRixFQUFrRztBQUM5RixpQkFBSyxlQUFMO0FBQ0gsU0FGRCxNQUVPLElBQUksS0FBSyxVQUFMLElBQW1CLE1BQU0sTUFBTixDQUFhLElBQWIsS0FBc0IsR0FBekMsSUFBZ0QsTUFBTSxNQUFOLENBQWEsSUFBakUsRUFBdUU7QUFDMUUsaUJBQUssVUFBTDtBQUNIO0FBQ0osS0FydEJrQzs7QUF1dEJuQyx3QkFBb0IsNEJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDdEMsWUFBSSxLQUFLLFlBQVQsRUFBdUI7QUFDbkIsaUJBQUssWUFBTCxDQUFrQixrQkFBbEIsQ0FBcUMsSUFBckMsRUFBMkMsS0FBM0M7QUFDSDtBQUNKLEtBM3RCa0M7O0FBNnRCbkM7Ozs7OztBQU1BLGFBQVMsaUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDM0IsWUFBSSxLQUFLLFlBQVQsRUFBdUI7QUFDbkIsaUJBQUssWUFBTCxDQUFrQixXQUFsQixDQUE4QixJQUE5QixFQUFvQyxLQUFwQztBQUNBLGlCQUFLLFNBQUwsQ0FBZSxJQUFmO0FBQ0g7QUFDSixLQXh1QmtDOztBQTB1Qm5DOzs7Ozs7QUFNQSxpQkFBYSxxQkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUMvQixZQUFJLEtBQUssWUFBVCxFQUF1QjtBQUNuQixpQkFBSyxZQUFMLENBQWtCLGVBQWxCLENBQWtDLElBQWxDLEVBQXdDLEtBQXhDO0FBQ0g7QUFDSixLQXB2QmtDOztBQXN2Qm5DOzs7Ozs7QUFNQSxtQkFBZSx1QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNqQyxZQUFJLEtBQUssWUFBVCxFQUF1QjtBQUNuQixpQkFBSyxZQUFMLENBQWtCLGlCQUFsQixDQUFvQyxJQUFwQyxFQUEwQyxLQUExQztBQUNBLGlCQUFLLFNBQUwsQ0FBZSxJQUFmO0FBQ0g7QUFDSixLQWp3QmtDO0FBa3dCbkM7Ozs7OztBQU1BLHFCQUFpQix5QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNuQyxZQUFJLEtBQUssWUFBVCxFQUF1QjtBQUNuQixpQkFBSyxZQUFMLENBQWtCLGVBQWxCLENBQWtDLElBQWxDLEVBQXdDLEtBQXhDO0FBQ0EsaUJBQUssU0FBTCxDQUFlLElBQWY7QUFDSDtBQUNKLEtBN3dCa0M7O0FBK3dCbkM7Ozs7OztBQU1BLGtDQUE4QixzQ0FBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNoRCxZQUFJLEtBQUssWUFBVCxFQUF1QjtBQUNuQixpQkFBSyxZQUFMLENBQWtCLDRCQUFsQixDQUErQyxJQUEvQyxFQUFxRCxLQUFyRDtBQUNBLGlCQUFLLFNBQUwsQ0FBZSxJQUFmO0FBQ0g7QUFDSixLQTF4QmtDOztBQTR4Qm5DOzs7Ozs7QUFNQSxxQkFBaUIseUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDbkMsWUFBSSxLQUFLLFlBQVQsRUFBdUI7QUFDbkIsaUJBQUssWUFBTCxDQUFrQixlQUFsQixDQUFrQyxJQUFsQyxFQUF3QyxLQUF4QztBQUNBLGlCQUFLLFNBQUwsQ0FBZSxJQUFmO0FBQ0g7QUFDSixLQXZ5QmtDOztBQXl5Qm5DOzs7O0FBSUEsYUFBUyxtQkFBVztBQUFFLGFBQUssSUFBTCxDQUFVLGVBQVY7QUFBOEIsS0E3eUJqQjs7QUEreUJuQzs7OztBQUlBLGtCQUFjLHdCQUFXO0FBQUUsYUFBSyxJQUFMLENBQVUsb0JBQVY7QUFBbUMsS0FuekIzQjs7QUFxekJuQzs7OztBQUlBLGtCQUFjLHdCQUFXO0FBQUUsYUFBSyxJQUFMLENBQVUsb0JBQVY7QUFBbUMsS0F6ekIzQjs7QUEyekJuQzs7OztBQUlBLHlCQUFxQiwrQkFBVztBQUM1QixlQUFPLEtBQUssVUFBTCxDQUFnQix1QkFBaEIsRUFBeUMsb0NBQXpDLEVBQStFLE9BQS9FLENBQVA7QUFDSCxLQWowQmtDOztBQW0wQm5DOzs7OztBQUtBLHlCQUFxQiw2QkFBUyxDQUFULEVBQVk7QUFDN0IsWUFBSSxTQUFTLEtBQUssU0FBTCxDQUFlLENBQWYsQ0FBYjtBQUNBLGVBQU8sVUFBVSxPQUFPLFVBQXhCO0FBQ0gsS0EzMEJrQzs7QUE2MEJuQzs7Ozs7QUFLQSx5QkFBcUIsNkJBQVMsQ0FBVCxFQUFZLFVBQVosRUFBd0I7QUFDekMsWUFBSSxTQUFTLEtBQUssU0FBTCxDQUFlLENBQWYsQ0FBYjtBQUNBLFlBQUksQ0FBQyxNQUFMLEVBQWE7QUFDVCxrQkFBTSxrQkFBTjtBQUNIO0FBQ0QsWUFBSSxTQUFTLE9BQU8sTUFBUCxDQUFjLE9BQU8sVUFBckIsRUFBaUMsVUFBakMsQ0FBYjtBQUNBLGFBQUssT0FBTDtBQUNBLGVBQU8sTUFBUDtBQUNILEtBMTFCa0M7O0FBNDFCbkM7Ozs7O0FBS0EsNEJBQXdCLGdDQUFTLENBQVQsRUFBWTtBQUNoQyxZQUFJLE1BQU0sU0FBVixFQUFxQjtBQUNqQixnQkFBSSxTQUFTLEtBQUssU0FBTCxDQUFlLENBQWYsQ0FBYjtBQUNBLGdCQUFJLE1BQUosRUFBWTtBQUNSLHVCQUFPLHNCQUFQO0FBQ0g7QUFDSixTQUxELE1BS08sSUFBSSxLQUFLLFFBQVQsRUFBbUI7QUFDdEIsaUJBQUssUUFBTCxDQUFjLE9BQWQsQ0FBc0IsVUFBUyxTQUFULEVBQW9CO0FBQ3RDLHFCQUFLLElBQUksSUFBSSxVQUFVLFdBQVYsRUFBYixFQUFzQyxHQUF0QyxHQUE0QztBQUN4Qyw4QkFBVSxjQUFWLENBQXlCLENBQXpCO0FBQ0g7QUFDSixhQUpEO0FBS0g7QUFDSixLQTkyQmtDOztBQWczQm5DOzs7O0FBSUEsZ0NBQTRCLHNDQUFXO0FBQ25DLFlBQUksYUFBYSxLQUFLLElBQUwsQ0FBVSxVQUEzQjtBQUNBLFlBQUksVUFBVSxXQUFXLGFBQXpCO0FBQ0EsWUFBSSxTQUFTLEVBQWI7QUFDQSxZQUFJLGNBQWMsS0FBSyxvQkFBTCxFQUFsQjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxXQUFwQixFQUFpQyxHQUFqQyxFQUFzQztBQUNsQyxnQkFBSSxRQUFRLE9BQVIsQ0FBZ0IsQ0FBaEIsTUFBdUIsQ0FBQyxDQUE1QixFQUErQjtBQUMzQixvQkFBSSxTQUFTLEtBQUssZUFBTCxDQUFxQixDQUFyQixDQUFiO0FBQ0EsdUJBQU8sSUFBUCxDQUFZO0FBQ1Isd0JBQUksQ0FESTtBQUVSLDRCQUFRLE9BQU8sTUFGUDtBQUdSLDJCQUFPLE9BQU87QUFITixpQkFBWjtBQUtIO0FBQ0o7QUFDRCxlQUFPLE1BQVA7QUFDSCxLQXA0QmtDOztBQXM0Qm5DOzs7O0FBSUEseUJBQXFCLCtCQUFXO0FBQzVCLGVBQU8sS0FBSyxJQUFMLENBQVUsVUFBVixDQUFxQixnQkFBNUI7QUFDSCxLQTU0QmtDOztBQTg0Qm5DOzs7OztBQUtBLHlCQUFxQiw2QkFBUyxDQUFULEVBQVk7QUFDN0IsYUFBSyxJQUFMLENBQVUsVUFBVixDQUFxQixnQkFBckIsR0FBd0MsQ0FBeEM7QUFDSCxLQXI1QmtDOztBQXU1Qm5DOzs7Ozs7OztBQVFBLHNCQUFrQiw0QkFBVztBQUN6QixlQUNJLEtBQUssaUJBQUwsS0FDQSxLQUFLLElBQUwsQ0FBVSxVQUFWLENBQXFCLGFBRnpCO0FBSUgsS0FwNkJrQzs7QUFzNkJuQzs7Ozs7Ozs7Ozs7OztBQWFBLHNCQUFrQiwwQkFBUyxDQUFULEVBQVk7QUFDMUIsYUFBSyxJQUFMLENBQVUsVUFBVixDQUFxQixhQUFyQixHQUFxQyxDQUFyQztBQUNILEtBcjdCa0M7O0FBdTdCbkM7Ozs7QUFJQSwrQkFBMkIscUNBQVcsQ0FBRSxDQTM3Qkw7O0FBNjdCbkM7Ozs7OztBQU1BLGlCQUFhLHFCQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDeEIsZUFBTyxJQUFQO0FBQ0gsS0FyOEJrQzs7QUF1OEJuQzs7Ozs7QUFLQSwwQkFBc0IsZ0NBQVc7QUFDN0IsZUFBTyxLQUFLLE9BQUwsQ0FBYSxNQUFwQjtBQUNILEtBOThCa0M7O0FBZzlCbkM7Ozs7Ozs7Ozs7OztBQVlBLHdCQUFvQiw0QkFBUyxDQUFULEVBQVk7QUFDNUI7Ozs7QUFJQSxhQUFLLGVBQUwsR0FBdUIsQ0FBdkI7QUFDSCxLQWwrQmtDOztBQW8rQm5DLHdCQUFvQiw4QkFBVztBQUMzQixlQUFPLEtBQUssZUFBWjtBQUNILEtBdCtCa0M7O0FBdytCbkM7Ozs7O0FBS0Esd0JBQW9CLDRCQUFTLENBQVQsRUFBWTtBQUM1Qjs7OztBQUlBLGFBQUssZUFBTCxHQUF1QixDQUF2QjtBQUNILEtBbi9Ca0M7O0FBcS9CbkMsd0JBQW9CLDhCQUFXO0FBQzNCLGVBQU8sS0FBSyxlQUFaO0FBQ0gsS0F2L0JrQzs7QUF5L0JuQzs7Ozs7QUFLQSxxQkFBaUIseUJBQVMsS0FBVCxFQUFnQjtBQUM3QixlQUFPLE1BQU0sWUFBTixJQUFzQixNQUFNLE1BQU4sQ0FBYSxlQUFiLENBQTZCLEtBQTdCLENBQTdCO0FBQ0gsS0FoZ0NrQzs7QUFrZ0NuQzs7Ozs7O0FBTUEsMEJBQXNCLDhCQUFTLGVBQVQsRUFBMEIsWUFBMUIsRUFBd0M7QUFDMUQsZUFBTyxtQkFBbUIsWUFBMUI7QUFDSCxLQTFnQ2tDOztBQTRnQ25DOzs7OztBQUtBLHdDQUFvQyw0Q0FBUyxJQUFULEVBQWUsQ0FFbEQsQ0FuaENrQzs7QUFxaENuQzs7Ozs7QUFLQSxzQ0FBa0MsMENBQVMsSUFBVCxFQUFlLENBRWhELENBNWhDa0M7O0FBOGhDbkM7Ozs7O0FBS0EseUNBQXFDLDZDQUFTLElBQVQsRUFBZSxDQUVuRCxDQXJpQ2tDOztBQXVpQ25DOzs7OztBQUtBLHFDQUFpQyx5Q0FBUyxJQUFULEVBQWUsQ0FFL0MsQ0E5aUNrQzs7QUFnakNuQzs7Ozs7O0FBTUEsaUJBQWEscUJBQVMsTUFBVCxFQUFpQixNQUFqQixFQUF5QjtBQUNsQyxZQUFJLFVBQVUsS0FBSyxPQUFuQjtBQUNBLFlBQUksTUFBTSxRQUFRLE1BQVIsQ0FBVjtBQUNBLGdCQUFRLE1BQVIsSUFBa0IsUUFBUSxNQUFSLENBQWxCO0FBQ0EsZ0JBQVEsTUFBUixJQUFrQixHQUFsQjtBQUNBLGFBQUssT0FBTDtBQUNILEtBNWpDa0M7O0FBOGpDbkMsbUNBQStCLHlDQUFXO0FBQ3RDLGFBQUssSUFBTCxDQUFVLEdBQVYsQ0FBYyxhQUFkLENBQTRCLEtBQUssSUFBTCxDQUFVLFVBQXRDO0FBQ0gsS0Foa0NrQzs7QUFra0NuQyw0QkFBd0Isa0NBQVc7QUFDL0IsYUFBSyxJQUFMLENBQVUsR0FBVixDQUFjLGdCQUFkO0FBQ0gsS0Fwa0NrQzs7QUFza0NuQzs7Ozs7Ozs7OztBQVVBLGlCQUFhLHFCQUFTLElBQVQsRUFBZSxHQUFmLEVBQW9CLE1BQXBCLEVBQStFO0FBQUE7O0FBQUEsWUFBbkQsY0FBbUQsdUVBQWxDLElBQWtDO0FBQUEsWUFBNUIsa0JBQTRCLHVFQUFQLEtBQU87O0FBQ3hGLGFBQUssR0FBTCxDQUFTLGdDQUFULEVBQTJDLElBQTNDLEVBQWlELEdBQWpELEVBQXNELE1BQXRELEVBQThELGNBQTlELEVBQThFLGtCQUE5RTtBQUNBLFlBQU0sVUFBVSxLQUFLLE9BQXJCOztBQUVBLFlBQU0saUJBQWlCLEtBQUssSUFBTCxDQUFVLGlCQUFqQztBQUNBLFlBQU0sVUFBVSxLQUFLLElBQUwsQ0FBVSxVQUExQjs7QUFFQSxZQUFJLGdCQUFnQixxQkFDZCxRQUFRLEtBQVIsQ0FBYyxDQUFkLEVBQWlCLE1BQWpCLENBQXdCLElBQXhCLEVBQThCLEdBQTlCLENBRGMsR0FFZCxlQUFlLEtBQWYsQ0FBcUIsQ0FBckIsRUFBd0IsTUFBeEIsQ0FBK0IsSUFBL0IsRUFBcUMsR0FBckMsQ0FGTjs7QUFJQSxZQUFJLFVBQVUsRUFBZDtBQUNBLFlBQUksS0FBSyxJQUFMLENBQVUsVUFBVixDQUFxQixlQUF6QixFQUEwQztBQUN0QyxzQkFBVSxRQUFRLEdBQVIsQ0FBWTtBQUFBLHVCQUFLLEVBQUUsTUFBUDtBQUFBLGFBQVosQ0FBVjtBQUNIOztBQUVELFlBQUksQ0FBQyxrQkFBTCxFQUF5QjtBQUNyQixnQkFBSSwrQkFBK0IsZUFBZSxNQUFmLENBQW5DO0FBQ0EscUJBQVMsUUFBUSxPQUFSLENBQWdCLDRCQUFoQixDQUFUO0FBQ0g7O0FBRUQsWUFBSSxlQUFlLEVBQW5CO0FBQ0EsWUFBSSxrQkFBa0IsYUFBdEI7QUFDQSxZQUFJLFFBQVEsT0FBUixDQUFnQixjQUFjLENBQWQsQ0FBaEIsS0FBcUMsTUFBekMsRUFBaUQ7QUFDN0MsOEJBQWtCLGNBQWMsT0FBZCxFQUFsQjtBQUNIO0FBQ0Qsd0JBQWdCLE9BQWhCLENBQXdCLFVBQUMsTUFBRCxFQUFZO0FBQ2hDLGdCQUFJLHVCQUF1QixRQUFRLElBQVIsQ0FBYSxVQUFDLENBQUQ7QUFBQSx1QkFBTyxFQUFFLE1BQUYsS0FBYSxNQUFwQjtBQUFBLGFBQWIsQ0FBM0I7QUFDQSxnQkFBSSxvQkFBSixFQUEwQjtBQUN0Qiw2QkFBYSxPQUFiLENBQXFCLG9CQUFyQjtBQUNIOztBQUVELGdCQUFJLHFCQUFxQixRQUFRLE9BQVIsQ0FBZ0IsTUFBaEIsQ0FBekI7QUFDQSxvQkFBUSxNQUFSLENBQWUsTUFBZixFQUF1QixDQUF2QixFQUEwQixRQUFRLE1BQVIsQ0FBZSxrQkFBZixFQUFtQyxDQUFuQyxFQUFzQyxDQUF0QyxDQUExQjs7QUFFQSxrQkFBSyxHQUFMLHdCQUE4QixrQkFBOUIsa0JBQTZELE1BQTdEO0FBQ0gsU0FWRDs7QUFZQSxhQUFLLDZCQUFMOztBQUVBLFlBQUksY0FBSixFQUFvQjtBQUNoQixpQkFBSyxJQUFMLENBQVUsOEJBQVYsQ0FBeUMsWUFBekMsRUFBdUQsTUFBdkQ7QUFDSDs7QUFFRCxhQUFLLElBQUwsQ0FBVSxpQkFBVixHQUE4QixRQUFRLE1BQVIsQ0FBZSxVQUFDLEVBQUQ7QUFBQSxtQkFBUSxDQUFDLEdBQUcsUUFBWjtBQUFBLFNBQWYsQ0FBOUI7O0FBRUEsWUFBSSxLQUFLLElBQUwsQ0FBVSxVQUFWLENBQXFCLGVBQXpCLEVBQTBDO0FBQ3RDLG9CQUFRLE9BQVIsQ0FBZ0IsVUFBQyxDQUFELEVBQUksQ0FBSjtBQUFBLHVCQUFVLEVBQUUsTUFBRixHQUFXLFFBQVEsQ0FBUixDQUFyQjtBQUFBLGFBQWhCO0FBQ0g7O0FBRUQsYUFBSyxPQUFMO0FBQ0gsS0Fub0NrQzs7QUFxb0NuQyxpQ0FBNkIscUNBQVMsVUFBVCxFQUFxQjtBQUM5QyxlQUFPLElBQUksS0FBSixDQUNILEtBQUssZUFBTCxDQUFxQixXQUFXLENBQWhDLEVBQW1DLEtBRGhDLEVBRUgsV0FBVyxDQUZSLENBQVA7QUFJSCxLQTFvQ2tDOztBQTRvQ25DOzs7OztBQUtBLDZCQUF5QixpQ0FBUyxRQUFULEVBQW1CO0FBQ3hDLFlBQUksTUFBTSxLQUFLLElBQUwsQ0FBVSxNQUFWLENBQWlCLFFBQWpCLENBQVY7O0FBRUEsZUFBTyxLQUFLLGdCQUFMLENBQXNCLEdBQXRCLENBQVA7QUFDSCxLQXJwQ2tDOztBQXVwQ25DOzs7OztBQUtBLHNCQUFrQiwwQkFBUyxHQUFULEVBQWM7QUFDNUIsZUFBTyxDQUFDLENBQUMsR0FBRixJQUFTLE9BQU8sSUFBSSxhQUFYLEtBQTZCLFdBQTdDO0FBQ0gsS0E5cENrQzs7QUFncUNuQzs7Ozs7QUFLQSx5QkFBcUIsNkJBQVMsUUFBVCxFQUFtQjtBQUNwQyxZQUFJLE1BQU0sS0FBSyxJQUFMLENBQVUsTUFBVixDQUFpQixRQUFqQixDQUFWOztBQUVBLGVBQU8sS0FBSyxZQUFMLENBQWtCLEdBQWxCLENBQVA7QUFDSCxLQXpxQ2tDO0FBMHFDbkM7Ozs7O0FBS0Esa0JBQWMsc0JBQVMsR0FBVCxFQUFjO0FBQ3hCLGVBQU8sQ0FBQyxDQUFDLEdBQUYsSUFBUyxJQUFJLFVBQWIsR0FBMEIsSUFBSSxVQUE5QixHQUEyQyxFQUFsRDtBQUNILEtBanJDa0M7O0FBbXJDbkM7Ozs7O0FBS0EseUJBQXFCLDZCQUFTLFFBQVQsRUFBbUI7QUFDcEMsZUFBTyxLQUFLLG1CQUFMLENBQXlCLFFBQXpCLEVBQW1DLE1BQW5DLEdBQTRDLENBQW5EO0FBQ0gsS0ExckNrQzs7QUE0ckNuQzs7Ozs7QUFLQSxrQkFBYyxzQkFBUyxHQUFULEVBQWM7QUFDeEIsZUFBTyxLQUFLLFlBQUwsQ0FBa0IsR0FBbEIsRUFBdUIsTUFBdkIsR0FBZ0MsQ0FBdkM7QUFDSCxLQW5zQ2tDOztBQXFzQ25DOzs7OztBQUtBLHFDQUFpQyx5Q0FBUyxRQUFULEVBQW1CO0FBQ2hELFlBQUksTUFBTSxLQUFLLElBQUwsQ0FBVSxNQUFWLENBQWlCLFFBQWpCLENBQVY7O0FBRUEsZUFBTyxLQUFLLHdCQUFMLENBQThCLEdBQTlCLENBQVA7QUFDSCxLQTlzQ2tDOztBQWd0Q25DOzs7OztBQUtBLDhCQUEwQixrQ0FBUyxHQUFULEVBQWM7QUFDcEMsZUFBTyxDQUFDLENBQUMsR0FBRixJQUFTLENBQUMsQ0FBQyxJQUFJLGNBQWYsR0FBZ0MsSUFBSSxjQUFwQyxHQUFxRCxDQUE1RDtBQUNILEtBdnRDa0M7O0FBeXRDbkMsNEJBQXdCLGdDQUFTLFFBQVQsRUFBbUI7QUFDdkMsWUFBSSxNQUFNLEtBQUssSUFBTCxDQUFVLE1BQVYsQ0FBaUIsUUFBakIsQ0FBVjtBQUNBLGVBQU8sS0FBSyxlQUFMLENBQXFCLEdBQXJCLENBQVA7QUFDSCxLQTV0Q2tDOztBQTh0Q25DLHFCQUFpQix5QkFBUyxHQUFULEVBQWM7QUFDM0IsZUFBTyxDQUFDLENBQUMsR0FBRixJQUFTLElBQUksWUFBYixHQUE0QixJQUFJLFlBQWhDLEdBQStDLEtBQXREO0FBQ0gsS0FodUNrQzs7QUFrdUNuQywwQkFBc0IsOEJBQVMsUUFBVCxFQUFtQjtBQUNyQyxZQUFJLE1BQU0sS0FBSyxJQUFMLENBQVUsTUFBVixDQUFpQixRQUFqQixDQUFWOztBQUVBLGVBQU8sS0FBSyxhQUFMLENBQW1CLEdBQW5CLENBQVA7QUFDSCxLQXR1Q2tDOztBQXd1Q25DLG1CQUFlLHVCQUFTLEdBQVQsRUFBYztBQUN6QixlQUFPLENBQUMsQ0FBQyxHQUFGLElBQVMsSUFBSSxNQUFiLEdBQXNCLElBQUksTUFBMUIsR0FBbUMsS0FBMUM7QUFDSCxLQTF1Q2tDOztBQTR1Q25DLDRCQUF3QixnQ0FBUyxRQUFULEVBQW1CO0FBQ3ZDLFlBQUksTUFBTSxLQUFLLElBQUwsQ0FBVSxNQUFWLENBQWlCLFFBQWpCLENBQVY7O0FBRUEsZUFBTyxLQUFLLGVBQUwsQ0FBcUIsR0FBckIsQ0FBUDtBQUNILEtBaHZDa0M7O0FBa3ZDbkMscUJBQWlCLHlCQUFTLEdBQVQsRUFBYztBQUMzQixlQUFPLENBQUMsQ0FBQyxHQUFGLElBQVMsSUFBSSxXQUFKLEtBQW9CLFNBQTdCLEdBQXlDLElBQUksV0FBN0MsR0FBMkQsS0FBbEU7QUFDSCxLQXB2Q2tDOztBQXN2Q25DLG1CQUFlLHVCQUFTLFdBQVQsRUFBc0I7QUFDakMsZUFBTyxJQUFQO0FBQ0gsS0F4dkNrQzs7QUEwdkNuQyxnQ0FBNEIsb0NBQVMsWUFBVCxFQUF1QjtBQUMvQyxlQUFPLFlBQVc7QUFDZCxtQkFBTyxJQUFQO0FBQ0gsU0FGRDtBQUdILEtBOXZDa0M7O0FBZ3dDbkMsd0JBQW9CLDhCQUFXO0FBQzNCLGVBQU8sS0FBSyxVQUFMLENBQWdCLEtBQUssY0FBckIsQ0FBUDtBQUNILEtBbHdDa0M7O0FBb3dDbkMsMkJBQXVCLCtCQUFTLFVBQVQsRUFBcUI7QUFDeEMsZUFBTyxLQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCO0FBQUEsbUJBQUssRUFBRSxJQUFGLEtBQVcsVUFBaEI7QUFBQSxTQUFsQixDQUFQO0FBQ0gsS0F0d0NrQzs7QUF3d0NuQyx3QkFBb0IsOEJBQVc7QUFDM0IsYUFBSyxxQkFBTCxDQUEyQixJQUEzQjtBQUNBLGFBQUssT0FBTDtBQUNILEtBM3dDa0M7O0FBNndDbkMsMkJBQXVCLCtCQUFTLEtBQVQsRUFBZ0I7QUFDbkMsZ0JBQVEsVUFBVSxJQUFsQjtBQUNBLFlBQUksWUFBWSxLQUFLLHVCQUFMLE1BQ1osS0FBSyxhQUFMLE1BQXdCLEtBQUssa0JBQUwsR0FBMEIscUJBQTFCLENBQWdELEtBQWhELENBRDVCO0FBRUEsYUFBSyxVQUFMLENBQWdCLE9BQWhCLENBQXdCLFVBQVMsTUFBVCxFQUFpQjtBQUNyQyx3QkFBWSxPQUFPLHFCQUFQLENBQTZCLEtBQTdCLEtBQXVDLFNBQW5EO0FBQ0gsU0FGRDtBQUdBLGVBQU8sU0FBUDtBQUNILEtBcnhDa0M7O0FBdXhDbkMsNkJBQXlCLG1DQUFXO0FBQ2hDLFlBQUksS0FBSyxJQUFMLENBQVUsVUFBVixDQUFxQixjQUFyQixJQUF1QyxLQUFLLElBQUwsQ0FBVSxVQUFWLENBQXFCLG1CQUFoRSxFQUFxRjtBQUNqRixtQkFBTyxLQUFLLGtCQUFMLEdBQTBCLHFCQUExQixDQUFnRCxJQUFoRCxDQUFQO0FBQ0g7QUFDSixLQTN4Q2tDOztBQTZ4Q25DLGdCQUFZLHNCQUFXO0FBQ25CLGVBQU8sS0FBSyxVQUFaO0FBQ0gsS0EveENrQzs7QUFpeUNuQyxzQkFBa0IsNEJBQVc7QUFDekIsZUFBTyxLQUFLLE9BQVo7QUFDSCxLQW55Q2tDOztBQXF5Q25DLHNCQUFrQiw0QkFBVztBQUN6QixZQUFJLFVBQVUsS0FBSyxPQUFuQjtBQUNBLFlBQUksTUFBTSxLQUFLLFVBQWY7QUFDQSxZQUFJLFNBQVMsRUFBYjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxJQUFJLE1BQXhCLEVBQWdDLEdBQWhDLEVBQXFDO0FBQ2pDLGdCQUFJLFFBQVEsT0FBUixDQUFnQixJQUFJLENBQUosQ0FBaEIsTUFBNEIsQ0FBQyxDQUFqQyxFQUFvQztBQUNoQyx1QkFBTyxJQUFQLENBQVksSUFBSSxDQUFKLENBQVo7QUFDSDtBQUNKO0FBQ0QsZUFBTyxJQUFQLENBQVksVUFBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQ3ZCLG1CQUFPLEVBQUUsTUFBRixHQUFXLEVBQUUsTUFBcEI7QUFDSCxTQUZEO0FBR0EsZUFBTyxNQUFQO0FBQ0gsS0FsekNrQzs7QUFvekNuQyxxQkFBaUIsMkJBQVc7QUFDeEIsZUFBTyxLQUFLLElBQUwsQ0FBVSxjQUFWLENBQXlCLGVBQXpCLEVBQVA7QUFDSCxLQXR6Q2tDOztBQXd6Q25DLHdCQUFvQiw4QkFBVztBQUMzQixlQUFPLEtBQUssSUFBTCxDQUFVLGNBQVYsQ0FBeUIsa0JBQXpCLEVBQVA7QUFDSCxLQTF6Q2tDOztBQTR6Q25DLG1CQUFlLHlCQUFXO0FBQ3RCLGVBQU8sS0FBSyxJQUFMLENBQVUsY0FBVixDQUF5QixhQUF6QixFQUFQO0FBQ0gsS0E5ekNrQzs7QUFnMENuQyxTQUFLLGVBQVc7QUFBQTs7QUFDZCxzQkFBSyxJQUFMLEVBQVUsR0FBVixjQUFpQixTQUFqQjtBQUNEO0FBbDBDa0MsQ0FBeEIsQ0FBZjs7QUFzMENBO0FBQ0EsT0FBTyxnQkFBUCxDQUF3QixTQUFTLFNBQWpDLEVBQTRDO0FBQ3hDLHFCQUFpQixFQUFFLE9BQU8sQ0FBQyxDQUFWLEVBRHVCO0FBRXhDLG9CQUFnQixFQUFFLE9BQU8sQ0FBQyxDQUFWO0FBRndCLENBQTVDOztBQU1BLFNBQVMsK0JBQVQsR0FBMkM7QUFDdkMsUUFBSSxlQUFlLEVBQW5CO0FBQUEsUUFBdUIsdUJBQXVCLEVBQTlDO0FBQUEsUUFBa0QsSUFBSSxDQUF0RDs7QUFFQSxTQUFLLFFBQUwsQ0FBYyxPQUFkLENBQXNCLFVBQVMsa0JBQVQsRUFBNkI7QUFDL0MsWUFBSSxZQUFZLG1CQUFtQixTQUFuQixDQUE2QixZQUE3QixJQUE2QyxtQkFBbUIsSUFBaEY7QUFBQSxZQUNJLGNBQWMsYUFBYSxZQUFZLEdBRDNDOztBQUdBO0FBQ0EscUJBQWEsSUFBYixDQUFrQixXQUFsQjs7QUFFQTtBQUNBLFlBQUksQ0FBQyxLQUFLLGVBQUwsQ0FBcUIsR0FBckIsQ0FBeUIsV0FBekIsRUFBc0MsSUFBdEMsQ0FBTCxFQUFrRDtBQUM5QyxnQkFBSSxrQkFBa0IsbUJBQW1CLElBQW5CLElBQTJCLG1CQUFtQixTQUFuQixDQUE2QixZQUF4RCxJQUF3RSx1QkFBdUIsQ0FBckg7QUFBQSxnQkFDSSxTQUFTLEVBRGI7QUFFQSxnQkFBSSxDQUFDLFNBQUwsRUFBZ0I7QUFDWix1QkFBTyxJQUFQLENBQVksT0FBTyxXQUFQLEdBQXFCLElBQWpDO0FBQ0g7QUFDRCxtQkFBTyxJQUFQLENBQVksZUFBWjtBQUNBLGlDQUFxQixJQUFyQixDQUEwQixPQUFPLElBQVAsQ0FBWSxJQUFaLENBQTFCO0FBQ0g7QUFDSixLQWpCRCxFQWlCRyxJQWpCSDs7QUFtQkEsUUFBSSxhQUFhLE1BQWpCLEVBQXlCO0FBQ3JCLFlBQUksYUFBYSxzQ0FBc0MsS0FBSyxNQUFMLEVBQWEsWUFBYixFQUEyQixPQUEzQixDQUF0QyxHQUE0RSxJQUE3Rjs7QUFFQSxZQUFJLHFCQUFxQixNQUF6QixFQUFpQztBQUM3QiwwQkFBYywySEFDVixLQUFLLGVBQUwsRUFBc0Isb0JBQXRCLEVBQTRDLE1BQTVDLENBREo7QUFFSDs7QUFFRCxZQUFJLENBQUosRUFBTztBQUNILDBCQUFjLDJHQUFkO0FBQ0g7O0FBRUQsZ0JBQVEsSUFBUixDQUFhLDBTQUEwUyxVQUF2VDtBQUNIO0FBQ0o7O0FBRUQsU0FBUyxJQUFULENBQWMsTUFBZCxFQUFzQixLQUF0QixFQUE2QixNQUE3QixFQUFxQztBQUNqQyxXQUFPLFNBQVMsTUFBTSxJQUFOLENBQVcsU0FBUyxNQUFwQixDQUFULEdBQXVDLE1BQTlDO0FBQ0g7O0FBR0Q7O0FBRUE7Ozs7OztBQU1BLFNBQVMsU0FBVCxDQUFtQixjQUFuQixHQUFvQyxTQUFTLFNBQVQsQ0FBbUIsT0FBdkQ7O0FBR0E7QUFDQSxTQUFTLFNBQVQsQ0FBbUIsS0FBbkIsQ0FBeUIsUUFBUSxpQkFBUixFQUEyQixLQUFwRDtBQUNBLFNBQVMsU0FBVCxDQUFtQixLQUFuQixDQUF5QixRQUFRLGtCQUFSLEVBQTRCLGFBQXJEO0FBQ0EsU0FBUyxTQUFULENBQW1CLEtBQW5CLENBQXlCLFFBQVEsWUFBUixFQUFzQixLQUEvQzs7QUFHQSxPQUFPLE9BQVAsR0FBaUIsUUFBakI7OztBQ3I4Q0E7O0FBRUE7Ozs7QUFFQSxJQUFJLFlBQVksUUFBUSxXQUFSLENBQWhCOztBQUVBLElBQUksYUFBYSxRQUFRLG1CQUFSLENBQWpCO0FBQ0EsSUFBSSxpQkFBaUIsUUFBUSxjQUFSLENBQXJCO0FBQ0EsSUFBSSxTQUFTLFFBQVEsY0FBUixDQUFiOztBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBLFNBQVMsTUFBVCxDQUFnQixRQUFoQixFQUEwQixLQUExQixFQUFpQztBQUM3QixRQUFJLE9BQUosRUFBYSxJQUFiOztBQUVBLFNBQUssUUFBTCxHQUFnQixRQUFoQjtBQUNBLFNBQUssU0FBTCxHQUFpQixTQUFTLFNBQTFCOztBQUVBLFFBQUksUUFBTyxLQUFQLHlDQUFPLEtBQVAsT0FBaUIsUUFBckIsRUFBK0I7QUFDM0Isa0JBQVUsS0FBVjtBQUNBLGdCQUFRLFFBQVEsS0FBUixLQUFrQixTQUFsQixHQUE4QixRQUFRLEtBQXRDLEdBQThDLFFBQVEsSUFBOUQ7QUFDSCxLQUhELE1BR087QUFDSCxrQkFBVSxFQUFWO0FBQ0g7O0FBRUQsU0FBSyxNQUFMLEdBQWMsS0FBSyxRQUFMLENBQWMsTUFBZCxDQUFxQixLQUFyQixDQUFkOztBQUVBLFFBQUksQ0FBQyxLQUFLLE1BQVYsRUFBa0I7QUFDZCxjQUFNLDJCQUFOO0FBQ0g7O0FBRUQsU0FBSyxVQUFMLEdBQWtCLE9BQWxCOztBQUVBLFlBQVEsS0FBUjtBQUNJLGFBQUssS0FBSyxRQUFMLENBQWMsZUFBbkI7QUFDSTtBQUNBLG1CQUFPLE9BQU8sT0FBTyxNQUFQLENBQWMsS0FBSyxVQUFMLENBQWdCLFVBQTlCLEVBQTBDLEVBQUUsV0FBVyxFQUFFLE9BQU8sSUFBVCxFQUFiLEVBQTFDLEVBQTBFLFFBQWpGLENBQVA7QUFDQSxpQkFBSyxVQUFMLENBQWdCLGtCQUFoQixHQUFxQyxPQUFPLEtBQUssS0FBTCxHQUFhLENBQXBCLEdBQXdCLENBQTdEO0FBQ0E7O0FBRUosYUFBSyxLQUFLLFFBQUwsQ0FBYyxjQUFuQjtBQUNJOztBQUVKO0FBQ0ksZ0JBQUksUUFBUSxDQUFaLEVBQWU7QUFDWCxzQkFBTSxzQkFBTjtBQUNIO0FBYlQ7QUFlSDs7QUFFRCxPQUFPLFNBQVAsR0FBbUI7QUFDZixpQkFBYSxPQUFPLFNBQVAsQ0FBaUIsV0FEZjtBQUVmLGtCQUFjLFFBRkM7O0FBSWYsb0JBQWdCLGNBSkQ7O0FBTWYsV0FBTyxVQUFVLEtBTkY7O0FBUWY7Ozs7QUFJQSxRQUFJLEtBQUosR0FBWTtBQUFFO0FBQ1YsZUFBTyxLQUFLLE1BQUwsQ0FBWSxLQUFuQjtBQUNILEtBZGM7O0FBZ0JmOzs7O0FBSUEsUUFBSSxJQUFKLEdBQVc7QUFBRTtBQUNULGVBQU8sS0FBSyxNQUFMLENBQVksSUFBbkI7QUFDSCxLQXRCYzs7QUF3QmY7Ozs7QUFJQSxRQUFJLEtBQUosR0FBWTtBQUFFO0FBQ1YsZUFBUSxLQUFLLE1BQUwsSUFBZSxLQUFLLE1BQUwsQ0FBWSxLQUE1QixJQUFzQyxLQUFLLE1BQUwsQ0FBWSxJQUF6RDtBQUNILEtBOUJjOztBQWdDZixRQUFJLE1BQUosR0FBYTtBQUFFO0FBQ1gsZUFBTyxLQUFLLFVBQUwsQ0FBZ0IsTUFBdkI7QUFDSCxLQWxDYzs7QUFvQ2YsUUFBSSxTQUFKLEdBQWdCO0FBQUU7QUFDZCxlQUFPLEtBQUssTUFBTCxHQUFjLEtBQUssTUFBTCxDQUFZLFNBQTFCLEdBQXNDLFNBQTdDO0FBQ0gsS0F0Q2M7O0FBd0NmOzs7Ozs7Ozs7QUFTQSxRQUFJLE1BQUosQ0FBVyxVQUFYLEVBQXVCO0FBQ25CLFlBQUksZUFBZSxTQUFuQixFQUE4QjtBQUMxQixtQkFBTyxLQUFLLE1BQUwsQ0FBWSxNQUFuQjtBQUNILFNBRkQsTUFFTztBQUNILGlCQUFLLE1BQUwsQ0FBWSxNQUFaLEdBQXFCLFVBQXJCO0FBQ0g7QUFDRCxhQUFLLFFBQUwsQ0FBYyxJQUFkLENBQW1CLE9BQW5CO0FBQ0gsS0F4RGM7QUF5RGYsUUFBSSxNQUFKLEdBQWE7QUFDVCxlQUFPLEtBQUssTUFBTCxDQUFZLE1BQW5CO0FBQ0gsS0EzRGM7O0FBNkRmOzs7Ozs7O0FBT0EsUUFBSSxVQUFKLENBQWUsVUFBZixFQUEyQjtBQUN2QixZQUFJLFVBQUosRUFBZ0I7QUFDWix5QkFBYSxrQkFBa0IsSUFBbEIsQ0FBdUIsSUFBdkIsRUFBNkIsVUFBN0IsQ0FBYjtBQUNBLGdCQUFJLGVBQWUsS0FBSyxNQUFMLENBQVksVUFBL0IsRUFBMkM7QUFDdkMsb0JBQUksZUFBZSxTQUFuQixFQUE4QjtBQUMxQiwyQkFBTyxLQUFLLE1BQUwsQ0FBWSxVQUFuQjtBQUNILGlCQUZELE1BRU87QUFDSCx5QkFBSyxNQUFMLENBQVksVUFBWixHQUF5QixVQUF6QjtBQUNIO0FBQ0QscUJBQUssUUFBTCxDQUFjLE9BQWQ7QUFDSDtBQUNKLFNBVkQsTUFVTyxJQUFJLEtBQUssTUFBTCxDQUFZLFVBQWhCLEVBQTRCO0FBQy9CLG1CQUFPLEtBQUssTUFBTCxDQUFZLFVBQW5CO0FBQ0EsaUJBQUssUUFBTCxDQUFjLE9BQWQ7QUFDSDtBQUNKLEtBbkZjO0FBb0ZmLFFBQUksVUFBSixHQUFpQjtBQUNiLGVBQU8sS0FBSyxNQUFMLENBQVksVUFBbkI7QUFDSCxLQXRGYzs7QUF3RmYsUUFBSSxVQUFKLEdBQWlCO0FBQ2IsZUFBTyxLQUFLLE1BQUwsSUFBZSxLQUFLLE1BQUwsQ0FBWSxVQUFsQztBQUNILEtBMUZjOztBQTRGZjs7Ozs7OztBQU9BLFFBQUksSUFBSixDQUFTLElBQVQsRUFBZTtBQUNYLFlBQUksU0FBUyxTQUFiLEVBQXdCO0FBQ3BCLG1CQUFPLEtBQUssTUFBTCxDQUFZLElBQW5CO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsaUJBQUssTUFBTCxDQUFZLElBQVosR0FBbUIsSUFBbkI7QUFDSDtBQUNELGFBQUssUUFBTCxDQUFjLE9BQWQ7QUFDSCxLQTFHYztBQTJHZixRQUFJLElBQUosR0FBVztBQUNQLGVBQU8sS0FBSyxNQUFMLENBQVksSUFBbkI7QUFDSCxLQTdHYzs7QUErR2YsY0FBVSxrQkFBUyxDQUFULEVBQVk7QUFDbEIsZUFBTyxLQUFLLFNBQUwsQ0FBZSxRQUFmLENBQXdCLEtBQUssS0FBN0IsRUFBb0MsQ0FBcEMsQ0FBUDtBQUNILEtBakhjOztBQW1IZixjQUFVLGtCQUFTLENBQVQsRUFBWTtBQUNsQixlQUFPLEtBQUssU0FBTCxDQUFlLFFBQWYsQ0FBd0IsS0FBSyxLQUE3QixFQUFvQyxDQUFwQyxDQUFQO0FBQ0gsS0FySGM7O0FBdUhmLGNBQVUsa0JBQVMsQ0FBVCxFQUFZLEtBQVosRUFBbUI7QUFDekIsZUFBTyxLQUFLLFNBQUwsQ0FBZSxRQUFmLENBQXdCLEtBQUssS0FBN0IsRUFBb0MsQ0FBcEMsRUFBdUMsS0FBdkMsQ0FBUDtBQUNILEtBekhjOztBQTJIZixjQUFVLG9CQUFXO0FBQ2pCLGVBQU8sS0FBSyxVQUFMLENBQWdCLEtBQWhCLElBQXlCLEtBQUssVUFBTCxDQUFnQixrQkFBaEQ7QUFDSCxLQTdIYzs7QUErSGYsY0FBVSxrQkFBUyxLQUFULEVBQWdCO0FBQ3RCLGdCQUFRLEtBQUssR0FBTCxDQUFTLEtBQUssVUFBTCxDQUFnQixrQkFBekIsRUFBNkMsS0FBN0MsQ0FBUjs7QUFFQSxZQUFJLEtBQUssVUFBTCxDQUFnQixRQUFoQixJQUE0QixRQUFRLEtBQUssVUFBTCxDQUFnQixRQUF4RCxFQUFrRTtBQUM5RCxvQkFBUSxLQUFLLFVBQUwsQ0FBZ0IsUUFBeEI7QUFDSDs7QUFFRCxZQUFJLFVBQVUsS0FBSyxVQUFMLENBQWdCLEtBQTlCLEVBQXFDO0FBQ2pDLGlCQUFLLFVBQUwsQ0FBZ0IsS0FBaEIsR0FBd0IsS0FBeEI7QUFDQSxpQkFBSyxNQUFMLENBQVksS0FBWixHQUFvQixLQUFwQjtBQUNBLGlCQUFLLFVBQUwsQ0FBZ0IsZ0JBQWhCLEdBQW1DLEtBQW5DO0FBQ0g7QUFDSixLQTNJYzs7QUE2SWYsMkJBQXVCLCtCQUFTLEtBQVQsRUFBZ0I7QUFDbkMsWUFBSSxhQUFhLEtBQUssVUFBdEI7QUFBQSxZQUFrQyxLQUFsQztBQUFBLFlBQXlDLGNBQXpDO0FBQUEsWUFBeUQsU0FBekQ7O0FBRUEsWUFBSSxXQUFXLGdCQUFmLEVBQWlDO0FBQzdCLG9CQUFRLFdBQVcsS0FBbkI7QUFDQSw2QkFBaUIsV0FBVyxjQUFYLElBQTZCLEtBQTlDO0FBQ0Esb0JBQVEsU0FBUyxDQUFDLFdBQVcsZUFBN0I7QUFDQSxnQkFBSSxVQUFVLGNBQVYsSUFBNEIsU0FBUyxtQkFBbUIsU0FBNUQsRUFBdUU7QUFDbkUsMkJBQVcsS0FBWCxHQUFtQixRQUFRLGNBQVIsR0FBeUIsS0FBSyxHQUFMLENBQVMsS0FBVCxFQUFnQixjQUFoQixDQUE1QztBQUNBLDJCQUFXLGVBQVgsR0FBNkIsQ0FBQyxNQUFNLFdBQVcsS0FBakIsQ0FBOUI7QUFDQSw0QkFBWSxXQUFXLEtBQVgsS0FBcUIsS0FBakM7QUFDSDtBQUNKOztBQUVELGVBQU8sU0FBUDtBQUNILEtBNUpjOztBQThKZixpQkFBYSxxQkFBUyxDQUFULEVBQVk7QUFDckIsWUFBSSxRQUFRLEtBQUssUUFBTCxDQUFjLENBQWQsQ0FBWjtBQUNBLGVBQU8sS0FBSyxNQUFMLENBQVksS0FBWixDQUFQO0FBQ0gsS0FqS2M7O0FBbUtmLGFBQVMsbUJBQVc7QUFDaEIsWUFBSSxRQUFRLEtBQUssVUFBakI7QUFDQSxZQUFJLE9BQU8sTUFBTSxJQUFqQjtBQUNBLFlBQUksQ0FBQyxJQUFMLEVBQVc7QUFDUCxtQkFBTyxLQUFLLGlCQUFMLEVBQVA7QUFDQSxnQkFBSSxTQUFTLFNBQWIsRUFBd0I7QUFDcEIsc0JBQU0sSUFBTixHQUFhLElBQWI7QUFDSDtBQUNKO0FBQ0QsZUFBTyxJQUFQO0FBQ0gsS0E3S2M7O0FBK0tmLHVCQUFtQiw2QkFBVztBQUMxQixZQUFJLGlCQUFpQixLQUFLLFFBQUwsQ0FBYyxpQkFBZCxFQUFyQjtBQUNBLFlBQUksU0FBUyxLQUFLLFFBQUwsQ0FBYyxXQUFkLEVBQWI7QUFDQSxZQUFJLFFBQVEsS0FBSyxRQUFMLENBQWMsY0FBZCxDQUFaO0FBQ0EsWUFBSSxXQUFXLEtBQUssTUFBTCxDQUFZLEtBQVosQ0FBZjtBQUNBLFlBQUksQ0FBQyxRQUFMLEVBQWU7QUFDWCxtQkFBTyxTQUFQO0FBQ0g7QUFDRCxZQUFJLE9BQU8sS0FBSyxNQUFMLENBQVksS0FBWixDQUFYO0FBQ0E7QUFDQSxhQUFLLElBQUksSUFBSSxjQUFiLEVBQTZCLElBQUksTUFBakMsRUFBeUMsR0FBekMsRUFBOEM7QUFDMUMsb0JBQVEsS0FBSyxRQUFMLENBQWMsQ0FBZCxDQUFSO0FBQ0EsdUJBQVcsS0FBSyxNQUFMLENBQVksS0FBWixDQUFYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNELGVBQU8sSUFBUDtBQUNILEtBck1jOztBQXVNZixZQUFRLGdCQUFTLFNBQVQsRUFBb0I7QUFDeEIsWUFBSSxhQUFhLElBQWpCLEVBQXVCO0FBQ25CLG1CQUFPLElBQVA7QUFDSDtBQUNELFlBQUksZ0JBQWdCLFNBQWhCLHlDQUFnQixTQUFoQixDQUFKO0FBQ0EsZ0JBQVEsTUFBUjtBQUNJLGlCQUFLLFFBQUw7QUFDSSx1QkFBTyxVQUFVLFdBQVYsQ0FBc0IsSUFBdEIsQ0FBMkIsV0FBM0IsRUFBUDtBQUNKLGlCQUFLLFFBQUw7QUFDSSx1QkFBTyxTQUFTLFNBQVQsTUFBd0IsU0FBeEIsR0FBb0MsS0FBcEMsR0FBNEMsT0FBbkQ7QUFDSjtBQUNJLHVCQUFPLE1BQVA7QUFOUjtBQVFILEtBcE5jOztBQXNOZixRQUFJLFVBQUosR0FBaUI7QUFDYixlQUFPLEtBQUssV0FBWjtBQUNILEtBeE5jO0FBeU5mLFFBQUksVUFBSixDQUFlLGFBQWYsRUFBOEI7QUFDMUIsYUFBSyxXQUFMLEdBQW1CLEtBQUssc0JBQUwsRUFBbkI7QUFDQSxhQUFLLGFBQUwsQ0FBbUIsYUFBbkI7QUFDSCxLQTVOYzs7QUE4TmY7OztBQUdBLHdCQUFvQiw0QkFBUyxLQUFULEVBQWdCO0FBQ2hDLFlBQUksS0FBSyxVQUFMLENBQWdCLGVBQWhCLEtBQW9DLEtBQXhDLEVBQStDO0FBQzNDLGlCQUFLLFVBQUwsQ0FBZ0IsZUFBaEIsR0FBa0MsS0FBbEM7QUFDQSxpQkFBSyxRQUFMLENBQWMsSUFBZCxDQUFtQixRQUFuQixDQUE0QixxQkFBNUI7QUFDSDtBQUNKLEtBdE9jOztBQXdPZixtQkFBZSx1QkFBUyxVQUFULEVBQXFCO0FBQ2hDLFlBQUksR0FBSjtBQUFBLFlBQVMsVUFBVDtBQUFBLFlBQXFCLE1BQU0sS0FBSyxVQUFoQzs7QUFFQSxhQUFLLEdBQUwsSUFBWSxVQUFaLEVBQXdCO0FBQ3BCLGdCQUFJLFdBQVcsY0FBWCxDQUEwQixHQUExQixDQUFKLEVBQW9DO0FBQ2hDLDZCQUFhLE9BQU8sd0JBQVAsQ0FBZ0MsR0FBaEMsRUFBcUMsR0FBckMsQ0FBYjtBQUNBLG9CQUFJLENBQUMsVUFBRCxJQUFlLFdBQVcsUUFBMUIsSUFBc0MsV0FBVyxHQUFyRCxFQUEwRDtBQUN0RCx3QkFBSSxHQUFKLElBQVcsV0FBVyxHQUFYLENBQVg7QUFDSDtBQUNKO0FBQ0o7QUFDSixLQW5QYzs7QUFxUGY7Ozs7Ozs7Ozs7QUFVQSxxQkFBaUIseUJBQVMsU0FBVCxFQUFvQjtBQUNqQyxZQUFJLGNBQWMsS0FBSyxLQUF2QjtBQUFBLFlBRUksV0FBVyxVQUFVLFFBQVYsQ0FBbUIsQ0FGbEM7QUFBQSxZQUlJLGFBQWEsVUFBVSxVQUFWLENBQXFCLE1BSnRDO0FBQUEsWUFNSSxVQUFVLE9BQU8sTUFBUCxDQUFjLFNBQWQsRUFBeUI7QUFDL0Isb0JBQVE7QUFDSjtBQUNBO0FBQ0E7QUFDQSwwQkFBVSxJQUpOO0FBS0osNEJBQVksSUFMUixFQUtjO0FBQ2xCLHVCQUFPLFVBQVUsVUFBVixDQUFxQjtBQU54QjtBQUR1QixTQUF6QixDQU5kO0FBQUEsWUFnQkksYUFBYSxLQUFLLFNBQUwsQ0FBZSxlQUFmLENBQStCLFdBQS9CLEVBQTRDLFFBQTVDLEVBQXNELFVBQXRELEVBQWtFLE9BQWxFLENBaEJqQjs7QUFrQkEsWUFBSSxjQUFjLENBQUMsV0FBVyxJQUE5QixFQUFvQztBQUNoQztBQUNBLHlCQUFhLFNBQWI7QUFDSDs7QUFFRCxlQUFPLFVBQVA7QUFDSCxLQXhSYzs7QUEwUmYsa0JBQWMsd0JBQVc7QUFDckIsWUFBSSxnQkFBZ0IsS0FBSyxVQUFMLENBQWdCLE1BQXBDO0FBQ0EsZUFBTyxLQUFLLFFBQUwsQ0FBYyxJQUFkLENBQW1CLFlBQW5CLENBQWdDLEdBQWhDLENBQW9DLGFBQXBDLEVBQW1ELE1BQTFEO0FBQ0g7QUE3UmMsQ0FBbkI7O0FBZ1NBLElBQUksbUJBQW1CLG9CQUF2Qjs7QUFFQTs7Ozs7Ozs7Ozs7OztBQWFBLFNBQVMsaUJBQVQsQ0FBMkIsVUFBM0IsRUFBdUM7QUFDbkMsUUFBSSxDQUFDLFVBQUwsRUFBaUI7QUFDYixlQUFPLFNBQVA7QUFDSDs7QUFFRCxRQUFJLE9BQU8sVUFBUCxLQUFzQixVQUExQixFQUFzQztBQUNsQyxxQkFBYSxXQUFXLFFBQVgsRUFBYjtBQUNILEtBRkQsTUFFTyxJQUFJLE9BQU8sVUFBUCxLQUFzQixRQUExQixFQUFvQztBQUN2QyxjQUFNLElBQUksY0FBSixDQUFtQiwyRUFBMkUsS0FBSyxJQUFoRixHQUF1RixzQkFBMUcsQ0FBTjtBQUNIOztBQUVELFFBQUksT0FBSjtBQUFBLFFBQWEsR0FBYjtBQUFBLFFBQ0ksY0FBYyxLQUFLLFFBQUwsQ0FBYyxJQUFkLENBQW1CLFVBQW5CLENBQThCLFdBQTlCLEtBQThDLEtBQUssUUFBTCxDQUFjLElBQWQsQ0FBbUIsVUFBbkIsQ0FBOEIsV0FBOUIsR0FBNEMsRUFBMUYsQ0FEbEI7O0FBR0EsUUFBSSxRQUFRLElBQVIsQ0FBYSxVQUFiLENBQUosRUFBOEI7QUFDMUIsY0FBTSxVQUFOLENBRDBCLENBQ1I7QUFDbEIsWUFBSSxDQUFDLFlBQVksR0FBWixDQUFMLEVBQXVCO0FBQ25CLGtCQUFNLElBQUksY0FBSixDQUFtQiw0QkFBNEIsR0FBNUIsR0FBa0MsU0FBbEMsR0FBOEMsS0FBSyxJQUFuRCxHQUEwRCxzQkFBN0UsQ0FBTjtBQUNIO0FBQ0osS0FMRCxNQUtPO0FBQ0gsa0JBQVUsV0FBVyxLQUFYLENBQWlCLHFCQUFqQixDQUFWOztBQUVBLFlBQUksT0FBSixFQUFhO0FBQ1Qsa0JBQU0sUUFBUSxDQUFSLENBQU4sQ0FEUyxDQUNTO0FBQ3JCLFNBRkQsTUFFTztBQUNILGtCQUFNLFVBQU4sQ0FERyxDQUNlO0FBQ3JCOztBQUVELFlBQUksQ0FBQyxZQUFZLEdBQVosQ0FBTCxFQUF1QjtBQUFFO0FBQ3JCLGdCQUFJLGlCQUFpQixJQUFqQixDQUFzQixVQUF0QixDQUFKLEVBQXVDO0FBQ25DLHNCQUFNLElBQUksY0FBSixDQUFtQixvRUFBb0UsS0FBSyxJQUF6RSxHQUFnRixLQUFuRyxDQUFOO0FBQ0g7QUFDRCx3QkFBWSxHQUFaLElBQW1CLFVBQW5CO0FBQ0g7QUFDSjs7QUFFRCxnQkFBWSxHQUFaLElBQW1CLFdBQVcsWUFBWSxHQUFaLENBQVgsQ0FBbkIsQ0FwQ21DLENBb0NjOztBQUVqRCxXQUFPLFlBQVksR0FBWixDQUFQO0FBQ0g7O0FBRUQsT0FBTyxTQUFQLENBQWlCLEtBQWpCLENBQXVCLFFBQVEsa0JBQVIsRUFBNEIsV0FBbkQ7QUFDQSxPQUFPLFNBQVAsQ0FBaUIsS0FBakIsQ0FBdUIsUUFBUSxvQkFBUixFQUE4QixLQUFyRDs7QUFFQSxPQUFPLE9BQVAsR0FBaUIsTUFBakI7OztBQy9aQTs7Ozs7O0FBRUEsSUFBSSxXQUFXLFFBQVEsWUFBUixDQUFmOztBQUVBOzs7Ozs7QUFNQSxJQUFJLG1CQUFtQixRQUFRLGtCQUFSLENBQXZCOztBQUVBLElBQUksYUFBYSxRQUFRLHdCQUFSLENBQWpCOztBQUVBLElBQU0sY0FBYyxlQUFwQjs7QUFHQTs7Ozs7O0FBTUEsSUFBSSxRQUFRLFNBQVMsTUFBVCxDQUFnQixPQUFoQixFQUF5Qjs7QUFFakMsZ0JBQVksb0JBQVMsSUFBVCxFQUFlLE9BQWYsRUFBd0I7QUFDaEMsYUFBSyxPQUFMLENBQWEsT0FBYjtBQUNILEtBSmdDOztBQU1qQzs7OztBQUlBLG1CQUFlLHlCQUFXO0FBQUE7O0FBQ3RCLFlBQU0sYUFBYSxLQUFLLE9BQXhCO0FBQ0EsWUFBTSxnQkFBZ0IsS0FBSyxVQUEzQjs7QUFFQSxpQkFBUyxTQUFULENBQW1CLGFBQW5CLENBQWlDLElBQWpDLENBQXNDLElBQXRDOztBQUVBLGFBQUssTUFBTCxDQUFZLE9BQVosQ0FBb0IsVUFBQyxZQUFELEVBQWUsS0FBZixFQUF5QjtBQUN6QyxnQkFBTSxlQUFlLFNBQWYsWUFBZSxDQUFTLENBQVQsRUFBWTtBQUM3Qix1QkFBTyxFQUFFLFVBQUYsQ0FBYSxLQUFiLEtBQXVCLEtBQXZCLElBQ0gsRUFBRSxVQUFGLENBQWEsSUFBYixLQUFzQixhQUFhLElBRGhDLElBRUgsRUFBRSxVQUFGLENBQWEsVUFBYixLQUE0QixhQUFhLFVBRnRDLElBR0gsRUFBRSxNQUFGLEtBQWEsYUFBYSxNQUg5QjtBQUlILGFBTEQ7QUFNQSxnQkFBTSxZQUFZLGNBQWMsSUFBZCxDQUFtQixZQUFuQixLQUFvQyxXQUFXLElBQVgsQ0FBZ0IsWUFBaEIsQ0FBdEQ7QUFDQSxnQkFBTSxtQkFBbUIsY0FBYyxJQUFkLENBQW1CO0FBQUEsdUJBQUssRUFBRSxNQUFGLElBQVksRUFBRSxNQUFGLEtBQWEsYUFBYSxNQUEzQztBQUFBLGFBQW5CLEtBQXlFLFdBQVcsSUFBWCxDQUFnQjtBQUFBLHVCQUFLLEVBQUUsTUFBRixLQUFhLGFBQWEsTUFBL0I7QUFBQSxhQUFoQixDQUFsRzs7QUFFQSxnQkFBSSxTQUFKLEVBQWU7QUFDWCxvQkFBTSxZQUFZLE1BQUssU0FBTCxDQUFlLFVBQVUsVUFBekIsQ0FBbEI7QUFDQSxvQkFBTSxRQUFRLFVBQVUsVUFBeEI7O0FBRUE7QUFDQTtBQUNBLG9CQUFJLE1BQU0sS0FBTixLQUFnQixNQUFNLGNBQXRCLElBQXdDLE1BQU0sZ0JBQTlDLElBQWtFLE1BQU0sZUFBNUUsRUFBNkY7QUFDekYsMEJBQU0sZ0JBQU4sR0FBeUIsS0FBekI7QUFDSDtBQUNKLGFBVEQsTUFTTztBQUNILG9CQUFNLGFBQVksTUFBSyxTQUFMLENBQWU7QUFDN0IsMkJBQU8sS0FEc0I7QUFFN0IsNEJBQVEsYUFBYSxNQUZRO0FBRzdCLGdDQUFZLGFBQWEsVUFISTtBQUk3Qiw0QkFBUSxhQUFhO0FBSlEsaUJBQWYsQ0FBbEI7O0FBT0E7QUFDQTtBQUNBLG9CQUFJLGFBQWEsS0FBakIsRUFBd0I7QUFDcEIsMkJBQU8sTUFBUCxDQUFjLFdBQVUsVUFBeEIsRUFBb0M7QUFDaEMsK0JBQU8sYUFBYSxLQURZO0FBRWhDLDBDQUFrQjtBQUZjLHFCQUFwQztBQUlILGlCQUxELE1BS08sSUFBSSxnQkFBSixFQUFzQjtBQUN6Qix3QkFBTSxTQUFRLGlCQUFpQixVQUEvQjs7QUFFQTtBQUNBO0FBQ0EsMkJBQU8sTUFBUCxDQUFjLFdBQVUsVUFBeEIsRUFBb0M7QUFDaEMsK0JBQU8sT0FBTSxLQURtQjtBQUVoQyx3Q0FBZ0IsT0FBTSxjQUZVO0FBR2hDLDBDQUFrQixPQUFNLGdCQUhRO0FBSWhDLHlDQUFpQixPQUFNO0FBSlMscUJBQXBDO0FBTUg7O0FBRUQsb0JBQUksYUFBYSxTQUFqQixFQUE0QjtBQUN4QiwrQkFBVSxVQUFWLENBQXFCLE1BQXJCLEdBQThCLFdBQVUsSUFBeEM7QUFDQSwrQkFBVSxNQUFWLENBQWlCLE1BQWpCLEdBQTBCLFdBQVUsSUFBcEM7QUFDQSx3QkFBTSxVQUFVO0FBQ1osOEJBQU0sV0FBVSxJQURKO0FBRVosZ0NBQVEsYUFBYSxTQUZULEVBRW9CO0FBQ2hDLCtCQUFPO0FBQUEsbUNBQVMsS0FBVDtBQUFBLHlCQUhLLEVBR1c7QUFDdkIsZ0NBQVE7QUFKSSxxQkFBaEI7QUFNQSwwQkFBSyxJQUFMLENBQVUsWUFBVixDQUF1QixHQUF2QixDQUEyQixXQUFVLElBQXJDLEVBQTJDLE9BQTNDO0FBQ0g7O0FBRUQsaUJBQUMsUUFBRCxFQUFXLFVBQVgsRUFBdUIsaUJBQXZCLEVBQTBDLE9BQTFDLENBQWtELFVBQVMsR0FBVCxFQUFjO0FBQzVELHdCQUFJLGFBQWEsR0FBYixDQUFKLEVBQXVCO0FBQ25CLG1DQUFVLFVBQVYsQ0FBcUIsR0FBckIsSUFBNEIsYUFBYSxHQUFiLENBQTVCO0FBQ0g7QUFDSixpQkFKRDtBQUtIO0FBQ0osU0FqRUQsRUFpRUcsSUFqRUg7QUFrRUgsS0FsRmdDOztBQW9GakM7Ozs7OztBQU1BLGVBQVcsbUJBQVMsU0FBVCxFQUFvQixLQUFwQixFQUEyQjtBQUFBOztBQUNsQyxZQUFJLFFBQU8sU0FBUCx5Q0FBTyxTQUFQLE9BQXFCLFFBQXpCLEVBQW1DO0FBQy9CLHdCQUFZLEtBQUssU0FBTCxDQUFlLFNBQWYsQ0FBWjtBQUNIOztBQUVELFlBQU0sU0FBUyxTQUFmO0FBQ0EsWUFBTSxPQUFPLEtBQUssT0FBTCxFQUFiO0FBQ0EsWUFBTSxLQUFLLEtBQUssSUFBTCxDQUFVLE1BQVYsQ0FBaUIsRUFBNUI7O0FBRUEsWUFBTSxRQUFRLE9BQU8sVUFBckI7O0FBRUEsWUFBSSxRQUFRLE9BQU8sS0FBUCxJQUFnQixNQUFNLGtCQUFsQzs7QUFFQTtBQUNBLGFBQUssT0FBTCxDQUFhLFVBQUMsQ0FBRCxFQUFJLENBQUosRUFBVTtBQUNuQixnQkFBSSxNQUFNLE9BQU8sUUFBUCxDQUFnQixDQUFoQixDQUFWO0FBRG1CLGdCQUVYLE1BRlcsR0FFQSxNQUZBLENBRVgsTUFGVzs7QUFHbkIsZ0JBQUksUUFBUSxRQUFPLEdBQVAseUNBQU8sR0FBUCxPQUFlLFFBQWYsSUFBMkIsZUFBZSxLQUFsRCxDQUFKLEVBQThEO0FBQzFELG9CQUFNLFNBQVMsRUFBZjs7QUFFQSxvQkFBTSxZQUFZLE9BQUssZ0JBQUwsQ0FBc0IsQ0FBdEIsS0FBNEIsS0FBOUM7QUFDQSx1QkFBTyxnQkFBUCxHQUEwQixNQUFNLGdCQUFoQzs7QUFFQSxvQkFBSSxVQUFVLHVCQUFkLEVBQXVDO0FBQ25DLHVCQUFHLEtBQUgsQ0FBUyxJQUFULEdBQWdCLE1BQU0sbUJBQXRCO0FBQ0EsMkJBQU8sdUJBQVAsR0FBaUMsTUFBTSxrQ0FBTixHQUEyQyxJQUFJLE1BQU0sd0JBQXJELEdBQWdGLE1BQU0sNkJBQXZIO0FBQ0g7O0FBRUQsb0JBQUksVUFBVSxjQUFWLElBQTRCLE9BQU8sV0FBdkMsRUFBb0Q7QUFDaEQsMkJBQU8sV0FBUCxHQUFxQixDQUFDLE9BQU8sdUJBQVAsSUFBa0MsQ0FBbkMsSUFBd0MsT0FBTyxnQkFBcEU7QUFDSDs7QUFFRCxvQkFBSSxVQUFVLE9BQU8sWUFBakIsSUFBaUMsVUFBVSxTQUEvQyxFQUEwRDtBQUN0RCx1QkFBRyxLQUFILENBQVMsSUFBVCxHQUFnQixNQUFNLHFCQUF0QjtBQUNBLDJCQUFPLFlBQVAsR0FBc0IsR0FBRyxZQUFILENBQWdCLE9BQU8sWUFBdkIsSUFBdUMsTUFBTSwyQkFBbkU7QUFDSDs7QUFFRCxvQkFBSSxPQUFPLFFBQVAsSUFBbUIsVUFBVSxTQUFqQyxFQUE0QztBQUN4Qyx1QkFBRyxLQUFILENBQVMsSUFBVCxHQUFnQixNQUFNLGFBQXRCO0FBQ0EsMkJBQU8sUUFBUCxHQUFrQixHQUFHLFlBQUgsQ0FBZ0IsTUFBTSxvQkFBdEIsSUFBOEMsTUFBTSwyQkFBdEU7QUFDSDs7QUFFRCxvQkFBSSxPQUFPLElBQVAsQ0FBWSxVQUFaLENBQXVCLGVBQXZCLENBQUosRUFBNkM7QUFDekMsd0JBQU0sWUFBWSxPQUFLLGVBQUwsQ0FBcUIsQ0FBckIsQ0FBbEI7QUFDQSx3QkFBTSxhQUFhLFlBQVksT0FBSyxlQUFMLENBQXFCLENBQXJCLElBQTBCLE1BQU0sK0JBQTVDLEdBQThFLENBQWpHO0FBQ0EsMkJBQU8sVUFBUCxHQUFvQixVQUFwQjs7QUFFQSx3QkFBTSxtQkFBbUIsT0FBSyx3QkFBTCxDQUE4QixDQUE5QixDQUF6QjtBQUNBLHdCQUFJLG1CQUFtQixDQUF2QixFQUEwQjtBQUN0QiwyQkFBRyxLQUFILENBQVMsSUFBVCxHQUFnQixNQUFNLG9CQUF0QjtBQUNBLCtCQUFPLGdCQUFQLEdBQTBCLE1BQU0sZUFBTixHQUF3QixVQUF4QixHQUFxQyxHQUFHLFlBQUgsT0FBb0IsZ0JBQXBCLE9BQXJDLEdBQWdGLE1BQU0sMEJBQWhIO0FBQ0g7QUFDSjs7QUFFRCxvQkFBSSxPQUFLLGVBQUwsQ0FBcUIsQ0FBckIsS0FBMkIsT0FBSyxTQUFMLENBQWUsMEJBQWYsQ0FBMEMsT0FBTyxLQUFqRCxFQUF3RCxDQUF4RCxDQUEvQixFQUEyRjtBQUN2Rix3QkFBTSxjQUFjLHNDQUFvQyxPQUFLLGFBQUwsQ0FBbUIsQ0FBbkIsSUFBd0IsV0FBeEIsR0FBc0MsVUFBMUUsV0FBcEI7QUFDQSx3QkFBSSxXQUFKLEVBQWlCO0FBQ2IsMkJBQUcsS0FBSCxDQUFTLElBQVQsR0FBZ0IsTUFBTSw4QkFBdEI7QUFDQSwrQkFBTyxXQUFQLEdBQXFCLEdBQUcsWUFBSCxDQUFnQixXQUFoQixJQUErQixNQUFNLDJCQUExRDtBQUNIO0FBQ0o7O0FBRUQsb0JBQU0sUUFBUSxPQUFPLFFBQVAsQ0FBZ0IsQ0FBaEIsQ0FBZDtBQUNBLG9CQUFJLFVBQVUsU0FBZCxFQUF5QjtBQUNyQix1QkFBRyxLQUFILENBQVMsSUFBVCxHQUFnQixNQUFNLG9CQUF0QjtBQUNBLDJCQUFPLFlBQVAsR0FBc0IsR0FBRyxZQUFILE9BQW9CLEtBQXBCLFVBQWdDLE1BQU0sMEJBQTVEO0FBQ0g7O0FBRUQsbUJBQUcsS0FBSCxDQUFTLElBQVQsR0FBZ0IsVUFBVSxJQUExQjtBQUNBLHVCQUFPLEdBQVAsR0FBYSxHQUFHLFlBQUgsQ0FBZ0IsT0FBSyxJQUFMLENBQVUsV0FBVixDQUFzQixPQUFPLElBQTdCLEVBQW1DLEdBQW5DLEVBQXdDLFVBQVUsU0FBbEQsQ0FBaEIsSUFBZ0YsTUFBTSxlQUFuRzs7QUFFQTtBQUNBLG9CQUFJLFlBQVksT0FBTyxNQUFQLENBQWMsTUFBZCxFQUFzQixNQUF0QixDQUE2QixVQUFDLENBQUQsRUFBSSxDQUFKO0FBQUEsMkJBQVUsSUFBSSxDQUFkO0FBQUEsaUJBQTdCLEVBQThDLENBQTlDLENBQWhCO0FBQ0E7O0FBRUEsb0JBQU0sVUFBVSxPQUFLLFNBQUwsQ0FBZSxVQUFmLENBQTBCLE9BQU8sS0FBakMsRUFBd0MsQ0FBeEMsQ0FBaEI7QUFDQSxvQkFBSSxVQUFVLENBQWQsRUFBaUI7QUFDYixnQ0FBWSxhQUFhLFVBQVUsQ0FBdkIsQ0FBWjtBQUNBLHlCQUFLLElBQUksS0FBSSxPQUFPLEtBQXBCLEVBQTJCLE1BQUssT0FBTyxLQUFQLEdBQWUsT0FBL0MsRUFBd0QsRUFBRSxFQUExRCxFQUE2RDtBQUN6RCwrQkFBSyxTQUFMLENBQWUsRUFBZixFQUFrQixLQUFsQixHQUEwQixTQUExQjtBQUNIO0FBQ0o7O0FBRUQsb0JBQUksWUFBWSxLQUFoQixFQUF1QjtBQUNuQiw0QkFBUSxTQUFSO0FBQ0g7QUFDSjtBQUNKLFNBekVEOztBQTJFQSxZQUFJLFFBQVEsTUFBTSxRQUFsQixFQUE0QjtBQUN4QixvQkFBUSxNQUFNLFFBQWQ7QUFDSDs7QUFFRCxjQUFNLGNBQU4sR0FBdUIsS0FBSyxJQUFMLENBQVUsS0FBVixDQUF2Qjs7QUFFQSxZQUFJLFNBQVMsTUFBTSxnQkFBbkIsRUFBcUM7QUFDakMsZ0JBQUksTUFBTSxjQUFOLEdBQXVCLENBQTNCLEVBQThCO0FBQzFCLHVCQUFPLFFBQVAsQ0FBZ0IsTUFBTSxjQUF0QjtBQUNIO0FBQ0o7QUFDSixLQTlMZ0M7O0FBZ01qQzs7Ozs7QUFLQSxnQkFBWSxzQkFBVztBQUFBOztBQUNuQixZQUFNLEtBQUssS0FBSyxJQUFMLENBQVUsTUFBVixDQUFpQixFQUE1QjtBQUNBLFlBQU0sVUFBVSxHQUFHLEtBQUgsQ0FBUyxJQUF6QjtBQUNBLGFBQUssVUFBTCxDQUFnQixPQUFoQixDQUF3QjtBQUFBLG1CQUFLLE9BQUssU0FBTCxDQUFlLENBQWYsQ0FBTDtBQUFBLFNBQXhCO0FBQ0EsV0FBRyxLQUFILENBQVMsSUFBVCxHQUFnQixPQUFoQjs7QUFFQSxlQUFPLEtBQUssVUFBWjtBQUNILEtBNU1nQzs7QUE4TWpDOzs7Ozs7QUFNQSxxQkFBaUIseUJBQVMsT0FBVCxFQUFrQjtBQUFBOztBQUMvQixZQUFNLGVBQWUsS0FBSyxVQUFMLENBQWdCLE1BQWhCLENBQXVCLGNBQU07QUFDOUMsbUJBQU8sR0FBRyxNQUFILElBQWEsR0FBRyxNQUFILENBQVUsWUFBdkIsSUFBdUMsR0FBRyxNQUFILENBQVUsWUFBVixDQUF1QixRQUF2QixDQUFnQyxPQUFoQyxDQUE5QztBQUNILFNBRm9CLENBQXJCOztBQUlBLFlBQUksYUFBYSxNQUFiLEdBQXNCLENBQTFCLEVBQTZCO0FBQ3pCLGdCQUFNLEtBQUssS0FBSyxJQUFMLENBQVUsTUFBVixDQUFpQixFQUE1QjtBQUNBLGdCQUFNLFVBQVUsR0FBRyxLQUFILENBQVMsSUFBekI7QUFDQSx5QkFBYSxPQUFiLENBQXFCO0FBQUEsdUJBQUssT0FBSyxTQUFMLENBQWUsQ0FBZixDQUFMO0FBQUEsYUFBckI7QUFDQSxlQUFHLEtBQUgsQ0FBUyxJQUFULEdBQWdCLE9BQWhCO0FBQ0g7O0FBRUQsZUFBTyxZQUFQO0FBQ0gsS0FqT2dDOztBQW1PakM7Ozs7Ozs7QUFPQSxnQkFBWSxvQkFBUyxPQUFULEVBQWtCO0FBQzFCLFlBQUksbUJBQW1CLEtBQXZCLEVBQThCO0FBQzFCO0FBQ0EsZ0JBQUksYUFBYSxLQUFLLFVBQXRCO0FBQ0Esb0JBQVEsT0FBUixDQUFnQixVQUFTLE1BQVQsRUFBaUIsS0FBakIsRUFBd0I7QUFDcEMsMkJBQVcsS0FBWCxFQUFrQixNQUFsQixHQUEyQixNQUEzQixDQURvQyxDQUNEO0FBQ3RDLGFBRkQ7QUFHSCxTQU5ELE1BTU8sSUFBSSxRQUFPLE9BQVAseUNBQU8sT0FBUCxPQUFtQixRQUF2QixFQUFpQztBQUNwQztBQUNBLGlCQUFLLFVBQUwsQ0FBZ0IsT0FBaEIsQ0FBd0IsVUFBUyxNQUFULEVBQWlCO0FBQ3JDLG9CQUFJLFFBQVEsT0FBTyxJQUFmLENBQUosRUFBMEI7QUFDdEIsMkJBQU8sTUFBUCxHQUFnQixRQUFRLE9BQU8sSUFBZixDQUFoQjtBQUNIO0FBQ0osYUFKRDtBQUtIO0FBQ0osS0F6UGdDOztBQTJQakM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQSxhQUFTLGlCQUFTLFFBQVQsRUFBbUIsT0FBbkIsRUFBNEI7QUFDakMsWUFBSSxFQUFFLE1BQU0sT0FBTixDQUFjLFFBQWQsS0FBMkIsT0FBTyxRQUFQLEtBQW9CLFVBQWpELENBQUosRUFBa0U7QUFDOUQsc0JBQVUsUUFBVjtBQUNBLHVCQUFXLFdBQVcsUUFBUSxJQUE5QjtBQUNIOztBQUVELG1CQUFXLEtBQUssTUFBTCxDQUFZLFFBQVosQ0FBWDs7QUFFQSxZQUFJLGFBQWEsU0FBakIsRUFBNEI7QUFDeEI7QUFDSDs7QUFFRCxZQUFJLENBQUMsTUFBTSxPQUFOLENBQWMsUUFBZCxDQUFMLEVBQThCO0FBQzFCLGtCQUFNLHFEQUFOO0FBQ0g7O0FBRUQsa0JBQVUsV0FBVyxFQUFyQjs7QUFFQSxZQUFJLE9BQU8sS0FBSyxJQUFoQjtBQUFBLFlBQ0ksU0FBUyxLQUFLLE1BQUwsQ0FBWSxRQUFRLE1BQXBCLENBRGI7QUFBQSxZQUMwQztBQUN0Qyx3QkFBZ0IsVUFBVSxDQUFDLEtBQUssUUFBTCxDQUFjLE1BQWQsQ0FBcUIsSUFBckIsQ0FBMEIsY0FBMUIsRUFGL0I7QUFBQSxZQUUyRTtBQUN2RSxrQkFBVSxRQUFRLEtBQVIsS0FBa0IsU0FBbEIsSUFBK0IsUUFBUSxLQUhyRCxDQWxCaUMsQ0FxQjJCOztBQUU1RDtBQUNBLFlBQUksaUJBQWlCLEtBQUssU0FBdEIsSUFBbUMsTUFBdkMsRUFBK0M7QUFDM0MsZ0JBQUksWUFBWSxLQUFLLFNBQXJCO0FBQ0EsbUJBQU8sT0FBUCxDQUFlLFVBQVMsWUFBVCxFQUF1QixLQUF2QixFQUE4QjtBQUN6QyxvQkFBSSxVQUFVLEtBQVYsS0FBb0IsVUFBVSxVQUFVLEtBQVYsRUFBaUIsS0FBL0MsSUFBd0QsYUFBYSxJQUFiLEtBQXNCLFVBQVUsS0FBVixFQUFpQixJQUEvRixJQUF1RyxVQUFVLEtBQVYsRUFBaUIsS0FBNUgsRUFBbUk7QUFDL0gsaUNBQWEsS0FBYixHQUFxQixVQUFVLEtBQVYsRUFBaUIsS0FBdEM7QUFDSDtBQUNKLGFBSkQ7QUFLSDs7QUFFRDtBQUNBLGFBQUssUUFBTCxDQUFjLE9BQWQsQ0FBc0IsVUFBUyxTQUFULEVBQW9CO0FBQ3RDLHNCQUFVLE9BQVYsQ0FBa0IsUUFBbEIsRUFBNEIsTUFBNUI7QUFDSCxTQUZEOztBQUlBLFlBQUksS0FBSyxVQUFULEVBQXFCO0FBQ2pCLGlCQUFLLFVBQUwsQ0FBZ0IsYUFBaEI7QUFDSDs7QUFFRCxZQUFJLE9BQUosRUFBYTtBQUNULGlCQUFLLE9BQUw7QUFDSDs7QUFFRCxZQUFJLGFBQUosRUFBbUI7QUFDZixpQkFBSyxhQUFMO0FBQ0g7O0FBRUQsYUFBSyxjQUFMOztBQUVBLGFBQUssV0FBTCxDQUFpQixLQUFLLFdBQUwsRUFBakI7QUFDSCxLQXJVZ0M7O0FBdVVqQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBLGFBQVMsaUJBQVMsUUFBVCxFQUFtQixPQUFuQixFQUE0QjtBQUNqQyxZQUFJLEVBQUUsTUFBTSxPQUFOLENBQWMsUUFBZCxLQUEyQixPQUFPLFFBQVAsS0FBb0IsVUFBakQsQ0FBSixFQUFrRTtBQUM5RCxzQkFBVSxRQUFWO0FBQ0EsdUJBQVcsV0FBVyxRQUFRLElBQTlCO0FBQ0g7O0FBRUQsbUJBQVcsS0FBSyxNQUFMLENBQVksUUFBWixDQUFYOztBQUVBLFlBQUksYUFBYSxTQUFqQixFQUE0QjtBQUN4QjtBQUNIOztBQUVELFlBQUksQ0FBQyxNQUFNLE9BQU4sQ0FBYyxRQUFkLENBQUwsRUFBOEI7QUFDMUIsa0JBQU0scURBQU47QUFDSDs7QUFFRCxrQkFBVSxXQUFXLEVBQXJCOztBQUVBLFlBQUksT0FBTyxLQUFLLElBQWhCO0FBQUEsWUFDSSxTQUFTLEtBQUssTUFBTCxDQUFZLFFBQVEsTUFBcEIsQ0FEYjtBQUFBLFlBQzBDO0FBQ3RDLHdCQUFnQixVQUFVLENBQUMsS0FBSyxRQUFMLENBQWMsTUFBZCxDQUFxQixJQUFyQixDQUEwQixjQUExQixFQUYvQjtBQUFBLFlBRTJFO0FBQ3ZFLGtCQUFVLFFBQVEsS0FBUixLQUFrQixTQUFsQixJQUErQixRQUFRLEtBSHJELENBbEJpQyxDQXFCMkI7O0FBRTVEO0FBQ0EsYUFBSyxRQUFMLENBQWMsT0FBZCxDQUFzQixVQUFTLFNBQVQsRUFBb0I7QUFDdEMsZ0JBQUksVUFBVSxPQUFkLEVBQXVCO0FBQ25CLDBCQUFVLE9BQVYsQ0FBa0IsUUFBbEIsRUFBNEIsTUFBNUI7QUFDSDtBQUNKLFNBSkQ7O0FBTUEsWUFBSSxLQUFLLFVBQVQsRUFBcUI7QUFDakIsaUJBQUssVUFBTCxDQUFnQixhQUFoQjtBQUNIOztBQUVELFlBQUksT0FBSixFQUFhO0FBQ1QsaUJBQUssT0FBTDtBQUNIOztBQUVELFlBQUksYUFBSixFQUFtQjtBQUNmLGlCQUFLLGFBQUw7QUFDSDs7QUFFRCxhQUFLLGNBQUw7O0FBRUEsYUFBSyxXQUFMLENBQWlCLEtBQUssV0FBTCxFQUFqQjtBQUNILEtBellnQzs7QUEyWWpDOzs7OztBQUtBLHNCQUFrQiw0QkFBVztBQUN6QixlQUFPLEtBQUssTUFBWjtBQUNILEtBbFpnQzs7QUFvWmpDOzs7O0FBSUEsb0JBQWdCLDBCQUFXO0FBQUE7O0FBQ3ZCLGFBQUssTUFBTCxHQUFjLEVBQWQ7O0FBRUEsYUFBSyxPQUFMLEdBQWUsT0FBZixDQUF1QixlQUFPO0FBQzFCLG1CQUFPLElBQVAsQ0FBWSxHQUFaLEVBQWlCLE9BQWpCLENBQXlCLHNCQUFjO0FBQ25DLG9CQUFNLFFBQVEsSUFBSSxVQUFKLENBQWQ7QUFDQSxvQkFBSSxTQUFTLFFBQU8sS0FBUCx5Q0FBTyxLQUFQLE9BQWlCLFFBQTFCLElBQXNDLE1BQU0sSUFBTixLQUFlLE9BQXpELEVBQWtFO0FBQzlELHdCQUFJLENBQUMsT0FBSyxNQUFMLENBQVksVUFBWixDQUFMLEVBQThCO0FBQzFCLCtCQUFLLE1BQUwsQ0FBWSxVQUFaLElBQTBCLEVBQTFCO0FBQ0g7QUFDRCwyQkFBSyxNQUFMLENBQVksVUFBWixFQUF3QixJQUF4QixDQUE2QixLQUE3QjtBQUNIO0FBQ0osYUFSRDtBQVNILFNBVkQ7O0FBWUEsYUFBSyxVQUFMLEdBQWtCLE9BQU8sSUFBUCxDQUFZLEtBQUssTUFBakIsRUFBeUIsTUFBM0M7O0FBRUEsWUFBSSxLQUFLLFVBQVQsRUFBcUI7QUFDakIsbUJBQU8sSUFBUCxDQUFZLEtBQUssTUFBakIsRUFBeUIsT0FBekIsQ0FBaUMsc0JBQWM7QUFDM0Msb0JBQU0sU0FBUyxPQUFLLElBQUwsQ0FBVSxlQUFWLENBQTBCLFVBQTFCLENBQWY7QUFDQSxvQkFBSSxNQUFKLEVBQVk7QUFDUiwyQkFBTyxRQUFQLEdBQWtCLElBQWxCO0FBQ0EsMkJBQU8sVUFBUCxHQUFvQixPQUFLLE1BQUwsQ0FBWSxVQUFaLEVBQXdCLE1BQTVDO0FBQ0EsMkJBQU8sVUFBUCxHQUFvQixPQUFLLE1BQUwsQ0FBWSxVQUFaLEVBQXdCLENBQXhCLENBQXBCOztBQUVBLHdCQUFNLFNBQVMsT0FBTyxNQUF0QjtBQUNBLHdCQUFJLE1BQUosRUFBWTtBQUNSLCtCQUFPLFVBQVAsR0FBb0IsT0FBSyxNQUFMLENBQVksVUFBWixFQUF3QixNQUE1QztBQUNIO0FBQ0o7QUFDSixhQVpEO0FBYUg7QUFDSixLQXhiZ0M7O0FBMGJqQzs7Ozs7Ozs7QUFRQSxxQkFBaUIseUJBQVMsT0FBVCxFQUFrQjtBQUMvQixZQUFJLFlBQUo7O0FBRUEsa0JBQVUsV0FBVyxFQUFyQjs7QUFFQSxZQUFJLFFBQVEsU0FBWixFQUF1QjtBQUNuQiwyQkFBZSxRQUFRLFNBQXZCO0FBQ0gsU0FGRCxNQUVPLElBQUksUUFBUSxTQUFaLEVBQXVCO0FBQzFCLDJCQUFlLElBQUksUUFBUSxTQUFaLEVBQWY7QUFDSCxTQUZNLE1BRUE7QUFDSCwyQkFBZSxJQUFJLGdCQUFKLEVBQWY7QUFDSDs7QUFFRCxlQUFPLFlBQVA7QUFDSCxLQWhkZ0M7O0FBa2RqQzs7Ozs7Ozs7Ozs7OztBQWFBLG9CQUFnQix3QkFBUyxPQUFULEVBQWtCO0FBQzlCLFlBQUksZUFBZSxLQUFLLGVBQUwsQ0FBcUIsT0FBckIsQ0FBbkI7QUFBQSxZQUNJLFVBQVUsZ0JBQWdCLGlCQUFpQixLQUFLLFNBRHBEOztBQUdBLFlBQUksT0FBSixFQUFhO0FBQ1QsaUJBQUssU0FBTCxHQUFpQixLQUFLLGlCQUFMLENBQXVCLFlBQXZCLEVBQXFDLE9BQXJDLENBQWpCO0FBQ0EsdUJBQVcsc0JBQVgsQ0FBa0MsSUFBbEMsQ0FBdUMsSUFBdkM7QUFDQSx1QkFBVyw2QkFBWCxDQUF5QyxJQUF6QyxDQUE4QyxJQUE5QztBQUNIOztBQUVELGVBQU8sT0FBUDtBQUNILEtBMWVnQzs7QUE0ZWpDOzs7O0FBSUEsdUJBQW1CLDJCQUFTLFlBQVQsRUFBdUIsT0FBdkIsRUFBZ0M7QUFDL0MsbUJBQVcsWUFBWCxDQUF3QixZQUF4QjtBQUNBLG1CQUFXLFlBQVgsQ0FBd0IsWUFBeEIsRUFBc0MsS0FBSyxJQUEzQztBQUNBLG1CQUFXLGVBQVgsQ0FBMkIsWUFBM0I7O0FBRUEscUJBQWEsZ0JBQWIsQ0FBOEIsV0FBVyxRQUFRLFFBQWpEOztBQUVBLGVBQU8sWUFBUDtBQUNILEtBeGZnQzs7QUEwZmpDOzs7Ozs7OztBQVFBLFFBQUksTUFBSixHQUFhO0FBQ1QsZUFBTyxLQUFLLFNBQUwsSUFBa0IsS0FBSyxTQUFMLENBQWUsU0FBZixFQUF6QjtBQUNILEtBcGdCZ0M7QUFxZ0JqQyxRQUFJLE1BQUosQ0FBVyxTQUFYLEVBQXNCO0FBQ2xCLGFBQUssU0FBTCxDQUFlLFNBQWYsQ0FBeUIsU0FBekI7QUFDSCxLQXZnQmdDOztBQXlnQmpDOzs7Ozs7QUFNQSxRQUFJLE9BQUosR0FBYztBQUNWLGVBQU8sS0FBSyxTQUFMLENBQWUsZ0JBQXRCO0FBQ0gsS0FqaEJnQzs7QUFtaEJqQzs7Ozs7QUFLQSxhQUFTLG1CQUFXO0FBQ2hCLGFBQUssU0FBTCxDQUFlLEtBQWY7QUFDSCxLQTFoQmdDOztBQTRoQmpDOzs7OztBQUtBLGlCQUFhLHVCQUFXO0FBQ3BCLGVBQU8sS0FBSyxTQUFMLENBQWUsV0FBZixFQUFQO0FBQ0gsS0FuaUJnQzs7QUFxaUJqQzs7Ozs7OztBQU9BLFlBQVEsZ0JBQVMsQ0FBVCxFQUFZO0FBQ2hCLGVBQU8sS0FBSyxTQUFMLENBQWUsTUFBZixDQUFzQixDQUF0QixDQUFQO0FBQ0gsS0E5aUJnQzs7QUFnakJqQzs7Ozs7OztBQU9BLGFBQVMsbUJBQVc7QUFDaEIsZUFBTyxLQUFLLFNBQUwsQ0FBZSxPQUFmLEVBQVA7QUFDSCxLQXpqQmdDOztBQTJqQmpDOzs7QUFHQSxvQkFBZ0IsMEJBQVc7QUFDdkIsZUFBTyxLQUFLLFVBQUwsQ0FBZ0Isa0JBQWhCLEVBQW9DLFdBQXBDLEVBQWlELE9BQWpELENBQVA7QUFDSCxLQWhrQmdDOztBQWtrQmpDOzs7Ozs7Ozs7QUFTQSxpQkFBYSxxQkFBUyxLQUFULEVBQWdCO0FBQ3pCLGVBQU8sS0FBSyxTQUFMLENBQWUsV0FBZixDQUEyQixNQUFNLFFBQU4sQ0FBZSxDQUExQyxLQUNILEtBQUssU0FBTCxDQUFlLEtBQWYsQ0FBcUIsTUFBTSxRQUFOLENBQWUsQ0FBcEMsQ0FESjtBQUVILEtBOWtCZ0M7O0FBZ2xCakM7Ozs7QUFJQSxtQkFBZSx1QkFBUyxXQUFULEVBQXNCO0FBQ2pDLGVBQU8sS0FBSyxJQUFMLENBQVUsVUFBVixDQUFxQixjQUFyQixJQUF1QyxLQUFLLFNBQUwsQ0FBZSxXQUFmLENBQTJCLFdBQTNCLENBQTlDO0FBQ0gsS0F0bEJnQzs7QUF3bEJqQzs7OztBQUlBLG1CQUFlLHlCQUFXO0FBQ3RCLGVBQU8sS0FBSyxJQUFMLENBQVUsY0FBVixDQUF5QixhQUF6QixFQUFQO0FBQ0gsS0E5bEJnQzs7QUFnbUJqQzs7Ozs7QUFLQSxrQ0FybUJpQywwQ0FxbUJGLEdBcm1CRSxFQXFtQkcsZ0JBcm1CSCxFQXFtQnFCO0FBQ2xELFlBQUksSUFBSSxXQUFKLEtBQW9CLFNBQXBCLElBQWlDLElBQUksYUFBSixLQUFzQixTQUEzRCxFQUFzRTtBQUNsRSxnQkFBSSxhQUFhLE9BQU8sTUFBUCxDQUFjLEVBQWQsRUFBa0IsSUFBSSxVQUFKLElBQWtCLGdCQUFsQixJQUFzQyxFQUF4RCxDQUFqQixDQURrRSxDQUNZO0FBQzlFLHVCQUFXLEtBQUssY0FBTCxDQUFvQixHQUFwQixDQUFYLElBQXVDLElBQUksYUFBM0M7QUFDQSxtQkFBTyxNQUFQLENBQWMsR0FBZCxFQUFtQixVQUFuQixFQUErQixFQUFFLHNCQUFGLEVBQS9CO0FBQ0g7QUFDSixLQTNtQmdDOzs7QUE2bUJqQyxvQkFBZ0Isd0JBQVMsR0FBVCxFQUFjO0FBQzFCLGlDQUF1QixJQUFJLFdBQTNCO0FBQ0gsS0EvbUJnQzs7QUFpbkJqQyxnQkFBWSxvQkFBUyxHQUFULEVBQWM7QUFDdEIsWUFBTSxNQUFNLEVBQVo7QUFDQSxlQUFPLElBQVAsQ0FBWSxHQUFaLEVBQWlCLE1BQWpCLENBQXdCO0FBQUEsbUJBQUssQ0FBQyxFQUFFLFVBQUYsQ0FBYSxJQUFiLENBQUQsSUFBdUIsQ0FBQyxFQUFFLFVBQUYsQ0FBYSxJQUFiLENBQTdCO0FBQUEsU0FBeEIsRUFBeUUsT0FBekUsQ0FBaUY7QUFBQSxtQkFBSyxJQUFJLENBQUosSUFBUyxJQUFJLENBQUosQ0FBZDtBQUFBLFNBQWpGO0FBQ0EsZUFBTyxHQUFQO0FBQ0gsS0FybkJnQzs7QUF1bkJqQzs7Ozs7QUFLQSxxQkFBaUIseUJBQVMsR0FBVCxFQUFjO0FBQUE7O0FBQzNCLFlBQUksQ0FBQyxLQUFLLGFBQUwsQ0FBbUIsR0FBbkIsQ0FBRCxJQUE0QixJQUFJLFVBQXBDLEVBQWdEO0FBQzVDLGlCQUFLLDhCQUFMLENBQW9DLEdBQXBDO0FBQ0EsZ0JBQUksSUFBSSxVQUFKLENBQWUsTUFBZixHQUF3QixDQUE1QixFQUErQjtBQUMzQixvQkFBTSxXQUFXLEtBQUssU0FBTCxDQUFlLE9BQWYsQ0FBdUIsR0FBdkIsQ0FBakI7O0FBRUEsb0JBQUksZ0JBQWdCLElBQUksVUFBeEI7O0FBRUEsb0JBQUksS0FBSyxJQUFMLENBQVUsVUFBVixDQUFxQixPQUF6QixFQUFrQztBQUM5Qix3QkFBSSxJQUFJLFVBQUosQ0FBZSxNQUFmLEtBQTBCLENBQTFCLElBQStCLENBQUMsSUFBSSxVQUFKLENBQWUsSUFBSSxVQUFKLENBQWUsTUFBZixHQUF3QixDQUF2QyxFQUEwQyxXQUExQyxDQUFwQyxFQUE0RjtBQUFBOztBQUN4Riw0QkFBSSxVQUFKLENBQWUsSUFBZixDQUFvQixPQUFPLE1BQVAsQ0FBYyxLQUFLLFVBQUwsQ0FBZ0IsR0FBaEIsQ0FBZCx3REFDZixXQURlLEVBQ0QsSUFEQyxtQ0FFZixLQUFLLGNBQUwsQ0FBb0IsR0FBcEIsQ0FGZSxFQUVlLElBQUksS0FBSyxjQUFMLENBQW9CLEdBQXBCLENBQUosQ0FGZiw4QkFBcEI7QUFJSDtBQUNELG9DQUFnQixJQUFJLFVBQUosQ0FBZSxLQUFmLENBQXFCLENBQXJCLENBQWhCO0FBQ0g7O0FBRUQscUJBQUssU0FBTCxDQUFlLE9BQWYsQ0FBdUIsYUFBdkIsRUFBc0MsV0FBVyxDQUFqRDs7QUFFQSxvQkFBSSxVQUFKLENBQWUsT0FBZixDQUF1QixhQUFLO0FBQ3hCLHNCQUFFLE1BQUYsR0FBVyxLQUFYO0FBQ0EsMkJBQUssOEJBQUwsQ0FBb0MsQ0FBcEMsRUFBdUMsT0FBSyxJQUFMLENBQVUsVUFBVixDQUFxQixPQUFyQixHQUErQixFQUEvQixHQUFvQyxJQUFJLFVBQS9FO0FBQ0gsaUJBSEQ7O0FBS0E7QUFDQSxvQkFBSSxDQUFDLEtBQUssSUFBTCxDQUFVLFVBQVYsQ0FBcUIsT0FBMUIsRUFBbUM7QUFDL0IseUJBQUssU0FBTCxDQUFlLElBQWYsQ0FBb0IsTUFBcEIsQ0FBMkIsUUFBM0IsRUFBcUMsQ0FBckM7QUFDSDtBQUNELHFCQUFLLFNBQUwsR0FBaUIsS0FBakI7QUFDQSxxQkFBSyxTQUFMLENBQWUsS0FBZixHQUF1QixFQUF2QjtBQUNIO0FBQ0o7QUFDRCxZQUFJLE1BQUosR0FBYSxJQUFiO0FBQ0gsS0E5cEJnQzs7QUFncUJqQzs7Ozs7QUFLQSx1QkFBbUIsMkJBQVMsR0FBVCxFQUFjO0FBQzdCLFlBQUksSUFBSSxNQUFKLElBQWMsSUFBSSxVQUFsQixJQUFnQyxJQUFJLFVBQUosQ0FBZSxNQUFmLEdBQXdCLENBQTVELEVBQStEO0FBQzNELGdCQUFNLFdBQVcsS0FBSyxTQUFMLENBQWUsT0FBZixDQUF1QixHQUF2QixJQUE4QixDQUEvQyxDQUQyRCxDQUNUOztBQUVsRDtBQUNBLGlCQUFLLGlCQUFMLENBQXVCLElBQUksVUFBSixDQUFlLENBQWYsQ0FBdkI7QUFDQSxpQkFBSyxJQUFJLElBQUksUUFBYixFQUF1QixJQUFJLFdBQVcsSUFBSSxVQUFKLENBQWUsTUFBMUIsR0FBbUMsQ0FBOUQsRUFBaUUsRUFBRSxDQUFuRSxFQUFzRTtBQUNsRSxxQkFBSyxpQkFBTCxDQUF1QixLQUFLLFNBQUwsQ0FBZSxJQUFmLENBQW9CLENBQXBCLENBQXZCLEVBRGtFLENBQ2xCO0FBQ25EO0FBQ0QsaUJBQUssU0FBTCxDQUFlLE1BQWYsQ0FBc0IsUUFBdEIsRUFBZ0MsSUFBSSxVQUFKLENBQWUsTUFBZixHQUF3QixDQUF4RDtBQUNIO0FBQ0QsWUFBSSxNQUFKLEdBQWEsS0FBYjtBQUNILEtBanJCZ0M7O0FBbXJCakM7Ozs7O0FBS0Esd0JBQW9CLDRCQUFTLE9BQVQsRUFBa0I7QUFDbEMsYUFBSyxpQ0FBTCxDQUF1QyxLQUFLLElBQUwsQ0FBVSxVQUFqRCxFQUE2RCxPQUE3RCxFQUFzRSxNQUF0RTs7QUFFQSxhQUFLLDZCQUFMO0FBQ0EsYUFBSyxlQUFMLENBQXFCLE9BQXJCO0FBQ0gsS0E3ckJnQzs7QUErckJqQzs7Ozs7QUFLQSwwQkFBc0IsOEJBQVMsT0FBVCxFQUFrQjtBQUNwQyxhQUFLLGlDQUFMLENBQXVDLEtBQUssSUFBTCxDQUFVLFVBQWpELEVBQTZELE9BQTdELEVBQXNFLFFBQXRFOztBQUVBLGFBQUssNkJBQUw7QUFDQSxhQUFLLGVBQUwsQ0FBcUIsT0FBckI7QUFDSCxLQXpzQmdDOztBQTJzQmpDOzs7Ozs7OztBQVFBLHVDQUFtQywyQ0FBUyxPQUFULEVBQWtCLE9BQWxCLEVBQTJCLFFBQTNCLEVBQXFDO0FBQUE7O0FBQ3BFLGdCQUFRLE9BQVIsQ0FBZ0IsY0FBTTtBQUNsQixnQkFBSSxHQUFHLE9BQUgsS0FBZSxPQUFuQixFQUE0QjtBQUN4QixtQkFBRyxlQUFILEdBQXFCLFFBQXJCO0FBQ0g7O0FBRUQsZ0JBQUksR0FBRyxRQUFILElBQWUsR0FBRyxRQUFILENBQVksTUFBWixHQUFxQixDQUF4QyxFQUEyQztBQUN2Qyx1QkFBSyxpQ0FBTCxDQUF1QyxHQUFHLFFBQTFDLEVBQW9ELE9BQXBELEVBQTZELFFBQTdEO0FBQ0g7QUFDSixTQVJEO0FBU0gsS0E3dEJnQzs7QUErdEJqQzs7O0FBR0EsbUJBQWUseUJBQVc7QUFBQTs7QUFDdEIsWUFBTSxZQUFZLFNBQVosU0FBWSxDQUFDLEdBQUQsRUFBUztBQUN2QixtQkFBSyxlQUFMLENBQXFCLEdBQXJCO0FBQ0EsZ0JBQUksSUFBSSxVQUFSLEVBQW9CO0FBQ2hCLG9CQUFJLFVBQUosQ0FBZSxPQUFmLENBQXVCO0FBQUEsMkJBQUssVUFBVSxDQUFWLENBQUw7QUFBQSxpQkFBdkI7QUFDSDtBQUNKLFNBTEQ7QUFNQSxXQUFHO0FBQ0MsaUJBQUssU0FBTCxHQUFpQixJQUFqQjtBQUNBLGlCQUFLLFNBQUwsQ0FBZSxJQUFmLENBQW9CLE9BQXBCLENBQTRCO0FBQUEsdUJBQU8sVUFBVSxHQUFWLENBQVA7QUFBQSxhQUE1QjtBQUNILFNBSEQsUUFHUyxDQUFDLEtBQUssU0FIZjs7QUFLQSxhQUFLLFNBQUwsQ0FBZSxLQUFmLEdBQXVCLEVBQXZCO0FBQ0gsS0EvdUJnQzs7QUFpdkJqQzs7Ozs7O0FBTUEsd0JBQW9CLDRCQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDL0IsZUFBTyxLQUFLLFNBQUwsQ0FBZSxrQkFBZixDQUFrQyxDQUFsQyxFQUFxQyxDQUFyQyxDQUFQO0FBQ0gsS0F6dkJnQzs7QUEydkJqQzs7Ozs7O0FBTUEseUJBQXFCLDZCQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDaEMsZUFBTyxLQUFLLFNBQUwsQ0FBZSxtQkFBZixDQUFtQyxDQUFuQyxFQUFzQyxDQUF0QyxDQUFQO0FBQ0gsS0Fud0JnQzs7QUFxd0JqQzs7Ozs7OztBQU9BLGdCQUFZLG9CQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDdkIsZUFBTyxLQUFLLFNBQUwsQ0FBZSxVQUFmLENBQTBCLENBQTFCLEVBQTZCLENBQTdCLENBQVA7QUFDSCxLQTl3QmdDOztBQWd4QmpDOzs7Ozs7O0FBT0EsZ0JBQVksb0JBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUN2QixlQUFPLEtBQUssU0FBTCxDQUFlLFVBQWYsQ0FBMEIsQ0FBMUIsRUFBNkIsQ0FBN0IsQ0FBUDtBQUNILEtBenhCZ0M7O0FBMnhCakMsWUFBUTtBQTN4QnlCLENBQXpCLENBQVo7O0FBOHhCQSxPQUFPLGdCQUFQLENBQXdCLE1BQU0sU0FBOUIsRUFBeUMsUUFBUSxjQUFSLEVBQXdCLFdBQWpFOztBQUVBLE9BQU8sT0FBUCxHQUFpQixLQUFqQjs7O0FDdnpCQTs7QUFFQTs7Ozs7OztBQUlBLFFBQVEsYUFBUixHQUF3QjtBQUNwQjs7Ozs7Ozs7O0FBU0EsMEJBQXNCLDhCQUFTLFlBQVQsRUFBdUIsQ0FBdkIsRUFBMEIsU0FBMUIsRUFBcUM7QUFDdkQsWUFBSSxVQUFVLE1BQVYsS0FBcUIsQ0FBekIsRUFBNEI7QUFDeEI7QUFDQSxtQkFBTyxhQUFhLE1BQWIsQ0FBb0Isb0JBQXBCLENBQXlDLGFBQWEsUUFBYixDQUFzQixDQUEvRCxFQUFrRSxhQUFhLE9BQS9FLENBQVA7QUFDSCxTQUhELE1BR087QUFDSDtBQUNBLG1CQUFPLEtBQUssU0FBTCxDQUFlLFlBQWYsRUFBNkIsb0JBQTdCLENBQWtELENBQWxELEVBQXFELFNBQXJELENBQVA7QUFDSDtBQUNKLEtBbEJtQjs7QUFvQnBCOzs7Ozs7Ozs7OztBQVdBLHVCQUFtQiwyQkFBUyxZQUFULEVBQXVCLENBQXZCLEVBQTBCLFNBQTFCLEVBQXFDO0FBQ3BELFlBQUksVUFBVSxNQUFWLEtBQXFCLENBQXpCLEVBQTRCO0FBQ3hCO0FBQ0EsbUJBQU8sT0FBTyxNQUFQLENBQWMsRUFBZCxFQUFrQixhQUFhLFVBQWIsSUFBMkIsRUFBN0MsRUFBaUQsYUFBYSxnQkFBYixJQUFpQyxFQUFsRixDQUFQO0FBQ0gsU0FIRCxNQUdPO0FBQ0g7QUFDQSxtQkFBTyxLQUFLLFNBQUwsQ0FBZSxZQUFmLEVBQTZCLGlCQUE3QixDQUErQyxDQUEvQyxFQUFrRCxTQUFsRCxDQUFQO0FBQ0g7QUFDSixLQXZDbUI7O0FBeUNwQjs7Ozs7Ozs7OztBQVVBLHFCQUFpQix5QkFBUyxZQUFULEVBQXVCLENBQXZCLEVBQTBCLEdBQTFCLEVBQStCLFNBQS9CLEVBQTBDO0FBQ3ZELFlBQUksUUFBTyxZQUFQLHlDQUFPLFlBQVAsT0FBd0IsUUFBNUIsRUFBc0M7QUFDbEMsa0JBQU0sQ0FBTjtBQUNBLG1CQUFPLGFBQWEsVUFBYixDQUF3QixHQUF4QixDQUFQO0FBQ0gsU0FIRCxNQUdPO0FBQ0gsZ0JBQUksU0FBUyxLQUFLLFNBQUwsQ0FBZSxZQUFmLENBQWI7QUFDQSxtQkFBTyxVQUFVLE9BQU8sZUFBUCxDQUF1QixDQUF2QixFQUEwQixHQUExQixFQUErQixTQUEvQixDQUFqQjtBQUNIO0FBQ0osS0EzRG1COztBQTZEcEI7Ozs7Ozs7O0FBUUEsdUJBQW1CLDJCQUFTLFlBQVQsRUFBdUIsQ0FBdkIsRUFBMEIsVUFBMUIsRUFBc0MsU0FBdEMsRUFBaUQ7QUFDaEUsWUFBSSxRQUFPLFlBQVAseUNBQU8sWUFBUCxPQUF3QixRQUE1QixFQUFzQztBQUNsQyx5QkFBYSxDQUFiO0FBQ0EsbUJBQU8sYUFBYSxNQUFiLENBQW9CLGlCQUFwQixDQUFzQyxhQUFhLFFBQWIsQ0FBc0IsQ0FBNUQsRUFBK0QsVUFBL0QsRUFBMkUsYUFBYSxPQUF4RixDQUFQO0FBQ0gsU0FIRCxNQUdPO0FBQ0gsbUJBQU8sS0FBSyxTQUFMLENBQWUsWUFBZixFQUE2QixpQkFBN0IsQ0FBK0MsQ0FBL0MsRUFBa0QsVUFBbEQsRUFBOEQsU0FBOUQsQ0FBUDtBQUNIO0FBQ0osS0E1RW1COztBQThFcEI7Ozs7Ozs7O0FBUUEsdUJBQW1CLDJCQUFTLFlBQVQsRUFBdUIsQ0FBdkIsRUFBMEIsVUFBMUIsRUFBc0MsU0FBdEMsRUFBaUQ7QUFDaEUsWUFBSSxRQUFPLFlBQVAseUNBQU8sWUFBUCxPQUF3QixRQUE1QixFQUFzQztBQUNsQyx5QkFBYSxDQUFiO0FBQ0EsbUJBQU8sYUFBYSxNQUFiLENBQW9CLGlCQUFwQixDQUFzQyxhQUFhLFFBQWIsQ0FBc0IsQ0FBNUQsRUFBK0QsVUFBL0QsRUFBMkUsYUFBYSxPQUF4RixDQUFQLENBRmtDLENBRXVFO0FBQzVHLFNBSEQsTUFHTztBQUNILG1CQUFPLEtBQUssU0FBTCxDQUFlLFlBQWYsRUFBNkIsaUJBQTdCLENBQStDLENBQS9DLEVBQWtELFVBQWxELEVBQThELFNBQTlELENBQVA7QUFDSDtBQUNKLEtBN0ZtQjs7QUErRnBCOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLHFCQUFpQix5QkFBUyxZQUFULEVBQXVCLENBQXZCLEVBQTBCLEdBQTFCLEVBQStCLEtBQS9CLEVBQXNDLFNBQXRDLEVBQWlEO0FBQzlELFlBQUksaUJBQUo7QUFDQSxZQUFJLFFBQU8sWUFBUCx5Q0FBTyxZQUFQLE9BQXdCLFFBQTVCLEVBQXNDO0FBQ2xDLG9CQUFRLEdBQVI7QUFDQSxrQkFBTSxDQUFOO0FBQ0EsZ0NBQW9CLGFBQWEsZUFBYixDQUE2QixHQUE3QixFQUFrQyxLQUFsQyxDQUFwQjtBQUNILFNBSkQsTUFJTztBQUNILGdDQUFvQixLQUFLLFNBQUwsQ0FBZSxZQUFmLEVBQTZCLGVBQTdCLENBQTZDLENBQTdDLEVBQWdELEdBQWhELEVBQXFELEtBQXJELEVBQTRELFNBQTVELENBQXBCO0FBQ0EsaUJBQUssSUFBTCxDQUFVLFFBQVYsQ0FBbUIsd0JBQW5CLENBQTRDLFlBQTVDLEVBQTBELENBQTFELEVBQTZELFNBQTdEO0FBQ0g7QUFDRCxlQUFPLGlCQUFQO0FBQ0g7QUExSG1CLENBQXhCOztBQTZIQTs7OztBQUlBLFFBQVEsV0FBUixHQUFzQjs7QUFFbEI7Ozs7Ozs7OztBQVNBLHVCQUFtQiwyQkFBUyxRQUFULEVBQW1CLFNBQW5CLEVBQThCO0FBQzdDLGVBQU8sS0FBSyxvQkFBTCxDQUEwQixRQUExQixFQUFvQyxTQUFwQyxLQUFrRCxLQUFLLFVBQTlEO0FBQ0gsS0FiaUI7O0FBZWxCOzs7Ozs7QUFNQSx1QkFBbUIsMkJBQVMsUUFBVCxFQUFtQixVQUFuQixFQUErQixTQUEvQixFQUEwQztBQUN6RCxlQUFPLE9BQU8sTUFBUCxDQUFjLHdCQUF3QixJQUF4QixDQUE2QixJQUE3QixFQUFtQyxRQUFuQyxFQUE2QyxTQUE3QyxDQUFkLEVBQXVFLFVBQXZFLENBQVA7QUFDSCxLQXZCaUI7O0FBeUJsQjs7Ozs7O0FBTUEsdUJBQW1CLDJCQUFTLFFBQVQsRUFBbUIsVUFBbkIsRUFBK0IsU0FBL0IsRUFBMEM7QUFDekQsZUFBTyxPQUFPLE1BQVAsQ0FBYyx3QkFBd0IsSUFBeEIsQ0FBNkIsSUFBN0IsRUFBbUMsUUFBbkMsRUFBNkMsU0FBN0MsQ0FBZCxFQUF1RSxVQUF2RSxDQUFQO0FBQ0gsS0FqQ2lCOztBQW1DbEI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkEsMEJBQXNCLDhCQUFTLFFBQVQsRUFBbUIsU0FBbkIsRUFBOEI7QUFDaEQsWUFBSSxRQUFKO0FBQ0E7QUFDSTtBQUNBLGFBQUMsV0FBVyxDQUFDLGFBQWEsS0FBSyxTQUFuQixFQUE4QixjQUE5QixDQUE2QyxRQUE3QyxDQUFaLEtBQXVFO0FBQ3ZFLG9CQURBLElBQ1ksU0FBUyxLQUFLLElBQWQsQ0FEWixJQUVBLElBSkosQ0FJUzs7QUFKVDtBQU1ILEtBM0RpQjs7QUE2RGxCLDZCQUF5QixpQ0FBUyxRQUFULEVBQW1CLFNBQW5CLEVBQThCO0FBQ25ELG9CQUFZLGFBQWEsS0FBSyxTQUE5QjtBQUNBLFlBQUksV0FBVyxVQUFVLGNBQVYsQ0FBeUIsUUFBekIsQ0FBZjtBQUNBLFlBQUksUUFBSixFQUFjO0FBQ1YsbUJBQU8sU0FBUyxLQUFLLElBQWQsQ0FBUDtBQUNBLGdCQUFJLE9BQU8sSUFBUCxDQUFZLFFBQVosRUFBc0IsTUFBdEIsS0FBaUMsQ0FBckMsRUFBd0M7QUFDcEMsMEJBQVUsY0FBVixDQUF5QixRQUF6QjtBQUNIO0FBQ0o7QUFDSixLQXRFaUI7O0FBd0VsQjs7Ozs7Ozs7QUFRQSxxQkFBaUIseUJBQVMsUUFBVCxFQUFtQixHQUFuQixFQUF3QixTQUF4QixFQUFtQztBQUNoRCxlQUFPLEtBQUssaUJBQUwsQ0FBdUIsUUFBdkIsRUFBaUMsU0FBakMsRUFBNEMsR0FBNUMsQ0FBUDtBQUNILEtBbEZpQjs7QUFvRmxCOzs7Ozs7O0FBT0EscUJBQWlCLHlCQUFTLFFBQVQsRUFBbUIsR0FBbkIsRUFBd0IsS0FBeEIsRUFBK0IsU0FBL0IsRUFBMEM7QUFDdkQsWUFBSSxZQUFZLHdCQUF3QixJQUF4QixDQUE2QixJQUE3QixFQUFtQyxRQUFuQyxFQUE2QyxTQUE3QyxDQUFoQjtBQUNBLGtCQUFVLEdBQVYsSUFBaUIsS0FBakI7QUFDQSxlQUFPLFNBQVA7QUFDSCxLQS9GaUI7O0FBaUdsQix3QkFBb0IsNEJBQVMsUUFBVCxFQUFtQixHQUFuQixFQUF3QixTQUF4QixFQUFtQztBQUNuRCxZQUFJLFlBQVksS0FBSyxvQkFBTCxDQUEwQixRQUExQixFQUFvQyxTQUFwQyxDQUFoQjtBQUNBLFlBQUksU0FBSixFQUFlO0FBQ1gsbUJBQU8sVUFBVSxHQUFWLENBQVA7QUFDSDtBQUNKLEtBdEdpQjs7QUF3R2xCOzs7O0FBSUEsNEJBQXdCLGtDQUFXO0FBQy9CLGFBQUssUUFBTCxDQUFjLFFBQWQsQ0FBdUIsT0FBdkIsQ0FBK0IsVUFBUyxTQUFULEVBQW9CO0FBQy9DLGlCQUFLLElBQUksSUFBSSxVQUFVLFdBQVYsRUFBYixFQUFzQyxHQUF0QyxHQUE0QztBQUN4QyxxQkFBSyx1QkFBTCxDQUE2QixDQUE3QixFQUFnQyxTQUFoQztBQUNIO0FBQ0osU0FKRCxFQUlHLElBSkg7QUFLSDtBQWxIaUIsQ0FBdEI7O0FBcUhBOzs7Ozs7O0FBT0EsU0FBUyx1QkFBVCxDQUFpQyxRQUFqQyxFQUEyQyxTQUEzQyxFQUFzRDtBQUNsRCxXQUFPLEtBQUssb0JBQUwsQ0FBMEIsUUFBMUIsRUFBb0MsU0FBcEMsS0FBa0Qsd0JBQXdCLElBQXhCLENBQTZCLElBQTdCLEVBQW1DLFFBQW5DLEVBQTZDLFNBQTdDLENBQXpEO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BLFNBQVMsdUJBQVQsQ0FBaUMsUUFBakMsRUFBMkMsU0FBM0MsRUFBc0Q7QUFDbEQsUUFBSSxXQUFXLENBQUMsYUFBYSxLQUFLLFNBQW5CLEVBQThCLGNBQTlCLENBQTZDLFFBQTdDLEVBQXVELElBQXZELENBQWY7QUFBQSxRQUNJLFFBQVEsS0FBSyxVQURqQjs7QUFHQSxZQUFRLEtBQUssTUFBYjtBQUNJLGFBQUssS0FBSyxRQUFMLENBQWMsZUFBbkI7QUFDSSxvQkFBUSxNQUFNLFVBQWQ7QUFDQTtBQUNKLGFBQUssS0FBSyxRQUFMLENBQWMsY0FBbkI7QUFDSSxvQkFBUSxNQUFNLFNBQWQ7QUFDQTtBQU5SOztBQVNBLFdBQVEsU0FBUyxLQUFLLElBQWQsSUFBc0IsT0FBTyxNQUFQLENBQWMsS0FBZCxDQUE5QjtBQUNIOzs7QUMzUkQ7O0FBRUEsSUFBSSxTQUFTLEVBQWI7O0FBRUEsSUFBSSxhQUFhLEVBQWpCOztBQUVBLElBQUksa0NBQWtDO0FBQ2xDLFNBQUssZUFBVztBQUNaO0FBQ0EsZUFBTyxVQUFQO0FBQ0gsS0FKaUM7QUFLbEMsU0FBSyxhQUFTLENBQVQsRUFBWTtBQUNiO0FBQ0g7QUFQaUMsQ0FBdEM7O0FBVUEsU0FBUyx5QkFBVCxHQUFxQztBQUNqQyxRQUFJLENBQUMsT0FBTyxvQkFBWixFQUFrQztBQUM5QixnQkFBUSxJQUFSLENBQWEsNlRBQWI7QUFDQSxlQUFPLG9CQUFQLEdBQThCLElBQTlCO0FBQ0g7QUFDSjs7QUFFRCxRQUFRLFdBQVIsR0FBc0I7QUFDbEIsZ0JBQVk7QUFDUixhQUFLLGVBQVc7QUFDWixnQkFBSSxDQUFDLE9BQU8sVUFBWixFQUF3QjtBQUNwQix3QkFBUSxJQUFSLENBQWEsOE5BQWI7QUFDQSx1QkFBTyxVQUFQLEdBQW9CLElBQXBCO0FBQ0g7QUFDRCxtQkFBTyxLQUFLLE1BQVo7QUFDSDtBQVBPLEtBRE07QUFVbEIsbUJBQWUsK0JBVkc7QUFXbEIsMEJBQXNCO0FBWEosQ0FBdEI7OztBQ3ZCQTs7QUFFQTs7Ozs7O0FBS0EsU0FBUyxzQkFBVCxHQUFrQztBQUM5QixRQUFJLFNBQVMsSUFBYjtBQUFBLFFBQ0ksWUFBWSxPQUFPLFFBQVAsQ0FBZ0IsSUFBaEIsQ0FBcUIsVUFEckM7QUFBQSxRQUVJLFVBRko7O0FBSUEsaUJBQWEsT0FBTyxNQUFQLENBQWMsU0FBZCxFQUF5Qjs7QUFFbEMsZUFBTyxFQUFFO0FBQ0wsaUJBQUssZUFBVztBQUNaLHVCQUFPLE9BQU8sS0FBZDtBQUNIO0FBSEUsU0FGMkI7O0FBUWxDLGNBQU0sRUFBRTtBQUNMLGlCQUFLLGVBQVc7QUFDWCx1QkFBTyxPQUFPLElBQWQ7QUFDSDtBQUhDLFNBUjRCOztBQWNsQyxlQUFPLEVBQUU7QUFDTCxpQkFBSyxlQUFXO0FBQ1osdUJBQU8sT0FBTyxJQUFkO0FBQ0g7QUFIRSxTQWQyQjs7QUFvQmxDLG9CQUFZLEVBQUU7QUFDVixpQkFBSyxlQUFXO0FBQ1osdUJBQU8sT0FBTyxJQUFkO0FBQ0g7QUFITyxTQXBCc0I7O0FBMEJsQyxnQkFBUTtBQUNKLGlCQUFLLGVBQVc7QUFDWix1QkFBTyxPQUFPLE1BQWQ7QUFDSCxhQUhHO0FBSUosaUJBQUssYUFBUyxNQUFULEVBQWlCO0FBQ2xCLG9CQUFJLFNBQVMsT0FBTyxVQUFwQixFQUFnQztBQUM1QjtBQUNBLDhCQUFVLE1BQVYsR0FBbUIsTUFBbkIsQ0FGNEIsQ0FFRDtBQUM5QjtBQUNELHVCQUFPLE1BQVAsR0FBZ0IsTUFBaEI7QUFDSDtBQVZHLFNBMUIwQjs7QUF1Q2xDLGNBQU07QUFDRixpQkFBSyxlQUFXO0FBQ1osdUJBQU8sT0FBTyxJQUFkO0FBQ0gsYUFIQztBQUlGLGlCQUFLLGFBQVMsSUFBVCxFQUFlO0FBQ2hCLG9CQUFJLFNBQVMsT0FBTyxVQUFwQixFQUFnQztBQUM1QjtBQUNBLDhCQUFVLElBQVYsR0FBaUIsSUFBakIsQ0FGNEIsQ0FFTDtBQUMxQjtBQUNELHVCQUFPLElBQVAsR0FBYyxJQUFkO0FBQ0g7QUFWQyxTQXZDNEI7O0FBb0RsQyxvQkFBWTtBQUNSLGlCQUFLLGVBQVc7QUFDWix1QkFBTyxPQUFPLFVBQWQ7QUFDSCxhQUhPO0FBSVIsaUJBQUssYUFBUyxVQUFULEVBQXFCO0FBQ3RCLG9CQUFJLFNBQVMsT0FBTyxVQUFwQixFQUFnQztBQUM1QjtBQUNBLDhCQUFVLFVBQVYsR0FBdUIsVUFBdkIsQ0FGNEIsQ0FFTztBQUN0QztBQUNELHVCQUFPLFVBQVAsR0FBb0IsVUFBcEI7QUFDSDtBQVZPLFNBcERzQjs7QUFpRWxDLGdCQUFRO0FBQ0osaUJBQUssZUFBVztBQUNaLHVCQUFPLFlBQVksT0FBTyxNQUFuQixHQUE0QixPQUFPLE1BQVAsQ0FBYyxNQUExQyxHQUFtRCxVQUFVLE1BQXBFO0FBQ0gsYUFIRztBQUlKLGlCQUFLLGFBQVMsTUFBVCxFQUFpQjtBQUNsQixvQkFBSSxTQUFTLE9BQU8sVUFBcEIsRUFBZ0M7QUFDNUI7QUFDQSwyQkFBTyxjQUFQLENBQXNCLElBQXRCLEVBQTRCLFFBQTVCLEVBQXNDO0FBQ2xDLG9DQUFZLElBRHNCO0FBRWxDLHNDQUFjLElBRm9CO0FBR2xDLGtDQUFVLElBSHdCO0FBSWxDLCtCQUFPO0FBSjJCLHFCQUF0QztBQU1ILGlCQVJELE1BUU8sSUFBSSxXQUFXLFNBQWYsRUFBMEI7QUFDN0IsMkJBQU8sT0FBTyxNQUFQLENBQWMsTUFBckIsQ0FENkIsQ0FDQTtBQUNoQyxpQkFGTSxNQUVBO0FBQ0gsMkJBQU8sTUFBUCxDQUFjLE1BQWQsR0FBdUIsTUFBdkI7QUFDSDtBQUNKO0FBbEJHLFNBakUwQjs7QUFzRmxDLGtCQUFVO0FBQ04saUJBQUssZUFBVztBQUNaLHVCQUFPLGNBQWMsT0FBTyxNQUFyQixHQUE4QixPQUFPLE1BQVAsQ0FBYyxRQUE1QyxHQUF1RCxVQUFVLFFBQXhFO0FBQ0gsYUFISztBQUlOLGlCQUFLLGFBQVMsUUFBVCxFQUFtQjtBQUNwQixvQkFBSSxTQUFTLE9BQU8sVUFBcEIsRUFBZ0M7QUFDNUI7QUFDQSwyQkFBTyxjQUFQLENBQXNCLElBQXRCLEVBQTRCLFVBQTVCLEVBQXdDO0FBQ3BDLG9DQUFZLElBRHdCO0FBRXBDLHNDQUFjLElBRnNCO0FBR3BDLGtDQUFVLElBSDBCO0FBSXBDLCtCQUFPO0FBSjZCLHFCQUF4QztBQU1ILGlCQVJELE1BUU8sSUFBSSxhQUFhLFNBQWpCLEVBQTRCO0FBQy9CLDJCQUFPLE9BQU8sTUFBUCxDQUFjLFFBQXJCLENBRCtCLENBQ0E7QUFDbEMsaUJBRk0sTUFFQTtBQUNILDJCQUFPLE1BQVAsQ0FBYyxRQUFkLEdBQXlCLFFBQXpCO0FBQ0g7QUFDSjtBQWxCSyxTQXRGd0I7O0FBMkdsQyxnQkFBUTtBQUNKO0FBQ0E7QUFDQSxtQkFBTyxpQkFBVztBQUNkLHVCQUFPLE9BQU8sTUFBUCxDQUFjO0FBQ2pCLDRCQUFRLEtBQUssTUFESTtBQUVqQiwwQkFBTSxLQUFLLElBRk07QUFHakIsZ0NBQVksS0FBSyxVQUhBO0FBSWpCLDRCQUFRLEtBQUssTUFKSTtBQUtqQiw4QkFBVSxLQUFLO0FBTEUsaUJBQWQsRUFNSixJQU5JLENBQVA7QUFPSDtBQVhHOztBQTNHMEIsS0FBekIsQ0FBYjs7QUEySEEsV0FBTyxnQkFBUCxDQUF3QixVQUF4QixFQUFvQztBQUNoQyxtQkFBVyxFQUFFLE9BQU8sT0FBTyxNQUFQLENBQWMsVUFBZCxFQUEwQix1QkFBdUIsb0JBQWpELENBQVQsRUFEcUI7QUFFaEMsb0JBQVksRUFBRSxPQUFPLE9BQU8sTUFBUCxDQUFjLFVBQWQsRUFBMEIsdUJBQXVCLHFCQUFqRCxDQUFULEVBRm9CO0FBR2hDLHNCQUFjLEVBQUUsT0FBTyxPQUFPLE1BQVAsQ0FBYyxVQUFkLEVBQTBCLHVCQUF1Qix1QkFBakQsQ0FBVCxFQUhrQjtBQUloQywwQkFBa0IsRUFBRSxPQUFPLE9BQU8sTUFBUCxDQUFjLFVBQWQsRUFBMEIsdUJBQXVCLGlCQUFqRCxDQUFUO0FBSmMsS0FBcEM7O0FBT0EsV0FBTyxVQUFQO0FBQ0g7O0FBRUQsdUJBQXVCLHFCQUF2QixHQUErQztBQUMzQyxVQUFNO0FBQ0Ysc0JBQWMsSUFEWjtBQUVGLG9CQUFZLElBRlY7QUFHRixhQUFLLGVBQVc7QUFDWixtQkFBTyxLQUFLLGNBQVo7QUFDSCxTQUxDO0FBTUYsYUFBSyxhQUFTLEtBQVQsRUFBZ0I7QUFDakIsaUJBQUssY0FBTCxHQUFzQixLQUF0QjtBQUNIO0FBUkMsS0FEcUM7QUFXM0MsV0FBTztBQUNILHNCQUFjLElBRFg7QUFFSCxvQkFBWSxJQUZUO0FBR0gsYUFBSyxlQUFXO0FBQ1osbUJBQU8sS0FBSyxlQUFaO0FBQ0gsU0FMRTtBQU1ILGFBQUssYUFBUyxLQUFULEVBQWdCO0FBQ2pCLGlCQUFLLGVBQUwsR0FBdUIsS0FBdkI7QUFDSDtBQVJFLEtBWG9DO0FBcUIzQyxxQkFBaUI7QUFDYixzQkFBYyxJQUREO0FBRWIsb0JBQVksSUFGQztBQUdiLGFBQUssZUFBVztBQUNaLG1CQUFPLEtBQUsseUJBQVo7QUFDSCxTQUxZO0FBTWIsYUFBSyxhQUFTLEtBQVQsRUFBZ0I7QUFDakIsaUJBQUsseUJBQUwsR0FBaUMsS0FBakM7QUFDSDtBQVJZLEtBckIwQjtBQStCM0MsNkJBQXlCO0FBQ3JCLHNCQUFjLElBRE87QUFFckIsb0JBQVksSUFGUztBQUdyQixhQUFLLGVBQVc7QUFDWixtQkFBTyxLQUFLLGlDQUFaO0FBQ0gsU0FMb0I7QUFNckIsYUFBSyxhQUFTLEtBQVQsRUFBZ0I7QUFDakIsaUJBQUssaUNBQUwsR0FBeUMsS0FBekM7QUFDSDtBQVJvQixLQS9Ca0I7QUF5QzNDLDhCQUEwQjtBQUN0QixzQkFBYyxJQURRO0FBRXRCLG9CQUFZLElBRlU7QUFHdEIsYUFBSyxlQUFXO0FBQ1osbUJBQU8sS0FBSyxrQ0FBWjtBQUNILFNBTHFCO0FBTXRCLGFBQUssYUFBUyxLQUFULEVBQWdCO0FBQ2pCLGlCQUFLLGtDQUFMLEdBQTBDLEtBQTFDO0FBQ0g7QUFScUIsS0F6Q2lCO0FBbUQzQyxjQUFVO0FBQ04sc0JBQWMsSUFEUjtBQUVOLG9CQUFZLElBRk47QUFHTixhQUFLLGVBQVc7QUFDWixtQkFBTyxLQUFLLFlBQVo7QUFDSCxTQUxLO0FBTU4sYUFBSyxhQUFTLEtBQVQsRUFBZ0I7QUFDakIsaUJBQUssWUFBTCxHQUFvQixLQUFwQjtBQUNIO0FBUkssS0FuRGlDO0FBNkQzQyw4QkFBMEI7QUFDdEIsc0JBQWMsSUFEUTtBQUV0QixvQkFBWSxJQUZVO0FBR3RCLGFBQUssZUFBVztBQUNaLG1CQUFPLEtBQUssa0NBQVo7QUFDSCxTQUxxQjtBQU10QixhQUFLLGFBQVMsS0FBVCxFQUFnQjtBQUNqQixpQkFBSyxrQ0FBTCxHQUEwQyxLQUExQztBQUNIO0FBRUw7QUFWMEIsS0E3RGlCLEVBQS9DOztBQTBFQSx1QkFBdUIsb0JBQXZCLEdBQThDO0FBQzFDLFVBQU07QUFDRixzQkFBYyxJQURaO0FBRUYsb0JBQVksSUFGVjtBQUdGLGFBQUssZUFBVztBQUNaLG1CQUFPLEtBQUssYUFBWjtBQUNILFNBTEM7QUFNRixhQUFLLGFBQVMsS0FBVCxFQUFnQjtBQUNqQixpQkFBSyxhQUFMLEdBQXFCLEtBQXJCO0FBQ0g7QUFSQyxLQURvQztBQVcxQyxXQUFPO0FBQ0gsc0JBQWMsSUFEWDtBQUVILG9CQUFZLElBRlQ7QUFHSCxhQUFLLGVBQVc7QUFDWixtQkFBTyxLQUFLLGNBQVo7QUFDSCxTQUxFO0FBTUgsYUFBSyxhQUFTLEtBQVQsRUFBZ0I7QUFDakIsaUJBQUssY0FBTCxHQUFzQixLQUF0QjtBQUNIO0FBUkUsS0FYbUM7QUFxQjFDLHFCQUFpQjtBQUNiLHNCQUFjLElBREQ7QUFFYixvQkFBWSxJQUZDO0FBR2IsYUFBSyxlQUFXO0FBQ1osbUJBQU8sS0FBSyx3QkFBWjtBQUNILFNBTFk7QUFNYixhQUFLLGFBQVMsS0FBVCxFQUFnQjtBQUNqQixpQkFBSyx3QkFBTCxHQUFnQyxLQUFoQztBQUNIO0FBUlksS0FyQnlCO0FBK0IxQyw2QkFBeUI7QUFDckIsc0JBQWMsSUFETztBQUVyQixvQkFBWSxJQUZTO0FBR3JCLGFBQUssZUFBVztBQUNaLG1CQUFPLEtBQUssZ0NBQVo7QUFDSCxTQUxvQjtBQU1yQixhQUFLLGFBQVMsS0FBVCxFQUFnQjtBQUNqQixpQkFBSyxnQ0FBTCxHQUF3QyxLQUF4QztBQUNIO0FBUm9CLEtBL0JpQjtBQXlDMUMsOEJBQTBCO0FBQ3RCLHNCQUFjLElBRFE7QUFFdEIsb0JBQVksSUFGVTtBQUd0QixhQUFLLGVBQVc7QUFDWixtQkFBTyxLQUFLLGlDQUFaO0FBQ0gsU0FMcUI7QUFNdEIsYUFBSyxhQUFTLEtBQVQsRUFBZ0I7QUFDakIsaUJBQUssaUNBQUwsR0FBeUMsS0FBekM7QUFDSDtBQVJxQixLQXpDZ0I7QUFtRDFDLDhCQUEwQjtBQUN0QixzQkFBYyxJQURRO0FBRXRCLG9CQUFZLElBRlU7QUFHdEIsYUFBSyxlQUFXO0FBQ1osbUJBQU8sS0FBSyxpQ0FBWjtBQUNILFNBTHFCO0FBTXRCLGFBQUssYUFBUyxLQUFULEVBQWdCO0FBQ2pCLGlCQUFLLGlDQUFMLEdBQXlDLEtBQXpDO0FBQ0g7QUFScUIsS0FuRGdCO0FBNkQxQyxjQUFVO0FBQ04sc0JBQWMsSUFEUjtBQUVOLG9CQUFZLElBRk47QUFHTixhQUFLLGVBQVc7QUFDWixnQkFBSSxLQUFLLElBQUwsQ0FBVSxVQUFWLENBQXFCLG1CQUF6QixFQUE4QztBQUMxQyxvQkFBSSxNQUFKO0FBQ0Esb0JBQUksS0FBSyxTQUFULEVBQW9CO0FBQ2hCLDZCQUFTLEtBQUssYUFBTCxHQUFxQixTQUFyQixHQUFpQyxXQUExQztBQUNILGlCQUZELE1BRU8sSUFBSSxLQUFLLFdBQVQsRUFBc0I7QUFDekIsNkJBQVMsS0FBSyxlQUFMLEdBQXVCLFNBQXZCLEdBQW1DLFdBQTVDO0FBQ0gsaUJBRk0sTUFFQSxJQUFJLEtBQUssV0FBVCxFQUFzQjtBQUN6Qiw2QkFBUyxZQUFUO0FBQ0g7QUFDRCx1QkFBTyxNQUFQO0FBQ0g7QUFDSixTQWZLO0FBZ0JOLGFBQUssYUFBUyxLQUFULEVBQWdCO0FBQ2pCO0FBQ0EsbUJBQU8sY0FBUCxDQUFzQixJQUF0QixFQUE0QixVQUE1QixFQUF3QztBQUNwQyw4QkFBYyxJQURzQjtBQUVwQyw0QkFBWSxJQUZ3QjtBQUdwQywwQkFBVSxJQUgwQjtBQUlwQyx1QkFBTztBQUo2QixhQUF4QztBQU1IO0FBeEJLO0FBN0RnQyxDQUE5Qzs7QUF5RkEsdUJBQXVCLGlCQUF2QixHQUEyQztBQUN2QyxVQUFNO0FBQ0Ysc0JBQWMsSUFEWjtBQUVGLG9CQUFZLElBRlY7QUFHRixhQUFLLGVBQVc7QUFDWixtQkFBTyxLQUFLLFVBQVo7QUFDSCxTQUxDO0FBTUYsYUFBSyxhQUFTLEtBQVQsRUFBZ0I7QUFDakIsaUJBQUssVUFBTCxHQUFrQixLQUFsQjtBQUNIO0FBUkMsS0FEaUM7QUFXdkMsV0FBTztBQUNILHNCQUFjLElBRFg7QUFFSCxvQkFBWSxJQUZUO0FBR0gsYUFBSyxlQUFXO0FBQ1osbUJBQU8sS0FBSyxXQUFaO0FBQ0gsU0FMRTtBQU1ILGFBQUssYUFBUyxLQUFULEVBQWdCO0FBQ2pCLGlCQUFLLFdBQUwsR0FBbUIsS0FBbkI7QUFDSDtBQVJFLEtBWGdDO0FBcUJ2QyxxQkFBaUI7QUFDYixzQkFBYyxJQUREO0FBRWIsb0JBQVksSUFGQztBQUdiLGFBQUssZUFBVztBQUNaLG1CQUFPLEtBQUsscUJBQVo7QUFDSCxTQUxZO0FBTWIsYUFBSyxhQUFTLEtBQVQsRUFBZ0I7QUFDakIsaUJBQUsscUJBQUwsR0FBNkIsS0FBN0I7QUFDSDtBQVJZLEtBckJzQjtBQStCdkMsOEJBQTBCO0FBQ3RCLHNCQUFjLElBRFE7QUFFdEIsb0JBQVksSUFGVTtBQUd0QixhQUFLLGVBQVc7QUFDWixtQkFBTyxLQUFLLDhCQUFaO0FBQ0gsU0FMcUI7QUFNdEIsYUFBSyxhQUFTLEtBQVQsRUFBZ0I7QUFDakIsaUJBQUssOEJBQUwsR0FBc0MsS0FBdEM7QUFDSDtBQVJxQixLQS9CYTtBQXlDdkMsOEJBQTBCO0FBQ3RCLHNCQUFjLElBRFE7QUFFdEIsb0JBQVksSUFGVTtBQUd0QixhQUFLLGVBQVc7QUFDWixtQkFBTyxLQUFLLDhCQUFaO0FBQ0gsU0FMcUI7QUFNdEIsYUFBSyxhQUFTLEtBQVQsRUFBZ0I7QUFDakIsaUJBQUssOEJBQUwsR0FBc0MsS0FBdEM7QUFDSDtBQVJxQixLQXpDYTtBQW1EdkMsWUFBUTtBQUNKLHNCQUFjLElBRFY7QUFFSixvQkFBWSxJQUZSO0FBR0osYUFBSyxlQUFXO0FBQ1osbUJBQU8sS0FBSyxZQUFaO0FBQ0gsU0FMRztBQU1KLGFBQUssYUFBUyxLQUFULEVBQWdCO0FBQ2pCLGlCQUFLLFlBQUwsR0FBb0IsS0FBcEI7QUFDSDtBQVJHLEtBbkQrQjtBQTZEdkMsY0FBVTtBQUNOLHNCQUFjLElBRFI7QUFFTixvQkFBWSxJQUZOO0FBR04sYUFBSyxlQUFXO0FBQ1osbUJBQU8sS0FBSyxjQUFaO0FBQ0gsU0FMSztBQU1OLGFBQUssYUFBUyxLQUFULEVBQWdCO0FBQ2pCLGlCQUFLLGNBQUwsR0FBc0IsS0FBdEI7QUFDSDtBQVJLLEtBN0Q2QjtBQXVFdkMsWUFBUTtBQUNKLHNCQUFjLElBRFY7QUFFSixvQkFBWSxJQUZSO0FBR0osYUFBSyxlQUFXO0FBQ1osbUJBQU8sS0FBSyxZQUFaO0FBQ0gsU0FMRztBQU1KLGFBQUssYUFBUyxLQUFULEVBQWdCO0FBQ2pCLGlCQUFLLFlBQUwsR0FBb0IsS0FBcEI7QUFDSDtBQVJHLEtBdkUrQjtBQWlGdkMsZUFBVztBQUNQLHNCQUFjLElBRFA7QUFFUCxvQkFBWSxJQUZMO0FBR1AsYUFBSyxlQUFXO0FBQ1osZ0JBQUksTUFBSjtBQUNBLGdCQUFJLEtBQUssVUFBVCxFQUFxQjtBQUNqQix5QkFBUyxLQUFLLE1BQUwsR0FBYyxXQUFkLEdBQTRCLFlBQXJDO0FBQ0g7QUFDRCxtQkFBTyxNQUFQO0FBQ0gsU0FUTTtBQVVQLGFBQUssYUFBUyxLQUFULEVBQWdCO0FBQ2pCO0FBQ0EsbUJBQU8sY0FBUCxDQUFzQixJQUF0QixFQUE0QixXQUE1QixFQUF5QztBQUNyQyw4QkFBYyxJQUR1QjtBQUVyQyw0QkFBWSxJQUZ5QjtBQUdyQywwQkFBVSxJQUgyQjtBQUlyQyx1QkFBTztBQUo4QixhQUF6QztBQU1IO0FBbEJNO0FBakY0QixDQUEzQzs7QUF1R0EsdUJBQXVCLHVCQUF2QixHQUFpRDtBQUM3QyxVQUFNO0FBQ0Ysc0JBQWMsSUFEWjtBQUVGLG9CQUFZLElBRlY7QUFHRixhQUFLLGVBQVc7QUFDWixtQkFBTyxLQUFLLGdCQUFaO0FBQ0gsU0FMQztBQU1GLGFBQUssYUFBUyxLQUFULEVBQWdCO0FBQ2pCLGlCQUFLLGdCQUFMLEdBQXdCLEtBQXhCO0FBQ0g7QUFSQyxLQUR1QztBQVc3QyxXQUFPO0FBQ0gsc0JBQWMsSUFEWDtBQUVILG9CQUFZLElBRlQ7QUFHSCxhQUFLLGVBQVc7QUFDWixtQkFBTyxLQUFLLGlCQUFaO0FBQ0gsU0FMRTtBQU1ILGFBQUssYUFBUyxLQUFULEVBQWdCO0FBQ2pCLGlCQUFLLGlCQUFMLEdBQXlCLEtBQXpCO0FBQ0g7QUFSRSxLQVhzQztBQXFCN0MscUJBQWlCO0FBQ2Isc0JBQWMsSUFERDtBQUViLG9CQUFZLElBRkM7QUFHYixhQUFLLGVBQVc7QUFDWixtQkFBTyxLQUFLLDJCQUFaO0FBQ0gsU0FMWTtBQU1iLGFBQUssYUFBUyxLQUFULEVBQWdCO0FBQ2pCLGlCQUFLLDJCQUFMLEdBQW1DLEtBQW5DO0FBQ0g7QUFSWSxLQXJCNEI7QUErQjdDLDZCQUF5QjtBQUNyQixzQkFBYyxJQURPO0FBRXJCLG9CQUFZLElBRlM7QUFHckIsYUFBSyxlQUFXO0FBQ1osbUJBQU8sS0FBSyxtQ0FBWjtBQUNILFNBTG9CO0FBTXJCLGFBQUssYUFBUyxLQUFULEVBQWdCO0FBQ2pCLGlCQUFLLG1DQUFMLEdBQTJDLEtBQTNDO0FBQ0g7QUFSb0IsS0EvQm9CO0FBeUM3Qyw4QkFBMEI7QUFDdEIsc0JBQWMsSUFEUTtBQUV0QixvQkFBWSxJQUZVO0FBR3RCLGFBQUssZUFBVztBQUNaLG1CQUFPLEtBQUssb0NBQVo7QUFDSCxTQUxxQjtBQU10QixhQUFLLGFBQVMsS0FBVCxFQUFnQjtBQUNqQixpQkFBSyxvQ0FBTCxHQUE0QyxLQUE1QztBQUNIO0FBUnFCLEtBekNtQjtBQW1EN0MsOEJBQTBCO0FBQ3RCLHNCQUFjLElBRFE7QUFFdEIsb0JBQVksSUFGVTtBQUd0QixhQUFLLGVBQVc7QUFDWixtQkFBTyxLQUFLLG9DQUFaO0FBQ0gsU0FMcUI7QUFNdEIsYUFBSyxhQUFTLEtBQVQsRUFBZ0I7QUFDakIsaUJBQUssb0NBQUwsR0FBNEMsS0FBNUM7QUFDSDtBQVJxQixLQW5EbUI7QUE2RDdDLFlBQVE7QUFDSixzQkFBYyxJQURWO0FBRUosb0JBQVksSUFGUjtBQUdKLGFBQUssZUFBVztBQUNaLG1CQUFPLEtBQUssa0JBQVo7QUFDSCxTQUxHO0FBTUosYUFBSyxhQUFTLEtBQVQsRUFBZ0I7QUFDakIsaUJBQUssa0JBQUwsR0FBMEIsS0FBMUI7QUFDSDtBQVJHLEtBN0RxQztBQXVFN0MsY0FBVTtBQUNOLHNCQUFjLElBRFI7QUFFTixvQkFBWSxJQUZOO0FBR04sYUFBSyxlQUFXO0FBQ1osbUJBQU8sS0FBSyxvQkFBWjtBQUNILFNBTEs7QUFNTixhQUFLLGFBQVMsS0FBVCxFQUFnQjtBQUNqQixpQkFBSyxvQkFBTCxHQUE0QixLQUE1QjtBQUNIO0FBUkssS0F2RW1DO0FBaUY3QyxjQUFVLEVBQUUsVUFBVSxJQUFaLEVBQWtCLE9BQU8sU0FBekIsRUFqRm1DO0FBa0Y3QyxnQkFBWSxFQUFFLFVBQVUsSUFBWixFQUFrQixPQUFPLFNBQXpCLEVBbEZpQztBQW1GN0MsZUFBVyxFQUFFLFVBQVUsSUFBWixFQUFrQixPQUFPLFNBQXpCO0FBbkZrQyxDQUFqRDs7QUFzRkE7Ozs7QUFJQSxRQUFRLEtBQVIsR0FBZ0I7QUFDWiw0QkFBd0I7QUFEWixDQUFoQjs7O0FDcmZBOztBQUVBOztBQUVBLElBQUksUUFBUSxRQUFRLEdBQVIsQ0FBWjtBQUNBLElBQUksWUFBWSxRQUFRLGFBQVIsQ0FBaEI7QUFDQSxJQUFJLGlCQUFpQixRQUFRLGlCQUFSLENBQXJCOztBQUdBLElBQUksU0FBUyxFQUFiOztBQUdBOzs7OztBQUtBLFNBQVMsWUFBVCxDQUFzQixTQUF0QixFQUFpQztBQUM3QixRQUFJLENBQUMsVUFBVSxPQUFmLEVBQXdCO0FBQ3BCLGtCQUFVLE9BQVYsR0FBb0IsVUFBUyxHQUFULEVBQWMsUUFBZCxFQUF3QjtBQUN4QyxnQkFBSSxZQUFZLENBQUMsTUFBTSxPQUFOLENBQWMsR0FBZCxDQUFqQixFQUFxQztBQUNqQyxzQkFBTSxPQUFPLElBQWI7QUFDQSx1QkFBTyxJQUFQLENBQVksR0FBWixFQUFpQixNQUFqQixDQUF3QixVQUFTLEdBQVQsRUFBYztBQUNsQywyQkFBTyxPQUFPLElBQUksR0FBSixDQUFQLEtBQW9CLFVBQTNCO0FBQ0gsaUJBRkQsRUFFRyxPQUZILENBRVcsVUFBUyxHQUFULEVBQWM7QUFDckIsd0JBQUksQ0FBQyxLQUFLLEdBQUwsQ0FBTCxFQUFnQjtBQUNaLDZCQUFLLEdBQUwsSUFBWSxJQUFJLEdBQUosQ0FBWjtBQUNIO0FBQ0osaUJBTkQsRUFNRyxJQU5IO0FBT0g7QUFDSixTQVhEO0FBWUg7QUFDSjs7QUFFRDs7Ozs7Ozs7O0FBU0EsU0FBUyxZQUFULENBQXNCLFNBQXRCLEVBQWlDLElBQWpDLEVBQXVDO0FBQ25DLGNBQVUsT0FBVixDQUFrQixTQUFsQixFQUE2QixJQUE3QjtBQUNBLGNBQVUsT0FBVixDQUFrQixFQUFFLGVBQWUsY0FBYyxJQUFkLENBQW1CLElBQW5CLENBQWpCLEVBQWxCLEVBQStELElBQS9EO0FBQ0g7O0FBRUQsSUFBSSwwQkFBMEIsa0JBQTlCOztBQUVBOzs7Ozs7QUFNQSxTQUFTLGFBQVQsQ0FBdUIsU0FBdkIsRUFBa0MsV0FBbEMsRUFBK0M7QUFDM0MsUUFBSSxDQUFDLHdCQUF3QixJQUF4QixDQUE2QixTQUE3QixDQUFMLEVBQThDO0FBQzFDLGNBQU0sSUFBSSxjQUFKLENBQW1CLHlDQUF5Qyx1QkFBekMsR0FBbUUsR0FBdEYsQ0FBTjtBQUNIO0FBQ0QsU0FBSyxNQUFMLENBQVksYUFBWixDQUEwQixJQUFJLFdBQUosQ0FBZ0IsZ0JBQWdCLFNBQWhDLEVBQTJDLFdBQTNDLENBQTFCO0FBQ0g7O0FBRUQ7Ozs7QUFJQSxTQUFTLHNCQUFULEdBQWtDO0FBQzlCLFFBQUksT0FBTyxLQUFLLElBQWhCOztBQUVBLFdBQU8sY0FBUCxDQUFzQixLQUFLLFNBQTNCLEVBQXNDLE1BQXRDLEVBQThDO0FBQzFDLHNCQUFjLElBRDRCO0FBRTFDLG9CQUFZLEtBRjhCO0FBRzFDLGFBQUssZUFBVztBQUNaLGdCQUFJLENBQUMsT0FBTyxJQUFaLEVBQWtCO0FBQ2Qsd0JBQVEsSUFBUixDQUFhLHNpQkFBYjtBQUNBLHVCQUFPLElBQVAsR0FBYyxJQUFkO0FBQ0g7QUFDRCxtQkFBTyxJQUFQO0FBQ0g7QUFUeUMsS0FBOUM7O0FBWUEsUUFBSSxLQUFLLFNBQUwsQ0FBZSxVQUFuQixFQUErQjtBQUMzQixZQUFJLENBQUMsT0FBTyxVQUFaLEVBQXdCO0FBQ3BCLG9CQUFRLElBQVIsQ0FBYSxpYkFBYjtBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNBLElBQUksNkJBQTZCO0FBQzdCLFVBQU0sTUFEdUI7QUFFN0IsV0FBTyxPQUZzQjtBQUc3QixVQUFNO0FBSHVCLENBQWpDOztBQU1BOzs7O0FBSUEsU0FBUyw2QkFBVCxHQUF5QztBQUNyQyxRQUFJLFVBQVUsS0FBSyxTQUFMLENBQWUsZ0JBQTdCO0FBQ0EsUUFBSSxPQUFKLEVBQWE7QUFDVCxlQUFPLElBQVAsQ0FBWSwwQkFBWixFQUF3QyxPQUF4QyxDQUFnRCxVQUFTLEdBQVQsRUFBYztBQUMxRCxnQkFBSSxPQUFPLE9BQVgsRUFBb0I7QUFDaEIsb0JBQUksZ0JBQWdCLDJCQUEyQixHQUEzQixDQUFwQjtBQUNBLG9CQUFJLEVBQUUsaUJBQWlCLE9BQW5CLENBQUosRUFBaUM7QUFDN0IsMkJBQU8sY0FBUCxDQUFzQixPQUF0QixFQUErQixhQUEvQixFQUE4QztBQUMxQyw2QkFBSyxlQUFXO0FBQUUsbUNBQU8sS0FBSyxHQUFMLENBQVA7QUFBbUIseUJBREs7QUFFMUMsNkJBQUssYUFBUyxDQUFULEVBQVk7QUFBRSxpQ0FBSyxHQUFMLElBQVksQ0FBWjtBQUFnQjtBQUZPLHFCQUE5QztBQUlIO0FBQ0o7QUFDSixTQVZEO0FBV0g7QUFDSjs7QUFFRDs7Ozs7QUFLQSxTQUFTLGVBQVQsQ0FBeUIsU0FBekIsRUFBb0M7QUFDaEMsUUFBSSxDQUFDLFVBQVUsT0FBZixFQUF3QjtBQUNwQixrQkFBVSxPQUFWLEdBQW9CLE1BQU0sT0FBMUI7QUFDSDs7QUFFRCxRQUFJLENBQUMsVUFBVSxlQUFmLEVBQWdDO0FBQzVCLGtCQUFVLGVBQVYsR0FBNEIsTUFBTSxlQUFsQztBQUNIO0FBQ0o7O0FBR0QsT0FBTyxPQUFQLEdBQWlCO0FBQ2Isa0JBQWMsWUFERDtBQUViLGtCQUFjLFlBRkQ7QUFHYiw0QkFBd0Isc0JBSFg7QUFJYixtQ0FBK0IsNkJBSmxCO0FBS2IscUJBQWlCO0FBTEosQ0FBakI7OztBQ3JJQTs7QUFFQTs7Ozs7O0FBS0EsT0FBTyxPQUFQLEdBQWlCO0FBQ2I7QUFDQSxXQUFPLGlCQUFXLENBQUUsQ0FGUDs7QUFJYjtBQUNBLGlCQUFhLHVCQUFXO0FBQUUsZUFBTyxLQUFQO0FBQWUsS0FMNUI7O0FBT2I7QUFDQSxXQUFPLGlCQUFXO0FBQUUsZUFBTyxLQUFQO0FBQWUsS0FSdEI7O0FBVWI7QUFDQSxvQkFBZ0IsMEJBQVc7QUFDdkIsZUFBTyxLQUFLLFNBQUwsR0FBaUIsTUFBeEI7QUFDSCxLQWJZOztBQWViO0FBQ0EsWUFBUSxnQkFBUyxDQUFULEVBQVk7QUFDaEIsYUFBSyxZQUFMLENBQWtCLEdBQWxCLEdBQXdCLENBQXhCO0FBQ0EsZUFBTyxLQUFLLFlBQVo7QUFDSCxLQW5CWTs7QUFxQmI7QUFDQSxhQUFTLGlCQUFTLGlCQUFULEVBQTRCO0FBQ2pDLFlBQUksQ0FBSjtBQUFBLFlBQU8sSUFBSSxLQUFLLFdBQUwsRUFBWDtBQUFBLFlBQ0ksR0FESjtBQUFBLFlBQ1MsT0FBTyxJQUFJLEtBQUosQ0FBVSxDQUFWLENBRGhCO0FBQUEsWUFFSSxRQUZKOztBQUlBLGFBQUssSUFBSSxDQUFULEVBQVksSUFBSSxDQUFoQixFQUFtQixHQUFuQixFQUF3QjtBQUNwQixrQkFBTSxLQUFLLElBQUwsQ0FBVSxDQUFWLENBQU4sQ0FEb0IsQ0FDQTtBQUNwQixnQkFBSSxHQUFKLEVBQVM7QUFDTCxxQkFBSyxDQUFMLElBQVUsT0FBTyxNQUFQLENBQWMsRUFBZCxFQUFrQixHQUFsQixDQUFWO0FBQ0Esb0JBQUksaUJBQUosRUFBdUI7QUFDbkIsK0JBQVcsS0FBSyxjQUFMLENBQW9CLENBQXBCLENBQVg7QUFDQSx3QkFBSSxRQUFKLEVBQWM7QUFDViw2QkFBSyxDQUFMLEVBQVEsaUJBQVIsSUFBNkIsUUFBN0I7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7QUFFRCxlQUFPLElBQVA7QUFDSCxLQXpDWTs7QUEyQ2IsYUFBUyxpQkFBUyxJQUFULEVBQWU7QUFDcEI7QUFDSCxLQTdDWTs7QUErQ2IsY0FBVSxrQkFBUyxDQUFULEVBQVksQ0FBWixFQUFlLEtBQWYsRUFBc0I7QUFDNUIsZ0JBQVEsSUFBUixDQUFhLHdCQUF3QixDQUF4QixHQUE0QixJQUE1QixHQUFtQyxDQUFuQyxHQUF1QyxLQUF2QyxHQUErQyxLQUEvQyxHQUF1RCxrREFBcEU7QUFDSCxLQWpEWTs7QUFtRGI7QUFDQSxpQkFBYSxxQkFBUyxDQUFULEVBQVk7QUFDckIsZUFBTyxDQUFQO0FBQ0gsS0F0RFk7O0FBd0RiO0FBQ0Esb0JBQWdCLHdCQUFTLENBQVQsRUFBWSxTQUFaLEVBQXVCO0FBQ25DLGVBQU8sS0FBSyxRQUFMLENBQWMsQ0FBZCxLQUFvQixjQUFjLFNBQWQsS0FBNEIsS0FBSyxRQUFMLENBQWMsQ0FBZCxJQUFtQixPQUFPLE1BQVAsQ0FBYyxTQUFkLENBQS9DLENBQTNCO0FBQ0gsS0EzRFk7O0FBNkRiO0FBQ0Esc0JBQWtCLDRCQUFXO0FBQ3pCLGVBQU8sS0FBSyxRQUFaO0FBQ0gsS0FoRVk7O0FBa0ViO0FBQ0Esb0JBQWdCLHdCQUFTLENBQVQsRUFBWSxRQUFaLEVBQXNCO0FBQ2xDLFlBQUksUUFBSixFQUFjO0FBQ1YsaUJBQUssUUFBTCxDQUFjLENBQWQsSUFBbUIsUUFBbkI7QUFDSCxTQUZELE1BRU87QUFDSCxtQkFBTyxLQUFLLFFBQUwsQ0FBYyxDQUFkLENBQVA7QUFDSDtBQUNELGVBQU8sUUFBUDtBQUNILEtBMUVZOztBQTRFYjtBQUNBLHNCQUFrQiwwQkFBUyxnQkFBVCxFQUEyQjtBQUN6QyxhQUFLLFFBQUwsR0FBZ0Isb0JBQW9CLEVBQXBDO0FBQ0g7QUEvRVksQ0FBakI7OztBQ1BBOztBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQSxRQUFRLE9BQVIsR0FBa0IsVUFBUyxNQUFULEVBQWlCLFlBQWpCLEVBQStCO0FBQzdDLFNBQU8sT0FBTyxJQUFQLENBQVksYUFBWixDQUEwQixHQUExQixDQUE4QixZQUE5QixDQUFQO0FBQ0gsQ0FGRDs7QUFLQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQSxRQUFRLGVBQVIsR0FBMEIsVUFBUyxXQUFULEVBQXNCLFFBQXRCLEVBQWdDLFVBQWhDLEVBQTRDLFNBQTVDLEVBQXVEO0FBQzdFLFNBQU8sVUFBVSxJQUFWLENBQWUsV0FBZixDQUEyQixNQUEzQixDQUFrQyxVQUFsQyxFQUE4QyxTQUE5QyxDQUFQO0FBQ0gsQ0FGRDs7O0FDOUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSSxNQUFKOztBQUVBLE9BQU8sT0FBUCxHQUFpQjtBQUNiLGNBQVUsUUFBUSxZQUFSLENBREc7QUFFYixXQUFPLFFBQVEsU0FBUixDQUZNO0FBR2IsWUFBUSxRQUFRLFVBQVIsQ0FISztBQUliLGVBQVcsUUFBUSxhQUFSLENBSkU7O0FBTWIsUUFBSSxJQUFKLEdBQVc7QUFDUCxZQUFJLENBQUMsTUFBTCxFQUFhO0FBQ1Qsb0JBQVEsSUFBUixDQUFhLHFHQUFiO0FBQ0g7QUFDRCxpQkFBUyxJQUFUO0FBQ0EsZUFBTyxRQUFRLFNBQVIsQ0FBUDtBQUNIO0FBWlksQ0FBakI7OztBQ1BBOzs7O0FBRUEsUUFBUSxLQUFSLEdBQWdCO0FBQ1o7Ozs7Ozs7O0FBUUEsd0JBQW9CLDhCQUFXO0FBQzNCLFlBQUksT0FBSjtBQUFBLFlBQWEsTUFBYjtBQUFBLFlBQXFCLENBQXJCO0FBQUEsWUFBd0IsQ0FBeEI7QUFBQSxZQUNJLFdBQVcsS0FBSyxRQURwQjtBQUFBLFlBRUksU0FBUyxDQUZiOztBQUlBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxTQUFTLE1BQWIsSUFBdUIsQ0FBQyxNQUF4QyxFQUFnRCxFQUFFLENBQWxELEVBQXFEO0FBQ2pELHNCQUFVLFNBQVMsQ0FBVCxDQUFWO0FBQ0EscUJBQVMsUUFBUSxNQUFqQjtBQUNBLGdCQUFJLFNBQVMsS0FBSyxJQUFMLENBQVUsVUFBVixDQUFxQixhQUE5QixHQUE4QyxRQUFRLFdBQVIsRUFBbEQ7QUFDQSxpQkFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLENBQWhCLEVBQW1CLEVBQUUsQ0FBckIsRUFBd0I7QUFDcEIsMEJBQVUsS0FBSyxZQUFMLENBQWtCLENBQWxCLEVBQXFCLE9BQXJCLENBQVY7QUFDSDtBQUNKOztBQUVELGVBQU8sTUFBUDtBQUNILEtBeEJXOztBQTBCWjs7Ozs7Ozs7QUFRQSxtQkFBZSx1QkFBUyxHQUFULEVBQWM7QUFBQTs7QUFDekIsWUFBSSxTQUFTLENBQWI7O0FBRUEsYUFBSyxRQUFMLENBQWMsT0FBZCxDQUFzQixtQkFBVztBQUM3QixnQkFBTSxjQUFjLFFBQVEsV0FBUixFQUFwQjtBQUNBLGdCQUFNLElBQUksUUFBUSxTQUFSLElBQXFCLE1BQU0sV0FBM0IsR0FBeUMsV0FBekMsR0FBdUQsR0FBakU7QUFDQSxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEVBQUUsQ0FBekIsRUFBNEI7QUFDeEIsMEJBQVUsTUFBSyxZQUFMLENBQWtCLENBQWxCLEVBQXFCLE9BQXJCLENBQVY7QUFDSDtBQUNKLFNBTkQ7O0FBUUEsZUFBTyxNQUFQO0FBQ0gsS0E5Q1c7O0FBZ0RaOzs7Ozs7Ozs7Ozs7QUFZQSxzQkFBa0IsMEJBQVMsWUFBVCxFQUF1QixTQUF2QixFQUFrQyxTQUFsQyxFQUE2QztBQUMzRCxZQUFJLFFBQU8sWUFBUCx5Q0FBTyxZQUFQLE9BQXdCLFFBQTVCLEVBQXNDO0FBQ2xDLHdCQUFZLGFBQWEsT0FBekI7QUFDQSwyQkFBZSxhQUFhLFFBQWIsQ0FBc0IsQ0FBckM7QUFDSDs7QUFFRCxZQUFJLFdBQVcsQ0FBQyxhQUFhLEtBQUssU0FBbkIsRUFBOEIsY0FBOUIsQ0FBNkMsWUFBN0MsRUFBMkQsYUFBYSxJQUF4RSxDQUFmO0FBQ0EsZUFBTyxhQUFhLFNBQVMsS0FBVCxJQUFrQixjQUFjLFNBQWQsS0FBNEIsU0FBUyxLQUFULEdBQWlCLE9BQU8sTUFBUCxDQUFjLFNBQWQsQ0FBN0MsQ0FBL0IsQ0FBUDtBQUNILEtBcEVXOztBQXNFWjs7Ozs7OztBQU9BLHNCQUFrQiwwQkFBUyxZQUFULEVBQXVCLFVBQXZCLEVBQW1DLFNBQW5DLEVBQThDO0FBQzVELFlBQUksUUFBTyxZQUFQLHlDQUFPLFlBQVAsT0FBd0IsUUFBNUIsRUFBc0M7QUFDbEMsd0JBQVksYUFBYSxPQUF6QjtBQUNBLDJCQUFlLGFBQWEsUUFBYixDQUFzQixDQUFyQztBQUNIOztBQUVELFNBQUMsYUFBYSxLQUFLLFNBQW5CLEVBQThCLGNBQTlCLENBQTZDLFlBQTdDLEVBQTJELElBQTNELEVBQWlFLEtBQWpFLEdBQXlFLFVBQXpFOztBQUVBLGFBQUssWUFBTDtBQUNILEtBdEZXOztBQXdGWjs7Ozs7Ozs7QUFRQSxvQkFBZ0Isd0JBQVMsWUFBVCxFQUF1QixHQUF2QixFQUE0QixLQUE1QixFQUFtQyxTQUFuQyxFQUE4QztBQUMxRCxhQUFLLGdCQUFMLENBQXNCLFlBQXRCLEVBQW9DLElBQXBDLEVBQTBDLFNBQTFDLEVBQXFELEdBQXJELElBQTRELEtBQTVEO0FBQ0EsYUFBSyxZQUFMO0FBQ0gsS0FuR1c7O0FBcUdaOzs7Ozs7O0FBT0Esc0JBQWtCLDBCQUFTLFlBQVQsRUFBdUIsVUFBdkIsRUFBbUMsU0FBbkMsRUFBOEM7QUFDNUQsZUFBTyxNQUFQLENBQWMsS0FBSyxnQkFBTCxDQUFzQixZQUF0QixFQUFvQyxJQUFwQyxFQUEwQyxTQUExQyxDQUFkLEVBQW9FLFVBQXBFO0FBQ0EsYUFBSyxZQUFMO0FBQ0gsS0EvR1c7O0FBaUhaOzs7Ozs7QUFNQSxrQkFBYyxzQkFBUyxZQUFULEVBQXVCLFNBQXZCLEVBQWtDO0FBQzVDLFlBQUksV0FBVyxLQUFLLGdCQUFMLENBQXNCLFlBQXRCLEVBQW9DLFNBQXBDLEVBQStDLFNBQS9DLENBQWY7QUFDQSxlQUFPLFlBQVksU0FBUyxNQUFyQixJQUNILEtBQUssSUFBTCxDQUFVLFVBQVYsQ0FBcUIsYUFBYSxVQUFVLFFBQXZCLEdBQWtDLHdCQUFsQyxHQUE2RCxrQkFBbEYsQ0FESjtBQUVILEtBM0hXOztBQTZIWjs7OztBQUlBLCtCQUEyQixxQ0FBVztBQUNsQyxlQUFPLEtBQUssSUFBTCxDQUFVLFVBQVYsQ0FBcUIsc0JBQTVCO0FBQ0gsS0FuSVc7O0FBcUlaOzs7Ozs7O0FBT0Esa0JBQWMsc0JBQVMsWUFBVCxFQUF1QixNQUF2QixFQUErQixTQUEvQixFQUEwQztBQUNwRCxZQUFJLFdBQVcsS0FBSyxnQkFBTCxDQUFzQixZQUF0QixFQUFvQyxJQUFwQyxFQUEwQyxTQUExQyxDQUFmO0FBQUEsWUFDSSxZQUFZLFNBQVMsTUFEekI7O0FBR0EsaUJBQVMsTUFBVCxHQUFrQixLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksS0FBSyxJQUFMLENBQVUsTUFBVixDQUFaLENBQWxCOztBQUVBLFlBQUksU0FBUyxNQUFULEtBQW9CLFNBQXhCLEVBQW1DO0FBQy9CLGlCQUFLLFlBQUw7QUFDSDtBQUNKO0FBckpXLENBQWhCOzs7QUNGQTs7OztBQUVBLElBQUksYUFBYSxRQUFRLHFCQUFSLENBQWpCOztBQUVBOzs7Ozs7O0FBT0E7Ozs7Ozs7Ozs7O0FBV0E7Ozs7QUFJQSxRQUFRLEtBQVIsR0FBZ0I7QUFDWjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQSxRQUFJLFFBQUosQ0FBYSxZQUFiLEVBQTJCO0FBQ3ZCLFlBQUksV0FBVyxLQUFLLFNBQUwsR0FBaUIsRUFBaEM7O0FBRUEsaUJBQVMsTUFBVCxHQUFrQixFQUFsQjs7QUFFQSxxQkFBYSxPQUFiLENBQXFCLFVBQVMsSUFBVCxFQUFlO0FBQ2hDLGdCQUFJLElBQUosRUFBVTtBQUNOLHlCQUFTLElBQVQsQ0FBYyxLQUFLLGFBQUwsQ0FBbUIsSUFBbkIsQ0FBZDtBQUNIO0FBQ0osU0FKRCxFQUlHLElBSkg7O0FBTUEsYUFBSyxZQUFMO0FBQ0gsS0FuQ1c7QUFvQ1osUUFBSSxRQUFKLEdBQWU7QUFDWCxlQUFPLEtBQUssU0FBWjtBQUNILEtBdENXOztBQXdDWjs7Ozs7OztBQU9BLG1CQUFlLHVCQUFTLElBQVQsRUFBZSxJQUFmLEVBQXFCO0FBQ2hDLFlBQUksT0FBSixFQUFhLFdBQWIsRUFBMEIsZ0JBQTFCOztBQUVBLFlBQUksU0FBUyxNQUFiLEVBQXFCO0FBQ2pCLHNCQUFVLEtBQUssU0FBZjtBQUNILFNBRkQsTUFFTyxJQUFJLGdCQUFnQixLQUFoQixJQUF5QixLQUFLLE1BQWxDLEVBQTBDO0FBQzdDLDBCQUFjLGdCQUFnQixJQUFoQixDQUFxQixJQUFyQixFQUEyQixLQUFLLENBQUwsQ0FBM0IsQ0FBZDtBQUNBLCtCQUFtQixLQUFLLEtBQUwsQ0FBVyxDQUFYLENBQW5CO0FBQ0Esc0JBQVUsS0FBSyxXQUFMLENBQWlCLFdBQWpCLEVBQThCLGdCQUE5QixFQUFnRCxTQUFoRCxFQUEyRCxFQUFFLE1BQU0sS0FBSyxJQUFiLEVBQTNELENBQVY7QUFDQSxzQkFBVSxLQUFLLGlCQUFMLENBQXVCLE9BQXZCLENBQVY7QUFDSCxTQUxNLE1BS0EsSUFBSSxRQUFPLElBQVAseUNBQU8sSUFBUCxPQUFnQixRQUFwQixFQUE4QjtBQUNqQyxzQkFBVSxJQUFWO0FBQ0gsU0FGTSxNQUVBO0FBQ0gsMEJBQWMsZ0JBQWdCLElBQWhCLENBQXFCLElBQXJCLEVBQTJCLElBQTNCLENBQWQ7QUFDQSwrQkFBbUIsTUFBTSxTQUFOLENBQWdCLEtBQWhCLENBQXNCLElBQXRCLENBQTJCLFNBQTNCLEVBQXNDLENBQXRDLENBQW5CO0FBQ0Esc0JBQVUsS0FBSyxXQUFMLENBQWlCLFdBQWpCLEVBQThCLGdCQUE5QixFQUFnRCxTQUFoRCxFQUEyRCxFQUFFLE1BQU0sS0FBSyxJQUFiLEVBQTNELENBQVY7QUFDQSxzQkFBVSxLQUFLLGlCQUFMLENBQXVCLE9BQXZCLENBQVY7QUFDSDs7QUFFRDtBQUNBLFlBQUksQ0FBQyxRQUFRLElBQWIsRUFBbUI7QUFDZixvQkFBUSxJQUFSLEdBQWUsTUFBZjtBQUNIOztBQUVEO0FBQ0EsWUFBSSxNQUFNLFFBQVEsSUFBUixLQUFpQixNQUFqQixJQUEyQixRQUFRLElBQW5DLElBQTJDLFFBQVEsSUFBbkQsSUFBMkQsUUFBUSxJQUE3RTtBQUNBLGFBQUssU0FBTCxDQUFlLE1BQWYsQ0FBc0IsR0FBdEIsSUFBNkIsS0FBSyxTQUFMLENBQWUsTUFBZixDQUFzQixHQUF0QixLQUE4QixPQUEzRCxDQTFCZ0MsQ0EwQm9DOztBQUVwRTtBQUNBLGdCQUFRLE9BQU8sUUFBUSxJQUFSLENBQWEsQ0FBYixFQUFnQixXQUFoQixFQUFQLEdBQXVDLFFBQVEsSUFBUixDQUFhLE1BQWIsQ0FBb0IsQ0FBcEIsQ0FBL0MsSUFBeUUsSUFBekU7O0FBRUEsZUFBTyxPQUFQO0FBQ0gsS0EvRVc7O0FBaUZaOzs7OztBQUtBLHVCQUFtQiw2QkFBVztBQUMxQixZQUFJLFNBQVMsQ0FBYjs7QUFFQSxhQUFLLFFBQUwsQ0FBYyxJQUFkLENBQW1CLFVBQVMsT0FBVCxFQUFrQjtBQUNqQyxnQkFBSSxRQUFRLE1BQVosRUFBb0I7QUFDaEIsdUJBQU8sSUFBUCxDQURnQixDQUNIO0FBQ2hCO0FBQ0Qsc0JBQVUsUUFBUSxXQUFSLEVBQVY7QUFDSCxTQUxEOztBQU9BLGVBQU8sTUFBUDtBQUNILEtBakdXOztBQW1HWjs7Ozs7QUFLQSx1QkFBbUIsNkJBQVc7QUFDMUIsWUFBSSxPQUFKO0FBQ0EsZUFBTyxLQUFLLFFBQUwsQ0FBYyxNQUFkLENBQXFCLFVBQVMsSUFBVCxFQUFlLE9BQWYsRUFBd0I7QUFDaEQsZ0JBQUksV0FBVyxDQUFDLFFBQVEsTUFBeEIsRUFBZ0M7QUFDNUIsd0JBQVEsUUFBUSxXQUFSLEVBQVI7QUFDSCxhQUZELE1BRU87QUFDSCwwQkFBVSxRQUFRLE1BQWxCO0FBQ0g7QUFDRCxtQkFBTyxJQUFQO0FBQ0gsU0FQTSxFQU9KLENBUEksQ0FBUDtBQVFILEtBbEhXOztBQW9IWjs7Ozs7QUFLQSx3QkFBb0IsOEJBQVc7QUFDM0IsZUFBTyxLQUFLLFFBQUwsQ0FBYyxNQUFkLENBQXFCLFVBQVMsSUFBVCxFQUFlLE9BQWYsRUFBd0I7QUFDaEQsbUJBQVEsUUFBUSxRQUFRLFdBQVIsRUFBaEI7QUFDSCxTQUZNLEVBRUosQ0FGSSxDQUFQO0FBR0g7QUE3SFcsQ0FBaEI7O0FBZ0lBOzs7Ozs7OztBQVFBLFNBQVMsZUFBVCxDQUF5QixHQUF6QixFQUE4QjtBQUMxQixRQUFJLFdBQUo7QUFDQSxtQkFBZSxHQUFmLHlDQUFlLEdBQWY7QUFDSSxhQUFLLFFBQUw7QUFDSSwwQkFBYyxXQUFXLEdBQVgsQ0FBZDtBQUNBO0FBQ0osYUFBSyxVQUFMO0FBQ0ksMEJBQWMsR0FBZDtBQUNBO0FBQ0o7QUFDSSxrQkFBTSxJQUFJLEtBQUssY0FBVCxDQUF3QixrRkFBaUYsR0FBakYseUNBQWlGLEdBQWpGLEtBQXVGLEdBQS9HLENBQU47QUFSUjtBQVVBLFdBQU8sV0FBUDtBQUNIOzs7QUMvS0Q7O0FBRUE7Ozs7QUFFQSxJQUFJLE9BQU8sUUFBUSxTQUFSLENBQVg7QUFDQSxJQUFJLFVBQVUsUUFBUSxvQkFBUixDQUFkO0FBQ0EsSUFBSSxlQUFlLFFBQVEscUJBQVIsQ0FBbkI7O0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQWVBLElBQUksYUFBYSxLQUFLLE1BQUwsQ0FBWSxZQUFaLEVBQTBCOztBQUV2QyxnQkFBWSxvQkFBUyxJQUFULEVBQWUsT0FBZixFQUF3QjtBQUNoQztBQUNBLGFBQUssSUFBSSxHQUFULElBQWdCLE9BQWhCLEVBQXlCO0FBQ3JCLGlCQUFLLEdBQUwsSUFBWSxRQUFRLEdBQVIsQ0FBWjtBQUNIOztBQUVELGFBQUssS0FBTCxHQUFhLE9BQWI7O0FBRUEsWUFBSSxRQUFRLEtBQUssS0FBTCxDQUFXLEtBQXZCOztBQUVBOzs7OztBQUtBLGFBQUssSUFBTCxHQUFZLElBQVo7O0FBRUEsYUFBSyxJQUFMLENBQVUsVUFBVixHQUF1QixJQUF2Qjs7QUFFQSxhQUFLLE1BQUwsR0FBYyxLQUFLLFlBQUwsQ0FBa0IsTUFBaEMsQ0FuQmdDLENBbUJROztBQUV4QztBQUNBO0FBQ0EsWUFBSSxZQUFZLEtBQUssSUFBTCxDQUFVLFlBQVYsQ0FBdUIsR0FBdkIsQ0FBMkIsUUFBUSxNQUFuQyxDQUFoQixDQXZCZ0MsQ0F1QjRCO0FBQzVELFlBQUksRUFBRSxjQUFjLGFBQWEsU0FBYixDQUF1QixNQUFyQyxJQUErQyxRQUFRLE1BQVIsS0FBbUIsUUFBcEUsQ0FBSixFQUFtRjtBQUMvRSxpQkFBSyxTQUFMLEdBQWlCLFNBQWpCO0FBQ0g7O0FBRUQsYUFBSyxZQUFMLEdBQW9CLEtBQXBCOztBQUVBLFlBQUksWUFBWSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBaEI7QUFDQSxrQkFBVSxTQUFWLEdBQXNCLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBa0IsU0FBbEIsQ0FBNEIsTUFBNUIsQ0FBbUMsS0FBSyxRQUF4QyxFQUFrRCxJQUFsRCxDQUF0Qjs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQSxhQUFLLEVBQUwsR0FBVSxVQUFVLFVBQXBCOztBQUVBLGFBQUssS0FBTCxHQUFhLEtBQUssRUFBbEI7O0FBRUEsYUFBSyxNQUFMLEdBQWMsQ0FBZDs7QUFFQSxZQUFJLE9BQU8sSUFBWDtBQUNBLGFBQUssRUFBTCxDQUFRLGdCQUFSLENBQXlCLE9BQXpCLEVBQWtDLEtBQUssS0FBTCxDQUFXLElBQVgsQ0FBZ0IsSUFBaEIsQ0FBbEM7QUFDQSxhQUFLLEVBQUwsQ0FBUSxnQkFBUixDQUF5QixTQUF6QixFQUFvQyxVQUFTLENBQVQsRUFBWTtBQUM1QyxnQkFBSSxFQUFFLE9BQUYsS0FBYyxDQUFsQixFQUFxQjtBQUNqQjtBQUNBLGtCQUFFLGNBQUY7QUFDSDtBQUNELGlCQUFLLCtCQUFMLENBQXFDLElBQXJDLEVBQTJDLENBQTNDO0FBQ0gsU0FORDtBQU9BLGFBQUssRUFBTCxDQUFRLGdCQUFSLENBQXlCLFVBQXpCLEVBQXFDLFVBQVMsQ0FBVCxFQUFZO0FBQzdDLGlCQUFLLGdDQUFMLENBQXNDLElBQXRDLEVBQTRDLENBQTVDO0FBQ0gsU0FGRDtBQUdBLGFBQUssRUFBTCxDQUFRLGdCQUFSLENBQXlCLFdBQXpCLEVBQXNDLFVBQVMsQ0FBVCxFQUFZO0FBQzlDLGlCQUFLLFdBQUwsQ0FBaUIsQ0FBakI7QUFDSCxTQUZEO0FBR0gsS0FuRXNDOztBQXFFdkM7QUFDQSxpQkFBYSxxQkFBUyxLQUFULEVBQWdCO0FBQ3pCLGNBQU0sZUFBTixHQUR5QixDQUNBO0FBQzVCLEtBeEVzQzs7QUEwRXZDLGVBQVcsYUFBYSxTQUFiLENBQXVCLElBMUVLOztBQTRFdkMsbUJBQWU7QUFDWDtBQUNBLGNBQU0sYUFGSyxFQUVVO0FBQ3JCLGNBQU0sYUFISyxFQUdVO0FBQ3JCLGNBQU0sZUFKSyxDQUlXO0FBSlgsS0E1RXdCOztBQW1GdkMsV0FBTyxlQUFTLENBQVQsRUFBWTtBQUNmLFlBQUksT0FBTyxLQUFLLElBQWhCO0FBQUEsWUFDSSxZQUFZLEtBQUssS0FBTCxDQUFXLFVBRDNCO0FBQUEsWUFFSSxnQkFBZ0IsVUFBVSxhQUY5QjtBQUFBLFlBR0ksVUFBVSxLQUFLLE1BQUwsQ0FBWSxVQUFaLENBQXVCLENBQXZCLENBSGQ7QUFBQSxZQUlJLFlBSko7QUFBQSxZQUtJLE9BTEo7O0FBT0E7QUFDQSxZQUNJLENBQUMsZUFBZSxLQUFLLGFBQUwsQ0FBbUIsRUFBRSxPQUFyQixDQUFoQixNQUNDLFVBQVUsS0FBSyxZQUFMLEVBQW1CLGFBQW5CLENBRFgsQ0FESixFQUdFO0FBQ0UsaUJBQUssT0FBTDtBQUNIOztBQUVEO0FBQ0EsWUFBSSxVQUFVLFlBQVYsQ0FBdUIsT0FBdkIsRUFBZ0MsRUFBRSxPQUFsQyxDQUFKLEVBQWdEO0FBQzVDLGdCQUNJLENBQUMsWUFBRDtBQUNBO0FBQ0Msc0JBQVUsS0FBSyxXQUFMLENBQWlCLGFBQWpCLENBRlgsQ0FESixFQUlFO0FBQ0UscUJBQUssT0FBTDtBQUNIOztBQUVELGdCQUFJLE9BQUosRUFBYTtBQUNUO0FBQ0E7QUFDQSxvQkFBSSxXQUFXLEtBQUssTUFBTCxDQUFZLFFBQVosQ0FBcUIsQ0FBckIsRUFBd0Isb0JBQXhCLEVBQThDO0FBQ3pELDBCQUFNLElBRG1EO0FBRXpELHlCQUFLLEVBQUUsTUFGa0Q7QUFHekQsMEJBQU0sRUFBRSxPQUhpRDtBQUl6RCwwQkFBTSxPQUptRDtBQUt6RCwwQkFBTSxFQUFFLFFBTGlEO0FBTXpELHlCQUFLLEVBQUUsT0FOa0Q7QUFPekQsMEJBQU0sRUFBRSxPQVBpRDtBQVF6RCwyQkFBTyxFQUFFLFFBUmdEO0FBU3pELGdDQUFZLEVBQUUsR0FUMkM7QUFVekQsNEJBQVE7QUFWaUQsaUJBQTlDLENBQWY7QUFZQSxxQkFBSyxlQUFMLENBQXFCLFFBQXJCO0FBQ0g7QUFDSjs7QUFFRCxhQUFLLElBQUwsQ0FBVSw2QkFBVixDQUF3QyxJQUF4QyxFQUE4QyxDQUE5Qzs7QUFFQSxlQUFPLE9BQVA7QUFDSCxLQW5Jc0M7O0FBcUl2Qzs7Ozs7O0FBTUEsNkJBQXlCLEtBM0ljOztBQTZJdkM7Ozs7QUFJQSw4QkFBMEIsb0NBQVc7QUFDakMsYUFBSyxXQUFMO0FBQ0gsS0FuSnNDOztBQXFKdkM7Ozs7QUFJQSxvQ0FBZ0MsMENBQVc7QUFDdkMsYUFBSyx1QkFBTCxHQUErQixJQUEvQjtBQUNILEtBM0pzQzs7QUE2SnZDOzs7O0FBSUEsZ0JBQVksc0JBQVc7QUFDbkIsYUFBSyxTQUFMLENBQWUsS0FBSyxLQUFMLENBQVcsTUFBMUI7QUFDSCxLQW5Lc0M7O0FBcUt2QyxrQkFBYyx3QkFBVztBQUNyQixZQUFJLEtBQUssSUFBTCxDQUFVLG1CQUFWLENBQThCLEtBQUssS0FBbkMsRUFBMEMsS0FBSyxZQUEvQyxDQUFKLEVBQWtFO0FBQzlELGlCQUFLLHVCQUFMLEdBQStCLElBQS9CO0FBQ0EsaUJBQUssV0FBTDtBQUNIO0FBQ0osS0ExS3NDOztBQTRLdkMsc0JBQWtCLDRCQUFXO0FBQ3pCLFlBQUksS0FBSyxJQUFMLENBQVUsbUJBQVYsQ0FBOEIsS0FBSyxLQUFuQyxFQUEwQyxLQUFLLFlBQS9DLENBQUosRUFBa0U7QUFDOUQsaUJBQUssdUJBQUwsR0FBK0IsSUFBL0I7QUFDQSxpQkFBSyxXQUFMLENBQWlCLEtBQWpCO0FBQ0EsaUJBQUssRUFBTCxDQUFRLFFBQVIsR0FBbUIsSUFBbkI7QUFDSDtBQUNKLEtBbExzQzs7QUFvTHZDOzs7Ozs7Ozs7O0FBVUEsb0JBQWdCLHdCQUFTLEtBQVQsRUFBZ0I7QUFDNUIsZ0JBQVEsS0FBSyxTQUFMLENBQWUsTUFBZixDQUFzQixLQUF0QixFQUE2QixLQUFLLEtBQUwsQ0FBVyxhQUFYLENBQXlCLFNBQXRELENBQVI7QUFDQSxZQUFJLE1BQU0sT0FBTixDQUFjLEtBQWQsQ0FBSixFQUEwQjtBQUN0QiwwQkFBWSxNQUFNLElBQU4sQ0FBVyxJQUFYLENBQVo7QUFDSDtBQUNELGdCQUFRLE9BQU8sS0FBUCxLQUFpQixXQUFqQixJQUFnQyxRQUFPLEtBQVAseUNBQU8sS0FBUCxPQUFpQixRQUFqRCxHQUE0RCxLQUE1RCxHQUFvRSxFQUE1RTtBQUNBLGFBQUssS0FBTCxDQUFXLEtBQVgsR0FBbUIsS0FBbkI7QUFDSCxLQXJNc0M7O0FBdU12Qzs7OztBQUlBLGdCQUFZLHNCQUFXO0FBQ25CLGVBQU8sTUFBUCxDQUFjLEtBQUssRUFBTCxDQUFRLEtBQXRCLEVBQTZCLEVBQUUsU0FBUyxRQUFYLEVBQTdCO0FBQ0gsS0E3TXNDOztBQStNdkM7Ozs7QUFJQSxnQkFBWSxzQkFBVztBQUNuQixhQUFLLEVBQUwsQ0FBUSxLQUFSLENBQWMsT0FBZCxHQUF3QixNQUF4QjtBQUNILEtBck5zQzs7QUF1TnZDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBLGlCQUFhLHFCQUFTLFFBQVQsRUFBbUI7QUFDNUI7Ozs7QUFJQSxZQUFJLFFBQVEsS0FBSyxtQkFBTCxFQUFaOztBQUVBLFlBQUksQ0FBQyxLQUFMLEVBQVk7QUFDUixnQkFBSTtBQUNBLG9CQUFJLFFBQVEsS0FBSyxjQUFMLEVBQVo7QUFDSCxhQUZELENBRUUsT0FBTyxHQUFQLEVBQVk7QUFDVix3QkFBUSxHQUFSO0FBQ0g7QUFDSjs7QUFFRCxZQUFJLENBQUMsS0FBRCxJQUFVLEtBQUssSUFBTCxDQUFVLGtDQUFWLENBQTZDLElBQTdDLEVBQW1ELEtBQUssWUFBeEQsRUFBc0UsS0FBdEUsQ0FBVixJQUEwRixDQUFDLEtBQUssRUFBTCxDQUFRLFFBQXZHLEVBQWlIO0FBQzdHLGdCQUFJO0FBQ0EscUJBQUssZUFBTCxDQUFxQixLQUFyQjtBQUNILGFBRkQsQ0FFRSxPQUFPLEdBQVAsRUFBWTtBQUNWLHdCQUFRLEdBQVI7QUFDSDtBQUNKOztBQUVELFlBQUksQ0FBQyxLQUFMLEVBQVk7QUFDUixpQkFBSyxVQUFMO0FBQ0EsaUJBQUssSUFBTCxDQUFVLFVBQVYsR0FBdUIsSUFBdkI7QUFDQSxpQkFBSyxFQUFMLENBQVEsTUFBUjtBQUNILFNBSkQsTUFJTyxJQUFJLFlBQVksQ0FBaEIsRUFBbUI7QUFBRTtBQUN4QixpQkFBSyxnQkFBTCxDQUFzQixFQUFFLEtBQUssTUFBUCxHQUFnQixRQUFoQixLQUE2QixDQUE3QixJQUFrQyxLQUF4RDtBQUNILFNBRk0sTUFFQTtBQUFFO0FBQ0wsaUJBQUssYUFBTDtBQUNIOztBQUVELGVBQU8sQ0FBQyxLQUFSO0FBQ0gsS0FsUnNDOztBQW9SdkM7OztBQUdBLG1CQUFlLHlCQUFXO0FBQ3RCLGFBQUssY0FBTCxDQUFvQixLQUFLLFlBQXpCO0FBQ0EsYUFBSyxVQUFMO0FBQ0EsYUFBSyxJQUFMLENBQVUsVUFBVixHQUF1QixJQUF2QjtBQUNBLGFBQUssRUFBTCxDQUFRLE1BQVI7O0FBRUEsZUFBTyxJQUFQO0FBQ0gsS0E5UnNDOztBQWdTdkM7Ozs7O0FBS0Esc0JBQWtCLDBCQUFTLEtBQVQsRUFBZ0I7QUFDOUIsWUFBSSxPQUFPLEtBQUssSUFBTCxDQUFVLFVBQVYsQ0FBcUIsY0FBaEM7QUFBQSxZQUFnRDtBQUM1QyxrQkFBVSxPQUFPLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLEtBQUssT0FBdkIsQ0FEZDtBQUFBLFlBQytDO0FBQzNDLGlCQUFTLFFBQVEsS0FBSyxJQUFMLElBQWEsSUFBckIsQ0FGYixDQUQ4QixDQUdXOztBQUV6QyxZQUFJLEtBQUosRUFBVztBQUNQLG9CQUFRLFFBQVIsR0FBbUIsS0FBSyxjQUFMLENBQW9CLElBQXBCLENBQXlCLElBQXpCLEVBQStCLEtBQS9CLENBQW5CO0FBQ0g7O0FBRUQsWUFBSSxNQUFKLEVBQVk7QUFDUixtQkFBTyxJQUFQLENBQVksSUFBWixFQUFrQixPQUFsQjtBQUNIO0FBQ0osS0FqVHNDOztBQW1UdkM7Ozs7O0FBS0Esb0JBQWdCLHdCQUFTLEtBQVQsRUFBZ0IsT0FBaEIsRUFBeUI7QUFDckMsWUFBSSxLQUFKLEVBQVc7QUFDUCxnQkFBSSxNQUNBLDREQUNBLHlDQURBLEdBRUEsbUJBRkEsR0FHQSx5REFKSjs7QUFNQSxvQkFBUSxNQUFNLE9BQU4sSUFBaUIsS0FBekI7O0FBRUEsZ0JBQUksT0FBTyxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzNCLHdCQUFRLEVBQVI7QUFDSDs7QUFFRCxnQkFBSSxLQUFLLFNBQUwsQ0FBZSxXQUFuQixFQUFnQztBQUM1Qix3QkFBUSxRQUFRLFFBQVEsSUFBUixHQUFlLEtBQUssU0FBTCxDQUFlLFdBQXRDLEdBQW9ELEtBQUssU0FBTCxDQUFlLFdBQTNFO0FBQ0g7O0FBRUQsZ0JBQUksS0FBSixFQUFXO0FBQ1Asb0JBQUksU0FBUyxJQUFULENBQWMsS0FBZCxDQUFKLEVBQTBCO0FBQ3RCLDRCQUFRLE9BQU8sS0FBZjtBQUNBLDRCQUFRLE1BQU0sT0FBTixDQUFjLFVBQWQsRUFBMEIsV0FBMUIsQ0FBUjtBQUNIO0FBQ0QsdUJBQU8sa0RBQWtELEtBQXpEO0FBQ0g7O0FBRUQsdUJBQVcsWUFBVztBQUFFO0FBQ3BCLHNCQUFNLEdBQU4sRUFEa0IsQ0FDTjtBQUNmLGFBRkQ7QUFHSDtBQUNKLEtBdFZzQzs7QUF3VnZDOzs7OztBQUtBLHFCQUFpQix5QkFBUyxLQUFULEVBQWdCO0FBQzdCLFlBQUksT0FDQSxFQUFFLFNBQVMsVUFBVSxLQUFLLFlBQTFCLEtBQTJDO0FBQzNDLGFBQUssSUFBTCxDQUFVLGtCQUFWLENBQTZCLEtBQUssS0FBTCxDQUFXLFFBQXhDLEVBQWtELEtBQUssWUFBdkQsRUFBcUUsS0FBckUsRUFBNEUsSUFBNUUsQ0FGQSxDQUVrRjtBQUZ0Rjs7QUFLQSxZQUFJLElBQUosRUFBVTtBQUNOLGlCQUFLLElBQUwsQ0FBVSxRQUFWLENBQW1CLFFBQW5CLENBQTRCLEtBQUssS0FBakMsRUFBd0MsS0FBeEM7QUFDQSxpQkFBSyxJQUFMLENBQVUsaUJBQVYsQ0FBNEIsS0FBSyxLQUFMLENBQVcsUUFBdkMsRUFBaUQsS0FBSyxZQUF0RCxFQUFvRSxLQUFwRSxFQUEyRSxJQUEzRTtBQUNIOztBQUVELGVBQU8sSUFBUDtBQUNILEtBeldzQzs7QUEyV3ZDOzs7Ozs7Ozs7O0FBVUEsb0JBQWdCLDBCQUFXO0FBQ3ZCLGVBQU8sS0FBSyxTQUFMLENBQWUsS0FBZixDQUFxQixLQUFLLEtBQUwsQ0FBVyxLQUFoQyxDQUFQO0FBQ0gsS0F2WHNDOztBQXlYdkM7Ozs7QUFJQSx5QkFBcUIsK0JBQVc7QUFDNUIsZUFBTyxLQUFLLFNBQUwsQ0FBZSxPQUFmLElBQTBCLEtBQUssU0FBTCxDQUFlLE9BQWYsQ0FBdUIsS0FBSyxLQUFMLENBQVcsS0FBbEMsQ0FBakM7QUFDSCxLQS9Yc0M7O0FBaVl2Qzs7Ozs7QUFLQSxlQUFXLHFCQUFXO0FBQ2xCLFlBQUksS0FBSyxLQUFLLEVBQWQ7QUFBQSxZQUNJLFVBQVUsR0FBRyxLQUFILENBQVMsSUFEdkI7QUFBQSxZQUVJLFNBQVMsR0FBRyxLQUFILENBQVMsR0FGdEI7O0FBSUEsV0FBRyxLQUFILENBQVMsSUFBVCxHQUFnQixHQUFHLEtBQUgsQ0FBUyxHQUFULEdBQWUsQ0FBL0IsQ0FMa0IsQ0FLZ0I7O0FBRWxDLFlBQUksSUFBSSxPQUFPLE9BQWY7QUFBQSxZQUF3QixJQUFJLE9BQU8sT0FBbkM7QUFDQSxhQUFLLEtBQUwsQ0FBVyxLQUFYO0FBQ0EsZUFBTyxRQUFQLENBQWdCLENBQWhCLEVBQW1CLENBQW5CO0FBQ0EsYUFBSyxTQUFMOztBQUVBLFdBQUcsS0FBSCxDQUFTLElBQVQsR0FBZ0IsT0FBaEI7QUFDQSxXQUFHLEtBQUgsQ0FBUyxHQUFULEdBQWUsTUFBZjtBQUNILEtBcFpzQzs7QUFzWnZDOzs7O0FBSUEsZUFBVyxXQTFaNEI7O0FBNFp2Qzs7Ozs7QUFLQSxlQUFXLG1CQUFTLFVBQVQsRUFBcUI7QUFBQSxZQUNwQiwwQkFEb0IsR0FDVyxLQUFLLElBQUwsQ0FBVSxVQURyQixDQUNwQiwwQkFEb0I7QUFBQSwyQkFFNkIsS0FBSyxJQUFMLENBQVUsTUFGdkM7QUFBQSxZQUVwQixFQUZvQixnQkFFcEIsRUFGb0I7QUFBQSxZQUVULFdBRlMsZ0JBRWhCLEtBRmdCO0FBQUEsWUFFWSxZQUZaLGdCQUVJLE1BRko7QUFBQSxZQUdwQixLQUhvQixHQUdWLEtBQUssRUFISyxDQUdwQixLQUhvQjs7QUFJNUIsWUFBTSxVQUFVLEtBQUssS0FBTCxDQUFXLGFBQVgsQ0FBeUIsSUFBekIsSUFBaUMsS0FBSyxLQUFMLENBQVcsVUFBWCxDQUFzQixJQUF2RTs7QUFFQSxZQUFJLE9BQU8sV0FBVyxDQUF0Qjs7QUFFQSxZQUFNLHFCQUFxQixjQUFjLElBQXpDOztBQUVBLFdBQUcsS0FBSCxDQUFTLElBQVQsR0FBZ0IsT0FBaEI7QUFDQTtBQUNBLFlBQUksUUFBUSxHQUFHLFlBQUgsQ0FBZ0IsS0FBSyxZQUFyQixJQUFxQyxFQUFqRDs7QUFFQTtBQUNBLFlBQUksQ0FBQyxLQUFELElBQVUsUUFBUSxXQUFXLEtBQWpDLEVBQXdDO0FBQ3BDLG9CQUFRLFdBQVcsS0FBWCxHQUFtQiwwQkFBM0I7QUFDSDtBQUNELFlBQUksUUFBUSxrQkFBWixFQUFnQztBQUM1QixvQkFBUSxrQkFBUjtBQUNIOztBQUVEO0FBQ0EsWUFBSSxPQUFPLEtBQVAsR0FBZSxXQUFuQixFQUFnQztBQUM1QixtQkFBTyxjQUFjLEtBQXJCO0FBQ0g7O0FBRUQsaUJBQVMsMEJBQVQ7O0FBRUEsZUFBTyxNQUFQLENBQWMsS0FBZCxFQUFxQixFQUFDLE1BQU0sR0FBRyxJQUFILENBQVAsRUFBaUIsT0FBTyxHQUFHLEtBQUgsQ0FBeEIsRUFBbUMsTUFBTSxPQUF6QyxFQUFrRCxRQUFRLE1BQTFELEVBQXJCOztBQUVBO0FBQ0EsWUFBSSxTQUFTLENBQUMsVUFBVSxxQkFBcUIsMEJBQS9CLEdBQTRELEtBQUssRUFBTCxDQUFRLFlBQXBFLEdBQW1GLFdBQVcsTUFBL0YsSUFBeUcsQ0FBdEg7QUFDQSxZQUFJLE1BQU0sV0FBVyxDQUFYLEdBQWUsMEJBQXpCO0FBQ0EsWUFBTSxzQkFBc0IsZUFBZSxHQUEzQzs7QUFFQTtBQUNBLFlBQUksU0FBUyxtQkFBYixFQUFrQztBQUM5QixxQkFBUyxtQkFBVDtBQUNIOztBQUVEO0FBQ0EsWUFBSSxNQUFNLE1BQU4sR0FBZSxZQUFuQixFQUFpQztBQUM3QixrQkFBTSxlQUFlLE1BQXJCO0FBQ0g7O0FBRUQsZUFBTyxNQUFQLENBQWMsS0FBZCxFQUFxQixFQUFFLEtBQUssR0FBRyxHQUFILENBQVAsRUFBZ0IsUUFBUSxHQUFHLE1BQUgsQ0FBeEIsRUFBckI7QUFDSCxLQWhkc0M7O0FBa2R2Qzs7Ozs7QUFLQSxpQkFBYSxxQkFBUyxlQUFULEVBQTBCO0FBQ25DLDBCQUFrQixvQkFBb0IsU0FBcEIsR0FBZ0MsSUFBaEMsR0FBdUMsZUFBekQ7QUFDQSxZQUFJLEtBQUssdUJBQVQsRUFBa0M7QUFDOUIsaUJBQUssdUJBQUwsR0FBK0IsS0FBL0I7QUFDQSxnQkFBSSxLQUFLLEtBQUwsQ0FBVyxhQUFmLEVBQThCO0FBQzFCLHFCQUFLLGNBQUwsQ0FBb0IsS0FBSyxZQUF6QjtBQUNBLHFCQUFLLFlBQUw7QUFDQSxxQkFBSyxVQUFMO0FBQ0EscUJBQUssVUFBTDtBQUNBLG9CQUFJLGVBQUosRUFBcUI7QUFDakIseUJBQUssU0FBTDtBQUNIO0FBQ0osYUFSRCxNQVFPO0FBQ0gscUJBQUssVUFBTDtBQUNIO0FBQ0o7QUFDSixLQXZlc0M7O0FBeWV2QyxrQkFBYyx3QkFBVztBQUNyQixhQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsV0FBZCxDQUEwQixLQUFLLEVBQS9CO0FBQ0gsS0EzZXNDOztBQTZldkMsY0FBVTs7QUE3ZTZCLENBQTFCLENBQWpCOztBQWlmQSxTQUFTLFdBQVQsR0FBdUIsQ0FBRTtBQUN6QixTQUFTLEVBQVQsQ0FBWSxDQUFaLEVBQWU7QUFBRSxXQUFPLElBQUksSUFBWDtBQUFrQjs7QUFHbkMsT0FBTyxPQUFQLEdBQWlCLFVBQWpCOzs7QUM1Z0JBOztBQUVBLElBQUksYUFBYSxRQUFRLGNBQVIsQ0FBakI7O0FBRUE7Ozs7OztBQU1BLElBQUksUUFBUSxXQUFXLE1BQVgsQ0FBa0IsT0FBbEIsRUFBMkI7O0FBRW5DLFlBQVU7O0FBRnlCLENBQTNCLENBQVo7O0FBTUEsT0FBTyxPQUFQLEdBQWlCLEtBQWpCOzs7QUNoQkE7O0FBRUE7O0FBRUEsSUFBSSxhQUFhLFFBQVEsY0FBUixDQUFqQjs7QUFFQSxJQUFJLGFBQWEsT0FBTyxNQUF4QjtBQUFBLElBQ0ksU0FBUyxPQUFPLFNBRHBCO0FBQUEsSUFFSSxhQUFhLE9BQU8sTUFGeEI7QUFBQSxJQUdJLFVBQVUsT0FBTyxTQUFQLENBQWlCLE9BQWpCLENBQXlCLEtBQXpCLElBQWtDLENBQUMsQ0FIakQ7QUFBQSxJQUlJLFdBQVcsT0FBTyxTQUFQLENBQWlCLE9BQWpCLENBQXlCLE1BQXpCLElBQW1DLENBQUMsQ0FKbkQ7QUFBQSxJQUtJLGNBQWMsT0FBTyxTQUFQLENBQWlCLEtBQWpCLENBQXVCLE9BQXZCLENBTGxCO0FBQUEsSUFNSSxXQUFXLENBQUMsV0FBRCxJQUNQLGVBQWUsSUFEUixJQUVQLGVBQWUsU0FGUixJQUdQLGVBQWUsYUFIUixJQUlQLFdBQVcsS0FKSixJQUlhLFlBQVksS0FWeEMsQyxDQVUrQzs7QUFFL0M7Ozs7Ozs7Ozs7QUFVQSxJQUFJLE9BQU8sV0FBVyxNQUFYLENBQWtCLE1BQWxCLEVBQTBCOztBQUVqQyxnQkFBWSxvQkFBUyxJQUFULEVBQWU7O0FBRXZCLFlBQUksYUFBSjtBQUFBLFlBQ0ksdUJBQXVCLFFBRDNCOztBQUdBLFlBQUksb0JBQUosRUFBMEI7QUFDdEIsNEJBQWdCLFlBQWhCO0FBQ0EsaUJBQUssUUFBTCxHQUFnQixxQkFBaEI7QUFDSCxTQUhELE1BR087QUFDSCw0QkFBZ0IsTUFBaEI7QUFDQSxpQkFBSyxRQUFMLEdBQWdCLHVDQUFoQjs7QUFFQSxpQkFBSyxTQUFMLEdBQWlCLFlBQVc7QUFDeEIsb0JBQUksa0JBQWtCLEtBQUssY0FBTCxHQUFzQixNQUE1QztBQUNBLHFCQUFLLEtBQUwsQ0FBVyxpQkFBWCxDQUE2QixDQUE3QixFQUFnQyxlQUFoQztBQUNILGFBSEQ7QUFJSDs7QUFFRCxhQUFLLFNBQUwsR0FBaUIsS0FBSyxZQUFMLENBQWtCLEdBQWxCLENBQXNCLGFBQXRCLENBQWpCO0FBQ0g7QUFyQmdDLENBQTFCLENBQVg7O0FBeUJBLE9BQU8sT0FBUCxHQUFpQixJQUFqQjs7O0FDckRBOztBQUVBLElBQUksWUFBWSxRQUFRLGFBQVIsQ0FBaEI7O0FBRUE7Ozs7O0FBS0EsSUFBSSxTQUFTLFVBQVUsTUFBVixDQUFpQixRQUFqQixFQUEyQjs7QUFFcEMsZ0JBQVksb0JBQVMsSUFBVCxFQUFlO0FBQ3ZCLGFBQUssU0FBTCxHQUFpQixLQUFLLFlBQUwsQ0FBa0IsR0FBbEIsQ0FBc0IsUUFBdEIsQ0FBakI7QUFDSDs7QUFKbUMsQ0FBM0IsQ0FBYjs7QUFRQSxPQUFPLE9BQVAsR0FBaUIsTUFBakI7OztBQ2pCQTs7QUFFQSxJQUFJLGFBQWEsUUFBUSxjQUFSLENBQWpCOztBQUVBOzs7O0FBSUEsSUFBSSxTQUFTLFdBQVcsTUFBWCxDQUFrQixRQUFsQixFQUE0Qjs7QUFFckMsWUFBVTs7QUFGMkIsQ0FBNUIsQ0FBYjs7QUFNQSxPQUFPLE9BQVAsR0FBaUIsTUFBakI7OztBQ2RBOztBQUVBLElBQUksYUFBYSxRQUFRLGNBQVIsQ0FBakI7O0FBRUE7Ozs7QUFJQSxJQUFJLFVBQVUsV0FBVyxNQUFYLENBQWtCLFNBQWxCLEVBQTZCOztBQUV2QyxZQUFVOztBQUY2QixDQUE3QixDQUFkOztBQU1BLE9BQU8sT0FBUCxHQUFpQixPQUFqQjs7O0FDZEE7O0FBRUEsSUFBSSxhQUFhLFFBQVEsY0FBUixDQUFqQjtBQUNBLElBQUksZUFBZSxRQUFRLHFCQUFSLENBQW5COztBQUdBOzs7Ozs7QUFNQSxJQUFJLFlBQVksV0FBVyxNQUFYLENBQWtCLFdBQWxCLEVBQStCOztBQUUzQyxjQUFVLDRFQUZpQzs7QUFJM0MsZ0JBQVksc0JBQVc7QUFDbkIsYUFBSyxLQUFMLENBQVcsS0FBWCxDQUFpQixTQUFqQixHQUE2QixLQUFLLEtBQUwsQ0FBVyxVQUFYLENBQXNCLE1BQW5EO0FBQ0gsS0FOMEM7O0FBUTNDLGVBQVcsYUFBYSxTQUFiLENBQXVCLE1BUlM7O0FBVTNDLGVBQVcscUJBQVc7QUFDbEIsYUFBSyxLQUFMLENBQVcsaUJBQVgsQ0FBNkIsQ0FBN0IsRUFBZ0MsS0FBSyxLQUFMLENBQVcsS0FBWCxDQUFpQixNQUFqRDtBQUNIO0FBWjBDLENBQS9CLENBQWhCOztBQWVBLE9BQU8sT0FBUCxHQUFpQixTQUFqQjs7O0FDM0JBOztBQUVBLElBQUksV0FBVyxRQUFRLGlCQUFSLENBQWY7O0FBR0EsSUFBSSxlQUFKOztBQUVBOzs7O0FBSUEsSUFBSSxjQUFjLFNBQVMsTUFBVCxDQUFnQixhQUFoQixFQUErQjs7QUFFN0MsZUFBVyxRQUFRLGNBQVIsQ0FGa0MsRUFFVDs7QUFFcEMsZ0JBQVksc0JBQVc7QUFDbkI7QUFDQSxhQUFLLEdBQUwsQ0FBUyxRQUFRLFNBQVIsQ0FBVDtBQUNBLGFBQUssR0FBTCxDQUFTLFFBQVEsUUFBUixDQUFUO0FBQ0EsYUFBSyxHQUFMLENBQVMsUUFBUSxVQUFSLENBQVQ7QUFDQSxhQUFLLEdBQUwsQ0FBUyxRQUFRLFVBQVIsQ0FBVDtBQUNBLGFBQUssR0FBTCxDQUFTLFFBQVEsV0FBUixDQUFUO0FBQ0EsYUFBSyxHQUFMLENBQVMsUUFBUSxhQUFSLENBQVQ7QUFDSCxLQVo0Qzs7QUFjN0MsU0FBSyxhQUFTLElBQVQsRUFBZTtBQUNoQixZQUFJLFFBQVEsS0FBSyxXQUFMLE9BQXVCLFlBQW5DLEVBQWlEO0FBQzdDLGdCQUFJLENBQUMsZUFBTCxFQUFzQjtBQUNsQix3QkFBUSxJQUFSLENBQWEsMkJBQTJCLElBQTNCLEdBQWtDLHlJQUEvQztBQUNBLGtDQUFrQixJQUFsQjtBQUNIO0FBQ0QsbUJBQU8sS0FBSyxTQUFaO0FBQ0g7QUFDRCxZQUFJO0FBQ0EsZ0JBQUksYUFBYSxTQUFTLFNBQVQsQ0FBbUIsR0FBbkIsQ0FBdUIsSUFBdkIsQ0FBNEIsSUFBNUIsRUFBa0MsSUFBbEMsQ0FBakI7QUFDSCxTQUZELENBRUUsT0FBTyxHQUFQLEVBQVk7QUFDVjtBQUNIO0FBQ0QsZUFBTyxVQUFQO0FBQ0g7O0FBNUI0QyxDQUEvQixDQUFsQjs7QUFnQ0EsT0FBTyxPQUFQLEdBQWlCLElBQUksV0FBSixFQUFqQjs7O0FDM0NBOztBQUVBLElBQUksZUFBZSxRQUFRLGdCQUFSLENBQW5COztBQUVBOzs7O0FBSUEsSUFBSSxTQUFTLGFBQWEsTUFBYixDQUFvQixRQUFwQixFQUE4Qjs7QUFFdkMsV0FBTyxlQUFTLEVBQVQsRUFBYSxNQUFiLEVBQXFCO0FBQ3hCLFlBQUksTUFBTSxPQUFPLEtBQWpCO0FBQUEsWUFDSSxJQUFJLE9BQU8sUUFBUCxDQUFnQixDQUR4QjtBQUFBLFlBRUksSUFBSSxPQUFPLFFBQVAsQ0FBZ0IsQ0FGeEI7QUFBQSxZQUdJLFNBQVMsT0FBTyxNQUhwQjtBQUFBLFlBSUksSUFBSSxPQUFPLENBQVAsR0FBVyxDQUpuQjtBQUFBLFlBS0ksSUFBSSxPQUFPLENBQVAsR0FBVyxDQUxuQjtBQUFBLFlBTUksUUFBUSxPQUFPLEtBQVAsR0FBZSxDQUFmLEdBQW1CLE9BQU8sU0FOdEM7QUFBQSxZQU9JLFNBQVMsT0FBTyxNQUFQLEdBQWdCLENBQWhCLEdBQW9CLE9BQU8sU0FQeEM7QUFBQSxZQVFJLFNBQVMsU0FBUyxDQVJ0QjtBQUFBLFlBU0ksY0FBYyxHQUFHLG9CQUFILENBQXdCLENBQXhCLEVBQTJCLENBQTNCLEVBQThCLENBQTlCLEVBQWlDLElBQUksTUFBckMsQ0FUbEI7O0FBV0EsWUFBSSxPQUFPLFNBQVgsRUFBc0I7QUFDbEIsd0JBQVksWUFBWixDQUF5QixDQUF6QixFQUE0QixTQUE1QjtBQUNBLHdCQUFZLFlBQVosQ0FBeUIsQ0FBekIsRUFBNEIsU0FBNUI7QUFDSCxTQUhELE1BR087QUFDSCx3QkFBWSxZQUFaLENBQXlCLENBQXpCLEVBQTRCLFNBQTVCO0FBQ0Esd0JBQVksWUFBWixDQUF5QixDQUF6QixFQUE0QixTQUE1QjtBQUNIOztBQUVEO0FBQ0EsV0FBRyxLQUFILENBQVMsU0FBVCxHQUFxQixPQUFPLGVBQTVCO0FBQ0EsV0FBRyxRQUFILENBQVksT0FBTyxDQUFuQixFQUFzQixPQUFPLENBQTdCLEVBQWdDLE9BQU8sS0FBdkMsRUFBOEMsT0FBTyxNQUFyRDs7QUFFQTtBQUNBLFdBQUcsS0FBSCxDQUFTLFNBQVQsR0FBcUIsV0FBckI7QUFDQSxXQUFHLEtBQUgsQ0FBUyxXQUFULEdBQXVCLFNBQXZCO0FBQ0EsYUFBSyxTQUFMLENBQWUsRUFBZixFQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5QixLQUF6QixFQUFnQyxNQUFoQyxFQUF3QyxNQUF4QyxFQUFnRCxXQUFoRCxFQUE2RCxJQUE3RDs7QUFFQSxZQUFJLEtBQUssQ0FBQyxRQUFRLEdBQUcsWUFBSCxDQUFnQixHQUFoQixDQUFULElBQWlDLENBQTFDO0FBQ0EsWUFBSSxLQUFLLENBQUMsU0FBUyxHQUFHLGFBQUgsQ0FBaUIsR0FBRyxLQUFILENBQVMsSUFBMUIsRUFBZ0MsT0FBMUMsSUFBcUQsQ0FBOUQ7O0FBRUE7QUFDQSxXQUFHLEtBQUgsQ0FBUyxZQUFULEdBQXdCLFFBQXhCO0FBQ0EsV0FBRyxLQUFILENBQVMsU0FBVCxHQUFxQixTQUFyQjtBQUNBLFdBQUcsS0FBSCxDQUFTLElBQVQsR0FBZ0IsU0FBUyxDQUFULEdBQWEsZUFBN0I7QUFDQSxlQUFPLGVBQVAsR0FBeUIsZUFBekI7QUFDQSxXQUFHLFVBQUgsQ0FBYyxHQUFkLEVBQW1CLElBQUksRUFBdkIsRUFBMkIsSUFBSSxFQUEvQjs7QUFFQTtBQUNBO0FBQ0EsWUFBSSxNQUFNLElBQUksR0FBSixHQUFVLENBQXBCO0FBQUEsWUFDSSxjQUFjLE9BQU8sV0FEekI7QUFBQSxZQUVJLGdCQUFnQixZQUFZLEdBQVosTUFBcUIsWUFBWSxHQUFaLElBQW1CLEVBQXhDLENBRnBCOztBQUlBLHNCQUFjLE9BQU8sTUFBckIsSUFBK0IsT0FBTyxNQUFQLENBQWMsRUFBZCxFQUFrQixNQUFsQixDQUEvQjtBQUNIO0FBaERzQyxDQUE5QixDQUFiOztBQW1EQSxPQUFPLE9BQVAsR0FBaUIsTUFBakI7OztBQzNEQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyRUEsSUFBSSxPQUFPLFFBQVEsU0FBUixDQUFYOztBQUVBOzs7Ozs7O0FBT0EsSUFBSSxlQUFlLEtBQUssTUFBTCxDQUFZLGNBQVosRUFBNEI7QUFDM0M7Ozs7Ozs7Ozs7Ozs7QUFhQSxXQUFPLGVBQVMsRUFBVCxFQUFhLE1BQWIsRUFBcUIsQ0FBRSxDQWRhOztBQWdCM0M7Ozs7Ozs7Ozs7OztBQVlBLGVBQVcsbUJBQVMsRUFBVCxFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsS0FBbkIsRUFBMEIsTUFBMUIsRUFBa0MsTUFBbEMsRUFBMEMsSUFBMUMsRUFBZ0QsTUFBaEQsRUFBd0Q7O0FBRS9ELFlBQUksQ0FBQyxNQUFMLEVBQWE7QUFDVCxxQkFBUyxJQUFUO0FBQ0g7QUFDRCxZQUFJLENBQUMsTUFBTCxFQUFhO0FBQ1QscUJBQVMsQ0FBVDtBQUNIO0FBQ0QsV0FBRyxTQUFIO0FBQ0EsV0FBRyxNQUFILENBQVUsSUFBSSxNQUFkLEVBQXNCLENBQXRCO0FBQ0EsV0FBRyxNQUFILENBQVUsSUFBSSxLQUFKLEdBQVksTUFBdEIsRUFBOEIsQ0FBOUI7QUFDQSxXQUFHLGdCQUFILENBQW9CLElBQUksS0FBeEIsRUFBK0IsQ0FBL0IsRUFBa0MsSUFBSSxLQUF0QyxFQUE2QyxJQUFJLE1BQWpEO0FBQ0EsV0FBRyxNQUFILENBQVUsSUFBSSxLQUFkLEVBQXFCLElBQUksTUFBSixHQUFhLE1BQWxDO0FBQ0EsV0FBRyxnQkFBSCxDQUFvQixJQUFJLEtBQXhCLEVBQStCLElBQUksTUFBbkMsRUFBMkMsSUFBSSxLQUFKLEdBQVksTUFBdkQsRUFBK0QsSUFBSSxNQUFuRTtBQUNBLFdBQUcsTUFBSCxDQUFVLElBQUksTUFBZCxFQUFzQixJQUFJLE1BQTFCO0FBQ0EsV0FBRyxnQkFBSCxDQUFvQixDQUFwQixFQUF1QixJQUFJLE1BQTNCLEVBQW1DLENBQW5DLEVBQXNDLElBQUksTUFBSixHQUFhLE1BQW5EO0FBQ0EsV0FBRyxNQUFILENBQVUsQ0FBVixFQUFhLElBQUksTUFBakI7QUFDQSxXQUFHLGdCQUFILENBQW9CLENBQXBCLEVBQXVCLENBQXZCLEVBQTBCLElBQUksTUFBOUIsRUFBc0MsQ0FBdEM7QUFDQSxXQUFHLFNBQUg7QUFDQSxZQUFJLE1BQUosRUFBWTtBQUNSLGVBQUcsTUFBSDtBQUNIO0FBQ0QsWUFBSSxJQUFKLEVBQVU7QUFDTixlQUFHLElBQUg7QUFDSDtBQUNELFdBQUcsU0FBSDtBQUNILEtBdEQwQzs7QUF3RDNDOzs7Ozs7Ozs7Ozs7O0FBYUEsNEJBQXdCLGdDQUFTLEVBQVQsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLE1BQW5CLEVBQTJCLEtBQTNCLEVBQWtDLE1BQWxDLEVBQTBDLEdBQTFDLEVBQStDLElBQS9DLEVBQXFELFNBQXJELEVBQWdFO0FBQ3BGLFlBQUksZ0JBQWdCLEdBQUcsS0FBSCxDQUFTLElBQTdCO0FBQUEsWUFDSSxxQkFBcUIsR0FBRyxLQUFILENBQVMsU0FEbEM7QUFBQSxZQUVJLGdCQUFnQixHQUFHLEtBQUgsQ0FBUyxTQUY3Qjs7QUFJQSxZQUFJLE1BQU0sSUFBSSxLQUFKLEVBQVY7QUFDQSxZQUFJLE1BQUosR0FBYSxZQUFVO0FBQ25CLGVBQUcsU0FBSCxDQUFhLEdBQWIsRUFBa0IsQ0FBbEIsRUFBcUIsQ0FBckIsRUFBd0IsTUFBeEIsRUFBZ0MsS0FBaEM7O0FBRUEsZ0JBQUksYUFBYSxJQUFJLFFBQVEsQ0FBN0I7QUFDQSxnQkFBSSxhQUFhLElBQUksU0FBUyxDQUFiLEdBQWlCLENBQWxDOztBQUVBLGVBQUcsS0FBSCxDQUFTLElBQVQsR0FBZ0IsSUFBaEI7QUFDQSxlQUFHLEtBQUgsQ0FBUyxTQUFULEdBQXFCLFNBQXJCO0FBQ0EsZUFBRyxLQUFILENBQVMsU0FBVCxHQUFxQixRQUFyQjs7QUFFQSxnQkFBSSxJQUFJLE1BQUosR0FBYSxDQUFqQixFQUFvQjtBQUNoQixzQkFBTSxLQUFOO0FBQ0g7O0FBRUQsZUFBRyxVQUFILENBQWMsR0FBZCxFQUNJLFVBREosRUFFSSxVQUZKOztBQUlBLGVBQUcsS0FBSCxDQUFTLElBQVQsR0FBZ0IsYUFBaEI7QUFDQSxlQUFHLEtBQUgsQ0FBUyxTQUFULEdBQXFCLGtCQUFyQjtBQUNBLGVBQUcsS0FBSCxDQUFTLFNBQVQsR0FBcUIsYUFBckI7QUFDSCxTQXJCRDtBQXNCQSxZQUFJLEdBQUosR0FBVSxNQUFWO0FBQ0gsS0FsRzBDOztBQW9HM0M7Ozs7Ozs7Ozs7Ozs7O0FBY0EsbUNBQStCLHVDQUFTLEVBQVQsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLE1BQW5CLEVBQTJCLEtBQTNCLEVBQWtDLFlBQWxDLEVBQWdELFNBQWhELEVBQTJELEdBQTNELEVBQWdFLElBQWhFLEVBQXNFLFNBQXRFLEVBQWlGO0FBQzVHLFlBQUksZ0JBQWdCLEdBQUcsS0FBSCxDQUFTLElBQTdCO0FBQUEsWUFDSSxxQkFBcUIsR0FBRyxLQUFILENBQVMsU0FEbEM7QUFBQSxZQUVJLGdCQUFnQixHQUFHLEtBQUgsQ0FBUyxTQUY3QjtBQUFBLFlBR0ksZUFBZSxHQUFHLEtBQUgsQ0FBUyxRQUg1QjtBQUFBLFlBSUksZ0JBQWdCLEdBQUcsS0FBSCxDQUFTLFNBSjdCOztBQU1BLFlBQUksWUFBWSxJQUFJLFFBQVEsQ0FBNUI7QUFDQSxZQUFJLFlBQVksSUFBSSxlQUFlLENBQW5DOztBQUVBLFlBQUksZ0JBQWdCLFFBQVEsZUFBZSxDQUEzQztBQUNBLFlBQUksaUJBQWlCLFNBQVMsZUFBZSxDQUE3Qzs7QUFFQSxXQUFHLFNBQUg7QUFDQSxXQUFHLE1BQUgsQ0FBVSxTQUFWLEVBQXFCLFNBQXJCO0FBQ0EsV0FBRyxNQUFILENBQVUsWUFBWSxnQkFBZ0IsQ0FBdEMsRUFBeUMsWUFBWSxjQUFyRDtBQUNBLFdBQUcsTUFBSCxDQUFVLFlBQVksZ0JBQWdCLENBQXRDLEVBQXlDLFlBQVksY0FBckQ7QUFDQSxXQUFHLFNBQUg7QUFDQSxXQUFHLFNBQUgsR0FBZSxTQUFmO0FBQ0EsV0FBRyxJQUFIOztBQUdBLFdBQUcsU0FBSCxHQUFlLFlBQWY7QUFDQSxXQUFHLFFBQUgsR0FBYyxPQUFkO0FBQ0EsV0FBRyxXQUFILEdBQWlCLFNBQWpCO0FBQ0EsV0FBRyxNQUFIOztBQUVBLFlBQUksYUFBYSxJQUFJLFFBQVEsQ0FBN0I7QUFDQSxZQUFJLGFBQWEsSUFBSSxTQUFTLENBQWIsR0FBaUIsQ0FBbEM7O0FBRUEsV0FBRyxLQUFILENBQVMsSUFBVCxHQUFnQixJQUFoQjtBQUNBLFdBQUcsS0FBSCxDQUFTLFNBQVQsR0FBcUIsU0FBckI7QUFDQSxXQUFHLEtBQUgsQ0FBUyxTQUFULEdBQXFCLFFBQXJCOztBQUVBLFlBQUksSUFBSSxNQUFKLEdBQWEsQ0FBakIsRUFBb0I7QUFDaEIsa0JBQU0sS0FBTjtBQUNIOztBQUVELFdBQUcsVUFBSCxDQUFjLEdBQWQsRUFDSSxVQURKLEVBRUksVUFGSjs7QUFJQSxXQUFHLEtBQUgsQ0FBUyxJQUFULEdBQWdCLGFBQWhCO0FBQ0EsV0FBRyxLQUFILENBQVMsU0FBVCxHQUFxQixrQkFBckI7QUFDQSxXQUFHLEtBQUgsQ0FBUyxTQUFULEdBQXFCLGFBQXJCO0FBQ0EsV0FBRyxLQUFILENBQVMsUUFBVCxHQUFvQixZQUFwQjtBQUNBLFdBQUcsS0FBSCxDQUFTLFNBQVQsR0FBcUIsYUFBckI7QUFDSDtBQWpLMEMsQ0FBNUIsQ0FBbkI7O0FBb0tBLE9BQU8sT0FBUCxHQUFpQixZQUFqQjs7O0FDM1BBOztBQUVBLElBQUksZUFBZSxRQUFRLGdCQUFSLENBQW5COztBQUVBOzs7O0FBSUEsSUFBSSxZQUFZLGFBQWEsTUFBYixDQUFvQixXQUFwQixFQUFpQzs7QUFFN0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkEsV0FBTyxlQUFTLEVBQVQsRUFBYSxNQUFiLEVBQXFCLE9BQXJCLEVBQThCO0FBQ2pDLFlBQUksSUFBSSxPQUFPLE1BQVAsQ0FBYyxDQUF0QjtBQUFBLFlBQ0ksSUFBSSxPQUFPLE1BQVAsQ0FBYyxDQUR0Qjs7QUFFSTtBQUNBLGlCQUFTLE9BQU8sTUFBUCxDQUFjLE1BSDNCOztBQUtBO0FBQ0E7QUFDQSxXQUFHLEtBQUgsQ0FBUyxTQUFULEdBQXFCLFNBQXJCO0FBQ0EsV0FBRyxJQUFIOztBQUVBO0FBQ0EsV0FBRyxLQUFILENBQVMsU0FBVCxHQUFxQixXQUFyQjtBQUNBLFdBQUcsS0FBSCxDQUFTLFNBQVQsR0FBcUIsT0FBckI7QUFDQSxXQUFHLEtBQUgsQ0FBUyxZQUFULEdBQXdCLFFBQXhCO0FBQ0EsV0FBRyxLQUFILENBQVMsSUFBVCxHQUFnQixrREFBaEI7QUFDQSxXQUFHLFVBQUgsQ0FBYyxPQUFkLEVBQXVCLElBQUksQ0FBM0IsRUFBOEIsSUFBSSxTQUFTLENBQWIsR0FBaUIsR0FBL0M7QUFDSDtBQXpDNEMsQ0FBakMsQ0FBaEI7O0FBNENBLE9BQU8sT0FBUCxHQUFpQixTQUFqQjs7O0FDcERBOztBQUVBLElBQUksZUFBZSxRQUFRLGdCQUFSLENBQW5COztBQUVBOzs7OztBQUtBLElBQUksZ0JBQWdCLGFBQWEsTUFBYixDQUFvQixlQUFwQixFQUFxQztBQUNyRCxXQUFPLGVBQVMsRUFBVCxFQUFhLE1BQWIsRUFBcUI7QUFDeEIsWUFBSSxhQUFhLEdBQUcsS0FBSCxDQUFTLE9BQU8sMkJBQWhCLElBQStDLENBQWhFO0FBQUEsWUFDSSxhQUFhLEdBQUcsS0FBSCxDQUFTLE9BQU8sMkJBQWhCLElBQStDLENBRGhFOztBQUdBLFlBQUksY0FBYyxVQUFsQixFQUE4QjtBQUMxQixnQkFBSSxJQUFJLE9BQU8sTUFBUCxDQUFjLENBQXRCO0FBQUEsZ0JBQ0ksSUFBSSxPQUFPLE1BQVAsQ0FBYyxDQUR0QjtBQUFBLGdCQUVJLFFBQVEsT0FBTyxNQUFQLENBQWMsS0FGMUI7QUFBQSxnQkFHSSxTQUFTLE9BQU8sTUFBUCxDQUFjLE1BSDNCOztBQUtBLGdCQUFJLFVBQUosRUFBZ0I7QUFDWixtQkFBRyxTQUFIOztBQUVBLG1CQUFHLElBQUgsQ0FBUSxDQUFSLEVBQVcsQ0FBWCxFQUFjLEtBQWQsRUFBcUIsTUFBckI7O0FBRUEsbUJBQUcsS0FBSCxDQUFTLFNBQVQsR0FBcUIsT0FBTywyQkFBNUI7QUFDQSxtQkFBRyxJQUFIOztBQUVBLG1CQUFHLFNBQUg7QUFDSDs7QUFFRCxnQkFBSSxVQUFKLEVBQWdCO0FBQ1osK0JBQWUsRUFBZixFQUNJLElBQUksQ0FEUixFQUVJLElBQUksQ0FGUixFQUdJLFFBQVEsQ0FIWixFQUlJLFNBQVMsQ0FKYixFQUtJLE9BQU8sMkJBTFgsRUFNSSxPQUFPLDBCQU5YO0FBT0g7QUFDSjtBQUNKO0FBaENvRCxDQUFyQyxDQUFwQjs7QUFtQ0EsT0FBTyxPQUFQLEdBQWlCLGFBQWpCOztBQUVBLFNBQVMsY0FBVCxDQUF3QixHQUF4QixFQUE2QixDQUE3QixFQUFnQyxDQUFoQyxFQUFtQyxLQUFuQyxFQUEwQyxNQUExQyxFQUFrRCxLQUFsRCxFQUF5RCxTQUF6RCxFQUFvRTtBQUNoRSxRQUFJLEtBQUosQ0FBVSxTQUFWLEdBQXNCLEtBQXRCO0FBQ0EsUUFBSSxRQUFKLENBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixTQUFuQixFQUE4QixNQUE5QjtBQUNBLFFBQUksUUFBSixDQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsS0FBbkIsRUFBMEIsU0FBMUI7QUFDQSxRQUFJLFFBQUosQ0FBYSxJQUFJLEtBQWpCLEVBQXdCLENBQXhCLEVBQTJCLFNBQTNCLEVBQXNDLE1BQXRDO0FBQ0EsUUFBSSxRQUFKLENBQWEsQ0FBYixFQUFnQixJQUFJLE1BQXBCLEVBQTRCLFFBQVEsQ0FBcEMsRUFBdUMsU0FBdkM7QUFDSDs7O0FDcEREOztBQUVBLElBQUksZUFBZSxRQUFRLGdCQUFSLENBQW5CO0FBQ0EsSUFBSSxTQUFTLFFBQVEsY0FBUixDQUFiOztBQUVBLElBQUksYUFBYSxRQUFqQjs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQSxJQUFJLGFBQWEsYUFBYSxNQUFiLENBQW9CLFlBQXBCLEVBQWtDO0FBQy9DLFdBQU8sZUFBUyxFQUFULEVBQWEsTUFBYixFQUFxQjtBQUN4QixZQUFJLE1BQU0sT0FBTyxLQUFqQjtBQUFBLFlBQ0ksU0FBUyxPQUFPLE1BRHBCO0FBQUEsWUFFSSxJQUFJLE9BQU8sQ0FGZjtBQUFBLFlBR0ksSUFBSSxPQUFPLENBSGY7QUFBQSxZQUlJLFFBQVEsT0FBTyxLQUpuQjtBQUFBLFlBS0ksU0FBUyxPQUFPLE1BTHBCO0FBQUEsWUFNSSxjQUFjLE9BQU8sV0FOekI7QUFBQSxZQU9JLGdCQUFnQixPQUFPLFlBQVAsS0FBd0IsU0FQNUM7QUFBQSxZQU91RDtBQUNuRCxtQkFBVyxPQUFPLFFBUnRCO0FBQUEsWUFTSSxPQUFPLFlBQVksYUFUdkI7QUFBQSxZQVVJLFdBQVcsQ0FWZjtBQUFBLFlBV0ksU0FYSjtBQUFBLFlBV2UsUUFYZjtBQUFBLFlBWUksUUFaSjtBQUFBLFlBWWMsUUFaZDtBQUFBLFlBYUksUUFiSjtBQUFBLFlBYWMsU0FiZDtBQUFBLFlBYXlCLFVBYnpCO0FBQUEsWUFjSSxXQWRKO0FBQUEsWUFjaUIsWUFkakI7QUFBQSxZQWVJLEtBZko7QUFBQSxZQWVXLFVBZlg7QUFBQSxZQWV1QixXQWZ2QjtBQUFBLFlBZW9DLGVBZnBDO0FBQUEsWUFlcUQsdUJBZnJEO0FBQUEsWUFnQkksQ0FoQko7QUFBQSxZQWdCTyxNQWhCUDs7QUFrQkE7O0FBRUEsbUJBQVcsT0FBTyxPQUFPLFFBQWQsQ0FBWDtBQUNBLHFCQUFhLE9BQU8sT0FBTyxVQUFkLENBQWI7QUFDQSxvQkFBWSxPQUFPLE9BQU8sU0FBZCxDQUFaOztBQUVBO0FBQ0EsWUFBSSxjQUFjLE9BQU8sT0FBTyxXQUFQLElBQXNCLE9BQU8sQ0FBdEQsQ0ExQndCLENBMEJpQzs7QUFFekQsWUFBSSxlQUFlLE9BQU8sU0FBMUIsRUFBcUM7QUFDakMsZ0JBQU0sUUFBUSxPQUFPLElBQVAsQ0FBWSxRQUFaLENBQXFCLFNBQXJCLENBQStCLFFBQS9CLENBQXdDLE9BQU8sUUFBUCxDQUFnQixDQUF4RCxFQUEyRCxPQUFPLFFBQVAsQ0FBZ0IsQ0FBM0UsQ0FBZDtBQUNBLGdCQUFJLFVBQVUsU0FBZCxFQUF5QjtBQUNyQix1QkFBTyxZQUFQLFNBQTBCLEtBQTFCO0FBQ0g7QUFDSjs7QUFFRCxZQUFJLFdBQUosRUFBaUI7QUFDYixrQkFBTSxPQUFPLFdBQVAsQ0FBbUIsR0FBbkIsRUFBd0IsTUFBeEIsQ0FBTjs7QUFFQSxnQkFBSSxNQUFNLE9BQU4sQ0FBYyxHQUFkLENBQUosRUFBd0I7QUFDcEIsNEJBQVUsSUFBSSxJQUFKLENBQVMsSUFBVCxDQUFWO0FBQ0g7O0FBRUQsdUJBQVcsT0FBTyxVQUFQLEdBQW9CLE9BQU8sdUJBQTNCLEdBQXFELE9BQU8sSUFBdkU7O0FBRUEsd0JBQVksR0FBRyxLQUFILENBQVMsV0FBVCxHQUF1QixPQUFPLFVBQVAsR0FDN0IsT0FBTyx3QkFEc0IsR0FFN0IsT0FBTyxLQUZiO0FBR0gsU0FaRCxNQVlPO0FBQ0gsa0JBQU0sRUFBTjtBQUNIOztBQUVELGVBQU8sUUFDSCxRQUFRLFNBQVMsS0FEZCxJQUVILGFBQWEsU0FBUyxRQUZuQixJQUdILGNBQWMsU0FBUyxTQUgzQjs7QUFLQTtBQUNBLGlCQUFTLEVBQVQ7QUFDQSxZQUFJLENBQUo7O0FBRUEsWUFBSSxDQUFDLE9BQU8sd0JBQVosRUFBc0M7QUFDbEMsZ0JBQUksT0FBTyxhQUFQLElBQXdCLE9BQU8sa0JBQVAsQ0FBMEIsT0FBdEQsRUFBK0Q7QUFDM0QsNkJBQWEsT0FBTyxrQkFBUCxDQUEwQixlQUF2QztBQUNILGFBRkQsTUFFTyxJQUFJLE9BQU8sWUFBUCxJQUF1QixDQUFDLFFBQVEsT0FBTyxpQkFBaEIsRUFBbUMsT0FBOUQsRUFBdUU7QUFDMUUsNkJBQWEsT0FBTyxZQUFQLElBQXVCLENBQUMsTUFBTSxNQUE5QixJQUF3QyxNQUFNLE1BQU4sQ0FBYSxlQUFiLEtBQWlDLFNBQXpFLEdBQXFGLE1BQU0sZUFBM0YsR0FBNkcsTUFBTSxNQUFOLENBQWEsZUFBdkk7QUFDSCxhQUZNLE1BRUEsSUFBSSxPQUFPLGVBQVAsSUFBMEIsQ0FBQyxRQUFRLE9BQU8sb0JBQWhCLEVBQXNDLE9BQXBFLEVBQTZFO0FBQ2hGLDZCQUFhLE9BQU8sU0FBUCxJQUFvQixDQUFDLE1BQU0sTUFBM0IsSUFBcUMsTUFBTSxNQUFOLENBQWEsZUFBYixLQUFpQyxTQUF0RSxHQUFrRixNQUFNLGVBQXhGLEdBQTBHLE1BQU0sTUFBTixDQUFhLGVBQXBJO0FBQ0g7QUFDSjs7QUFFRCxZQUFJLEdBQUcsS0FBSCxDQUFTLFVBQVQsSUFBdUIsQ0FBM0IsRUFBOEI7QUFDMUIsZ0JBQUksT0FBTyxVQUFQLElBQXFCLENBQUMsT0FBTyxtQkFBN0IsS0FBcUQsT0FBTyxXQUFQLElBQXNCLENBQUMsT0FBTyxZQUFuRixDQUFKLEVBQXNHO0FBQ2xHLDhCQUFjLE9BQU8sOEJBQXJCO0FBQ0g7O0FBRUQsZ0JBQUksR0FBRyxLQUFILENBQVMsV0FBVCxJQUF3QixDQUE1QixFQUErQjtBQUMzQiwwQ0FBMkIsT0FBTyxlQUFQLEtBQTJCLE9BQU8sWUFBN0Q7QUFDQSxvQkFBSSxDQUFDLHVCQUFMLEVBQThCO0FBQzFCLHNDQUFrQixJQUFsQjs7QUFFQSx3QkFBSSxPQUFPLGFBQVgsRUFBMEI7QUFDdEIsK0JBQU8sSUFBUCxDQUFZLE9BQU8sZUFBbkI7QUFDSCxxQkFGRCxNQUVPO0FBQ0gsaUNBQVMsQ0FBQyxPQUFPLGVBQVIsQ0FBVDtBQUNIOztBQUVELDJCQUFPLFFBQVMsb0JBQW9CLFNBQVMsZUFBdEMsSUFDSCxPQUFPLGVBQVAsS0FBMkIsU0FBUyxNQUFULENBQWdCLEdBQWhCLENBRC9CO0FBRUg7QUFDSjs7QUFFRCxnQkFBSSxnQkFBZ0IsU0FBcEIsRUFBK0I7QUFDM0Isb0JBQUksT0FBTyxhQUFYLEVBQTBCO0FBQ3RCLDJCQUFPLElBQVAsQ0FBWSxXQUFaO0FBQ0gsaUJBRkQsTUFFTztBQUNILDZCQUFTLENBQUMsV0FBRCxDQUFUO0FBQ0g7QUFDRDtBQUNBLHVCQUFPLFFBQVEsZ0JBQWdCLFNBQVMsTUFBVCxDQUFnQixHQUFoQixDQUEvQjtBQUNIO0FBQ0o7QUFDRCxZQUFJLGVBQWUsU0FBbkIsRUFBOEI7QUFDMUIsZ0JBQUksT0FBTyxhQUFYLEVBQTBCO0FBQ3RCLHVCQUFPLElBQVAsQ0FBWSxVQUFaO0FBQ0gsYUFGRCxNQUVPO0FBQ0gseUJBQVMsQ0FBQyxVQUFELENBQVQ7QUFDSDs7QUFFRCxtQkFBTyxRQUFRLGVBQWUsU0FBUyxNQUFULENBQWdCLEdBQWhCLENBQTlCO0FBQ0g7O0FBRUQ7QUFDQSxZQUFJLFFBQVEsTUFBTSxTQUFTLE1BQVQsQ0FBZ0IsTUFBbEMsRUFBMEM7QUFDdEM7QUFDSDs7QUFFRDtBQUNBLGVBQU8sUUFBUCxHQUFrQjtBQUNkLG1CQUFPLEdBRE87QUFFZCx1QkFBVyxTQUZHO0FBR2Qsc0JBQVUsUUFISTtBQUlkLDZCQUFpQixlQUpIO0FBS2Qsb0JBQVE7QUFMTSxTQUFsQjs7QUFRQSxvQkFBWSxFQUFaLEVBQWdCLE1BQWhCLEVBQXdCLENBQXhCLEVBQTJCLENBQTNCLEVBQThCLEtBQTlCLEVBQXFDLE1BQXJDLEVBQTZDLGVBQTdDOztBQUVBO0FBQ0Esc0JBQWMsV0FBVyxjQUFjLFNBQVMsS0FBdkIsR0FBK0IsV0FBMUMsR0FBd0QsT0FBTyxlQUE3RTtBQUNBLHVCQUFlLFlBQVksY0FBYyxVQUFVLEtBQXhCLEdBQWdDLFdBQTVDLEdBQTBELE9BQU8sZ0JBQWhGOztBQUVBLFlBQUksT0FBTyx1QkFBWCxFQUFvQztBQUNoQywyQkFBZSxPQUFPLFNBQVAsR0FBbUIsT0FBTywrQkFBekM7QUFDSDs7QUFFRCxZQUFJLG1CQUFtQixZQUF2Qjs7QUFFQSxZQUFJLE9BQU8sMEJBQVAsSUFBcUMsT0FBTyxxQkFBaEQsRUFBdUU7QUFDbkUsZ0JBQUksNkJBQTZCLEtBQUssU0FBUyxDQUFULEdBQWEsT0FBTywwQkFBUCxHQUFvQyxDQUF0RCxJQUEyRCxDQUE1RjtBQUNBLGdCQUFJLDZCQUE2QixLQUFLLFFBQVEsQ0FBUixHQUFZLE9BQU8seUJBQVAsR0FBbUMsQ0FBcEQsQ0FBakM7QUFDQSxpQkFBSyw2QkFBTCxDQUFtQyxFQUFuQyxFQUNJLDBCQURKLEVBRUksMEJBRkosRUFHSSxPQUFPLDBCQUhYLEVBSUksT0FBTyx5QkFKWCxFQUtJLENBTEosRUFNSSxPQUFPLHNCQU5YLEVBT0ksT0FBTyxxQkFQWCxFQVFJLE9BQU8saUJBUlgsRUFTSSxPQUFPLHNCQVRYO0FBVUg7O0FBRUQsWUFBSSxPQUFPLHVCQUFQLElBQWtDLFdBQXRDLEVBQW1EO0FBQy9DLGVBQUcsS0FBSCxDQUFTLFdBQVQsR0FBdUIsT0FBTyw0QkFBOUI7QUFDQSxnQkFBSSxPQUFPLHdCQUFYLEVBQXFDO0FBQ2pDLG1CQUFHLEtBQUgsQ0FBUyxTQUFULEdBQXFCLE9BQU8saUNBQTVCO0FBQ0gsYUFGRCxNQUVPO0FBQ0gsbUJBQUcsS0FBSCxDQUFTLFNBQVQsR0FBcUIsT0FBTywwQkFBNUI7QUFDSDs7QUFFRCxnQkFBSSxlQUFlLEtBQUssU0FBUyxDQUFULEdBQWEsT0FBTyx1QkFBUCxHQUFpQyxDQUFuRCxDQUFuQjtBQUNBLGdCQUFJLHFCQUFxQixPQUFPLGtDQUFQLEdBQ25CLElBQUksT0FBTyx3QkFEakI7O0FBR0EsZ0JBQUksZUFBZSxJQUFJLEtBQUosR0FBWSxPQUFPLDRCQUFuQixHQUFrRCxrQkFBckU7O0FBRUEsaUJBQUssU0FBTCxDQUFlLEVBQWYsRUFDSSxZQURKLEVBRUksWUFGSixFQUdJLGtCQUhKLEVBSUksT0FBTyx1QkFKWCxFQUtJLENBTEosRUFNSSxJQU5KOztBQVFBLGdCQUFJLGdCQUFnQixHQUFHLEtBQUgsQ0FBUyxJQUE3QjtBQUFBLGdCQUNJLHFCQUFxQixHQUFHLEtBQUgsQ0FBUyxTQURsQzs7QUFHQSxlQUFHLEtBQUgsQ0FBUyxJQUFULEdBQWdCLE9BQU8sbUJBQXZCOztBQUVBLGdCQUFJLE9BQU8sd0JBQVgsRUFBcUM7QUFDakMsbUJBQUcsS0FBSCxDQUFTLFNBQVQsR0FBcUIsT0FBTywyQkFBNUI7QUFDSCxhQUZELE1BRU87QUFDSCxtQkFBRyxLQUFILENBQVMsU0FBVCxHQUFxQixPQUFPLG9CQUE1QjtBQUNIOztBQUVELGdCQUFJLGNBQWMsT0FBTyxNQUFQLENBQWMsRUFBZCxFQUFrQixNQUFsQixDQUFsQjtBQUNBLHdCQUFZLE1BQVosR0FBcUIsT0FBckI7O0FBRUEsZ0JBQUksYUFBYSxJQUFJLEtBQUosR0FBWSxPQUFPLDRCQUFuQixHQUNYLE9BQU8sd0JBREksR0FFWCxPQUFPLGtDQUZiO0FBR0EsZ0JBQUksYUFBYSxlQUFlLE9BQU8sdUJBQVAsR0FBaUMsQ0FBakU7O0FBRUEsZUFBRyxVQUFILENBQWMsT0FBTywwQkFBckIsRUFDSSxVQURKLEVBRUksVUFGSjs7QUFJQSxlQUFHLEtBQUgsQ0FBUyxJQUFULEdBQWdCLGFBQWhCO0FBQ0EsZUFBRyxLQUFILENBQVMsU0FBVCxHQUFxQixrQkFBckI7O0FBRUEsZ0NBQW9CLHFCQUFxQixPQUFPLDZCQUFoRDtBQUNIOztBQUVELFlBQUksT0FBTyxjQUFQLElBQXlCLE9BQU8sV0FBcEMsRUFBaUQ7QUFDN0MsZ0JBQUksaUJBQWdCLEdBQUcsS0FBSCxDQUFTLElBQTdCO0FBQUEsZ0JBQ0ksc0JBQXFCLEdBQUcsS0FBSCxDQUFTLFNBRGxDOztBQUdBLGVBQUcsS0FBSCxDQUFTLElBQVQsR0FBZ0IsT0FBTyxrQkFBdkI7QUFDQSxlQUFHLEtBQUgsQ0FBUyxTQUFULEdBQXFCLE9BQU8sbUJBQTVCOztBQUVBLGdCQUFJLGVBQWMsT0FBTyxNQUFQLENBQWMsRUFBZCxFQUFrQixNQUFsQixDQUFsQjtBQUNBLHlCQUFZLE1BQVosR0FBcUIsT0FBckI7O0FBRUEsZ0NBQW9CLHFCQUFxQixFQUFyQixFQUF5QixZQUF6QixFQUFzQyxPQUFPLFdBQTdDLEVBQTBELFdBQTFELEVBQXVFLGdCQUF2RSxDQUFwQjs7QUFFQSxlQUFHLEtBQUgsQ0FBUyxJQUFULEdBQWdCLGNBQWhCO0FBQ0EsZUFBRyxLQUFILENBQVMsU0FBVCxHQUFxQixtQkFBckI7QUFDSDs7QUFFRCxZQUFJLE9BQU8sV0FBUCxJQUFzQixDQUFDLE9BQU8saUJBQWxDLEVBQXFEO0FBQ2pELGdCQUFJLGtCQUFnQixHQUFHLEtBQUgsQ0FBUyxJQUE3QjtBQUFBLGdCQUNJLHVCQUFxQixHQUFHLEtBQUgsQ0FBUyxTQURsQzs7QUFHQSxlQUFHLEtBQUgsQ0FBUyxJQUFULEdBQWdCLE9BQU8sZUFBdkI7QUFDQSxlQUFHLEtBQUgsQ0FBUyxTQUFULEdBQXFCLE9BQU8sZ0JBQTVCOztBQUVBLGdCQUFNLDRCQUE0QixPQUFPLGlCQUF6QztBQUNBLG1CQUFPLGlCQUFQLEdBQTJCLE9BQU8sNkJBQWxDO0FBQ0EsaUNBQXFCLEVBQXJCLEVBQXlCLE1BQXpCLEVBQWlDLE9BQU8sV0FBeEMsRUFBcUQsV0FBckQsRUFBa0UsZ0JBQWxFO0FBQ0EsMkJBQWUsR0FBRyxZQUFILENBQWdCLE9BQU8sV0FBdkIsSUFBc0MsT0FBTywyQkFBNUQ7QUFDQSxtQkFBTyxpQkFBUCxHQUEyQix5QkFBM0I7O0FBRUEsZUFBRyxLQUFILENBQVMsSUFBVCxHQUFnQixlQUFoQjtBQUNBLGVBQUcsS0FBSCxDQUFTLFNBQVQsR0FBcUIsb0JBQXJCO0FBQ0g7O0FBRUQsWUFBSSxPQUFPLGNBQVgsRUFBMkI7QUFDdkIsZUFBRyxLQUFILENBQVMsU0FBVCxHQUFxQixPQUFPLG1CQUE1QjtBQUNBLGVBQUcsS0FBSCxDQUFTLElBQVQsR0FBZ0IsT0FBTyxrQkFBdkI7O0FBRUEsaUNBQXFCLEVBQXJCLEVBQXlCLE1BQXpCLEVBQWlDLE9BQU8sY0FBeEMsRUFBd0QsV0FBeEQsRUFBcUUsZ0JBQXJFO0FBQ0g7O0FBRUQsWUFBSSxXQUFKLEVBQWlCO0FBQ2I7QUFDQSxlQUFHLEtBQUgsQ0FBUyxTQUFULEdBQXFCLFNBQXJCO0FBQ0EsZUFBRyxLQUFILENBQVMsSUFBVCxHQUFnQixRQUFoQjs7QUFFQSx1QkFBVyxPQUFPLFdBQVAsSUFBc0IsT0FBTyxrQkFBN0IsR0FDTCxvQkFBb0IsRUFBcEIsRUFBd0IsTUFBeEIsRUFBZ0MsR0FBaEMsRUFBcUMsV0FBckMsRUFBa0QsZ0JBQWxELENBREssR0FFTCxxQkFBcUIsRUFBckIsRUFBeUIsTUFBekIsRUFBaUMsR0FBakMsRUFBc0MsV0FBdEMsRUFBbUQsZ0JBQW5ELENBRk47O0FBSUEsZ0JBQUksT0FBTyxZQUFQLElBQXVCLENBQUMsT0FBTyxrQkFBbkMsRUFBdUQ7QUFDbkQsb0JBQU0saUJBQWlCLGNBQWMsR0FBRyxZQUFILENBQWdCLEdBQWhCLENBQWQsR0FBcUMsT0FBTywwQkFBbkU7QUFDQSxvQkFBSSw2QkFBNEIsT0FBTyxpQkFBdkM7QUFDQSx1QkFBTyxpQkFBUCxHQUEyQixJQUEzQjtBQUNBLG1CQUFHLEtBQUgsQ0FBUyxTQUFULEdBQXFCLE9BQU8scUJBQTVCO0FBQ0EsbUJBQUcsS0FBSCxDQUFTLElBQVQsR0FBZ0IsT0FBTyxvQkFBdkI7QUFDQSw0QkFBWSxvQkFBb0IsRUFBcEIsRUFBd0IsTUFBeEIsRUFBZ0MsT0FBTyxZQUF2QyxFQUFxRCxjQUFyRCxFQUFxRSxnQkFBckUsQ0FBWjtBQUNBLHVCQUFPLGlCQUFQLEdBQTJCLDBCQUEzQjtBQUNIO0FBQ0osU0FsQkQsTUFrQk8sSUFBSSxVQUFKLEVBQWdCO0FBQWE7QUFDaEMsdUJBQVcsS0FBSyxLQUFMLENBQVcsQ0FBQyxTQUFTLFdBQVcsTUFBckIsSUFBK0IsQ0FBMUMsQ0FBWDtBQUNBLHVCQUFXLEtBQUssS0FBTCxDQUFXLENBQUMsUUFBUSxXQUFXLEtBQXBCLElBQTZCLENBQXhDLENBQVg7QUFDQSxlQUFHLFNBQUgsQ0FBYSxVQUFiLEVBQXlCLElBQUksS0FBSixHQUFZLFFBQVosR0FBdUIsV0FBVyxLQUEzRCxFQUFrRSxJQUFJLFFBQXRFO0FBQ0EsdUJBQVcsY0FBYyxXQUFXLEtBQXpCLEdBQWlDLFdBQTVDO0FBQ0g7O0FBRUQsWUFBSSxRQUFKLEVBQWM7QUFDVjtBQUNBLHVCQUFXLEtBQUssS0FBTCxDQUFXLENBQUMsU0FBUyxTQUFTLE1BQW5CLElBQTZCLENBQXhDLENBQVg7QUFDQSxlQUFHLFNBQUgsQ0FBYSxRQUFiLEVBQXVCLElBQUksV0FBM0IsRUFBd0MsSUFBSSxRQUE1QztBQUNIOztBQUVELFlBQUksU0FBSixFQUFlO0FBQ1g7QUFDQTtBQUNBLGdCQUFJLFNBQVMsSUFBSSxLQUFKLElBQWEsVUFBVSxLQUFWLEdBQWtCLFdBQS9CLENBQWI7QUFDQSxnQkFBSSx1QkFBSixFQUE2QjtBQUN6QixrQ0FBa0IsSUFBbEI7QUFDQSx1QkFBTyxPQUFQLENBQWUsT0FBTyxlQUF0QjtBQUNIO0FBQ0Qsd0JBQVksRUFBWixFQUFnQixNQUFoQixFQUF3QixNQUF4QixFQUFnQyxDQUFoQyxFQUFtQyxZQUFuQyxFQUFpRCxNQUFqRCxFQUF5RCxlQUF6RDs7QUFFQTtBQUNBLHVCQUFXLEtBQUssS0FBTCxDQUFXLENBQUMsU0FBUyxVQUFVLE1BQXBCLElBQThCLENBQXpDLENBQVg7QUFDQSxlQUFHLFNBQUgsQ0FBYSxTQUFiLEVBQXdCLE1BQXhCLEVBQWdDLElBQUksUUFBcEM7QUFDSDs7QUFFRCxZQUFJLE9BQU8sbUJBQVgsRUFBZ0M7QUFDNUIsZUFBRyxTQUFIO0FBQ0EsZUFBRyxJQUFILENBQVEsQ0FBUixFQUFXLENBQVgsRUFBYyxLQUFkLEVBQXFCLE1BQXJCO0FBQ0EsZUFBRyxLQUFILENBQVMsU0FBVCxHQUFxQixPQUFPLG1CQUE1QjtBQUNBLGVBQUcsS0FBSCxDQUFTLFdBQVQsR0FBdUIsT0FBTyxlQUE5QjtBQUNBLGVBQUcsTUFBSDtBQUNBLGVBQUcsU0FBSDtBQUNIOztBQUVELFlBQUksUUFBSixFQUFjO0FBQ1YsbUJBQU8sUUFBUCxHQUFrQixjQUFjLFFBQWQsR0FBeUIsWUFBM0M7QUFDSDtBQUNKO0FBOVM4QyxDQUFsQyxDQUFqQjs7QUFpVEE7Ozs7Ozs7O0FBUUEsU0FBUyxtQkFBVCxDQUE2QixFQUE3QixFQUFpQyxNQUFqQyxFQUF5QyxHQUF6QyxFQUE4QyxXQUE5QyxFQUEyRCxZQUEzRCxFQUF5RTtBQUNyRSxRQUFJLElBQUksT0FBTyxNQUFQLENBQWMsQ0FBdEI7QUFBQSxRQUNJLElBQUksT0FBTyxNQUFQLENBQWMsQ0FEdEI7QUFBQSxRQUVJLFFBQVEsT0FBTyxNQUFQLENBQWMsS0FGMUI7QUFBQSxRQUdJLFNBQVMsT0FBTyxNQUFQLENBQWMsTUFIM0I7QUFBQSxRQUlJLFdBQVcsQ0FBQyxNQUFNLEVBQVAsRUFBVyxJQUFYLEdBQWtCLE9BQWxCLENBQTBCLFVBQTFCLEVBQXNDLEdBQXRDLENBSmY7QUFBQSxRQUkyRDtBQUN2RCxZQUFRLFVBQVUsRUFBVixFQUFjLE1BQWQsRUFBc0IsU0FBUyxLQUFULENBQWUsR0FBZixDQUF0QixFQUEyQyxLQUEzQyxDQUxaOztBQU9BLFFBQUksTUFBTSxNQUFOLEtBQWlCLENBQXJCLEVBQXdCO0FBQ3BCLGVBQU8scUJBQXFCLEVBQXJCLEVBQXlCLE1BQXpCLEVBQWlDLFFBQWpDLEVBQTJDLFdBQTNDLEVBQXdELFlBQXhELENBQVA7QUFDSDs7QUFFRCxRQUFJLGVBQWUsV0FBbkI7QUFBQSxRQUNJLGVBQWUsT0FBTyxPQUQxQjtBQUFBLFFBRUksU0FBUyxPQUFPLE1BRnBCO0FBQUEsUUFHSSxhQUFhLEdBQUcsYUFBSCxDQUFpQixPQUFPLElBQXhCLEVBQThCLE1BSC9DOztBQUtBLFlBQVEsTUFBUjtBQUNJLGFBQUssT0FBTDtBQUNJLDJCQUFlLFFBQVEsWUFBdkI7QUFDQTtBQUNKLGFBQUssUUFBTDtBQUNJLDJCQUFlLFFBQVEsQ0FBdkI7QUFDQTtBQU5SOztBQVNBLFFBQUksT0FBTyxDQUFYO0FBQUEsUUFBYyxPQUFPLEtBQUssSUFBTCxDQUFVLGFBQWEsQ0FBdkIsQ0FBckI7O0FBRUEsb0JBQWdCLEtBQUssSUFBTCxDQUFVLENBQUMsU0FBUyxDQUFDLE1BQU0sTUFBTixHQUFlLENBQWhCLElBQXFCLFVBQS9CLElBQTZDLENBQXZELENBQWhCOztBQUVBLG1CQUFlLEtBQUssR0FBTCxDQUFTLElBQVQsRUFBZSxZQUFmLENBQWY7QUFDQSxtQkFBZSxLQUFLLEdBQUwsQ0FBUyxJQUFULEVBQWUsWUFBZixDQUFmOztBQUVBLE9BQUcsS0FBSCxDQUFTLElBQVQsR0FqQ3FFLENBaUNwRDtBQUNqQixPQUFHLFNBQUg7QUFDQSxPQUFHLElBQUgsQ0FBUSxDQUFSLEVBQVcsQ0FBWCxFQUFjLEtBQWQsRUFBcUIsTUFBckI7QUFDQSxPQUFHLElBQUg7O0FBRUEsT0FBRyxLQUFILENBQVMsU0FBVCxHQUFxQixNQUFyQjtBQUNBLE9BQUcsS0FBSCxDQUFTLFlBQVQsR0FBd0IsUUFBeEI7O0FBRUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE1BQU0sTUFBMUIsRUFBa0MsR0FBbEMsRUFBdUM7QUFDbkMsV0FBRyxVQUFILENBQWMsTUFBTSxDQUFOLENBQWQsRUFBd0IsSUFBSSxZQUE1QixFQUEwQyxJQUFJLFlBQUosR0FBb0IsSUFBSSxVQUFsRTtBQUNIOztBQUVELE9BQUcsS0FBSCxDQUFTLE9BQVQsR0E3Q3FFLENBNkNqRDs7QUFFcEIsV0FBTyxLQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7O0FBUUEsU0FBUyxvQkFBVCxDQUE4QixFQUE5QixFQUFrQyxNQUFsQyxFQUEwQyxHQUExQyxFQUErQyxXQUEvQyxFQUE0RCxZQUE1RCxFQUEwRTtBQUN0RSxRQUFJLElBQUksT0FBTyxNQUFQLENBQWMsQ0FBdEI7QUFBQSxRQUNJLElBQUksT0FBTyxNQUFQLENBQWMsQ0FEdEI7QUFBQSxRQUVJLFFBQVEsT0FBTyxNQUFQLENBQWMsS0FGMUI7QUFBQSxRQUdJLGVBQWUsV0FIbkI7QUFBQSxRQUlJLFNBQVMsT0FBTyxNQUpwQjtBQUFBLFFBS0ksUUFMSjtBQUFBLFFBTUksT0FOSjs7QUFRQSxRQUFJLE9BQU8sZ0JBQVgsRUFBNkI7QUFDekIsa0JBQVUsR0FBRyxxQkFBSCxDQUF5QixHQUF6QixFQUE4QixRQUFRLFdBQVIsR0FBc0IsWUFBcEQsRUFBa0UsT0FBTyx3QkFBekUsRUFBbUcsT0FBTyxnQkFBMUcsQ0FBVjtBQUNBLG1CQUFXLFFBQVEsS0FBUixHQUFnQixZQUEzQjtBQUNBLGNBQU0sUUFBUSxNQUFSLElBQWtCLEdBQXhCO0FBQ0EsZ0JBQVEsTUFBUjtBQUNJLGlCQUFLLE9BQUw7QUFDSSwrQkFBZSxRQUFRLFlBQVIsR0FBdUIsUUFBUSxLQUE5QztBQUNBO0FBQ0osaUJBQUssUUFBTDtBQUNJLCtCQUFlLENBQUMsUUFBUSxRQUFRLEtBQWpCLElBQTBCLENBQXpDO0FBQ0E7QUFOUjtBQVFILEtBWkQsTUFZTztBQUNILGtCQUFVLEdBQUcscUJBQUgsQ0FBeUIsR0FBekIsRUFBOEIsUUFBUSxXQUFSLEdBQXNCLFlBQXBELEVBQWtFLE9BQU8sd0JBQXpFLEVBQW1HLE9BQU8sZ0JBQTFHLEVBQTRILElBQTVILENBQVY7QUFDQSxtQkFBVyxJQUFJLFlBQWY7QUFDQSxZQUFJLFFBQVEsTUFBUixLQUFtQixTQUF2QixFQUFrQztBQUM5QixrQkFBTSxRQUFRLE1BQWQ7QUFDSCxTQUZELE1BRU87QUFDSCxvQkFBUSxNQUFSO0FBQ0kscUJBQUssT0FBTDtBQUNJLG1DQUFlLFFBQVEsWUFBUixHQUF1QixRQUFRLEtBQTlDO0FBQ0E7QUFDSixxQkFBSyxRQUFMO0FBQ0ksbUNBQWUsQ0FBQyxRQUFRLFFBQVEsS0FBakIsSUFBMEIsQ0FBekM7QUFDQTtBQU5SO0FBUUg7QUFDSjs7QUFFRCxRQUFJLFFBQVEsSUFBWixFQUFrQjtBQUNkLGFBQUssS0FBSyxHQUFMLENBQVMsV0FBVCxFQUFzQixZQUF0QixDQUFMO0FBQ0EsYUFBSyxPQUFPLE1BQVAsQ0FBYyxNQUFkLEdBQXVCLENBQTVCOztBQUVBLFlBQUksUUFBUSxVQUFSLENBQW1CLE1BQW5CLEdBQTRCLENBQWhDLEVBQW1DO0FBQy9CLGdCQUFNLGVBQWUsR0FBRyxLQUFILENBQVMsU0FBOUI7QUFDQSxlQUFHLEtBQUgsQ0FBUyxTQUFULEdBQXFCLE9BQU8sY0FBNUI7QUFDQSxvQkFBUSxVQUFSLENBQW1CLE9BQW5CLENBQTJCO0FBQUEsdUJBQUssR0FBRyxRQUFILENBQVksSUFBSSxFQUFFLENBQWxCLEVBQXFCLE9BQU8sTUFBUCxDQUFjLENBQW5DLEVBQXNDLEVBQUUsS0FBeEMsRUFBK0MsT0FBTyxNQUFQLENBQWMsTUFBN0QsQ0FBTDtBQUFBLGFBQTNCO0FBQ0EsZUFBRyxLQUFILENBQVMsU0FBVCxHQUFxQixZQUFyQjtBQUNIOztBQUVELFlBQUksT0FBTyxjQUFYLEVBQTJCO0FBQ3ZCLGdCQUFNLGtDQUFrQyxDQUFDLE9BQU8sZUFBUixJQUEyQixPQUFPLHVCQUFsQyxJQUE2RCxPQUFPLGdCQUFwRSxJQUF3RixPQUFPLHFCQUFQLEdBQStCLENBQS9KO0FBQ0EsZ0JBQUksT0FBTyxJQUFQLElBQWUsbUNBQW1DLENBQUMsT0FBTyxpQkFBOUQsRUFBaUY7QUFDN0Usb0JBQUksT0FBTyxhQUFQLElBQXdCLENBQUMsT0FBTyxXQUFwQyxFQUFpRDtBQUM3Qyx3QkFBSSxPQUFPLFNBQVgsRUFBc0I7QUFDbEIsMkJBQUcsS0FBSCxDQUFTLFdBQVQsR0FBdUIsT0FBTyxTQUE5QjtBQUNIO0FBQ0QsdUJBQUcsU0FBSDtBQUNBLDhCQUFVLE1BQVYsRUFBa0IsRUFBbEIsRUFBc0IsR0FBdEIsRUFBMkIsQ0FBM0IsRUFBOEIsQ0FBOUIsRUFBaUMsQ0FBakM7QUFDQSx1QkFBRyxNQUFIO0FBQ0EsdUJBQUcsU0FBSDtBQUNIO0FBQ0Qsb0JBQUksT0FBTyxTQUFQLEtBQXFCLE9BQU8sYUFBUCxJQUF3QixDQUFDLE9BQU8sZ0JBQXJELENBQUosRUFBNEU7QUFDeEUsdUJBQUcsS0FBSCxDQUFTLFNBQVQsR0FBcUIsT0FBTyxTQUE1QjtBQUNIO0FBQ0o7O0FBRUQsZ0JBQUksT0FBTyxhQUFQLEtBQXlCLElBQTdCLEVBQW1DO0FBQy9CLG1CQUFHLFNBQUg7QUFDQSw4QkFBYyxNQUFkLEVBQXNCLEVBQXRCLEVBQTBCLEdBQTFCLEVBQStCLENBQS9CLEVBQWtDLENBQWxDLEVBQXFDLENBQXJDO0FBQ0EsbUJBQUcsTUFBSDtBQUNBLG1CQUFHLFNBQUg7QUFDSDtBQUNKOztBQUVELFdBQUcsS0FBSCxDQUFTLFNBQVQsR0FBcUIsTUFBckI7QUFDQSxXQUFHLEtBQUgsQ0FBUyxZQUFULEdBQXdCLFFBQXhCO0FBQ0EsV0FBRyxVQUFILENBQWMsR0FBZCxFQUFtQixDQUFuQixFQUFzQixDQUF0QjtBQUNIOztBQUVELFdBQU8sUUFBUDtBQUNIOztBQUVELFNBQVMsU0FBVCxDQUFtQixFQUFuQixFQUF1QixNQUF2QixFQUErQixLQUEvQixFQUFzQyxLQUF0QyxFQUE2Qzs7QUFFekMsUUFBSSxNQUFNLE1BQU4sS0FBaUIsQ0FBckIsRUFBd0I7QUFDcEIsZUFBTyxLQUFQO0FBQ0g7O0FBRUQ7QUFDQSxRQUFJLFNBQUo7QUFBQSxRQUFlLE9BQU8sQ0FBQyxNQUFNLEtBQU4sRUFBRCxDQUF0QjtBQUNBO0FBQ0k7QUFDSixLQUFDLFlBQVksR0FBRyxZQUFILENBQWdCLEtBQUssSUFBTCxDQUFVLEdBQVYsQ0FBaEIsSUFBa0MsS0FBL0M7QUFDQTtBQUNHLFVBQU0sTUFKVCxFQUtNO0FBQ0Y7QUFDQSxhQUFLLElBQUwsQ0FBVSxNQUFNLEtBQU4sRUFBVjtBQUNIOztBQUVELFFBQ0ksQ0FBQyxTQUFELENBQVc7QUFBWCxPQUNHLEtBQUssTUFBTCxHQUFjLENBRnJCLENBRXVCO0FBRnZCLE1BR0U7QUFDRSxrQkFBTSxPQUFOLENBQWMsS0FBSyxHQUFMLEVBQWQsRUFERixDQUM2QjtBQUM5Qjs7QUFFRCxXQUFPLENBQUMsS0FBSyxJQUFMLENBQVUsR0FBVixDQUFELENBQVA7O0FBRUEsUUFBSSxNQUFNLE1BQVYsRUFBa0I7QUFBRTtBQUNoQixlQUFPLEtBQUssTUFBTCxDQUFZLFVBQVUsRUFBVixFQUFjLE1BQWQsRUFBc0IsS0FBdEIsRUFBNkIsS0FBN0IsQ0FBWixDQUFQLENBRGMsQ0FDMkM7QUFDNUQ7O0FBRUQsV0FBTyxJQUFQO0FBQ0g7O0FBRUQsU0FBUyxhQUFULENBQXVCLE1BQXZCLEVBQStCLEVBQS9CLEVBQW1DLElBQW5DLEVBQXlDLENBQXpDLEVBQTRDLENBQTVDLEVBQStDLFNBQS9DLEVBQTBEO0FBQ3RELFFBQUksWUFBWSxHQUFHLFlBQUgsQ0FBZ0IsSUFBaEIsQ0FBaEI7O0FBRUEsWUFBUSxHQUFHLEtBQUgsQ0FBUyxTQUFqQjtBQUNJLGFBQUssUUFBTDtBQUNJLGlCQUFLLFlBQVksQ0FBakI7QUFDQTtBQUNKLGFBQUssT0FBTDtBQUNJLGlCQUFLLFNBQUw7QUFDQTtBQU5SOztBQVNBLFFBQUksS0FBSyxLQUFMLENBQVcsSUFBSSxHQUFmLElBQXNCLEdBQTFCOztBQUVBLE9BQUcsS0FBSCxDQUFTLFNBQVQsR0FBcUIsU0FBckI7QUFDQSxPQUFHLE1BQUgsQ0FBVSxJQUFJLENBQWQsRUFBaUIsQ0FBakI7QUFDQSxPQUFHLE1BQUgsQ0FBVSxJQUFJLFNBQUosR0FBZ0IsQ0FBMUIsRUFBNkIsQ0FBN0I7QUFDSDs7QUFFRCxTQUFTLFNBQVQsQ0FBbUIsTUFBbkIsRUFBMkIsRUFBM0IsRUFBK0IsSUFBL0IsRUFBcUMsQ0FBckMsRUFBd0MsQ0FBeEMsRUFBMkMsU0FBM0MsRUFBc0Q7QUFDbEQsUUFBSSxhQUFhLEdBQUcsYUFBSCxDQUFpQixPQUFPLElBQXhCLEVBQThCLE1BQS9DO0FBQUEsUUFDSSxZQUFZLEdBQUcsWUFBSCxDQUFnQixJQUFoQixDQURoQjs7QUFHQSxZQUFRLEdBQUcsS0FBSCxDQUFTLFNBQWpCO0FBQ0ksYUFBSyxRQUFMO0FBQ0ksaUJBQUssWUFBWSxDQUFqQjtBQUNBO0FBQ0osYUFBSyxPQUFMO0FBQ0ksaUJBQUssU0FBTDtBQUNBO0FBTlI7O0FBU0EsUUFBSSxLQUFLLEtBQUwsQ0FBVyxJQUFJLGFBQWEsQ0FBNUIsSUFBaUMsR0FBckM7O0FBRUE7QUFDQSxPQUFHLEtBQUgsQ0FBUyxTQUFULEdBQXFCLFNBQXJCO0FBQ0EsT0FBRyxNQUFILENBQVUsQ0FBVixFQUFhLENBQWI7QUFDQSxPQUFHLE1BQUgsQ0FBVSxJQUFJLFNBQWQsRUFBeUIsQ0FBekI7QUFDSDs7QUFFRCxTQUFTLFdBQVQsQ0FBcUIsRUFBckIsRUFBeUIsTUFBekIsRUFBaUMsQ0FBakMsRUFBb0MsQ0FBcEMsRUFBdUMsS0FBdkMsRUFBOEMsTUFBOUMsRUFBc0QsZUFBdEQsRUFBdUU7QUFDbkUsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQU8sTUFBM0IsRUFBbUMsR0FBbkMsRUFBd0M7QUFDcEMsWUFBSSxtQkFBbUIsQ0FBQyxDQUF4QixFQUEyQjtBQUN2QixlQUFHLFNBQUgsQ0FBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLEtBQW5CLEVBQTBCLE1BQTFCLEVBQWtDLE9BQU8sQ0FBUCxDQUFsQztBQUNILFNBRkQsTUFFTztBQUNILGVBQUcsS0FBSCxDQUFTLFNBQVQsR0FBcUIsT0FBTyxDQUFQLENBQXJCO0FBQ0EsZUFBRyxRQUFILENBQVksQ0FBWixFQUFlLENBQWYsRUFBa0IsS0FBbEIsRUFBeUIsTUFBekI7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsT0FBTyxPQUFQLEdBQWlCLFVBQWpCOzs7QUM1aUJBOztBQUVBLElBQUksZUFBZSxRQUFRLGdCQUFSLENBQW5COztBQUVBOzs7Ozs7QUFNQSxJQUFJLFNBQVMsYUFBYSxNQUFiLENBQW9CLFFBQXBCLEVBQThCO0FBQ3ZDLFdBQU8sZUFBUyxFQUFULEVBQWEsTUFBYixFQUFxQjtBQUN4QixZQUFJLElBQUksT0FBTyxNQUFQLENBQWMsQ0FBdEI7QUFBQSxZQUNJLElBQUksT0FBTyxNQUFQLENBQWMsQ0FEdEI7QUFBQSxZQUVJLFFBQVEsT0FBTyxNQUFQLENBQWMsS0FGMUI7QUFBQSxZQUdJLFNBQVMsT0FBTyxNQUFQLENBQWMsTUFIM0I7QUFJQSxXQUFHLEtBQUgsQ0FBUyxXQUFULEdBQXVCLE9BQXZCO0FBQ0EsWUFBSSxNQUFNLE9BQU8sS0FBakI7QUFDQSxZQUFJLFNBQVMsU0FBUyxDQUF0QjtBQUNBLFlBQUksU0FBUyxRQUFRLEdBQXJCO0FBQ0EsWUFBSSxVQUFVLE9BQU8sVUFBUCxHQUFvQixPQUFPLGVBQTNCLEdBQTZDLFNBQTNEO0FBQ0EsWUFBSSxjQUFjLEdBQUcsb0JBQUgsQ0FBd0IsQ0FBeEIsRUFBMkIsQ0FBM0IsRUFBOEIsQ0FBOUIsRUFBaUMsSUFBSSxNQUFyQyxDQUFsQjtBQUNBLG9CQUFZLFlBQVosQ0FBeUIsQ0FBekIsRUFBNEIsT0FBNUI7QUFDQSxvQkFBWSxZQUFaLENBQXlCLENBQXpCLEVBQTRCLFNBQTVCO0FBQ0EsWUFBSSxjQUFjLEdBQUcsb0JBQUgsQ0FBd0IsQ0FBeEIsRUFBMkIsQ0FBM0IsRUFBOEIsQ0FBOUIsRUFBaUMsSUFBSSxNQUFyQyxDQUFsQjtBQUNBLG9CQUFZLFlBQVosQ0FBeUIsQ0FBekIsRUFBNEIsU0FBNUI7QUFDQSxvQkFBWSxZQUFaLENBQXlCLENBQXpCLEVBQTRCLFNBQTVCO0FBQ0EsV0FBRyxLQUFILENBQVMsU0FBVCxHQUFxQixXQUFyQjtBQUNBLGFBQUssU0FBTCxDQUFlLEVBQWYsRUFBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsRUFBeUIsS0FBekIsRUFBZ0MsTUFBaEMsRUFBd0MsTUFBeEMsRUFBZ0QsV0FBaEQ7QUFDQSxZQUFJLE1BQU0sR0FBVixFQUFlO0FBQ1gsZUFBRyxLQUFILENBQVMsU0FBVCxHQUFxQixXQUFyQjtBQUNILFNBRkQsTUFFTztBQUNILGVBQUcsS0FBSCxDQUFTLFNBQVQsR0FBcUIsU0FBckI7QUFDSDtBQUNELFdBQUcsU0FBSDtBQUNBLFdBQUcsR0FBSCxDQUFPLElBQUksS0FBSyxHQUFMLENBQVMsU0FBUyxNQUFsQixFQUEwQixNQUExQixDQUFYLEVBQThDLElBQUksTUFBbEQsRUFBMEQsTUFBMUQsRUFBa0UsQ0FBbEUsRUFBcUUsSUFBSSxLQUFLLEVBQTlFO0FBQ0EsV0FBRyxJQUFIO0FBQ0EsV0FBRyxTQUFIO0FBQ0EsZUFBTyxRQUFQLEdBQWtCLEdBQWxCO0FBQ0g7QUE3QnNDLENBQTlCLENBQWI7O0FBZ0NBLE9BQU8sT0FBUCxHQUFpQixNQUFqQjs7O0FDMUNBOztBQUVBLElBQUksZUFBZSxRQUFRLGdCQUFSLENBQW5COztBQUVBOzs7OztBQUtBLElBQUksV0FBVyxhQUFhLE1BQWIsQ0FBb0IsVUFBcEIsRUFBZ0M7QUFDM0MsV0FBTyxlQUFTLEVBQVQsRUFBYSxNQUFiLEVBQXFCO0FBQ3hCLFlBQUksSUFBSSxPQUFPLE1BQVAsQ0FBYyxDQUF0QjtBQUFBLFlBQ0ksSUFBSSxPQUFPLE1BQVAsQ0FBYyxDQUR0QjtBQUFBLFlBRUksUUFBUSxPQUFPLE1BQVAsQ0FBYyxLQUYxQjtBQUFBLFlBR0ksU0FBUyxPQUFPLE1BQVAsQ0FBYyxNQUgzQjs7QUFLQSxXQUFHLFNBQUg7QUFDQSxZQUFJLE1BQU0sT0FBTyxLQUFqQjtBQUNBLFlBQUksQ0FBQyxHQUFELElBQVEsQ0FBQyxJQUFJLE1BQWpCLEVBQXlCO0FBQ3JCO0FBQ0g7QUFDRCxZQUFJLFFBQVEsSUFBSSxNQUFoQjtBQUNBLFlBQUksU0FBUyxRQUFRLEtBQXJCO0FBQ0EsWUFBSSxVQUFVLE9BQU8sVUFBUCxHQUFvQixPQUFPLHdCQUEzQixHQUFzRCxPQUFPLEtBQTNFO0FBQ0EsWUFBSSxPQUFPLGVBQVAsSUFBMEIsT0FBTyxVQUFyQyxFQUFpRDtBQUM3QyxlQUFHLEtBQUgsQ0FBUyxTQUFULEdBQXFCLE9BQU8sVUFBUCxHQUFvQixNQUFwQixHQUE2QixPQUFPLGVBQXpEO0FBQ0EsZUFBRyxRQUFILENBQVksQ0FBWixFQUFlLENBQWYsRUFBa0IsS0FBbEIsRUFBeUIsTUFBekI7QUFDSDtBQUNELFdBQUcsS0FBSCxDQUFTLFNBQVQsR0FBcUIsT0FBckI7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksSUFBSSxNQUF4QixFQUFnQyxHQUFoQyxFQUFxQztBQUNqQyxnQkFBSSxZQUFZLElBQUksQ0FBSixJQUFTLEdBQVQsR0FBZSxNQUEvQjtBQUNBLGVBQUcsUUFBSCxDQUFZLElBQUksQ0FBaEIsRUFBbUIsSUFBSSxNQUFKLEdBQWEsU0FBaEMsRUFBMkMsU0FBUyxNQUFwRCxFQUE0RCxTQUE1RDtBQUNBLGlCQUFLLE1BQUw7QUFDSDtBQUNELFdBQUcsU0FBSDtBQUNBLGVBQU8sUUFBUCxHQUFrQixRQUFRLEVBQTFCO0FBQ0g7QUEzQjBDLENBQWhDLENBQWY7O0FBOEJBLE9BQU8sT0FBUCxHQUFpQixRQUFqQjs7O0FDdkNBOztBQUVBLElBQUksZUFBZSxRQUFRLGdCQUFSLENBQW5COztBQUVBOzs7Ozs7QUFNQSxJQUFJLFlBQVksYUFBYSxNQUFiLENBQW9CLFdBQXBCLEVBQWlDO0FBQzdDLFdBQU8sZUFBUyxFQUFULEVBQWEsTUFBYixFQUFxQjtBQUN4QixZQUFJLElBQUksT0FBTyxNQUFQLENBQWMsQ0FBdEI7QUFBQSxZQUNJLElBQUksT0FBTyxNQUFQLENBQWMsQ0FEdEI7QUFBQSxZQUVJLFFBQVEsT0FBTyxNQUFQLENBQWMsS0FGMUI7QUFBQSxZQUdJLFNBQVMsT0FBTyxNQUFQLENBQWMsTUFIM0I7O0FBS0EsV0FBRyxTQUFIO0FBQ0EsWUFBSSxNQUFNLE9BQU8sS0FBakI7QUFDQSxZQUFJLENBQUMsR0FBRCxJQUFRLENBQUMsSUFBSSxNQUFqQixFQUF5QjtBQUNyQjtBQUNIO0FBQ0QsWUFBSSxRQUFRLElBQUksTUFBaEI7QUFDQSxZQUFJLFNBQVMsUUFBUSxLQUFyQjs7QUFFQSxZQUFJLFVBQVUsT0FBTyxVQUFQLEdBQW9CLE9BQU8sd0JBQTNCLEdBQXNELE9BQU8sS0FBM0U7QUFDQSxZQUFJLE9BQU8sZUFBUCxJQUEwQixPQUFPLFVBQXJDLEVBQWlEO0FBQzdDLGVBQUcsS0FBSCxDQUFTLFNBQVQsR0FBcUIsT0FBTyxVQUFQLEdBQW9CLE9BQU8sd0JBQTNCLEdBQXNELE9BQU8sZUFBbEY7QUFDQSxlQUFHLFFBQUgsQ0FBWSxDQUFaLEVBQWUsQ0FBZixFQUFrQixLQUFsQixFQUF5QixNQUF6QjtBQUNIO0FBQ0QsV0FBRyxLQUFILENBQVMsV0FBVCxHQUF1QixPQUF2QjtBQUNBLFdBQUcsS0FBSCxDQUFTLFNBQVQsR0FBcUIsT0FBckI7QUFDQSxXQUFHLFNBQUg7QUFDQSxZQUFJLElBQUo7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksSUFBSSxNQUF4QixFQUFnQyxHQUFoQyxFQUFxQztBQUNqQyxnQkFBSSxZQUFZLElBQUksQ0FBSixJQUFTLEdBQVQsR0FBZSxNQUEvQjtBQUNBLGdCQUFJLENBQUMsSUFBTCxFQUFXO0FBQ1AsdUJBQU8sU0FBUDtBQUNIO0FBQ0QsZUFBRyxNQUFILENBQVUsSUFBSSxDQUFkLEVBQWlCLElBQUksTUFBSixHQUFhLFNBQTlCO0FBQ0EsZUFBRyxHQUFILENBQU8sSUFBSSxDQUFYLEVBQWMsSUFBSSxNQUFKLEdBQWEsU0FBM0IsRUFBc0MsQ0FBdEMsRUFBeUMsQ0FBekMsRUFBNEMsSUFBSSxLQUFLLEVBQXJELEVBQXlELEtBQXpEO0FBQ0EsaUJBQUssTUFBTDtBQUNIO0FBQ0QsZUFBTyxRQUFQLEdBQWtCLFFBQVEsRUFBMUI7QUFDQSxXQUFHLE1BQUg7QUFDQSxXQUFHLFNBQUg7QUFDSDtBQXBDNEMsQ0FBakMsQ0FBaEI7O0FBdUNBLE9BQU8sT0FBUCxHQUFpQixTQUFqQjs7O0FDakRBOztBQUVBLElBQUksZUFBZSxRQUFRLGdCQUFSLENBQW5COztBQUVBOzs7OztBQUtBLElBQUksV0FBVyxhQUFhLE1BQWIsQ0FBb0IsVUFBcEIsRUFBZ0M7QUFDM0MsV0FBTyxlQUFTLEVBQVQsRUFBYSxNQUFiLEVBQXFCO0FBQ3hCLFlBQUksSUFBSSxPQUFPLE1BQVAsQ0FBYyxDQUF0QjtBQUFBLFlBQ0ksSUFBSSxPQUFPLE1BQVAsQ0FBYyxDQUR0QjtBQUFBLFlBRUksTUFBTSxPQUFPLEtBQVAsQ0FBYSxJQUZ2QjtBQUFBLFlBR0ksU0FBUyxPQUFPLEtBQVAsQ0FBYSxNQUgxQjtBQUFBLFlBSUksT0FBTyxPQUFPLEtBQVAsQ0FBYSxJQUp4Qjs7QUFNQTtBQUNBLFlBQUksT0FBTyxlQUFQLElBQTBCLE9BQU8sVUFBckMsRUFBaUQ7QUFDN0MsZUFBRyxLQUFILENBQVMsU0FBVCxHQUFxQixPQUFPLFVBQVAsR0FBb0IsT0FBTyxlQUEzQixHQUE2QyxPQUFPLGVBQXpFO0FBQ0EsZUFBRyxRQUFILENBQVksQ0FBWixFQUFlLENBQWYsRUFBa0IsT0FBTyxNQUFQLENBQWMsS0FBaEMsRUFBdUMsT0FBTyxNQUFQLENBQWMsTUFBckQ7QUFDSDs7QUFFRCxZQUFJLENBQUMsR0FBRCxJQUFRLENBQUMsSUFBSSxNQUFqQixFQUF5QjtBQUNyQjtBQUNIOztBQUVELFdBQUcsS0FBSCxDQUFTLFNBQVQsR0FBcUIsT0FBTyxVQUFQLEdBQW9CLE9BQU8sZUFBM0IsR0FBNkMsT0FBTyxlQUF6RTs7QUFFQSxZQUFJLGVBQWUsS0FBSyxJQUFMLENBQVUsT0FBTyxNQUFQLENBQWMsTUFBZCxHQUF1QixDQUFqQyxDQUFuQjtBQUNBLFdBQUcsVUFBSCxDQUFjLE9BQU8sR0FBckIsRUFBMEIsSUFBSSxNQUE5QixFQUFzQyxJQUFJLFlBQTFDOztBQUVBLGVBQU8sUUFBUCxHQUFrQixJQUFJLE1BQUosR0FBYSxHQUFHLFlBQUgsQ0FBZ0IsT0FBTyxHQUF2QixDQUFiLEdBQTJDLEVBQTdEO0FBQ0g7QUF4QjBDLENBQWhDLENBQWY7O0FBMkJBLE9BQU8sT0FBUCxHQUFpQixRQUFqQjs7O0FDcENBOztBQUVBLElBQUksV0FBVyxRQUFRLGlCQUFSLENBQWY7O0FBR0EsSUFBSSxlQUFKOztBQUVBOzs7O0FBSUEsSUFBSSxnQkFBZ0IsU0FBUyxNQUFULENBQWdCLGVBQWhCLEVBQWlDOztBQUVqRCxlQUFXLFFBQVEsZ0JBQVIsQ0FGc0MsRUFFWDs7QUFFdEMsZ0JBQVksc0JBQVc7QUFDbkI7QUFDQSxhQUFLLEdBQUwsQ0FBUyxRQUFRLFVBQVIsQ0FBVDtBQUNBLGFBQUssR0FBTCxDQUFTLFFBQVEsY0FBUixDQUFUO0FBQ0EsYUFBSyxHQUFMLENBQVMsUUFBUSxjQUFSLENBQVQ7QUFDQSxhQUFLLEdBQUwsQ0FBUyxRQUFRLFlBQVIsQ0FBVDtBQUNBLGFBQUssR0FBTCxDQUFTLFFBQVEsaUJBQVIsQ0FBVDtBQUNBLGFBQUssR0FBTCxDQUFTLFFBQVEsYUFBUixDQUFUO0FBQ0EsYUFBSyxHQUFMLENBQVMsUUFBUSxhQUFSLENBQVQ7QUFDQSxhQUFLLEdBQUwsQ0FBUyxRQUFRLFlBQVIsQ0FBVDtBQUNILEtBZGdEOztBQWdCakQ7QUFDQSxTQUFLLGFBQVMsSUFBVCxFQUFlLFdBQWYsRUFBNEI7QUFDN0Isc0JBQWMsU0FBUyxTQUFULENBQW1CLEdBQW5CLENBQXVCLElBQXZCLENBQTRCLElBQTVCLEVBQWtDLElBQWxDLEVBQXdDLFdBQXhDLENBQWQ7O0FBRUEsWUFBSSxXQUFKLEVBQWlCO0FBQ2IsaUJBQUssWUFBWSxZQUFaLEVBQUwsSUFBbUMsSUFBSSxXQUFKLEVBQW5DO0FBQ0g7QUFDSixLQXZCZ0Q7O0FBeUJqRCxTQUFLLGFBQVMsSUFBVCxFQUFlO0FBQ2hCLFlBQUksUUFBUSxLQUFLLFdBQUwsT0FBdUIsV0FBbkMsRUFBZ0Q7QUFDNUMsZ0JBQUksQ0FBQyxlQUFMLEVBQXNCO0FBQ2xCLHdCQUFRLElBQVIsQ0FBYSw2QkFBNkIsSUFBN0IsR0FBb0MsMklBQWpEO0FBQ0Esa0NBQWtCLElBQWxCO0FBQ0g7QUFDRCxpQkFBSyxTQUFMLENBQWUsV0FBZixHQUE2QixLQUFLLFNBQWxDO0FBQ0EsbUJBQU8sS0FBSyxTQUFaO0FBQ0g7QUFDRCxlQUFPLFNBQVMsU0FBVCxDQUFtQixHQUFuQixDQUF1QixJQUF2QixDQUE0QixJQUE1QixFQUFrQyxJQUFsQyxDQUFQO0FBQ0g7O0FBbkNnRCxDQUFqQyxDQUFwQjs7QUF1Q0EsT0FBTyxPQUFQLEdBQWlCLElBQUksYUFBSixFQUFqQjs7O0FDbERBOztBQUVBLElBQUksaUJBQWlCLFFBQVEsaUJBQVIsQ0FBckI7O0FBRUE7Ozs7Ozs7QUFPQSxJQUFJLGdCQUFnQixlQUFlLE1BQWYsQ0FBc0IsZUFBdEIsRUFBdUM7QUFDdkQsVUFBTSxRQURpRDs7QUFHdkQsWUFBUSxRQUgrQyxFQUdyQzs7QUFFbEIsZ0JBQVksb0JBQVMsY0FBVCxFQUF5QixPQUF6QixFQUFrQztBQUMxQyxhQUFLLElBQUwsR0FBWSxRQUFRLElBQXBCO0FBQ0gsS0FQc0Q7O0FBU3ZELGlCQUFhLHVCQUFXO0FBQ3BCLGVBQU8sS0FBSyxJQUFMLENBQVUsVUFBVixDQUFxQixhQUFyQixHQUFxQyxDQUFyQyxHQUF5QyxDQUFoRDtBQUNILEtBWHNEOztBQWF2RCxjQUFVLGtCQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDckIsWUFBSSxTQUFTLEtBQUssSUFBTCxDQUFVLFFBQVYsQ0FBbUIsU0FBbkIsQ0FBNkIsQ0FBN0IsQ0FBYjtBQUNBLGVBQU8sT0FBTyxNQUFQLElBQWlCLE9BQU8sSUFBL0IsQ0FGcUIsQ0FFZ0I7QUFDeEMsS0FoQnNEOztBQWtCdkQsY0FBVSxrQkFBUyxDQUFULEVBQVksQ0FBWixFQUFlLEtBQWYsRUFBc0I7QUFDNUIsWUFBSSxJQUFJLEtBQUssV0FBTCxFQUFSLEVBQTRCO0FBQ3hCLGlCQUFLLElBQUwsQ0FBVSxRQUFWLENBQW1CLFNBQW5CLENBQTZCLENBQTdCLEVBQWdDLE1BQWhDLEdBQXlDLEtBQXpDO0FBQ0g7QUFDSixLQXRCc0Q7O0FBd0J2RCxZQUFRLGdCQUFTLENBQVQsRUFBWTtBQUNoQixlQUFPLEtBQUssT0FBWjtBQUNIO0FBMUJzRCxDQUF2QyxDQUFwQjs7QUE2QkEsT0FBTyxPQUFQLEdBQWlCLGFBQWpCOzs7QUN4Q0E7O0FBRUEsSUFBSSxXQUFXLFFBQVEsaUJBQVIsQ0FBZjs7QUFFQTs7Ozs7QUFLQSxJQUFJLGFBQWEsU0FBUyxNQUFULENBQWdCLFlBQWhCLEVBQThCOztBQUUzQyxlQUFXLFFBQVEsaUJBQVIsQ0FGZ0M7O0FBSTNDLGdCQUFZLHNCQUFXO0FBQ25CO0FBQ0EsYUFBSyxHQUFMLENBQVMsUUFBUSxpQkFBUixDQUFUO0FBQ0g7O0FBUDBDLENBQTlCLENBQWpCOztBQVdBLE9BQU8sT0FBUCxHQUFpQixJQUFJLFVBQUosRUFBakI7OztBQ3BCQTs7OztBQUVBLElBQUksaUJBQWlCLFFBQVEsYUFBUixDQUFyQjs7QUFHQSxJQUFJLGdCQUFnQjtBQUNoQixXQUFTLENBRE87QUFFaEIsV0FBUyxDQUZPO0FBR2hCLFFBQU0sQ0FIVTtBQUloQixTQUFPO0FBSlMsQ0FBcEI7O0FBT0EsSUFBSSxxQkFBcUI7QUFDckIsV0FBUyxDQUFDLGNBQWMsT0FBZixFQUF3QixjQUFjLE9BQXRDLEVBQStDLGNBQWMsSUFBN0QsRUFBbUUsY0FBYyxLQUFqRixDQURZO0FBRXJCLFdBQVMsQ0FBQyxjQUFjLEtBQWY7QUFGWSxDQUF6Qjs7QUFNQTs7Ozs7O0FBTUEsSUFBSSxXQUFXOztBQUVYOzs7Ozs7QUFNQSxhQUFXLFNBUkE7O0FBVVg7Ozs7Ozs7QUFPQSxpQkFBZSxFQWpCSjs7QUFtQlg7Ozs7OztBQU1BLGNBQVksSUF6QkQ7O0FBMkJYOzs7Ozs7QUFNQSwwQkFBd0IsSUFqQ2I7O0FBbUNYOzs7Ozs7QUFNQSwwQkFBd0IsQ0F6Q2I7O0FBMkNYOzs7Ozs7O0FBT0EsWUFBVSxDQUNOLGVBRE0sRUFFTixNQUZNLENBbERDOztBQXVEWDs7Ozs7O0FBTUEsUUFBTSxrREE3REs7O0FBK0RYOzs7Ozs7QUFNQSxTQUFPLFNBckVJOztBQXVFWDs7Ozs7O0FBTUEsbUJBQWlCLFNBN0VOOztBQStFWDs7Ozs7O0FBTUEseUJBQXVCLFNBckZaOztBQXVGWDs7Ozs7O0FBTUEsMkJBQXlCLGtEQTdGZDs7QUErRlg7Ozs7OztBQU1BLDRCQUEwQixTQXJHZjtBQXNHWDs7Ozs7O0FBTUEsNEJBQTBCLFNBNUdmOztBQThHWDs7Ozs7O0FBTUEsa0NBQWdDLFNBcEhyQjs7QUFzSFg7Ozs7OztBQU1BLHNCQUFvQixXQTVIVDs7QUE4SFgsNEJBQTBCLElBOUhmOztBQWlJWDs7QUFFQTs7QUFFQTs7Ozs7QUFLQSxvQkFBa0IsdUJBMUlQOztBQTRJWDs7Ozs7O0FBTUEsd0JBQXNCLHVEQWxKWDs7QUFvSlg7Ozs7O0FBS0EscUJBQW1CLFNBekpSOztBQTJKWDs7Ozs7O0FBTUEsdUNBQXFDLHVCQWpLMUI7O0FBbUtYOzs7OztBQUtBLCtCQUE2QixrQkF4S2xCOztBQTBLWDs7Ozs7QUFLQSx3Q0FBc0MsU0EvSzNCOztBQWlMWDs7Ozs7QUFLQSx3Q0FBc0MsMEJBdEwzQjs7QUF3TFg7Ozs7OztBQU1BLHNCQUFvQixRQTlMVDs7QUFnTVg7Ozs7OztBQU1BLHlCQUF1QixFQXRNWjs7QUF3TVg7Ozs7O0FBS0Esd0JBQXNCLFlBN01YOztBQWdOWDs7QUFFQTs7Ozs7QUFLQSxpQkFBZSx1QkF2Tko7O0FBeU5YOzs7OztBQUtBLGtCQUFnQixTQTlOTDs7QUFnT1g7Ozs7O0FBS0EsNEJBQTBCLGtCQXJPZjs7QUF1T1g7Ozs7O0FBS0EscUNBQW1DLFNBNU94Qjs7QUE4T1g7Ozs7OztBQU1BLG9DQUFrQyx1QkFwUHZCOztBQXNQWDs7Ozs7QUFLQSxxQ0FBbUMsMEJBM1B4QjtBQTRQWDs7Ozs7QUFLQSxvQkFBa0Isb0JBalFQOztBQW9RWDs7QUFFQTs7Ozs7QUFLQSxrQkFBZ0IsaUNBM1FMOztBQTZRWDs7Ozs7QUFLQSxtQkFBaUIsaUJBbFJOOztBQW9SWDs7Ozs7QUFLQSw2QkFBMkIsb0JBelJoQjs7QUEyUlg7Ozs7O0FBS0Esc0NBQW9DLGlCQWhTekI7O0FBa1NYOzs7Ozs7QUFNQSxxQ0FBbUMsc0NBeFN4Qjs7QUEwU1g7Ozs7O0FBS0Esc0NBQW9DLDBCQS9TekI7QUFnVFg7O0FBRUE7Ozs7O0FBS0EsY0FBWSxpQ0F2VEQ7O0FBeVRYOzs7OztBQUtBLGVBQWEsaUJBOVRGOztBQWdVWDs7Ozs7QUFLQSx5QkFBdUIsT0FyVVo7O0FBdVVYOzs7OztBQUtBLGtDQUFnQyxpQkE1VXJCOztBQThVWDs7Ozs7QUFLQSxrQ0FBZ0MsbUJBblZyQjs7QUFxVlg7Ozs7O0FBS0EsZ0JBQWMsUUExVkg7O0FBNFZYOzs7OztBQUtBLGtCQUFnQixZQWpXTDs7QUFtV1g7Ozs7O0FBS0EsZ0JBQWMsV0F4V0g7O0FBMFdYOzs7OztBQUtBLGNBQVksSUEvV0Q7O0FBaVhYOzs7OztBQUtBLGlCQUFlLEtBdFhKOztBQXdYWDs7Ozs7QUFLQSxXQUFTLENBN1hFOztBQStYWDs7Ozs7QUFLQSxzQkFBb0IsU0FwWVQ7O0FBc1lYOzs7OztBQUtBLHFCQUFtQixRQTNZUjs7QUE2WVg7Ozs7O0FBS0Esb0JBQWtCLElBbFpQOztBQW9aWDs7Ozs7QUFLQSx5QkFBdUIsRUF6Wlo7O0FBMlpYOzs7OztBQUtBLHlCQUF1QixFQWhhWjs7QUFrYVg7Ozs7OztBQU1BLDJCQUF5QixDQUFDLENBeGFmOztBQTBhWDs7Ozs7O0FBTUEsVUFBUSxNQWhiRzs7QUFrYlg7Ozs7Ozs7Ozs7QUFVQSxlQUFhLENBNWJGOztBQThiWCxvQkFBa0IsQ0E5YlA7O0FBZ2NYLG1CQUFpQixDQWhjTjs7QUFrY1g7Ozs7Ozs7Ozs7Ozs7QUFhQSxlQUFhLENBL2NGOztBQWlkWDs7Ozs7Ozs7Ozs7QUFXQSxZQUFVLFNBNWRDOztBQThkWDs7Ozs7Ozs7Ozs7QUFXQSxjQUFZLFNBemVEOztBQTJlWDs7Ozs7Ozs7Ozs7QUFXQSxhQUFXLFNBdGZBOztBQXdmWDs7O0FBR0Esc0JBQW9CLEtBM2ZUOztBQTZmWDs7Ozs7O0FBTUEsZUFBYSxJQW5nQkY7O0FBcWdCWDs7Ozs7Ozs7Ozs7Ozs7QUFjQSxhQUFXLFVBbmhCQTs7QUFxaEJYOzs7OztBQUtBLGNBQVksSUExaEJEOztBQTRoQlg7Ozs7O0FBS0EsY0FBWSxJQWppQkQ7O0FBbWlCWDs7Ozs7QUFLQSxrQkFBZ0IsQ0F4aUJMOztBQTBpQlg7Ozs7QUFJQSxrQkFBZ0IsU0E5aUJMOztBQWdqQlg7Ozs7O0FBS0Esd0JBQXNCLFNBcmpCWDs7QUF1akJYOzs7Ozs7Ozs7Ozs7QUFZQSxjQUFZLElBbmtCRDs7QUFxa0JYOzs7Ozs7OztBQVFBLGtCQUFnQixJQTdrQkw7O0FBK2tCWDs7Ozs7Ozs7QUFRQSxtQkFBaUIsSUF2bEJOOztBQXlsQlg7Ozs7Ozs7O0FBUUEsaUJBQWUsS0FqbUJKOztBQW1tQlg7Ozs7Ozs7O0FBUUEsb0JBQWtCLElBM21CUDs7QUE2bUJYOzs7Ozs7QUFNQSxvQkFBa0IsQ0FubkJQOztBQXFuQlg7Ozs7OztBQU1BLG1CQUFpQixTQTNuQk4sRUEybkJpQjs7QUFFNUI7Ozs7OztBQU1BLG9CQUFrQixrQkFub0JQLEVBbW9CMkI7O0FBRXRDOzs7Ozs7QUFNQSxvQkFBa0IsQ0Ezb0JQOztBQTZvQlg7Ozs7OztBQU1BLG1CQUFpQixTQW5wQk4sRUFtcEJpQjs7QUFFNUI7Ozs7OztBQU1BLG9CQUFrQixrQkEzcEJQLEVBMnBCMkI7O0FBRXRDOzs7OztBQUtBLG9CQUFrQixFQWxxQlA7O0FBb3FCWDs7Ozs7O0FBTUEsMEJBQXdCLEVBMXFCYjs7QUE0cUJYOzs7OztBQUtBLHNCQUFvQixHQWpyQlQ7O0FBbXJCWDs7Ozs7QUFLQSxzQkFBb0IsRUF4ckJUOztBQTByQlg7Ozs7OztBQU1BLHNCQUFvQixHQWhzQlQ7O0FBa3NCWDs7OztBQUlBLG1CQUFpQixFQXRzQk47O0FBd3NCWDs7QUFFQTs7Ozs7QUFLQSx1QkFBcUIsRUEvc0JWOztBQWl0Qlg7Ozs7O0FBS0Esc0JBQW9CLEtBdHRCVDs7QUF3dEJYOztBQUVBOzs7OztBQUtBLGNBQVksS0EvdEJEOztBQWt1Qlg7Ozs7O0FBS0EsWUFBVSxJQXZ1QkM7O0FBeXVCWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyREEsYUFBVztBQUNQLFlBQVEsTUFERDtBQUVQLGlCQUFhLElBRk47QUFHUCxTQUFLLE9BSEU7QUFJUCxjQUFVO0FBSkgsR0FweUJBOztBQTJ5Qlg7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkEsaUJBQWUsQ0FqMEJKOztBQW0wQlg7Ozs7O0FBS0Esa0JBQWdCLFFBeDBCTDs7QUEwMEJYOzs7OztBQUtBLFlBQVUsS0EvMEJDOztBQWkxQlg7Ozs7O0FBS0Esb0JBQWtCLENBdDFCUDs7QUF3MUJYOzs7OztBQUtBLGlCQUFlLENBNzFCSjs7QUErMUJYOzs7OztBQUtBLG1CQUFpQixRQXAyQk47O0FBczJCWDs7Ozs7O0FBTUEsb0JBQWtCLElBNTJCUDs7QUE4MkJYOzs7Ozs7QUFNQSx1QkFBcUIsS0FwM0JWOztBQXMzQlg7Ozs7O0FBS0EsZ0NBQThCLENBMzNCbkI7O0FBNjNCWDs7Ozs7QUFLQSxrQkFBZ0IsSUFsNEJMOztBQW80Qlg7Ozs7O0FBS0EsZ0JBQWMsWUF6NEJIOztBQTI0Qlg7Ozs7O0FBS0EsaUJBQWUsSUFoNUJKOztBQWs1Qlg7Ozs7O0FBS0EsaUJBQWUsSUF2NUJKOztBQXk1Qlg7Ozs7O0FBS0EsbUJBQWlCLElBOTVCTjs7QUFnNkJYOzs7OztBQUtBLGdCQUFjLElBcjZCSDs7QUF1NkJYOzs7Ozs7QUFNQSxxQ0FBbUMsSUE3NkJ4Qjs7QUErNkJYOzs7Ozs7QUFNQSwwQ0FBd0MsSUFyN0I3Qjs7QUF1N0JYOzs7OztBQUtBLDBCQUF3QixLQTU3QmI7O0FBODdCWDs7Ozs7OztBQU9BLCtCQUE2QixzQkFyOEJsQixFQXE4QjBDOztBQUVyRDs7Ozs7O0FBTUEsK0JBQTZCLFNBNzhCbEI7O0FBKzhCWDs7Ozs7O0FBTUEsOEJBQTRCLENBcjlCakI7O0FBdTlCWDs7Ozs7QUFLQSxvQkFBa0IsSUE1OUJQOztBQTg5Qlg7Ozs7O0FBS0EsdUJBQXFCLElBbitCVjs7QUFxK0JYOzs7OztBQUtBLHNCQUFvQixLQTErQlQ7O0FBNCtCWDs7Ozs7QUFLQSxhQUFXLEtBai9CQTs7QUFvL0JYOztBQUVBOzs7OztBQUtBLFlBQVUsS0EzL0JDOztBQTYvQlg7Ozs7Ozs7QUFPQSxxQkFBbUIsSUFwZ0NSOztBQXNnQ1g7Ozs7Ozs7Ozs7Ozs7O0FBY0EsaUJBQWUsSUFwaENKOztBQXNoQ1g7Ozs7Ozs7Ozs7O0FBV0Esa0JBQWdCLEtBamlDTDs7QUFvaUNYOztBQUVBOzs7Ozs7OztBQVFBLGNBQVksS0E5aUNEOztBQWdqQ1g7Ozs7Ozs7Ozs7QUFVQSxxQkFBbUIsSUExakNSOztBQTRqQ1g7Ozs7Ozs7OztBQVNBLGtCQUFnQixDQXJrQ0w7O0FBdWtDWDs7Ozs7Ozs7OztBQVVBLHVCQUFxQixJQWpsQ1Y7O0FBb2xDWDs7Ozs7OztBQU9BLHFCQUFtQixLQTNsQ1I7O0FBNmxDWDs7Ozs7Ozs7Ozs7O0FBWUEsa0JBQWdCLEtBem1DTDs7QUEybUNYOzs7Ozs7O0FBT0EscUJBQW1CLEtBbG5DUjs7QUFvbkNYOzs7Ozs7OztBQVFBLFVBQVEsU0E1bkNHOztBQThuQ1g7Ozs7Ozs7QUFPQSxVQUFRLFdBcm9DRzs7QUF1b0NYOzs7Ozs7QUFNQSxZQUFVLFlBN29DQzs7QUErb0NYOzs7Ozs7OztBQVFBLGdCQUFjLHFCQXZwQ0g7O0FBeXBDWDs7QUFFQTs7Ozs7O0FBTUE7Ozs7O0FBS0Esc0JBQW9CO0FBQ2hCLGFBQVMsSUFETztBQUVoQixxQkFBaUI7QUFGRCxHQXRxQ1Q7O0FBMnFDWDs7Ozs7QUFLQSxxQkFBbUI7QUFDZixhQUFTLEtBRE07QUFFZixxQkFBaUI7O0FBRkYsR0FockNSOztBQXNyQ1g7Ozs7O0FBS0Esd0JBQXNCO0FBQ2xCLGFBQVMsS0FEUztBQUVsQixxQkFBaUI7QUFGQyxHQTNyQ1g7O0FBZ3NDWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkJBLFFBQU0sS0EzdENLOztBQTZ0Q1g7Ozs7Ozs7OztBQVNBLGNBQVksUUF0dUNEOztBQXd1Q1g7Ozs7O0FBS0EsZUFBYSxLQTd1Q0Y7O0FBK3VDWDs7Ozs7O0FBTUEsYUFBVyxTQXJ2Q0E7O0FBdXZDWDs7Ozs7O0FBTUEsb0JBQWtCLFNBN3ZDUDs7QUErdkNYOzs7OztBQUtBLG9CQUFrQixLQXB3Q1A7O0FBc3dDWDs7Ozs7QUFLQSxpQkFBZSxLQTN3Q0o7O0FBNndDWDs7Ozs7QUFLQSxzQkFBb0IsSUFseENUOztBQW94Q1g7Ozs7Ozs7OztBQVNBLDJCQUF5QixLQTd4Q2Q7O0FBK3hDWDs7Ozs7Ozs7QUFRQSxzQkFBb0IsSUF2eUNUOztBQXl5Q1g7OztBQUdBLG1CQUFpQixJQTV5Q047O0FBOHlDWDs7Ozs7QUFLQSxvQkFBa0IsQ0FuekNQOztBQXF6Q1g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkEsY0FBWSxLQXgwQ0Q7O0FBMDBDWDs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSxjQUFZLFNBMTFDRDs7QUE0MUNYO0FBQ0EsbUJBQWlCLG1CQUFtQixPQTcxQ3pCOztBQSsxQ1g7OztBQUdBLFlBQVUsQ0FDTixTQURNLEVBRU4sYUFGTTtBQUdOO0FBQ0E7QUFDQSxpQkFMTSxFQU1OLFdBTk0sRUFPTixnQkFQTTtBQVFOO0FBQ0EsZ0JBVE0sRUFVTixpQkFWTSxFQVdOLGNBWE0sRUFZTixlQVpNLEVBYU4sV0FiTSxFQWNOLGFBZE0sRUFlTixTQWZNLEVBZ0JOLGFBaEJNLEVBaUJOLGdCQWpCTSxDQWwyQ0M7O0FBczNDWDs7Ozs7Ozs7OztBQVVBLDRCQUEwQixJQWg0Q2Y7O0FBazRDWDs7Ozs7O0FBTUEsaUJBQWUsS0F4NENKOztBQTA0Q1g7Ozs7Ozs7OztBQVNBLG1CQUFpQixDQUNiO0FBQ0ksVUFBTSx3QkFEVjtBQUVJLFlBQVEsZ0JBQVMsVUFBVCxFQUFxQixTQUFyQixFQUFnQztBQUNwQyxjQUFRLEdBQVIsQ0FBWSxtQ0FBWixFQUFpRCxTQUFqRDtBQUNIO0FBSkwsR0FEYSxFQU9iO0FBQ0ksVUFBTSwyQkFEVjtBQUVJLFlBQVEsZ0JBQVMsVUFBVCxFQUFxQixTQUFyQixFQUFnQztBQUNwQyxjQUFRLEdBQVIsQ0FBWSxzQ0FBWixFQUFvRCxTQUFwRDtBQUNIO0FBSkwsR0FQYSxFQWFiO0FBQ0ksVUFBTSxNQURWO0FBRUksWUFBUSxnQkFBUyxVQUFULEVBQXFCLFNBQXJCLEVBQWdDO0FBQ3BDLGdCQUFVLElBQVYsQ0FBZSxHQUFmLENBQW1CLDRCQUFuQixDQUFnRCxLQUFoRDtBQUNIO0FBSkwsR0FiYSxFQW1CYjtBQUNJLFVBQU0sbUJBRFY7QUFFSSxZQUFRLGdCQUFTLFVBQVQsRUFBcUIsU0FBckIsRUFBZ0M7QUFDcEMsZ0JBQVUsSUFBVixDQUFlLEdBQWYsQ0FBbUIsNEJBQW5CLENBQWdELElBQWhEO0FBQ0g7QUFKTCxHQW5CYSxDQW41Q047O0FBODZDWDs7Ozs7Ozs7O0FBU0EscUJBQW1CLENBQ2Y7QUFDSSxVQUFNLFFBRFY7QUFFSSxZQUFRLGdCQUFTLFVBQVQsRUFBcUIsU0FBckIsRUFBZ0M7QUFDcEMsY0FBUSxHQUFSLENBQVksaUJBQVosRUFBK0IsVUFBL0IsRUFBMkMsU0FBM0M7QUFDQSxnQkFBVSxJQUFWLENBQWUsZ0JBQWYsQ0FBZ0MsU0FBaEM7QUFDSDtBQUxMLEdBRGUsRUFRZjtBQUNJLFVBQU0sUUFEVjtBQUVJLFlBQVEsZ0JBQVMsVUFBVCxFQUFxQixTQUFyQixFQUFnQztBQUNwQyxjQUFRLEdBQVIsQ0FBWSxpQkFBWixFQUErQixVQUEvQixFQUEyQyxTQUEzQztBQUNBLFVBQU0sT0FBTyxVQUFVLElBQXZCO0FBQ0EsVUFBTSxTQUFTLEtBQUssVUFBcEI7QUFDQSxVQUFNLFNBQVMsVUFBVSxNQUF6Qjs7QUFFQTtBQUNBLFdBQUssVUFBTCxDQUFnQixPQUFPLElBQXZCLEVBQTZCLE9BQTdCLENBQXFDLHdCQUFnQjtBQUNqRCxlQUFPLE1BQVAsQ0FBYyxPQUFPLE9BQVAsQ0FBZSxZQUFmLENBQWQsRUFBNEMsQ0FBNUM7QUFDSCxPQUZEOztBQUlBLFdBQUssR0FBTCxDQUFTLGFBQVQsQ0FBdUIsTUFBdkI7QUFDSDtBQWRMLEdBUmUsQ0F2N0NSOztBQWk5Q1g7Ozs7OztBQU1BLHVCQUFxQixJQXY5Q1Y7O0FBeTlDWDs7Ozs7Ozs7QUFRQSwyQkFBeUIsSUFqK0NkOztBQW0rQ1g7Ozs7OztBQU1BLDBCQUF3QjtBQUNwQixjQUFVLE9BRFU7QUFFcEIsWUFBUSxNQUZZO0FBR3BCLGNBQVUsTUFIVTtBQUlwQixZQUFRLENBSlk7QUFLcEIsWUFBUSxTQUxZO0FBTXBCLGdCQUFZLDZDQU5RO0FBT3BCLFdBQU8sTUFQYTtBQVFwQixZQUFRLE1BUlk7QUFTcEIsbUJBQWU7QUFUSyxHQXorQ2I7O0FBcS9DWDs7Ozs7O0FBTUEsd0JBQXNCO0FBQ2xCLGFBQVMsT0FEUztBQUVsQixlQUFXLE9BRk87QUFHbEIsY0FBVSxPQUhRO0FBSWxCLGNBQVUsUUFKUTtBQUtsQixZQUFRLGdCQUxVO0FBTWxCLHFCQUFpQixNQU5DO0FBT2xCLGFBQVMsTUFQUztBQVFsQixtQkFBZSxRQVJHO0FBU2xCLGVBQVcsTUFUTztBQVVsQixvQkFBZ0IsVUFWRTtBQVdsQixjQUFVO0FBWFEsR0EzL0NYOztBQXlnRFg7Ozs7OztBQU1BLDhCQUE0QjtBQUN4QixZQUFRLE1BRGdCO0FBRXhCLGNBQVUsTUFGYztBQUd4QixZQUFRLFNBSGdCO0FBSXhCLGFBQVMsTUFKZTtBQUt4QixnQkFBWSxRQUxZO0FBTXhCLHFCQUFpQjtBQU5PLEdBL2dEakI7O0FBd2hEWDs7Ozs7O0FBTUEsbUNBQWlDO0FBQzdCLHFCQUFpQjtBQURZLEdBOWhEdEI7O0FBa2lEWDs7Ozs7O0FBTUEsa0NBQWdDO0FBQzVCLFdBQU8sTUFEcUI7QUFFNUIsYUFBUyxTQUZtQjtBQUc1QixtQkFBZTtBQUhhLEdBeGlEckI7O0FBOGlEWDs7Ozs7O0FBTUEsa0NBQWdDO0FBQzVCLGFBQVMsU0FEbUI7QUFFNUIsbUJBQWUsUUFGYTtBQUc1QixjQUFVO0FBSGtCLEdBcGpEckI7O0FBMGpEWDs7Ozs7O0FBTUEsc0NBQW9DO0FBQ2hDLGFBQVMsa0JBRHVCO0FBRWhDLG1CQUFlLFFBRmlCO0FBR2hDLFdBQU87QUFIeUIsR0Foa0R6Qjs7QUFza0RYOzs7Ozs7QUFNQSwwQ0FBd0M7QUFDcEMsYUFBUyxTQUQyQjtBQUVwQyxtQkFBZSxRQUZxQjtBQUdwQyxXQUFPO0FBSDZCLEdBNWtEN0I7O0FBa2xEWDs7Ozs7O0FBTUEsNkJBQTJCO0FBQ3ZCLGFBQVMsT0FEYztBQUV2QixlQUFXLG1CQUZZO0FBR3ZCLFlBQVE7QUFIZSxHQXhsRGhCOztBQThsRFg7Ozs7Ozs7O0FBUUEsb0NBQWtDLG1DQXRtRHZCOztBQXdtRFg7Ozs7OztBQU1BLDRDQUEwQyxTQTltRC9COztBQWduRFg7Ozs7OztBQU1BLDJDQUF5QyxTQXRuRDlCOztBQXduRFg7Ozs7OztBQU1BLDRDQUEwQyxTQTluRC9COztBQWdvRFg7Ozs7OztBQU1BLDBDQUF3QyxTQXRvRDdCOztBQXdvRFg7Ozs7OztBQU1BLHdDQUFzQyxTQTlvRDNCOztBQWdwRFg7Ozs7OztBQU1BLHNDQUFvQyxTQXRwRHpCOztBQXdwRFg7Ozs7OztBQU1BLHlDQUF1QyxTQTlwRDVCOztBQWdxRFg7Ozs7OztBQU1BLHdDQUFzQyxTQXRxRDNCOztBQXdxRFg7Ozs7OztBQU1BLHlDQUF1QyxTQTlxRDVCOztBQWdyRFg7Ozs7OztBQU1BLHVDQUFxQyxTQXRyRDFCOztBQXdyRFg7Ozs7OztBQU1BLHFDQUFtQyxTQTlyRHhCOztBQWdzRFg7Ozs7OztBQU1BLG1DQUFpQyxTQXRzRHRCOztBQXdzRFg7Ozs7OztBQU1BLG1CQUFpQjtBQUNiLFdBQU8sRUFETTtBQUViLGdCQUFZLFNBRkM7QUFHYixlQUFXLG9DQUhFO0FBSWIsZUFBVyxDQUpFO0FBS2Isa0JBQWMsQ0FMRDtBQU1iLGlCQUFhLENBQUMsQ0FORDtBQU9iLGtCQUFjLENBUEQ7QUFRYixpQkFBYSxPQVJBO0FBU2IsaUJBQWEsU0FUQTtBQVViLGlCQUFhO0FBVkEsR0E5c0ROOztBQTJ0RFg7Ozs7OztBQU1BLG1CQUFpQjtBQUNiLFlBQVEsRUFESztBQUViLFlBQVEsbUJBRks7QUFHYixnQkFBWSxTQUhDO0FBSWIsZUFBVyxvQ0FKRTtBQUtiLGdCQUFZLENBTEM7QUFNYixpQkFBYSxDQU5BO0FBT2Isa0JBQWMsQ0FBQyxDQVBGO0FBUWIsa0JBQWM7QUFSRCxHQWp1RE47O0FBNHVEWDs7Ozs7O0FBTUEsd0JBQXNCO0FBQ2xCLFlBQVEsQ0FEVTtBQUVsQixXQUFPLENBRlc7QUFHbEIsV0FBTyxDQUhXO0FBSWxCLHFCQUFpQixTQUpDO0FBS2xCLGVBQVcsbUJBTE87QUFNbEIsY0FBVSxVQU5RO0FBT2xCLGtCQUFjO0FBUEksR0FsdkRYOztBQTR2RFg7Ozs7OztBQU1BLHdCQUFzQjtBQUNsQixZQUFRLENBRFU7QUFFbEIsWUFBUSxDQUZVO0FBR2xCLFlBQVEsQ0FIVTtBQUlsQixxQkFBaUIsU0FKQztBQUtsQixlQUFXLG1CQUxPO0FBTWxCLGtCQUFjO0FBTkksR0Fsd0RYOztBQTJ3RFg7Ozs7OztBQU1BLHdCQUFzQjtBQUNsQixjQUFVLFVBRFE7QUFFbEIsZ0JBQVksU0FGTTtBQUdsQixZQUFRO0FBSFUsR0FqeERYOztBQXV4RFg7Ozs7OztBQU1BLHdCQUFzQjtBQUNsQixjQUFVLFVBRFE7QUFFbEIsZ0JBQVksU0FGTTtBQUdsQixZQUFRLG1CQUhVO0FBSWxCLG9CQUFnQjtBQUpFLEdBN3hEWDs7QUFveURYOzs7Ozs7QUFNQSxvQkFBa0I7QUFDZCxZQUFRLFNBRE07QUFFZCxhQUFTLE1BRks7QUFHZCxjQUFVLFFBSEk7QUFJZCxjQUFVLFVBSkk7QUFLZCxnQkFBWSxTQUxFO0FBTWQsZUFBVyx1REFORztBQU9kLGtCQUFjLEtBUEE7QUFRZCxhQUFTLFNBUks7QUFTZCxZQUFRLElBVE07QUFVZCxjQUFVLE1BVkk7QUFXZCxvQkFBZ0I7QUFYRixHQTF5RFA7O0FBd3pEWDs7Ozs7O0FBTUEsMkJBQXlCO0FBQ3JCLGVBQVc7QUFEVSxHQTl6RGQ7O0FBazBEWDs7Ozs7OztBQU9BLDhCQUE0QixFQXowRGpCOztBQTIwRFg7Ozs7OztBQU1BLDBCQUF3QixJQWoxRGI7O0FBbTFEWDs7Ozs7O0FBTUEsMEJBQXdCO0FBQ3BCLFdBQU8sU0FEYTtBQUVwQixvQkFBZ0IsTUFGSTtBQUdwQixnQkFBWSxNQUhRO0FBSXBCLGdCQUFZO0FBSlEsR0F6MURiOztBQWcyRFg7Ozs7OztBQU1BLHFCQUFtQixFQXQyRFI7O0FBdzJEWDs7Ozs7O0FBTUEsc0JBQW9CLEVBOTJEVDs7QUFnM0RYOzs7Ozs7O0FBT0EsMkJBQXlCLEtBdjNEZDs7QUF5M0RYOzs7Ozs7O0FBT0EsdUJBQXFCLHdDQWg0RFY7O0FBazREWDs7Ozs7OztBQU9BLDRCQUEwQixLQXo0RGY7O0FBMjREWDs7Ozs7O0FBTUEsd0JBQXNCLFNBajVEWDs7QUFtNURYOzs7Ozs7QUFNQSwrQkFBNkIsU0F6NURsQjs7QUEyNURYOzs7Ozs7QUFNQSxnQ0FBOEIsU0FqNkRuQjs7QUFtNkRYOzs7Ozs7QUFNQSw4QkFBNEIsU0F6NkRqQjs7QUEyNkRYOzs7Ozs7QUFNQSxxQ0FBbUMsU0FqN0R4Qjs7QUFtN0RYOzs7Ozs7O0FBT0EsOEJBQTRCLFVBQVUsUUFBVixDQTE3RGpCOztBQTQ3RFg7Ozs7Ozs7QUFPQSx3QkFBc0IsVUFBVSxRQUFWLENBbjhEWDs7QUFxOERYOzs7Ozs7QUFNQSw4QkFBNEIsRUEzOERqQjs7QUE2OERYOzs7Ozs7QUFNQSw2QkFBMkIsRUFuOURoQjs7QUFxOURYOzs7Ozs7O0FBT0EsaUJBQWUsa0JBNTlESjs7QUE4OURYOzs7Ozs7QUFNQSxrQkFBZ0IsU0FwK0RMOztBQXMrRFg7Ozs7Ozs7QUFPQSxzQ0FBb0MsQ0E3K0R6Qjs7QUErK0RYOzs7Ozs7QUFNQSxnQ0FBOEIsQ0FyL0RuQjs7QUF1L0RYOzs7Ozs7QUFNQSwyQkFBeUIsRUE3L0RkOztBQSsvRFg7Ozs7OztBQU1BLDRCQUEwQixDQXJnRWY7O0FBdWdFWDs7Ozs7O0FBTUEsaUNBQStCLENBN2dFcEI7O0FBK2dFWDs7Ozs7O0FBTUEsc0JBQW9CLHNEQXJoRVQ7O0FBdWhFWDs7Ozs7O0FBTUEsdUJBQXFCLFNBN2hFVjs7QUEraEVYOzs7Ozs7QUFNQSx5QkFBdUIsc0RBcmlFWjs7QUF1aUVYOzs7Ozs7QUFNQSwwQkFBd0IsU0E3aUViOztBQStpRVg7Ozs7OztBQU1BLCtCQUE2QixDQXJqRWxCOztBQXVqRVg7Ozs7OztBQU1BLHFCQUFtQixzREE3akVSOztBQStqRVg7Ozs7OztBQU1BLDBCQUF3QixPQXJrRWI7O0FBdWtFWDs7Ozs7O0FBTUEsMEJBQXdCLFNBN2tFYjs7QUEra0VYOzs7Ozs7QUFNQSw2QkFBMkIsNERBcmxFaEI7O0FBdWxFWDs7Ozs7O0FBTUEsNEJBQTBCLDJEQTdsRWY7O0FBK2xFWDs7Ozs7O0FBTUEsNEJBQTBCLGVBcm1FZjs7QUF1bUVYOzs7Ozs7QUFNQSw0QkFBMEIsZUE3bUVmOztBQSttRVg7Ozs7OztBQU1BLHlCQUF1QixHQXJuRVo7O0FBdW5FWDs7Ozs7QUFLQSw2QkFBMkIsU0E1bkVoQjs7QUE4bkVYOzs7OztBQUtBLDZCQUEyQixDQW5vRWhCOztBQXFvRVg7Ozs7OztBQU1BLHlCQUF1QixTQTNvRVo7O0FBNm9FWDs7Ozs7O0FBTUEsd0JBQXNCLGtEQW5wRVg7O0FBcXBFWDs7Ozs7O0FBTUEsOEJBQTRCLENBM3BFakI7O0FBNnBFWDs7Ozs7OztBQU9BLGtDQUFnQyx3Q0FwcUVyQjs7QUFzcUVYOzs7Ozs7QUFNQSxtQ0FBaUMsU0E1cUV0Qjs7QUE4cUVYOzs7Ozs7QUFNQSwwQ0FBd0MsVUFBVSxRQUFWLENBcHJFN0I7O0FBc3JFWDs7Ozs7O0FBTUEsMkNBQXlDLFVBQVUsUUFBVixDQTVyRTlCOztBQThyRVg7Ozs7Ozs7QUFPQSxtQ0FBaUMsRUFyc0V0Qjs7QUF1c0VYOzs7Ozs7O0FBT0EsNENBQTBDLEVBOXNFL0I7O0FBZ3RFWDs7Ozs7O0FBTUEsNEJBQTBCLHVEQXR0RWY7O0FBd3RFWDs7Ozs7O0FBTUEscUJBQW1CLEtBOXRFUjs7QUFndUVYOzs7Ozs7QUFNQSxzQkFBb0IsS0F0dUVUOztBQXd1RVg7OztBQUdBLHVCQUFxQixHQTN1RVY7O0FBNnVFWDs7O0FBR0EsaUJBQWUsU0FodkVKOztBQWt2RVg7OztBQUdBLGlCQUFlLEVBcnZFSjs7QUF1dkVYOzs7QUFHQSxrQkFBZ0IsU0ExdkVMOztBQTR2RVg7OztBQUdBLFdBQVM7QUEvdkVFLENBQWY7O0FBbXdFQSxJQUFJLFNBQVMsRUFBYjs7QUFFQSxTQUFTLCtCQUFULEdBQTJDO0FBQ3ZDLE1BQUksQ0FBQyxPQUFPLGFBQVosRUFBMkI7QUFDdkIsV0FBTyxhQUFQLEdBQXVCLElBQXZCO0FBQ0EsWUFBUSxJQUFSLENBQWEsZ0lBQWI7QUFDSDtBQUNKOztBQUVELE9BQU8sZ0JBQVAsQ0FBd0IsUUFBeEIsRUFBa0M7QUFDOUIsaUJBQWU7QUFDWCxTQUFLLGVBQVc7QUFDWjtBQUNBLGFBQU8sS0FBSyxVQUFaO0FBQ0gsS0FKVTtBQUtYLFNBQUssYUFBUyxhQUFULEVBQXdCO0FBQ3pCO0FBQ0EsV0FBSyxVQUFMLEdBQWtCLGFBQWxCO0FBQ0g7QUFSVTtBQURlLENBQWxDOztBQWFBLFNBQVMsZUFBVCxHQUEyQjtBQUN2QixRQUFNLElBQUksY0FBSixDQUFtQiw0RUFBbkIsQ0FBTjtBQUNIOztBQUVELENBQUMsTUFBRCxFQUFTLE1BQVQsRUFBaUIsUUFBakIsRUFBMkIsWUFBM0IsRUFBeUMsT0FBekMsQ0FBaUQsVUFBUyxHQUFULEVBQWM7QUFDM0QsU0FBTyxjQUFQLENBQXNCLFFBQXRCLEVBQWdDLEdBQWhDLEVBQXFDO0FBQ2pDLFNBQUs7QUFENEIsR0FBckM7QUFHSCxDQUpEOztBQU1BOzs7O0FBSUE7Ozs7QUFLQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsU0FBUyxNQUFULENBQWdCLE9BQWhCLEVBQXlCLE9BQXpCLEVBQWtDO0FBQzlCLE1BQUksTUFBSjtBQUNBLE1BQUksUUFBUSxNQUFSLEdBQWlCLENBQWpCLElBQXNCLENBQUMsS0FBSyxhQUE1QixJQUE2QyxPQUFqRCxFQUEwRDtBQUN0RCxhQUFTLE9BQVQsQ0FEc0QsQ0FDcEM7QUFDckI7QUFDRCxTQUFPLE1BQVA7QUFDSDs7QUFFRDs7Ozs7Ozs7QUFRQSxTQUFTLFlBQVQsQ0FBc0IsT0FBdEIsRUFBK0IsT0FBL0IsRUFBd0M7QUFDcEMsWUFBVSxLQUFLLFNBQUwsQ0FBZSxPQUFmLENBQVY7QUFDQSxTQUFPLFdBQVcsS0FBSyxNQUFMLENBQVksT0FBWixDQUFsQjtBQUNIOztBQUVEOzs7OztBQUtBLFNBQVMscUJBQVQsQ0FBK0IsS0FBL0IsRUFBc0M7QUFDbEMsTUFBSSxDQUFDLE9BQU8scUJBQVosRUFBbUM7QUFDL0IsWUFBUSxJQUFSLENBQWEsK3FCQUFiO0FBQ0EsV0FBTyxxQkFBUCxHQUErQixJQUEvQjtBQUNIO0FBQ0QsT0FBSyxlQUFMLEdBQXVCLFFBQVEsbUJBQW1CLE9BQTNCLEdBQXFDLG1CQUFtQixPQUEvRTtBQUNIOztBQUVELFNBQVMsVUFBVCxDQUFvQixRQUFwQixFQUE4QjtBQUMxQixNQUFJLGFBQWEsT0FBTyx3QkFBUCxDQUFnQyxJQUFoQyxFQUFzQyxRQUF0QyxDQUFqQjtBQUNBLE1BQUksQ0FBQyxVQUFMLEVBQWlCO0FBQ2IsV0FBTyxLQUFQLENBRGEsQ0FDQztBQUNqQixHQUZELE1BRU8sSUFBSSxDQUFDLFdBQVcsR0FBaEIsRUFBcUI7QUFDeEIsV0FBTyxPQUFPLEtBQUssUUFBTCxDQUFkLENBRHdCLENBQ007QUFDakMsR0FGTSxNQUVBLElBQUksV0FBVyxHQUFYLENBQWUsUUFBZixHQUEwQixPQUExQixDQUFrQyxPQUFsQyxDQUFKLEVBQWdEO0FBQ25ELFNBQUssR0FBTCxDQUFTLFFBQVQsSUFBcUIsT0FBTyxjQUFQLENBQXNCLElBQXRCLEVBQTRCLFFBQTVCLENBQXJCO0FBQ0gsR0FGTSxNQUVBO0FBQ0gsV0FBTyxJQUFQLENBREcsQ0FDVTtBQUNoQjtBQUNELE9BQUssSUFBTCxDQUFVLE9BQVY7QUFDQSxTQUFPLEtBQVAsQ0FaMEIsQ0FZWjtBQUNqQjs7QUFFRDs7Ozs7Ozs7OztBQVVBLFNBQVMsSUFBVCxDQUFjLEVBQWQsRUFBa0I7QUFDZCxNQUFJLEtBQUssT0FBVCxFQUFrQjtBQUNkLFFBQUksYUFBYSxRQUFRLEVBQVIseUNBQVEsRUFBUixHQUFZLENBQVosTUFBbUIsR0FBbkIsSUFBMEIsRUFBMUIsSUFBZ0MsS0FBSyxVQUF0RDtBQUNBLFFBQUksVUFBSixFQUFnQjtBQUNaLFdBQUssV0FBVyxLQUFLLE9BQWhCLEVBQXlCLEtBQUssSUFBOUIsRUFBb0MsS0FBSyxNQUF6QyxDQUFMO0FBQ0g7QUFDSjtBQUNELFNBQU8sRUFBUDtBQUNIOztBQUVEO0FBQ0EsT0FBTyxnQkFBUCxDQUF3QixRQUF4QixFQUFrQztBQUM5QixTQUFPLEVBQUUsT0FBTyxRQUFRLFdBQVIsRUFBcUIsS0FBOUIsRUFEdUI7QUFFOUIsVUFBUSxFQUFFLE9BQU8sVUFBVCxFQUZzQjtBQUc5QixpQkFBZSxFQUFFLE9BQU8sYUFBVCxFQUhlO0FBSTlCLHNCQUFvQixFQUFFLE9BQU8sa0JBQVQsRUFKVTtBQUs5QixVQUFRLEVBQUUsT0FBTyxNQUFULEVBTHNCO0FBTTlCLGdCQUFjLEVBQUUsT0FBTyxZQUFULEVBTmdCO0FBTzlCLHlCQUF1QixFQUFFLEtBQUsscUJBQVAsRUFQTztBQVE5QixRQUFNLEVBQUUsT0FBTyxJQUFUO0FBUndCLENBQWxDOztBQVdBLE9BQU8sT0FBUCxHQUFpQixRQUFqQjs7O0FDdDZFQTs7OztBQUVBLElBQUksVUFBVSxRQUFRLFdBQVIsQ0FBZDs7QUFFQTs7OztBQUlBLElBQUksWUFBWSxRQUFRLE1BQVIsQ0FBZSxXQUFmLEVBQTRCO0FBQ3hDLHFCQUFpQix5QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNuQyxhQUFLLE1BQUwsR0FBYyxLQUFLLDRCQUFMLENBQWtDLElBQWxDLEVBQXdDLEtBQXhDLElBQWlELFNBQWpELEdBQTZELElBQTNFOztBQUVBLFlBQUksS0FBSyxJQUFULEVBQWU7QUFDWCxpQkFBSyxJQUFMLENBQVUsZUFBVixDQUEwQixJQUExQixFQUFnQyxLQUFoQztBQUNIO0FBQ0osS0FQdUM7O0FBU3hDOzs7OztBQUtBLGlCQUFhLHFCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQy9CLGFBQUssR0FBTCxDQUFTLE9BQVQsRUFBa0IsS0FBbEI7QUFDQSxZQUFJLFdBQVcsS0FBZjtBQUNBLFlBQUksTUFBTSxtQkFBTixJQUE2QixLQUFLLHNCQUFMLENBQTRCLElBQTVCLEVBQWtDLEtBQWxDLENBQTdCLElBQXlFLE1BQU0sZUFBbkYsRUFBb0c7QUFDaEcsaUJBQUssb0JBQUwsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBaEM7QUFDQSx1QkFBVyxJQUFYO0FBQ0gsU0FIRCxNQUdPLElBQUksS0FBSyxxQkFBTCxDQUEyQixLQUEzQixLQUFxQyxNQUFNLGVBQTNDLElBQThELEtBQUsscUJBQXZFLEVBQThGO0FBQ2pHLGlCQUFLLHFCQUFMLENBQTJCLEtBQTNCO0FBQ0gsU0FGTSxNQUVBLElBQUksS0FBSyxzQkFBTCxDQUE0QixJQUE1QixFQUFrQyxLQUFsQyxLQUE0QyxNQUFNLGtCQUF0RCxFQUEwRTtBQUM3RSxpQkFBSyx1QkFBTCxDQUE2QixJQUE3QixFQUFtQyxLQUFuQztBQUNBLHVCQUFXLElBQVg7QUFDSCxTQUhNLE1BR0E7QUFDSCx1QkFBVyxDQUFDLE1BQU0sVUFBTixJQUFvQixNQUFNLFlBQTNCLE1BQ1AsS0FBSyxRQUFMLENBQWMsSUFBZCxFQUFvQixLQUFwQixNQUErQixTQUEvQixJQUNBLEtBQUssUUFBTCxDQUFjLFdBQWQsQ0FBMEIsS0FBMUIsQ0FGTyxDQUFYO0FBSUg7O0FBRUQsWUFBSSxDQUFDLFFBQUQsSUFBYSxLQUFLLElBQXRCLEVBQTRCO0FBQ3hCLGlCQUFLLElBQUwsQ0FBVSxXQUFWLENBQXNCLElBQXRCLEVBQTRCLEtBQTVCO0FBQ0g7QUFDSixLQW5DdUM7O0FBcUN4Qzs7Ozs7QUFLQSx1QkFBbUIsMkJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDckM7QUFDQSxZQUFJLEtBQUssNEJBQUwsQ0FBa0MsSUFBbEMsRUFBd0MsS0FBeEMsQ0FBSixFQUFvRDtBQUNoRDtBQUNIOztBQUVELFlBQUksS0FBSyxJQUFULEVBQWU7QUFDWCxpQkFBSyxJQUFMLENBQVUsaUJBQVYsQ0FBNEIsSUFBNUIsRUFBa0MsS0FBbEM7QUFDSDtBQUNKLEtBbkR1Qzs7QUFxRHhDOzs7Ozs7QUFNQSwwQkFBc0IsOEJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDeEMsWUFBSSxDQUFDLE1BQU0sYUFBWCxFQUEwQjtBQUN0QixpQkFBSyxRQUFMLENBQWMsZUFBZCxDQUE4QixNQUFNLE9BQXBDO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsaUJBQUssUUFBTCxDQUFjLGlCQUFkLENBQWdDLE1BQU0sT0FBdEM7QUFDSDtBQUNKLEtBakV1Qzs7QUFtRXhDOzs7Ozs7QUFNQSw2QkFBeUIsaUNBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDM0MsWUFBSSxDQUFDLE1BQU0sZ0JBQVgsRUFBNkI7QUFDekIsaUJBQUssUUFBTCxDQUFjLGtCQUFkLENBQWlDLE1BQU0sYUFBdkM7QUFDSCxTQUZELE1BRU87QUFDSCxpQkFBSyxRQUFMLENBQWMsb0JBQWQsQ0FBbUMsTUFBTSxhQUF6QztBQUNIO0FBQ0osS0EvRXVDOztBQWlGeEM7Ozs7O0FBS0EsMkJBQXVCLCtCQUFTLEtBQVQsRUFBZ0I7QUFDbkMsWUFBTSwwQkFBMEIsTUFBTSx1QkFBdEM7QUFBQSxZQUNJLG1CQUFtQixNQUFNLGdCQUQ3QjtBQUFBLFlBRUksd0JBQXdCLE1BQU0scUJBRmxDO0FBQUEsWUFHSSwyQkFBMkIsTUFBTSxlQUhyQzs7QUFLQSxlQUFPLDJCQUEyQixnQkFBM0IsSUFBK0Msd0JBQXdCLENBQXZFLElBQTRFLENBQUMsd0JBQXBGO0FBQ0gsS0E3RnVDOztBQStGeEM7Ozs7OztBQU1BLDRCQUF3QixnQ0FBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUMxQyxZQUFLLENBQUMsTUFBTSxlQUFQLElBQTBCLENBQUMsTUFBTSxrQkFBbEMsSUFBeUQsTUFBTSxrQkFBbkUsRUFBdUY7QUFDbkYsbUJBQU8sS0FBUDtBQUNIOztBQUVELFlBQUksWUFBWSxNQUFNLFVBQU4sQ0FBaUIsZUFBakIsR0FDWixNQUFNLFNBQU4sR0FBa0IsTUFBTSxVQUFOLENBQWlCLCtCQUR2QztBQUVBLFlBQUksYUFBYSxZQUFZLE1BQU0sVUFBTixDQUFpQix3Q0FBOUM7O0FBRUEsWUFBSSxXQUFXLENBQWY7QUFDQSxZQUFJLGNBQWMsTUFBTSxNQUFOLENBQWEsTUFBYixHQUFzQixDQUF4Qzs7QUFFQSxlQUFPLE1BQU0sVUFBTixDQUFpQixDQUFqQixJQUFzQixVQUF0QixJQUNBLE1BQU0sVUFBTixDQUFpQixDQUFqQixJQUFzQixDQUR0QixJQUVBLE1BQU0sVUFBTixDQUFpQixDQUFqQixJQUFzQixXQUZ0QixJQUdBLE1BQU0sVUFBTixDQUFpQixDQUFqQixJQUFzQixRQUg3QjtBQUlILEtBckh1Qzs7QUF1SHhDOzs7Ozs7QUFNQSxrQ0FBOEIsc0NBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDaEQsZUFBTyxDQUFFLE1BQU0sbUJBQU4sSUFBNkIsTUFBTSxlQUFwQyxJQUF3RCxLQUFLLHFCQUFMLENBQTJCLEtBQTNCLENBQXhELElBQTZGLE1BQU0sa0JBQXBHLEtBQ0EsS0FBSyxzQkFBTCxDQUE0QixJQUE1QixFQUFrQyxLQUFsQyxDQURQO0FBRUgsS0FoSXVDOztBQWtJeEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkEsY0FBVSxrQkFBUyxJQUFULEVBQWUsU0FBZixFQUEwQjtBQUNoQyxZQUFJLE1BQUo7QUFBQSxZQUFZLEdBQVo7QUFBQSxZQUNJLFVBQVUsVUFBVSxPQUR4QjtBQUFBLFlBRUksU0FBUyxPQUFPLE1BQVAsQ0FBYyxVQUFVLFVBQXhCLEVBQW9DLEVBQUUsU0FBUyxFQUFFLE9BQU8sT0FBVCxFQUFYLEVBQXBDLENBRmI7QUFBQSxZQUdJLFFBQVEsT0FBTyxJQUFQLENBQVksVUFBVSxLQUF0QixDQUhaO0FBQUEsWUFJSSxXQUFXLFVBQVUsVUFBVixDQUFxQixJQUpwQztBQUFBLFlBS0ksVUFBVSxvQkFBb0IsS0FMbEM7QUFBQSxZQU1JLE9BQU8sVUFBVSxTQUFTLENBQVQsQ0FBVixHQUF3QixRQU5uQzs7QUFRQTtBQUNBLHVCQUFlLElBQWYseUNBQWUsSUFBZjtBQUNJLGlCQUFLLFFBQUw7QUFDSSxvQkFBSSxTQUFTLEdBQWIsRUFBa0I7QUFDZCwwQkFBTSxLQUFOO0FBQ0gsaUJBRkQsTUFFTyxJQUFJLFFBQVEsSUFBUixDQUFhLElBQWIsQ0FBSixFQUF3QjtBQUMzQiwwQkFBTSxRQUFRLElBQVIsQ0FBTjtBQUNIO0FBQ0Q7O0FBRUosaUJBQUssVUFBTDtBQUNJLHNCQUFNLEtBQUssU0FBTCxDQUFOO0FBQ0E7QUFYUjs7QUFjQSxZQUFJLEdBQUosRUFBUztBQUNMO0FBQ0Esa0JBQU0sSUFBSSxRQUFKLEdBQWUsT0FBZixDQUF1QixRQUF2QixFQUFpQyxPQUFPLElBQXhDLEVBQThDLE9BQTlDLENBQXNELFNBQXRELEVBQWlFLEtBQWpFLENBQU47O0FBRUE7QUFDQSxnQkFBSSxPQUFKLEVBQWE7QUFDVCwyQkFBVyxTQUFTLEtBQVQsRUFBWDtBQUNBLHlCQUFTLENBQVQsSUFBYyxHQUFkO0FBQ0EseUJBQVMsS0FBSyxVQUFMLENBQWdCLEtBQWhCLENBQXNCLElBQXRCLEVBQTRCLFFBQTVCLENBQVQ7QUFDSCxhQUpELE1BSU87QUFDSCx5QkFBUyxLQUFLLFVBQUwsQ0FBZ0IsR0FBaEIsRUFBcUIsVUFBVSxVQUFWLENBQXFCLFVBQTFDLENBQVQ7QUFDSDtBQUNKOztBQUVEO0FBQ0EsWUFBSSxNQUFKLEVBQVk7QUFDUixzQkFBVSxlQUFWLENBQTBCLFdBQTFCLEVBQXVDLEtBQUssVUFBTCxDQUFnQixnQkFBdkQ7QUFDQSxpQkFBSyxRQUFMLENBQWMsd0JBQWQsQ0FBdUMsU0FBdkM7QUFDQSxpQkFBSyxPQUFMO0FBQ0g7O0FBRUQsZUFBTyxNQUFQO0FBQ0g7O0FBdk11QyxDQUE1QixDQUFoQjs7QUEyTUEsT0FBTyxPQUFQLEdBQWlCLFNBQWpCOzs7QUNuTkE7O0FBRUEsSUFBSSxVQUFVLFFBQVEsV0FBUixDQUFkO0FBQ0EsSUFBSSxhQUFhLFFBQVEsMkJBQVIsQ0FBakI7O0FBRUE7Ozs7QUFJQSxJQUFJLGNBQWMsUUFBUSxNQUFSLENBQWUsYUFBZixFQUE4Qjs7QUFFNUM7Ozs7O0FBS0EsaUJBQWEscUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDL0IsYUFBSyxJQUFMLENBQVUsSUFBVixFQUFnQixJQUFoQixFQUFzQixLQUF0QjtBQUNILEtBVDJDOztBQVc1Qzs7Ozs7QUFLQSx1QkFBbUIsMkJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDckMsYUFBSyxJQUFMLENBQVUsSUFBVixFQUFnQixJQUFoQixFQUFzQixLQUF0QixFQUE2QixJQUE3QjtBQUNILEtBbEIyQzs7QUFvQjVDOzs7OztBQUtBLG1CQUFlLHVCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ2pDLFlBQUksSUFBSixFQUFVLGFBQVYsRUFBeUIsWUFBekIsRUFBdUMsTUFBdkMsRUFBK0MsU0FBL0M7O0FBRUEsWUFDSSxDQUFDLFlBQVksS0FBSyw0QkFBTCxFQUFiLEtBQ0EsVUFBVSxVQUFWLENBQXFCLGFBRHJCLElBRUEsQ0FBQyxLQUFLLFVBRk4sS0FJSSxDQUFDLE9BQU8sTUFBTSxNQUFOLENBQWEsSUFBckIsTUFBK0IsSUFBL0IsS0FDQyxnQkFBZ0IsS0FBSyxNQUFMLEtBQWdCLENBQWhCLElBQXFCLEVBQUUsTUFBTSxNQUFOLENBQWEsSUFBYixJQUFxQixNQUFNLE1BQU4sQ0FBYSxJQUFwQyxDQUR0QyxNQUVDLGVBQWUsU0FBUyxRQUFULElBQXFCLFNBQVMsV0FGOUMsQ0FKSixDQURKLEVBU0U7QUFDRSxnQkFBTSx1QkFBdUIsVUFBVSxTQUFWLEdBQXNCLFVBQXRCLEdBQW1DLFlBQWhFO0FBQ0EsZ0JBQU0sYUFBYSxVQUFVLGFBQVYsQ0FBd0Isb0JBQXhCLEtBQWlELFVBQVUsVUFBVixDQUFxQixvQkFBckIsQ0FBcEU7QUFDQSxnQkFBSSxVQUFKLEVBQWdCO0FBQ1oseUJBQVMsS0FBSyxnQkFBTCxDQUFzQixTQUF0QixDQUFUOztBQUVBLG9CQUFJLGtCQUFrQixVQUF0QixFQUFrQzs7QUFFOUIsd0JBQUksYUFBSixFQUFtQjtBQUNmLCtCQUFPLEtBQVAsQ0FBYSxLQUFiLEdBQXFCLElBQXJCO0FBQ0gscUJBRkQsTUFFTyxJQUFJLFlBQUosRUFBa0I7QUFDckIsK0JBQU8sY0FBUCxDQUFzQixFQUF0QjtBQUNIO0FBQ0o7QUFDRCxzQkFBTSxNQUFOLENBQWEsY0FBYixDQUE0QixjQUE1QjtBQUNIO0FBQ0osU0F6QkQsTUF5Qk8sSUFBSSxLQUFLLElBQVQsRUFBZTtBQUNsQixpQkFBSyxJQUFMLENBQVUsYUFBVixDQUF3QixJQUF4QixFQUE4QixLQUE5QjtBQUNIO0FBQ0o7O0FBeEQyQyxDQUE5QixDQUFsQjs7QUE0REEsU0FBUyxJQUFULENBQWMsSUFBZCxFQUFvQixLQUFwQixFQUEyQixhQUEzQixFQUEwQztBQUN0QyxRQUNJLE1BQU0sVUFBTixJQUNBLEVBQUUsTUFBTSxlQUFOLENBQXNCLG1CQUF0QixJQUE2QyxhQUEvQyxDQUZKLENBRWtFO0FBRmxFLE1BR0U7QUFDRSxpQkFBSyxnQkFBTCxDQUFzQixLQUF0QjtBQUNIOztBQUVELFFBQUksS0FBSyxJQUFULEVBQWU7QUFDWCxhQUFLLElBQUwsQ0FBVSxnQkFBZ0IsbUJBQWhCLEdBQXNDLGFBQWhELEVBQStELElBQS9ELEVBQXFFLEtBQXJFO0FBQ0g7QUFDSjs7QUFFRCxPQUFPLE9BQVAsR0FBaUIsV0FBakI7OztBQ2xGQTs7QUFFQSxJQUFJLFVBQVUsUUFBUSxXQUFSLENBQWQ7O0FBRUE7Ozs7QUFJQSxJQUFJLGdCQUFnQixRQUFRLE1BQVIsQ0FBZSxlQUFmLEVBQWdDOztBQUVoRDs7Ozs7QUFLQSxpQkFBYSxJQVBtQzs7QUFTaEQ7Ozs7O0FBS0Esa0JBQWMsSUFka0M7O0FBZ0JoRDs7Ozs7O0FBTUEsZ0JBQVksQ0F0Qm9DOztBQXdCaEQ7Ozs7OztBQU1BLGlCQUFhLENBOUJtQzs7QUFnQ2hEOzs7OztBQUtBLG1CQUFlLHVCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ2pDLFlBQUksS0FBSyxRQUFULEVBQW1CO0FBQ2YsaUJBQUssUUFBTCxHQUFnQixLQUFoQjtBQUNIO0FBQ0QsWUFBSSxLQUFLLElBQVQsRUFBZTtBQUNYLGlCQUFLLElBQUwsQ0FBVSxhQUFWLENBQXdCLElBQXhCLEVBQThCLEtBQTlCO0FBQ0g7QUFDSixLQTVDK0M7O0FBOENoRDs7Ozs7QUFLQSxxQkFBaUIseUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDbkMsWUFBSSxXQUFKO0FBQUEsWUFBUSxXQUFSO0FBQ0EsYUFBSyxRQUFMLENBQWMscUJBQWQ7QUFDQSxZQUFJLE1BQU0sdUJBQU4sSUFBaUMsTUFBTSxxQkFBM0MsRUFBa0U7QUFDOUQsZ0JBQUksYUFBYSxLQUFLLFFBQUwsQ0FBYyxxQkFBZCxDQUFvQyxNQUFNLHFCQUExQyxDQUFqQjtBQUNBLGdCQUFJLGtCQUFrQixLQUFLLFFBQUwsQ0FBYyxPQUFkLENBQXNCLE9BQXRCLENBQThCLFVBQTlCLENBQXRCOztBQUVBLGdCQUFJLGNBQWMsZUFBbEIsRUFBbUM7QUFDL0IscUJBQUssZUFBTDtBQUNIO0FBQ0osU0FQRCxNQU9PLElBQUksTUFBTSxjQUFOLEtBQXlCLFNBQXpCLElBQXNDLE1BQU0sY0FBTixLQUF5QixJQUFuRSxFQUF5RTtBQUM1RSxpQkFBSyxNQUFNLGNBQVg7QUFDSDs7QUFFRCxhQUFLLE9BQU8sU0FBUCxHQUFtQixFQUFuQixHQUF3QixNQUFNLFFBQU4sQ0FBZSxDQUE1QztBQUNBLGFBQUssT0FBTyxTQUFQLEdBQW1CLEVBQW5CLEdBQXdCLE1BQU0sUUFBTixDQUFlLENBQTVDO0FBQ0EsWUFBSSxlQUFlLEtBQUssUUFBTCxDQUFjLGVBQWQsQ0FBOEIsRUFBOUIsRUFBa0MsRUFBbEMsRUFBc0MsZUFBdEMsQ0FBbkI7O0FBRUEsWUFBSSxnQkFBZ0IsTUFBTSxVQUExQixFQUFzQztBQUNsQyxnQkFBSSxNQUFNLGNBQU4sQ0FBcUIsTUFBckIsQ0FBNEIsWUFBNUIsSUFBNEMsTUFBTSxjQUF0RCxFQUFzRTtBQUNsRTtBQUNIO0FBQ0QsZ0JBQUksUUFBUSxLQUFLLFFBQUwsQ0FBYyxFQUFkLEVBQWtCLEVBQWxCLENBQVo7QUFBQSxnQkFDSSxZQUFZLE1BQU0sY0FEdEI7QUFBQSxnQkFFSSxPQUFPLFVBQVUsTUFBVixDQUFpQixJQUY1QjtBQUdBLGlCQUFLLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxpQkFBSyxlQUFMLENBQXFCLElBQXJCLEVBQTJCLEtBQTNCLEVBQWtDLElBQWxDO0FBQ0g7O0FBRUQsWUFBSSxLQUFLLElBQVQsRUFBZTtBQUNYLGlCQUFLLElBQUwsQ0FBVSxlQUFWLENBQTBCLElBQTFCLEVBQWdDLEtBQWhDO0FBQ0g7QUFDSixLQW5GK0M7O0FBcUZoRDs7Ozs7QUFLQSxxQkFBaUIseUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDbkMsWUFBSSxLQUFLLFFBQUwsSUFBaUIsS0FBSyxVQUFMLENBQWdCLGFBQWpDLElBQWtELENBQUMsTUFBTSxjQUFOLENBQXFCLE1BQXJCLENBQTRCLFlBQW5GLEVBQWlHO0FBQzdGLGlCQUFLLFdBQUwsR0FBbUIsTUFBTSxjQUFOLENBQXFCLE1BQXJCLENBQTRCLEtBQS9DO0FBQ0EsaUJBQUssWUFBTCxHQUFvQixLQUFLLFFBQUwsQ0FBYyxNQUFNLFFBQU4sQ0FBZSxDQUE3QixFQUFnQyxNQUFNLFFBQU4sQ0FBZSxDQUEvQyxDQUFwQjtBQUNBLGlCQUFLLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsS0FBSyxXQUFoQztBQUNBLGlCQUFLLDRCQUFMLENBQWtDLElBQWxDLEVBQXdDLEtBQUssWUFBN0MsRUFBMkQsTUFBTSxjQUFOLENBQXFCLE1BQXJCLENBQTRCLElBQXZGO0FBQ0gsU0FMRCxNQUtPLElBQUksS0FBSyxJQUFULEVBQWU7QUFDbEIsaUJBQUssSUFBTCxDQUFVLGVBQVYsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBaEM7QUFDSDtBQUNKLEtBbkcrQzs7QUFxR2hEOzs7OztBQUtBLG1CQUFlLHVCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ2pDLFlBQUksWUFBWSxLQUFLLDRCQUFMLENBQWtDLElBQWxDLENBQWhCO0FBQ0EsWUFBTSxTQUFTLE1BQU0sTUFBckI7QUFBQSxZQUNJLE9BQU8sT0FBTyxXQURsQjtBQUVBLFlBQU0sY0FBYyxNQUFNLE9BQU4sSUFDYixNQUFNLE9BRE8sSUFFYixLQUFLLE9BQUwsQ0FBYSxNQUFiLEtBQXdCLENBRlgsSUFHYixLQUFLLE9BQUwsQ0FBYSxhQUFiLEtBQStCLENBSGxCLElBSWIsS0FBSyxPQUFMLENBQWEsY0FBYixLQUFnQyxDQUp2QztBQUtBLFlBQU0sU0FBUyxjQUNQLFVBQVUsVUFBVixDQUFxQixZQUFyQixDQUFrQyxPQUFPLElBQXpDLEVBQStDLFdBQS9DLEtBQ0EsVUFBVSxVQUFWLENBQXFCLE1BQXJCLENBQTRCLE9BQU8sSUFBbkMsRUFBeUMsV0FBekMsQ0FGTyxDQUFmOztBQUtBLFlBQU0sVUFBVyxlQUFlLEtBQUssZUFBZSxNQUFwQixDQUFoQixHQUErQyxLQUFLLGVBQWUsTUFBcEIsQ0FBL0MsR0FBNkUsS0FBSyxXQUFXLE1BQWhCLENBQTdGOztBQUVBO0FBQ0EsWUFBSSxPQUFKLEVBQWE7QUFDVCxvQkFBUSxJQUFSLENBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QixNQUF6Qjs7QUFFQTtBQUNBLHdCQUFZLEtBQUssNEJBQUwsQ0FBa0MsSUFBbEMsQ0FBWixDQUpTLENBSTRDO0FBQ3JELGdCQUFJLFVBQVUsVUFBVixDQUFxQixjQUF6QixFQUF5QztBQUNyQyxxQkFBSyxNQUFMLENBQVksU0FBWixFQURxQyxDQUNiO0FBQzNCOztBQUVEO0FBQ0EsZ0JBQUksQ0FBQyxLQUFLLFVBQVYsRUFBc0I7QUFDbEIscUJBQUssU0FBTDtBQUNIOztBQUVELGdCQUFJLE1BQU0sTUFBTixDQUFhLFdBQWIsSUFBNEIsTUFBTSxNQUFOLENBQWEsV0FBYixDQUF5QixjQUF6RCxFQUF5RTtBQUNyRSxzQkFBTSxNQUFOLENBQWEsV0FBYixDQUF5QixjQUF6QjtBQUNIO0FBQ0osU0FqQkQsTUFpQk8sSUFBSSxLQUFLLElBQVQsRUFBZTtBQUNsQixpQkFBSyxJQUFMLENBQVUsYUFBVixDQUF3QixJQUF4QixFQUE4QixLQUE5QjtBQUNIO0FBQ0osS0EvSStDOztBQWlKaEQ7Ozs7Ozs7QUFPQSxrQ0FBOEIsc0NBQVMsSUFBVCxFQUFlLFFBQWYsRUFBeUIsSUFBekIsRUFBK0I7QUFDekQsWUFBTSxJQUFJLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxTQUFTLENBQXJCLENBQVY7QUFBQSxZQUNJLElBQUksS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLFNBQVMsQ0FBckIsQ0FEUjtBQUFBLFlBRUkscUJBQXFCLEtBQUssYUFBTCxFQUZ6QjtBQUFBLFlBR0ksWUFBWSxLQUFLLFlBQUwsRUFIaEI7QUFBQSxZQUlJLE9BQU8sSUFBSSxVQUFVLENBSnpCO0FBQUEsWUFLSSxPQUFPLElBQUksVUFBVSxDQUx6Qjs7QUFPQSxZQUFJLG1CQUFtQixDQUFuQixLQUF5QixJQUF6QixJQUFpQyxtQkFBbUIsQ0FBbkIsS0FBeUIsSUFBOUQsRUFBb0U7QUFDaEU7QUFDSDs7QUFFRCxhQUFLLHdCQUFMOztBQUVBLGFBQUssTUFBTCxDQUFZLFVBQVUsQ0FBdEIsRUFBeUIsVUFBVSxDQUFuQyxFQUFzQyxJQUF0QyxFQUE0QyxJQUE1QztBQUNBLGFBQUssYUFBTCxDQUFtQixLQUFLLFFBQUwsQ0FBYyxJQUFkLEVBQW9CLElBQXBCLENBQW5COztBQUVBLGFBQUssT0FBTDtBQUNILEtBMUsrQzs7QUE0S2hEOzs7Ozs7QUFNQSxxQkFBaUIseUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDbkMsWUFBSSxDQUFDLEtBQUssVUFBTCxDQUFnQixnQkFBckIsRUFBdUM7QUFDbkM7QUFDSDtBQUNELFlBQU0sSUFBSSxLQUFLLGFBQUwsRUFBVjtBQUNBLFlBQU0sU0FBUyxFQUFFLFFBQUYsQ0FBVyxLQUFYLENBQWY7QUFDQSxZQUFJLE1BQUosRUFBWTtBQUNSLGdCQUFJLEtBQUssY0FBTCxFQUFKLEVBQTJCO0FBQ3ZCLHFCQUFLLGVBQUwsQ0FBcUIsS0FBckI7QUFDSDtBQUNKLFNBSkQsTUFJTyxJQUFJLENBQUMsS0FBSyxjQUFMLEVBQUwsRUFBNEI7QUFDL0IsaUJBQUssZUFBTCxDQUFxQixJQUFyQjtBQUNBLGlCQUFLLFVBQUwsQ0FBZ0IsSUFBaEI7QUFDSDtBQUNKLEtBaE0rQzs7QUFrTWhEOzs7OztBQUtBLGdCQUFZLG9CQUFTLElBQVQsRUFBZTtBQUN2QixZQUFJLENBQUMsS0FBSyxjQUFMLEVBQUwsRUFBNEI7QUFDeEI7QUFDSDs7QUFFRCxZQUFJLGVBQWUsS0FBSyxZQUF4QjtBQUFBLFlBQ0ksSUFBSSxLQUFLLGFBQUwsRUFEUjtBQUFBLFlBR0ksVUFBVSxDQUhkO0FBQUEsWUFJSSxVQUFVLENBSmQ7QUFBQSxZQU1JLGtCQUFrQixLQUFLLG1CQUFMLEVBTnRCO0FBQUEsWUFPSSxlQUFlLEtBQUssZ0JBQUwsRUFQbkI7QUFBQSxZQVNJLHNCQUFzQixhQUFhLENBQWIsR0FBaUIsZUFUM0M7QUFBQSxZQVVJLHNCQUFzQixhQUFhLENBQWIsR0FBaUIsWUFWM0M7O0FBWUEsWUFBSSxLQUFLLFdBQUwsQ0FBaUIsQ0FBakIsR0FBcUIsRUFBRSxNQUFGLENBQVMsQ0FBbEMsRUFBcUM7QUFDakMsc0JBQVUsQ0FBQyxDQUFYO0FBQ0g7QUFDRCxZQUFJLEtBQUssV0FBTCxDQUFpQixDQUFqQixHQUFxQixFQUFFLE1BQUYsQ0FBUyxDQUFsQyxFQUFxQztBQUNqQyxzQkFBVSxDQUFDLENBQVg7QUFDSDs7QUFFRCxZQUFJLEtBQUssV0FBTCxDQUFpQixDQUFqQixHQUFxQixFQUFFLE1BQUYsQ0FBUyxDQUFULEdBQWEsRUFBRSxNQUFGLENBQVMsQ0FBL0MsRUFBa0Q7QUFDOUMsc0JBQVUsQ0FBVjtBQUNIO0FBQ0QsWUFBSSxLQUFLLFdBQUwsQ0FBaUIsQ0FBakIsR0FBcUIsRUFBRSxNQUFGLENBQVMsQ0FBVCxHQUFhLEVBQUUsTUFBRixDQUFTLENBQS9DLEVBQWtEO0FBQzlDLHNCQUFVLENBQVY7QUFDSDs7QUFFRCxZQUFJLGtCQUFrQixPQUF0QjtBQUNBLFlBQUksa0JBQWtCLE9BQXRCOztBQUVBLFlBQUksbUJBQUosRUFBeUI7QUFDckIsOEJBQWtCLENBQWxCO0FBQ0g7QUFDRCxZQUFJLG1CQUFKLEVBQXlCO0FBQ3JCLDhCQUFrQixDQUFsQjtBQUNIOztBQUVELGFBQUssWUFBTCxHQUFvQixhQUFhLE1BQWIsQ0FBb0IsZUFBcEIsRUFBcUMsZUFBckMsQ0FBcEI7QUFDQSxhQUFLLFFBQUwsQ0FBYyxPQUFkLEVBQXVCLE9BQXZCO0FBQ0EsYUFBSyw0QkFBTCxDQUFrQyxJQUFsQyxFQUF3QyxZQUF4QyxFQUFzRCxFQUF0RCxFQTNDdUIsQ0EyQ29DO0FBQzNELGFBQUssT0FBTDtBQUNBLG1CQUFXLEtBQUssVUFBTCxDQUFnQixJQUFoQixDQUFxQixJQUFyQixFQUEyQixJQUEzQixDQUFYLEVBQTZDLEVBQTdDO0FBQ0gsS0FyUCtDOztBQXVQaEQ7Ozs7Ozs7QUFPQSxxQkFBaUIseUJBQVMsSUFBVCxFQUFlLFFBQWYsRUFBeUIsSUFBekIsRUFBK0I7QUFDNUMsWUFBTSxVQUFVLEtBQUssT0FBTCxDQUFhLE1BQWIsS0FBd0IsQ0FBeEIsSUFBNkIsS0FBSyxPQUFMLENBQWEsYUFBYixLQUErQixDQUE1RCxJQUFpRSxLQUFLLE9BQUwsQ0FBYSxjQUFiLEtBQWdDLENBQWpIO0FBQUEsWUFDSSxXQUFXLEtBQUssT0FBTCxDQUFhLE9BQWIsS0FBeUIsQ0FEeEM7QUFBQSxZQUVJLGFBQWEsS0FBSyxZQUFMLEVBRmpCO0FBQUEsWUFHSSxJQUFJLFNBQVMsQ0FIakI7QUFBQSxZQUdvQjtBQUNoQixZQUFJLFNBQVMsQ0FKakIsQ0FENEMsQ0FLeEI7O0FBRXBCO0FBQ0EsWUFBSSxJQUFJLENBQUosSUFBUyxJQUFJLENBQWpCLEVBQW9CO0FBQ2hCO0FBQ0g7O0FBRUQ7QUFDQSxZQUNJLFdBQ0EsTUFBTSxXQUFXLENBRGpCLElBRUEsTUFBTSxXQUFXLENBSHJCLEVBSUU7QUFDRSxpQkFBSyx3QkFBTDtBQUNBLGlCQUFLLFlBQUw7QUFDQSxpQkFBSyxPQUFMO0FBQ0E7QUFDSDs7QUFFRCxZQUFJLENBQUMsT0FBRCxJQUFZLENBQUMsUUFBakIsRUFBMkI7QUFDdkIsaUJBQUssZUFBTDtBQUNIOztBQUVELFlBQUksUUFBSixFQUFjO0FBQ1YsaUJBQUssd0JBQUw7QUFDQSxpQkFBSyxNQUFMLENBQVksV0FBVyxDQUF2QixFQUEwQixXQUFXLENBQXJDLEVBQXdDLElBQUksV0FBVyxDQUF2RCxFQUEwRCxJQUFJLFdBQVcsQ0FBekU7QUFDQSxpQkFBSyxhQUFMLENBQW1CLEtBQUssUUFBTCxDQUFjLElBQUksV0FBVyxDQUE3QixFQUFnQyxJQUFJLFdBQVcsQ0FBL0MsQ0FBbkI7QUFDSCxTQUpELE1BSU87QUFDSCxpQkFBSyxNQUFMLENBQVksQ0FBWixFQUFlLENBQWYsRUFBa0IsQ0FBbEIsRUFBcUIsQ0FBckI7QUFDQSxpQkFBSyxZQUFMLENBQWtCLEtBQUssUUFBTCxDQUFjLENBQWQsRUFBaUIsQ0FBakIsQ0FBbEI7QUFDQSxpQkFBSyxhQUFMLENBQW1CLEtBQUssUUFBTCxDQUFjLENBQWQsRUFBaUIsQ0FBakIsQ0FBbkI7QUFDSDtBQUNELGFBQUssT0FBTDtBQUNILEtBcFMrQzs7QUFzU2hEOzs7O0FBSUEscUJBQWlCLHlCQUFTLElBQVQsRUFBZTtBQUM1QixhQUFLLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsQ0FBM0IsRUFBOEIsQ0FBOUI7QUFDSCxLQTVTK0M7O0FBOFNoRDs7OztBQUlBLG1CQUFlLHVCQUFTLElBQVQsRUFBZTtBQUMxQixhQUFLLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsQ0FBM0IsRUFBOEIsQ0FBQyxDQUEvQjtBQUNILEtBcFQrQzs7QUFzVGhEOzs7O0FBSUEscUJBQWlCLHlCQUFTLElBQVQsRUFBZTtBQUM1QixhQUFLLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsQ0FBQyxDQUE1QixFQUErQixDQUEvQjtBQUNILEtBNVQrQzs7QUE4VGhEOzs7O0FBSUEsc0JBQWtCLDBCQUFTLElBQVQsRUFBZTtBQUM3QixhQUFLLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsQ0FBM0IsRUFBOEIsQ0FBOUI7QUFDSCxLQXBVK0M7O0FBc1VoRDs7Ozs7Ozs7QUFRQSxnQ0FBNEIsb0NBQVMsSUFBVCxFQUFlLFNBQWYsRUFBeUI7QUFDakQsWUFBTSx1QkFBdUIsS0FBSyxRQUFMLENBQWMsU0FBZCxDQUF3Qix5QkFBeEIsRUFBN0I7QUFDQSxZQUFNLG9CQUFvQixLQUFLLFFBQUwsQ0FBYyxTQUFkLENBQXdCLHNCQUF4QixFQUExQjs7QUFFQSxlQUFPLFVBQVUsTUFBVixDQUFpQixDQUFqQixJQUF1Qix1QkFBdUIsQ0FBOUMsSUFDQSxVQUFVLE1BQVYsQ0FBaUIsQ0FBakIsSUFBc0IsaUJBRDdCO0FBRUgsS0FwVitDOztBQXNWaEQ7Ozs7Ozs7O0FBUUEsMkNBQXVDLCtDQUFTLElBQVQsRUFBZSxTQUFmLEVBQXlCO0FBQzVELGVBQU8sVUFBVSxNQUFWLENBQWlCLENBQWpCLEdBQXFCLEtBQUsseUJBQUwsRUFBNUI7QUFDSCxLQWhXK0M7O0FBa1doRDs7Ozs7Ozs7QUFRQSx1Q0FBbUMsMkNBQVMsSUFBVCxFQUFlLFNBQWYsRUFBeUI7QUFDeEQsZUFBTyxVQUFVLE1BQVYsQ0FBaUIsQ0FBakIsS0FBdUIsS0FBSyx5QkFBTCxFQUF2QixJQUNBLFVBQVUsTUFBVixDQUFpQixDQUFqQixLQUF1QixLQUFLLHlCQUFMLEVBRDlCO0FBRUgsS0E3VytDOztBQStXaEQ7Ozs7Ozs7O0FBUUEsc0NBQWtDLDBDQUFTLElBQVQsRUFBZSxTQUFmLEVBQTBCO0FBQ3hELFlBQU0sb0JBQW9CLEtBQUssUUFBTCxDQUFjLFNBQWQsQ0FBd0Isc0JBQXhCLEVBQTFCO0FBQ0EsZUFBTyxVQUFVLE1BQVYsQ0FBaUIsQ0FBakIsS0FBdUIsb0JBQW9CLEtBQUsseUJBQUwsRUFBcEIsR0FBdUQsQ0FBckY7QUFDSCxLQTFYK0M7O0FBNFhoRDs7Ozs7Ozs7QUFRQSx5Q0FBcUMsNkNBQVMsSUFBVCxFQUFlLFNBQWYsRUFBMEI7QUFDM0QsWUFBTSx1QkFBdUIsS0FBSyxRQUFMLENBQWMsU0FBZCxDQUF3Qix5QkFBeEIsRUFBN0I7QUFDQSxlQUFPLFVBQVUsTUFBVixDQUFpQixDQUFqQixLQUF1Qix1QkFBdUIsQ0FBckQ7QUFDSCxLQXZZK0M7O0FBeVloRDs7Ozs7Ozs7QUFRQSwrQ0FBMkMsbURBQVMsSUFBVCxFQUFlLFNBQWYsRUFBMEI7QUFDakUsZUFBTyxLQUFLLGdDQUFMLENBQXNDLElBQXRDLEVBQTRDLFNBQTVDLEtBQ0EsS0FBSyxtQ0FBTCxDQUF5QyxJQUF6QyxFQUErQyxTQUEvQyxDQURQO0FBRUgsS0FwWitDOztBQXNaaEQ7Ozs7Ozs7O0FBUUEsb0NBQWdDLHdDQUFTLElBQVQsRUFBZSxTQUFmLEVBQTBCO0FBQ3RELGVBQU8sVUFBVSxNQUFWLENBQWlCLENBQWpCLElBQXNCLENBQXRCLElBQTJCLFVBQVUsTUFBVixDQUFpQixDQUFqQixJQUFzQixLQUFLLHlCQUFMLEVBQXhEO0FBQ0gsS0FoYStDOztBQWthaEQ7Ozs7QUFJQSxpQkFBYSxxQkFBUyxJQUFULEVBQWU7QUFDeEIsWUFBTSxtQkFBbUIsS0FBSyxjQUFMLENBQW9CLGdCQUFwQixFQUF6QjtBQUNBLFlBQU0sdUJBQXVCLEtBQUssUUFBTCxDQUFjLFNBQWQsQ0FBd0IseUJBQXhCLEVBQTdCO0FBQ0EsWUFBTSxvQkFBb0IsS0FBSyxRQUFMLENBQWMsU0FBZCxDQUF3QixzQkFBeEIsRUFBMUI7QUFDQSxZQUFNLHlCQUF5QixLQUFLLHlCQUFMLEVBQS9COztBQUVBLFlBQUksc0JBQXNCLENBQTFCO0FBQUEsWUFBNkIsc0JBQXNCLENBQW5EO0FBQUEsWUFBc0Qsc0JBQXNCLENBQTVFO0FBQUEsWUFBZ0Ysc0JBQXNCLENBQXRHOztBQUVBLFlBQUksS0FBSywwQkFBTCxDQUFnQyxJQUFoQyxFQUFzQyxnQkFBdEMsS0FDRyxFQUFFLEtBQUsseUNBQUwsQ0FBK0MsSUFBL0MsRUFBcUQsZ0JBQXJELEtBQ0UsS0FBSyw4QkFBTCxDQUFvQyxJQUFwQyxFQUEwQyxnQkFBMUMsQ0FESixDQURQLEVBRXlFO0FBQ3JFLGtDQUFzQixDQUF0QjtBQUNBLGtDQUFzQixzQkFBdEI7QUFDQSxrQ0FBc0IsdUJBQXVCLENBQTdDO0FBQ0Esa0NBQXNCLG9CQUFvQixDQUExQztBQUNILFNBUEQsTUFPTztBQUNILGtDQUFzQixDQUF0QjtBQUNBLGtDQUFzQixDQUF0QjtBQUNBLGtDQUFzQixLQUFLLGNBQUwsRUFBdEI7QUFDQSxrQ0FBc0IsS0FBSyxXQUFMLEVBQXRCO0FBQ0g7O0FBRUQsWUFBSSxLQUFLLHFDQUFMLENBQTJDLElBQTNDLEVBQWlELGdCQUFqRCxLQUNHLEtBQUssVUFBTCxDQUFnQixpQ0FEdkIsRUFDMEQ7QUFDdEQsa0NBQXNCLENBQXRCO0FBQ0EsbUNBQXVCLEtBQUsseUJBQUwsRUFBdkI7QUFDSDs7QUFFRDtBQUNBLGFBQUssd0JBQUw7QUFDQSxhQUFLLE1BQUwsQ0FBWSxtQkFBWixFQUFpQyxtQkFBakMsRUFBc0QsbUJBQXRELEVBQTJFLG1CQUEzRTtBQUNBO0FBQ0E7QUFDQSxhQUFLLFlBQUwsQ0FBa0IsS0FBSyxRQUFMLENBQWMsaUJBQWlCLGlCQUFqQixDQUFtQyxDQUFqRCxFQUFvRCxpQkFBaUIsaUJBQWpCLENBQW1DLENBQXZGLENBQWxCO0FBQ0EsYUFBSyxhQUFMLENBQW1CLEtBQUssUUFBTCxDQUFjLHNCQUFzQixpQkFBaUIsaUJBQWpCLENBQW1DLENBQXZFLEVBQ2Ysc0JBQXNCLGlCQUFpQixpQkFBakIsQ0FBbUMsQ0FEMUMsQ0FBbkI7QUFFQSxZQUFNLG1CQUFtQixLQUFLLGNBQUwsQ0FBb0IsZ0JBQXBCLEVBQXpCO0FBQ0EseUJBQWlCLGlCQUFqQixHQUFxQyxpQkFBaUIsaUJBQXREO0FBQ0EseUJBQWlCLGdCQUFqQixHQUFvQyxpQkFBaUIsZ0JBQXJEO0FBQ0EsYUFBSyxPQUFMO0FBQ0gsS0E5YytDOztBQWdkaEQ7Ozs7QUFJQSxrQkFBYyxzQkFBUyxJQUFULEVBQWU7QUFDekIsWUFBTSxnQkFBZ0IsS0FBSyxjQUFMLENBQW9CLGdCQUFwQixFQUF0QjtBQUNBLFlBQU0sb0JBQW9CLEtBQUssUUFBTCxDQUFjLFNBQWQsQ0FBd0Isc0JBQXhCLEVBQTFCOztBQUVBLFlBQUksQ0FBQyxLQUFLLDBCQUFMLENBQWdDLElBQWhDLEVBQXNDLGFBQXRDLENBQUQsSUFDRyxLQUFLLFVBQUwsQ0FBZ0Isc0NBRHZCLEVBQytEO0FBQzNELGdCQUFJLGNBQWMsTUFBZCxDQUFxQixDQUFyQixJQUEwQixLQUFLLFFBQUwsQ0FBYyxTQUFkLENBQXdCLHlCQUF4QixFQUExQixJQUNHLEtBQUssVUFBTCxDQUFnQixzQ0FEdkIsRUFDK0Q7QUFDM0QscUJBQUssZ0JBQUwsQ0FBc0IsQ0FBdEIsRUFBeUIsQ0FBRSxLQUFLLEdBQUwsQ0FBUyxjQUFjLE1BQWQsQ0FBcUIsQ0FBOUIsRUFBaUMsY0FBYyxNQUFkLENBQXFCLENBQXRELENBQTNCO0FBQ0gsYUFIRCxNQUdPO0FBQ0gscUJBQUssZ0JBQUwsQ0FBc0IsQ0FBdEIsRUFBeUIsRUFBRyxLQUFLLEdBQUwsQ0FBUyxjQUFjLE1BQWQsQ0FBcUIsQ0FBOUIsRUFBaUMsY0FBYyxNQUFkLENBQXFCLENBQXRELElBQTJELGlCQUE5RCxDQUF6QjtBQUNIO0FBQ0osU0FSRCxNQVFPO0FBQ0gsZ0JBQUksS0FBSyxxQ0FBTCxDQUEyQyxJQUEzQyxFQUFpRCxhQUFqRCxLQUNHLEtBQUssaUNBQUwsQ0FBdUMsSUFBdkMsRUFBNkMsYUFBN0MsQ0FESCxJQUVHLEtBQUssVUFBTCxDQUFnQixpQ0FGdkIsRUFFMEQ7QUFDdEQscUJBQUssZ0JBQUwsQ0FBc0IsQ0FBdEIsRUFBeUIsQ0FBRSxLQUFLLEdBQUwsQ0FBUyxjQUFjLE1BQWQsQ0FBcUIsQ0FBOUIsRUFBaUMsY0FBYyxNQUFkLENBQXFCLENBQXRELENBQTNCO0FBQ0gsYUFKRCxNQUlPO0FBQ0gscUJBQUssZ0JBQUwsQ0FBc0IsQ0FBdEIsRUFBeUIsRUFBRyxLQUFLLEdBQUwsQ0FBUyxjQUFjLE1BQWQsQ0FBcUIsQ0FBOUIsRUFBaUMsY0FBYyxNQUFkLENBQXFCLENBQXRELElBQTJELEtBQUsseUJBQUwsRUFBOUQsQ0FBekI7QUFDSDtBQUNKO0FBQ0osS0F6ZStDOztBQTJlaEQ7Ozs7QUFJQSxvQkFBZ0Isd0JBQVMsSUFBVCxFQUFlO0FBQzNCLFlBQU0sZ0JBQWdCLEtBQUssY0FBTCxDQUFvQixnQkFBcEIsRUFBdEI7QUFDQSxZQUFNLG9CQUFvQixLQUFLLFFBQUwsQ0FBYyxTQUFkLENBQXdCLHNCQUF4QixFQUExQjs7QUFFQSxZQUFJLENBQUMsS0FBSywwQkFBTCxDQUFnQyxJQUFoQyxFQUFzQyxhQUF0QyxDQUFELElBQ0csS0FBSyxnQ0FBTCxDQUFzQyxJQUF0QyxFQUE0QyxhQUE1QyxDQURILElBRUcsY0FBYyxNQUFkLENBQXFCLENBQXJCLEdBQXlCLEtBQUssUUFBTCxDQUFjLFNBQWQsQ0FBd0IseUJBQXhCLEVBRjVCLElBR0csS0FBSyxVQUFMLENBQWdCLHNDQUh2QixFQUcrRDtBQUMzRCxpQkFBSyxnQkFBTCxDQUFzQixDQUF0QixFQUF5QixLQUFLLFdBQUwsS0FBcUIsY0FBYyxnQkFBZCxDQUErQixDQUE3RTtBQUNILFNBTEQsTUFLTztBQUNILGdCQUFJLEtBQUsscUNBQUwsQ0FBMkMsSUFBM0MsRUFBaUQsYUFBakQsS0FDRyxDQUFDLEtBQUssaUNBQUwsQ0FBdUMsSUFBdkMsRUFBNkMsYUFBN0MsQ0FESixJQUVHLENBQUMsS0FBSyxVQUFMLENBQWdCLGlDQUZ4QixFQUUyRDtBQUN2RCxxQkFBSyxnQkFBTCxDQUFzQixDQUF0QixFQUF5QixLQUFLLHlCQUFMLEtBQW1DLGNBQWMsZ0JBQWQsQ0FBK0IsQ0FBM0Y7QUFDSCxhQUpELE1BSU87QUFDSCxxQkFBSyxnQkFBTCxDQUFzQixDQUF0QixFQUF5QixvQkFBb0IsY0FBYyxnQkFBZCxDQUErQixDQUE1RTtBQUNIO0FBQ0o7QUFDSixLQWpnQitDOztBQW1nQmhEOzs7O0FBSUEscUJBQWlCLHlCQUFTLElBQVQsRUFBZTtBQUM1QixZQUFNLGdCQUFnQixLQUFLLGNBQUwsQ0FBb0IsZ0JBQXBCLEVBQXRCO0FBQ0EsWUFBTSx1QkFBdUIsS0FBSyxRQUFMLENBQWMsU0FBZCxDQUF3Qix5QkFBeEIsRUFBN0I7O0FBRUEsWUFBSSxDQUFDLEtBQUssMEJBQUwsQ0FBZ0MsSUFBaEMsRUFBc0MsYUFBdEMsQ0FBRCxJQUNHLEtBQUssbUNBQUwsQ0FBeUMsSUFBekMsRUFBK0MsYUFBL0MsQ0FEUCxFQUNzRTtBQUNsRSxpQkFBSyxnQkFBTCxDQUF1QixLQUFLLGNBQUwsS0FBd0IsY0FBYyxNQUFkLENBQXFCLENBQXBFLEVBQXdFLENBQXhFO0FBQ0gsU0FIRCxNQUdPO0FBQ0gsaUJBQUssZ0JBQUwsQ0FBd0IsdUJBQXVCLENBQXhCLEdBQTZCLGNBQWMsTUFBZCxDQUFxQixDQUF6RSxFQUE2RSxDQUE3RTtBQUNIO0FBQ0osS0FqaEIrQzs7QUFtaEJoRDs7OztBQUlBLG9CQUFnQix3QkFBUyxJQUFULEVBQWU7QUFDM0IsWUFBTSxnQkFBZ0IsS0FBSyxjQUFMLENBQW9CLGdCQUFwQixFQUF0QjtBQUNBLFlBQU0sdUJBQXVCLEtBQUssUUFBTCxDQUFjLFNBQWQsQ0FBd0IseUJBQXhCLEVBQTdCOztBQUVBLFlBQUksS0FBSywwQkFBTCxDQUFnQyxJQUFoQyxFQUFzQyxhQUF0QyxLQUNHLEtBQUssbUNBQUwsQ0FBeUMsSUFBekMsRUFBK0MsYUFBL0MsQ0FEUCxFQUNzRTtBQUNsRSxpQkFBSyxnQkFBTCxDQUFzQixDQUFDLGNBQWMsTUFBZCxDQUFxQixDQUE1QyxFQUErQyxDQUEvQztBQUNILFNBSEQsTUFHTztBQUNILGlCQUFLLGdCQUFMLENBQXNCLEVBQUUsY0FBYyxNQUFkLENBQXFCLENBQXJCLElBQTBCLHVCQUF1QixDQUFqRCxDQUFGLENBQXRCLEVBQThFLENBQTlFO0FBQ0g7QUFDSixLQWppQitDOztBQW1pQmhEOzs7O0FBSUEsdUJBQW1CLDJCQUFTLElBQVQsRUFBZTtBQUM5QixZQUFNLGdCQUFnQixLQUFLLGNBQUwsQ0FBb0IsZ0JBQXBCLEVBQXRCO0FBQ0EsWUFBTSxvQkFBb0IsS0FBSyxRQUFMLENBQWMsU0FBZCxDQUF3QixzQkFBeEIsRUFBMUI7O0FBR0EsWUFBSSxDQUFDLEtBQUssMEJBQUwsQ0FBZ0MsSUFBaEMsRUFBc0MsYUFBdEMsQ0FBRCxJQUNHLEtBQUssVUFBTCxDQUFnQixzQ0FEdkIsRUFDK0Q7QUFDM0QsZ0JBQUksY0FBYyxNQUFkLENBQXFCLENBQXJCLElBQTBCLEtBQUssUUFBTCxDQUFjLFNBQWQsQ0FBd0IseUJBQXhCLEVBQTFCLElBQ0csS0FBSyxVQUFMLENBQWdCLHNDQUR2QixFQUMrRDtBQUMzRCxxQkFBSyxlQUFMLENBQXFCLElBQXJCLEVBQTJCLENBQTNCLEVBQThCLENBQUUsS0FBSyxHQUFMLENBQVMsY0FBYyxNQUFkLENBQXFCLENBQTlCLEVBQWlDLGNBQWMsTUFBZCxDQUFxQixDQUF0RCxDQUFoQztBQUNILGFBSEQsTUFHTztBQUNILHFCQUFLLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsQ0FBM0IsRUFBOEIsRUFBRyxLQUFLLEdBQUwsQ0FBUyxjQUFjLE1BQWQsQ0FBcUIsQ0FBOUIsRUFBaUMsY0FBYyxNQUFkLENBQXFCLENBQXRELElBQTJELGlCQUE5RCxDQUE5QjtBQUNIO0FBQ0osU0FSRCxNQVFPO0FBQ0gsZ0JBQUksS0FBSyxxQ0FBTCxDQUEyQyxJQUEzQyxFQUFpRCxhQUFqRCxLQUNHLEtBQUssaUNBQUwsQ0FBdUMsSUFBdkMsRUFBNkMsYUFBN0MsQ0FESCxJQUVHLEtBQUssVUFBTCxDQUFnQixpQ0FGdkIsRUFFMEQ7QUFDdEQscUJBQUssZUFBTCxDQUFxQixJQUFyQixFQUEyQixDQUEzQixFQUE4QixDQUFFLEtBQUssR0FBTCxDQUFTLGNBQWMsTUFBZCxDQUFxQixDQUE5QixFQUFpQyxjQUFjLE1BQWQsQ0FBcUIsQ0FBdEQsQ0FBaEM7QUFDSCxhQUpELE1BSU87QUFDSCxxQkFBSyxlQUFMLENBQXFCLElBQXJCLEVBQTJCLENBQTNCLEVBQThCLEVBQUcsS0FBSyxHQUFMLENBQVMsY0FBYyxNQUFkLENBQXFCLENBQTlCLEVBQWlDLGNBQWMsTUFBZCxDQUFxQixDQUF0RCxJQUEyRCxLQUFLLHlCQUFMLEVBQTlELENBQTlCO0FBQ0g7QUFDSjtBQUNKLEtBN2pCK0M7O0FBK2pCaEQ7Ozs7QUFJQSx5QkFBcUIsNkJBQVMsSUFBVCxFQUFlO0FBQ2hDLFlBQU0sZ0JBQWdCLEtBQUssY0FBTCxDQUFvQixnQkFBcEIsRUFBdEI7QUFDQSxZQUFNLG9CQUFvQixLQUFLLFFBQUwsQ0FBYyxTQUFkLENBQXdCLHNCQUF4QixFQUExQjs7QUFFQSxZQUFJLENBQUMsS0FBSywwQkFBTCxDQUFnQyxJQUFoQyxFQUFzQyxhQUF0QyxDQUFELElBQ0csS0FBSyxnQ0FBTCxDQUFzQyxJQUF0QyxFQUE0QyxhQUE1QyxDQURILElBRUcsY0FBYyxNQUFkLENBQXFCLENBQXJCLEdBQXlCLEtBQUssUUFBTCxDQUFjLFNBQWQsQ0FBd0IseUJBQXhCLEVBRjVCLElBR0csS0FBSyxVQUFMLENBQWdCLHNDQUh2QixFQUcrRDtBQUMzRCxpQkFBSyxlQUFMLENBQXFCLElBQXJCLEVBQTJCLENBQTNCLEVBQThCLEtBQUssV0FBTCxLQUFxQixjQUFjLGdCQUFkLENBQStCLENBQWxGO0FBQ0gsU0FMRCxNQUtPO0FBQ0gsaUJBQUssZUFBTCxDQUFxQixJQUFyQixFQUEyQixDQUEzQixFQUE4QixvQkFBb0IsY0FBYyxnQkFBZCxDQUErQixDQUFqRjtBQUNIO0FBQ0osS0Eva0IrQzs7QUFpbEJoRDs7OztBQUlBLDBCQUFzQiw4QkFBUyxJQUFULEVBQWU7QUFDakMsWUFBTSxnQkFBZ0IsS0FBSyxjQUFMLENBQW9CLGdCQUFwQixFQUF0QjtBQUNBLFlBQU0sdUJBQXVCLEtBQUssUUFBTCxDQUFjLFNBQWQsQ0FBd0IseUJBQXhCLEVBQTdCOztBQUVBLFlBQUksQ0FBQyxLQUFLLDBCQUFMLENBQWdDLElBQWhDLEVBQXNDLGFBQXRDLENBQUQsSUFDRyxLQUFLLG1DQUFMLENBQXlDLElBQXpDLEVBQStDLGFBQS9DLENBRFAsRUFDc0U7QUFDbEUsaUJBQUssZUFBTCxDQUFxQixJQUFyQixFQUE0QixLQUFLLGNBQUwsS0FBd0IsY0FBYyxNQUFkLENBQXFCLENBQXpFLEVBQTZFLENBQTdFO0FBQ0gsU0FIRCxNQUdPO0FBQ0gsaUJBQUssZUFBTCxDQUFxQixJQUFyQixFQUE2Qix1QkFBdUIsQ0FBeEIsR0FBNkIsY0FBYyxNQUFkLENBQXFCLENBQTlFLEVBQWtGLENBQWxGO0FBQ0g7QUFDSixLQS9sQitDOztBQWltQmhEOzs7O0FBSUEseUJBQXFCLDZCQUFTLElBQVQsRUFBZTtBQUNoQyxZQUFNLGdCQUFnQixLQUFLLGNBQUwsQ0FBb0IsZ0JBQXBCLEVBQXRCO0FBQ0EsWUFBTSx1QkFBdUIsS0FBSyxRQUFMLENBQWMsU0FBZCxDQUF3Qix5QkFBeEIsRUFBN0I7O0FBRUEsWUFBSSxLQUFLLDBCQUFMLENBQWdDLElBQWhDLEVBQXNDLGFBQXRDLEtBQ0csS0FBSyxtQ0FBTCxDQUF5QyxJQUF6QyxFQUErQyxhQUEvQyxDQURQLEVBQ3NFO0FBQ2xFLGlCQUFLLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsQ0FBQyxjQUFjLE1BQWQsQ0FBcUIsQ0FBakQsRUFBb0QsQ0FBcEQ7QUFDSCxTQUhELE1BR087QUFDSCxpQkFBSyxlQUFMLENBQXFCLElBQXJCLEVBQTJCLEVBQUUsY0FBYyxNQUFkLENBQXFCLENBQXJCLElBQTBCLHVCQUF1QixDQUFqRCxDQUFGLENBQTNCLEVBQW1GLENBQW5GO0FBQ0g7QUFDSixLQS9tQitDOztBQWluQmhEOzs7OztBQUtBLGdCQUFZLG9CQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQzlCO0FBQ0EsY0FBTSxjQUFOLENBQXFCLGNBQXJCOztBQUVBLFlBQU0sUUFBUSxLQUFLLHlCQUFMLEVBQWQ7QUFDQSxhQUFLLGdCQUFMLENBQXNCLENBQXRCLEVBQXlCLEtBQXpCO0FBQ0gsS0E1bkIrQzs7QUE4bkJoRDs7Ozs7QUFLQSxjQUFVLGtCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQzVCO0FBQ0EsY0FBTSxjQUFOLENBQXFCLGNBQXJCOztBQUVBLFlBQU0sUUFBUSxLQUFLLHlCQUFMLEVBQWQ7QUFDQSxhQUFLLGdCQUFMLENBQXNCLENBQXRCLEVBQXlCLENBQUMsS0FBMUI7QUFDSCxLQXpvQitDOztBQTJvQmhEOzs7O0FBSUEsZ0JBQVksb0JBQVMsSUFBVCxFQUFlO0FBQ3ZCLGFBQUssZ0JBQUwsQ0FBc0IsQ0FBQyxDQUF2QixFQUEwQixDQUExQjtBQUNILEtBanBCK0M7O0FBbXBCaEQ7Ozs7QUFJQSxpQkFBYSxxQkFBUyxJQUFULEVBQWU7QUFDeEIsYUFBSyxnQkFBTCxDQUFzQixDQUF0QixFQUF5QixDQUF6QjtBQUNILEtBenBCK0M7O0FBMnBCaEQ7Ozs7O0FBS0EsK0JBQTJCLHFDQUFXO0FBQ2xDLFlBQU0sVUFBVSxLQUFLLHFCQUFMLEtBQStCLElBQS9DO0FBQ0EsZUFBTyxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksS0FBSyxLQUFMLENBQVcsVUFBVSxPQUFWLEdBQW9CLE9BQXBCLEdBQThCLE9BQXpDLENBQVosQ0FBUDtBQUNILEtBbnFCK0M7O0FBcXFCaEQ7Ozs7QUFJQSw0QkFBd0Isa0NBQVc7QUFDL0IsYUFBSyxXQUFMLEdBQW1CLEtBQUssR0FBTCxFQUFuQjtBQUNILEtBM3FCK0M7O0FBNnFCaEQ7Ozs7QUFJQSxvQkFBZ0IsMEJBQVc7QUFDdkIsWUFBTSxNQUFNLEtBQUssR0FBTCxFQUFaO0FBQ0EsWUFBSSxNQUFNLEtBQUssVUFBWCxHQUF3QixHQUE1QixFQUFpQztBQUM3QixpQkFBSyxzQkFBTDtBQUNIO0FBQ0QsYUFBSyxVQUFMLEdBQWtCLEtBQUssR0FBTCxFQUFsQjtBQUNILEtBdnJCK0M7O0FBeXJCaEQ7Ozs7O0FBS0EsMkJBQXVCLGlDQUFXO0FBQzlCLFlBQUksS0FBSyxHQUFMLEtBQWEsS0FBSyxVQUFsQixHQUErQixHQUFuQyxFQUF3QztBQUNwQyxtQkFBTyxDQUFQO0FBQ0g7QUFDRCxlQUFPLEtBQUssR0FBTCxLQUFhLEtBQUssV0FBekI7QUFDSCxLQW5zQitDOztBQXFzQmhEOzs7Ozs7O0FBT0EscUJBQWlCLHlCQUFTLElBQVQsRUFBZSxPQUFmLEVBQXdCLE9BQXhCLEVBQWlDO0FBQzlDLFlBQUksS0FBSyxZQUFMLENBQWtCLE9BQWxCLEVBQTJCLE9BQTNCLENBQUosRUFBeUM7QUFDckMsaUJBQUssY0FBTDtBQUNIO0FBQ0o7O0FBaHRCK0MsQ0FBaEMsQ0FBcEI7O0FBb3RCQSxPQUFPLE9BQVAsR0FBaUIsYUFBakI7OztBQzV0QkE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJLFVBQVUsUUFBUSxXQUFSLENBQWQ7O0FBRUEsSUFBSSxPQUFKO0FBQ0EsSUFBSSxVQUFKO0FBQ0EsSUFBSSxXQUFKO0FBQ0EsSUFBSSxjQUFKOztBQUVBLElBQUksT0FBTyxDQUFDLE1BQUQsRUFBUyxXQUFULEVBQXNCLGNBQXRCLENBQVg7QUFBQSxJQUNJLFdBQVcsQ0FBQyxVQUFELEVBQWEsZUFBYixFQUE4QixrQkFBOUIsQ0FEZjs7QUFHQTs7OztBQUlBLElBQUksaUJBQWlCLFFBQVEsTUFBUixDQUFlLGdCQUFmLEVBQWlDO0FBQ2xEOzs7O0FBSUEsY0FBVSxLQUx3Qzs7QUFPbEQ7Ozs7O0FBS0EsZ0JBQVksQ0Fac0M7O0FBY2xEOzs7OztBQUtBLGlDQUE2QixDQUFDLENBbkJvQjs7QUFxQmxEOzs7Ozs7QUFNQSx3QkFBb0IsNEJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDdEMsYUFBSywwQkFBTCxDQUFnQyxJQUFoQzs7QUFFQSxZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLGtCQUFWLENBQTZCLElBQTdCO0FBQ0g7QUFDSixLQWpDaUQ7QUFrQ2xEOzs7OztBQUtBLGdDQUE0QixvQ0FBUyxJQUFULEVBQWU7QUFDdkMsYUFBSyxxQkFBTCxDQUEyQixJQUEzQjtBQUNBLFlBQUksQ0FBQyxXQUFMLEVBQWtCO0FBQ2QsMEJBQWMsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBQWQ7QUFDQSx3QkFBWSxZQUFaLENBQXlCLE9BQXpCLEVBQWtDLEtBQWxDO0FBQ0Esd0JBQVksWUFBWixDQUF5QixRQUF6QixFQUFtQyxLQUFuQztBQUNBLHdCQUFZLEtBQVosQ0FBa0IsUUFBbEIsR0FBNkIsT0FBN0I7O0FBRUEscUJBQVMsSUFBVCxDQUFjLFdBQWQsQ0FBMEIsV0FBMUI7QUFDQSw2QkFBaUIsWUFBWSxVQUFaLENBQXVCLElBQXZCLEVBQTZCLEVBQUUsT0FBTyxLQUFULEVBQTdCLENBQWpCO0FBQ0g7QUFDSixLQWxEaUQ7O0FBb0RsRDs7Ozs7QUFLQSxxQkFBaUIseUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDbkMsWUFBSSxLQUFLLElBQVQsRUFBZTtBQUNYLGlCQUFLLElBQUwsQ0FBVSxlQUFWLENBQTBCLElBQTFCLEVBQWdDLEtBQWhDO0FBQ0g7QUFDSixLQTdEaUQ7O0FBK0RsRDs7Ozs7QUFLQSxxQkFBaUIseUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDbkMsWUFBSSxLQUFLLElBQVQsRUFBZTtBQUNYLGlCQUFLLElBQUwsQ0FBVSxlQUFWLENBQTBCLElBQTFCLEVBQWdDLEtBQWhDO0FBQ0g7QUFDSixLQXhFaUQ7O0FBMEVsRDs7Ozs7QUFLQSxtQkFBZSx1QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNqQyxZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLGFBQVYsQ0FBd0IsSUFBeEIsRUFBOEIsS0FBOUI7QUFDSDtBQUNKLEtBbkZpRDs7QUFxRmxEOzs7OztBQUtBLHFCQUFpQix5QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNuQyxZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLGVBQVYsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBaEM7QUFDSDtBQUNKLEtBOUZpRDs7QUFnR2xELDhCQUEwQixrQ0FBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUM1QyxhQUFLLFFBQUw7QUFDQSxhQUFLLFdBQUwsQ0FBaUIsSUFBakIsRUFBdUIsS0FBSywyQkFBTCxDQUFpQyxJQUFqQyxDQUF2QixFQUErRCxLQUEvRDs7QUFFQSxZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLHdCQUFWLENBQW1DLElBQW5DLEVBQXlDLEtBQXpDO0FBQ0g7QUFDSixLQXZHaUQ7O0FBeUdsRDs7Ozs7OztBQU9BLGlCQUFhLHFCQUFTLElBQVQsRUFBZSxDQUFmLEVBQWtCLHFCQUFsQixFQUF5QztBQUNsRCxnQ0FBd0IsT0FBTyxxQkFBUCxLQUFpQyxXQUFqQyxHQUErQyxxQkFBL0MsR0FBdUUsSUFBL0Y7QUFDQSxnQkFBUSxLQUFSLENBQWMsSUFBZCxHQUFxQixJQUFJLEtBQUssTUFBTCxDQUFZLElBQVosQ0FBaUIsSUFBckIsR0FBNEIsSUFBakQ7O0FBRUEsWUFBSSxxQkFBSixFQUEyQjtBQUN2QixnQkFBSSxxQkFBcUIsS0FBSyxxQkFBTCxDQUEyQixJQUEzQixFQUFpQyxDQUFqQyxDQUF6QjtBQUNBLGdCQUFLLHVCQUF1QixTQUF4QixJQUFzQyx1QkFBdUIsS0FBSywyQkFBdEUsRUFBbUc7QUFDL0YscUJBQUssaUJBQUwsQ0FBdUIsSUFBdkIsRUFBNkIsa0JBQTdCO0FBQ0EscUJBQUssMkJBQUwsR0FBbUMsa0JBQW5DO0FBQ0g7QUFDSjtBQUNKLEtBM0hpRDs7QUE2SGxEOzs7Ozs7QUFNQSx1QkFBbUIsMkJBQVMsSUFBVCxFQUFlLE1BQWYsRUFBdUI7QUFDdEMsb0JBQVksS0FBWixDQUFrQixPQUFsQixHQUE0QixRQUE1Qjs7QUFFQSxZQUFJLFlBQVksS0FBSyxxQkFBTCxDQUEyQixJQUEzQixFQUFpQyxNQUFqQyxDQUFoQjs7QUFFQSxvQkFBWSxLQUFaLENBQWtCLElBQWxCLEdBQXlCLFlBQVksSUFBckM7QUFDSCxLQXpJaUQ7O0FBMklsRDs7Ozs7QUFLQSx1QkFBbUIsMkJBQVMsSUFBVCxFQUFlO0FBQzlCLFlBQUksUUFBUSxLQUFLLFVBQUwsQ0FBZ0IsZ0JBQTVCO0FBQ0EsWUFBSSxhQUFhLEtBQUssR0FBTCxDQUFTLFlBQTFCO0FBQ0EsWUFBSSxZQUFZLEtBQUssUUFBTCxDQUFjLGNBQWQsQ0FBaEI7QUFDQSxZQUFJLGVBQWUsS0FBSyxZQUFMLENBQWtCLENBQWxCLENBQW5COztBQUVBLFlBQUksV0FBVyxLQUFLLEdBQUwsQ0FBUyxxQkFBVCxFQUFmOztBQUVBLG9CQUFZLEtBQVosQ0FBa0IsR0FBbEIsR0FBd0IsU0FBUyxHQUFULEdBQWUsSUFBdkM7QUFDQSxvQkFBWSxZQUFaLENBQXlCLE9BQXpCLEVBQWtDLEtBQUssS0FBTCxDQUFXLFFBQVEsU0FBbkIsSUFBZ0MsSUFBbEU7QUFDQSxvQkFBWSxZQUFaLENBQXlCLFFBQXpCLEVBQW1DLEtBQUssS0FBTCxDQUFXLGFBQWEsU0FBeEIsSUFBcUMsSUFBeEU7QUFDQSxvQkFBWSxLQUFaLENBQWtCLE9BQWxCLEdBQTRCLFFBQTVCOztBQUVBLHVCQUFlLFNBQWYsQ0FBeUIsQ0FBekIsRUFBNEIsQ0FBNUIsRUFBK0IsS0FBL0IsRUFBc0MsVUFBdEM7QUFDQSx1QkFBZSxTQUFmLEdBQTJCLEtBQUssVUFBTCxDQUFnQixvQ0FBM0M7QUFDQSx1QkFBZSxRQUFmLENBQXdCLENBQXhCLEVBQTJCLENBQTNCLEVBQThCLEtBQTlCLEVBQXFDLFlBQXJDO0FBQ0EsdUJBQWUsU0FBZixHQUEyQixLQUFLLFVBQUwsQ0FBZ0Isa0NBQTNDO0FBQ0EsdUJBQWUsUUFBZixDQUF3QixDQUF4QixFQUEyQixZQUEzQixFQUF5QyxLQUF6QyxFQUFnRCxVQUFoRDs7QUFFQSx1QkFBZSxLQUFmLENBQXFCLFNBQXJCLEVBQWdDLFNBQWhDOztBQUVBLG9CQUFZLEtBQVosQ0FBa0IsTUFBbEIsR0FBMkIsR0FBM0I7O0FBRUEsYUFBSyxpQkFBTCxDQUF1QixJQUF2QixFQUE2QixLQUFLLG1CQUFMLEVBQTdCO0FBQ0gsS0F4S2lEOztBQTBLbEQ7Ozs7Ozs7QUFPQSw2QkFBeUIsaUNBQVMsT0FBVCxFQUFrQixRQUFsQixFQUE0QixLQUE1QixFQUFtQztBQUN4RCxZQUFJLFlBQVksU0FBUyxDQUFULEVBQVksV0FBWixLQUE0QixTQUFTLE1BQVQsQ0FBZ0IsQ0FBaEIsQ0FBNUM7QUFDQSxhQUFLLE9BQUwsQ0FBYSxPQUFiLEVBQXNCLFdBQVcsU0FBakMsRUFBNEMsS0FBNUM7QUFDQSxhQUFLLE9BQUwsQ0FBYSxPQUFiLEVBQXNCLFFBQVEsU0FBOUIsRUFBeUMsS0FBekM7QUFDQSxhQUFLLE9BQUwsQ0FBYSxPQUFiLEVBQXNCLE9BQU8sU0FBN0IsRUFBd0MsS0FBeEM7QUFDQSxhQUFLLE9BQUwsQ0FBYSxPQUFiLEVBQXNCLE1BQU0sU0FBNUIsRUFBdUMsS0FBdkM7QUFDQSxhQUFLLE9BQUwsQ0FBYSxPQUFiLEVBQXNCLFFBQXRCLEVBQWdDLEtBQWhDO0FBQ0gsS0F4TGlEOztBQTBMbEQ7Ozs7O0FBS0EsMkJBQXVCLCtCQUFTLElBQVQsRUFBZTtBQUNsQyxZQUFJLEtBQUssUUFBVCxFQUFtQjtBQUNmO0FBQ0g7O0FBRUQsYUFBSyxnQkFBTCxHQUF3QixLQUFLLFVBQUwsQ0FBZ0IsZ0JBQXhDOztBQUVBLFlBQUksQ0FBQyxPQUFMLEVBQWM7QUFDVixzQkFBVSxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBVjtBQUNBLHlCQUFhLFFBQVEsVUFBUixDQUFtQixJQUFuQixFQUF5QixFQUFFLE9BQU8sS0FBVCxFQUF6QixDQUFiO0FBQ0EscUJBQVMsSUFBVCxDQUFjLFdBQWQsQ0FBMEIsT0FBMUI7QUFDSDs7QUFFRCxZQUFJLFFBQVEsS0FBSyxnQkFBakI7QUFDQSxZQUFJLFNBQVMsS0FBSywyQkFBTCxDQUFpQyxJQUFqQyxDQUFiOztBQUVBLFlBQUksZUFBZSxLQUFLLFlBQUwsQ0FBa0IsQ0FBbEIsQ0FBbkI7QUFDQSxZQUFJLGFBQWEsS0FBSyxHQUFMLENBQVMsWUFBMUI7O0FBRUEsWUFBSSxZQUFZLEtBQUssUUFBTCxDQUFjLFVBQWQsQ0FBaEI7QUFDQSxZQUFJLFdBQVcsS0FBSyxHQUFMLENBQVMscUJBQVQsRUFBZjs7QUFFQSxnQkFBUSxZQUFSLENBQXFCLE9BQXJCLEVBQStCLFFBQVEsU0FBVCxHQUFzQixJQUFwRDtBQUNBLGdCQUFRLFlBQVIsQ0FBcUIsUUFBckIsRUFBZ0MsYUFBYSxTQUFkLEdBQTJCLElBQTFEO0FBQ0EsZ0JBQVEsS0FBUixDQUFjLFFBQWQsR0FBeUIsT0FBekI7QUFDQSxnQkFBUSxLQUFSLENBQWMsR0FBZCxHQUFvQixTQUFTLEdBQVQsR0FBZSxJQUFuQztBQUNBLGdCQUFRLEtBQVIsQ0FBYyxJQUFkLEdBQXFCLFNBQVMsSUFBOUI7QUFDQSxnQkFBUSxLQUFSLENBQWMsT0FBZCxHQUF3QixRQUF4Qjs7QUFFQSxtQkFBVyxTQUFYLENBQXFCLENBQXJCLEVBQXdCLENBQXhCLEVBQTJCLEtBQTNCLEVBQWtDLFVBQWxDO0FBQ0EsbUJBQVcsU0FBWCxHQUF1QixLQUFLLFVBQUwsQ0FBZ0Isd0NBQXZDO0FBQ0EsbUJBQVcsUUFBWCxDQUFvQixDQUFwQixFQUF1QixDQUF2QixFQUEwQixLQUExQixFQUFpQyxZQUFqQzs7QUFFQSxZQUFJLE9BQU8sSUFBWDtBQUNBLGdCQUFRLFlBQVIsR0FBdUIsVUFBUyxLQUFULEVBQWdCO0FBQ25DLGdCQUFJLENBQUMsS0FBSyxRQUFWLEVBQW9CO0FBQ2hCLHNCQUFNLHdCQUFOO0FBQ0Esc0JBQU0sY0FBTjtBQUNBLHFCQUFLLE1BQUwsR0FBYyxJQUFkOztBQUVBLDJCQUFXLFNBQVgsQ0FBcUIsQ0FBckIsRUFBd0IsQ0FBeEIsRUFBMkIsS0FBM0IsRUFBa0MsVUFBbEM7QUFDQSwyQkFBVyxTQUFYLEdBQXVCLEtBQUssVUFBTCxDQUFnQix1Q0FBdkM7QUFDQSwyQkFBVyxRQUFYLENBQW9CLENBQXBCLEVBQXVCLENBQXZCLEVBQTBCLEtBQTFCLEVBQWlDLFlBQWpDO0FBQ0g7QUFDSixTQVZEOztBQVlBLGdCQUFRLFlBQVIsR0FBdUIsWUFBVztBQUM5QixnQkFBSSxDQUFDLEtBQUssUUFBVixFQUFvQjtBQUNoQixzQkFBTSx3QkFBTjtBQUNBLHNCQUFNLGNBQU47O0FBRUEscUJBQUssTUFBTCxHQUFjLElBQWQ7O0FBRUEsMkJBQVcsU0FBWCxDQUFxQixDQUFyQixFQUF3QixDQUF4QixFQUEyQixLQUEzQixFQUFrQyxVQUFsQztBQUNBLDJCQUFXLFNBQVgsR0FBdUIsS0FBSyxVQUFMLENBQWdCLHdDQUF2QztBQUNBLDJCQUFXLFFBQVgsQ0FBb0IsQ0FBcEIsRUFBdUIsQ0FBdkIsRUFBMEIsS0FBMUIsRUFBaUMsWUFBakM7QUFDSDtBQUNKLFNBWEQ7O0FBYUEsZ0JBQVEsV0FBUixHQUFzQixVQUFTLEtBQVQsRUFBZ0I7QUFDbEMsa0JBQU0sd0JBQU47QUFDQSxrQkFBTSxjQUFOO0FBQ0EsaUJBQUssTUFBTCxHQUFjLFFBQWQ7O0FBRUEsaUJBQUssUUFBTCxHQUFnQixJQUFoQjs7QUFFQSxpQkFBSyxtQkFBTCxDQUF5QixLQUFLLG1CQUFMLEVBQXpCLEVBQXFELEtBQUssZ0JBQUwsS0FBMEIsQ0FBL0U7O0FBRUEsaUJBQUssaUJBQUwsQ0FBdUIsSUFBdkI7QUFDQSxpQkFBSyxVQUFMLEdBQWtCLFFBQVEscUJBQVIsR0FBZ0MsSUFBbEQ7O0FBRUEsdUJBQVcsU0FBWCxDQUFxQixDQUFyQixFQUF3QixDQUF4QixFQUEyQixLQUEzQixFQUFrQyxVQUFsQztBQUNBLHVCQUFXLFNBQVgsR0FBdUIsS0FBSyxVQUFMLENBQWdCLHdDQUF2QztBQUNBLHVCQUFXLFFBQVgsQ0FBb0IsQ0FBcEIsRUFBdUIsQ0FBdkIsRUFBMEIsS0FBMUIsRUFBaUMsWUFBakM7QUFDQSx1QkFBVyxTQUFYLEdBQXVCLEtBQUssVUFBTCxDQUFnQixzQ0FBdkM7QUFDQSx1QkFBVyxRQUFYLENBQW9CLENBQXBCLEVBQXVCLFlBQXZCLEVBQXFDLEtBQXJDLEVBQTRDLFVBQTVDOztBQUVBLHFCQUFTLFdBQVQsR0FBdUIsVUFBUyxDQUFULEVBQVk7QUFDL0Isb0JBQUksT0FBTyxFQUFFLE9BQUYsR0FBYSxLQUFLLFVBQUwsQ0FBZ0IsZ0JBQWhCLEdBQW1DLENBQWhELEdBQXFELEtBQUssTUFBTCxDQUFZLElBQVosQ0FBaUIsSUFBakY7O0FBRUEscUJBQUssV0FBTCxDQUFpQixJQUFqQixFQUF1QixJQUF2QjtBQUNILGFBSkQ7QUFLQSxxQkFBUyxTQUFULEdBQXFCLFVBQVMsQ0FBVCxFQUFZO0FBQzdCLHlCQUFTLFdBQVQsR0FBdUIsSUFBdkI7QUFDQSx5QkFBUyxTQUFULEdBQXFCLElBQXJCOztBQUVBLG9CQUFJLEtBQUssUUFBVCxFQUFtQjtBQUNmLHlCQUFLLE1BQUwsR0FBYyxJQUFkO0FBQ0EseUJBQUssZUFBTCxDQUFxQixJQUFyQjtBQUNBLHlCQUFLLFFBQUw7QUFDQSx5QkFBSyxXQUFMLENBQWlCLElBQWpCLEVBQXVCLEtBQUssMkJBQUwsQ0FBaUMsSUFBakMsSUFBeUMsS0FBSyxNQUFMLENBQVksSUFBWixDQUFpQixJQUFqRixFQUF1RixLQUF2RjtBQUNIO0FBQ0QscUJBQUssUUFBTCxHQUFnQixLQUFoQjtBQUNBLHFCQUFLLE1BQUwsR0FBYyxJQUFkOztBQUVBLDJCQUFXLFNBQVgsQ0FBcUIsQ0FBckIsRUFBd0IsQ0FBeEIsRUFBMkIsS0FBM0IsRUFBa0MsVUFBbEM7QUFDQSwyQkFBVyxTQUFYLEdBQXVCLEtBQUssVUFBTCxDQUFnQix3Q0FBdkM7QUFDQSwyQkFBVyxRQUFYLENBQW9CLENBQXBCLEVBQXVCLENBQXZCLEVBQTBCLEtBQTFCLEVBQWlDLFlBQWpDO0FBQ0gsYUFoQkQ7QUFpQkgsU0F4Q0Q7QUF5Q0gsS0FuU2lEOztBQXFTbEQ7Ozs7O0FBS0EsaUNBQTZCLHFDQUFTLElBQVQsRUFBZTtBQUN4QyxlQUFPLEtBQUsscUJBQUwsQ0FBMkIsSUFBM0IsRUFBaUMsS0FBSyxVQUFMLENBQWdCLGdCQUFqRCxDQUFQO0FBQ0gsS0E1U2lEOztBQThTbEQ7Ozs7OztBQU1BLDJCQUF1QiwrQkFBUyxJQUFULEVBQWUsV0FBZixFQUE0QjtBQUMvQyxZQUFJLGNBQWMsQ0FBbEIsRUFBcUI7QUFDakIsMEJBQWMsQ0FBZDtBQUNIOztBQUVELFlBQUksTUFBSixFQUFZLEdBQVo7QUFDQSxZQUFJLGNBQWMsQ0FBbEIsRUFBcUI7QUFDakI7QUFDQSxxQkFBUyxLQUFLLFFBQUwsQ0FBYyxjQUFkLENBQTZCLGNBQWMsQ0FBM0MsQ0FBVDtBQUNBLGdCQUFJLENBQUMsTUFBTCxFQUFhO0FBQ1QseUJBQVMsS0FBSyxRQUFMLENBQWMsY0FBZCxDQUE2QixDQUE3QixDQUFUO0FBQ0g7QUFDRCxrQkFBTSxTQUFTLE9BQU8sS0FBaEIsR0FBd0IsQ0FBOUI7QUFDSCxTQVBELE1BT087QUFDSDtBQUNBLGtCQUFNLEtBQUssUUFBTCxDQUFjLGNBQWQsQ0FBNkIsQ0FBN0IsRUFBZ0MsSUFBaEMsR0FBdUMsS0FBSyxnQkFBbEQ7QUFDSDs7QUFFRCxlQUFPLE1BQU0sS0FBSyxNQUFMLENBQVksSUFBWixDQUFpQixJQUE5QjtBQUNILEtBdlVpRDs7QUF5VWxEOzs7OztBQUtBLHFCQUFpQix5QkFBUyxJQUFULEVBQWU7QUFDNUIsWUFBSSwwQkFBMEIsS0FBSyxVQUFMLENBQWdCLGdCQUE5QztBQUNBLGFBQUssYUFBTCxDQUFtQjtBQUNmLDhCQUFrQixLQUFLO0FBRFIsU0FBbkI7O0FBSUEsb0JBQVksS0FBWixDQUFrQixPQUFsQixHQUE0QixNQUE1Qjs7QUFFQSxhQUFLLDJDQUFMLENBQWlELHVCQUFqRCxFQUEwRSxLQUFLLDJCQUEvRTtBQUNILEtBdlZpRDs7QUF5VmxEOzs7Ozs7QUFNQSwyQkFBdUIsK0JBQVMsSUFBVCxFQUFlLENBQWYsRUFBa0I7QUFDckMsWUFBSSx5QkFBeUIsS0FBSyxRQUFMLENBQWMsbUJBQWQsQ0FBa0MsQ0FBbEMsQ0FBN0I7QUFDQSxZQUFJLGlCQUFpQixLQUFLLFFBQUwsQ0FBYyxjQUFuQzs7QUFFQSxZQUFJLE1BQU0sS0FBSyxzQkFBTCxFQUFWO0FBQ0EsWUFBSSxlQUFlLGVBQWUsS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLHNCQUFkLENBQWYsRUFBc0QsSUFBekU7QUFDQSxZQUFJLGFBQWEsZUFBZSxLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsc0JBQWQsQ0FBZixFQUFzRCxLQUF2RTs7QUFFQSxZQUFJLE1BQU0sc0JBQVY7O0FBRUEsWUFBSSxFQUFFLEtBQUssR0FBTCxDQUFTLGVBQWUsQ0FBeEIsSUFBNkIsS0FBSyxHQUFMLENBQVMsYUFBYSxDQUF0QixDQUEvQixDQUFKLEVBQThEO0FBQzFELG1CQUFPLENBQVA7QUFDSDs7QUFFRCxZQUFJLE9BQU8sZUFBZSxlQUFlLE1BQWYsR0FBd0IsQ0FBdkMsRUFBMEMsV0FBckQsRUFBa0U7QUFDOUQsa0JBQU0sZUFBZSxlQUFlLE1BQWYsR0FBd0IsQ0FBdkMsRUFBMEMsV0FBaEQ7QUFDSDs7QUFFRCxlQUFPLEdBQVA7QUFDSCxLQWxYaUQ7O0FBb1hsRCxhQUFTLGlCQUFTLE9BQVQsRUFBa0IsUUFBbEIsRUFBNEIsS0FBNUIsRUFBbUM7QUFDeEMsWUFBSSxZQUFZLFFBQVEsS0FBeEIsRUFBK0I7QUFDM0Isb0JBQVEsS0FBUixDQUFjLFFBQWQsSUFBMEIsS0FBMUI7QUFDSDtBQUNKO0FBeFhpRCxDQUFqQyxDQUFyQjs7QUEyWEEsT0FBTyxPQUFQLEdBQWlCLGNBQWpCOzs7QUM5WUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQU0sVUFBVSxRQUFRLFdBQVIsQ0FBaEI7O0FBRUEsSUFBTSxPQUFPLENBQUMsTUFBRCxFQUFTLFdBQVQsRUFBc0IsY0FBdEIsQ0FBYjtBQUFBLElBQ0ksV0FBVyxDQUFDLFVBQUQsRUFBYSxlQUFiLEVBQThCLGtCQUE5QixDQURmO0FBQUEsSUFFSSxVQUFVLFNBQVYsT0FBVSxDQUFTLElBQVQsRUFBZTtBQUFFLFNBQUssTUFBTCxHQUFjLElBQWQ7QUFBcUIsQ0FGcEQ7O0FBSUEsSUFBSSxnQkFBSjtBQUFBLElBQ0ksbUJBREo7QUFBQSxJQUVJLG9CQUZKO0FBQUEsSUFHSSx1QkFISjs7QUFLQTs7OztBQUlBLElBQU0sZUFBZSxRQUFRLE1BQVIsQ0FBZSxjQUFmLEVBQStCOztBQUVoRDs7Ozs7QUFLQSwyQkFBdUIsRUFQeUI7O0FBU2hEOzs7OztBQUtBLGtDQUE4QixLQWRrQjs7QUFnQmhEOzs7OztBQUtBLGlDQUE2QixLQXJCbUI7O0FBdUJoRDs7Ozs7QUFLQSxjQUFVLEtBNUJzQzs7QUE4QmhEOzs7OztBQUtBLGFBQVMsQ0FBQyxDQW5Dc0M7O0FBcUNoRDs7Ozs7QUFLQSxnQkFBWSxDQTFDb0M7O0FBNENoRCxvQkFBZ0IsRUE1Q2dDO0FBNkNoRCxvQkFBZ0IsR0E3Q2dDO0FBOENoRCxtQkFBZSxDQTlDaUM7O0FBZ0RoRDs7Ozs7QUFLQSxrQkFBYyxzQkFBUyxJQUFULEVBQWU7QUFDekIsYUFBSywwQkFBTCxDQUFnQyxJQUFoQztBQUNBLFlBQUksS0FBSyxJQUFULEVBQWU7QUFDWCxpQkFBSyxJQUFMLENBQVUsWUFBVixDQUF1QixJQUF2QjtBQUNIO0FBQ0osS0ExRCtDOztBQTREaEQ7Ozs7O0FBS0EsZ0NBQTRCLG9DQUFTLElBQVQsRUFBZTtBQUN2QyxZQUFJLENBQUMsT0FBTCxFQUFjO0FBQ1Ysc0JBQVUsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBQVY7QUFDQSxvQkFBUSxZQUFSLENBQXFCLE9BQXJCLEVBQThCLEtBQTlCO0FBQ0Esb0JBQVEsWUFBUixDQUFxQixRQUFyQixFQUErQixLQUEvQjtBQUNBLG9CQUFRLEtBQVIsQ0FBYyxRQUFkLEdBQXlCLE9BQXpCOztBQUVBLHFCQUFTLElBQVQsQ0FBYyxXQUFkLENBQTBCLE9BQTFCO0FBQ0EseUJBQWEsUUFBUSxVQUFSLENBQW1CLElBQW5CLEVBQXlCLEVBQUUsT0FBTyxJQUFULEVBQXpCLENBQWI7QUFDSDtBQUNELFlBQUksQ0FBQyxXQUFMLEVBQWtCO0FBQ2QsMEJBQWMsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBQWQ7QUFDQSx3QkFBWSxZQUFaLENBQXlCLE9BQXpCLEVBQWtDLEtBQWxDO0FBQ0Esd0JBQVksWUFBWixDQUF5QixRQUF6QixFQUFtQyxLQUFuQztBQUNBLHdCQUFZLEtBQVosQ0FBa0IsUUFBbEIsR0FBNkIsT0FBN0I7O0FBRUEscUJBQVMsSUFBVCxDQUFjLFdBQWQsQ0FBMEIsV0FBMUI7QUFDQSw2QkFBaUIsWUFBWSxVQUFaLENBQXVCLElBQXZCLEVBQTZCLEVBQUUsT0FBTyxJQUFULEVBQTdCLENBQWpCO0FBQ0g7QUFFSixLQXJGK0M7O0FBdUZoRDs7Ozs7QUFLQSxxQkFBaUIseUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7O0FBRW5DLFlBQUksTUFBTSxhQUFWLEVBQXlCO0FBQ3JCLGdCQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gscUJBQUssSUFBTCxDQUFVLGVBQVYsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBaEM7QUFDSDtBQUNEO0FBQ0g7O0FBRUYsWUFBSSxLQUFLLElBQVQsRUFBZTtBQUNWLGlCQUFLLElBQUwsQ0FBVSxlQUFWLENBQTBCLElBQTFCLEVBQWdDLEtBQWhDO0FBQ0g7O0FBRUQsWUFBSSxLQUFLLFFBQVQsRUFBbUI7QUFDZixpQkFBSyxVQUFMLENBQWdCLElBQWhCLEVBQXNCLEtBQXRCO0FBQ0g7QUFDSixLQTVHK0M7O0FBOEdoRDs7Ozs7QUFLQSxxQkFBaUIseUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDbkMsWUFDSSxLQUFLLFFBQUwsQ0FBYyxtQkFBZCxNQUNBLENBQUMsTUFBTSxhQURQLElBRUEsTUFBTSxZQUZOLElBR0EsQ0FBQyxNQUFNLGFBSFAsSUFJQSxDQUFDLE1BQU0sY0FBTixDQUFxQixNQUFyQixDQUE0QixZQUxqQyxFQU1FO0FBQ0U7QUFDQSxnQkFBTSxXQUFXLE1BQU0sUUFBdkI7QUFDQSxpQkFBSyxNQUFMLEdBQWMsUUFBZDtBQUNBLGlCQUFLLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxpQkFBSyxPQUFMLEdBQWUsU0FBUyxDQUF4Qjs7QUFFQSxnQkFBTSxzQkFBc0IsS0FBSyxrQkFBTCxHQUEwQixDQUExQixLQUN4QixLQUFLLFFBQUwsQ0FBYyxjQUFkLENBQTZCLFNBQTdCLENBQXVDLFVBQVMsQ0FBVCxFQUFZO0FBQUMsdUJBQU8sRUFBRSxNQUFGLEtBQWEsTUFBTSxNQUExQjtBQUFrQyxhQUF0RixDQURKO0FBRUEsZ0JBQU0sZ0JBQWdCLEtBQUssZUFBTCxFQUF0QjtBQUNBLGdCQUFNLHVCQUF1QixLQUFLLFFBQUwsQ0FBYyxjQUFkLENBQTZCLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxzQkFBc0IsYUFBbEMsQ0FBN0IsRUFBK0UsSUFBNUc7O0FBRUEsaUJBQUssVUFBTCxHQUFrQixNQUFNLGNBQU4sQ0FBcUIsTUFBckIsQ0FBNEIsS0FBNUIsQ0FBa0MsQ0FBbEMsR0FBc0Msb0JBQXhEOztBQUVBLGlCQUFLLFdBQUw7QUFDQSxpQkFBSyxnQkFBTCxDQUFzQixJQUF0QixFQUE0QixLQUFLLE9BQWpDO0FBQ0EsaUJBQUssaUJBQUwsQ0FBdUIsSUFBdkIsRUFBNkIsS0FBSyxPQUFsQztBQUNBLGlCQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsRUFBc0IsS0FBdEI7QUFDSDtBQUNELFlBQUksS0FBSyxJQUFULEVBQWU7QUFDWCxpQkFBSyxJQUFMLENBQVUsZUFBVixDQUEwQixJQUExQixFQUFnQyxLQUFoQztBQUNIO0FBQ0osS0FoSitDOztBQWtKaEQ7Ozs7O0FBS0EsbUJBQWUsdUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDakM7QUFDQSxZQUFJLEtBQUssUUFBVCxFQUFtQjtBQUNmLGlCQUFLLE1BQUwsR0FBYyxJQUFkO0FBQ0E7QUFDQSxnQkFBTSxPQUFPLElBQWI7QUFDQSxpQkFBSyxhQUFMLENBQW1CLElBQW5CO0FBQ0EsdUJBQVcsWUFBVztBQUNsQixxQkFBSyxXQUFMO0FBQ0gsYUFGRCxFQUVHLEdBRkg7QUFHSDtBQUNELGFBQUssT0FBTCxHQUFlLENBQUMsQ0FBaEI7QUFDQSxhQUFLLFFBQUwsR0FBZ0IsS0FBaEI7QUFDQSxhQUFLLE1BQUwsR0FBYyxJQUFkO0FBQ0EsYUFBSyxPQUFMOztBQUVBLFlBQUksS0FBSyxJQUFULEVBQWU7QUFDWCxpQkFBSyxJQUFMLENBQVUsYUFBVixDQUF3QixJQUF4QixFQUE4QixLQUE5QjtBQUNIO0FBRUosS0EzSytDOztBQTZLaEQ7Ozs7O0FBS0EscUJBQWlCLHlCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ25DLFlBQ0ksTUFBTSxnQkFBTixJQUNBLEtBQUssUUFBTCxDQUFjLG1CQUFkLEVBREEsSUFFQSxDQUFDLE1BQU0sYUFGUCxJQUdBLENBQUMsS0FBSyxRQUhOLElBSUEsTUFBTTtBQUNOO0FBTkosVUFPRTtBQUNFLHFCQUFLLE1BQUwsR0FBYyxJQUFkO0FBQ0gsYUFURCxNQVNPO0FBQ0gsaUJBQUssTUFBTCxHQUFjLElBQWQ7QUFDSDs7QUFFRCxZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLGVBQVYsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBaEM7QUFDSDs7QUFFRCxZQUFJLE1BQU0sWUFBTixJQUFzQixLQUFLLFFBQS9CLEVBQXlDO0FBQ3JDLGlCQUFLLE1BQUwsR0FBYyxRQUFkLENBRHFDLENBQ2I7QUFDM0I7QUFDSixLQXZNK0M7O0FBeU1oRDs7Ozs7QUFLQSx1QkFBbUIsMkJBQVMsSUFBVCxFQUFlLE9BQWYsRUFBd0I7QUFDdkMsWUFBTSx1QkFBdUIsS0FBSyxVQUFMLENBQWdCLHlCQUE3QztBQUNBLFlBQU0saUJBQWlCLEtBQUssUUFBTCxDQUFjLGNBQXJDOztBQUVBLFlBQU0sSUFBSSxXQUFWO0FBQ0EsVUFBRSxLQUFGLENBQVEsT0FBUixHQUFrQixRQUFsQjs7QUFFQSxZQUFJLGFBQWEsS0FBSyxlQUFMLEVBQWpCO0FBQ0EsWUFBTSxtQkFBbUIsS0FBSyxtQkFBTCxFQUF6QjtBQUNBLFlBQUksVUFBVSxnQkFBZCxFQUFnQztBQUM1Qix5QkFBYSxDQUFiO0FBQ0g7O0FBRUQsWUFBSSxVQUFKO0FBQ0EsWUFBSSxXQUFXLGFBQWEsZUFBZSxNQUEzQyxFQUFrRDtBQUM5QyxnQkFBTSxhQUFhLGVBQWUsZUFBZSxNQUFmLEdBQXdCLENBQXZDLENBQW5CO0FBQ0EsZ0JBQUksV0FBVyxJQUFYLEdBQWtCLFdBQVcsS0FBakM7QUFDSCxTQUhELE1BR087QUFDSCxnQkFBSSxtQkFBbUIsZUFBZSxVQUFVLFVBQXpCLENBQXZCO0FBQ0EsZ0JBQUksQ0FBQyxnQkFBTCxFQUF1QjtBQUNuQjtBQUNIO0FBQ0QsZ0JBQUksaUJBQWlCLElBQWpCLEdBQXdCLHVCQUF1QixDQUFuRDtBQUNIOztBQUVELGFBQUssdUJBQUwsQ0FBNkIsQ0FBN0IsRUFBZ0MsV0FBaEMsRUFBNkMsZUFBZSxDQUFmLEdBQW1CLE1BQW5CLEdBQTRCLENBQTVCLEdBQWdDLEtBQTdFO0FBQ0EsYUFBSyxPQUFMO0FBQ0gsS0F6TytDOztBQTJPaEQ7Ozs7OztBQU1BLHVCQUFtQiwyQkFBUyxJQUFULEVBQWUsV0FBZixFQUE0QjtBQUMzQyxZQUFNLG1CQUFtQixLQUFLLG1CQUFMLEVBQXpCO0FBQ0EsWUFBSSxhQUFhLEtBQUssZUFBTCxFQUFqQjs7QUFFQSxZQUFJLGNBQWMsZ0JBQWxCLEVBQW9DO0FBQ2hDLHlCQUFhLENBQWI7QUFDSDs7QUFFRCxZQUFNLFFBQVEsS0FBSyxVQUFMLENBQWdCLHlCQUE5QjtBQUNBLFlBQUksWUFBWSxLQUFLLEdBQUwsQ0FBUyxZQUF6QjtBQUNBLFlBQU0sSUFBSSxXQUFWO0FBQ0EsWUFBTSxRQUFRLEVBQUUsS0FBaEI7QUFDQSxZQUFNLFdBQVcsS0FBSyxHQUFMLENBQVMscUJBQVQsRUFBakI7O0FBRUEsWUFBSSxlQUFlLENBQW5CO0FBQ0EsWUFBTSxhQUFhLEtBQUssaUJBQUwsRUFBbkI7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksVUFBcEIsRUFBZ0MsR0FBaEMsRUFBcUM7QUFDakMsNEJBQWdCLEtBQUssWUFBTCxDQUFrQixDQUFsQixDQUFoQjtBQUNIO0FBQ0QsWUFBSSxLQUFLLFVBQUwsQ0FBZ0IsVUFBaEIsSUFBOEIsS0FBSyxVQUFMLENBQWdCLGNBQWxELEVBQWtFO0FBQzlELDRCQUFnQixLQUFLLFVBQUwsQ0FBZ0IsY0FBaEM7QUFDSDtBQUNELHFCQUFhLFlBQWI7O0FBRUEsY0FBTSxHQUFOLEdBQWEsU0FBUyxHQUFULEdBQWUsWUFBaEIsR0FBZ0MsSUFBNUM7QUFDQSxjQUFNLElBQU4sR0FBYSxTQUFTLElBQVQsR0FBZ0IsQ0FBaEIsR0FBb0IsSUFBakM7O0FBRUEsWUFBTSxZQUFZLEtBQUssUUFBTCxDQUFjLGNBQWQsQ0FBbEI7O0FBRUEsVUFBRSxZQUFGLENBQWUsT0FBZixFQUF3QixLQUFLLEtBQUwsQ0FBVyxRQUFRLFNBQW5CLElBQWdDLElBQXhEO0FBQ0EsVUFBRSxZQUFGLENBQWUsUUFBZixFQUF5QixLQUFLLEtBQUwsQ0FBVyxZQUFZLFNBQXZCLElBQW9DLElBQTdEO0FBQ0E7QUFDQSxjQUFNLEtBQU4sR0FBYyxRQUFRLElBQXRCLENBaEMyQyxDQWdDZjtBQUM1QixjQUFNLE1BQU4sR0FBZSxZQUFZLElBQTNCLENBakMyQyxDQWlDVjtBQUNqQyxjQUFNLGVBQU4sR0FBd0IsS0FBSyxVQUFMLENBQWdCLHlCQUF4Qzs7QUFFQSxZQUFJLFNBQVMsS0FBSyxRQUFMLENBQWMsY0FBZCxDQUE2QixjQUFjLFVBQTNDLEVBQXVELElBQXZELEdBQThELFNBQTNFOztBQUVBLHVCQUFlLEtBQWYsQ0FBcUIsU0FBckIsRUFBZ0MsU0FBaEM7O0FBRUEsYUFBSyxvQkFBTCxDQUEwQixPQUExQixHQUFvQztBQUNoQyx5QkFBYSxXQURtQjtBQUVoQyxvQkFBUTtBQUZ3QixTQUFwQzs7QUFLQSxjQUFNLE1BQU4sR0FBZSxHQUFmO0FBQ0EsaUJBQVMsT0FBVCxDQUFpQixPQUFqQixFQUEwQixLQUExQjtBQUNBLGFBQUssT0FBTDtBQUNILEtBalMrQzs7QUFtU2hEOzs7Ozs7O0FBT0EsNkJBQXlCLGlDQUFTLE9BQVQsRUFBa0IsUUFBbEIsRUFBNEIsS0FBNUIsRUFBbUM7QUFDeEQsWUFBTSxZQUFZLFNBQVMsQ0FBVCxFQUFZLFdBQVosS0FBNEIsU0FBUyxNQUFULENBQWdCLENBQWhCLENBQTlDO0FBQ0EsYUFBSyxPQUFMLENBQWEsT0FBYixFQUFzQixXQUFXLFNBQWpDLEVBQTRDLEtBQTVDO0FBQ0EsYUFBSyxPQUFMLENBQWEsT0FBYixFQUFzQixRQUFRLFNBQTlCLEVBQXlDLEtBQXpDO0FBQ0EsYUFBSyxPQUFMLENBQWEsT0FBYixFQUFzQixPQUFPLFNBQTdCLEVBQXdDLEtBQXhDO0FBQ0EsYUFBSyxPQUFMLENBQWEsT0FBYixFQUFzQixNQUFNLFNBQTVCLEVBQXVDLEtBQXZDO0FBQ0EsYUFBSyxPQUFMLENBQWEsT0FBYixFQUFzQixRQUF0QixFQUFnQyxLQUFoQztBQUNILEtBalQrQzs7QUFtVGhEOzs7Ozs7O0FBT0EsYUFBUyxpQkFBUyxPQUFULEVBQWtCLFFBQWxCLEVBQTRCLEtBQTVCLEVBQW1DO0FBQ3hDLFlBQUksWUFBWSxRQUFRLEtBQXhCLEVBQStCO0FBQzNCLG9CQUFRLEtBQVIsQ0FBYyxRQUFkLElBQTBCLEtBQTFCO0FBQ0g7QUFDSixLQTlUK0M7O0FBZ1VoRDs7Ozs7O0FBTUEsc0JBQWtCLDBCQUFTLElBQVQsRUFBZSxXQUFmLEVBQTRCO0FBQzFDLFlBQU0sWUFBWSxLQUFLLFFBQUwsQ0FBYyxVQUFkLENBQWxCO0FBQ0EsWUFBTSxrQkFBa0IsS0FBSyxrQkFBTCxFQUF4QjtBQUNBLFlBQU0sYUFBYSxLQUFLLGFBQUwsQ0FBbUIsZUFBbkIsQ0FBbkI7QUFDQSxZQUFNLFVBQVUsYUFBYSxlQUFiLEdBQStCLENBQUMsV0FBRCxDQUEvQzs7QUFFQSxZQUFJLGNBQWMsQ0FBbEI7QUFDQSxnQkFBUSxPQUFSLENBQWdCLFVBQVMsR0FBVCxFQUFhO0FBQ3pCLDJCQUFlLEtBQUssY0FBTCxDQUFvQixHQUFwQixDQUFmO0FBQ0gsU0FGRDs7QUFJQSxZQUFNLFlBQVksS0FBSyxHQUFMLENBQVMsWUFBM0I7QUFDQSxZQUFNLElBQUksT0FBVjtBQUNBLFlBQU0sV0FBVyxLQUFLLEdBQUwsQ0FBUyxxQkFBVCxFQUFqQjtBQUNBLFlBQU0sUUFBUSxFQUFFLEtBQWhCO0FBQ0E7QUFDQSxZQUFNLFVBQVUsS0FBSyxrQkFBTCxFQUFoQjtBQUNBLGNBQU0sR0FBTixHQUFZLFNBQVMsR0FBVCxHQUFlLE9BQWYsR0FBeUIsSUFBckM7QUFDQSxjQUFNLElBQU4sR0FBYSxTQUFTLElBQVQsR0FBZ0IsSUFBN0I7QUFDQSxjQUFNLE9BQU4sR0FBZ0IsSUFBaEI7QUFDQSxjQUFNLE1BQU4sR0FBZSxtQkFBZjtBQUNBLGNBQU0sZUFBTixHQUF3QixjQUF4Qjs7QUFFQSxVQUFFLFlBQUYsQ0FBZSxPQUFmLEVBQXdCLEtBQUssS0FBTCxDQUFXLGNBQWMsU0FBekIsSUFBc0MsSUFBOUQ7QUFDQSxVQUFFLFlBQUYsQ0FBZSxRQUFmLEVBQXlCLEtBQUssS0FBTCxDQUFXLFlBQVksU0FBdkIsSUFBb0MsSUFBN0Q7O0FBRUEsY0FBTSxLQUFOLEdBQWMsY0FBYyxJQUE1QixDQTFCMEMsQ0EwQlI7QUFDbEMsY0FBTSxNQUFOLEdBQWUsWUFBWSxPQUFaLEdBQXNCLElBQXJDLENBM0IwQyxDQTJCQzs7QUFFM0MsbUJBQVcsS0FBWCxDQUFpQixTQUFqQixFQUE0QixTQUE1Qjs7QUFFQSxhQUFLLG9CQUFMLENBQTBCLE9BQTFCLEdBQW9DO0FBQ2hDLHlCQUFhLFdBRG1CO0FBRWhDLHdCQUFZO0FBRm9CLFNBQXBDOztBQUtBO0FBQ0EsY0FBTSxNQUFOLEdBQWUsR0FBZjtBQUNBLGlCQUFTLE9BQVQsQ0FBaUIsT0FBakIsRUFBMEIsS0FBMUI7QUFDQSxhQUFLLE9BQUw7QUFDSCxLQTlXK0M7O0FBZ1hoRDs7Ozs7O0FBTUEsZ0JBQVksb0JBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDOUIsWUFBTSxJQUFJLE1BQU0sY0FBTixDQUFxQixNQUFyQixDQUE0QixLQUE1QixDQUFrQyxDQUE1QztBQUNBLFlBQU0sV0FBVyxJQUFJLEtBQUssVUFBMUI7O0FBRUEsWUFBTSxtQkFBbUIsS0FBSyw0QkFBTCxJQUFxQyxLQUFLLDJCQUFuRTtBQUNBLFlBQU0sa0JBQWtCLEtBQUssb0JBQUwsQ0FBMEIsT0FBMUIsQ0FBa0MsVUFBMUQ7O0FBRUEsWUFBTSxPQUFPLENBQWI7QUFDQSxZQUFNLE9BQU8sS0FBSyxRQUFMLENBQWMsNkJBQWQsRUFBYjs7QUFFQSxZQUFNLElBQUksT0FBVjs7QUFFQSxhQUFLLHVCQUFMLENBQTZCLENBQTdCLEVBQWdDLFdBQWhDLEVBQTZDLGVBQWUsUUFBZixHQUEwQixNQUExQixHQUFtQyxDQUFuQyxHQUF1QyxLQUFwRjtBQUNBLDhCQUFzQixZQUFXO0FBQzdCLGNBQUUsS0FBRixDQUFRLE9BQVIsR0FBa0IsUUFBbEI7QUFDSCxTQUZEOztBQUlBLFlBQU0sWUFBWSxFQUFsQjtBQUNBLFlBQUksSUFBSSxPQUFPLFNBQWYsRUFBMEI7QUFDdEIsaUJBQUsscUJBQUwsQ0FBMkIsSUFBM0IsRUFBaUMsQ0FBakM7QUFDSDtBQUNELFlBQUksSUFBSSxPQUFPLFNBQWYsRUFBMEI7QUFDdEIsaUJBQUssMkJBQUwsR0FBbUMsS0FBbkM7QUFDQSxpQkFBSyxnQkFBTDtBQUNIO0FBQ0QsWUFBSSxJQUFJLE9BQU8sU0FBZixFQUEwQjtBQUN0QixpQkFBSyxzQkFBTCxDQUE0QixJQUE1QixFQUFrQyxDQUFsQztBQUNIO0FBQ0QsWUFBSSxJQUFJLE9BQU8sU0FBZixFQUEwQjtBQUN0QixpQkFBSyw0QkFBTCxHQUFvQyxLQUFwQztBQUNBLGlCQUFLLGdCQUFMO0FBQ0g7O0FBRUQsWUFBSSxVQUFVLEtBQUssUUFBTCxDQUFjLG1CQUFkLENBQWtDLENBQWxDLENBQWQ7QUFDQSxZQUFNLGtCQUFrQixLQUFLLGtCQUFMLEVBQXhCO0FBQ0EsWUFBTSxpQkFBaUIsS0FBSyxRQUFMLENBQWMsY0FBckM7QUFDQSxZQUFJLGlCQUFpQixDQUFDLENBQXRCO0FBQ0EsWUFBSSxDQUFDLGdCQUFMLEVBQXVCO0FBQ25CLGdCQUFJLENBQUMsZ0JBQWdCLEtBQWhCLENBQXNCLENBQXRCLEVBQXlCLFFBQXpCLENBQWtDLE9BQWxDLENBQUwsRUFBZ0Q7QUFDNUMscUJBQUssb0JBQUwsQ0FBMEIsT0FBMUIsQ0FBa0MsV0FBbEMsR0FBZ0QsT0FBaEQ7QUFDQSxvQkFBTSxvQkFBb0Isa0JBQWtCLE9BQTVDO0FBQ0Esb0JBQUksaUJBQUosRUFBdUI7QUFDbkIsK0JBQVcsQ0FBWDtBQUNIO0FBQ0QsaUNBQWlCLE9BQWpCO0FBQ0gsYUFQRCxNQU9PO0FBQ0gsb0JBQU0sMkJBQTJCLGdCQUFnQixDQUFoQixDQUFqQztBQUNBLG9CQUFNLDBCQUEwQixlQUFlLENBQWYsRUFBa0IsV0FBbEQ7QUFDQSxvQkFBTSwwQkFBMEIsZ0JBQWdCLGdCQUFnQixNQUFoQixHQUF5QixDQUF6QyxJQUE4QyxDQUE5RTtBQUNBLG9CQUFNLHlCQUF5QixlQUFlLGVBQWUsTUFBZixHQUF3QixDQUF2QyxFQUEwQyxXQUF6RTtBQUNBLG9CQUFJLDBCQUEwQix3QkFBOUIsRUFBd0Q7QUFDcEQscUNBQWlCLHdCQUFqQjtBQUNILGlCQUZELE1BRU8sSUFBSSx5QkFBeUIsdUJBQTdCLEVBQXNEO0FBQ3pELHFDQUFpQix1QkFBakI7QUFDSDtBQUNKO0FBQ0QsZ0JBQUksaUJBQWlCLENBQUMsQ0FBdEIsRUFBeUI7QUFDckIscUJBQUssaUJBQUwsQ0FBdUIsSUFBdkIsRUFBNkIsY0FBN0I7QUFDSDtBQUNKO0FBQ0osS0FsYitDOztBQW9iaEQ7Ozs7QUFJQSxzQkFBa0IsNEJBQVU7QUFDeEIsYUFBSyxhQUFMLEdBQXFCLENBQXJCO0FBQ0gsS0ExYitDOztBQTRiaEQ7Ozs7QUFJQSxvQkFBZ0IsMEJBQVc7QUFDdkIsZUFBTyxLQUFLLEdBQUwsQ0FBUyxLQUFLLGNBQWQsRUFBOEIsS0FBSyxjQUFMLEdBQXNCLEtBQUssYUFBTCxLQUF1QixDQUEzRSxDQUFQO0FBQ0gsS0FsYytDOztBQW9jaEQ7Ozs7OztBQU1BLDRCQUF3QixnQ0FBUyxJQUFULEVBQWUsQ0FBZixFQUFrQjtBQUN0QyxZQUFJLEtBQUssNEJBQVQsRUFBdUM7QUFDbkM7QUFDSDtBQUNELGFBQUssNEJBQUwsR0FBb0MsSUFBcEM7QUFDQSxhQUFLLHVCQUFMLENBQTZCLElBQTdCLEVBQW1DLENBQW5DO0FBQ0gsS0FoZCtDOztBQWtkaEQsNkJBQXlCLGlDQUFTLElBQVQsRUFBZSxDQUFmLEVBQWtCO0FBQ3ZDLFlBQUksQ0FBQyxLQUFLLDRCQUFWLEVBQXdDO0FBQ3BDO0FBQ0g7QUFDRCxZQUFNLGFBQWEsS0FBSyxlQUFMLEVBQW5CO0FBQ0EsWUFBSSxDQUFDLEtBQUssUUFBTixJQUFrQixhQUFjLEtBQUssV0FBTCxDQUFpQixLQUFqQixDQUF1QixHQUF2QixHQUE2QixDQUFqRSxFQUFxRTtBQUNqRTtBQUNIO0FBQ0QsYUFBSyxRQUFMLENBQWMsQ0FBZCxFQUFpQixDQUFqQjs7QUFFQSxZQUFNLGlCQUFpQixLQUFLLFFBQUwsQ0FBYyxjQUFyQztBQUNBLFlBQU0saUJBQWlCLGVBQWUsZUFBZSxNQUFmLEdBQXdCLENBQXZDLEVBQTBDLFdBQTFDLEdBQXdELENBQS9FO0FBQ0EsYUFBSyxpQkFBTCxDQUF1QixJQUF2QixFQUE2QixjQUE3Qjs7QUFFQSxhQUFLLG9CQUFMLENBQTBCLE9BQTFCLENBQWtDLFdBQWxDLElBQWlELENBQWpEO0FBQ0EsbUJBQVcsS0FBSyx1QkFBTCxDQUE2QixJQUE3QixDQUFrQyxJQUFsQyxFQUF3QyxJQUF4QyxFQUE4QyxDQUE5QyxDQUFYLEVBQTZELEtBQUssY0FBTCxFQUE3RDtBQUNILEtBbGUrQzs7QUFvZWhEOzs7Ozs7QUFNQSwyQkFBdUIsK0JBQVMsSUFBVCxFQUFlLENBQWYsRUFBa0I7QUFDckMsWUFBSSxLQUFLLDJCQUFULEVBQXNDO0FBQ2xDO0FBQ0g7QUFDRCxhQUFLLDJCQUFMLEdBQW1DLElBQW5DO0FBQ0EsYUFBSyxzQkFBTCxDQUE0QixJQUE1QixFQUFrQyxDQUFsQztBQUNILEtBaGYrQzs7QUFrZmhELDRCQUF3QixnQ0FBUyxJQUFULEVBQWUsQ0FBZixFQUFrQjtBQUN0QyxZQUFJLENBQUMsS0FBSywyQkFBVixFQUF1QztBQUNuQztBQUNIO0FBQ0QsWUFBTSxhQUFhLEtBQUssZUFBTCxFQUFuQjtBQUNBLFlBQUksQ0FBQyxLQUFLLFFBQU4sSUFBa0IsYUFBYSxDQUFuQyxFQUFzQztBQUNsQztBQUNIO0FBQ0QsYUFBSyxRQUFMLENBQWMsQ0FBQyxDQUFmLEVBQWtCLENBQWxCOztBQUVBLFlBQU0saUJBQWlCLEtBQUssUUFBTCxDQUFjLGNBQXJDO0FBQ0EsWUFBTSxpQkFBaUIsZUFBZSxDQUFmLEVBQWtCLFdBQWxCLEdBQWdDLENBQXZEO0FBQ0EsYUFBSyxpQkFBTCxDQUF1QixJQUF2QixFQUE2QixjQUE3Qjs7QUFFQSxhQUFLLG9CQUFMLENBQTBCLE9BQTFCLENBQWtDLFdBQWxDLElBQWlELENBQWpEO0FBQ0EsbUJBQVcsS0FBSyxzQkFBTCxDQUE0QixJQUE1QixDQUFpQyxJQUFqQyxFQUF1QyxJQUF2QyxFQUE2QyxDQUE3QyxDQUFYLEVBQTRELEtBQUssY0FBTCxFQUE1RDtBQUNILEtBbGdCK0M7O0FBb2dCaEQ7Ozs7O0FBS0EsbUJBQWUsdUJBQVMsSUFBVCxFQUFlO0FBQzFCLFlBQU0sSUFBSSxPQUFWO0FBQ0EsWUFBTSxVQUFVLEtBQUssb0JBQUwsQ0FBMEIsT0FBMUIsQ0FBa0MsVUFBbEMsS0FBaUQsS0FBSyxvQkFBTCxDQUEwQixPQUExQixDQUFrQyxXQUFuRzs7QUFFQSxZQUFNLGtCQUFrQixLQUFLLGtCQUFMLEVBQXhCO0FBQ0EsWUFBTSxhQUFhLEtBQUssYUFBTCxDQUFtQixlQUFuQixDQUFuQjs7QUFFQSxZQUFNLG1CQUFtQixLQUFLLG9CQUFMLENBQTBCLE9BQTFCLENBQWtDLFdBQTNEO0FBQ0EsWUFBTSxlQUFlLEtBQUssb0JBQUwsQ0FBMEIsT0FBMUIsQ0FBa0MsVUFBdkQ7QUFDQSxZQUFNLE9BQU8sYUFBYSxnQkFBZ0IsQ0FBaEIsQ0FBYixHQUFrQyxDQUFDLFlBQUQsQ0FBL0M7QUFDQSxZQUFNLE1BQU0sYUFBYSxnQkFBZ0IsTUFBN0IsR0FBc0MsQ0FBbEQ7QUFDQSxhQUFLLFdBQUwsQ0FBaUIsSUFBakIsRUFBdUIsR0FBdkIsRUFBNEIsZ0JBQTVCOztBQUVBLFlBQU0sSUFBSSxXQUFWO0FBQ0EsOEJBQXNCLFlBQVc7QUFDN0IsY0FBRSxLQUFGLENBQVEsT0FBUixHQUFrQixNQUFsQjtBQUNILFNBRkQ7O0FBSUEsYUFBSyxvQkFBTCxDQUEwQixPQUExQixHQUFvQyxJQUFwQztBQUNBLGFBQUssT0FBTDs7QUFFQSxhQUFLLGVBQUw7QUFDQSxZQUFJLDhCQUFKO0FBQ0EsWUFBSSxPQUFPLGdCQUFYLEVBQTRCO0FBQ3hCLG9DQUF3QixvQkFBb0IsTUFBTSxDQUExQixDQUF4QjtBQUNILFNBRkQsTUFFTztBQUNILG9DQUF3QixnQkFBeEI7QUFDSDtBQUNELGFBQUssWUFBTCxDQUFrQixxQkFBbEIsRUFBeUMseUJBQXlCLE1BQU0sQ0FBL0IsQ0FBekM7O0FBRUEsOEJBQXNCLFlBQVc7QUFDN0IsY0FBRSxLQUFGLENBQVEsT0FBUixHQUFrQixNQUFsQjtBQUNBLGlCQUFLLHlCQUFMLEdBRjZCLENBRUs7QUFDbEMsZ0JBQUksT0FBSixFQUFZO0FBQ1IscUJBQUssa0NBQUwsR0FEUSxDQUNtQztBQUM5QztBQUNKLFNBTkQ7QUFRSCxLQS9pQitDOztBQWlqQmhELG1CQUFlLHVCQUFTLEdBQVQsRUFBYTtBQUN4QixZQUFJLGFBQWEsSUFBakI7QUFDQSxZQUFJLElBQUksTUFBSixHQUFhLENBQWpCLEVBQW9CO0FBQ2hCLGdCQUFJLElBQUo7QUFDQSxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLElBQUksTUFBSixHQUFhLENBQWpDLEVBQW9DLEdBQXBDLEVBQXlDO0FBQ3JDLG9CQUFJLElBQUksSUFBSSxDQUFSLElBQWEsSUFBSSxDQUFKLENBQWIsS0FBd0IsQ0FBNUIsRUFBOEI7QUFDMUIsaUNBQWEsS0FBYjtBQUNIO0FBQ0o7QUFDSjtBQUNELGVBQU8sVUFBUDtBQUNIOztBQTVqQitDLENBQS9CLENBQXJCOztBQWdrQkEsT0FBTyxPQUFQLEdBQWlCLFlBQWpCOzs7QUN2bEJBOztBQUVBLElBQUksVUFBVSxRQUFRLFdBQVIsQ0FBZDs7QUFFQTs7OztBQUlBLElBQUksaUJBQWlCLFFBQVEsTUFBUixDQUFlLGdCQUFmLEVBQWlDOztBQUVsRDs7Ozs7O0FBTUEsZUFBVyxDQUFDLENBUnNDOztBQVVsRDs7Ozs7O0FBTUEsb0JBQWdCLENBQUMsQ0FoQmlDOztBQWtCbEQ7Ozs7OztBQU1BLG1CQUFlLHVCQUFTLEtBQVQsRUFBZ0I7QUFDM0IsZUFBTyxNQUFNLGNBQU4sQ0FBcUIsTUFBckIsQ0FBNEIsS0FBNUIsQ0FBa0MsQ0FBekM7QUFDSCxLQTFCaUQ7O0FBNEJsRDs7Ozs7OztBQU9BLHFCQUFpQix5QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNuQyxZQUFJLHNCQUFzQixLQUFLLFFBQUwsQ0FBYyxnQkFBeEM7O0FBRUE7QUFDQSxZQUFJLE1BQU0sUUFBTixDQUFlLENBQWYsS0FBcUIsbUJBQXJCLElBQTRDLE1BQU0sVUFBTixDQUFpQixDQUFqQixJQUFzQixDQUF0RSxFQUF5RTtBQUNyRSxnQkFBSSxhQUFhLEtBQUssUUFBTCxDQUFjLGdCQUFkLENBQStCLE1BQU0sUUFBTixDQUFlLENBQTlDLEVBQWlELEtBQWpELENBQWpCO0FBQ0EsZ0JBQUksY0FBYyxDQUFDLFdBQVcsVUFBWCxDQUFzQixLQUF6QyxFQUFnRDtBQUM1Qyx1QkFBTyxJQUFQO0FBQ0g7QUFDSjs7QUFFRDtBQUNBLFlBQUksTUFBTSxVQUFOLENBQWlCLENBQWpCLElBQXNCLE1BQU0sTUFBTixDQUFhLEtBQWIsR0FBcUIsQ0FBL0MsRUFBa0Q7QUFDOUMsZ0JBQUksU0FBUyxLQUFLLFFBQUwsQ0FBYyxTQUFkLENBQXdCLE1BQU0sUUFBTixDQUFlLENBQXZDLENBQWI7QUFDQSxnQkFBSSxVQUFVLENBQUMsT0FBTyxVQUFQLENBQWtCLEtBQWpDLEVBQXdDO0FBQ3BDLHVCQUFPLElBQVA7QUFDSDtBQUNKOztBQUVELGVBQU8sS0FBUDtBQUNILEtBdkRpRDs7QUF5RGxEOzs7OztBQUtBLG1CQUFlLHlCQUFXO0FBQ3RCLGVBQU8sWUFBUDtBQUNILEtBaEVpRDs7QUFrRWxEOzs7OztBQUtBLHFCQUFpQix5QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNuQyxZQUFJLEtBQUssVUFBVCxFQUFxQjtBQUNqQixnQkFBSSxRQUFRLEtBQUssYUFBTCxDQUFtQixLQUFuQixJQUE0QixLQUFLLFNBQTdDO0FBQ0EsaUJBQUssUUFBTCxDQUFjLGNBQWQsQ0FBNkIsS0FBSyxVQUFsQyxFQUE4QyxLQUFLLGNBQUwsR0FBc0IsS0FBcEU7QUFDSCxTQUhELE1BR08sSUFBSSxLQUFLLElBQVQsRUFBZTtBQUNsQixpQkFBSyxJQUFMLENBQVUsZUFBVixDQUEwQixJQUExQixFQUFnQyxLQUFoQztBQUNIO0FBQ0osS0E5RWlEOztBQWdGbEQ7Ozs7O0FBS0EscUJBQWlCLHlCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ25DLFlBQUksTUFBTSxXQUFOLElBQXFCLEtBQUssZUFBTCxDQUFxQixJQUFyQixFQUEyQixLQUEzQixDQUF6QixFQUE0RDtBQUN4RCxnQkFBSSxNQUFNLFVBQU4sQ0FBaUIsQ0FBakIsSUFBc0IsQ0FBMUIsRUFBNkI7QUFDekIsb0JBQUksY0FBYyxNQUFNLFFBQU4sQ0FBZSxDQUFmLEdBQW1CLENBQXJDO0FBQ0EscUJBQUssVUFBTCxHQUFrQixLQUFLLFFBQUwsQ0FBYyxlQUFkLENBQThCLFdBQTlCLENBQWxCO0FBQ0E7QUFDQSxvQkFBSSxrQkFBa0IsS0FBSyxRQUFMLENBQWMsY0FBcEM7QUFDQSxvQkFBSSxhQUFhLEtBQUssVUFBdEI7QUFDQSxxQkFBSyxRQUFMLENBQWMsY0FBZCxDQUE2QixjQUE3QixDQUE0QyxVQUFTLElBQVQsRUFBZSxNQUFmLEVBQXNCO0FBQzlELHdCQUFJLE1BQU0sS0FBSyxNQUFmO0FBQ0Esd0JBQUksSUFBSSxLQUFKLEtBQWMsV0FBVyxLQUE3QixFQUFtQztBQUMvQiwwQ0FBa0IsTUFBbEI7QUFDSDtBQUNKLGlCQUxEO0FBTUEscUJBQUssY0FBTCxHQUFzQixLQUFLLFFBQUwsQ0FBYyxjQUFkLENBQTZCLGVBQTdCLEVBQThDLEtBQXBFO0FBQ0gsYUFiRCxNQWFPO0FBQ0gscUJBQUssVUFBTCxHQUFrQixNQUFNLE1BQXhCO0FBQ0EscUJBQUssY0FBTCxHQUFzQixNQUFNLE1BQU4sQ0FBYSxLQUFuQztBQUNIOztBQUVELGlCQUFLLFNBQUwsR0FBaUIsS0FBSyxhQUFMLENBQW1CLEtBQW5CLENBQWpCO0FBQ0E7QUFDSCxTQXJCRCxNQXFCTyxJQUFJLEtBQUssSUFBVCxFQUFlO0FBQ2xCLGlCQUFLLElBQUwsQ0FBVSxlQUFWLENBQTBCLElBQTFCLEVBQWdDLEtBQWhDO0FBQ0g7QUFDSixLQTlHaUQ7O0FBZ0hsRDs7Ozs7QUFLQSxtQkFBZSx1QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNqQyxZQUFJLEtBQUssVUFBVCxFQUFxQjtBQUNqQixpQkFBSyxvQkFBTCxDQUEwQixJQUExQixFQUFnQyxLQUFLLFVBQXJDOztBQUVBLGlCQUFLLE1BQUwsR0FBYyxJQUFkO0FBQ0EsaUJBQUssVUFBTCxHQUFrQixLQUFsQjs7QUFFQSxrQkFBTSxjQUFOLENBQXFCLGVBQXJCO0FBQ0E7QUFDQSxpQkFBSyxvQkFBTDtBQUNILFNBVEQsTUFTTyxJQUFJLEtBQUssSUFBVCxFQUFlO0FBQ2xCLGlCQUFLLElBQUwsQ0FBVSxhQUFWLENBQXdCLElBQXhCLEVBQThCLEtBQTlCO0FBQ0g7QUFDSixLQWxJaUQ7O0FBb0lsRDs7Ozs7QUFLQSxxQkFBaUIseUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDbkMsWUFBSSxDQUFDLEtBQUssVUFBVixFQUFzQjtBQUNsQixpQkFBSyxNQUFMLEdBQWMsSUFBZDs7QUFFQSxnQkFBSSxLQUFLLElBQVQsRUFBZTtBQUNYLHFCQUFLLElBQUwsQ0FBVSxlQUFWLENBQTBCLElBQTFCLEVBQWdDLEtBQWhDO0FBQ0g7O0FBRUQsaUJBQUssTUFBTCxHQUFjLE1BQU0sV0FBTixJQUFxQixLQUFLLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsS0FBM0IsQ0FBckIsR0FBeUQsS0FBSyxhQUFMLEVBQXpELEdBQWdGLElBQTlGO0FBQ0g7QUFDSixLQW5KaUQ7O0FBcUpsRDs7Ozs7QUFLQSx1QkFBbUIsMkJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDckMsWUFBSSxNQUFNLFdBQU4sSUFBcUIsS0FBSyxlQUFMLENBQXFCLElBQXJCLEVBQTJCLEtBQTNCLENBQXpCLEVBQTREO0FBQ3hELGdCQUFJLFNBQVMsTUFBTSxVQUFOLENBQWlCLENBQWpCLElBQXNCLENBQXRCLEdBQ1AsS0FBSyxRQUFMLENBQWMsZUFBZCxDQUE4QixNQUFNLFFBQU4sQ0FBZSxDQUFmLEdBQW1CLENBQWpELENBRE8sR0FFUCxNQUFNLE1BRlo7QUFHQSxpQkFBSyxjQUFMLENBQW9CLE1BQXBCO0FBQ0EsbUJBQU8sYUFBUCxDQUFxQjtBQUNqQixrQ0FBa0IsSUFERDtBQUVqQixpQ0FBaUIsS0FGQSxDQUVNO0FBRk4sYUFBckI7QUFJQSxnQkFBSSxPQUFPLE1BQVgsRUFBbUI7QUFDZix1QkFBTyxPQUFPLE1BQVAsQ0FBYyxLQUFyQjtBQUNIO0FBQ0QsaUJBQUssb0JBQUwsQ0FBMEIsSUFBMUIsRUFBZ0MsTUFBaEM7QUFDSCxTQWJELE1BYU8sSUFBSSxLQUFLLElBQVQsRUFBZTtBQUNsQixpQkFBSyxJQUFMLENBQVUsaUJBQVYsQ0FBNEIsSUFBNUIsRUFBa0MsS0FBbEM7QUFDSDtBQUNKLEtBM0tpRDs7QUE4S2xELDBCQUFzQiw4QkFBUyxJQUFULEVBQWUsTUFBZixFQUF1QjtBQUN6QyxZQUFJLEtBQUssZUFBTCxJQUF3QixLQUFLLGNBQUwsS0FBd0IsS0FBSyxLQUFMLENBQVcsT0FBTyxRQUFQLEVBQVgsQ0FBcEQsRUFBbUY7QUFDL0UsaUJBQUssZUFBTCxDQUFxQixNQUFyQjtBQUNIO0FBQ0o7O0FBbExpRCxDQUFqQyxDQUFyQjs7QUFzTEEsT0FBTyxPQUFQLEdBQWlCLGNBQWpCOzs7QUM5TEE7O0FBRUEsSUFBSSxVQUFVLFFBQVEsV0FBUixDQUFkOztBQUVBOzs7O0FBSUEsSUFBSSxrQkFBa0IsUUFBUSxNQUFSLENBQWUsaUJBQWYsRUFBa0M7O0FBRXBEOzs7Ozs7QUFNQSxpQkFBYSxJQVJ1Qzs7QUFVcEQ7Ozs7OztBQU1BLG9CQUFnQixJQWhCb0M7O0FBa0JwRDs7Ozs7O0FBTUEsZ0JBQVksQ0F4QndDOztBQTBCcEQ7Ozs7OztBQU1BLGlCQUFhLENBaEN1Qzs7QUFtQ3BEOzs7OztBQUtBLG1CQUFlLHVCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ2pDLFlBQUksS0FBSyxRQUFULEVBQW1CO0FBQ2YsaUJBQUssUUFBTCxHQUFnQixLQUFoQjtBQUNIO0FBQ0QsWUFBSSxLQUFLLElBQVQsRUFBZTtBQUNYLGlCQUFLLElBQUwsQ0FBVSxhQUFWLENBQXdCLElBQXhCLEVBQThCLEtBQTlCO0FBQ0g7QUFDSixLQS9DbUQ7O0FBaURwRCx1QkFBbUIsMkJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDckMsWUFBSSxLQUFLLGdCQUFULEVBQTJCO0FBQ3ZCLHlCQUFhLEtBQUssZ0JBQWxCLEVBRHVCLENBQ2M7QUFDckMsaUJBQUssZ0JBQUwsR0FBd0IsU0FBeEI7QUFDSDtBQUNELFlBQUksS0FBSyxJQUFULEVBQWU7QUFDWCxpQkFBSyxJQUFMLENBQVUsaUJBQVYsQ0FBNEIsSUFBNUIsRUFBa0MsS0FBbEM7QUFDSDtBQUNKLEtBekRtRDs7QUEyRHBEOzs7OztBQUtBLHFCQUFpQix5QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNuQyxZQUFJLEtBQUssZ0JBQVQsRUFBMkI7QUFDdkI7QUFDSDs7QUFFRDtBQUNBLFlBQ0ksQ0FBQyxNQUFNLGdCQUFQLElBQ0EsS0FBSyxVQUFMLENBQWdCLGVBRGhCLElBRUEsQ0FBQyxNQUFNLGNBQU4sQ0FBcUIsTUFBckIsQ0FBNEIsWUFGN0IsSUFHQSxNQUFNLFlBSlYsRUFLRTtBQUNFLGlCQUFLLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxpQkFBSyxlQUFMLENBQXFCLElBQXJCLEVBQTJCLE1BQU0sUUFBTixDQUFlLENBQTFDLEVBQTZDLE1BQU0sY0FBTixDQUFxQixNQUFyQixDQUE0QixJQUF6RTtBQUNILFNBUkQsTUFRTyxJQUFJLEtBQUssSUFBVCxFQUFlO0FBQ2xCLGlCQUFLLElBQUwsQ0FBVSxlQUFWLENBQTBCLElBQTFCLEVBQWdDLEtBQWhDO0FBQ0g7QUFDSixLQWpGbUQ7O0FBbUZwRDs7Ozs7QUFLQSxxQkFBaUIseUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDbkMsWUFDSSxLQUFLLFVBQUwsQ0FBZ0IsZUFBaEIsSUFDQSxDQUFDLEtBQUssZ0JBQUwsQ0FBc0IsSUFBdEIsQ0FERCxJQUVBLENBQUMsTUFBTSxjQUFOLENBQXFCLE1BQXJCLENBQTRCLFlBRjdCLElBR0EsS0FBSyxRQUpULEVBS0U7QUFDRTtBQUNBLGlCQUFLLGNBQUwsR0FBc0IsTUFBTSxRQUFOLENBQWUsQ0FBckM7QUFDQSxpQkFBSyxXQUFMLEdBQW1CLE1BQU0sY0FBTixDQUFxQixNQUFyQixDQUE0QixLQUEvQztBQUNBLGlCQUFLLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsS0FBSyxXQUFoQztBQUNBLGlCQUFLLDRCQUFMLENBQWtDLElBQWxDLEVBQXdDLEtBQUssY0FBN0MsRUFBNkQsTUFBTSxjQUFOLENBQXFCLE1BQXJCLENBQTRCLElBQXpGO0FBQ0gsU0FYRCxNQVdPLElBQUksS0FBSyxJQUFULEVBQWU7QUFDbEIsaUJBQUssSUFBTCxDQUFVLGVBQVYsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBaEM7QUFDSDtBQUNKLEtBdkdtRDs7QUF5R3BEOzs7OztBQUtBLG1CQUFlLHVCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ2pDLFlBQUksU0FBUyxNQUFNLE1BQW5CO0FBQUEsWUFDSSxVQUFVLEtBQUssb0JBQUwsT0FBZ0MsUUFBaEMsSUFDTixLQUFLLFdBQVcsT0FBTyxJQUF2QixDQUZSOztBQUlBLFlBQUksT0FBSixFQUFhO0FBQ1Qsb0JBQVEsSUFBUixDQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUIsTUFBekI7QUFDSCxTQUZELE1BRU8sSUFBSSxLQUFLLElBQVQsRUFBZTtBQUNsQixpQkFBSyxJQUFMLENBQVUsYUFBVixDQUF3QixJQUF4QixFQUE4QixLQUE5QjtBQUNIO0FBQ0osS0F4SG1EOztBQTBIcEQ7Ozs7Ozs7QUFPQSxrQ0FBOEIsc0NBQVMsSUFBVCxFQUFlLENBQWYsRUFBa0IsSUFBbEIsRUFBd0I7QUFDbEQsWUFBSSxTQUFTLEtBQUssWUFBTCxHQUFvQixDQUFqQzs7QUFFQSxhQUFLLDhCQUFMOztBQUVBLGFBQUssWUFBTCxDQUFrQixNQUFsQixFQUEwQixDQUExQjtBQUNBLGFBQUssYUFBTCxDQUFtQixLQUFLLFFBQUwsQ0FBYyxJQUFJLE1BQWxCLEVBQTBCLENBQTFCLENBQW5COztBQUVBLGFBQUssT0FBTDtBQUNILEtBMUltRDs7QUE0SXBEOzs7Ozs7QUFNQSxxQkFBaUIseUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDbkMsWUFDSSxLQUFLLFVBQUwsQ0FBZ0IsZ0JBQWhCLElBQ0EsS0FBSyxhQUFMLEdBQXFCLFFBQXJCLENBQThCLEtBQTlCLENBRkosRUFHRTtBQUNFLGdCQUFJLEtBQUssY0FBTCxFQUFKLEVBQTJCO0FBQ3ZCLHFCQUFLLGVBQUwsQ0FBcUIsS0FBckI7QUFDSDtBQUNKLFNBUEQsTUFPTztBQUNILGdCQUFJLENBQUMsS0FBSyxjQUFMLEVBQUwsRUFBNEI7QUFDeEIscUJBQUssZUFBTCxDQUFxQixJQUFyQjtBQUNBLHFCQUFLLFVBQUwsQ0FBZ0IsSUFBaEI7QUFDSDtBQUNKO0FBQ0osS0FoS21EOztBQWtLcEQ7Ozs7O0FBS0EsZ0JBQVksb0JBQVMsSUFBVCxFQUFlO0FBQ3ZCLFlBQUksQ0FBQyxLQUFLLGNBQUwsRUFBTCxFQUE0QjtBQUN4QjtBQUNIOztBQUVELFlBQUksSUFBSSxLQUFLLGFBQUwsRUFBUjtBQUFBLFlBQ0ksT0FESjs7QUFHQSxZQUFJLEtBQUssV0FBTCxDQUFpQixDQUFqQixHQUFxQixFQUFFLE1BQUYsQ0FBUyxDQUFsQyxFQUFxQztBQUNqQyxzQkFBVSxDQUFDLENBQVg7QUFDSCxTQUZELE1BRU8sSUFBSSxLQUFLLFdBQUwsQ0FBaUIsQ0FBakIsR0FBcUIsRUFBRSxNQUFGLENBQVMsQ0FBVCxHQUFhLEVBQUUsTUFBRixDQUFTLENBQS9DLEVBQWtEO0FBQ3JELHNCQUFVLENBQVY7QUFDSDs7QUFFRCxZQUFJLE9BQUosRUFBYTtBQUNULGdCQUFJLEtBQUssY0FBTCxJQUF1QixLQUFLLG1CQUFMLEVBQTNCLEVBQXVEO0FBQ25ELHFCQUFLLGNBQUwsSUFBdUIsT0FBdkI7QUFDSDtBQUNELGlCQUFLLFFBQUwsQ0FBYyxPQUFkLEVBQXVCLENBQXZCO0FBQ0g7O0FBRUQsYUFBSyw0QkFBTCxDQUFrQyxJQUFsQyxFQUF3QyxLQUFLLGNBQTdDLEVBQTZELEVBQTdELEVBckJ1QixDQXFCMkM7QUFDbEUsYUFBSyxPQUFMO0FBQ0EsbUJBQVcsS0FBSyxVQUFMLENBQWdCLElBQWhCLENBQXFCLElBQXJCLEVBQTJCLElBQTNCLENBQVgsRUFBNkMsRUFBN0M7QUFDSCxLQS9MbUQ7O0FBaU1wRDs7Ozs7OztBQU9BLHFCQUFpQix5QkFBUyxJQUFULEVBQWUsQ0FBZixFQUFrQixJQUFsQixFQUF3QjtBQUNyQyxZQUFJLENBQUMsS0FBSyxZQUFMLEVBQUwsRUFBMEI7QUFBRTtBQUFTOztBQUVyQyxZQUFJLFNBQVMsS0FBSyxZQUFMLEdBQW9CLENBQWpDO0FBQUEsWUFDSSxXQUFXLEtBQUssT0FBTCxDQUFhLE9BQWIsSUFBd0IsQ0FEdkM7O0FBR0EsWUFBSSxJQUFJLENBQVIsRUFBVztBQUFFO0FBQ1QsbUJBRE8sQ0FDQztBQUNYOztBQUVELFlBQUksUUFBSixFQUFjO0FBQ1YsaUJBQUssOEJBQUw7QUFDQSxpQkFBSyxZQUFMLENBQWtCLENBQWxCLEVBQXFCLE1BQXJCO0FBQ0EsaUJBQUssYUFBTCxDQUFtQixLQUFLLFFBQUwsQ0FBYyxJQUFJLE1BQWxCLEVBQTBCLENBQTFCLENBQW5CO0FBQ0gsU0FKRCxNQUlPO0FBQ0gsaUJBQUssa0JBQUwsQ0FBd0IsQ0FBeEIsRUFBMkIsSUFBM0I7QUFDQSxpQkFBSyxZQUFMLENBQWtCLEtBQUssUUFBTCxDQUFjLENBQWQsRUFBaUIsQ0FBakIsQ0FBbEI7QUFDQSxpQkFBSyxhQUFMLENBQW1CLEtBQUssUUFBTCxDQUFjLENBQWQsRUFBaUIsQ0FBakIsQ0FBbkI7QUFDSDs7QUFFRCxhQUFLLE9BQUw7QUFDSCxLQTdObUQ7O0FBZ09wRDs7OztBQUlBLHFCQUFpQix5QkFBUyxJQUFULEVBQWUsQ0FBRSxDQXBPa0I7O0FBc09wRDs7Ozs7QUFLQSxtQkFBZSx1QkFBUyxJQUFULEVBQWUsQ0FBRSxDQTNPb0I7O0FBNk9wRDs7Ozs7QUFLQSxxQkFBaUIseUJBQVMsSUFBVCxFQUFlO0FBQzVCLGFBQUssZUFBTCxDQUFxQixJQUFyQixFQUEyQixDQUFDLENBQTVCO0FBQ0gsS0FwUG1EOztBQXNQcEQ7Ozs7O0FBS0Esc0JBQWtCLDBCQUFTLElBQVQsRUFBZTtBQUM3QixhQUFLLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsQ0FBM0I7QUFDSCxLQTdQbUQ7O0FBK1BwRDs7Ozs7QUFLQSxnQkFBWSxvQkFBUyxJQUFULEVBQWU7O0FBRXZCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNILEtBcFJtRDs7QUFzUnBEOzs7OztBQUtBLGNBQVUsa0JBQVMsSUFBVCxFQUFlLENBQUUsQ0EzUnlCOztBQTZScEQ7Ozs7O0FBS0EsZ0JBQVksb0JBQVMsSUFBVCxFQUFlO0FBQ3ZCLGFBQUssZ0JBQUwsQ0FBc0IsSUFBdEIsRUFBNEIsQ0FBQyxDQUE3QjtBQUNILEtBcFNtRDs7QUFzU3BEOzs7OztBQUtBLGlCQUFhLHFCQUFTLElBQVQsRUFBZTtBQUN4QixhQUFLLGdCQUFMLENBQXNCLElBQXRCLEVBQTRCLENBQTVCO0FBQ0gsS0E3U21EOztBQStTcEQ7Ozs7O0FBS0EsK0JBQTJCLHFDQUFXO0FBQ2xDLFlBQUksVUFBVSxLQUFLLHFCQUFMLEtBQStCLElBQTdDO0FBQ0EsZUFBTyxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksS0FBSyxLQUFMLENBQVcsVUFBVSxPQUFWLEdBQW9CLE9BQXBCLEdBQThCLE9BQXpDLENBQVosQ0FBUDtBQUNILEtBdlRtRDs7QUF5VHBEOzs7O0FBSUEsNEJBQXdCLGtDQUFXO0FBQy9CLGFBQUssV0FBTCxHQUFtQixLQUFLLEdBQUwsRUFBbkI7QUFDSCxLQS9UbUQ7O0FBaVVwRDs7OztBQUlBLG9CQUFnQiwwQkFBVztBQUN2QixZQUFJLE1BQU0sS0FBSyxHQUFMLEVBQVY7QUFDQSxZQUFJLE1BQU0sS0FBSyxVQUFYLEdBQXdCLEdBQTVCLEVBQWlDO0FBQzdCLGlCQUFLLHNCQUFMO0FBQ0g7QUFDRCxhQUFLLFVBQUwsR0FBa0IsS0FBSyxHQUFMLEVBQWxCO0FBQ0gsS0EzVW1EOztBQTZVcEQ7Ozs7O0FBS0EsMkJBQXVCLGlDQUFXO0FBQzlCLFlBQUksS0FBSyxHQUFMLEtBQWEsS0FBSyxVQUFsQixHQUErQixHQUFuQyxFQUF3QztBQUNwQyxtQkFBTyxDQUFQO0FBQ0g7QUFDRCxlQUFPLEtBQUssR0FBTCxLQUFhLEtBQUssV0FBekI7QUFDSCxLQXZWbUQ7O0FBeVZwRDs7Ozs7OztBQU9BLHFCQUFpQix5QkFBUyxJQUFULEVBQWUsT0FBZixFQUF3QjtBQUNyQyxZQUFJLFNBQVMsS0FBSyxZQUFMLEVBQWI7QUFBQSxZQUNJLFNBQVMsS0FBSyxhQUFMLEVBRGI7QUFBQSxZQUVJLE9BQU8sT0FBTyxDQUFQLEdBQVcsT0FGdEI7QUFBQSxZQUdJLHFCQUFxQixLQUFLLFFBQUwsQ0FBYyxjQUFkLENBQTZCLE1BQTdCLEdBQXNDLENBSC9EO0FBQUEsWUFJSSxhQUFhLEtBQUssY0FBTCxLQUF3QixDQUp6Qzs7QUFNQSxZQUFJLENBQUMsS0FBSyxVQUFMLENBQWdCLGdCQUFyQixFQUF1QztBQUNuQyx5QkFBYSxLQUFLLEdBQUwsQ0FBUyxVQUFULEVBQXFCLGtCQUFyQixDQUFiO0FBQ0g7O0FBRUQsZUFBTyxLQUFLLEdBQUwsQ0FBUyxhQUFhLE9BQU8sQ0FBN0IsRUFBZ0MsS0FBSyxHQUFMLENBQVMsQ0FBQyxPQUFPLENBQWpCLEVBQW9CLElBQXBCLENBQWhDLENBQVA7O0FBRUEsYUFBSyw4QkFBTDtBQUNBLGFBQUssWUFBTCxDQUFrQixPQUFPLENBQXpCLEVBQTRCLE9BQU8sQ0FBUCxHQUFXLElBQXZDO0FBQ0EsYUFBSyxhQUFMLENBQW1CLEtBQUssUUFBTCxDQUFjLElBQWQsRUFBb0IsQ0FBcEIsQ0FBbkI7O0FBRUEsWUFBSSxLQUFLLHVCQUFMLENBQTZCLE9BQU8sT0FBTyxDQUEzQyxFQUE4QyxPQUE5QyxDQUFKLEVBQTREO0FBQ3hELGlCQUFLLGNBQUw7QUFDSDs7QUFFRCxhQUFLLE9BQUw7QUFDSCxLQXRYbUQ7O0FBd1hwRDs7Ozs7OztBQU9BLHNCQUFrQiwwQkFBUyxJQUFULEVBQWUsT0FBZixFQUF3QjtBQUN0QyxZQUFJLFNBQVMsS0FBSyxhQUFMLEVBQWI7QUFBQSxZQUNJLGNBQWMsS0FBSyxZQUFMLEdBQW9CLElBQXBCLENBQXlCLE1BQXpCLENBRGxCO0FBQUEsWUFFSSxPQUFPLFlBQVksQ0FBWixHQUFnQixPQUYzQjtBQUFBLFlBR0ksYUFBYSxLQUFLLGNBQUwsS0FBd0IsQ0FIekM7QUFBQSxZQUlJLHFCQUFxQixLQUFLLHNCQUFMLEtBQWdDLENBSnpEOztBQU1BLFlBQUksQ0FBQyxLQUFLLFVBQUwsQ0FBZ0IsZ0JBQXJCLEVBQXVDO0FBQ25DLHlCQUFhLEtBQUssR0FBTCxDQUFTLFVBQVQsRUFBcUIsa0JBQXJCLENBQWI7QUFDSDs7QUFFRCxlQUFPLEtBQUssR0FBTCxDQUFTLFVBQVQsRUFBcUIsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLElBQVosQ0FBckIsQ0FBUDs7QUFFQSxhQUFLLGVBQUw7QUFDQSxhQUFLLFlBQUwsQ0FBa0IsSUFBbEI7QUFDQSxhQUFLLFlBQUwsQ0FBa0IsS0FBSyxRQUFMLENBQWMsSUFBZCxFQUFvQixDQUFwQixDQUFsQjtBQUNBLGFBQUssYUFBTCxDQUFtQixLQUFLLFFBQUwsQ0FBYyxDQUFkLEVBQWlCLENBQWpCLENBQW5COztBQUVBLFlBQUksS0FBSyx1QkFBTCxDQUE2QixJQUE3QixFQUFtQyxPQUFuQyxDQUFKLEVBQWlEO0FBQzdDLGlCQUFLLGNBQUw7QUFDSDs7QUFFRCxhQUFLLE9BQUw7QUFDSCxLQXRabUQ7O0FBd1pwRCxzQkFBa0IsMEJBQVMsSUFBVCxFQUFlO0FBQzdCLFlBQUksVUFBVSxLQUFLLGFBQUwsQ0FBbUIsY0FBbkIsQ0FBZDtBQUNBLGVBQU8sV0FBVyxRQUFRLFFBQW5CLElBQStCLENBQUMsS0FBSyxRQUE1QztBQUNIOztBQTNabUQsQ0FBbEMsQ0FBdEI7O0FBK1pBLE9BQU8sT0FBUCxHQUFpQixlQUFqQjs7O0FDdmFBOztBQUVBLElBQUksVUFBVSxRQUFRLFdBQVIsQ0FBZDs7QUFFQTs7OztBQUlBLElBQUksZ0JBQWdCLFFBQVEsTUFBUixDQUFlLGVBQWYsRUFBZ0M7O0FBRWhEOzs7OztBQUtBLGlCQUFhLHFCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQy9CLGFBQUssSUFBTCxDQUFVLElBQVYsRUFBZ0IsSUFBaEIsRUFBc0IsS0FBdEI7QUFDSCxLQVQrQzs7QUFXaEQ7Ozs7O0FBS0EsdUJBQW1CLDJCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ3JDLGFBQUssSUFBTCxDQUFVLElBQVYsRUFBZ0IsSUFBaEIsRUFBc0IsS0FBdEIsRUFBNkIsSUFBN0I7QUFDSCxLQWxCK0M7O0FBb0JoRDs7Ozs7QUFLQSxxQkFBaUIseUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDbkMsWUFBSSxnQkFBSjtBQUNBLFlBQ0ksTUFBTSxVQUFOLElBQ0EsTUFBTSxZQUROLEtBRUMsbUJBQW1CLEtBQUssUUFBTCxDQUFjLG1CQUFkLENBQWtDLE1BQU0sUUFBTixDQUFlLENBQWpELENBRnBCLEtBR0EsQ0FBQyxpQkFBaUIsVUFKdEIsRUFLRTtBQUNFLGlCQUFLLE1BQUwsR0FBYyxTQUFkO0FBQ0gsU0FQRCxNQU9PO0FBQ0gsaUJBQUssTUFBTCxHQUFjLElBQWQ7QUFDSDtBQUNELFlBQUksS0FBSyxJQUFULEVBQWU7QUFDWCxpQkFBSyxJQUFMLENBQVUsZUFBVixDQUEwQixJQUExQixFQUFnQyxLQUFoQztBQUNIO0FBQ0o7O0FBeEMrQyxDQUFoQyxDQUFwQjs7QUE0Q0EsU0FBUyxJQUFULENBQWMsSUFBZCxFQUFvQixLQUFwQixFQUEyQixhQUEzQixFQUEwQztBQUN0QyxRQUFJLGdCQUFKO0FBQ0EsUUFDSSxNQUFNLFlBQU4sSUFDQSxDQUFDLENBQUMsbUJBQW1CLE1BQU0sZ0JBQTFCLEVBQTRDLFVBRDdDLElBRUEsRUFBRSxpQkFBaUIsaUJBQWpCLEdBQXFDLGFBQXZDLENBSEosQ0FHMEQ7QUFIMUQsTUFJRTtBQUNFLGlCQUFLLDRCQUFMLENBQWtDLE1BQU0sUUFBTixDQUFlLENBQWpELEVBQW9ELE1BQU0sY0FBTixDQUFxQixNQUFyQixDQUE0QixJQUFoRjtBQUNIOztBQUVELFFBQUksS0FBSyxJQUFULEVBQWU7QUFDWCxhQUFLLElBQUwsQ0FBVSxnQkFBZ0IsbUJBQWhCLEdBQXNDLGFBQWhELEVBQStELElBQS9ELEVBQXFFLEtBQXJFO0FBQ0g7QUFDSjs7QUFFRCxPQUFPLE9BQVAsR0FBaUIsYUFBakI7OztBQ25FQTtBQUNBOzs7O0FBRUEsSUFBSSxVQUFVLFFBQVEsV0FBUixDQUFkOztBQUVBLElBQUksT0FBSjs7QUFFQSxJQUFJLHdCQUFKOztBQUVBOzs7O0FBSUEsSUFBSSxjQUFjLFFBQVEsTUFBUixDQUFlLGFBQWYsRUFBOEI7QUFDNUM7Ozs7O0FBS0Esa0JBQWMsc0JBQVMsSUFBVCxFQUFlO0FBQ3pCLFlBQUksQ0FBQyxPQUFMLEVBQWM7QUFDVixzQkFBVSxLQUFLLHdCQUFMLEVBQVY7QUFDSDs7QUFFRCxZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLFlBQVYsQ0FBdUIsSUFBdkI7QUFDSDtBQUNKLEtBZDJDO0FBZTVDOzs7O0FBSUEsOEJBQTBCLG9DQUFXO0FBQ2pDLFlBQUksZ0JBQWdCLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUFwQjs7QUFFQSxzQkFBYyxLQUFkLENBQW9CLE9BQXBCLEdBQThCLE1BQTlCO0FBQ0Esc0JBQWMsS0FBZCxDQUFvQixRQUFwQixHQUErQixPQUEvQjtBQUNBLHNCQUFjLFlBQWQsQ0FBMkIsT0FBM0IsRUFBb0MsV0FBcEM7O0FBRUEsaUJBQVMsSUFBVCxDQUFjLFdBQWQsQ0FBMEIsYUFBMUI7O0FBRUEsZUFBTztBQUNILHFCQUFTLGFBRE47QUFFSCxxQkFBUztBQUZOLFNBQVA7QUFJSCxLQWhDMkM7O0FBa0M1Qzs7Ozs7QUFLQSxxQkFBaUIseUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDbkMsYUFBSyxlQUFMLENBQXFCLE9BQXJCO0FBQ0EsWUFBSSxLQUFLLElBQVQsRUFBZTtBQUNYLGlCQUFLLElBQUwsQ0FBVSxlQUFWLENBQTBCLElBQTFCLEVBQWdDLEtBQWhDO0FBQ0g7QUFDSixLQTVDMkM7O0FBOEM1Qyx3QkFBb0IsNEJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDdEMsYUFBSyxlQUFMLENBQXFCLE9BQXJCOztBQUVBLFlBQUksS0FBSyxJQUFULEVBQWU7QUFDWCxpQkFBSyxJQUFMLENBQVUsa0JBQVYsQ0FBNkIsSUFBN0IsRUFBbUMsS0FBbkM7QUFDSDtBQUNKLEtBcEQyQzs7QUFzRDVDLGtDQUE4QixzQ0FBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNoRCxhQUFLLGVBQUwsQ0FBcUIsT0FBckI7O0FBRUEsWUFBSSxLQUFLLElBQVQsRUFBZTtBQUNYLGlCQUFLLElBQUwsQ0FBVSw0QkFBVixDQUF1QyxJQUF2QyxFQUE2QyxLQUE3QztBQUNIO0FBQ0osS0E1RDJDOztBQStENUM7Ozs7O0FBS0EsaUJBQWEscUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDL0IsYUFBSyxlQUFMLENBQXFCLE9BQXJCOztBQUVBLFlBQUksOEJBQThCLEtBQUssbUJBQUwsQ0FBeUIsSUFBekIsRUFBK0IsS0FBL0IsQ0FBbEM7O0FBRUEsWUFBSSx3QkFBd0IsTUFBTSxNQUFOLENBQWEsQ0FBYixHQUN0QixNQUFNLE1BQU4sQ0FBYSxLQURTLEdBRXRCLEtBQUssVUFBTCxDQUFnQiw0QkFGdEI7QUFHQSxZQUFJLHVCQUF1Qix3QkFDckIsS0FBSyxVQUFMLENBQWdCLGtDQURLLEdBRXBCLEtBQUssVUFBTCxDQUFnQix3QkFBaEIsR0FBMkMsQ0FGbEQ7O0FBS0EsWUFBSSwyQkFBSixFQUFpQztBQUM3QixnQkFBSSxjQUFjLEtBQUssUUFBTCxDQUFjLGlCQUFkLENBQWdDLEtBQWhDLEVBQXVDLGVBQXZDLElBQTBELEtBQUssVUFBTCxDQUFnQixlQUE1RjtBQUNBLGdCQUFJLE1BQU0sV0FBTixJQUFxQixLQUFLLFVBQUwsQ0FBZ0IsaUJBQXpDLEVBQTREO0FBQ3hELDhCQUFjLEtBQUssVUFBTCxDQUFnQixpQkFBOUI7QUFDSDs7QUFFRCxnQkFBSSxjQUFjLE1BQU0sY0FBTixDQUFxQixNQUFyQixDQUE0QixLQUE1QixDQUFrQyxDQUFsQyxHQUFzQyxHQUF0QyxJQUE2QyxPQUFPLFVBQXRFO0FBQ0EsZ0JBQUksU0FBUyxjQUFjLHFCQUFkLEdBQXNDLG9CQUFuRDtBQUNBLHNCQUFVLEtBQUssTUFBTCxDQUFZLElBQVosQ0FBaUIsSUFBM0I7O0FBRUEsaUJBQUssZ0JBQUwsQ0FBc0IsT0FBdEIsRUFDSSxJQURKLEVBRUksS0FGSixFQUdJLFdBSEosRUFJSSxNQUpKLEVBS0ksTUFBTSxNQUFOLENBQWEsQ0FBYixHQUFpQixNQUFNLE1BQU4sQ0FBYSxNQUE5QixHQUF1QyxLQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWlCLEdBTDVELEVBTUksV0FOSjtBQU9IOztBQUVELFlBQUksS0FBSyxJQUFULEVBQWU7QUFDWCxpQkFBSyxJQUFMLENBQVUsV0FBVixDQUFzQixJQUF0QixFQUE0QixLQUE1QjtBQUNIO0FBQ0osS0F2RzJDOztBQXlHNUM7Ozs7O0FBS0Esc0JBQWtCLDBCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ3BDLFlBQUksTUFBTSxXQUFOLElBQXFCLE1BQU0sY0FBM0IsSUFBNkMsQ0FBQyxNQUFNLFNBQXhELEVBQW1FO0FBQy9ELGlCQUFLLGVBQUw7QUFDQSxpQkFBSyxjQUFMLENBQW9CLGFBQXBCO0FBQ0gsU0FIRCxNQUdPLElBQUksTUFBTSxXQUFOLElBQXFCLENBQUMsTUFBTSxnQkFBaEMsRUFBa0Q7QUFDckQ7QUFDQSxpQkFBSyxlQUFMO0FBQ0EsaUJBQUssWUFBTCxDQUFrQixNQUFNLFFBQU4sQ0FBZSxDQUFqQyxFQUFvQyxNQUFNLFFBQU4sQ0FBZSxDQUFuRDtBQUNILFNBSk0sTUFJQSxJQUFJLE1BQU0sY0FBTixJQUF3QixNQUFNLFNBQTlCLElBQTJDLENBQUMsTUFBTSxhQUF0RCxFQUFxRTtBQUN4RTtBQUNBLGlCQUFLLGVBQUw7QUFDQSxpQkFBSyxTQUFMLENBQWUsTUFBTSxRQUFOLENBQWUsQ0FBOUIsRUFBaUMsTUFBTSxRQUFOLENBQWUsQ0FBaEQ7QUFDSCxTQUpNLE1BSUEsSUFBSSxDQUFDLE1BQU0sY0FBWCxFQUEyQjtBQUM5QjtBQUNBLGlCQUFLLGVBQUw7QUFDQSxpQkFBSyxNQUFMLENBQVksTUFBTSxRQUFOLENBQWUsQ0FBM0IsRUFBOEIsTUFBTSxRQUFOLENBQWUsQ0FBN0MsRUFBZ0QsQ0FBaEQsRUFBbUQsQ0FBbkQ7QUFDSDtBQUNKLEtBL0gyQzs7QUFpSTVDOzs7OztBQUtBLHVCQUFtQiwyQkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNyQyxZQUFJLG9CQUFKO0FBQ0EsWUFBSSxNQUFNLFdBQU4sSUFBcUIsS0FBSyxVQUFMLENBQWdCLGlCQUF6QyxFQUE0RDtBQUN4RCwwQkFBYyxLQUFLLFVBQUwsQ0FBZ0IsaUJBQTlCO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsMEJBQWMsS0FBSyxRQUFMLENBQWMsaUJBQWQsQ0FBZ0MsS0FBaEMsRUFBdUMsZUFBdkMsSUFBMEQsS0FBSyxVQUFMLENBQWdCLGVBQXhGO0FBQ0g7O0FBRUQsYUFBSyxnQkFBTCxDQUFzQixJQUF0QixFQUE0QixLQUE1Qjs7QUFFQTtBQUNBLFlBQUksTUFBTSxjQUFWLEVBQTBCO0FBQ3RCLGdCQUFNLFFBQVEsS0FBSyxjQUFMLENBQW9CLG1DQUFwQixFQUFkO0FBQ0EsZ0JBQUksS0FBSixFQUFXO0FBQ1AsOEJBQWMsS0FBSyxRQUFMLENBQWMsaUJBQWQsQ0FBZ0MsTUFBTSxDQUF0QyxFQUF5QyxNQUFNLENBQS9DLEVBQWtELGVBQWxELElBQXFFLEtBQUssVUFBTCxDQUFnQixlQUFuRztBQUNIO0FBQ0o7O0FBRUQsWUFBSSxjQUFjLE1BQU0sY0FBTixDQUFxQixNQUFyQixDQUE0QixLQUE1QixDQUFrQyxDQUFsQyxHQUFzQyxHQUF0QyxJQUE2QyxPQUFPLFVBQXRFO0FBQ0EsYUFBSyxnQkFBTCxDQUFzQixPQUF0QixFQUNJLElBREosRUFFSSxLQUZKLEVBR0ksV0FISixFQUlJLE1BQU0sY0FBTixDQUFxQixNQUFyQixDQUE0QixLQUE1QixDQUFrQyxDQUFsQyxHQUFzQyxLQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWlCLElBSjNELEVBS0ksTUFBTSxjQUFOLENBQXFCLE1BQXJCLENBQTRCLEtBQTVCLENBQWtDLENBQWxDLEdBQXNDLEtBQUssTUFBTCxDQUFZLElBQVosQ0FBaUIsR0FBdkQsR0FBNkQsRUFMakUsRUFNSSxXQU5KO0FBT0EsWUFBSSxLQUFLLElBQVQsRUFBZTtBQUNYLGlCQUFLLElBQUwsQ0FBVSxpQkFBVixDQUE0QixJQUE1QixFQUFrQyxLQUFsQztBQUNIO0FBQ0osS0FuSzJDOztBQXFLNUMscUJBQWlCLHlCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ25DOztBQUVBLFlBQUksZUFBZSxLQUFuQjtBQUNBLFlBQUksOEJBQThCLEtBQUssbUJBQUwsQ0FBeUIsSUFBekIsRUFBK0IsS0FBL0IsQ0FBbEM7QUFDQSxZQUFJLDJCQUEyQixDQUFDLENBQUMsd0JBQWpDOztBQUVBLFlBQUksMkJBQUosRUFBaUM7QUFDN0IsZ0JBQUksQ0FBQyx3QkFBRCxJQUE2QixNQUFNLE1BQU4sQ0FBYSxDQUFiLEtBQW1CLHlCQUF5QixNQUF6QixDQUFnQyxDQUFoRixJQUNHLE1BQU0sTUFBTixDQUFhLENBQWIsS0FBbUIseUJBQXlCLE1BQXpCLENBQWdDLENBRDFELEVBQzZEOztBQUV6RDtBQUNBO0FBQ0EscUJBQUssUUFBTCxDQUFjLGVBQWQsQ0FBOEIsTUFBTSxRQUFOLENBQWUsQ0FBN0MsRUFBZ0QsTUFBTSxRQUFOLENBQWUsQ0FBL0QsRUFBa0UsMEJBQWxFLEVBQThGLElBQTlGO0FBQ0Esc0JBQU0sd0JBQU4sR0FBaUMsSUFBakM7QUFDQSwrQkFBZSxJQUFmO0FBQ0EsMkNBQTJCLEtBQTNCO0FBQ0EscUJBQUssTUFBTCxHQUFjLFNBQWQ7QUFDSDtBQUNKLFNBWkQsTUFZTztBQUNILGdCQUFJLHdCQUFKLEVBQThCOztBQUUxQjtBQUNBO0FBQ0EscUJBQUssUUFBTCxDQUFjLGVBQWQsQ0FBOEIseUJBQXlCLFFBQXpCLENBQWtDLENBQWhFLEVBQW1FLHlCQUF5QixRQUF6QixDQUFrQyxDQUFyRyxFQUF3RywwQkFBeEcsRUFBb0ksS0FBcEk7QUFDQSxzQkFBTSx3QkFBTixHQUFpQyxLQUFqQztBQUNBLDJDQUEyQixJQUEzQjtBQUNBLCtCQUFlLElBQWY7QUFDSDtBQUNELGlCQUFLLE1BQUwsR0FBYyxJQUFkO0FBQ0g7O0FBRUQsWUFBSSxZQUFKLEVBQWtCO0FBQ2QsaUJBQUssT0FBTDtBQUNIOztBQUVELFlBQUksS0FBSyxJQUFULEVBQWU7QUFDWCxpQkFBSyxJQUFMLENBQVUsZUFBVixDQUEwQixJQUExQixFQUFnQyxLQUFoQztBQUNIO0FBQ0osS0E1TTJDOztBQThNNUM7Ozs7Ozs7O0FBUUEscUJBQWlCLHlCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ25DLGFBQUssZUFBTCxDQUFxQixPQUFyQjs7QUFFQSxZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLGVBQVYsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBaEM7QUFDSDtBQUNKLEtBNU4yQzs7QUE4TjVDLHlCQUFxQiw2QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUN2QyxZQUFJLHlCQUF5QixNQUFNLFVBQU4sQ0FBaUIsdUJBQWpCLElBQ3JCLE1BQU0sYUFBTixJQUF1QixNQUFNLGFBQU4sQ0FBb0IsdUJBRHRCLElBRXJCLE1BQU0saUJBQU4sSUFBMkIsTUFBTSxpQkFBTixDQUF3Qix1QkFGM0Q7O0FBSUEsWUFBSSxDQUFDLHNCQUFMLEVBQTZCO0FBQ3pCLG1CQUFPLEtBQVA7QUFDSDs7QUFFRCxZQUFJLGtCQUFrQixNQUFNLE1BQU4sQ0FBYSxLQUFuQztBQUNBLFlBQUksd0JBQXdCLGtCQUN0QixLQUFLLFVBQUwsQ0FBZ0IsNEJBRHRCOztBQUlBLFlBQUksZ0JBQWdCLENBQXBCO0FBQ0EsWUFBSSxNQUFNLE1BQU4sQ0FBYSxNQUFiLElBQXVCLE1BQU0sTUFBTixDQUFhLE1BQWIsQ0FBb0IsV0FBL0MsRUFBNEQ7QUFDeEQsZ0JBQUksS0FBSyxLQUFLLE1BQUwsQ0FBWSxFQUFyQjtBQUFBLGdCQUNJLGdCQUFnQixHQUFHLEtBQUgsQ0FBUyxJQUQ3QjtBQUFBLGdCQUVJLHFCQUFxQixHQUFHLEtBQUgsQ0FBUyxTQUZsQztBQUFBLGdCQUdJLFNBQVMsTUFBTSxVQUhuQjs7QUFLQSxlQUFHLEtBQUgsQ0FBUyxJQUFULEdBQWdCLE9BQU8sa0JBQXZCO0FBQ0EsZUFBRyxLQUFILENBQVMsU0FBVCxHQUFxQixPQUFPLG1CQUE1QjtBQUNBLDRCQUFnQixHQUFHLFdBQUgsQ0FBZSxNQUFNLE1BQU4sQ0FBYSxNQUFiLENBQW9CLFdBQW5DLEVBQWdELEtBQWhFO0FBQ0EsNkJBQWlCLE9BQU8sNkJBQXhCOztBQUVBLGVBQUcsS0FBSCxDQUFTLElBQVQsR0FBZ0IsYUFBaEI7QUFDQSxlQUFHLEtBQUgsQ0FBUyxTQUFULEdBQXFCLGtCQUFyQjtBQUNIO0FBQ0QsWUFBSSx1QkFBdUIsd0JBQ3JCLEtBQUssVUFBTCxDQUFnQixrQ0FESyxHQUVwQixLQUFLLFVBQUwsQ0FBZ0Isd0JBQWhCLEdBQTJDLENBRnZCLEdBR3JCLGFBSE47O0FBS0EsWUFBSSxzQkFBc0IsTUFBTSxNQUFOLENBQWEsTUFBYixHQUFzQixDQUF0QixHQUEwQixLQUFLLFVBQUwsQ0FBZ0IsdUJBQWhCLEdBQTBDLENBQTlGO0FBQ0EsWUFBSSx5QkFBeUIsc0JBQXNCLEtBQUssVUFBTCxDQUFnQix1QkFBbkU7O0FBRUEsZUFBTyxNQUFNLFVBQU4sQ0FBaUIsQ0FBakIsSUFBc0IscUJBQXRCLElBQ0EsTUFBTSxVQUFOLENBQWlCLENBQWpCLElBQXNCLG9CQUR0QixJQUVBLE1BQU0sVUFBTixDQUFpQixDQUFqQixJQUFzQixzQkFGdEIsSUFHQSxNQUFNLFVBQU4sQ0FBaUIsQ0FBakIsSUFBc0IsbUJBSDdCO0FBSUgsS0F2UTJDOztBQXlRNUM7Ozs7Ozs7Ozs7O0FBV0Esc0JBQWtCLDBCQUFTLGFBQVQsRUFBd0IsSUFBeEIsRUFBOEIsS0FBOUIsRUFBcUMsS0FBckMsRUFBNEMsQ0FBNUMsRUFBK0MsQ0FBL0MsRUFBa0QsV0FBbEQsRUFBK0Q7QUFBQTs7QUFDN0UsYUFBSyxlQUFMLENBQXFCLGFBQXJCOztBQUVBLFlBQUksb0JBQW9CLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUF4Qjs7QUFFQSwwQkFBa0IsWUFBbEIsQ0FBK0IsT0FBL0IsRUFBd0MsU0FBeEM7O0FBRUEsc0JBQWMsT0FBZCxDQUFzQixXQUF0QixDQUFrQyxpQkFBbEM7O0FBRUEsWUFBSSxPQUFPLEtBQVAsS0FBaUIsVUFBckIsRUFBaUM7QUFDN0Isb0JBQVEsTUFBTSxFQUFFLFFBQVEsTUFBTSxNQUFoQixFQUF3QixNQUFNLEVBQUUsTUFBTSxNQUFNLE9BQWQsRUFBdUIsT0FBTyxNQUFNLE1BQU4sQ0FBYSxTQUEzQyxFQUE5QixFQUFzRixPQUFPLE1BQU0sS0FBbkcsRUFBTixDQUFSO0FBQ0g7O0FBRUQsY0FBTSxPQUFOLENBQWMsVUFBQyxJQUFELEVBQVU7QUFDcEIsa0JBQUssbUJBQUwsQ0FBeUIsSUFBekIsRUFBK0IsS0FBL0IsRUFBc0MsYUFBdEMsRUFBcUQsaUJBQXJELEVBQXdFLElBQXhFO0FBQ0gsU0FGRDs7QUFJQSxZQUFJLEtBQUssVUFBTCxDQUFnQix1QkFBcEIsRUFBNEM7QUFDeEMsZ0JBQUksS0FBSyxVQUFMLENBQWdCLHNCQUFwQixFQUE0QztBQUN4Qyx1QkFBTyxNQUFQLENBQWMsY0FBYyxPQUFkLENBQXNCLEtBQXBDLEVBQTJDLEtBQUssVUFBTCxDQUFnQixzQkFBM0Q7QUFDSDtBQUNELGdCQUFJLEtBQUssVUFBTCxDQUFnQix1QkFBcEIsRUFBNkM7QUFDekMsdUJBQU8sTUFBUCxDQUFjLGtCQUFrQixLQUFoQyxFQUF1QyxLQUFLLFVBQUwsQ0FBZ0Isb0JBQXZEO0FBQ0g7QUFDSjs7QUFFRCxhQUFLLGVBQUwsQ0FBcUIsYUFBckIsRUFBb0MsQ0FBcEMsRUFBdUMsQ0FBdkMsRUFBMEMsV0FBMUM7QUFDSCxLQS9TMkM7O0FBaVQ1Qzs7Ozs7Ozs7O0FBU0EseUJBQXFCLDZCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCLGFBQXRCLEVBQXFDLGlCQUFyQyxFQUF3RCxJQUF4RCxFQUE4RDtBQUMvRSxZQUFJLEtBQUssY0FBTCxDQUFvQixTQUFwQixDQUFKLEVBQW9DO0FBQ2hDLGdCQUFLLE9BQU8sS0FBSyxPQUFaLEtBQXdCLFVBQXpCLElBQXdDLENBQUMsS0FBSyxPQUFMLENBQWEsS0FBYixDQUE3QyxFQUFrRTtBQUM5RDtBQUNILGFBRkQsTUFFTyxJQUFJLENBQUMsS0FBSyxPQUFWLEVBQW1CO0FBQ3RCO0FBQ0g7QUFDSjs7QUFFRCxZQUFNLE9BQU8sSUFBYjs7QUFFQSxZQUFNLGFBQWEsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQW5CO0FBQ0EsbUJBQVcsS0FBWCxDQUFpQixPQUFqQixHQUEyQixPQUEzQjs7QUFFQSxtQkFBVyxZQUFYLENBQXdCLE9BQXhCLEVBQWlDLGdCQUFqQzs7QUFFQSxZQUFJLFFBQU8sSUFBUCx5Q0FBTyxJQUFQLE9BQWdCLFFBQXBCLEVBQThCO0FBQzFCLGdCQUFNLHFCQUFxQixTQUFTLGFBQVQsQ0FBdUIsTUFBdkIsQ0FBM0I7QUFDQSwrQkFBbUIsWUFBbkIsQ0FBZ0MsT0FBaEMsRUFBeUMscUJBQXpDO0FBQ0EsK0JBQW1CLFlBQW5CLENBQWdDLElBQWhDLEVBQXNDLE9BQXRDO0FBQ0EsdUJBQVcsV0FBWCxDQUF1QixrQkFBdkI7QUFDQSxnQkFBSSxLQUFLLElBQVQsRUFBZTtBQUNYLG1DQUFtQixTQUFuQixHQUErQixLQUFLLElBQXBDO0FBQ0g7O0FBRUQsZ0JBQU0scUJBQXFCLFNBQVMsYUFBVCxDQUF1QixNQUF2QixDQUEzQjtBQUNBLCtCQUFtQixZQUFuQixDQUFnQyxPQUFoQyxFQUF5QyxxQkFBekM7QUFDQSwrQkFBbUIsWUFBbkIsQ0FBZ0MsSUFBaEMsRUFBc0MsT0FBdEM7QUFDQSwrQkFBbUIsU0FBbkIsR0FBK0IsS0FBSyxLQUFMLElBQWMsS0FBSyxJQUFsRDtBQUNBLHVCQUFXLFdBQVgsQ0FBdUIsa0JBQXZCOztBQUVBLGdCQUFNLHlCQUF5QixTQUFTLGFBQVQsQ0FBdUIsTUFBdkIsQ0FBL0I7QUFDQSxtQ0FBdUIsWUFBdkIsQ0FBb0MsT0FBcEMsRUFBNkMsOEJBQTdDO0FBQ0EsbUNBQXVCLFlBQXZCLENBQW9DLElBQXBDLEVBQTBDLFdBQTFDO0FBQ0EsdUJBQVcsV0FBWCxDQUF1QixzQkFBdkI7O0FBRUEsZ0JBQU0sNkJBQTZCLFNBQVMsYUFBVCxDQUF1QixNQUF2QixDQUFuQztBQUNBLHVDQUEyQixZQUEzQixDQUF3QyxPQUF4QyxFQUFpRCxtQ0FBakQ7QUFDQSx1Q0FBMkIsWUFBM0IsQ0FBd0MsSUFBeEMsRUFBOEMsZUFBOUM7O0FBRUEsZ0JBQUksS0FBSyxTQUFMLElBQWtCLEtBQUssU0FBTCxDQUFlLE1BQXJDLEVBQTZDO0FBQ3pDLDJDQUEyQixTQUEzQixHQUF1QyxLQUFLLFVBQUwsQ0FBZ0IsZ0NBQXZEO0FBQ0g7O0FBRUQsdUJBQVcsV0FBWCxDQUF1QiwwQkFBdkI7O0FBRUEsdUJBQVcsZ0JBQVgsQ0FBNEIsT0FBNUIsRUFBcUMsVUFBUyxVQUFULEVBQXFCO0FBQ3RELG9CQUFJLEtBQUssTUFBVCxFQUFpQjtBQUNiLHlCQUFLLFNBQUwsR0FBaUIsSUFBakI7QUFDQSx5QkFBSyxNQUFMLENBQVksVUFBWixFQUF3QixLQUF4QjtBQUNBLDJCQUFPLEtBQUssU0FBWjtBQUNIO0FBQ0QscUJBQUssZUFBTCxDQUFxQixPQUFyQjtBQUNILGFBUEQ7O0FBU0EsZ0JBQUksS0FBSyxVQUFMLENBQWdCLHVCQUFwQixFQUE0QztBQUN4QyxvQkFBSSxLQUFLLFVBQUwsQ0FBZ0IsMEJBQXBCLEVBQWdEO0FBQzVDLDJCQUFPLE1BQVAsQ0FBYyxXQUFXLEtBQXpCLEVBQWdDLEtBQUssVUFBTCxDQUFnQiwwQkFBaEQ7QUFDSDs7QUFFRCxvQkFBSSxLQUFLLFVBQUwsQ0FBZ0IsOEJBQXBCLEVBQW1EO0FBQy9DLDJCQUFPLE1BQVAsQ0FBYyxtQkFBbUIsS0FBakMsRUFBd0MsS0FBSyxVQUFMLENBQWdCLDhCQUF4RDtBQUNIOztBQUVELG9CQUFJLEtBQUssVUFBTCxDQUFnQiw4QkFBcEIsRUFBb0Q7QUFDaEQsMkJBQU8sTUFBUCxDQUFjLG1CQUFtQixLQUFqQyxFQUF3QyxLQUFLLFVBQUwsQ0FBZ0IsOEJBQXhEO0FBQ0g7O0FBRUQsb0JBQUksS0FBSyxVQUFMLENBQWdCLGtDQUFwQixFQUF3RDtBQUNwRCwyQkFBTyxNQUFQLENBQWMsdUJBQXVCLEtBQXJDLEVBQTRDLEtBQUssVUFBTCxDQUFnQixrQ0FBNUQ7QUFDSDs7QUFFRCxvQkFBSSxLQUFLLFVBQUwsQ0FBZ0Isc0NBQXBCLEVBQTREO0FBQ3hELDJCQUFPLE1BQVAsQ0FBYywyQkFBMkIsS0FBekMsRUFBZ0QsS0FBSyxVQUFMLENBQWdCLHNDQUFoRTtBQUNIO0FBQ0o7O0FBRUQsdUJBQVcsZ0JBQVgsQ0FBNEIsWUFBNUIsRUFBMEMsVUFBUyxLQUFULEVBQWU7QUFDckQscUJBQUssY0FBTCxDQUFvQixhQUFwQjtBQUNBLG9CQUFJLEtBQUssU0FBTCxJQUNBLEtBQUssU0FBTCxDQUFlLE1BRGYsSUFFQSxDQUFDLEtBQUssWUFGVixFQUV3QjtBQUNwQix5QkFBSyxZQUFMLEdBQW9CLEtBQUssd0JBQUwsRUFBcEI7O0FBRUEsa0NBQWMsT0FBZCxDQUFzQixJQUF0QixDQUEyQixLQUFLLFlBQWhDOztBQUVBLHdCQUFNLFlBQVksV0FBVyxxQkFBWCxFQUFsQjtBQUNBLHdCQUFNLGVBQWUsVUFBVSxLQUEvQjtBQUNBLHdCQUFLLGVBQWUsR0FBaEIsR0FBdUIsT0FBTyxVQUFsQyxFQUE4QztBQUMxQyw2QkFBSyxnQkFBTCxDQUFzQixLQUFLLFlBQTNCLEVBQXlDLElBQXpDLEVBQStDLEtBQS9DLEVBQXNELEtBQUssU0FBM0QsRUFBc0UsVUFBVSxJQUFoRixFQUFzRixVQUFVLEdBQWhHLEVBQXFHLElBQXJHO0FBQ0gscUJBRkQsTUFFTztBQUNILDZCQUFLLGdCQUFMLENBQXNCLEtBQUssWUFBM0IsRUFBeUMsSUFBekMsRUFBK0MsS0FBL0MsRUFBc0QsS0FBSyxTQUEzRCxFQUFzRSxZQUF0RSxFQUFvRixVQUFVLEdBQTlGO0FBQ0g7QUFDSjtBQUNKLGFBakJEOztBQW1CQSx1QkFBVyxnQkFBWCxDQUE0QixXQUE1QixFQUF5QyxVQUFTLEtBQVQsRUFBZTtBQUNwRCxvQkFBSSxLQUFLLFVBQUwsQ0FBZ0IsdUJBQWhCLElBQTJDLEtBQUssVUFBTCxDQUFnQiwrQkFBL0QsRUFBK0Y7QUFDM0YsMkJBQU8sTUFBUCxDQUFjLFdBQVcsS0FBekIsRUFBZ0MsS0FBSyxVQUFMLENBQWdCLCtCQUFoRDtBQUNIO0FBQ0osYUFKRDs7QUFNQSx1QkFBVyxnQkFBWCxDQUE0QixZQUE1QixFQUEwQyxVQUFTLEtBQVQsRUFBZTtBQUNyRCxvQkFBSSxLQUFLLFVBQUwsQ0FBZ0IsdUJBQWhCLElBQTJDLEtBQUssVUFBTCxDQUFnQiwwQkFBL0QsRUFBMEY7QUFDdEYsMkJBQU8sTUFBUCxDQUFjLFdBQVcsS0FBekIsRUFBZ0MsS0FBSyxVQUFMLENBQWdCLDBCQUFoRDtBQUNIOztBQUVELG9CQUFJLEtBQUssWUFBTCxJQUFxQixDQUFDLEtBQUssc0JBQUwsQ0FBNEIsS0FBSyxZQUFMLENBQWtCLE9BQTlDLEVBQXVELE1BQU0sYUFBN0QsQ0FBMUIsRUFBdUc7QUFDbkcseUJBQUssZUFBTCxDQUFxQixLQUFLLFlBQTFCO0FBQ0EseUJBQUssZ0JBQUwsQ0FBc0IsS0FBSyxZQUFMLENBQWtCLE9BQXhDO0FBQ0EseUJBQUssWUFBTCxHQUFvQixJQUFwQjtBQUNIO0FBQ0osYUFWRDtBQVdILFNBakdELE1BaUdPLElBQUksU0FBUyxXQUFiLEVBQTBCO0FBQzdCLHVCQUFXLFNBQVgsR0FBdUIsbUJBQXZCOztBQUVBLGdCQUFJLFlBQVksU0FBUyxhQUFULENBQXVCLElBQXZCLENBQWhCO0FBQ0EsdUJBQVcsV0FBWCxDQUF1QixTQUF2Qjs7QUFFQSxnQkFBSSxLQUFLLFVBQUwsQ0FBZ0IsdUJBQXBCLEVBQTZDO0FBQ3pDLG9CQUFJLEtBQUssVUFBTCxDQUFnQix5QkFBcEIsRUFBK0M7QUFDM0MsMkJBQU8sTUFBUCxDQUFjLFVBQVUsS0FBeEIsRUFBK0IsS0FBSyxVQUFMLENBQWdCLHlCQUEvQztBQUNIO0FBQ0o7QUFDSjs7QUFFRCwwQkFBa0IsV0FBbEIsQ0FBOEIsVUFBOUI7QUFDSCxLQXpiMkM7O0FBMmI1Qzs7Ozs7QUFLQSxzQkFBa0IsMEJBQVMsYUFBVCxFQUF3QjtBQUN0QyxlQUFPLGNBQWMsT0FBZCxDQUFzQixVQUE3QixFQUF5QztBQUNyQywwQkFBYyxPQUFkLENBQXNCLFdBQXRCLENBQWtDLGNBQWMsT0FBZCxDQUFzQixVQUF4RDtBQUNIO0FBQ0QsYUFBSyxjQUFMLENBQW9CLGFBQXBCO0FBQ0gsS0FyYzJDOztBQXVjNUMsb0JBQWdCLHdCQUFTLGFBQVQsRUFBd0I7QUFDcEMsZUFBTyxjQUFjLE9BQWQsQ0FBc0IsTUFBN0IsRUFBcUM7QUFDakMsaUJBQUssZUFBTCxDQUFxQixjQUFjLE9BQWQsQ0FBc0IsQ0FBdEIsQ0FBckI7QUFDQSwwQkFBYyxPQUFkLENBQXNCLEtBQXRCO0FBQ0g7QUFDSixLQTVjMkM7O0FBOGM1Qzs7Ozs7Ozs7O0FBU0EscUJBQWlCLHlCQUFTLGFBQVQsRUFBd0IsQ0FBeEIsRUFBMkIsQ0FBM0IsRUFBOEIsV0FBOUIsRUFBMkM7QUFDeEQsc0JBQWMsT0FBZCxDQUFzQixLQUF0QixDQUE0QixPQUE1QixHQUFzQyxPQUF0QztBQUNBLHNCQUFjLE9BQWQsQ0FBc0IsS0FBdEIsQ0FBNEIsR0FBNUIsR0FBa0MsSUFBSSxJQUF0Qzs7QUFFQSxZQUFJLFNBQVMsQ0FBYjtBQUNBLFlBQUksV0FBSixFQUFpQjtBQUNiLHFCQUFTLElBQUksY0FBYyxPQUFkLENBQXNCLFdBQW5DO0FBQ0g7QUFDRCxzQkFBYyxPQUFkLENBQXNCLEtBQXRCLENBQTRCLElBQTVCLEdBQW1DLFNBQVMsSUFBNUM7QUFDSCxLQWhlMkM7O0FBa2U1Qzs7Ozs7QUFLQSxxQkFBaUIseUJBQVMsYUFBVCxFQUF3QjtBQUNyQyxhQUFLLGdCQUFMLENBQXNCLGFBQXRCO0FBQ0Esc0JBQWMsT0FBZCxDQUFzQixLQUF0QixDQUE0QixPQUE1QixHQUFzQyxNQUF0QztBQUNILEtBMWUyQzs7QUE0ZTVDOzs7OztBQUtBLHNCQUFrQiwwQkFBUyxPQUFULEVBQWtCO0FBQ2hDLGdCQUFRLE1BQVI7QUFDSCxLQW5mMkM7O0FBcWY1Qzs7Ozs7O0FBTUEsNEJBQXdCLGdDQUFTLE9BQVQsRUFBa0IsYUFBbEIsRUFBaUM7QUFDckQsWUFBSSxZQUFZLGFBQWhCLEVBQStCO0FBQzNCLG1CQUFPLElBQVA7QUFDSDs7QUFFRCxhQUFLLElBQUksUUFBUSxRQUFRLFVBQXpCLEVBQXFDLEtBQXJDLEVBQTRDLFFBQVEsTUFBTSxXQUExRCxFQUF1RTtBQUNuRSxnQkFBSSxVQUFVLGFBQWQsRUFBNkI7QUFDekIsdUJBQU8sSUFBUDtBQUNIOztBQUVELGdCQUFJLHlCQUF5QixLQUFLLHNCQUFMLENBQTRCLEtBQTVCLEVBQW1DLGFBQW5DLENBQTdCO0FBQ0EsZ0JBQUksc0JBQUosRUFBNEI7QUFDeEIsdUJBQU8sSUFBUDtBQUNIO0FBQ0o7O0FBRUQsZUFBTyxLQUFQO0FBQ0g7QUE1Z0IyQyxDQUE5QixDQUFsQjs7QUErZ0JBLE9BQU8sT0FBUCxHQUFpQixXQUFqQjs7O0FDNWhCQTs7QUFFQSxJQUFJLE9BQU8sUUFBUSxTQUFSLENBQVg7O0FBRUE7Ozs7QUFJQSxJQUFJLFVBQVUsS0FBSyxNQUFMLENBQVksU0FBWixFQUF1Qjs7QUFFakM7Ozs7OztBQU1BLFVBQU0sSUFSMkI7O0FBVWpDOzs7Ozs7QUFNQSxjQUFVLElBaEJ1Qjs7QUFrQmpDOzs7Ozs7QUFNQSxZQUFRLElBeEJ5Qjs7QUEwQmpDOzs7Ozs7QUFNQSxzQkFBa0IsSUFoQ2U7O0FBa0NqQzs7Ozs7OztBQU9BLGFBQVMsaUJBQVMsV0FBVCxFQUFzQjtBQUMzQixZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLE9BQVYsQ0FBa0IsV0FBbEI7QUFDSCxTQUZELE1BRU87QUFDSCxpQkFBSyxJQUFMLEdBQVksV0FBWjtBQUNBLGlCQUFLLFFBQUwsR0FBZ0IsV0FBaEI7QUFDSDtBQUNKLEtBaERnQzs7QUFrRGpDOzs7O0FBSUEsaUJBQWEsdUJBQVc7QUFDcEIsYUFBSyxJQUFMLEdBQVksSUFBWjtBQUNILEtBeERnQzs7QUEwRGpDOzs7O0FBSUEsaUJBQWEsdUJBQVc7QUFDcEIsYUFBSyxJQUFMLEdBQVksS0FBSyxRQUFqQjtBQUNILEtBaEVnQzs7QUFrRWpDOzs7Ozs7OztBQVFBLHFCQUFpQix5QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNuQyxZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLGVBQVYsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBaEM7QUFDSDtBQUNKLEtBOUVnQzs7QUFnRmpDOzs7Ozs7OztBQVFBLHFCQUFpQix5QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNuQyxZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLGVBQVYsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBaEM7QUFDSDtBQUNKLEtBNUZnQzs7QUE4RmpDOzs7Ozs7O0FBT0EscUJBQWlCLHlCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ25DLFlBQUksS0FBSyxJQUFULEVBQWU7QUFDWCxpQkFBSyxJQUFMLENBQVUsZUFBVixDQUEwQixJQUExQixFQUFnQyxLQUFoQztBQUNIO0FBQ0osS0F6R2dDOztBQTJHakM7Ozs7Ozs7QUFPQSxzQkFBa0IsMEJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDcEMsWUFBSSxLQUFLLElBQVQsRUFBZTtBQUNYLGlCQUFLLElBQUwsQ0FBVSxnQkFBVixDQUEyQixJQUEzQixFQUFpQyxLQUFqQztBQUNIO0FBQ0osS0F0SGdDOztBQXdIakM7Ozs7Ozs7QUFPQSxxQkFBaUIseUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDbkMsWUFBSSxLQUFLLElBQVQsRUFBZTtBQUNYLGlCQUFLLElBQUwsQ0FBVSxlQUFWLENBQTBCLElBQTFCLEVBQWdDLEtBQWhDO0FBQ0g7QUFDSixLQW5JZ0M7O0FBcUlqQzs7Ozs7OztBQU9BLHdCQUFvQiw0QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUN0QyxZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLGtCQUFWLENBQTZCLElBQTdCLEVBQW1DLEtBQW5DO0FBQ0g7QUFDSixLQWhKZ0M7O0FBa0pqQyxrQ0FBOEIsc0NBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDaEQsWUFBSSxLQUFLLElBQVQsRUFBZTtBQUNYLGlCQUFLLElBQUwsQ0FBVSw0QkFBVixDQUF1QyxJQUF2QyxFQUE2QyxLQUE3QztBQUNIO0FBQ0osS0F0SmdDOztBQXdKakM7Ozs7Ozs7QUFPQSxtQkFBZSx1QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNqQyxZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLGFBQVYsQ0FBd0IsSUFBeEIsRUFBOEIsS0FBOUI7QUFDSDtBQUNKLEtBbktnQzs7QUFxS2pDOzs7Ozs7O0FBT0EsbUJBQWUsdUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDakMsWUFBSSxLQUFLLElBQVQsRUFBZTtBQUNYLGlCQUFLLElBQUwsQ0FBVSxhQUFWLENBQXdCLElBQXhCLEVBQThCLEtBQTlCO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsbUJBQU8sSUFBUDtBQUNIO0FBQ0osS0FsTGdDOztBQW9MakM7Ozs7Ozs7QUFPQSxpQkFBYSxxQkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUMvQixZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLFdBQVYsQ0FBc0IsSUFBdEIsRUFBNEIsS0FBNUI7QUFDSDtBQUNKLEtBL0xnQzs7QUFpTWpDOzs7Ozs7O0FBT0Esc0JBQWtCLDBCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ3BDLFlBQUksS0FBSyxJQUFULEVBQWU7QUFDWCxpQkFBSyxJQUFMLENBQVUsZ0JBQVYsQ0FBMkIsSUFBM0IsRUFBaUMsS0FBakM7QUFDSDtBQUNKLEtBNU1nQzs7QUE4TWpDOzs7Ozs7O0FBT0EsdUJBQW1CLDJCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ3JDLFlBQUksS0FBSyxJQUFULEVBQWU7QUFDWCxpQkFBSyxJQUFMLENBQVUsaUJBQVYsQ0FBNEIsSUFBNUIsRUFBa0MsS0FBbEM7QUFDSDtBQUNKLEtBek5nQzs7QUEyTmpDOzs7Ozs7O0FBT0EsaUJBQWEscUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDL0IsWUFBSSxLQUFLLElBQVQsRUFBZTtBQUNYLGlCQUFLLElBQUwsQ0FBVSxXQUFWLENBQXNCLElBQXRCLEVBQTRCLEtBQTVCO0FBQ0g7QUFDSixLQXRPZ0M7O0FBd09qQzs7Ozs7OztBQU9BLHFCQUFpQix5QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNuQyxZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLGVBQVYsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBaEM7QUFDSDtBQUNKLEtBblBnQzs7QUFxUGpDOzs7Ozs7O0FBT0EsdUJBQW1CLDJCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ3JDLFlBQUksS0FBSyxJQUFULEVBQWU7QUFDWCxpQkFBSyxJQUFMLENBQVUsaUJBQVYsQ0FBNEIsSUFBNUIsRUFBa0MsS0FBbEM7QUFDSDtBQUNKLEtBaFFnQzs7QUFrUWpDOzs7Ozs7QUFNQSxzQkFBa0IsMEJBQVMsSUFBVCxFQUFlLENBQWYsRUFBa0IsQ0FBbEIsRUFBcUI7QUFDbkMsWUFBSSxLQUFLLElBQVQsRUFBZTtBQUNYLGlCQUFLLElBQUwsQ0FBVSxnQkFBVixDQUEyQixJQUEzQixFQUFpQyxDQUFqQyxFQUFvQyxDQUFwQztBQUNIO0FBQ0osS0E1UWdDOztBQThRakM7Ozs7O0FBS0EscUJBQWlCLHlCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ25DLGVBQU8sTUFBTSxRQUFOLENBQWUsQ0FBZixHQUFtQixDQUExQjtBQUNILEtBclJnQzs7QUF1UmpDOzs7OztBQUtBLHdCQUFvQiw0QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUN0QyxlQUFPLE1BQU0sUUFBTixDQUFlLENBQWYsS0FBcUIsQ0FBNUI7QUFDSCxLQTlSZ0M7O0FBZ1NqQzs7Ozs7OztBQU9BLGVBQVcsbUJBQVMsSUFBVCxFQUFlO0FBQ3RCLFlBQUksS0FBSyxJQUFULEVBQWU7QUFDWCxpQkFBSyxJQUFMLENBQVUsU0FBVixDQUFvQixJQUFwQjtBQUNIO0FBQ0QsWUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDYixpQkFBSyxRQUFMLENBQWMsS0FBSyxNQUFuQjtBQUNIO0FBQ0osS0E5U2dDOztBQWdUakM7Ozs7Ozs7QUFPQSxrQkFBYyxzQkFBUyxJQUFULEVBQWU7QUFDekIsWUFBSSxLQUFLLElBQVQsRUFBZTtBQUNYLGlCQUFLLElBQUwsQ0FBVSxZQUFWLENBQXVCLElBQXZCO0FBQ0g7QUFDSixLQTNUZ0M7O0FBNlRqQzs7Ozs7OztBQU9BLHdCQUFvQiw0QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUN0QyxZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLGtCQUFWLENBQTZCLElBQTdCLEVBQW1DLEtBQW5DO0FBQ0g7QUFDSixLQXhVZ0M7O0FBMFVqQyw0QkFBd0IsZ0NBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDMUMsWUFBSSxLQUFLLElBQVQsRUFBZTtBQUNYLGlCQUFLLElBQUwsQ0FBVSxrQkFBVixDQUE2QixJQUE3QixFQUFtQyxLQUFuQztBQUNIO0FBQ0osS0E5VWdDOztBQWdWakM7Ozs7OztBQU1BLDhCQUEwQixrQ0FBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUM1QyxZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLHdCQUFWLENBQW1DLElBQW5DLEVBQXlDLEtBQXpDO0FBQ0g7QUFDSjtBQTFWZ0MsQ0FBdkIsQ0FBZDs7QUE4VkEsT0FBTyxPQUFQLEdBQWlCLE9BQWpCOzs7QUN0V0E7O0FBRUEsSUFBSSxVQUFVLFFBQVEsV0FBUixDQUFkOztBQUVBOzs7QUFHQSxJQUFJLFVBQVUsUUFBUSxNQUFSLENBQWUsU0FBZixFQUEwQjs7QUFFcEM7Ozs7Ozs7OztBQVNBLG1CQUFlLHVCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ2pDLFlBQUksU0FBSjtBQUFBLFlBQWUsWUFBZjtBQUFBLFlBQTZCLE9BQTdCO0FBQUEsWUFDSSxTQUFTLE1BQU0sTUFEbkI7O0FBR0EsWUFBSSxPQUFPLE1BQVgsRUFBbUI7QUFDZix3QkFBWSxPQUFPLE1BQVAsQ0FBYyxLQUExQjtBQUNBLGdCQUFJLFVBQVUsWUFBZCxFQUE0QjtBQUN4QiwrQkFBZSxVQUFVLFVBQVYsQ0FBcUIsWUFBckIsQ0FBa0MsT0FBTyxJQUF6QyxDQUFmO0FBQ0EsMEJBQVUsS0FBSyxXQUFXLFlBQWhCLENBQVY7QUFDSDtBQUNKOztBQUVELFlBQUksT0FBSixFQUFhO0FBQ1Qsb0JBQVEsSUFBUixDQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUIsTUFBekI7QUFDSCxTQUZELE1BRU8sSUFBSSxLQUFLLElBQVQsRUFBZTtBQUNsQixpQkFBSyxJQUFMLENBQVUsYUFBVixDQUF3QixJQUF4QixFQUE4QixLQUE5QjtBQUNIO0FBQ0osS0E1Qm1DOztBQThCcEMsZ0JBQVksb0JBQVMsSUFBVCxFQUFlLE1BQWYsRUFBdUI7QUFBRSxzQkFBYyxJQUFkLEVBQW9CLE1BQXBCLEVBQTRCLENBQUMsQ0FBN0I7QUFBa0MsS0E5Qm5DO0FBK0JwQyxpQkFBYSxxQkFBUyxJQUFULEVBQWUsTUFBZixFQUF1QjtBQUFFLHNCQUFjLElBQWQsRUFBb0IsTUFBcEIsRUFBNEIsQ0FBQyxDQUE3QjtBQUFrQyxLQS9CcEM7QUFnQ3BDLGNBQVUsUUFoQzBCO0FBaUNwQyxnQkFBWSxRQWpDd0I7O0FBbUNwQyx1QkFBbUIsMkJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDckMsWUFBSSxNQUFNLFlBQVYsRUFBd0I7QUFDcEIsaUJBQUssZ0JBQUwsQ0FBc0IsS0FBdEI7QUFDSCxTQUZELE1BRU8sSUFBSSxLQUFLLElBQVQsRUFBZTtBQUNsQixpQkFBSyxJQUFMLENBQVUsaUJBQVYsQ0FBNEIsSUFBNUIsRUFBa0MsS0FBbEM7QUFDSDtBQUNKLEtBekNtQzs7QUEyQ3BDLGlCQUFhLHFCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQy9CLFlBQUksTUFBTSxZQUFWLEVBQXdCO0FBQ3BCLGlCQUFLLGdCQUFMLENBQXNCLEtBQXRCO0FBQ0gsU0FGRCxNQUVPLElBQUksS0FBSyxJQUFULEVBQWU7QUFDbEIsaUJBQUssSUFBTCxDQUFVLFdBQVYsQ0FBc0IsSUFBdEIsRUFBNEIsS0FBNUI7QUFDSDtBQUNKOztBQWpEbUMsQ0FBMUIsQ0FBZDs7QUFxREEsU0FBUyxhQUFULENBQXVCLElBQXZCLEVBQTZCLE1BQTdCLEVBQXFDLE1BQXJDLEVBQTZDO0FBQ3pDLFFBQUksWUFBWSxPQUFPLE1BQVAsQ0FBYyxLQUE5QjtBQUFBLFFBQ0ksUUFBUSxVQUFVLGFBQVYsQ0FBd0IsS0FEcEM7QUFBQSxRQUVJLFFBQVEsVUFBVSxVQUFWLENBQXFCLEtBRmpDO0FBQUEsUUFHSSxVQUFVLEtBSGQ7QUFBQSxRQUlJLElBQUksS0FBSyxRQUFMLENBQWMsY0FBZCxDQUE2QixNQUpyQzs7QUFNQSxnQkFBWSxJQUFJLEtBQUssUUFBTCxDQUFjLFNBQWxCLEVBQVosQ0FQeUMsQ0FPQTs7QUFFekMsV0FDSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLE1BQVIsR0FBaUIsQ0FBbEIsSUFBdUIsQ0FBaEMsTUFBdUMsT0FBdkMsSUFDQSxVQUFVLFdBQVYsQ0FBc0IsS0FBdEIsRUFBNkIsS0FBN0IsQ0FGSixFQUdFO0FBQ0UsWUFBSSxVQUFVLFVBQVYsQ0FBcUIsVUFBekIsRUFBcUM7QUFDakM7QUFDQSxpQkFBSyxNQUFMLENBQVksU0FBWjtBQUNBO0FBQ0g7QUFDSjs7QUFFRCxhQUFTLElBQVQsRUFBZSxTQUFmO0FBQ0g7O0FBRUQsU0FBUyxRQUFULENBQWtCLElBQWxCLEVBQXdCLE1BQXhCLEVBQWdDO0FBQzVCLFFBQUksWUFBWSxPQUFPLE1BQVAsQ0FBYyxLQUE5QjtBQUFBLFFBQ0ksUUFBUSxVQUFVLGFBQVYsQ0FBd0IsS0FEcEM7O0FBR0E7QUFDQSxTQUFLLGtCQUFMLENBQXdCLEtBQXhCLEVBQStCLENBQS9CO0FBQ0EsU0FBSyxTQUFMO0FBQ0g7O0FBRUQsT0FBTyxPQUFQLEdBQWlCLE9BQWpCOzs7QUM1RkE7O0FBRUEsSUFBSSxVQUFVLFFBQVEsV0FBUixDQUFkOztBQUVBLElBQUksV0FBVztBQUNYLGNBQVUsa0JBQVMsSUFBVCxFQUFlO0FBQUUsYUFBSyxRQUFMO0FBQWtCLEtBRGxDO0FBRVgsWUFBUSxnQkFBUyxJQUFULEVBQWU7QUFBRSxhQUFLLE1BQUw7QUFBZ0IsS0FGOUI7QUFHWCxjQUFVLGtCQUFTLElBQVQsRUFBZTtBQUFFLGFBQUssUUFBTDtBQUFrQixLQUhsQztBQUlYLGVBQVcsbUJBQVMsSUFBVCxFQUFlO0FBQUUsYUFBSyxTQUFMO0FBQW1CO0FBSnBDLENBQWY7O0FBT0E7OztBQUdBLElBQUksWUFBWSxRQUFRLE1BQVIsQ0FBZSxXQUFmLEVBQTRCOztBQUV4Qzs7Ozs7QUFLQSxtQkFBZSx1QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNqQyxZQUFJLE9BQU8sU0FBUyxNQUFNLE1BQU4sQ0FBYSxJQUF0QixDQUFYO0FBQ0EsWUFBSSxJQUFKLEVBQVU7QUFDTixpQkFBSyxJQUFMO0FBQ0gsU0FGRCxNQUVPLElBQUksS0FBSyxJQUFULEVBQWU7QUFDbEIsaUJBQUssSUFBTCxDQUFVLGFBQVYsQ0FBd0IsSUFBeEIsRUFBOEIsS0FBOUI7QUFDSDtBQUNKOztBQWR1QyxDQUE1QixDQUFoQjs7QUFrQkEsT0FBTyxPQUFQLEdBQWlCLFNBQWpCOzs7QUNoQ0E7QUFDQTs7QUFFQSxJQUFJLFVBQVUsUUFBUSxXQUFSLENBQWQ7O0FBRUEsSUFBSSxvQkFBSjtBQUNBLElBQUkseUJBQXlCLElBQTdCOztBQUVBLElBQUkscUJBQXFCLElBQXpCOztBQUVBOzs7O0FBSUEsSUFBSSxjQUFjLFFBQVEsTUFBUixDQUFlLGFBQWYsRUFBOEI7QUFDNUM7Ozs7O0FBS0Esa0JBQWMsc0JBQVMsSUFBVCxFQUFlO0FBQ3pCLFlBQUksQ0FBQyxvQkFBTCxFQUEyQjtBQUN2QixtQ0FBdUIsS0FBSyx3QkFBTCxFQUF2QjtBQUNIOztBQUVELFlBQUksS0FBSyxJQUFULEVBQWU7QUFDWCxpQkFBSyxJQUFMLENBQVUsWUFBVixDQUF1QixJQUF2QjtBQUNIO0FBQ0osS0FkMkM7QUFlNUM7Ozs7QUFJQSw4QkFBMEIsb0NBQVc7QUFDakMsWUFBSSxnQkFBZ0IsU0FBUyxhQUFULENBQXVCLEdBQXZCLENBQXBCOztBQUVBLHNCQUFjLEtBQWQsQ0FBb0IsT0FBcEIsR0FBOEIsTUFBOUI7QUFDQSxzQkFBYyxZQUFkLENBQTJCLE9BQTNCLEVBQW9DLHNCQUFwQzs7QUFFQSxpQkFBUyxJQUFULENBQWMsV0FBZCxDQUEwQixhQUExQjs7QUFFQSxlQUFPLGFBQVA7QUFDSCxLQTVCMkM7O0FBOEI1Qyx3QkFBb0IsNEJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDdEMsYUFBSyxlQUFMLENBQXFCLElBQXJCLEVBQTJCLG9CQUEzQjs7QUFFQSxZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLGtCQUFWLENBQTZCLElBQTdCLEVBQW1DLEtBQW5DO0FBQ0g7QUFDSixLQXBDMkM7O0FBc0M1QyxrQ0FBOEIsc0NBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDaEQsYUFBSyxlQUFMLENBQXFCLElBQXJCLEVBQTJCLG9CQUEzQjs7QUFFQSxZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLDRCQUFWLENBQXVDLElBQXZDLEVBQTZDLEtBQTdDO0FBQ0g7QUFDSixLQTVDMkM7O0FBOEM1Qzs7Ozs7QUFLQSxpQkFBYSxxQkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUMvQixZQUFJLDJCQUNJLHVCQUF1QixDQUF2QixLQUE2QixNQUFNLFFBQU4sQ0FBZSxDQUE1QyxJQUNHLHVCQUF1QixDQUF2QixLQUE2QixNQUFNLFFBQU4sQ0FBZSxDQUZuRCxDQUFKLEVBRTJEO0FBQ3ZELGlCQUFLLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsb0JBQTNCO0FBQ0g7O0FBRUQsWUFBSSxLQUFLLElBQVQsRUFBZTtBQUNYLGlCQUFLLElBQUwsQ0FBVSxXQUFWLENBQXNCLElBQXRCLEVBQTRCLEtBQTVCO0FBQ0g7QUFDSixLQTdEMkM7O0FBK0Q1Qzs7Ozs7OztBQU9BLHNCQUFrQiwwQkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNwQyxhQUFLLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsb0JBQTNCOztBQUVBLFlBQUksS0FBSyxJQUFULEVBQWU7QUFDWCxpQkFBSyxJQUFMLENBQVUsZ0JBQVYsQ0FBMkIsSUFBM0IsRUFBaUMsS0FBakM7QUFDSDtBQUNKLEtBNUUyQzs7QUE4RTVDLHFCQUFpQix5QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNuQyxZQUFJLENBQUMsc0JBQUQsSUFDRyx1QkFBdUIsQ0FBdkIsS0FBNkIsTUFBTSxRQUFOLENBQWUsQ0FEL0MsSUFFRyx1QkFBdUIsQ0FBdkIsS0FBNkIsTUFBTSxRQUFOLENBQWUsQ0FGbkQsRUFFc0Q7QUFDbEQsZ0JBQUksTUFBTSxVQUFOLENBQWlCLElBQWpCLElBQTBCLE1BQU0sVUFBTixDQUFpQixzQkFBakIsSUFBMkMsTUFBTSxVQUEvRSxFQUE0RjtBQUN4RixxQkFBSyxlQUFMLENBQXFCLElBQXJCLEVBQTJCLG9CQUEzQjs7QUFFQSxvQkFBTSxnQkFBZ0IsTUFBTSxVQUFOLENBQWlCLElBQWpCLEdBQXdCLE1BQU0sVUFBTixDQUFpQixJQUF6QyxHQUFnRCxNQUFNLEtBQTVFOztBQUVBLHFCQUFLLGdCQUFMLENBQXNCLG9CQUF0QixFQUNJLElBREosRUFFSSxhQUZKLEVBR0ksTUFBTSxNQUhWOztBQUtBLHlDQUF5QixNQUFNLFFBQS9CO0FBQ0gsYUFYRCxNQVdPLElBQUksc0JBQUosRUFBNEI7QUFDL0IscUJBQUssd0JBQUwsQ0FBOEIsSUFBOUIsRUFBb0Msb0JBQXBDO0FBQ0g7QUFDSjs7QUFFRCxZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLGVBQVYsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBaEM7QUFDSDtBQUNKLEtBckcyQzs7QUF1RzVDOzs7Ozs7OztBQVFBLHNCQUFrQiwwQkFBUyx3QkFBVCxFQUFtQyxJQUFuQyxFQUF5QyxTQUF6QyxFQUFvRCxVQUFwRCxFQUFnRTtBQUFBOztBQUM5RSxhQUFLLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsd0JBQTNCOztBQUVBLFlBQUksUUFBUSxTQUFaO0FBQ0EsWUFBSSxDQUFDLE1BQU0sT0FBTixDQUFjLFNBQWQsQ0FBTCxFQUErQjtBQUMzQixvQkFBUSxDQUFDLFNBQUQsQ0FBUjtBQUNIOztBQUVELGNBQU0sT0FBTixDQUFjLGFBQUs7QUFDZixnQkFBSSxXQUFXLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUFmO0FBQ0EsZ0JBQUksY0FBYyxTQUFTLGFBQVQsQ0FBdUIsR0FBdkIsQ0FBbEI7O0FBRUEsZ0JBQUksS0FBSyxVQUFMLENBQWdCLHNCQUFwQixFQUE0QztBQUN4Qyx1QkFBTyxNQUFQLENBQWMsWUFBWSxLQUExQixFQUFpQyxLQUFLLFVBQUwsQ0FBZ0Isc0JBQWpEO0FBQ0g7O0FBRUQscUNBQXlCLElBQXpCLEdBQWdDLENBQWhDO0FBQ0EscUNBQXlCLE1BQXpCLEdBQWtDLFFBQWxDOztBQUVBLHdCQUFZLElBQVosR0FBbUIsQ0FBbkI7QUFDQSxnQkFBSSxnQkFBZ0IsTUFBSyxjQUFMLENBQW9CLENBQXBCLEVBQXVCLEtBQUssVUFBTCxDQUFnQiwwQkFBdkMsRUFBbUUsS0FBbkUsQ0FBcEI7QUFDQSx3QkFBWSxJQUFaLEdBQXNCLGFBQXRCO0FBQ0Esd0JBQVksTUFBWixHQUFxQixRQUFyQjs7QUFFQSxnQkFBSSxrQkFBa0IsU0FBUyxhQUFULENBQXVCLEdBQXZCLENBQXRCO0FBQ0EsNEJBQWdCLFlBQWhCLENBQTZCLE9BQTdCLEVBQXNDLHFCQUF0Qzs7QUFFQSx3QkFBWSxXQUFaLENBQXdCLGVBQXhCOztBQUVBLHFCQUFTLFdBQVQsQ0FBcUIsV0FBckI7QUFDQSxxQ0FBeUIsV0FBekIsQ0FBcUMsUUFBckM7QUFDQSxxQ0FBeUIsV0FBekIsR0FBdUMsWUFBVTtBQUM3Qyx1QkFBTyxNQUFQLENBQWMseUJBQXlCLEtBQXZDLEVBQThDLEtBQUssVUFBTCxDQUFnQix1QkFBOUQ7QUFDSCxhQUZEO0FBR0EscUNBQXlCLFVBQXpCLEdBQXNDLFlBQVU7QUFDNUMsdUJBQU8sTUFBUCxDQUFjLHlCQUF5QixLQUF2QyxFQUE4QyxLQUFLLFVBQUwsQ0FBZ0IsZ0JBQTlEO0FBQ0gsYUFGRDtBQUdILFNBN0JEOztBQStCQSxZQUFJLEtBQUssVUFBTCxDQUFnQixnQkFBcEIsRUFBc0M7QUFDbEMsbUJBQU8sTUFBUCxDQUFjLHlCQUF5QixLQUF2QyxFQUE4QyxLQUFLLFVBQUwsQ0FBZ0IsZ0JBQTlEO0FBQ0g7O0FBRUQsYUFBSyxlQUFMLENBQXFCLElBQXJCLEVBQTJCLHdCQUEzQixFQUFxRCxVQUFyRDtBQUNILEtBM0oyQzs7QUE2SjVDOzs7Ozs7OztBQVFBLHFCQUFpQix5QkFBUyxJQUFULEVBQWUsd0JBQWYsRUFBeUMsVUFBekMsRUFBcUQ7QUFDbEUsaUNBQXlCLEtBQXpCLENBQStCLE9BQS9CLEdBQXlDLE9BQXpDOztBQUVBLFlBQU0sdUJBQXVCLE9BQU8sZ0JBQVAsQ0FBd0Isd0JBQXhCLENBQTdCOztBQUVBLFlBQUksZUFBSjtBQUFBLFlBQVksZUFBWjtBQUFBLFlBQW9CLGNBQWMsSUFBbEM7O0FBRUEsWUFBTSxlQUFlLHFCQUFxQixNQUFyQixDQUE0QixPQUE1QixDQUFvQyxJQUFwQyxFQUEwQyxFQUExQyxDQUFyQjtBQUNBLFlBQUssV0FBVyxDQUFYLEdBQWUsWUFBaEIsSUFBbUMsT0FBTyxXQUFXLENBQWxCLElBQXVCLE9BQU8sWUFBUCxDQUF4QixHQUFnRCxPQUFPLFdBQTdGLEVBQTJHO0FBQ3ZHLDBCQUFjLEtBQWQ7QUFDSDs7QUFFRCxZQUFJLFdBQUosRUFBaUI7QUFDYixxQkFBUyxXQUFXLENBQVgsR0FBZSxLQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWlCLEdBQWhDLEdBQXNDLHFCQUFxQixNQUFyQixDQUE0QixPQUE1QixDQUFvQyxJQUFwQyxFQUEwQyxFQUExQyxDQUEvQztBQUNBLHFCQUFTLFdBQVcsQ0FBWCxHQUFlLEtBQUssTUFBTCxDQUFZLElBQVosQ0FBaUIsSUFBaEMsR0FBdUMsS0FBSyxVQUFMLENBQWdCLGNBQWhFO0FBQ0gsU0FIRCxNQUdPO0FBQ0gscUJBQVMsV0FBVyxDQUFYLEdBQWUsV0FBVyxNQUExQixHQUFtQyxLQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWlCLEdBQTdEO0FBQ0EscUJBQVMsV0FBVyxDQUFYLEdBQWUsS0FBSyxNQUFMLENBQVksSUFBWixDQUFpQixJQUFoQyxHQUF1QyxLQUFLLFVBQUwsQ0FBZ0IsY0FBaEU7QUFDSDs7QUFFRCxpQ0FBeUIsS0FBekIsQ0FBK0IsR0FBL0IsR0FBcUMsU0FBUyxJQUE5QztBQUNBLGlDQUF5QixLQUF6QixDQUErQixJQUEvQixHQUFzQyxTQUFTLElBQS9DO0FBQ0gsS0EzTDJDOztBQTZMNUM7Ozs7OztBQU1BLHFCQUFpQix5QkFBUyxJQUFULEVBQWUsb0JBQWYsRUFBcUM7QUFDbEQsNkJBQXFCLFNBQXJCLEdBQWlDLEVBQWpDO0FBQ0EsNkJBQXFCLEtBQXJCLENBQTJCLE9BQTNCLEdBQXFDLE1BQXJDO0FBQ0EsaUNBQXlCLElBQXpCO0FBQ0EsWUFBSSxrQkFBSixFQUF3QjtBQUNwQix5QkFBYSxrQkFBYjtBQUNBLGlDQUFxQixJQUFyQjtBQUNIO0FBQ0osS0EzTTJDOztBQTZNNUM7Ozs7OztBQU1BLDhCQUEwQixrQ0FBUyxJQUFULEVBQWUsb0JBQWYsRUFBcUM7QUFBQTs7QUFDM0QsWUFBSSxDQUFDLGtCQUFMLEVBQXlCO0FBQ3JCLGlDQUFxQixXQUFXLFlBQU07QUFDbEMsdUJBQUssZUFBTCxDQUFxQixJQUFyQixFQUEyQixvQkFBM0I7QUFDSCxhQUZvQixFQUVsQixLQUFLLFVBQUwsQ0FBZ0Isc0JBRkUsQ0FBckI7QUFHSDtBQUNKLEtBek4yQzs7QUEyTjVDOzs7OztBQUtBLHNCQUFrQiwwQkFBUyxPQUFULEVBQWtCO0FBQ2hDLGdCQUFRLE1BQVI7QUFDSCxLQWxPMkM7O0FBb081Qzs7Ozs7Ozs7QUFRQSxvQkFBZ0Isd0JBQVMsT0FBVCxFQUFrQixNQUFsQixFQUEwQixTQUExQixFQUFxQztBQUNqRCxZQUFJLFFBQVEsTUFBUixJQUFrQixNQUF0QixFQUE4QjtBQUMxQixtQkFBTyxPQUFQO0FBQ0g7O0FBRUQsb0JBQVksYUFBYSxLQUF6Qjs7QUFFQSxZQUFJLFNBQVMsVUFBVSxNQUF2QjtBQUFBLFlBQ0ksY0FBYyxTQUFTLE1BRDNCO0FBQUEsWUFFSSxhQUFhLEtBQUssSUFBTCxDQUFVLGNBQWMsQ0FBeEIsQ0FGakI7QUFBQSxZQUdJLFlBQVksS0FBSyxLQUFMLENBQVcsY0FBYyxDQUF6QixDQUhoQjs7QUFLQSxlQUFPLFFBQVEsTUFBUixDQUFlLENBQWYsRUFBa0IsVUFBbEIsSUFDSCxTQURHLEdBRUgsUUFBUSxNQUFSLENBQWUsUUFBUSxNQUFSLEdBQWlCLFNBQWhDLENBRko7QUFHSDtBQTNQMkMsQ0FBOUIsQ0FBbEI7O0FBOFBBLE9BQU8sT0FBUCxHQUFpQixXQUFqQjs7O0FDNVFBOztBQUVBLElBQUksVUFBVSxRQUFRLFdBQVIsQ0FBZDs7QUFFQTs7O0FBR0EsSUFBSSxVQUFVLFFBQVEsTUFBUixDQUFlLFNBQWYsRUFBMEI7O0FBRXBDOzs7OztBQUtBLHFCQUFpQix5QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNuQyxZQUFJLFlBQVksS0FBSyxTQUFyQjtBQUNBLFlBQUksQ0FBQyxNQUFNLFFBQU4sQ0FBZSxNQUFmLENBQXNCLFNBQXRCLENBQUwsRUFBdUM7QUFDbkMsZ0JBQUksU0FBSixFQUFlO0FBQ1gscUJBQUssZUFBTCxDQUFxQixJQUFyQixFQUEyQixTQUEzQjtBQUNIO0FBQ0QsaUJBQUssZ0JBQUwsQ0FBc0IsSUFBdEIsRUFBNEIsS0FBNUI7QUFDQSxpQkFBSyxZQUFMLENBQWtCLEtBQWxCO0FBQ0gsU0FORCxNQU1PLElBQUksS0FBSyxJQUFULEVBQWU7QUFDbEIsaUJBQUssSUFBTCxDQUFVLGVBQVYsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBaEM7QUFDSDtBQUNKOztBQWxCbUMsQ0FBMUIsQ0FBZDs7QUFzQkEsT0FBTyxPQUFQLEdBQWlCLE9BQWpCOzs7QUM3QkE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJLFVBQVUsUUFBUSxXQUFSLENBQWQ7O0FBRUEsSUFBSSxrQkFBSjtBQUNBLElBQUkscUJBQUo7QUFDQSxJQUFJLHNCQUFKO0FBQ0EsSUFBSSx5QkFBSjs7QUFFQSxJQUFJLE9BQU8sQ0FBQyxNQUFELEVBQVMsV0FBVCxFQUFzQixjQUF0QixDQUFYO0FBQUEsSUFDSSxXQUFXLENBQUMsVUFBRCxFQUFhLGVBQWIsRUFBOEIsa0JBQTlCLENBRGY7O0FBR0E7Ozs7QUFJQSxJQUFJLGNBQWMsUUFBUSxNQUFSLENBQWUsYUFBZixFQUE4QjtBQUM1Qzs7OztBQUlBLGNBQVUsS0FMa0M7O0FBTzVDOzs7OztBQUtBLGdCQUFZLENBWmdDOztBQWM1Qzs7Ozs7QUFLQSxnQ0FBNEIsQ0FBQyxDQW5CZTs7QUFxQjVDOzs7Ozs7QUFNQSx3QkFBb0IsNEJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDdEMsYUFBSywwQkFBTCxDQUFnQyxJQUFoQzs7QUFFQSxZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLGtCQUFWLENBQTZCLElBQTdCO0FBQ0g7QUFDSixLQWpDMkM7QUFrQzVDOzs7OztBQUtBLGdDQUE0QixvQ0FBUyxJQUFULEVBQWU7QUFDdkMsYUFBSyxxQkFBTCxDQUEyQixJQUEzQjtBQUNBLFlBQUksQ0FBQyxzQkFBTCxFQUE2QjtBQUN6QixxQ0FBeUIsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBQXpCO0FBQ0EsbUNBQXVCLFlBQXZCLENBQW9DLE9BQXBDLEVBQTZDLEtBQTdDO0FBQ0EsbUNBQXVCLFlBQXZCLENBQW9DLFFBQXBDLEVBQThDLEtBQTlDO0FBQ0EsbUNBQXVCLEtBQXZCLENBQTZCLFFBQTdCLEdBQXdDLFVBQXhDOztBQUVBLHFCQUFTLElBQVQsQ0FBYyxXQUFkLENBQTBCLHNCQUExQjtBQUNBLHdDQUE0Qix1QkFBdUIsVUFBdkIsQ0FBa0MsSUFBbEMsRUFBd0MsRUFBRSxPQUFPLEtBQVQsRUFBeEMsQ0FBNUI7QUFDSDtBQUNKLEtBbEQyQzs7QUFvRDVDOzs7OztBQUtBLHFCQUFpQix5QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNuQyxZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLGVBQVYsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBaEM7QUFDSDtBQUNKLEtBN0QyQzs7QUErRDVDOzs7OztBQUtBLHFCQUFpQix5QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNuQyxZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLGVBQVYsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBaEM7QUFDSDtBQUNKLEtBeEUyQzs7QUEwRTVDOzs7OztBQUtBLG1CQUFlLHVCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ2pDLFlBQUksS0FBSyxJQUFULEVBQWU7QUFDWCxpQkFBSyxJQUFMLENBQVUsYUFBVixDQUF3QixJQUF4QixFQUE4QixLQUE5QjtBQUNIO0FBQ0osS0FuRjJDOztBQXFGNUM7Ozs7O0FBS0EscUJBQWlCLHlCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ25DLFlBQUksS0FBSyxJQUFULEVBQWU7QUFDWCxpQkFBSyxJQUFMLENBQVUsZUFBVixDQUEwQixJQUExQixFQUFnQyxLQUFoQztBQUNIO0FBQ0osS0E5RjJDOztBQWdHNUM7Ozs7Ozs7O0FBUUEsaUJBQWEscUJBQVMsSUFBVCxFQUFlLENBQWYsRUFBa0IsQ0FBbEIsRUFBcUIscUJBQXJCLEVBQTRDO0FBQ3JELGdDQUF3QixPQUFPLHFCQUFQLEtBQWlDLFdBQWpDLEdBQStDLHFCQUEvQyxHQUF1RSxJQUEvRjtBQUNBLGFBQUssR0FBTCxDQUFTLElBQUksS0FBSyxNQUFMLENBQVksSUFBWixDQUFpQixHQUE5QjtBQUNBLDJCQUFtQixLQUFuQixDQUF5QixHQUF6QixHQUErQixJQUFJLEtBQUssTUFBTCxDQUFZLElBQVosQ0FBaUIsR0FBckIsR0FBMkIsSUFBMUQ7O0FBRUEsWUFBSSxxQkFBSixFQUEyQjtBQUN2QixnQkFBSSxrQkFBa0IsS0FBSyxrQkFBTCxDQUF3QixJQUF4QixFQUE4QixDQUE5QixFQUFpQyxDQUFqQyxDQUF0QjtBQUNBLGdCQUFLLE9BQU8sZUFBUCxLQUEyQixXQUE1QixJQUE0QyxvQkFBb0IsS0FBSywwQkFBekUsRUFBcUc7QUFDakcscUJBQUssaUJBQUwsQ0FBdUIsSUFBdkIsRUFBNkIsZUFBN0I7QUFDQSxxQkFBSywwQkFBTCxHQUFrQyxlQUFsQztBQUNIO0FBQ0o7QUFDSixLQXBIMkM7O0FBc0g1Qzs7Ozs7O0FBTUEsdUJBQW1CLDJCQUFTLElBQVQsRUFBZSxNQUFmLEVBQXVCO0FBQ3RDLFlBQUksWUFBWSxLQUFLLGtCQUFMLENBQXdCLElBQXhCLEVBQThCLE1BQTlCLENBQWhCOztBQUVBLCtCQUF1QixLQUF2QixDQUE2QixHQUE3QixHQUFtQyxZQUFZLElBQS9DO0FBQ0gsS0FoSTJDOztBQWtJNUM7Ozs7O0FBS0EsdUJBQW1CLDJCQUFTLElBQVQsRUFBZTtBQUM5QixZQUFJLG9CQUFvQixLQUFLLFVBQUwsQ0FBZ0IsZ0JBQXhDO0FBQ0EsWUFBSSxTQUFTLEtBQUssd0JBQUwsQ0FBOEIsSUFBOUIsQ0FBYjtBQUNBLFlBQUksaUJBQWlCLEtBQUssUUFBTCxDQUFjLGNBQWQsQ0FBNkIsQ0FBN0IsRUFBZ0MsSUFBckQ7QUFDQSxZQUFJLFlBQVksS0FBSyxHQUFMLENBQVMsV0FBekI7O0FBRUEsWUFBSSxZQUFZLEtBQUssUUFBTCxDQUFjLHlCQUFkLENBQWhCO0FBQ0EsWUFBSSxXQUFXLEtBQUssR0FBTCxDQUFTLHFCQUFULEVBQWY7O0FBRUEsK0JBQXVCLFlBQXZCLENBQW9DLE9BQXBDLEVBQThDLFlBQVksU0FBYixHQUEwQixJQUF2RTtBQUNBLCtCQUF1QixZQUF2QixDQUFvQyxRQUFwQyxFQUErQyxvQkFBb0IsU0FBckIsR0FBa0MsSUFBaEY7QUFDQSwrQkFBdUIsS0FBdkIsQ0FBNkIsUUFBN0IsR0FBd0MsT0FBeEM7QUFDQSwrQkFBdUIsS0FBdkIsQ0FBNkIsR0FBN0IsR0FBbUMsU0FBUyxJQUE1QztBQUNBLCtCQUF1QixLQUF2QixDQUE2QixJQUE3QixHQUFvQyxTQUFTLElBQVQsR0FBZ0IsSUFBcEQ7QUFDQSwrQkFBdUIsS0FBdkIsQ0FBNkIsT0FBN0IsR0FBdUMsUUFBdkM7O0FBRUEsa0NBQTBCLFNBQTFCLENBQW9DLENBQXBDLEVBQXVDLENBQXZDLEVBQTBDLFNBQTFDLEVBQXFELGlCQUFyRDtBQUNBLGtDQUEwQixTQUExQixHQUFzQyxLQUFLLFVBQUwsQ0FBZ0IsaUNBQXREO0FBQ0Esa0NBQTBCLFFBQTFCLENBQW1DLENBQW5DLEVBQXNDLENBQXRDLEVBQXlDLGNBQXpDLEVBQXlELGlCQUF6RDtBQUNBLGtDQUEwQixTQUExQixHQUFzQyxLQUFLLFVBQUwsQ0FBZ0IsK0JBQXREO0FBQ0Esa0NBQTBCLFFBQTFCLENBQW1DLGNBQW5DLEVBQW1ELENBQW5ELEVBQXNELFNBQXRELEVBQWlFLGlCQUFqRTs7QUFFQSxhQUFLLGlCQUFMLENBQXVCLElBQXZCLEVBQTZCLEtBQUssZ0JBQUwsRUFBN0I7QUFDSCxLQTlKMkM7O0FBZ0s1Qzs7Ozs7OztBQU9BLDZCQUF5QixpQ0FBUyxPQUFULEVBQWtCLFFBQWxCLEVBQTRCLEtBQTVCLEVBQW1DO0FBQ3hELFlBQUksWUFBWSxTQUFTLENBQVQsRUFBWSxXQUFaLEtBQTRCLFNBQVMsTUFBVCxDQUFnQixDQUFoQixDQUE1QztBQUNBLGFBQUssT0FBTCxDQUFhLE9BQWIsRUFBc0IsV0FBVyxTQUFqQyxFQUE0QyxLQUE1QztBQUNBLGFBQUssT0FBTCxDQUFhLE9BQWIsRUFBc0IsUUFBUSxTQUE5QixFQUF5QyxLQUF6QztBQUNBLGFBQUssT0FBTCxDQUFhLE9BQWIsRUFBc0IsT0FBTyxTQUE3QixFQUF3QyxLQUF4QztBQUNBLGFBQUssT0FBTCxDQUFhLE9BQWIsRUFBc0IsTUFBTSxTQUE1QixFQUF1QyxLQUF2QztBQUNBLGFBQUssT0FBTCxDQUFhLE9BQWIsRUFBc0IsUUFBdEIsRUFBZ0MsS0FBaEM7QUFDSCxLQTlLMkM7O0FBZ0w1Qzs7Ozs7QUFLQSwyQkFBdUIsK0JBQVMsSUFBVCxFQUFlO0FBQ2xDLFlBQUksS0FBSyxRQUFULEVBQW1CO0FBQ2Y7QUFDSDs7QUFFRCxZQUFJLENBQUMsa0JBQUwsRUFBeUI7QUFDckIsaUNBQXFCLFNBQVMsYUFBVCxDQUF1QixRQUF2QixDQUFyQjtBQUNBLG9DQUF3QixtQkFBbUIsVUFBbkIsQ0FBOEIsSUFBOUIsRUFBb0MsRUFBRSxPQUFPLEtBQVQsRUFBcEMsQ0FBeEI7QUFDQSxxQkFBUyxJQUFULENBQWMsV0FBZCxDQUEwQixrQkFBMUI7QUFDSDs7QUFFRCxZQUFJLG9CQUFvQixLQUFLLGlCQUFMLEdBQXlCLEtBQUssVUFBTCxDQUFnQixnQkFBakU7QUFDQSxZQUFJLFNBQVMsS0FBSyx3QkFBTCxDQUE4QixJQUE5QixDQUFiOztBQUVBLFlBQUksaUJBQWlCLEtBQUssUUFBTCxDQUFjLGNBQWQsQ0FBNkIsQ0FBN0IsRUFBZ0MsSUFBckQ7QUFDQSxZQUFJLFlBQVksS0FBSyxHQUFMLENBQVMsV0FBekI7O0FBRUEsWUFBSSxZQUFZLEtBQUssUUFBTCxDQUFjLHFCQUFkLENBQWhCO0FBQ0EsWUFBSSxXQUFXLEtBQUssR0FBTCxDQUFTLHFCQUFULEVBQWY7O0FBRUEsMkJBQW1CLFlBQW5CLENBQWdDLE9BQWhDLEVBQTBDLFlBQVksU0FBYixHQUEwQixJQUFuRTtBQUNBLDJCQUFtQixZQUFuQixDQUFnQyxRQUFoQyxFQUEyQyxvQkFBb0IsU0FBckIsR0FBa0MsSUFBNUU7QUFDQSwyQkFBbUIsS0FBbkIsQ0FBeUIsUUFBekIsR0FBb0MsT0FBcEM7QUFDQSwyQkFBbUIsS0FBbkIsQ0FBeUIsR0FBekIsR0FBK0IsU0FBUyxJQUF4QztBQUNBLDJCQUFtQixLQUFuQixDQUF5QixJQUF6QixHQUFnQyxTQUFTLElBQVQsR0FBZ0IsSUFBaEQ7QUFDQSwyQkFBbUIsS0FBbkIsQ0FBeUIsT0FBekIsR0FBbUMsUUFBbkM7O0FBRUEsOEJBQXNCLFNBQXRCLENBQWdDLENBQWhDLEVBQW1DLENBQW5DLEVBQXNDLFNBQXRDLEVBQWlELGlCQUFqRDtBQUNBLDhCQUFzQixTQUF0QixHQUFrQyxLQUFLLFVBQUwsQ0FBZ0IscUNBQWxEO0FBQ0EsOEJBQXNCLFFBQXRCLENBQStCLENBQS9CLEVBQWtDLENBQWxDLEVBQXFDLGNBQXJDLEVBQXFELGlCQUFyRDs7QUFFQSxZQUFJLE9BQU8sSUFBWDtBQUNBLDJCQUFtQixZQUFuQixHQUFrQyxVQUFTLEtBQVQsRUFBZ0I7QUFDOUMsZ0JBQUksQ0FBQyxLQUFLLFFBQVYsRUFBb0I7QUFDaEIsc0JBQU0sd0JBQU47QUFDQSxzQkFBTSxjQUFOO0FBQ0EscUJBQUssTUFBTCxHQUFjLElBQWQ7O0FBRUEsc0NBQXNCLFNBQXRCLENBQWdDLENBQWhDLEVBQW1DLENBQW5DLEVBQXNDLFNBQXRDLEVBQWlELGlCQUFqRDtBQUNBLHNDQUFzQixTQUF0QixHQUFrQyxLQUFLLFVBQUwsQ0FBZ0Isb0NBQWxEO0FBQ0Esc0NBQXNCLFFBQXRCLENBQStCLENBQS9CLEVBQWtDLENBQWxDLEVBQXFDLGNBQXJDLEVBQXFELGlCQUFyRDtBQUNIO0FBQ0osU0FWRDs7QUFZQSwyQkFBbUIsWUFBbkIsR0FBa0MsWUFBVztBQUN6QyxnQkFBSSxDQUFDLEtBQUssUUFBVixFQUFvQjtBQUNoQixzQkFBTSx3QkFBTjtBQUNBLHNCQUFNLGNBQU47O0FBRUEscUJBQUssTUFBTCxHQUFjLElBQWQ7O0FBRUEsc0NBQXNCLFNBQXRCLENBQWdDLENBQWhDLEVBQW1DLENBQW5DLEVBQXNDLFNBQXRDLEVBQWlELGlCQUFqRDtBQUNBLHNDQUFzQixTQUF0QixHQUFrQyxLQUFLLFVBQUwsQ0FBZ0IscUNBQWxEO0FBQ0Esc0NBQXNCLFFBQXRCLENBQStCLENBQS9CLEVBQWtDLENBQWxDLEVBQXFDLGNBQXJDLEVBQXFELGlCQUFyRDtBQUNIO0FBQ0osU0FYRDs7QUFhQSwyQkFBbUIsV0FBbkIsR0FBaUMsVUFBUyxLQUFULEVBQWdCO0FBQzdDLGtCQUFNLHdCQUFOO0FBQ0Esa0JBQU0sY0FBTjtBQUNBLGlCQUFLLE1BQUwsR0FBYyxRQUFkOztBQUVBLGlCQUFLLFFBQUwsR0FBZ0IsSUFBaEI7O0FBRUEsaUJBQUssbUJBQUwsQ0FBeUIsS0FBSyxtQkFBTCxFQUF6QixFQUFxRCxLQUFLLGdCQUFMLEtBQTBCLENBQS9FOztBQUVBLGlCQUFLLGlCQUFMLENBQXVCLElBQXZCO0FBQ0EsaUJBQUssVUFBTCxHQUFrQixtQkFBbUIscUJBQW5CLEdBQTJDLEdBQTdEOztBQUVBLGtDQUFzQixTQUF0QixDQUFnQyxDQUFoQyxFQUFtQyxDQUFuQyxFQUFzQyxTQUF0QyxFQUFpRCxpQkFBakQ7QUFDQSxrQ0FBc0IsU0FBdEIsR0FBa0MsS0FBSyxVQUFMLENBQWdCLHFDQUFsRDtBQUNBLGtDQUFzQixRQUF0QixDQUErQixDQUEvQixFQUFrQyxDQUFsQyxFQUFxQyxjQUFyQyxFQUFxRCxpQkFBckQ7QUFDQSxrQ0FBc0IsU0FBdEIsR0FBa0MsS0FBSyxVQUFMLENBQWdCLG1DQUFsRDtBQUNBLGtDQUFzQixRQUF0QixDQUErQixjQUEvQixFQUErQyxDQUEvQyxFQUFrRCxTQUFsRCxFQUE2RCxpQkFBN0Q7O0FBRUEscUJBQVMsV0FBVCxHQUF1QixVQUFTLENBQVQsRUFBWTtBQUMvQixvQkFBSSxPQUFPLEVBQUUsT0FBRixHQUFhLEtBQUssVUFBTCxDQUFnQixnQkFBaEIsR0FBbUMsQ0FBaEQsR0FBcUQsS0FBSyxNQUFMLENBQVksSUFBWixDQUFpQixHQUFqRjs7QUFFQSxxQkFBSyxXQUFMLENBQWlCLElBQWpCLEVBQXVCLEVBQUUsT0FBekIsRUFBa0MsSUFBbEM7QUFDSCxhQUpEO0FBS0EscUJBQVMsU0FBVCxHQUFxQixVQUFTLENBQVQsRUFBWTtBQUM3Qix5QkFBUyxXQUFULEdBQXVCLElBQXZCO0FBQ0EseUJBQVMsU0FBVCxHQUFxQixJQUFyQjs7QUFFQSxvQkFBSSxLQUFLLFFBQVQsRUFBbUI7QUFDZix5QkFBSyxNQUFMLEdBQWMsSUFBZDtBQUNBLHlCQUFLLGVBQUwsQ0FBcUIsSUFBckI7QUFDQSx5QkFBSyxRQUFMO0FBQ0EseUJBQUssV0FBTCxDQUFpQixJQUFqQixFQUF1QixDQUF2QixFQUEwQixLQUFLLHdCQUFMLENBQThCLElBQTlCLElBQXNDLEtBQUssTUFBTCxDQUFZLElBQVosQ0FBaUIsR0FBakYsRUFBc0YsS0FBdEY7QUFDSDtBQUNELHFCQUFLLFFBQUwsR0FBZ0IsS0FBaEI7QUFDQSxxQkFBSyxNQUFMLEdBQWMsSUFBZDs7QUFFQSxzQ0FBc0IsU0FBdEIsQ0FBZ0MsQ0FBaEMsRUFBbUMsQ0FBbkMsRUFBc0MsU0FBdEMsRUFBaUQsaUJBQWpEO0FBQ0Esc0NBQXNCLFNBQXRCLEdBQWtDLEtBQUssVUFBTCxDQUFnQixxQ0FBbEQ7QUFDQSxzQ0FBc0IsUUFBdEIsQ0FBK0IsQ0FBL0IsRUFBa0MsQ0FBbEMsRUFBcUMsY0FBckMsRUFBcUQsaUJBQXJEO0FBQ0gsYUFoQkQ7QUFpQkgsU0F4Q0Q7QUF5Q0gsS0F2UjJDOztBQXlSNUM7Ozs7O0FBS0EsOEJBQTBCLGtDQUFTLElBQVQsRUFBZTtBQUNyQyxlQUFPLEtBQUssa0JBQUwsQ0FBd0IsSUFBeEIsRUFBOEIsS0FBSyxVQUFMLENBQWdCLGFBQWhCLEdBQWdDLENBQTlELENBQVA7QUFDSCxLQWhTMkM7O0FBa1M1Qzs7Ozs7O0FBTUEsd0JBQW9CLDRCQUFTLElBQVQsRUFBZSxRQUFmLEVBQXlCO0FBQ3pDLFlBQUksaUJBQWlCLEtBQUssaUJBQUwsRUFBckI7QUFDQSxZQUFJLFdBQVcsY0FBZixFQUErQjtBQUMzQix1QkFBVyxjQUFYO0FBQ0g7O0FBRUQsWUFBSSxHQUFKO0FBQ0EsWUFBSSxXQUFXLENBQWYsRUFBa0I7QUFBRTtBQUNoQixnQkFBSSxNQUFNLEtBQUssUUFBTCxDQUFjLFdBQWQsQ0FBMEIsV0FBVyxDQUFyQyxDQUFWO0FBQ0EsZ0JBQUksQ0FBQyxHQUFMLEVBQVU7QUFDTixzQkFBTSxLQUFLLFFBQUwsQ0FBYyxXQUFkLENBQTBCLENBQTFCLENBQU47QUFDSDtBQUNELGtCQUFNLE1BQU0sSUFBSSxNQUFWLEdBQW1CLENBQXpCO0FBQ0gsU0FORCxNQU1PO0FBQ0gsa0JBQU0sS0FBSyxRQUFMLENBQWMsV0FBZCxDQUEwQixDQUExQixFQUE2QixNQUE3QixHQUFzQyxLQUFLLGlCQUEzQyxHQUErRCxDQUFyRTtBQUNIOztBQUVELGVBQU8sTUFBTSxLQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWlCLEdBQTlCO0FBQ0gsS0ExVDJDO0FBMlQ1Qzs7Ozs7QUFLQSxxQkFBaUIseUJBQVMsSUFBVCxFQUFlO0FBQzVCLFlBQUksdUJBQXVCLEtBQUssVUFBTCxDQUFnQixhQUEzQztBQUNBLCtCQUF1QixLQUF2QixDQUE2QixPQUE3QixHQUF1QyxNQUF2Qzs7QUFFQSxZQUFJLEtBQUssMEJBQUwsR0FBa0MsQ0FBdEMsRUFBeUM7QUFDckM7QUFDSDs7QUFFRCxZQUFJLG1CQUFtQixLQUFLLDBCQUFMLEdBQWtDLEtBQUssaUJBQUwsRUFBekQ7O0FBRUEsYUFBSyxhQUFMLENBQW1CO0FBQ2YsMkJBQWU7QUFEQSxTQUFuQjs7QUFJQSxhQUFLLHdDQUFMLENBQThDLG9CQUE5QyxFQUFvRSxnQkFBcEU7QUFDSCxLQS9VMkM7O0FBaVY1Qzs7Ozs7OztBQU9BLHdCQUFvQiw0QkFBUyxJQUFULEVBQWUsQ0FBZixFQUFrQixDQUFsQixFQUFxQjtBQUNyQyxZQUFJLGtCQUFrQixLQUFLLFFBQUwsQ0FBYyx5QkFBZCxDQUF3QyxFQUFFLEdBQUcsQ0FBTCxFQUFRLEdBQUcsQ0FBWCxFQUF4QyxDQUF0QjtBQUNBLFlBQUksc0JBQXNCLGdCQUFnQixTQUFoQixDQUEwQixVQUExQixDQUFxQyxRQUEvRDtBQUNBLFlBQUksY0FBYyxLQUFLLFFBQUwsQ0FBYyxXQUFoQzs7QUFFQSxZQUFJLE1BQU0sS0FBSyxtQkFBTCxFQUFWO0FBQ0EsWUFBSSxlQUFlLFlBQVksS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLG1CQUFkLENBQVosRUFBZ0QsR0FBbkU7QUFDQSxZQUFJLGFBQWEsWUFBWSxLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsbUJBQWQsQ0FBWixFQUFnRCxNQUFqRTs7QUFFQSxZQUFJLE1BQU0sbUJBQVY7O0FBRUEsWUFBSSxFQUFFLEtBQUssR0FBTCxDQUFTLGVBQWUsQ0FBeEIsSUFBNkIsS0FBSyxHQUFMLENBQVMsYUFBYSxDQUF0QixDQUEvQixDQUFKLEVBQThEO0FBQzFELG1CQUFPLENBQVA7QUFDSDs7QUFFRCxZQUFJLE9BQU8sWUFBWSxZQUFZLE1BQVosR0FBcUIsQ0FBakMsRUFBb0MsV0FBL0MsRUFBNEQ7QUFDeEQsa0JBQU0sWUFBWSxZQUFZLE1BQVosR0FBcUIsQ0FBakMsRUFBb0MsV0FBMUM7QUFDSDs7QUFFRCxZQUFJLGlCQUFpQixLQUFLLGlCQUFMLEVBQXJCOztBQUVBLFlBQUksT0FBTyxjQUFYLEVBQTJCO0FBQ3ZCLGtCQUFNLGNBQU47QUFDSDtBQUNELGVBQU8sR0FBUDtBQUNILEtBalgyQzs7QUFtWDVDLGFBQVMsaUJBQVMsT0FBVCxFQUFrQixRQUFsQixFQUE0QixLQUE1QixFQUFtQztBQUN4QyxZQUFJLFlBQVksUUFBUSxLQUF4QixFQUErQjtBQUMzQixvQkFBUSxLQUFSLENBQWMsUUFBZCxJQUEwQixLQUExQjtBQUNIO0FBQ0o7QUF2WDJDLENBQTlCLENBQWxCOztBQTBYQSxPQUFPLE9BQVAsR0FBaUIsV0FBakI7OztBQzdZQTs7QUFFQSxJQUFJLFVBQVUsUUFBUSxXQUFSLENBQWQ7O0FBRUE7OztBQUdBLElBQUksZUFBZSxRQUFRLE1BQVIsQ0FBZSxjQUFmLEVBQStCOztBQUU5Qzs7Ozs7O0FBTUEsaUJBQWEsSUFSaUM7O0FBVTlDOzs7Ozs7QUFNQSxrQkFBYyxJQWhCZ0M7O0FBa0I5Qzs7Ozs7O0FBTUEsZ0JBQVksQ0F4QmtDOztBQTBCOUM7Ozs7OztBQU1BLGlCQUFhLENBaENpQzs7QUFrQzlDLGVBQVcsS0FsQ21DOztBQW9DOUM7Ozs7O0FBS0EsbUJBQWUsdUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDakMsWUFBSSxLQUFLLFNBQVQsRUFBb0I7QUFDaEIsaUJBQUssU0FBTCxHQUFpQixLQUFqQjtBQUNBLGlCQUFLLHFDQUFMO0FBQ0gsU0FIRCxNQUdPLElBQUksS0FBSyxRQUFULEVBQW1CO0FBQ3RCLGlCQUFLLFFBQUwsR0FBZ0IsS0FBaEI7QUFDQSxpQkFBSyxxQ0FBTDtBQUNILFNBSE0sTUFHQSxJQUFJLEtBQUssSUFBVCxFQUFlO0FBQ2xCLGlCQUFLLElBQUwsQ0FBVSxhQUFWLENBQXdCLElBQXhCLEVBQThCLEtBQTlCO0FBQ0g7QUFDSixLQW5ENkM7O0FBcUQ5Qzs7Ozs7QUFLQSxxQkFBaUIseUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDbkMsWUFBSSxnQkFBZ0IsS0FBSyxVQUFMLENBQWdCLFlBQWhCLElBQ2hCLENBQUMsTUFBTSxjQUFOLENBQXFCLE1BQXJCLENBQTRCLFlBRGIsSUFFaEIsS0FBSyxVQUFMLENBQWdCLGNBRkEsSUFHaEIsTUFBTSxjQUhWOztBQUtBLFlBQUksaUJBQWlCLE1BQU0sY0FBM0IsRUFBMkM7QUFDdkM7QUFDQSxpQkFBSyxtQkFBTDtBQUNILFNBSEQsTUFHTyxJQUFJLGlCQUFpQixNQUFNLFNBQTNCLEVBQXVDO0FBQzFDO0FBQ0EsaUJBQUssU0FBTCxHQUFpQixJQUFqQjtBQUNBLGlCQUFLLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsTUFBTSxRQUFOLENBQWUsQ0FBMUMsRUFBNkMsTUFBTSxjQUFOLENBQXFCLE1BQXJCLENBQTRCLElBQXpFO0FBQ0gsU0FKTSxNQUlBLElBQUksS0FBSyxJQUFULEVBQWU7QUFDbEIsaUJBQUssSUFBTCxDQUFVLGVBQVYsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBaEM7QUFDSDtBQUNKLEtBMUU2Qzs7QUE0RTlDOzs7OztBQUtBLHFCQUFpQix5QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNuQyxZQUNJLEtBQUssU0FBTCxJQUNBLEtBQUssVUFBTCxDQUFnQixZQURoQixJQUVBLENBQUMsTUFBTSxjQUFOLENBQXFCLE1BQXJCLENBQTRCLFlBSGpDLEVBSUU7QUFDRTtBQUNBLGlCQUFLLFdBQUwsR0FBbUIsTUFBTSxRQUFOLENBQWUsQ0FBbEM7QUFDQSxpQkFBSyxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsaUJBQUssV0FBTCxHQUFtQixNQUFNLGNBQU4sQ0FBcUIsTUFBckIsQ0FBNEIsS0FBL0M7QUFDQSxpQkFBSyxlQUFMLENBQXFCLElBQXJCLEVBQTJCLEtBQUssV0FBaEM7QUFDQSxpQkFBSyw0QkFBTCxDQUFrQyxJQUFsQyxFQUF3QyxLQUFLLFdBQTdDLEVBQTBELE1BQU0sY0FBTixDQUFxQixNQUFyQixDQUE0QixJQUF0RjtBQUNILFNBWEQsTUFXTyxJQUFJLEtBQUssSUFBVCxFQUFlO0FBQ2xCLGlCQUFLLElBQUwsQ0FBVSxlQUFWLENBQTBCLElBQTFCLEVBQWdDLEtBQWhDO0FBQ0g7QUFDSixLQWhHNkM7O0FBa0c5Qzs7Ozs7QUFLQSxtQkFBZSx1QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNqQyxZQUFJLE9BQUo7QUFDQSxZQUNJLEtBQUssb0JBQUwsT0FBZ0MsS0FBaEMsS0FDQyxVQUFVLEtBQUssV0FBVyxNQUFNLE1BQU4sQ0FBYSxJQUE3QixDQURYLENBREosRUFHRTtBQUNFLG9CQUFRLElBQVIsQ0FBYSxJQUFiLEVBQW1CLElBQW5CLEVBQXlCLE1BQU0sTUFBL0I7QUFDSCxTQUxELE1BS08sSUFBSSxLQUFLLElBQVQsRUFBZTtBQUNsQixpQkFBSyxJQUFMLENBQVUsYUFBVixDQUF3QixJQUF4QixFQUE4QixLQUE5QjtBQUNIO0FBQ0osS0FqSDZDOztBQW1IOUM7Ozs7Ozs7QUFPQSxrQ0FBOEIsc0NBQVMsSUFBVCxFQUFlLENBQWYsRUFBa0IsSUFBbEIsRUFBd0I7QUFDbEQsWUFBSSxTQUFTLEtBQUssWUFBTCxHQUFvQixDQUFqQzs7QUFFQSxhQUFLLDJCQUFMOztBQUVBLGFBQUssU0FBTCxDQUFlLE1BQWYsRUFBdUIsQ0FBdkI7QUFDQSxhQUFLLGFBQUwsQ0FBbUIsS0FBSyxRQUFMLENBQWMsQ0FBZCxFQUFpQixJQUFJLE1BQXJCLENBQW5COztBQUVBLGFBQUssT0FBTDtBQUNILEtBbkk2Qzs7QUFxSTlDOzs7Ozs7QUFNQSxxQkFBaUIseUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDbkMsWUFDSSxLQUFLLFVBQUwsQ0FBZ0IsZ0JBQWhCLElBQ0EsS0FBSyxhQUFMLEdBQXFCLFFBQXJCLENBQThCLEtBQTlCLENBRkosRUFHRTtBQUNFLGdCQUFJLEtBQUssY0FBTCxFQUFKLEVBQTJCO0FBQ3ZCLHFCQUFLLGVBQUwsQ0FBcUIsS0FBckI7QUFDSDtBQUNKLFNBUEQsTUFPTztBQUNILGdCQUFJLENBQUMsS0FBSyxjQUFMLEVBQUwsRUFBNEI7QUFDeEIscUJBQUssZUFBTCxDQUFxQixJQUFyQjtBQUNBLHFCQUFLLFVBQUwsQ0FBZ0IsSUFBaEI7QUFDSDtBQUNKO0FBQ0osS0F6SjZDOztBQTJKOUM7Ozs7O0FBS0EsZ0JBQVksb0JBQVMsSUFBVCxFQUFlO0FBQ3ZCLFlBQUksQ0FBQyxLQUFLLGNBQUwsRUFBTCxFQUE0QjtBQUN4QjtBQUNIOztBQUVELFlBQUksSUFBSSxLQUFLLGFBQUwsRUFBUjtBQUFBLFlBQ0ksT0FESjs7QUFHQSxZQUFJLEtBQUssV0FBTCxDQUFpQixDQUFqQixHQUFxQixFQUFFLE1BQUYsQ0FBUyxDQUFsQyxFQUFxQztBQUNqQyxzQkFBVSxDQUFDLENBQVg7QUFDSCxTQUZELE1BRU8sSUFBSSxLQUFLLFdBQUwsQ0FBaUIsQ0FBakIsR0FBcUIsRUFBRSxNQUFGLENBQVMsQ0FBVCxHQUFhLEVBQUUsTUFBRixDQUFTLENBQS9DLEVBQWtEO0FBQ3JELHNCQUFVLENBQVY7QUFDSDs7QUFFRCxZQUFJLE9BQUosRUFBYTtBQUNULGdCQUFJLEtBQUssV0FBTCxJQUFvQixLQUFLLGdCQUFMLEVBQXhCLEVBQWlEO0FBQzdDLHFCQUFLLFdBQUwsSUFBb0IsT0FBcEI7QUFDSDtBQUNELGlCQUFLLFFBQUwsQ0FBYyxDQUFkLEVBQWlCLE9BQWpCO0FBQ0g7O0FBRUQsYUFBSyw0QkFBTCxDQUFrQyxJQUFsQyxFQUF3QyxLQUFLLFdBQTdDLEVBQTBELEVBQTFELEVBckJ1QixDQXFCd0M7QUFDL0QsYUFBSyxPQUFMO0FBQ0EsbUJBQVcsS0FBSyxVQUFMLENBQWdCLElBQWhCLENBQXFCLElBQXJCLEVBQTJCLElBQTNCLENBQVgsRUFBNkMsRUFBN0M7QUFDSCxLQXhMNkM7O0FBMEw5Qzs7Ozs7OztBQU9BLHFCQUFpQix5QkFBUyxJQUFULEVBQWUsQ0FBZixFQUFrQixJQUFsQixFQUF3QjtBQUNyQyxZQUFJLENBQUMsS0FBSyxZQUFMLEVBQUwsRUFBMEI7QUFBRTtBQUFTOztBQUVyQyxZQUFJLFNBQVMsS0FBSyxZQUFMLEdBQW9CLENBQWpDO0FBQUEsWUFDSSxXQUFXLEtBQUssT0FBTCxDQUFhLE9BQWIsTUFBMEIsQ0FBQyxDQUQxQzs7QUFHQSxZQUFJLElBQUksQ0FBUixFQUFXO0FBQUU7QUFDVCxtQkFETyxDQUNDO0FBQ1g7O0FBRUQsWUFBSSxRQUFKLEVBQWM7QUFDVixpQkFBSywyQkFBTDtBQUNBLGlCQUFLLFNBQUwsQ0FBZSxDQUFmLEVBQWtCLE1BQWxCO0FBQ0EsaUJBQUssYUFBTCxDQUFtQixLQUFLLFFBQUwsQ0FBYyxDQUFkLEVBQWlCLElBQUksTUFBckIsQ0FBbkI7QUFDSCxTQUpELE1BSU87QUFDSCxpQkFBSyxlQUFMLENBQXFCLENBQXJCLEVBQXdCLElBQXhCO0FBQ0EsaUJBQUssWUFBTCxDQUFrQixLQUFLLFFBQUwsQ0FBYyxDQUFkLEVBQWlCLENBQWpCLENBQWxCO0FBQ0EsaUJBQUssYUFBTCxDQUFtQixLQUFLLFFBQUwsQ0FBYyxDQUFkLEVBQWlCLENBQWpCLENBQW5CO0FBQ0g7O0FBRUQsYUFBSyxPQUFMO0FBQ0gsS0F0TjZDOztBQXlOOUM7Ozs7QUFJQSxxQkFBaUIseUJBQVMsSUFBVCxFQUFlO0FBQzVCLGFBQUssZUFBTCxDQUFxQixJQUFyQixFQUEyQixDQUEzQjtBQUNILEtBL042Qzs7QUFpTzlDOzs7OztBQUtBLG1CQUFlLHVCQUFTLElBQVQsRUFBZTtBQUMxQixhQUFLLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsQ0FBQyxDQUE1QjtBQUNILEtBeE82Qzs7QUEwTzlDOzs7OztBQUtBLHFCQUFpQix5QkFBUyxJQUFULEVBQWUsQ0FBRSxDQS9PWTs7QUFpUDlDOzs7OztBQUtBLHNCQUFrQiwwQkFBUyxJQUFULEVBQWUsQ0FBRSxDQXRQVzs7QUF3UDlDOzs7OztBQUtBLGdCQUFZLG9CQUFTLElBQVQsRUFBZTtBQUN2QixhQUFLLGdCQUFMLENBQXNCLElBQXRCLEVBQTRCLENBQTVCO0FBQ0gsS0EvUDZDOztBQWlROUM7Ozs7O0FBS0EsY0FBVSxrQkFBUyxJQUFULEVBQWU7QUFDckIsYUFBSyxnQkFBTCxDQUFzQixJQUF0QixFQUE0QixDQUFDLENBQTdCO0FBQ0gsS0F4UTZDOztBQTBROUM7Ozs7O0FBS0EsZ0JBQVksb0JBQVMsSUFBVCxFQUFlLENBQUUsQ0EvUWlCOztBQWlSOUM7Ozs7O0FBS0EsaUJBQWEscUJBQVMsSUFBVCxFQUFlO0FBQ3hCLFlBQUksY0FBYyxLQUFLLFlBQUwsR0FBb0IsSUFBcEIsQ0FBeUIsS0FBSyxhQUFMLEVBQXpCLENBQWxCO0FBQUEsWUFDSSxhQUFhLEtBQUssY0FBTCxLQUF3QixDQUR6QztBQUFBLFlBRUksT0FBTyxLQUFLLGVBQUwsRUFGWDtBQUFBLFlBR0ksT0FBTyxZQUFZLENBSHZCOztBQUtBLGVBQU8sS0FBSyxHQUFMLENBQVMsVUFBVCxFQUFxQixJQUFyQixDQUFQOztBQUVBLGFBQUssZUFBTDtBQUNBLGFBQUssTUFBTCxDQUFZLElBQVosRUFBa0IsSUFBbEIsRUFBd0IsQ0FBeEIsRUFBMkIsQ0FBM0I7QUFDQSxhQUFLLFlBQUwsQ0FBa0IsS0FBSyxRQUFMLENBQWMsSUFBZCxFQUFvQixJQUFwQixDQUFsQjtBQUNBLGFBQUssYUFBTCxDQUFtQixLQUFLLFFBQUwsQ0FBYyxDQUFkLEVBQWlCLENBQWpCLENBQW5COztBQUVBLGFBQUssT0FBTDtBQUNILEtBcFM2Qzs7QUFzUzlDOzs7OztBQUtBLCtCQUEyQixxQ0FBVztBQUNsQyxZQUFJLFFBQVEsQ0FBWjtBQUNBLFlBQUksVUFBVSxLQUFLLHFCQUFMLEtBQStCLElBQTdDO0FBQ0EsZ0JBQVEsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLEtBQUssS0FBTCxDQUFXLFVBQVUsT0FBVixHQUFvQixPQUFwQixHQUE4QixPQUF6QyxDQUFaLENBQVI7QUFDQSxlQUFPLEtBQVA7QUFDSCxLQWhUNkM7O0FBa1Q5Qzs7OztBQUlBLDRCQUF3QixrQ0FBVztBQUMvQixhQUFLLFdBQUwsR0FBbUIsS0FBSyxHQUFMLEVBQW5CO0FBQ0gsS0F4VDZDOztBQTBUOUM7Ozs7QUFJQSxvQkFBZ0IsMEJBQVc7QUFDdkIsWUFBSSxNQUFNLEtBQUssR0FBTCxFQUFWO0FBQ0EsWUFBSSxNQUFNLEtBQUssVUFBWCxHQUF3QixHQUE1QixFQUFpQztBQUM3QixpQkFBSyxzQkFBTDtBQUNIO0FBQ0QsYUFBSyxVQUFMLEdBQWtCLEtBQUssR0FBTCxFQUFsQjtBQUNILEtBcFU2Qzs7QUFzVTlDOzs7OztBQUtBLDJCQUF1QixpQ0FBVztBQUM5QixZQUFJLEtBQUssR0FBTCxLQUFhLEtBQUssVUFBbEIsR0FBK0IsR0FBbkMsRUFBd0M7QUFDcEMsbUJBQU8sQ0FBUDtBQUNIO0FBQ0QsZUFBTyxLQUFLLEdBQUwsS0FBYSxLQUFLLFdBQXpCO0FBQ0gsS0FoVjZDOztBQWtWOUM7Ozs7Ozs7QUFPQSxxQkFBaUIseUJBQVMsSUFBVCxFQUFlLE9BQWYsRUFBd0I7QUFDckMsWUFBSSxTQUFTLEtBQUssWUFBTCxFQUFiO0FBQUEsWUFDSSxTQUFTLEtBQUssYUFBTCxFQURiO0FBQUEsWUFFSSxrQkFBa0IsS0FBSyxRQUFMLENBQWMsV0FBZCxDQUEwQixNQUExQixHQUFtQyxDQUZ6RDtBQUFBLFlBR0ksVUFBVSxLQUFLLFdBQUwsS0FBcUIsQ0FIbkM7O0FBS0EsWUFBSSxDQUFDLEtBQUssVUFBTCxDQUFnQixnQkFBckIsRUFBdUM7QUFDbkMsc0JBQVUsS0FBSyxHQUFMLENBQVMsT0FBVCxFQUFrQixlQUFsQixDQUFWO0FBQ0g7O0FBRUQsWUFBSSxPQUFPLE9BQU8sQ0FBUCxHQUFXLE9BQXRCOztBQUVBLGVBQU8sS0FBSyxHQUFMLENBQVMsVUFBVSxPQUFPLENBQTFCLEVBQTZCLEtBQUssR0FBTCxDQUFTLENBQUMsT0FBTyxDQUFqQixFQUFvQixJQUFwQixDQUE3QixDQUFQOztBQUVBLGFBQUssMkJBQUw7QUFDQSxhQUFLLFNBQUwsQ0FBZSxPQUFPLENBQXRCLEVBQXlCLE9BQU8sQ0FBUCxHQUFXLElBQXBDO0FBQ0EsYUFBSyxhQUFMLENBQW1CLEtBQUssUUFBTCxDQUFjLENBQWQsRUFBaUIsSUFBakIsQ0FBbkI7O0FBRUEsWUFBSSxLQUFLLHVCQUFMLENBQTZCLE9BQU8sT0FBTyxDQUEzQyxFQUE4QyxPQUE5QyxDQUFKLEVBQTREO0FBQ3hELGlCQUFLLGNBQUw7QUFDSDs7QUFFRCxhQUFLLHFDQUFMOztBQUVBLGFBQUssT0FBTDtBQUNILEtBbFg2Qzs7QUFvWDlDOzs7Ozs7O0FBT0Esc0JBQWtCLDBCQUFTLElBQVQsRUFBZSxPQUFmLEVBQXdCO0FBQ3RDLFlBQUksVUFBVSxLQUFLLFdBQUwsS0FBcUIsQ0FBbkM7QUFBQSxZQUNJLGtCQUFrQixLQUFLLG1CQUFMLEtBQTZCLENBRG5EO0FBQUEsWUFFSSxjQUFjLEtBQUssWUFBTCxHQUFvQixJQUFwQixDQUF5QixLQUFLLGFBQUwsRUFBekIsQ0FGbEI7QUFBQSxZQUdJLE9BQU8sWUFBWSxDQUFaLEdBQWdCLE9BSDNCOztBQUtBLFlBQUksQ0FBQyxLQUFLLFVBQUwsQ0FBZ0IsZ0JBQXJCLEVBQXVDO0FBQ25DLHNCQUFVLEtBQUssR0FBTCxDQUFTLE9BQVQsRUFBa0IsZUFBbEIsQ0FBVjtBQUNIOztBQUVELGVBQU8sS0FBSyxHQUFMLENBQVMsT0FBVCxFQUFrQixLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBWixDQUFsQixDQUFQOztBQUVBLGFBQUssZUFBTDtBQUNBLGFBQUssU0FBTCxDQUFlLElBQWY7QUFDQSxhQUFLLFlBQUwsQ0FBa0IsS0FBSyxRQUFMLENBQWMsQ0FBZCxFQUFpQixJQUFqQixDQUFsQjtBQUNBLGFBQUssYUFBTCxDQUFtQixLQUFLLFFBQUwsQ0FBYyxDQUFkLEVBQWlCLENBQWpCLENBQW5COztBQUVBLFlBQUksS0FBSyx1QkFBTCxDQUE2QixJQUE3QixFQUFtQyxPQUFuQyxDQUFKLEVBQWlEO0FBQzdDLGlCQUFLLGNBQUw7QUFDSDs7QUFFRCxhQUFLLHFDQUFMO0FBQ0EsYUFBSyxPQUFMO0FBQ0gsS0FsWjZDOztBQW9aOUMsMEJBQXNCLGdDQUFXO0FBQzdCLGVBQU8sSUFBUDtBQUNIOztBQXRaNkMsQ0FBL0IsQ0FBbkI7O0FBMFpBLE9BQU8sT0FBUCxHQUFpQixZQUFqQjs7O0FDamFBOztBQUVBLElBQUksVUFBVSxRQUFRLFdBQVIsQ0FBZDs7QUFFQTs7O0FBR0EsSUFBSSxzQkFBc0IsUUFBUSxNQUFSLENBQWUscUJBQWYsRUFBc0M7O0FBRTVEOzs7OztBQUtBLHNCQUFrQiwwQkFBUyxJQUFULEVBQWUsQ0FBZixFQUFrQjtBQUNoQyxZQUFJLENBQUMsS0FBSyxVQUFMLENBQWdCLGdCQUFyQixFQUF1QztBQUNuQztBQUNIOztBQUVELFlBQUksWUFBWSxFQUFFLGNBQWxCO0FBQUEsWUFDSSxTQUFTLEtBQUssSUFBTCxDQUFVLFVBQVUsV0FBVixJQUF5QixDQUFDLFVBQVUsTUFBOUMsQ0FEYjtBQUFBLFlBRUksU0FBUyxLQUFLLElBQUwsQ0FBVSxVQUFVLFdBQVYsSUFBeUIsQ0FBQyxVQUFVLE1BQTlDLENBRmI7O0FBSUEsWUFBSSxVQUFVLE1BQWQsRUFBc0I7QUFDbEIsaUJBQUssUUFBTCxDQUNJLENBQUMsTUFBRCxJQUFXLENBRGYsRUFDa0I7QUFDZCxhQUFDLE1BQUQsSUFBVyxDQUZmO0FBSUg7QUFDSjs7QUF0QjJELENBQXRDLENBQTFCOztBQTJCQSxPQUFPLE9BQVAsR0FBaUIsbUJBQWpCOzs7QUNsQ0E7QUFDQTs7QUFFQSxJQUFNLFVBQVUsUUFBUSxXQUFSLENBQWhCOztBQUVBLElBQUksVUFBSixFQUNJLGNBREosRUFFSSxlQUZKOztBQUlBOzs7O0FBSUEsSUFBTSxpQkFBaUIsUUFBUSxNQUFSLENBQWUsZ0JBQWYsRUFBaUM7QUFDcEQsaUJBQWEsS0FEdUM7O0FBR3BEOzs7O0FBSUEsaUNBQTZCLHVDQUFXO0FBQ3BDLHFCQUFhLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUFiOztBQUVBLG1CQUFXLEtBQVgsQ0FBaUIsT0FBakIsR0FBMkIsTUFBM0I7O0FBRUEsaUJBQVMsSUFBVCxDQUFjLFdBQWQsQ0FBMEIsVUFBMUI7O0FBRUEsZUFBTyxVQUFQO0FBQ0gsS0FmbUQ7O0FBaUJwRCxxQkFBaUIseUJBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDbkMsWUFBSSxlQUFlLEtBQW5CO0FBQ0EsWUFBSSxpQ0FBaUMsS0FBSyxxQkFBTCxDQUEyQixJQUEzQixFQUFpQyxLQUFqQyxDQUFyQztBQUNBLFlBQUksK0JBQStCLEtBQUssb0JBQUwsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBaEMsQ0FBbkM7O0FBRUEsWUFBSSw4QkFBSixFQUFvQztBQUNoQyxnQkFBSSxDQUFDLEtBQUssV0FBVixFQUF1QjtBQUNuQixvQkFBSSxnQkFBZ0IsTUFBTSxNQUFOLENBQWEsQ0FBYixHQUNkLE1BQU0sVUFBTixDQUFpQixlQURILEdBRWQsS0FBSyxNQUFMLENBQVksSUFBWixDQUFpQixJQUZILEdBR2QsQ0FITjtBQUlBLG9CQUFJLGNBQWMsTUFBTSxNQUFOLENBQWEsQ0FBYixHQUFpQixNQUFNLE1BQU4sQ0FBYSxNQUE5QixHQUF1QyxLQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWlCLEdBQTFFO0FBQ0EscUJBQUssbUJBQUwsQ0FBeUIsSUFBekIsRUFDSSxhQURKLEVBRUksV0FGSixFQUdJLE1BQU0sTUFBTixDQUFhLFVBQWIsQ0FBd0IsV0FINUIsRUFJSSxRQUpKO0FBS0g7QUFDSixTQWJELE1BYU8sSUFBSSw0QkFBSixFQUFrQztBQUNyQyxnQkFBSSxDQUFDLEtBQUssV0FBVixFQUF1QjtBQUNuQixvQkFBSSxpQkFBZ0IsTUFBTSxNQUFOLENBQWEsQ0FBYixHQUNkLE1BQU0sTUFBTixDQUFhLEtBQWIsR0FBcUIsQ0FEUCxHQUNXLE1BQU0sVUFBTixDQUFpQix5QkFBakIsR0FBNkMsQ0FEeEQsR0FFZCxLQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWlCLElBRnZCO0FBR0Esb0JBQUksZUFBYyxNQUFNLE1BQU4sQ0FBYSxDQUFiLEdBQWlCLE1BQU0sTUFBTixDQUFhLE1BQWIsR0FBc0IsQ0FBdkMsR0FBMkMsS0FBSyxNQUFMLENBQVksSUFBWixDQUFpQixHQUE5RTtBQUNBLHFCQUFLLG1CQUFMLENBQXlCLElBQXpCLEVBQ0ksY0FESixFQUVJLFlBRkosRUFHSSxLQUFLLHNCQUFMLEVBSEosRUFJSSxPQUpKO0FBS0g7QUFDSixTQVpNLE1BWUE7QUFDSCxnQkFBSSxLQUFLLFdBQVQsRUFBc0I7QUFDbEIscUJBQUssa0JBQUwsQ0FBd0IsSUFBeEI7QUFDSDtBQUNKOztBQUVELFlBQUksWUFBSixFQUFrQjtBQUNkLGlCQUFLLE9BQUw7QUFDSDs7QUFFRCxZQUFJLEtBQUssSUFBVCxFQUFlO0FBQ1gsaUJBQUssSUFBTCxDQUFVLGVBQVYsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBaEM7QUFDSDtBQUNKLEtBNURtRDs7QUE4RHBEOzs7Ozs7OztBQVFBLHFCQUFpQix5QkFBUyxJQUFULEVBQWUsS0FBZixFQUFzQjtBQUNuQyxhQUFLLGtCQUFMLENBQXdCLElBQXhCOztBQUVBLFlBQUksS0FBSyxJQUFULEVBQWU7QUFDWCxpQkFBSyxJQUFMLENBQVUsZUFBVixDQUEwQixJQUExQixFQUFnQyxLQUFoQztBQUNIO0FBQ0osS0E1RW1EOztBQThFcEQsMkJBQXVCLCtCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ3pDLFlBQUksaUJBQWlCLE1BQU0sTUFBTixDQUFhLFFBQWxDO0FBQ0EsWUFBSSxjQUFjLE1BQU0sVUFBTixDQUFpQixTQUFqQixJQUE4QixNQUFNLGFBQU4sQ0FBb0IsU0FBcEU7O0FBRUEsWUFBSSxDQUFDLGNBQUQsSUFBbUIsQ0FBQyxXQUF4QixFQUFxQztBQUNqQyxtQkFBTyxLQUFQO0FBQ0g7O0FBRUQsWUFBSSxtQkFBbUIsTUFBTSxVQUFOLENBQWlCLGVBQXhDO0FBQ0EsWUFBSSxvQkFBb0IsbUJBQW1CLEVBQW5CLEdBQXdCLE1BQU0sVUFBTixDQUFpQiwyQkFBakU7O0FBRUEsWUFBSSxrQkFBa0IsQ0FBdEI7QUFDQSxZQUFJLHFCQUFxQixNQUFNLE1BQU4sQ0FBYSxNQUFiLEdBQXNCLENBQS9DOztBQUVBLGVBQU8sTUFBTSxVQUFOLENBQWlCLENBQWpCLElBQXNCLGlCQUF0QixJQUNBLE1BQU0sVUFBTixDQUFpQixDQUFqQixJQUFzQixnQkFEdEIsSUFFQSxNQUFNLFVBQU4sQ0FBaUIsQ0FBakIsSUFBc0Isa0JBRnRCLElBR0EsTUFBTSxVQUFOLENBQWlCLENBQWpCLElBQXNCLGVBSDdCO0FBSUgsS0FoR21EOztBQWtHcEQsMEJBQXNCLDhCQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ3hDLFlBQUksSUFBSSxNQUFNLFFBQU4sQ0FBZSxDQUF2QjtBQUNBLFlBQUksSUFBSSxNQUFNLFFBQU4sQ0FBZSxDQUF2Qjs7QUFFQSxZQUFJLDZCQUE2QixNQUFNLEtBQUssUUFBTCxDQUFjLGNBQXBCLElBQzFCLE1BQU0sQ0FEb0IsSUFFMUIsTUFBTSxXQUZvQixJQUcxQixLQUFLLFFBQUwsQ0FBYyxVQUhyQjs7QUFLQSxZQUFJLENBQUMsMEJBQUwsRUFBaUM7QUFDN0IsbUJBQU8sS0FBUDtBQUNIOztBQUVELFlBQUksNkJBQTZCLE1BQU0sTUFBTixDQUFhLE1BQWIsR0FBc0IsQ0FBdEIsR0FBMEIsTUFBTSxVQUFOLENBQWlCLDBCQUFqQixHQUE4QyxDQUF6RztBQUNBLFlBQUksMkJBQTJCLDZCQUE2QixNQUFNLFVBQU4sQ0FBaUIsMEJBQTdFO0FBQ0EsWUFBSSw2QkFBNkIsTUFBTSxNQUFOLENBQWEsS0FBYixHQUFxQixDQUFyQixHQUF5QixNQUFNLFVBQU4sQ0FBaUIseUJBQWpCLEdBQTZDLENBQXZHO0FBQ0EsWUFBSSwyQkFBMkIsNkJBQTZCLE1BQU0sVUFBTixDQUFpQix5QkFBN0U7O0FBRUEsZUFBTyxNQUFNLFVBQU4sQ0FBaUIsQ0FBakIsSUFBc0Isd0JBQXRCLElBQ0EsTUFBTSxVQUFOLENBQWlCLENBQWpCLElBQXNCLDBCQUR0QixJQUVBLE1BQU0sVUFBTixDQUFpQixDQUFqQixJQUFzQix3QkFGdEIsSUFHQSxNQUFNLFVBQU4sQ0FBaUIsQ0FBakIsSUFBc0IsMEJBSDdCO0FBSUgsS0F4SG1EOztBQTBIcEQ7Ozs7Ozs7OztBQVNBLHlCQUFxQiw2QkFBUyxJQUFULEVBQWUsQ0FBZixFQUFrQixDQUFsQixFQUFxQixJQUFyQixFQUEyQixTQUEzQixFQUFzQztBQUN2RCxhQUFLLGtCQUFMLENBQXdCLElBQXhCOztBQUVBLFlBQUksQ0FBQyxVQUFMLEVBQWlCO0FBQ2IsaUJBQUssMkJBQUw7QUFDSDs7QUFFRDs7QUFFQSxnQkFBUSxTQUFSO0FBQ0ksaUJBQUssUUFBTDtBQUNJLDJCQUFXLFlBQVgsQ0FBd0IsT0FBeEIsRUFBaUMsS0FBSyxVQUFMLENBQWdCLHlCQUFqRDtBQUNBO0FBQ0osaUJBQUssT0FBTDtBQUNJLDJCQUFXLFlBQVgsQ0FBd0IsT0FBeEIsRUFBaUMsS0FBSyxVQUFMLENBQWdCLHdCQUFqRDtBQUNBO0FBTlI7O0FBU0EsWUFBSSxrQkFBa0IsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQXRCO0FBQ0Esd0JBQWdCLFlBQWhCLENBQTZCLE9BQTdCLEVBQXNDLEtBQUssVUFBTCxDQUFnQix3QkFBdEQ7QUFDQSxtQkFBVyxXQUFYLENBQXVCLGVBQXZCOztBQUVBLFlBQUksa0JBQWtCLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUF0QjtBQUNBLHdCQUFnQixZQUFoQixDQUE2QixPQUE3QixFQUFzQyxLQUFLLFVBQUwsQ0FBZ0Isd0JBQXREO0FBQ0Esd0JBQWdCLFNBQWhCLEdBQTRCLElBQTVCO0FBQ0EsbUJBQVcsV0FBWCxDQUF1QixlQUF2Qjs7QUFFQSxhQUFLLGtCQUFMLENBQXdCLElBQXhCOztBQUVBLFlBQUksY0FBSjtBQUFBLFlBQVcsYUFBWDtBQUNBLFlBQUksZUFBZSxXQUFXLFdBQTlCO0FBQUEsWUFDSSxnQkFBZ0IsV0FBVyxZQUQvQjs7QUFHQSxnQkFBUSxTQUFSO0FBQ0ksaUJBQUssUUFBTDtBQUNJLHdCQUFRLElBQUksZUFBZSxDQUEzQjtBQUNBLHVCQUFPLENBQVA7QUFDQTtBQUNKLGlCQUFLLE9BQUw7QUFDSSx3QkFBUSxDQUFSO0FBQ0EsdUJBQU8sSUFBSSxnQkFBZ0IsQ0FBM0I7QUFDQTtBQVJSOztBQVdBLGFBQUssa0JBQUwsQ0FBd0IsS0FBeEIsRUFBK0IsSUFBL0I7QUFDSCxLQWhMbUQ7O0FBa0xwRDs7Ozs7QUFLQSx3QkFBb0IsNEJBQVMsSUFBVCxFQUFlO0FBQy9CLFlBQUksS0FBSyxHQUFULENBRCtCLENBQ2hCO0FBQ2YsbUJBQVcsS0FBWCxDQUFpQixPQUFqQixHQUEyQixFQUEzQjtBQUNBLG1CQUFXLEtBQVgsQ0FBaUIsT0FBakIsR0FBMkIsT0FBM0I7QUFDQSxhQUFLLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxhQUFLLGNBQUw7QUFDQSx5QkFBaUIsWUFBWSxZQUFNO0FBQy9CLGdCQUFJLE1BQU0sS0FBSyxVQUFMLENBQWdCLHFCQUExQixFQUFnRDtBQUM1Qyw4QkFBYyxjQUFkO0FBQ0g7QUFDRCxnQkFBSSxDQUFDLFVBQUwsRUFBaUI7QUFDYjtBQUNIO0FBQ0QsdUJBQVcsS0FBWCxDQUFpQixPQUFqQixHQUEyQixFQUEzQjtBQUNBLHVCQUFXLEtBQVgsQ0FBaUIsTUFBakIsR0FBMEIsbUJBQW1CLEtBQUssR0FBeEIsR0FBOEIsR0FBeEQ7QUFDQSxrQkFBTSxLQUFLLEdBQVg7QUFDSCxTQVZnQixFQVVkLENBVmMsQ0FBakI7QUFXSCxLQXhNbUQ7O0FBME1wRDs7Ozs7OztBQU9BLHdCQUFvQiw0QkFBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQy9CLG1CQUFXLEtBQVgsQ0FBaUIsR0FBakIsR0FBdUIsSUFBSSxJQUEzQjtBQUNBLG1CQUFXLEtBQVgsQ0FBaUIsSUFBakIsR0FBd0IsSUFBSSxJQUE1QjtBQUNILEtBcE5tRDs7QUFzTnBEOzs7OztBQUtBLHdCQUFvQiw0QkFBUyxJQUFULEVBQWU7QUFDL0IsYUFBSyxXQUFMLEdBQW1CLEtBQW5COztBQUVBLFlBQUksQ0FBQyxVQUFMLEVBQWlCO0FBQ2I7QUFDSDs7QUFFRCxZQUFJLEtBQUssS0FBSyxVQUFMLENBQWdCLHFCQUF6QixDQVArQixDQU9rQjtBQUNqRCxhQUFLLGNBQUw7QUFDQSwwQkFBa0IsWUFBWSxZQUFNO0FBQ2hDLGdCQUFJLE1BQU0sR0FBVixFQUFjO0FBQ1YsOEJBQWMsZUFBZDs7QUFFQSxvQkFBSSxDQUFDLFVBQUwsRUFBaUI7QUFDYjtBQUNIO0FBQ0QsMkJBQVcsS0FBWCxDQUFpQixPQUFqQixHQUEyQixNQUEzQjs7QUFFQSwyQkFBVyxTQUFYLEdBQXVCLEVBQXZCO0FBQ0EsMkJBQVcsTUFBWDtBQUNBLDZCQUFhLElBQWI7QUFDSDs7QUFFRCxnQkFBSSxDQUFDLFVBQUwsRUFBaUI7QUFDYjtBQUNIOztBQUVELHVCQUFXLEtBQVgsQ0FBaUIsT0FBakIsR0FBMkIsRUFBM0I7QUFDQSx1QkFBVyxLQUFYLENBQWlCLE1BQWpCLEdBQTBCLG1CQUFtQixLQUFLLEdBQXhCLEdBQThCLEdBQXhEO0FBQ0Esa0JBQU0sS0FBSyxHQUFYO0FBQ0gsU0FyQmlCLEVBcUJmLENBckJlLENBQWxCO0FBc0JILEtBMVBtRDs7QUE0UHBELG9CQUFnQiwwQkFBVztBQUN2QixZQUFLLGVBQUwsRUFBc0I7QUFDbEIsMEJBQWMsZUFBZDtBQUNIO0FBQ0QsWUFBSyxjQUFMLEVBQXFCO0FBQ2pCLDBCQUFjLGNBQWQ7QUFDSDtBQUNKO0FBblFtRCxDQUFqQyxDQUF2Qjs7QUFzUUEsT0FBTyxPQUFQLEdBQWlCLGNBQWpCOzs7QUNuUkE7O0FBRUEsSUFBSSxXQUFXLFFBQVEsaUJBQVIsQ0FBZjs7QUFHQTs7Ozs7QUFLQSxJQUFJLFdBQVcsU0FBUyxNQUFULENBQWdCLFVBQWhCLEVBQTRCOztBQUV2QyxlQUFXLFFBQVEsV0FBUixDQUY0QixFQUVOOztBQUVqQyxnQkFBWSxzQkFBVztBQUNuQjtBQUNBLGFBQUssR0FBTCxDQUFTLFNBQVMsU0FBbEI7QUFDQSxhQUFLLEdBQUwsQ0FBUyxTQUFTLFdBQWxCO0FBQ0EsYUFBSyxHQUFMLENBQVMsU0FBUyxhQUFsQjtBQUNBLGFBQUssR0FBTCxDQUFTLFNBQVMsWUFBbEI7QUFDQSxhQUFLLEdBQUwsQ0FBUyxTQUFTLGNBQWxCO0FBQ0EsYUFBSyxHQUFMLENBQVMsU0FBUyxlQUFsQjtBQUNBLGFBQUssR0FBTCxDQUFTLFNBQVMsYUFBbEI7QUFDQSxhQUFLLEdBQUwsQ0FBUyxTQUFTLE9BQWxCO0FBQ0EsYUFBSyxHQUFMLENBQVMsU0FBUyxTQUFsQjtBQUNBLGFBQUssR0FBTCxDQUFTLFNBQVMsT0FBbEI7QUFDQTtBQUNBLGFBQUssR0FBTCxDQUFTLFNBQVMsWUFBbEI7QUFDQSxhQUFLLEdBQUwsQ0FBUyxTQUFTLG1CQUFsQjtBQUNBLGFBQUssR0FBTCxDQUFTLFNBQVMsV0FBbEI7QUFDQSxhQUFLLEdBQUwsQ0FBUyxTQUFTLGNBQWxCO0FBQ0EsYUFBSyxHQUFMLENBQVMsU0FBUyxXQUFsQjtBQUNBLGFBQUssR0FBTCxDQUFTLFNBQVMsV0FBbEI7QUFDQSxhQUFLLEdBQUwsQ0FBUyxTQUFTLGNBQWxCO0FBQ0g7O0FBeEJzQyxDQUE1QixDQUFmOztBQTZCQTtBQUNBOztBQUVBLFNBQVMsU0FBVCxHQUFxQixRQUFRLFdBQVIsQ0FBckIsQyxDQUEyQztBQUMzQyxTQUFTLFNBQVQsR0FBcUIsUUFBUSxhQUFSLENBQXJCO0FBQ0EsU0FBUyxXQUFULEdBQXVCLFFBQVEsZUFBUixDQUF2QjtBQUNBLFNBQVMsYUFBVCxHQUF5QixRQUFRLGlCQUFSLENBQXpCO0FBQ0EsU0FBUyxZQUFULEdBQXdCLFFBQVEsZ0JBQVIsQ0FBeEI7QUFDQSxTQUFTLGNBQVQsR0FBMEIsUUFBUSxrQkFBUixDQUExQjtBQUNBLFNBQVMsZUFBVCxHQUEyQixRQUFRLG1CQUFSLENBQTNCO0FBQ0EsU0FBUyxhQUFULEdBQXlCLFFBQVEsaUJBQVIsQ0FBekI7QUFDQSxTQUFTLE9BQVQsR0FBbUIsUUFBUSxXQUFSLENBQW5CO0FBQ0EsU0FBUyxTQUFULEdBQXFCLFFBQVEsYUFBUixDQUFyQjtBQUNBLFNBQVMsT0FBVCxHQUFtQixRQUFRLFdBQVIsQ0FBbkI7QUFDQTtBQUNBLFNBQVMsWUFBVCxHQUF3QixRQUFRLGdCQUFSLENBQXhCO0FBQ0EsU0FBUyxtQkFBVCxHQUErQixRQUFRLHVCQUFSLENBQS9CO0FBQ0EsU0FBUyxXQUFULEdBQXVCLFFBQVEsZUFBUixDQUF2QjtBQUNBLFNBQVMsY0FBVCxHQUEwQixRQUFRLGtCQUFSLENBQTFCO0FBQ0EsU0FBUyxXQUFULEdBQXVCLFFBQVEsZUFBUixDQUF2QjtBQUNBLFNBQVMsV0FBVCxHQUF1QixRQUFRLGVBQVIsQ0FBdkI7QUFDQSxTQUFTLGNBQVQsR0FBMEIsUUFBUSxrQkFBUixDQUExQjs7QUFFQSxPQUFPLE9BQVAsR0FBaUIsSUFBSSxRQUFKLEVBQWpCOzs7QUM5REE7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FBUUE7O0FBQ0EsSUFBSSxNQUFNLE9BQU8sR0FBUCxHQUFhLE9BQU8sR0FBUCxJQUFjLEVBQXJDOztBQUVBO0FBQ0EsSUFBSSxZQUFZLElBQUksU0FBSixHQUFnQixRQUFRLGNBQVIsQ0FBaEM7O0FBRUE7QUFDQSxVQUFVLE9BQVYsR0FBb0IsUUFBUSxpQkFBUixDQUFwQjs7QUFFQTtBQUNBLFVBQVUsR0FBVixHQUFnQixFQUFoQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTyxnQkFBUCxDQUF3QixVQUFVLE9BQWxDLEVBQTJDO0FBQ3ZDLHFCQUFpQixFQUFFLE9BQU8sUUFBUSxpQkFBUixDQUFULEVBRHNCLEVBQ2lCO0FBQ3hELHNCQUFrQixFQUFFLE9BQU8sUUFBUSxrQkFBUixDQUFULEVBRnFCLEVBRW1CO0FBQzFELGlCQUFhLEVBQUUsT0FBTyxRQUFRLFdBQVIsQ0FBVCxFQUgwQjtBQUl2Qyx3QkFBb0IsRUFBRSxPQUFPLFFBQVEsa0JBQVIsQ0FBVCxFQUptQjtBQUt2QyxlQUFXLEVBQUUsT0FBTyxRQUFRLFdBQVIsQ0FBVCxFQUw0QjtBQU12QyxpQkFBYSxFQUFFLE9BQU8sUUFBUSxhQUFSLENBQVQsRUFOMEI7QUFPdkMsNEJBQXdCLEVBQUUsT0FBTyxRQUFRLHNCQUFSLENBQVQ7QUFQZSxDQUEzQzs7QUFVQTtBQUNBLE9BQU8sZ0JBQVAsQ0FBd0IsVUFBVSxHQUFsQyxFQUF1QztBQUNuQyxTQUFLLEVBQUUsT0FBTyxRQUFRLFNBQVIsQ0FBVCxFQUQ4QjtBQUVuQyxlQUFXLEVBQUUsT0FBTyxRQUFRLGNBQVIsQ0FBVCxFQUZ3QjtBQUduQyxnQkFBWSxFQUFFLE9BQU8sUUFBUSxlQUFSLENBQVQsRUFIdUI7QUFJbkMsY0FBVSxFQUFFLE9BQU8sUUFBUSxhQUFSLENBQVQsRUFKeUI7QUFLbkMsVUFBTSxFQUFFLE9BQU8sUUFBUSxTQUFSLENBQVQsRUFMNkI7QUFNbkMsY0FBVSxFQUFFLE9BQU8sUUFBUSxhQUFSLENBQVQ7QUFOeUIsQ0FBdkM7O0FBU0E7QUFDQSxPQUFPLGdCQUFQLENBQXdCLFNBQXhCLEVBQW1DO0FBQy9CLFNBQUssRUFBRSxLQUFLLFdBQVcsSUFBWCxDQUFnQixJQUFoQixFQUFzQixLQUF0QixDQUFQLEVBRDBCO0FBRS9CLGVBQVcsRUFBRSxLQUFLLFdBQVcsSUFBWCxDQUFnQixJQUFoQixFQUFzQixXQUF0QixDQUFQLEVBRm9CO0FBRy9CLGdCQUFZLEVBQUUsS0FBSyxXQUFXLElBQVgsQ0FBZ0IsSUFBaEIsRUFBc0IsWUFBdEIsQ0FBUCxFQUhtQjtBQUkvQixjQUFVLEVBQUUsS0FBSyxXQUFXLElBQVgsQ0FBZ0IsSUFBaEIsRUFBc0IsVUFBdEIsQ0FBUCxFQUpxQjtBQUsvQixpQkFBYSxFQUFFLEtBQUssV0FBVyxJQUFYLENBQWdCLElBQWhCLEVBQXNCLGFBQXRCLEVBQXFDLFNBQXJDLENBQVA7QUFMa0IsQ0FBbkM7O0FBUUEsU0FBUyxVQUFULENBQW9CLEdBQXBCLEVBQXlCLFFBQXpCLEVBQW1DO0FBQy9CLGVBQVcsWUFBWSxLQUF2Qjs7QUFFQSxRQUFJLGFBQUosRUFBbUIsT0FBbkI7O0FBRUEsWUFBUSxRQUFSO0FBQ0ksYUFBSyxLQUFMO0FBQ0ksNEJBQWdCLFFBQVEsR0FBeEI7QUFDQSxzQkFBVSxrQkFBa0IsR0FBbEIsR0FBd0IseUJBQXhCLEdBQ04sY0FETSxHQUNXLEdBRFgsR0FDaUIsMkRBRGpCLEdBRU4sd0JBRk0sR0FFcUIsYUFGckIsR0FFcUMsMERBRnJDLEdBR04sb0ZBSEo7QUFJQTs7QUFFSixhQUFLLFNBQUw7QUFDSSw0QkFBZ0IsR0FBaEI7QUFDQSxzQkFBVSxrQkFBa0IsR0FBbEIsR0FBd0Isd0JBQXhCLEdBQ04sY0FETSxHQUNXLEdBRFgsR0FDaUIsaURBRGpCLEdBRU4sd0JBRk0sR0FFcUIsYUFGckIsR0FFcUMsK0NBRnJDLEdBR04sa0ZBSEo7QUFYUjs7QUFpQkEsUUFBSSxDQUFDLFdBQVcsTUFBWCxDQUFrQixHQUFsQixDQUFMLEVBQTZCO0FBQ3pCLGdCQUFRLElBQVIsQ0FBYSxPQUFiO0FBQ0EsbUJBQVcsTUFBWCxDQUFrQixHQUFsQixJQUF5QixJQUF6QjtBQUNIOztBQUVELFdBQU8sVUFBVSxPQUFWLENBQWtCLGFBQWxCLENBQVA7QUFDSDs7QUFFRCxXQUFXLE1BQVgsR0FBb0IsRUFBcEI7O0FBRUEsT0FBTyxPQUFQLEdBQWlCLFNBQWpCOzs7QUN6RkE7O0FBRUEsSUFBSSxjQUFjLE9BQWxCO0FBQ0EsSUFBSSxZQUFZLFFBQVEsY0FBUixDQUFoQjs7QUFFQSxJQUFJLG9CQUFvQixJQUFJLE1BQUosQ0FBVyxNQUFNLFdBQU4sR0FBb0IsdUJBQS9CLENBQXhCO0FBQUEsSUFDSSx5QkFBeUIsSUFBSSxNQUFKLENBQVcsTUFBTSxXQUFOLEdBQW9CLHFEQUEvQixDQUQ3Qjs7QUFHQSxTQUFTLFlBQVQsQ0FBc0IsSUFBdEIsRUFBNEI7QUFBRTtBQUMxQixRQUFJLE1BQUosRUFBWSxNQUFaOztBQUVBLFlBQVEsSUFBUjtBQUNJLGFBQUssV0FBTDtBQUNJLHFCQUFTLFNBQVQ7QUFDQTtBQUNKLGFBQUssY0FBYyxTQUFuQjtBQUNJLHFCQUFTLFFBQVEsY0FBUixDQUFUO0FBQ0E7QUFDSjtBQUNJLGdCQUFLLFNBQVMsS0FBSyxLQUFMLENBQVcsaUJBQVgsQ0FBZCxFQUE4QztBQUMxQyx5QkFBUyxVQUFVLEdBQVYsQ0FBYyxPQUFPLENBQVAsQ0FBZCxDQUFUO0FBQ0gsYUFGRCxNQUVPLElBQUssU0FBUyxLQUFLLEtBQUwsQ0FBVyxzQkFBWCxDQUFkLEVBQW1EO0FBQ3RELHlCQUFTLFVBQVUsR0FBVixDQUFjLE9BQU8sQ0FBUCxDQUFkLENBQVQ7QUFDQSxvQkFBSSxPQUFPLENBQVAsQ0FBSixFQUFlO0FBQ1gsNkJBQVMsT0FBTyxPQUFPLENBQVAsQ0FBUCxDQUFUO0FBQ0g7QUFDSixhQUxNLE1BS0E7QUFDSCx5QkFBUyxVQUFVLE9BQVYsQ0FBa0IsSUFBbEIsQ0FBVDtBQUNIO0FBakJUOztBQW9CQSxRQUFJLENBQUMsTUFBTCxFQUFhO0FBQ1QsWUFBSSxNQUFNLG9CQUFxQixJQUEvQjtBQUFBLFlBQ0ksUUFBUSxLQUFLLEtBQUwsQ0FBVywyQkFBWCxDQURaOztBQUdBLFlBQUksS0FBSixFQUFXO0FBQ1AsbUJBQU8sOEJBQThCLE1BQU0sQ0FBTixDQUE5QixHQUF5QyxJQUFoRDtBQUNIOztBQUVELGNBQU0sR0FBTjtBQUNIOztBQUVELFdBQU8sTUFBUDtBQUNIOztBQUVELE9BQU8sT0FBUCxHQUFpQixZQUFqQjs7O0FDN0NBOztBQUVBOztBQUVBLElBQUksT0FBTyxPQUFPLFdBQWQsS0FBOEIsVUFBbEMsRUFBOEM7QUFDMUMsV0FBTyxXQUFQLEdBQXFCLFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QjtBQUN6QyxpQkFBUyxVQUFVLEVBQUUsU0FBUyxLQUFYLEVBQWtCLFlBQVksS0FBOUIsRUFBcUMsUUFBUSxTQUE3QyxFQUFuQjtBQUNBLFlBQUksTUFBTSxTQUFTLFdBQVQsQ0FBcUIsYUFBckIsQ0FBVjtBQUNBLFlBQUksZUFBSixDQUFvQixLQUFwQixFQUEyQixPQUFPLE9BQWxDLEVBQTJDLE9BQU8sVUFBbEQsRUFBOEQsT0FBTyxNQUFyRTtBQUNBLGVBQU8sR0FBUDtBQUNILEtBTEQ7O0FBT0EsV0FBTyxXQUFQLENBQW1CLFNBQW5CLEdBQStCLE9BQU8sS0FBUCxDQUFhLFNBQTVDO0FBQ0g7O0FBRUQsSUFBSSxjQUFjLFFBQVEsYUFBUixDQUFsQjs7QUFFQSxJQUFJLDBCQUEwQixHQUE5QjtBQUFBLElBQ0ksYUFBYSxFQURqQjtBQUFBLElBRUksYUFBYSxFQUZqQjtBQUFBLElBR0ksWUFISjtBQUFBLElBSUksY0FKSjtBQUFBLElBS0ksVUFBVSxhQUxkOztBQU9BLFNBQVMsTUFBVCxDQUFnQixHQUFoQixFQUFxQixTQUFyQixFQUFnQztBQUM1QixRQUFJLE9BQU8sSUFBWDs7QUFFQTtBQUNBLFNBQUssR0FBTCxHQUFXLEdBQVg7QUFDQSxTQUFLLFNBQUwsR0FBaUIsU0FBakI7O0FBRUEsU0FBSyxXQUFMLEdBQW1CLEtBQUssR0FBTCxFQUFuQjs7QUFFQTtBQUNBLFNBQUssT0FBTCxHQUFlLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUFmO0FBQ0EsU0FBSyxPQUFMLENBQWEsU0FBYixHQUF5QixNQUF6QjtBQUNBLFNBQUssR0FBTCxDQUFTLFdBQVQsQ0FBcUIsS0FBSyxPQUExQjs7QUFFQTtBQUNBLFNBQUssRUFBTCxHQUFVLGlCQUFpQixLQUFLLE1BQUwsR0FBYyxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBL0IsQ0FBVjtBQUNBLFNBQUssRUFBTCxHQUFVLGlCQUFpQixLQUFLLE1BQUwsR0FBYyxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBL0IsQ0FBVjs7QUFFQSxTQUFLLEdBQUwsQ0FBUyxXQUFULENBQXFCLEtBQUssTUFBMUI7O0FBRUEsU0FBSyxNQUFMLENBQVksS0FBWixDQUFrQixPQUFsQixHQUE0QixNQUE1QjtBQUNBLFNBQUssTUFBTCxDQUFZLEtBQVosQ0FBa0IsVUFBbEIsR0FBK0IsS0FBSyxTQUFMLENBQWUsVUFBZixDQUEwQixxQkFBekQ7O0FBRUEsU0FBSyxhQUFMLEdBQXFCLElBQUksWUFBWSxLQUFoQixDQUFzQixDQUFDLENBQXZCLEVBQTBCLENBQUMsQ0FBM0IsQ0FBckI7QUFDQSxTQUFLLFNBQUwsR0FBaUIsSUFBSSxZQUFZLEtBQWhCLENBQXNCLENBQUMsQ0FBdkIsRUFBMEIsQ0FBQyxDQUEzQixDQUFqQjtBQUNBO0FBQ0EsU0FBSyxNQUFMLEdBQWMsSUFBSSxZQUFZLFNBQWhCLENBQTBCLENBQTFCLEVBQTZCLENBQTdCLEVBQWdDLENBQWhDLEVBQW1DLENBQW5DLENBQWQ7QUFDQSxTQUFLLFFBQUwsR0FBZ0IsS0FBaEI7O0FBRUEsU0FBSyxNQUFMLENBQVksV0FBWixHQUEwQixZQUFXO0FBQ2pDLGFBQUssUUFBTCxHQUFnQixJQUFoQjtBQUNILEtBRkQ7QUFHQSxTQUFLLGdCQUFMLENBQXNCLE9BQXRCLEVBQStCLFVBQVMsQ0FBVCxFQUFZO0FBQ3ZDLGFBQUssY0FBTCxDQUFvQixDQUFwQjtBQUNILEtBRkQ7QUFHQSxTQUFLLGdCQUFMLENBQXNCLE1BQXRCLEVBQThCLFVBQVMsQ0FBVCxFQUFZO0FBQ3RDLGFBQUssWUFBTCxDQUFrQixDQUFsQjtBQUNILEtBRkQ7QUFHQSxTQUFLLGdCQUFMLENBQXNCLFdBQXRCLEVBQW1DLFVBQVMsQ0FBVCxFQUFZO0FBQzNDLGFBQUssWUFBTCxDQUFrQixDQUFsQjtBQUNILEtBRkQ7QUFHQSxTQUFLLGdCQUFMLENBQXNCLFVBQXRCLEVBQWtDLFVBQVMsQ0FBVCxFQUFZO0FBQzFDLGFBQUssUUFBTCxHQUFnQixLQUFoQjtBQUNBLGFBQUssV0FBTCxDQUFpQixDQUFqQjtBQUNILEtBSEQ7QUFJQSxTQUFLLGdCQUFMLENBQXNCLE9BQXRCLEVBQStCLFVBQVMsQ0FBVCxFQUFZO0FBQ3ZDLGFBQUssUUFBTCxDQUFjLENBQWQ7QUFDSCxLQUZEO0FBR0EsU0FBSyxnQkFBTCxDQUFzQixVQUF0QixFQUFrQyxVQUFTLENBQVQsRUFBWTtBQUMxQyxhQUFLLFdBQUwsQ0FBaUIsQ0FBakI7QUFDSCxLQUZEO0FBR0EsU0FBSyxnQkFBTCxDQUFzQixhQUF0QixFQUFxQyxVQUFTLENBQVQsRUFBWTtBQUM3QyxhQUFLLGNBQUwsQ0FBb0IsQ0FBcEI7QUFDQSxVQUFFLGNBQUY7QUFDQSxlQUFPLEtBQVA7QUFDSCxLQUpEOztBQU1BLFNBQUssTUFBTCxDQUFZLFlBQVosQ0FBeUIsVUFBekIsRUFBcUMsQ0FBckM7O0FBRUEsU0FBSyxNQUFMOztBQUVBLFNBQUssS0FBTDtBQUNBO0FBQ0E7QUFDSDs7QUFFRCxPQUFPLFNBQVAsR0FBbUI7QUFDZixpQkFBYSxPQUFPLFNBQVAsQ0FBaUIsV0FEZjtBQUVmLFNBQUssSUFGVTtBQUdmLGVBQVcsSUFISTtBQUlmLFlBQVEsSUFKTztBQUtmLGFBQVMsSUFMTTtBQU1mLFlBQVEsSUFOTztBQU9mLFNBQUssSUFQVTtBQVFmLG1CQUFlLElBUkE7QUFTZixlQUFXLElBVEk7QUFVZixZQUFRLElBVk87QUFXZixZQUFRLElBWE87QUFZZixXQUFPLEtBWlE7QUFhZixVQUFNLElBYlM7QUFjZixlQUFXLEtBZEk7QUFlZixjQUFVLEtBZks7QUFnQmYsb0JBQWdCLENBaEJEO0FBaUJmLGVBQVcsSUFqQkk7QUFrQmYsd0JBQW9CLENBbEJMO0FBbUJmLGlCQUFhLEVBbkJFO0FBb0JmLGNBQVUsS0FwQks7QUFxQmYsaUJBQWEsQ0FyQkU7QUFzQmYscUJBQWlCLENBdEJGO0FBdUJmLHVCQUFtQixDQXZCSjtBQXdCZixnQkFBWSxDQXhCRztBQXlCZix3QkFBb0IsQ0F6Qkw7QUEwQmYsZUFBVyxFQTFCSTs7QUE0QmYsc0JBQWtCLDBCQUFTLElBQVQsRUFBZSxRQUFmLEVBQXlCO0FBQ3ZDLGFBQUssTUFBTCxDQUFZLGdCQUFaLENBQTZCLElBQTdCLEVBQW1DLFFBQW5DO0FBQ0gsS0E5QmM7O0FBZ0NmLGtDQUE4QixzQ0FBUyxRQUFULEVBQW1CO0FBQUE7O0FBQzdDLFlBQUksUUFBSixFQUFjO0FBQ1YsaUJBQUssNEJBQUwsQ0FBa0MsS0FBbEM7QUFDSDs7QUFFRCxZQUFNLFlBQVk7QUFDZCx1QkFBVyxzQkFBSztBQUNaLG9CQUFJLE1BQUssUUFBTCxJQUFpQixNQUFLLFVBQUwsRUFBckIsRUFBd0M7QUFDcEMsMEJBQUssWUFBTCxDQUFrQixDQUFsQjtBQUNIO0FBQ0osYUFMYTtBQU1kLHFCQUFTLG9CQUFLO0FBQ1Ysc0JBQUssVUFBTCxDQUFnQixDQUFoQjtBQUNILGFBUmE7QUFTZCxtQkFBTyxrQkFBSztBQUNSLHNCQUFLLGFBQUwsQ0FBbUIsQ0FBbkI7QUFDSCxhQVhhO0FBWWQscUJBQVMsb0JBQUs7QUFDVixzQkFBSyxVQUFMLENBQWdCLENBQWhCO0FBQ0gsYUFkYTtBQWVkLG1CQUFPLGtCQUFLO0FBQ1Isc0JBQUssUUFBTCxDQUFjLENBQWQ7QUFDSCxhQWpCYTtBQWtCZCx1QkFBVyxzQkFBSztBQUNaLG9CQUFJLE1BQUssTUFBVCxFQUFpQjtBQUNiLHdCQUFNLGFBQWEsTUFBSyxNQUFMLENBQVkscUJBQVosRUFBbkI7O0FBRUEsd0JBQUksV0FBVyxDQUFYLEtBQWlCLFdBQVcsQ0FBNUIsSUFBaUMsV0FBVyxLQUFYLEtBQXFCLFdBQVcsTUFBakUsSUFDQSxFQUFFLE1BQU0sT0FBTixHQUFnQixXQUFXLENBQTNCLElBQ0MsTUFBTSxPQUFOLEdBQWdCLFdBQVcsQ0FENUIsSUFFQyxNQUFNLE9BQU4sR0FBaUIsV0FBVyxDQUFYLEdBQWUsV0FBVyxLQUY1QyxJQUdDLE1BQU0sT0FBTixHQUFpQixXQUFXLENBQVgsR0FBZSxXQUFXLE1BSDlDLENBREosRUFJNEQ7QUFDeEQsOEJBQUssbUJBQUwsQ0FBeUIsQ0FBekI7QUFDSDtBQUNKO0FBQ0o7QUE5QmEsU0FBbEI7O0FBaUNBLGVBQU8sSUFBUCxDQUFZLFNBQVosRUFBdUIsT0FBdkIsQ0FBK0IscUJBQWE7QUFDeEMsZ0JBQUksQ0FBQyxNQUFLLFNBQUwsQ0FBZSxTQUFmLENBQUwsRUFBZ0M7QUFDNUIsc0JBQUssU0FBTCxDQUFlLFNBQWYsSUFBNEIsVUFBVSxTQUFWLENBQTVCO0FBQ0g7QUFDRCxzQkFBWSxXQUFXLEtBQVgsR0FBbUIsUUFBL0IscUJBQXdELFNBQXhELEVBQW1FLE1BQUssU0FBTCxDQUFlLFNBQWYsQ0FBbkU7QUFDQSxnQkFBSSxDQUFDLFFBQUwsRUFBZTtBQUNYLHVCQUFPLE1BQUssU0FBTCxDQUFlLFNBQWYsQ0FBUDtBQUNIO0FBQ0osU0FSRDtBQVNILEtBL0VjOztBQWlGZix5QkFBcUIsNkJBQVMsSUFBVCxFQUFlLFFBQWYsRUFBeUI7QUFDMUMsYUFBSyxNQUFMLENBQVksbUJBQVosQ0FBZ0MsSUFBaEMsRUFBc0MsUUFBdEM7QUFDSCxLQW5GYzs7QUFxRmYsbUJBQWUsYUFyRkE7QUFzRmYsc0JBQWtCLGdCQXRGSDs7QUF3RmYsb0JBQWdCLGNBeEZEO0FBeUZmLHVCQUFtQixpQkF6Rko7O0FBMkZmLGNBQVUsb0JBQVc7QUFDakIsYUFBSyxZQUFMO0FBQ0EsYUFBSyxZQUFMO0FBQ0gsS0E5RmM7O0FBZ0dmLG1CQUFjLHlCQUFXO0FBQ3JCLGVBQU8sS0FBSyxVQUFaO0FBQ0gsS0FsR2M7O0FBcUdmLGVBQVcsbUJBQVMsR0FBVCxFQUFjO0FBQ3JCLFlBQUksc0JBQXNCLEtBQUssU0FBTCxDQUFlLFVBQWYsQ0FBMEIsdUJBQXBEO0FBQUEsWUFDSSxNQUFNLEtBQUssU0FBTCxDQUFlLFVBQWYsQ0FBMEIsbUJBRHBDO0FBRUEsWUFBSSxRQUFRLENBQVosRUFBZTtBQUNYO0FBQ0g7QUFDRCxZQUFJLFdBQVcsT0FBTyxHQUF0Qjs7QUFFQSxZQUFJLFVBQVUsTUFBTSxLQUFLLGVBQXpCO0FBQ0EsWUFBSSxVQUFVLFFBQVYsS0FBdUIsdUJBQXVCLEtBQUssS0FBbkQsQ0FBSixFQUErRDtBQUMzRCxpQkFBSyxRQUFMO0FBQ0EsaUJBQUssZUFBTCxHQUF1QixHQUF2QjtBQUNBO0FBQ0EsZ0JBQUksbUJBQUosRUFBeUI7QUFDckIscUJBQUssaUJBQUw7QUFDQSxvQkFBSSxNQUFNLEtBQUssa0JBQVgsSUFBaUMsSUFBckMsRUFBMkM7QUFDdkMseUJBQUssVUFBTCxHQUFtQixLQUFLLGlCQUFMLEdBQXlCLElBQTFCLElBQW1DLE1BQU0sS0FBSyxrQkFBOUMsQ0FBbEI7QUFDQSx5QkFBSyxpQkFBTCxHQUF5QixDQUF6QjtBQUNBLHlCQUFLLGtCQUFMLEdBQTBCLEdBQTFCO0FBQ0g7QUFDSjtBQUNKO0FBQ0osS0EzSGM7O0FBNkhmLG1CQUFlLHlCQUFXO0FBQ3RCLFlBQUksT0FBTyxJQUFYO0FBQ0EsYUFBSyxLQUFMLEdBQWEsSUFBYjtBQUNBLGFBQUssV0FBTCxHQUFtQixVQUFTLEdBQVQsRUFBYztBQUM3QixpQkFBSyxTQUFMLENBQWUsR0FBZjtBQUNILFNBRkQ7QUFHQSxtQkFBVyxJQUFYLENBQWdCLElBQWhCO0FBQ0gsS0FwSWM7O0FBc0lmLGtCQUFjLHdCQUFXO0FBQ3JCLG1CQUFXLE1BQVgsQ0FBa0IsV0FBVyxPQUFYLENBQW1CLElBQW5CLENBQWxCLEVBQTRDLENBQTVDO0FBQ0gsS0F4SWM7O0FBMElmLG1CQUFlLHlCQUFXO0FBQ3RCLFlBQUksT0FBTyxJQUFYO0FBQ0EsYUFBSyxXQUFMLEdBQW1CLFlBQVc7QUFDMUIsaUJBQUssU0FBTDtBQUNILFNBRkQ7QUFHQSxtQkFBVyxJQUFYLENBQWdCLElBQWhCO0FBQ0gsS0FoSmM7O0FBa0pmLGtCQUFjLHdCQUFXO0FBQ3JCLG1CQUFXLE1BQVgsQ0FBa0IsV0FBVyxPQUFYLENBQW1CLElBQW5CLENBQWxCLEVBQTRDLENBQTVDO0FBQ0gsS0FwSmM7O0FBc0pmLFdBQU8saUJBQVc7QUFDZCxhQUFLLGFBQUw7QUFDQSxhQUFLLGFBQUw7QUFDQSxhQUFLLDRCQUFMLENBQWtDLElBQWxDO0FBQ0gsS0ExSmM7O0FBNEpmLFVBQU0sZ0JBQVc7QUFDYixhQUFLLFlBQUw7QUFDQSxhQUFLLFlBQUw7QUFDSCxLQS9KYzs7QUFpS2YsOEJBQTBCLG9DQUFXO0FBQ2pDO0FBQ0EsWUFBSSxPQUFPLEtBQUssR0FBTCxDQUFTLHFCQUFULEVBQVg7QUFDQSxZQUFJLE1BQU0sS0FBSyxLQUFMLENBQVcsS0FBSyxHQUFoQixDQUFWO0FBQUEsWUFDSSxPQUFPLEtBQUssS0FBTCxDQUFXLEtBQUssSUFBaEIsQ0FEWDtBQUFBLFlBRUksUUFBUSxLQUFLLElBQUwsQ0FBVSxLQUFLLEtBQWYsQ0FGWjtBQUFBLFlBR0ksU0FBUyxLQUFLLElBQUwsQ0FBVSxLQUFLLE1BQWYsQ0FIYjs7QUFLQSxlQUFPO0FBQ0gsaUJBQUssR0FERjtBQUVILG1CQUFPLE9BQU8sS0FGWDtBQUdILG9CQUFRLE1BQU0sTUFIWDtBQUlILGtCQUFNLElBSkg7QUFLSCxtQkFBTyxLQUxKO0FBTUgsb0JBQVEsTUFOTDtBQU9ILGVBQUcsS0FBSyxDQVBMO0FBUUgsZUFBRyxLQUFLO0FBUkwsU0FBUDtBQVVILEtBbkxjOztBQXFMZixlQUFXLHFCQUFXO0FBQ2xCO0FBQ0EsWUFBSSxVQUFVLEtBQUssd0JBQUwsRUFBZDtBQUNBLFlBQUksUUFBUSxLQUFSLEtBQWtCLEtBQUssSUFBTCxDQUFVLEtBQTVCLElBQXFDLFFBQVEsTUFBUixLQUFtQixLQUFLLElBQUwsQ0FBVSxNQUF0RSxFQUE4RTtBQUMxRSxpQkFBSyxNQUFMO0FBQ0g7QUFDSixLQTNMYzs7QUE2TGYsbUJBQWUseUJBQVc7QUFDdEIsWUFBTSxNQUFNLEtBQUssSUFBTCxHQUFZLEtBQUssd0JBQUwsRUFBeEI7QUFDQSxhQUFLLEtBQUwsR0FBYSxJQUFJLEtBQUosR0FBWSxLQUFLLFNBQUwsQ0FBZSxVQUFmLENBQTBCLGlCQUFuRDtBQUNBLGFBQUssTUFBTCxHQUFjLElBQUksTUFBSixHQUFhLEtBQUssU0FBTCxDQUFlLFVBQWYsQ0FBMEIsa0JBQXJEO0FBQ0EsYUFBSyxNQUFMLEdBQWMsSUFBSSxZQUFZLFNBQWhCLENBQTBCLENBQTFCLEVBQTZCLENBQTdCLEVBQWdDLEtBQUssS0FBckMsRUFBNEMsS0FBSyxNQUFqRCxDQUFkO0FBQ0EsYUFBSyxTQUFMLENBQWUsU0FBZixDQUF5QixLQUFLLE1BQTlCO0FBQ0EsYUFBSyxTQUFMLENBQWUsVUFBZixHQUE0QixLQUFLLE1BQUwsQ0FBWSxNQUF4QztBQUNILEtBcE1jOztBQXNNZixZQUFRLGdCQUFTLGdCQUFULEVBQTJCO0FBQy9CLDJCQUFtQixPQUFPLGdCQUFQLEtBQTRCLFdBQTVCLEdBQTBDLGdCQUExQyxHQUE2RCxJQUFoRjtBQUNBLFlBQUksTUFBTSxLQUFLLElBQUwsR0FBWSxLQUFLLHdCQUFMLEVBQXRCOztBQUVBLGFBQUssS0FBTCxHQUFhLElBQUksS0FBSixHQUFZLEtBQUssU0FBTCxDQUFlLFVBQWYsQ0FBMEIsaUJBQW5EO0FBQ0EsYUFBSyxNQUFMLEdBQWMsSUFBSSxNQUFKLEdBQWEsS0FBSyxTQUFMLENBQWUsVUFBZixDQUEwQixrQkFBckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBSSxRQUFRLENBQVo7QUFDQSxZQUFJLFVBQVUsT0FBTyxnQkFBUCxJQUEyQixLQUFLLFNBQUwsQ0FBZSxVQUFmLENBQTBCLFFBQW5FO0FBQ0EsWUFBSSxPQUFKLEVBQWE7QUFDVCxnQkFBSSxtQkFBbUIsT0FBTyxnQkFBUCxJQUEyQixDQUFsRDtBQUNBLGdCQUFJLG9CQUFvQixLQUFLLEVBQUwsQ0FBUSw0QkFBUixJQUNwQixLQUFLLEVBQUwsQ0FBUSx5QkFEWSxJQUVwQixLQUFLLEVBQUwsQ0FBUSx3QkFGWSxJQUdwQixLQUFLLEVBQUwsQ0FBUSx1QkFIWSxJQUlwQixLQUFLLEVBQUwsQ0FBUSxzQkFKWSxJQUljLENBSnRDOztBQU1BLG9CQUFRLG1CQUFtQixpQkFBM0I7QUFDQTtBQUNIOztBQUVELGFBQUssTUFBTCxDQUFZLEtBQVosR0FBb0IsS0FBSyxNQUFMLENBQVksS0FBWixHQUFvQixLQUFLLEtBQUwsR0FBYSxLQUFyRDtBQUNBLGFBQUssTUFBTCxDQUFZLE1BQVosR0FBcUIsS0FBSyxNQUFMLENBQVksTUFBWixHQUFxQixLQUFLLE1BQUwsR0FBYyxLQUF4RDs7QUFFQTtBQUNBLGFBQUssTUFBTCxDQUFZLEtBQVosQ0FBa0IsS0FBbEIsR0FBMEIsS0FBSyxNQUFMLENBQVksS0FBWixDQUFrQixLQUFsQixHQUEwQixLQUFLLEtBQUwsR0FBYSxDQUFiLEdBQWlCLElBQXJFO0FBQ0EsYUFBSyxNQUFMLENBQVksS0FBWixDQUFrQixNQUFsQixHQUEyQixLQUFLLE1BQUwsQ0FBWSxLQUFaLENBQWtCLE1BQWxCLEdBQTJCLEtBQUssTUFBTCxHQUFjLENBQWQsR0FBa0IsSUFBeEU7O0FBRUEsYUFBSyxFQUFMLENBQVEsS0FBUixDQUFjLEtBQWQsRUFBcUIsS0FBckI7QUFDQSxZQUFJLFdBQVcsQ0FBQyxLQUFLLFNBQUwsQ0FBZSxVQUFmLENBQTBCLFVBQTFDLEVBQXNEO0FBQ2xELGlCQUFLLEVBQUwsQ0FBUSxLQUFSLENBQWMsS0FBZCxFQUFxQixLQUFyQjtBQUNIOztBQUVELGFBQUssTUFBTCxHQUFjLElBQUksWUFBWSxTQUFoQixDQUEwQixDQUExQixFQUE2QixDQUE3QixFQUFnQyxLQUFLLEtBQXJDLEVBQTRDLEtBQUssTUFBakQsQ0FBZDtBQUNBLGFBQUssU0FBTCxDQUFlLFNBQWYsQ0FBeUIsS0FBSyxNQUE5QjtBQUNBLFlBQUksZ0JBQUosRUFBc0I7QUFDbEIsaUJBQUssa0JBQUw7QUFDSDs7QUFFRCxhQUFLLFFBQUw7QUFDSCxLQWpQYzs7QUFtUGYsd0JBQW9CLDhCQUFXO0FBQzNCLGFBQUssZ0JBQUwsQ0FBc0IsU0FBdEIsRUFBaUMsb0JBQWpDLEVBQXVEO0FBQ25ELG1CQUFPLEtBQUssS0FEdUM7QUFFbkQsb0JBQVEsS0FBSztBQUZzQyxTQUF2RDtBQUlILEtBeFBjOztBQTBQZixlQUFXLHFCQUFXO0FBQ2xCLGVBQU8sS0FBSyxNQUFaO0FBQ0gsS0E1UGM7O0FBOFBmLGNBQVUsb0JBQVc7QUFDakIsWUFBSSxhQUFhLEtBQUssU0FBTCxDQUFlLFVBQWYsQ0FBMEIsVUFBM0M7QUFBQSxZQUNJLEtBQUssYUFBYSxLQUFLLEVBQWxCLEdBQXVCLEtBQUssRUFEckM7O0FBR0EsWUFBSTtBQUNBLGVBQUcsS0FBSCxDQUFTLElBQVQ7QUFDQSxpQkFBSyxTQUFMLENBQWUsS0FBZixDQUFxQixFQUFyQjtBQUNBLGlCQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0gsU0FKRCxDQUlFLE9BQU8sQ0FBUCxFQUFVO0FBQ1Isb0JBQVEsS0FBUixDQUFjLENBQWQ7QUFDSCxTQU5ELFNBTVU7QUFDTixlQUFHLEtBQUgsQ0FBUyxPQUFUO0FBQ0g7O0FBRUQsWUFBSSxVQUFKLEVBQWdCO0FBQ1osaUJBQUssV0FBTDtBQUNIO0FBQ0osS0EvUWM7O0FBaVJmLGlCQUFhLHVCQUFXO0FBQ3BCLFlBQUksS0FBSyxNQUFMLENBQVksS0FBWixHQUFvQixDQUFwQixJQUF5QixLQUFLLE1BQUwsQ0FBWSxNQUFaLEdBQXFCLENBQWxELEVBQXFEO0FBQ2pELGlCQUFLLEVBQUwsQ0FBUSxTQUFSLENBQWtCLEtBQUssTUFBdkIsRUFBK0IsQ0FBL0IsRUFBa0MsQ0FBbEM7QUFDSDtBQUNKLEtBclJjOztBQXVSZixjQUFVLGtCQUFTLGNBQVQsRUFBeUIsSUFBekIsRUFBK0IsTUFBL0IsRUFBdUM7QUFDN0MsWUFBSSxRQUFRO0FBQ1Isb0JBQVEsVUFBVTtBQURWLFNBQVo7QUFHQSxZQUFJLGNBQUosRUFBb0I7QUFDaEIsa0JBQU0sTUFBTixDQUFhLGNBQWIsR0FBOEIsY0FBOUI7QUFDSDtBQUNELGVBQU8sSUFBSSxXQUFKLENBQWdCLElBQWhCLEVBQXNCLEtBQXRCLENBQVA7QUFDSCxLQS9SYzs7QUFpU2Ysc0JBQWtCLDBCQUFTLGNBQVQsRUFBeUIsSUFBekIsRUFBK0IsTUFBL0IsRUFBdUM7QUFDckQsZUFBTyxLQUFLLE1BQUwsQ0FBWSxhQUFaLENBQTBCLEtBQUssUUFBTCxDQUFjLGNBQWQsRUFBOEIsSUFBOUIsRUFBb0MsTUFBcEMsQ0FBMUIsQ0FBUDtBQUNILEtBblNjOztBQXFTZiwrQkFBMkIsbUNBQVMsS0FBVCxFQUFnQixJQUFoQixFQUFzQixNQUF0QixFQUE4QjtBQUNyRCxpQkFBUyxVQUFVLEVBQW5CO0FBQ0EsZUFBTyxLQUFQLEdBQWUsS0FBSyxhQUFwQjtBQUNBLGVBQU8sSUFBUCxHQUFjLEtBQUssV0FBbkI7QUFDQSxlQUFPLEtBQUssZ0JBQUwsQ0FBc0IsS0FBdEIsRUFBNkIsSUFBN0IsRUFBbUMsTUFBbkMsQ0FBUDtBQUNILEtBMVNjOztBQTRTZixrQkFBYyxzQkFBUyxDQUFULEVBQVk7QUFDdEIsWUFBSSxDQUFDLEtBQUssVUFBTCxFQUFELElBQXNCLEtBQUssU0FBL0IsRUFBMEM7QUFDdEMsaUJBQUssVUFBTDtBQUNBLGlCQUFLLHlCQUFMLENBQStCLENBQS9CLEVBQWtDLHNCQUFsQyxFQUEwRDtBQUN0RCw4QkFBYyxLQUFLLFlBQUwsQ0FBa0IsQ0FBbEIsQ0FEd0M7QUFFdEQsMkJBQVcsS0FBSztBQUZzQyxhQUExRDtBQUlBLGlCQUFLLFNBQUwsR0FBaUIsSUFBSSxZQUFZLEtBQWhCLENBQXNCLEtBQUssYUFBTCxDQUFtQixDQUF6QyxFQUE0QyxLQUFLLGFBQUwsQ0FBbUIsQ0FBL0QsQ0FBakI7QUFDSDtBQUNELGFBQUssYUFBTCxHQUFxQixLQUFLLFFBQUwsQ0FBYyxDQUFkLENBQXJCO0FBQ0E7QUFDQSxZQUFJLEtBQUssVUFBTCxFQUFKLEVBQXVCO0FBQ25CLGlCQUFLLHlCQUFMLENBQStCLENBQS9CLEVBQWtDLGlCQUFsQyxFQUFxRDtBQUNqRCwyQkFBVyxLQUFLLFNBRGlDO0FBRWpELDhCQUFjLEtBQUssWUFBTCxDQUFrQixDQUFsQjtBQUZtQyxhQUFyRDtBQUlIO0FBQ0QsWUFBSSxLQUFLLE1BQUwsQ0FBWSxRQUFaLENBQXFCLEtBQUssYUFBMUIsQ0FBSixFQUE4QztBQUMxQyxpQkFBSyx5QkFBTCxDQUErQixDQUEvQixFQUFrQyxzQkFBbEM7QUFDSDtBQUNKLEtBaFVjOztBQWtVZixrQkFBYyxzQkFBUyxDQUFULEVBQVk7QUFDdEIsYUFBSyxhQUFMLEdBQXFCLEtBQUssaUJBQUwsR0FBeUIsS0FBSyxRQUFMLENBQWMsQ0FBZCxDQUE5QztBQUNBLGFBQUssU0FBTCxHQUFpQixJQUFqQjs7QUFFQSxhQUFLLHlCQUFMLENBQStCLENBQS9CLEVBQWtDLHNCQUFsQyxFQUEwRDtBQUN0RCwwQkFBYyxLQUFLLFlBQUwsQ0FBa0IsQ0FBbEI7QUFEd0MsU0FBMUQ7QUFHQSxhQUFLLFNBQUw7O0FBRUE7QUFDSCxLQTVVYzs7QUE4VWYseUJBQXFCLDZCQUFTLENBQVQsRUFBWTtBQUM3QixhQUFLLHlCQUFMLENBQStCLENBQS9CLEVBQWtDLDhCQUFsQyxFQUFrRTtBQUM5RCwwQkFBYyxLQUFLLFlBQUwsQ0FBa0IsQ0FBbEI7QUFEZ0QsU0FBbEU7QUFHSCxLQWxWYzs7QUFvVmYsZ0JBQVksb0JBQVMsQ0FBVCxFQUFZO0FBQ3BCLFlBQUksQ0FBQyxLQUFLLFNBQVYsRUFBcUI7QUFDakI7QUFDQTtBQUNIO0FBQ0QsWUFBSSxLQUFLLFVBQUwsRUFBSixFQUF1QjtBQUNuQixpQkFBSyx5QkFBTCxDQUErQixDQUEvQixFQUFrQyxvQkFBbEMsRUFBd0Q7QUFDcEQsMkJBQVcsS0FBSyxTQURvQztBQUVwRCw4QkFBYyxLQUFLLFlBQUwsQ0FBa0IsQ0FBbEI7QUFGc0MsYUFBeEQ7QUFJQSxpQkFBSyxhQUFMO0FBQ0EsaUJBQUssV0FBTCxHQUFtQixLQUFLLEdBQUwsRUFBbkI7QUFDSDtBQUNELGFBQUssU0FBTCxHQUFpQixLQUFqQjtBQUNBLGFBQUsseUJBQUwsQ0FBK0IsQ0FBL0IsRUFBa0Msb0JBQWxDLEVBQXdEO0FBQ3BELHVCQUFXLEtBQUssU0FEb0M7QUFFcEQsMEJBQWMsS0FBSyxZQUFMLENBQWtCLENBQWxCO0FBRnNDLFNBQXhEO0FBSUE7QUFDSCxLQXZXYzs7QUF5V2YsaUJBQWEscUJBQVMsQ0FBVCxFQUFZO0FBQ3JCLFlBQUksQ0FBQyxLQUFLLFNBQVYsRUFBcUI7QUFDakIsaUJBQUssYUFBTCxHQUFxQixJQUFJLFlBQVksS0FBaEIsQ0FBc0IsQ0FBQyxDQUF2QixFQUEwQixDQUFDLENBQTNCLENBQXJCO0FBQ0g7QUFDRCxhQUFLLE9BQUw7QUFDQSxhQUFLLHlCQUFMLENBQStCLENBQS9CLEVBQWtDLHFCQUFsQyxFQUF5RDtBQUNyRCx1QkFBVyxLQUFLO0FBRHFDLFNBQXpEO0FBR0gsS0FqWGM7O0FBbVhmLG1CQUFlLHVCQUFTLENBQVQsRUFBWTtBQUN2QixZQUFJLEtBQUssVUFBTCxNQUFxQixDQUFDLEtBQUssUUFBTCxFQUExQixFQUEyQztBQUN2QztBQUNIO0FBQ0QsVUFBRSxjQUFGO0FBQ0EsYUFBSyx5QkFBTCxDQUErQixDQUEvQixFQUFrQyx1QkFBbEMsRUFBMkQ7QUFDdkQsMEJBQWMsS0FBSyxZQUFMLENBQWtCLENBQWxCO0FBRHlDLFNBQTNEO0FBR0gsS0EzWGM7O0FBNlhmLGNBQVUsa0JBQVMsQ0FBVCxFQUFZO0FBQ2xCLGFBQUssYUFBTCxHQUFxQixLQUFLLFFBQUwsQ0FBYyxDQUFkLENBQXJCO0FBQ0EsYUFBSyx5QkFBTCxDQUErQixDQUEvQixFQUFrQyxrQkFBbEMsRUFBc0Q7QUFDbEQsMEJBQWMsS0FBSyxZQUFMLENBQWtCLENBQWxCO0FBRG9DLFNBQXREO0FBR0gsS0FsWWM7O0FBb1lmLGlCQUFhLHFCQUFTLENBQVQsRUFBWTtBQUNyQixhQUFLLGFBQUwsR0FBcUIsS0FBSyxRQUFMLENBQWMsQ0FBZCxDQUFyQjtBQUNBLGFBQUsseUJBQUwsQ0FBK0IsQ0FBL0IsRUFBa0MscUJBQWxDLEVBQXlEO0FBQ3JELDBCQUFjLEtBQUssWUFBTCxDQUFrQixDQUFsQjtBQUR1QyxTQUF6RDtBQUdILEtBelljOztBQTJZZixnQkFBWSxzQkFBVztBQUNuQixlQUFPLE9BQVA7QUFDSCxLQTdZYzs7QUErWWYsZ0JBQVksb0JBQVMsQ0FBVCxFQUFZO0FBQ3BCLFlBQUksTUFBTSxFQUFFLE9BQUYsSUFBYSxFQUFFLE1BQUYsQ0FBUyxHQUFoQztBQUFBLFlBQ0ksUUFBUSxFQUFFLFFBQUYsSUFBYyxFQUFFLE1BQUYsQ0FBUyxLQURuQztBQUVBLGVBQU8sUUFBUSxHQUFSLEVBQWEsUUFBUSxDQUFSLEdBQVksQ0FBekIsQ0FBUDtBQUNILEtBblpjOztBQXFaZixnQkFBWSxvQkFBUyxDQUFULEVBQVk7QUFDcEIsWUFBSSxDQUFDLEtBQUssUUFBTCxFQUFMLEVBQXNCO0FBQ2xCO0FBQ0g7O0FBRUQ7QUFDQSxZQUFJLEVBQUUsT0FBRixLQUFjLENBQWxCLEVBQXFCO0FBQ2pCLGNBQUUsY0FBRjtBQUNIOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSxZQUFJLFVBQVUsS0FBSyxVQUFMLENBQWdCLENBQWhCLENBQWQ7QUFDQSxZQUFJLEVBQUUsTUFBTixFQUFjO0FBQ1YsZ0JBQUksS0FBSyxTQUFMLEtBQW1CLE9BQXZCLEVBQWdDO0FBQzVCLHFCQUFLLGNBQUw7QUFDSCxhQUZELE1BRU87QUFDSCxxQkFBSyxTQUFMLEdBQWlCLE9BQWpCO0FBQ0EscUJBQUssa0JBQUwsR0FBMEIsS0FBSyxHQUFMLEVBQTFCO0FBQ0g7QUFDSixTQVBELE1BT087QUFDSCxpQkFBSyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsaUJBQUssY0FBTCxHQUFzQixDQUF0QjtBQUNBLGlCQUFLLGtCQUFMLEdBQTBCLENBQTFCO0FBQ0g7QUFDRCxZQUFJLEtBQUssV0FBTCxDQUFpQixPQUFqQixDQUF5QixPQUF6QixNQUFzQyxDQUFDLENBQTNDLEVBQThDO0FBQzFDLGlCQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBc0IsT0FBdEI7QUFDSDs7QUFFRCxhQUFLLGdCQUFMLENBQXNCLENBQXRCLEVBQXlCLG9CQUF6QixFQUErQztBQUMzQyxpQkFBSyxFQUFFLE1BRG9DO0FBRTNDLGtCQUFNLEVBQUUsT0FGbUM7QUFHM0Msa0JBQU0sT0FIcUM7QUFJM0Msa0JBQU0sRUFBRSxRQUptQztBQUszQyxpQkFBSyxFQUFFLE9BTG9DO0FBTTNDLGtCQUFNLEVBQUUsT0FObUM7QUFPM0MseUJBQWEsS0FBSyxjQVB5QjtBQVEzQyw2QkFBaUIsS0FBSyxrQkFScUI7QUFTM0MsbUJBQU8sRUFBRSxRQVRrQztBQVUzQyx3QkFBWSxFQUFFLEdBVjZCO0FBVzNDLHlCQUFhLEtBQUssV0FBTCxDQUFpQixLQUFqQixDQUF1QixDQUF2QixDQVg4QjtBQVkzQyx5QkFBYTtBQVo4QixTQUEvQztBQWNILEtBbGNjOztBQW9jZixjQUFVLGtCQUFTLENBQVQsRUFBWTtBQUNsQixZQUFJLENBQUMsS0FBSyxRQUFMLEVBQUwsRUFBc0I7QUFDbEI7QUFDSDs7QUFFRDtBQUNBLFlBQUksRUFBRSxPQUFGLEtBQWMsQ0FBbEIsRUFBcUI7QUFDakIsY0FBRSxjQUFGO0FBQ0g7O0FBRUQsWUFBSSxVQUFVLEtBQUssVUFBTCxDQUFnQixDQUFoQixDQUFkO0FBQ0EsYUFBSyxXQUFMLENBQWlCLE1BQWpCLENBQXdCLEtBQUssV0FBTCxDQUFpQixPQUFqQixDQUF5QixPQUF6QixDQUF4QixFQUEyRCxDQUEzRDtBQUNBLGFBQUssY0FBTCxHQUFzQixDQUF0QjtBQUNBLGFBQUssU0FBTCxHQUFpQixJQUFqQjtBQUNBLGFBQUssa0JBQUwsR0FBMEIsQ0FBMUI7QUFDQSxhQUFLLGdCQUFMLENBQXNCLENBQXRCLEVBQXlCLGtCQUF6QixFQUE2QztBQUN6QyxpQkFBSyxFQUFFLE1BRGtDO0FBRXpDLGtCQUFNLEVBQUUsT0FGaUM7QUFHekMsa0JBQU0sT0FIbUM7QUFJekMsa0JBQU0sRUFBRSxRQUppQztBQUt6QyxpQkFBSyxFQUFFLE9BTGtDO0FBTXpDLGtCQUFNLEVBQUUsT0FOaUM7QUFPekMsb0JBQVEsRUFBRSxNQVArQjtBQVF6QyxtQkFBTyxFQUFFLFFBUmdDO0FBU3pDLHdCQUFZLEVBQUUsR0FUMkI7QUFVekMseUJBQWEsS0FBSyxXQUFMLENBQWlCLEtBQWpCLENBQXVCLENBQXZCO0FBVjRCLFNBQTdDO0FBWUgsS0EvZGM7O0FBaWVmLHVCQUFtQiw2QkFBVztBQUMxQixhQUFLLFdBQUwsR0FBbUIsRUFBbkI7QUFDSCxLQW5lYzs7QUFxZWYsb0JBQWdCLHdCQUFTLENBQVQsRUFBWTtBQUN4QixhQUFLLGdCQUFMLENBQXNCLENBQXRCLEVBQXlCLHlCQUF6QjtBQUNILEtBdmVjOztBQXllZixrQkFBYyxzQkFBUyxDQUFULEVBQVk7QUFDdEIsYUFBSyxpQkFBTDtBQUNBLGFBQUssZ0JBQUwsQ0FBc0IsQ0FBdEIsRUFBeUIsdUJBQXpCO0FBQ0gsS0E1ZWM7O0FBOGVmLG9CQUFnQix3QkFBUyxDQUFULEVBQVk7QUFDeEIsWUFBSSxFQUFFLE9BQUYsSUFBYSxLQUFLLFdBQUwsQ0FBaUIsT0FBakIsQ0FBeUIsTUFBekIsTUFBcUMsQ0FBQyxDQUF2RCxFQUEwRDtBQUN0RCxpQkFBSyxXQUFMLENBQWlCLElBQWpCLENBQXNCLE1BQXRCO0FBQ0g7O0FBRUQsYUFBSyx5QkFBTCxDQUErQixDQUEvQixFQUFrQyx5QkFBbEMsRUFBNkQ7QUFDekQsMEJBQWMsS0FBSyxZQUFMLENBQWtCLENBQWxCO0FBRDJDLFNBQTdEO0FBR0gsS0F0ZmM7O0FBd2ZmLGFBQVMsbUJBQVc7QUFDaEIsYUFBSyxLQUFMLEdBQWEsSUFBYjtBQUNBLFlBQUksQ0FBQyxZQUFELElBQWlCLEtBQUssU0FBTCxDQUFlLFVBQWYsQ0FBMEIsbUJBQTFCLEtBQWtELENBQXZFLEVBQTBFO0FBQ3RFLGlCQUFLLFFBQUw7QUFDSDtBQUNKLEtBN2ZjOztBQStmZixzQkFBa0IsNEJBQVc7QUFDekIsZUFBTyxLQUFLLGFBQVo7QUFDSCxLQWpnQmM7O0FBbWdCZixlQUFXLHFCQUFXO0FBQ2xCLFlBQUksT0FBTyxLQUFLLE1BQUwsQ0FBWSxxQkFBWixFQUFYO0FBQ0EsWUFBSSxJQUFJLElBQUksWUFBWSxLQUFoQixDQUFzQixLQUFLLElBQTNCLEVBQWlDLEtBQUssR0FBdEMsQ0FBUjtBQUNBLGVBQU8sQ0FBUDtBQUNILEtBdmdCYzs7QUF5Z0JmLGNBQVUsa0JBQVMsQ0FBVCxFQUFZO0FBQ2xCLFlBQUksT0FBTyxLQUFLLE1BQUwsQ0FBWSxxQkFBWixFQUFYO0FBQ0EsWUFBSSxJQUFJLElBQUksWUFBWSxLQUFoQixDQUFzQixFQUFFLE9BQUYsR0FBWSxLQUFLLElBQXZDLEVBQTZDLEVBQUUsT0FBRixHQUFZLEtBQUssR0FBOUQsQ0FBUjtBQUNBLGVBQU8sQ0FBUDtBQUNILEtBN2dCYzs7QUErZ0JmLGNBQVUsb0JBQVc7QUFDakIsZUFBTyxTQUFTLGFBQVQsS0FBMkIsS0FBSyxNQUF2QztBQUNILEtBamhCYzs7QUFtaEJmLGVBQVcscUJBQVc7QUFDbEIsWUFBSSxPQUFPLElBQVg7QUFDQSxZQUFJLENBQUMsS0FBSyxRQUFMLEVBQUwsRUFBc0I7QUFDbEIsdUJBQVcsWUFBVztBQUNsQixxQkFBSyxNQUFMLENBQVksS0FBWjtBQUNILGFBRkQsRUFFRyxFQUZIO0FBR0g7QUFDSixLQTFoQmM7O0FBNGhCZixnQkFBWSxzQkFBVztBQUNuQixhQUFLLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxhQUFLLCtCQUFMO0FBQ0gsS0EvaEJjOztBQWlpQmYsbUJBQWUseUJBQVc7QUFDdEIsYUFBSyxRQUFMLEdBQWdCLEtBQWhCO0FBQ0EsYUFBSyw4QkFBTDtBQUNILEtBcGlCYzs7QUFzaUJmLGdCQUFZLHNCQUFXO0FBQ25CLGVBQU8sS0FBSyxRQUFaO0FBQ0gsS0F4aUJjOztBQTBpQmYscUNBQWlDLDJDQUFXO0FBQ3hDLFlBQUksUUFBUSxTQUFTLElBQVQsQ0FBYyxLQUExQjtBQUNBLGNBQU0sT0FBTixHQUFnQixNQUFNLE9BQU4sR0FBZ0IsMkJBQWhDO0FBQ0gsS0E3aUJjOztBQStpQmYsb0NBQWdDLDBDQUFXO0FBQ3ZDLFlBQUksUUFBUSxTQUFTLElBQVQsQ0FBYyxLQUExQjtBQUNBLGNBQU0sT0FBTixHQUFnQixNQUFNLE9BQU4sQ0FBYyxPQUFkLENBQXNCLDJCQUF0QixFQUFtRCxFQUFuRCxDQUFoQjtBQUNILEtBbGpCYzs7QUFvakJmLGtCQUFjLHNCQUFTLE1BQVQsRUFBaUI7QUFDM0IsYUFBSyxPQUFMLENBQWEsS0FBYixDQUFtQixPQUFuQixHQUE2QixTQUFTLEVBQVQsR0FBYyxNQUEzQztBQUNILEtBdGpCYzs7QUF3akJmLGtCQUFjLHNCQUFTLENBQVQsRUFBWTtBQUN0QixZQUFJLFNBQUo7QUFDQSxZQUFJLEtBQUssT0FBTyxLQUFoQjs7QUFFQSxZQUFJLFdBQVcsQ0FBZixFQUFrQjtBQUFFO0FBQ2hCLHdCQUFZLEVBQUUsS0FBRixLQUFZLENBQXhCO0FBQ0gsU0FGRCxNQUVPLElBQUksWUFBWSxDQUFoQixFQUFtQjtBQUFFO0FBQ3hCLHdCQUFZLEVBQUUsTUFBRixLQUFhLENBQXpCO0FBQ0g7QUFDRCxlQUFPLFNBQVA7QUFDSCxLQWxrQmM7O0FBb2tCZixtQkFBZSx1QkFBUyxDQUFULEVBQVk7QUFDdkIsZUFBTyxLQUFLLE1BQUwsQ0FBWSxhQUFaLENBQTBCLENBQTFCLENBQVA7QUFDSCxLQXRrQmM7O0FBd2tCZixhQUFTLGlCQUFTLE9BQVQsRUFBa0IsS0FBbEIsRUFBeUI7QUFDOUIsWUFBSSxPQUFKLEVBQWE7QUFDVCxnQkFBSSxVQUFVLFNBQWQsRUFBeUI7QUFDckIsb0JBQUksU0FBUyxDQUFDLE1BQU0sT0FBTyxLQUFQLENBQU4sQ0FBZCxFQUFvQztBQUNoQyw2QkFBUyxJQUFUO0FBQ0g7QUFDRCxxQkFBSyxPQUFMLENBQWEsS0FBYixDQUFtQixLQUFuQixHQUEyQixLQUEzQjtBQUNIOztBQUVELGdCQUFJLFFBQVEsT0FBUixDQUFnQixHQUFoQixDQUFKLEVBQTBCO0FBQ3RCLHFCQUFLLE9BQUwsQ0FBYSxTQUFiLEdBQXlCLE9BQXpCO0FBQ0gsYUFGRCxNQUVPO0FBQ0gscUJBQUssT0FBTCxDQUFhLFNBQWIsR0FBeUIsT0FBekI7QUFDSDtBQUNKOztBQUVELGFBQUssT0FBTCxDQUFhLEtBQWIsQ0FBbUIsT0FBbkIsR0FBNkIsVUFBVSxPQUFWLEdBQW9CLE1BQWpEO0FBQ0g7QUF6bEJjLENBQW5COztBQTRsQkEsU0FBUyxpQkFBVCxDQUEyQixHQUEzQixFQUFnQztBQUM1QixRQUFJLFlBQUosRUFBa0I7QUFDZCxtQkFBVyxPQUFYLENBQW1CLFVBQVMsU0FBVCxFQUFvQjtBQUNuQyxnQkFBSTtBQUNBLDBCQUFVLFdBQVYsQ0FBc0IsR0FBdEI7QUFDSCxhQUZELENBRUUsT0FBTyxDQUFQLEVBQVU7QUFDUix3QkFBUSxLQUFSLENBQWMsQ0FBZDtBQUNIOztBQUVELGdCQUFJLFVBQVUsU0FBVixDQUFvQixnQkFBeEIsRUFBMEM7QUFDdEMsMEJBQVUsU0FBVixDQUFvQixnQkFBcEI7QUFDSDtBQUNKLFNBVkQ7QUFXQSx1QkFBZSxzQkFBc0IsaUJBQXRCLENBQWY7QUFDSDtBQUNKO0FBQ0QsU0FBUyxnQkFBVCxHQUE0QjtBQUN4QixtQkFBZSxnQkFBZ0Isc0JBQXNCLGlCQUF0QixDQUEvQjtBQUNIO0FBQ0QsU0FBUyxhQUFULEdBQXlCO0FBQ3JCLFFBQUksWUFBSixFQUFrQjtBQUNkLDZCQUFxQixZQUFyQjtBQUNBLHVCQUFlLFNBQWY7QUFDSDtBQUNKO0FBQ0Q7O0FBRUEsU0FBUyxzQkFBVCxDQUFnQyxHQUFoQyxFQUFxQztBQUNqQyxRQUFJLGNBQUosRUFBb0I7QUFDaEIsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFdBQVcsTUFBL0IsRUFBdUMsR0FBdkMsRUFBNEM7QUFDeEMsZ0JBQUk7QUFDQSwyQkFBVyxDQUFYLEVBQWMsV0FBZCxDQUEwQixHQUExQjtBQUNILGFBRkQsQ0FFRSxPQUFPLENBQVAsRUFBVTtBQUNSLHdCQUFRLEtBQVIsQ0FBYyxDQUFkO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFDRCxTQUFTLGlCQUFULEdBQTZCO0FBQ3pCLHFCQUFpQixrQkFBa0IsWUFBWSxzQkFBWixFQUFvQyx1QkFBcEMsQ0FBbkM7QUFDSDtBQUNELFNBQVMsY0FBVCxHQUEwQjtBQUN0QixRQUFJLGNBQUosRUFBb0I7QUFDaEIsc0JBQWMsY0FBZDtBQUNBLHlCQUFpQixTQUFqQjtBQUNIO0FBQ0o7QUFDRDs7QUFFQSxTQUFTLFdBQVQsR0FBdUI7QUFDbkIsUUFBSSxNQUFNLEVBQVY7O0FBRUEsUUFBSSxRQUFRLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBWjs7QUFFQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksR0FBcEIsRUFBeUIsR0FBekIsRUFBOEI7QUFDMUIsWUFBSSxDQUFKLElBQVMsS0FBVDtBQUNIOztBQUVELFFBQUksRUFBSixJQUFVLENBQUMsS0FBRCxFQUFRLFVBQVIsQ0FBVjtBQUNBLFFBQUksR0FBSixJQUFXLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBWDtBQUNBLFFBQUksRUFBSixJQUFVLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBVjtBQUNBLFFBQUksRUFBSixJQUFVLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBVjtBQUNBLFFBQUksRUFBSixJQUFVLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBVjtBQUNBLFFBQUksRUFBSixJQUFVLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBVjtBQUNBLFFBQUksRUFBSixJQUFVLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBVjtBQUNBLFFBQUksRUFBSixJQUFVLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBVjtBQUNBLFFBQUksRUFBSixJQUFVLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBVjtBQUNBLFFBQUksRUFBSixJQUFVLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBVjtBQUNBLFFBQUksRUFBSixJQUFVLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBVjtBQUNBLFFBQUksRUFBSixJQUFVLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBVjtBQUNBLFFBQUksR0FBSixJQUFXLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBWDtBQUNBLFFBQUksR0FBSixJQUFXLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBWDtBQUNBLFFBQUksQ0FBSixJQUFTLENBQUMsV0FBRCxFQUFjLGdCQUFkLENBQVQ7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLFFBQUQsRUFBVyxhQUFYLENBQVY7QUFDQSxRQUFJLENBQUosSUFBUyxDQUFDLEtBQUQsRUFBUSxVQUFSLENBQVQ7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEdBQUosSUFBVyxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVg7QUFDQSxRQUFJLEdBQUosSUFBVyxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVg7QUFDQSxRQUFJLEdBQUosSUFBVyxDQUFDLElBQUQsRUFBTyxHQUFQLENBQVg7QUFDQSxRQUFJLEdBQUosSUFBVyxDQUFDLFVBQUQsRUFBYSxlQUFiLENBQVg7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEdBQUosSUFBVyxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVg7QUFDQSxRQUFJLEdBQUosSUFBVyxDQUFDLElBQUQsRUFBTyxHQUFQLENBQVg7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLFFBQUQsRUFBVyxhQUFYLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLE9BQUQsRUFBVSxPQUFWLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVY7QUFDQSxRQUFJLEdBQUosSUFBVyxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVg7QUFDQSxRQUFJLEdBQUosSUFBVyxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVg7QUFDQSxRQUFJLEdBQUosSUFBVyxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVg7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLE9BQUQsRUFBVSxPQUFWLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLE1BQUQsRUFBUyxXQUFULENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLEtBQUQsRUFBUSxVQUFSLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLGFBQUQsRUFBZ0Isa0JBQWhCLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLE9BQUQsRUFBVSxZQUFWLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxDQUFDLGNBQUQsRUFBaUIsbUJBQWpCLENBQVY7QUFDQSxRQUFJLEVBQUosSUFBVSxD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QUFTLFNBQVQsRUFBb0I7QUFDNUQsV0FBTyxVQUFVLGdCQUFqQjtBQUNILENBRkQ7O0FBSUEsU0FBUyxXQUFULENBQXFCLFNBQXJCLEVBQWdDO0FBQzVCLFFBQUksQ0FBSjtBQUFBLFFBQU8sSUFBUDtBQUFBLFFBQWEsV0FBYjtBQUFBLFFBQ0ksUUFBUSxVQUFVLFVBRHRCO0FBQUEsUUFFSSxhQUFhLE1BQU0sZUFGdkI7O0FBSUEsWUFBUSxXQUFXLENBQVgsQ0FBUjtBQUNJLGFBQUssT0FBTDtBQUNJLGdCQUFJLENBQUosQ0FESixDQUNXO0FBQ1AsbUJBQU8sVUFBVSxnQkFBakIsQ0FGSixDQUV1QztBQUNuQztBQUNKLGFBQUssS0FBTDtBQUNJLGdCQUFJLENBQUosQ0FESixDQUNXO0FBQ1AsbUJBQU8sS0FBUCxDQUZKLENBRWtCO0FBQ2Q7QUFDSjtBQUNJLGdCQUFJLENBQUosQ0FESixDQUNXO0FBQ1AsbUJBQU8sS0FBSyxJQUFMLENBQVUsVUFBakI7QUFYUjs7QUFjQSxTQUFLLGNBQWMsQ0FBQyxPQUFPLE1BQVAsQ0FBYyxJQUFkLENBQUQsQ0FBbkIsRUFBMEMsSUFBSSxXQUFXLE1BQXpELEVBQWlFLEVBQUUsQ0FBbkUsRUFBc0U7QUFDbEUsb0JBQVksSUFBWixDQUFpQixhQUFhLFdBQVcsQ0FBWCxDQUFiLEVBQTRCLFNBQTVCLENBQWpCO0FBQ0g7O0FBRUQsV0FBTyxPQUFPLE1BQVAsQ0FBYyxLQUFkLENBQW9CLE1BQXBCLEVBQTRCLFdBQTVCLENBQVA7QUFDSDs7QUFFRCxPQUFPLE9BQVAsR0FBaUIsV0FBakIiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfXJldHVybiBlfSkoKSIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5ncmlkID0gW1xuJy5oeXBlcmdyaWQtY29udGFpbmVyIHsnLFxuJ1x0cG9zaXRpb246IHJlbGF0aXZlOycsXG4nXHRoZWlnaHQ6IDUxMHB4OycsXG4nfScsXG4nLmh5cGVyZ3JpZC1jb250YWluZXIgPiBkaXY6Zmlyc3QtY2hpbGQgeycsXG4nXHRwb3NpdGlvbjogYWJzb2x1dGU7JyxcbidcdGxlZnQ6IDA7JyxcbidcdHRvcDogMDsnLFxuJ1x0cmlnaHQ6IDA7JyxcbidcdGJvdHRvbTogMDsnLFxuJ30nLFxuJy5oeXBlcmdyaWQtY29udGFpbmVyID4gZGl2OmZpcnN0LWNoaWxkID4gZGl2LmluZm8geycsXG4nXHRwb3NpdGlvbjogYWJzb2x1dGU7JyxcbidcdGRpc3BsYXk6IG5vbmU7IC8qIGluaXRpYWxseSBoaWRkZW4gKi8nLFxuJ1x0bWFyZ2luLXRvcDogMTUwcHg7IC8qIHRvIHBsYWNlIGJlbG93IGhlYWRlcnMgKi8nLFxuJ1x0Y29sb3I6ICNlZWU7JyxcbidcdHRleHQtc2hhZG93OiAxcHggMXB4ICNjY2M7JyxcbidcdGZvbnQtc2l6ZTogMzZwdDsnLFxuJ1x0Zm9udC13ZWlnaHQ6IGJvbGQ7JyxcbidcdHRleHQtYWxpZ246IGNlbnRlcjsnLFxuJ1x0dG9wOiAwOyByaWdodDogMDsgYm90dG9tOiAwOyBsZWZ0OiAwOycsXG4nfScsXG4nLmh5cGVyZ3JpZC10ZXh0ZmllbGQgeycsXG4nXHRwb3NpdGlvbjogYWJzb2x1dGU7JyxcbidcdGZvbnQtc2l6ZTogMTJweDsnLFxuJ1x0Y29sb3I6IGJsYWNrOycsXG4nXHQvKmJhY2tncm91bmQtY29sb3I6IGl2b3J5OyovJyxcbidcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7JyxcbidcdG1hcmdpbjogMDsnLFxuJ1x0cGFkZGluZy1yaWdodDogNXB4OycsXG4nXHRwYWRkaW5nLWxlZnQ6IDVweDsnLFxuJ1x0cGFkZGluZy1ib3R0b206IDJweDsnLFxuJ1x0Ym9yZGVyOiAxcHggIzUyOTJmNyBzb2xpZDsnLFxuJ1x0Lypib3JkZXI6IDA7ICovJyxcbidcdC8qYm9yZGVyOiAxcHggc29saWQgIzc3NzsqLycsXG4nXHRvdXRsaW5lOiAwOycsXG4nXHQtd2Via2l0LWJveC1zaGFkb3c6IDAgMnB4IDVweCByZ2JhKDAsMCwwLDAuNCk7JyxcbidcdC1tb3otYm94LXNoYWRvdzogMCAycHggNXB4IHJnYmEoMCwwLDAsMC40KTsnLFxuJ1x0Ym94LXNoYWRvdzogMCAycHggNXB4IHJnYmEoMCwwLDAsMC40KTsnLFxuJ30nLFxuJycsXG4nLmZpbi1saW5rLWRldGFpbHMtZGl2ID4gYTpob3ZlciB7JyxcbidcdHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lICFpbXBvcnRhbnQ7Jyxcbid9JyxcbicnLFxuJycsXG4nJ1xuXS5qb2luKCdcXG4nKTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuXHRcImNhbGVuZGFyXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFvQUFBQUtDQVlBQUFDTk1zKzlBQUFBYzBsRVFWUjRuSVhRd1FrQ01SU0U0VTlaTE1DVDlYamFxMkFmTmhmWVU1b1FMTUFPdG9ONDhFV2VpNWlCSVJQZS95WVEzcXJoZjFsRkc3aUtjRWFKeFNmdWtVdk1XZ2RIYXZ0MHVXSHRnMlF3eFhuQW5KWjJ1T0x5Vlp0eWJ6emhnV05tZm9GbDAvWUI4N05ielIxY2pQOXhlUUhTREM2bWNMMXhGUUFBQUFCSlJVNUVya0pnZ2c9PVwiXG5cdH0sXG5cdFwiY2hlY2tlZFwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBMEFBQUFQQ0FZQUFBQS9JMFYzQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFsd1NGbHpBQUFPd2dBQURzSUJGU2hLZ0FBQUFCaDBSVmgwVTI5bWRIZGhjbVVBY0dGcGJuUXVibVYwSURRdU1DNDFaWVV5WlFBQUFZSkpSRUZVT0UrTmtzdExnbEVReGYwZmFoRzBpRnJVeG0yRWxGRFlMb2hDcUNEYUNBa1dQYXhJUmJGRkVKRWFHRUtMRENvTUVUUkZVQU1MeWFJSEJVRzZzU0tJTXRLRnFFaExUODE4WlVnbURoenUzRFBuOXowdVYxUnJtVXdteUdReXFOVnFmRnZWaXdCeHU1UkZQWnVMU3lHTUtoei9xbEVzUlYxOUs4eG02eSt3N2JwQlBGbkFmZXJqajNiZFFYNkRwSGNBVXdhdkFIVU4yUkdJWnhCSlpISDJtQy9UVWV5ZHd3VFp2QmVnTEVOTmd3N3NYNldoMUZzd05tUEVtalBDRHlHUlJ3Q3RXOUUzdE1nZEF0UXc3R1pqWWNOWCtnemEyd0ozWlhzU1pVdVEwdldDT1Y4U0hmSkovdWx1aGJIVWoxdjhQS05Nc3pJb1FOUk1IQ1NoRDZXaDh6eWhyYk9Qd3o4dytTVEtsQ0NKN29STlV6UUg2M2tCczV0aEJnaGVQWHhsajJhVW9TeERQY3VYUE5pTEFjNUVFWjZISWtibVYyRFlpWEJQSHMwbzA3OStLMERUVmovczExbUUwMEEwTCtnNFZjRHAxMHFLWk1Benl0QmhNYVRSYVBtWWc4ODVEbGNTelNpajBlb0VpSW91b1VxbHFxcWFMMnJsRW9rK0FkNHZsZnpQb1ZEc0FBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcImRvd24tcmVjdGFuZ2xlXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFrQUFBQUVDQVlBQUFCY0R4WE9BQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBQWFkRVZZZEZOdlpuUjNZWEpsQUZCaGFXNTBMazVGVkNCMk15NDFMakV4Ui9OQ053QUFBQnBKUkVGVUdGZGpnSUwvZURBS0lLZ0FCZ2dxZ0FFMEJRd01BUFRsRC9GcGkwSmZBQUFBQUVsRlRrU3VRbUNDXCJcblx0fSxcblx0XCJmaWx0ZXItb2ZmXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUE0QUFBQU1DQVlBQUFCU2dJemFBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBQVlkRVZZZEZOdlpuUjNZWEpsQUhCaGFXNTBMbTVsZENBMExqQXVOV1dGTW1VQUFBQ2hTVVJCVkNoVHpaSEJDb1VnRkVUOVRxRWlza2d5V291dFF2UkxSSXIrY1I3WFFBamlKVy8xQmdabU1VZXZYc1k1eHk5T29ERUdNY1lpVXplQjY3cWliVnV3UWpWTkE2MzExVitXQmVNNHZzTERNRUFwZGUvMWZZOXBtdEk0NTNuZUhFS0FsQkpkMXowZlh0YzE2UGJqT0RLMDd6dm1lVVpWVmQ4bm9vYzc1ekpJT1gzR202aTBiVnNHS2Y4eEtJUkl1eUpUTGdKSjNudlF6c2pXMmdlSXNRL3ByOWhNVnJTbmNBQUFBQUJKUlU1RXJrSmdnZz09XCJcblx0fSxcblx0XCJmaWx0ZXItb25cIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTRBQUFBTUNBWUFBQUJTZ0l6YUFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFBWWRFVllkRk52Wm5SM1lYSmxBSEJoYVc1MExtNWxkQ0EwTGpBdU5XV0ZNbVVBQUFDb1NVUkJWQ2hUWTNCcWZQMmZIQXpXbURiajdmOHAyOTRSaFZPQmFzRWEwMmUrL2UvVkJtUVFDVHhhWC85UG52WUdvajV5d3B2L1FkMkVOZnQzdnY0ZjFnZlZCQVArblcvK2gvYStBVHRuMXE3M0tIanl0dmRnZzMwNzBEVEJnSHZMNi84ZzIyZnNRR2lhRG1TSEEyMXhheWJnSXBESGl4YThoV3NzbkE4TkRFSUFwQ2gzTGtJamlEMklOWUpDTDJYNlczQjhnZGhFYVFRQlVPQ0E0Z3lFOCtlOXhhS0pnUUVBLzc0Qk5FM2NFbGtBQUFBQVNVVk9SSzVDWUlJPVwiXG5cdH0sXG5cdFwidW5jaGVja2VkXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUEwQUFBQVBDQVlBQUFBL0kwVjNBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQWx3U0ZsekFBQU93Z0FBRHNJQkZTaEtnQUFBQUJoMFJWaDBVMjltZEhkaGNtVUFjR0ZwYm5RdWJtVjBJRFF1TUM0MVpZVXlaUUFBQVJCSlJFRlVPRSs5a3J0dWcxQVFSUGxkU2lvN0ZRMXRaSW1Pa29LT0JvbUdUMEVVUkM1aW5vNTR5VHc5MFd5d1FoVGtJa1ZXR29GMnp1eGRybEQrdDB6VGhLWnBUMFZteGI4Q1FSQ2c2enIwZmI4cmVyN3Zmd2NQeHhkY3J4K1lwZ256UEdOWmxoOWlieHhIbEdVSnNoTFNkVjBhdDl0TnBnN0RJQnJYNStPa1BNOUJWa0tHWVNCSkV0UjFqYlpyQmRpcWJWdFVWWVUwVFVGV1FxK25FK0k0eHZ2bEltR2FXN0ZIand4WkNWbVdoYmZ6R1ZtV29TZ0tXWFVyOXVpUklTc2h4M0ZrRWxkb211YlhhdXpSSTBOV1FwN255VVIrTkcvcmZyL2pVWHhuang1dm1LeUViTnVXb3g5WHZpZDZaTWhLNkhBNHduVmRoR0dJS0lwMlJZOE1XUW14K0p1b3F2cFVaRmI4TDZVb255WUwzdU90ckZIK0FBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcInVwLWRvd24tc3BpblwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBNEFBQUFQQ0FZQUFBRFVGUDUwQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFsd1NGbHpBQUFPd1FBQURzRUJ1SkZyN1FBQUFCaDBSVmgwVTI5bWRIZGhjbVVBY0dGcGJuUXVibVYwSURRdU1DNDFaWVV5WlFBQUFHSkpSRUZVT0UrbGt3RUtBQ0VJQkgyWmIvUG5Ic29HZWFWSkRVakdPZ1JScEtwa2lJait5NE1NRTNlRFI3a2FLT1ZOc0p5TU5qSUh6R3k5WW5XNko3cUljcnJpUWltZUNxT1JOQUJkMGZwUlRrdDh1VlVqN0VzeEM2dnMvcTNlL1E2aUQyYnduQnlqUFhITkFBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcInVwLWRvd25cIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTRBQUFBUENBWUFBQURVRlA1MEFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBbHdTRmx6QUFBT3dRQUFEc0VCdUpGcjdRQUFBQmgwUlZoMFUyOW1kSGRoY21VQWNHRnBiblF1Ym1WMElEUXVNQzQxWllVeVpRQUFBR0ZKUkVGVU9FK2xra0VLUUNFSVJEMlpKM1BoM2lONFdEOUdmbHBZaGowWVlvd3BHZ0ptYmlrZDNnak1ERm9rd2J1VDFpQWl1ckc1bm9tZ3FvNVFhUG85RVJRUkk2SmY3c2ZHanVkeTJqZTIzK2kwV2wyb1E4NVRPZGxmckpRT2F6RjhicitycVRYUUtuMEFBQUFBU1VWT1JLNUNZSUk9XCJcblx0fSxcbn07XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIGEgcmVnaXN0cnkgb2YgYEhUTUxJbWFnZUljb25gIG9iamVjdHMuXG4gKlxuICogSHlwZXJncmlkIGNvbWVzIHdpdGggYSBmZXcgaW1hZ2VzIChzZWUgYmVsb3cpLlxuICpcbiAqIEFwcGxpY2F0aW9uIGRldmVsb3BlciBpcyBmcmVlIHRvIHJlZ2lzdGVyIGFkZGl0aW9uYWwgaW1hZ2Ugb2JqZWN0cyBoZXJlIChzZWUge0BsaW5rIG1vZHVsZTppbWFnZXMuYWRkfGFkZH0pLlxuICogQG1vZHVsZSBpbWFnZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnb2JqZWN0LWl0ZXJhdG9ycycpO1xuXG52YXIgaW1hZ2VzID0gcmVxdWlyZSgnLi9pbWFnZXMnKTsgLy8gdGhpcyBpcyB0aGUgZmlsZSBnZW5lcmF0ZWQgYnkgZ3VscGZpbGUuanMgKGFuZCBpZ25vcmVkIGJ5IGdpdClcblxuLyoqXG4gKiA8aW1nIHNyYz1cImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9vcGVuZmluL2Zpbi1oeXBlcmdyaWQvbWFzdGVyL2ltYWdlcy9jYWxlbmRhci5wbmdcIj5cbiAqIEBuYW1lIGNhbGVuZGFyXG4gKiBAbWVtYmVyT2YgbW9kdWxlOmltYWdlc1xuICovXG5cbi8qKlxuICogPGltZyBzcmM9XCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vb3BlbmZpbi9maW4taHlwZXJncmlkL21hc3Rlci9pbWFnZXMvY2hlY2tlZC5wbmdcIj5cbiAqIEBuYW1lIGNoZWNrZWRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6aW1hZ2VzXG4gKi9cblxuLyoqXG4gKiA8aW1nIHNyYz1cImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9vcGVuZmluL2Zpbi1oeXBlcmdyaWQvbWFzdGVyL2ltYWdlcy91bmNoZWNrZWQucG5nXCI+XG4gKiBAbmFtZSB1bmNoZWNrZWRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6aW1hZ2VzXG4gKi9cblxuLyoqXG4gKiA8aW1nIHNyYz1cImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9vcGVuZmluL2Zpbi1oeXBlcmdyaWQvbWFzdGVyL2ltYWdlcy9maWx0ZXItb2ZmLnBuZ1wiPlxuICogQG5hbWUgZmlsdGVyLW9mZlxuICogQG1lbWJlck9mIG1vZHVsZTppbWFnZXNcbiAqL1xuXG4vKipcbiAqIDxpbWcgc3JjPVwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL29wZW5maW4vZmluLWh5cGVyZ3JpZC9tYXN0ZXIvaW1hZ2VzL2ZpbHRlci1vbi5wbmdcIj5cbiAqIEBuYW1lIGZpbHRlci1vblxuICogQG1lbWJlck9mIG1vZHVsZTppbWFnZXNcbiAqL1xuXG4vKipcbiAqIDxpbWcgc3JjPVwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL29wZW5maW4vZmluLWh5cGVyZ3JpZC9tYXN0ZXIvaW1hZ2VzL3VwLWRvd24ucG5nXCI+XG4gKiBAbmFtZSB1cC1kb3duXG4gKiBAbWVtYmVyT2YgbW9kdWxlOmltYWdlc1xuICovXG5cbl8oaW1hZ2VzKS5lYWNoKGZ1bmN0aW9uKGltYWdlLCBrZXkpIHtcbiAgICB2YXIgZWxlbWVudCA9IG5ldyBJbWFnZSgpO1xuICAgIGVsZW1lbnQuc3JjID0gJ2RhdGE6JyArIGltYWdlLnR5cGUgKyAnO2Jhc2U2NCwnICsgaW1hZ2UuZGF0YTtcbiAgICBpbWFnZXNba2V5XSA9IGVsZW1lbnQ7XG59KTtcblxuLyoqXG4gKiBTeW5vbnltIG9mIHtAbGluayBtb2R1bGU6aW1hZ2VzLmNoZWNrZWR8Y2hlY2tlZH0gKHVuYWZmZWN0ZWQgaWYgYGNoZWNrZWRgIG92ZXJyaWRkZW4pLlxuICogQG5hbWUgY2hlY2tib3gtb25cbiAqIEBtZW1iZXJPZiBtb2R1bGU6aW1hZ2VzXG4gKi9cbmltYWdlc1snY2hlY2tib3gtb24nXSA9IGltYWdlcy5jaGVja2VkO1xuXG4vKipcbiAqIFN5bm9ueW0gb2Yge0BsaW5rIG1vZHVsZTppbWFnZXMudW5jaGVja2VkfHVuY2hlY2tlZH0gKHVuYWZmZWN0ZWQgaWYgYHVuY2hlY2tlZGAgb3ZlcnJpZGRlbikuXG4gKiBAbmFtZSBjaGVja2JveC1vZmZcbiAqIEBtZW1iZXJPZiBtb2R1bGU6aW1hZ2VzXG4gKi9cbmltYWdlc1snY2hlY2tib3gtb2ZmJ10gPSBpbWFnZXMudW5jaGVja2VkO1xuXG4vKipcbiAqIEBuYW1lIGFkZFxuICogQG1ldGhvZFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBpbWdcbiAqIEBtZW1iZXJPZiBtb2R1bGU6aW1hZ2VzXG4gKi9cbmltYWdlcy5hZGQgPSBmdW5jdGlvbihrZXksIGltZykge1xuICAgIHJldHVybiBpbWFnZXNba2V5XSA9IGltZztcbn07XG5cbi8qKlxuICogQ29udmVuaWVuY2UgZnVuY3Rpb24uXG4gKiBAbmFtZSBjaGVja2JveFxuICogQG1ldGhvZFxuICogQHBhcmFtIHtib29sZWFufSBzdGF0ZVxuICogQHJldHVybnMge0hUTUxJbWFnZUVsZW1lbnR9IHtAbGluayBtb2R1bGU6aW1hZ2VzLmNoZWNrZWR8Y2hlY2tlZH0gd2hlbiBgc3RhdGVgIGlzIHRydXRoeSBvciB7QGxpbmsgbW9kdWxlOmltYWdlcy51bmNoZWNrZWR8dW5jaGVja2VkfSBvdGhlcndpc2UuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOmltYWdlc1xuICovXG5pbWFnZXMuY2hlY2tib3ggPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiBpbWFnZXNbc3RhdGUgPyAnY2hlY2tlZCcgOiAndW5jaGVja2VkJ107XG59O1xuXG4vKipcbiAqIENvbnZlbmllbmNlIGZ1bmN0aW9uLlxuICogQG5hbWUgZmlsdGVyXG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHN0YXRlXG4gKiBAcmV0dXJucyB7SFRNTEltYWdlRWxlbWVudH0ge0BsaW5rIG1vZHVsZTppbWFnZXMuZmlsdGVyLW9mZnxmaWx0ZXItb2ZmfSB3aGVuIGBzdGF0ZWAgaXMgdHJ1dGh5IG9yIHtAbGluayBtb2R1bGU6aW1hZ2VzLmZpbHRlci1vbnxmaWx0ZXItb259IG90aGVyd2lzZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6aW1hZ2VzXG4gKi9cbmltYWdlcy5maWx0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiBpbWFnZXNbc3RhdGUgPyAnZmlsdGVyLW9uJyA6ICdmaWx0ZXItb2ZmJ107XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGltYWdlcztcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKiBAbW9kdWxlIGF1dG9tYXQgKi9cblxudmFyIEVOQ09ERVJTID0gLyVcXHsoXFxkKylcXH0vZzsgLy8gZG91YmxlICQkIHRvIGVuY29kZVxuXG52YXIgUkVQTEFDRVJTID0gL1xcJFxceyguKj8pXFx9L2c7IC8vIHNpbmdsZSAkIHRvIHJlcGxhY2VcblxuXG4vKipcbiAqIEBzdW1tYXJ5IFN0cmluZyBmb3JtYXR0ZXIuXG4gKlxuICogQGRlc2MgU3RyaW5nIHN1YnN0aXR1dGlvbiBpcyBwZXJmb3JtZWQgb24gbnVtYmVyZWQgX3JlcGxhY2VyXyBwYXR0ZXJucyBsaWtlIGAke259YCBvciBfZW5jb2Rlcl8gcGF0dGVybnMgbGlrZSBgJXtufWAgd2hlcmUgbiBpcyB0aGUgemVyby1iYXNlZCBgYXJndW1lbnRzYCBpbmRleC4gU28gYCR7MH1gIHdvdWxkIGJlIHJlcGxhY2VkIHdpdGggdGhlIGZpcnN0IGFyZ3VtZW50IGZvbGxvd2luZyBgdGV4dGAuXG4gKlxuICogRW5jb2RlcnMgYXJlIGp1c3QgbGlrZSByZXBsYWNlcnMgZXhjZXB0IHRoZSBhcmd1bWVudCBpcyBIVE1MLWVuY29kZWQgYmVmb3JlIGJlaW5nIHVzZWQuXG4gKlxuICogVG8gY2hhbmdlIHRoZSBmb3JtYXQgcGF0dGVybnMsIGFzc2lnbiBuZXcgYFJlZ0V4cGAgcGF0dGVybnMgdG8gYGF1dG9tYXQuZW5jb2RlcnNgIGFuZCBgYXV0b21hdC5yZXBsYWNlcnNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufSB0ZW1wbGF0ZSAtIEEgdGVtcGxhdGUgdG8gYmUgZm9ybWF0dGVkIGFzIGRlc2NyaWJlZCBhYm92ZS4gT3ZlcmxvYWRzOlxuICogKiBBIHN0cmluZyBwcmltaXRpdmUgY29udGFpbmluZyB0aGUgdGVtcGxhdGUuXG4gKiAqIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggYHRoaXNgIGFzIHRoZSBjYWxsaW5nIGNvbnRleHQuIFRoZSB0ZW1wbGF0ZSBpcyB0aGUgdmFsdWUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuXG4gKlxuICogQHBhcmFtIHsuLi4qfSBbcmVwbGFjZW1lbnRzXSAtIFJlcGxhY2VtZW50IHZhbHVlcyBmb3IgbnVtYmVyZWQgZm9ybWF0IHBhdHRlcm5zLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB0ZXh0LlxuICpcbiAqIEBtZW1iZXJPZiBtb2R1bGU6YXV0b21hdFxuICovXG5mdW5jdGlvbiBhdXRvbWF0KHRlbXBsYXRlLCByZXBsYWNlbWVudHMvKi4uLiovKSB7XG4gICAgdmFyIGhhc1JlcGxhY2VtZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxO1xuXG4gICAgLy8gaWYgYHRlbXBsYXRlYCBpcyBhIGZ1bmN0aW9uLCBjb252ZXJ0IGl0IHRvIHRleHRcbiAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuY2FsbCh0aGlzKTsgLy8gbm9uLXRlbXBsYXRlIGZ1bmN0aW9uOiBjYWxsIGl0IHdpdGggY29udGV4dCBhbmQgdXNlIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIGlmIChoYXNSZXBsYWNlbWVudHMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZShhdXRvbWF0LnJlcGxhY2Vyc1JlZ2V4LCBmdW5jdGlvbihtYXRjaCwga2V5KSB7XG4gICAgICAgICAgICBrZXkgLT0gLTE7IC8vIGNvbnZlcnQgdG8gbnVtYmVyIGFuZCBpbmNyZW1lbnRcbiAgICAgICAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA+IGtleSA/IGFyZ3Nba2V5XSA6ICcnO1xuICAgICAgICB9KTtcblxuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoYXV0b21hdC5lbmNvZGVyc1JlZ2V4LCBmdW5jdGlvbihtYXRjaCwga2V5KSB7XG4gICAgICAgICAgICBrZXkgLT0gLTE7IC8vIGNvbnZlcnQgdG8gbnVtYmVyIGFuZCBpbmNyZW1lbnRcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBodG1sRW5jb2Rlck5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgICAgICAgICAgICBodG1sRW5jb2Rlck5vZGUudGV4dENvbnRlbnQgPSBhcmdzW2tleV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0bWxFbmNvZGVyTm9kZS5pbm5lckhUTUw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xufVxuXG4vKipcbiAqIEBzdW1tYXJ5IFJlcGxhY2UgY29udGVudHMgb2YgYGVsYCB3aXRoIGBOb2Rlc2AgZ2VuZXJhdGVkIGZyb20gZm9ybWF0dGVkIHRlbXBsYXRlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufSB0ZW1wbGF0ZSAtIFNlZSBgdGVtcGxhdGVgIHBhcmFtZXRlciBvZiB7QGxpbmsgYXV0b21hdH0uXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2VsXSAtIE5vZGUgaW4gd2hpY2ggdG8gcmV0dXJuIG1hcmt1cCBnZW5lcmF0ZWQgZnJvbSB0ZW1wbGF0ZS4gSWYgb21pdHRlZCwgYSBuZXcgYDxkaXY+Li4uPC9kaXY+YCBlbGVtZW50IHdpbGwgYmUgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHsuLi4qfSBbcmVwbGFjZW1lbnRzXSAtIFJlcGxhY2VtZW50IHZhbHVlcyBmb3IgbnVtYmVyZWQgZm9ybWF0IHBhdHRlcm5zLlxuICpcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBUaGUgYGVsYCBwcm92aWRlZCBvciBhIG5ldyBgPGRpdj4uLi48L2Rpdj5gIGVsZW1lbnQsIGl0cyBgaW5uZXJIVE1MYCBzZXQgdG8gdGhlIGZvcm1hdHRlZCB0ZXh0LlxuICpcbiAqIEBtZW1iZXJPZiBtb2R1bGU6YXV0b21hdFxuICovXG5mdW5jdGlvbiByZXBsYWNlKHRlbXBsYXRlLCBlbCwgcmVwbGFjZW1lbnRzLyouLi4qLykge1xuICAgIHZhciBlbE9taXR0ZWQgPSB0eXBlb2YgZWwgIT09ICdvYmplY3QnLFxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIGlmIChlbE9taXR0ZWQpIHtcbiAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgICAgYXJncy51bnNoaWZ0KHRlbXBsYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcmdzWzBdID0gdGVtcGxhdGU7XG4gICAgfVxuXG4gICAgZWwuaW5uZXJIVE1MID0gYXV0b21hdC5hcHBseShudWxsLCBhcmdzKTtcblxuICAgIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBAc3VtbWFyeSBBcHBlbmQgb3IgaW5zZXJ0IGBOb2RlYHMgZ2VuZXJhdGVkIGZyb20gZm9ybWF0dGVkIHRlbXBsYXRlIGludG8gZ2l2ZW4gYGVsYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbn0gdGVtcGxhdGUgLSBTZWUgYHRlbXBsYXRlYCBwYXJhbWV0ZXIgb2Yge0BsaW5rIGF1dG9tYXR9LlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gKlxuICogQHBhcmFtIHtOb2RlfSBbcmVmZXJlbmNlTm9kZT1udWxsXSBJbnNlcnRzIGJlZm9yZSB0aGlzIGVsZW1lbnQgd2l0aGluIGBlbGAgb3IgYXQgZW5kIG9mIGBlbGAgaWYgYG51bGxgLlxuICpcbiAqIEBwYXJhbSB7Li4uKn0gW3JlcGxhY2VtZW50c10gLSBSZXBsYWNlbWVudCB2YWx1ZXMgZm9yIG51bWJlcmVkIGZvcm1hdCBwYXR0ZXJucy5cbiAqXG4gKiBAcmV0dXJucyB7Tm9kZVtdfSBBcnJheSBvZiB0aGUgZ2VuZXJhdGVkIG5vZGVzICh0aGlzIGlzIGFuIGFjdHVhbCBBcnJheSBpbnN0YW5jZTsgbm90IGFuIEFycmF5LWxpa2Ugb2JqZWN0KS5cbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOmF1dG9tYXRcbiAqL1xuZnVuY3Rpb24gYXBwZW5kKHRlbXBsYXRlLCBlbCwgcmVmZXJlbmNlTm9kZSwgcmVwbGFjZW1lbnRzLyouLi4qLykge1xuICAgIHZhciByZXBsYWNlbWVudHNTdGFydEF0ID0gMyxcbiAgICAgICAgcmVmZXJlbmNlTm9kZU9taXR0ZWQgPSB0eXBlb2YgcmVmZXJlbmNlTm9kZSAhPT0gJ29iamVjdCc7ICAvLyByZXBsYWNlbWVudHMgYXJlIG5ldmVyIG9iamVjdHNcblxuICAgIGlmIChyZWZlcmVuY2VOb2RlT21pdHRlZCkge1xuICAgICAgICByZWZlcmVuY2VOb2RlID0gbnVsbDtcbiAgICAgICAgcmVwbGFjZW1lbnRzU3RhcnRBdCA9IDI7XG4gICAgfVxuXG4gICAgcmVwbGFjZW1lbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCByZXBsYWNlbWVudHNTdGFydEF0KTtcbiAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIGRpdiA9IHJlcGxhY2UuYXBwbHkobnVsbCwgW3RlbXBsYXRlXS5jb25jYXQocmVwbGFjZW1lbnRzKSk7XG5cbiAgICB3aGlsZSAoZGl2LmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGRpdi5maXJzdENoaWxkKTtcbiAgICAgICAgZWwuaW5zZXJ0QmVmb3JlKGRpdi5maXJzdENoaWxkLCByZWZlcmVuY2VOb2RlKTsgLy8gcmVtb3ZlcyBjaGlsZCBmcm9tIGRpdlxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVXNlIHRoaXMgY29udmVuaWVuY2Ugd3JhcHBlciB0byByZXR1cm4gdGhlIGZpcnN0IGNoaWxkIG5vZGUgZGVzY3JpYmVkIGluIGB0ZW1wbGF0ZWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb259IHRlbXBsYXRlIC0gSWYgYSBmdW5jdGlvbiwgZXh0cmFjdCB0ZW1wbGF0ZSBmcm9tIGNvbW1lbnQgd2l0aGluLlxuICpcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gVGhlIGZpcnN0IGBOb2RlYCBpbiB5b3VyIHRlbXBsYXRlLlxuICpcbiAqIEBtZW1iZXJPZiBtb2R1bGU6YXV0b21hdFxuICovXG5mdW5jdGlvbiBmaXJzdENoaWxkKHRlbXBsYXRlLCByZXBsYWNlbWVudHMvKi4uLiovKSB7XG4gICAgcmV0dXJuIHJlcGxhY2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5maXJzdENoaWxkO1xufVxuXG4vKipcbiAqIFVzZSB0aGlzIGNvbnZlbmllbmNlIHdyYXBwZXIgdG8gcmV0dXJuIHRoZSBmaXJzdCBjaGlsZCBlbGVtZW50IGRlc2NyaWJlZCBpbiBgdGVtcGxhdGVgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufSB0ZW1wbGF0ZSAtIElmIGEgZnVuY3Rpb24sIGV4dHJhY3QgdGVtcGxhdGUgZnJvbSBjb21tZW50IHdpdGhpbi5cbiAqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IFRoZSBmaXJzdCBgSFRNTEVsZW1lbnRgIGluIHlvdXIgdGVtcGxhdGUuXG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTphdXRvbWF0XG4gKi9cbmZ1bmN0aW9uIGZpcnN0RWxlbWVudCh0ZW1wbGF0ZSwgcmVwbGFjZW1lbnRzLyouLi4qLykge1xuICAgIHJldHVybiByZXBsYWNlLmFwcGx5KG51bGwsIGFyZ3VtZW50cykuZmlyc3RFbGVtZW50Q2hpbGQ7XG59XG5cbi8qKlxuICogQHN1bW1hcnkgRmluZHMgc3RyaW5nIHN1YnN0aXR1dGlvbiBsZXhlbWVzIHRoYXQgcmVxdWlyZSBIVE1MIGVuY29kaW5nLlxuICogQGRlc2MgTW9kaWZ5IHRvIHN1aXQuXG4gKiBAZGVmYXVsdCAle259XG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQG1lbWJlck9mIG1vZHVsZTphdXRvbWF0XG4gKi9cbmF1dG9tYXQuZW5jb2RlcnNSZWdleCA9IEVOQ09ERVJTO1xuXG4vKipcbiAqIEBzdW1tYXJ5IEZpbmRzIHN0cmluZyBzdWJzdGl0dXRpb24gbGV4ZW1lcy5cbiAqIEBkZXNjIE1vZGlmeSB0byBzdWl0LlxuICogQGRlZmF1bHQgJHtufVxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6YXV0b21hdFxuICovXG5hdXRvbWF0LnJlcGxhY2Vyc1JlZ2V4ID0gUkVQTEFDRVJTO1xuXG5hdXRvbWF0LmZvcm1hdCA9IGF1dG9tYXQ7IC8vIGlmIHlvdSBmaW5kIHVzaW5nIGp1c3QgYGF1dG9tYXQoKWAgY29uZnVzaW5nXG5hdXRvbWF0LnJlcGxhY2UgPSByZXBsYWNlO1xuYXV0b21hdC5hcHBlbmQgPSBhcHBlbmQ7XG5hdXRvbWF0LmZpcnN0Q2hpbGQgPSBmaXJzdENoaWxkO1xuYXV0b21hdC5maXJzdEVsZW1lbnQgPSBmaXJzdEVsZW1lbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gYXV0b21hdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKiBAbmFtZXNwYWNlIGNzc0luamVjdG9yICovXG5cbi8qKlxuICogQHN1bW1hcnkgSW5zZXJ0IGJhc2Ugc3R5bGVzaGVldCBpbnRvIERPTVxuICpcbiAqIEBkZXNjIENyZWF0ZXMgYSBuZXcgYDxzdHlsZT4uLi48L3N0eWxlPmAgZWxlbWVudCBmcm9tIHRoZSBuYW1lZCB0ZXh0IHN0cmluZyhzKSBhbmQgaW5zZXJ0cyBpdCBidXQgb25seSBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0IGluIHRoZSBzcGVjaWZpZWQgY29udGFpbmVyIGFzIHBlciBgcmVmZXJlbmNlRWxlbWVudGAuXG4gKlxuICogPiBDYXZlYXQ6IElmIHN0eWxlc2hlZXQgaXMgZm9yIHVzZSBpbiBhIHNoYWRvdyBET00sIHlvdSBtdXN0IHNwZWNpZnkgYSBsb2NhbCBgcmVmZXJlbmNlRWxlbWVudGAuXG4gKlxuICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhlIG5ld2x5IGNyZWF0ZWQgYDxzdHlsZT4uLi48L3N0eWxlPmAgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gY3NzUnVsZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbSURdXG4gKiBAcGFyYW0ge3VuZGVmaW5lZHxudWxsfEVsZW1lbnR8c3RyaW5nfSBbcmVmZXJlbmNlRWxlbWVudF0gLSBDb250YWluZXIgZm9yIGluc2VydGlvbi4gT3ZlcmxvYWRzOlxuICogKiBgdW5kZWZpbmVkYCB0eXBlIChvciBvbWl0dGVkKTogaW5qZWN0cyBzdHlsZXNoZWV0IGF0IHRvcCBvZiBgPGhlYWQ+Li4uPC9oZWFkPmAgZWxlbWVudFxuICogKiBgbnVsbGAgdmFsdWU6IGluamVjdHMgc3R5bGVzaGVldCBhdCBib3R0b20gb2YgYDxoZWFkPi4uLjwvaGVhZD5gIGVsZW1lbnRcbiAqICogYEVsZW1lbnRgIHR5cGU6IGluamVjdHMgc3R5bGVzaGVldCBpbW1lZGlhdGVseSBiZWZvcmUgZ2l2ZW4gZWxlbWVudCwgd2hlcmV2ZXIgaXQgaXMgZm91bmQuXG4gKiAqIGBzdHJpbmdgIHR5cGU6IGluamVjdHMgc3R5bGVzaGVldCBpbW1lZGlhdGVseSBiZWZvcmUgZ2l2ZW4gZmlyc3QgZWxlbWVudCBmb3VuZCB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuIGNzcyBzZWxlY3Rvci5cbiAqXG4gKiBAbWVtYmVyT2YgY3NzSW5qZWN0b3JcbiAqL1xuZnVuY3Rpb24gY3NzSW5qZWN0b3IoY3NzUnVsZXMsIElELCByZWZlcmVuY2VFbGVtZW50KSB7XG4gICAgaWYgKHR5cGVvZiByZWZlcmVuY2VFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihyZWZlcmVuY2VFbGVtZW50KTtcbiAgICAgICAgaWYgKCFyZWZlcmVuY2VFbGVtZW50KSB7XG4gICAgICAgICAgICB0aHJvdyAnQ2Fubm90IGZpbmQgcmVmZXJlbmNlIGVsZW1lbnQgZm9yIENTUyBpbmplY3Rpb24uJztcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVmZXJlbmNlRWxlbWVudCAmJiAhKHJlZmVyZW5jZUVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgICB0aHJvdyAnR2l2ZW4gdmFsdWUgbm90IGEgcmVmZXJlbmNlIGVsZW1lbnQuJztcbiAgICB9XG5cbiAgICB2YXIgY29udGFpbmVyID0gcmVmZXJlbmNlRWxlbWVudCAmJiByZWZlcmVuY2VFbGVtZW50LnBhcmVudE5vZGUgfHwgZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuXG4gICAgaWYgKElEKSB7XG4gICAgICAgIElEID0gY3NzSW5qZWN0b3IuaWRQcmVmaXggKyBJRDtcblxuICAgICAgICBpZiAoY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJyMnICsgSUQpKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIHN0eWxlc2hlZXQgYWxyZWFkeSBpbiBET01cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgaWYgKElEKSB7XG4gICAgICAgIHN0eWxlLmlkID0gSUQ7XG4gICAgfVxuICAgIGlmIChjc3NSdWxlcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGNzc1J1bGVzID0gY3NzUnVsZXMuam9pbignXFxuJyk7XG4gICAgfVxuICAgIGNzc1J1bGVzID0gJ1xcbicgKyBjc3NSdWxlcyArICdcXG4nO1xuICAgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1J1bGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzc1J1bGVzKSk7XG4gICAgfVxuXG4gICAgaWYgKHJlZmVyZW5jZUVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgY29udGFpbmVyLmluc2VydEJlZm9yZShzdHlsZSwgcmVmZXJlbmNlRWxlbWVudCk7XG5cbiAgICByZXR1cm4gc3R5bGU7XG59XG5cbi8qKlxuICogQHN1bW1hcnkgT3B0aW9uYWwgcHJlZml4IGZvciBgPHN0eWxlPmAgdGFnIElEcy5cbiAqIEBkZXNjIERlZmF1bHRzIHRvIGAnaW5qZWN0ZWQtc3R5bGVzaGVldC0nYC5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAbWVtYmVyT2YgY3NzSW5qZWN0b3JcbiAqL1xuY3NzSW5qZWN0b3IuaWRQcmVmaXggPSAnaW5qZWN0ZWQtc3R5bGVzaGVldC0nO1xuXG4vLyBJbnRlcmZhY2Vcbm1vZHVsZS5leHBvcnRzID0gY3NzSW5qZWN0b3I7XG4iLCJ2YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuL2xpYi9rZXlzLmpzJyk7XG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2xpYi9pc19hcmd1bWVudHMuanMnKTtcblxudmFyIGRlZXBFcXVhbCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpIHtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMy4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCB8fCB0eXBlb2YgYWN0dWFsICE9ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvcHRzLnN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAoeCkge1xuICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnIHx8IHR5cGVvZiB4Lmxlbmd0aCAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB4LmNvcHkgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHguc2xpY2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHgubGVuZ3RoID4gMCAmJiB0eXBlb2YgeFswXSAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIG9wdHMpIHtcbiAgdmFyIGksIGtleTtcbiAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKGEpIHx8IGlzVW5kZWZpbmVkT3JOdWxsKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vfn5+SSd2ZSBtYW5hZ2VkIHRvIGJyZWFrIE9iamVjdC5rZXlzIHRocm91Z2ggc2NyZXd5IGFyZ3VtZW50cyBwYXNzaW5nLlxuICAvLyAgIENvbnZlcnRpbmcgdG8gYXJyYXkgc29sdmVzIHRoZSBwcm9ibGVtLlxuICBpZiAoaXNBcmd1bWVudHMoYSkpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIGRlZXBFcXVhbChhLCBiLCBvcHRzKTtcbiAgfVxuICBpZiAoaXNCdWZmZXIoYSkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLFxuICAgICAgICBrYiA9IG9iamVjdEtleXMoYik7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgb3B0cykpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiO1xufVxuIiwidmFyIHN1cHBvcnRzQXJndW1lbnRzQ2xhc3MgPSAoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudHMpXG59KSgpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID8gc3VwcG9ydGVkIDogdW5zdXBwb3J0ZWQ7XG5cbmV4cG9ydHMuc3VwcG9ydGVkID0gc3VwcG9ydGVkO1xuZnVuY3Rpb24gc3VwcG9ydGVkKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG5leHBvcnRzLnVuc3VwcG9ydGVkID0gdW5zdXBwb3J0ZWQ7XG5mdW5jdGlvbiB1bnN1cHBvcnRlZChvYmplY3Qpe1xuICByZXR1cm4gb2JqZWN0ICYmXG4gICAgdHlwZW9mIG9iamVjdCA9PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBvYmplY3QubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ2NhbGxlZScpICYmXG4gICAgIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsICdjYWxsZWUnKSB8fFxuICAgIGZhbHNlO1xufTtcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJ1xuICA/IE9iamVjdC5rZXlzIDogc2hpbTtcblxuZXhwb3J0cy5zaGltID0gc2hpbTtcbmZ1bmN0aW9uIHNoaW0gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAbmFtZXNwYWNlIGV4dGVuZC1tZSAqKi9cblxuLyoqIEBzdW1tYXJ5IEV4dGVuZHMgYW4gZXhpc3RpbmcgY29uc3RydWN0b3IgaW50byBhIG5ldyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcmV0dXJucyB7Q29uc3RydWN0b3J9IEEgbmV3IGNvbnN0cnVjdG9yLCBleHRlbmRlZCBmcm9tIHRoZSBnaXZlbiBjb250ZXh0LCBwb3NzaWJseSB3aXRoIHNvbWUgcHJvdG90eXBlIGFkZGl0aW9ucy5cbiAqXG4gKiBAZGVzYyBFeHRlbmRzIFwib2JqZWN0c1wiIChjb25zdHJ1Y3RvcnMpLCB3aXRoIG9wdGlvbmFsIGFkZGl0aW9uYWwgY29kZSwgb3B0aW9uYWwgcHJvdG90eXBlIGFkZGl0aW9ucywgYW5kIG9wdGlvbmFsIHByb3RvdHlwZSBtZW1iZXIgYWxpYXNlcy5cbiAqXG4gKiA+IENBVkVBVDogTm90IHRvIGJlIGNvbmZ1c2VkIHdpdGggVW5kZXJzY29yZS1zdHlsZSAuZXh0ZW5kKCkgd2hpY2ggaXMgc29tZXRoaW5nIGVsc2UgZW50aXJlbHkuIEkndmUgdXNlZCB0aGUgbmFtZSBcImV4dGVuZFwiIGhlcmUgYmVjYXVzZSBvdGhlciBwYWNrYWdlcyAobGlrZSBCYWNrYm9uZS5qcykgdXNlIGl0IHRoaXMgd2F5LiBZb3UgYXJlIGZyZWUgdG8gY2FsbCBpdCB3aGF0ZXZlciB5b3Ugd2FudCB3aGVuIHlvdSBcInJlcXVpcmVcIiBpdCwgc3VjaCBhcyBgdmFyIGluaGVyaXRzID0gcmVxdWlyZSgnZXh0ZW5kJylgLlxuICpcbiAqIFByb3ZpZGUgYSBjb25zdHJ1Y3RvciBhcyB0aGUgY29udGV4dCBhbmQgYW55IHByb3RvdHlwZSBhZGRpdGlvbnMgeW91IHJlcXVpcmUgaW4gdGhlIGZpcnN0IGFyZ3VtZW50LlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiB5b3Ugd2lzaCB0byBiZSBhYmxlIHRvIGV4dGVuZCBgQmFzZUNvbnN0cnVjdG9yYCB0byBhIG5ldyBjb25zdHJ1Y3RvciB3aXRoIHByb3RvdHlwZSBvdmVycmlkZXMgYW5kL29yIGFkZGl0aW9ucywgYmFzaWMgdXNhZ2UgaXM6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIEJhc2UgPSByZXF1aXJlKCdleHRlbmQtbWUnKS5CYXNlO1xuICogdmFyIEJhc2VDb25zdHJ1Y3RvciA9IEJhc2UuZXh0ZW5kKGJhc2VQcm90b3R5cGUpOyAvLyBtaXhlcyBpbiAuZXh0ZW5kXG4gKiB2YXIgQ2hpbGRDb25zdHJ1Y3RvciA9IEJhc2VDb25zdHJ1Y3Rvci5leHRlbmQoY2hpbGRQcm90b3R5cGVPdmVycmlkZXNBbmRBZGRpdGlvbnMpO1xuICogdmFyIEdyYW5kY2hpbGRDb25zdHJ1Y3RvciA9IENoaWxkQ29uc3RydWN0b3IuZXh0ZW5kKGdyYW5kY2hpbGRQcm90b3R5cGVPdmVycmlkZXNBbmRBZGRpdGlvbnMpO1xuICogYGBgXG4gKlxuICogVGhpcyBmdW5jdGlvbiAoYGV4dGVuZCgpYCkgaXMgYWRkZWQgdG8gdGhlIG5ldyBleHRlbmRlZCBvYmplY3QgY29uc3RydWN0b3IgYXMgYSBwcm9wZXJ0eSBgLmV4dGVuZGAsIGVzc2VudGlhbGx5IG1ha2luZyB0aGUgb2JqZWN0IGNvbnN0cnVjdG9yIGl0c2VsZiBlYXNpbHkgXCJleHRlbmRhYmxlLlwiIChOb3RlOiBUaGlzIGlzIGEgcHJvcGVydHkgb2YgZWFjaCBjb25zdHJ1Y3RvciBhbmQgbm90IGEgbWV0aG9kIG9mIGl0cyBwcm90b3R5cGUhKVxuICpcbiAqIEB0aGlzIEJhc2UgY2xhc3MgYmVpbmcgZXh0ZW5kZWQgZnJvbSAoaS5lLiwgaXRzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIG9iamVjdCkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtleHRlbmRlZENsYXNzTmFtZV0gLSBUaGlzIGlzIHNpbXBseSBhZGRlZCB0byB0aGUgcHJvdG90eXBlIGFzICQkQ0xBU1NfTkFNRS4gVXNlZnVsIGZvciBkZWJ1Z2dpbmcgYmVjYXVzZSBhbGwgZGVyaXZlZCBjb25zdHJ1Y3RvcnMgYXBwZWFyIHRvIGhhdmUgdGhlIHNhbWUgbmFtZSAoXCJDb25zdHJ1Y3RvclwiKSBpbiB0aGUgZGVidWdnZXIuXG4gKlxuICogQHBhcmFtIHtleHRlbmRlZFByb3RvdHlwZUFkZGl0aW9uc09iamVjdH0gW3Byb3RvdHlwZUFkZGl0aW9uc10gLSBPYmplY3Qgd2l0aCBtZW1iZXJzIHRvIGNvcHkgdG8gbmV3IGNvbnN0cnVjdG9yJ3MgcHJvdG90eXBlLlxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RlYnVnXSAtIFNlZSBwYXJhbWV0ZXIgYGV4dGVuZGVkQ2xhc3NOYW1lYCBfKGFib3ZlKV8uXG4gKlxuICogQHByb3BlcnR5IHtvYmplY3R9IEJhc2UgLSBBIGNvbnZlbmllbnQgYmFzZSBjbGFzcyBmcm9tIHdoaWNoIGFsbCBvdGhlciBjbGFzc2VzIGNhbiBiZSBleHRlbmRlZC5cbiAqXG4gKiBAbWVtYmVyT2YgZXh0ZW5kLW1lXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChleHRlbmRlZENsYXNzTmFtZSwgcHJvdG90eXBlQWRkaXRpb25zKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHByb3RvdHlwZUFkZGl0aW9ucyA9IHt9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGV4dGVuZGVkQ2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgcHJvdG90eXBlQWRkaXRpb25zID0gZXh0ZW5kZWRDbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkQ2xhc3NOYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICBwcm90b3R5cGVBZGRpdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ1NpbmdsZS1wYXJhbWV0ZXIgb3ZlcmxvYWQgbXVzdCBiZSBlaXRoZXIgc3RyaW5nIG9yIG9iamVjdC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0ZW5kZWRDbGFzc05hbWUgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm90b3R5cGVBZGRpdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1R3by1wYXJhbWV0ZXIgb3ZlcmxvYWQgbXVzdCBiZSBzdHJpbmcsIG9iamVjdC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyAnVG9vIG1hbnkgcGFyYW1ldGVycyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGNsYXNzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29uc3RydWN0b3IoKSB7XG4gICAgICAgIGlmICh0aGlzLnByZUluaXRpYWxpemUpIHtcbiAgICAgICAgICAgIHRoaXMucHJlSW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5pdGlhbGl6ZVByb3RvdHlwZUNoYWluLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgaWYgKHRoaXMucG9zdEluaXRpYWxpemUpIHtcbiAgICAgICAgICAgIHRoaXMucG9zdEluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAc2VlIHtAbGluayBleHRlbmQtbWUuZXh0ZW5kfVxuICAgICAqIEBkZXNjIEFkZGVkIHRvIGVhY2ggcmV0dXJuZWQgZXh0ZW5kZWQgY2xhc3MgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgQ29uc3RydWN0b3IuZXh0ZW5kID0gZXh0ZW5kO1xuXG4gICAgQ29uc3RydWN0b3IuZ2V0Q2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lO1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYW5jZXN0b3JDb25zdHJ1Y3Rvck5hbWVdIC0gSWYgZ2l2ZW4sIHNlYXJjaGVzIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4gZm9yIGNvbnN0cnVjdG9yIHdpdGggbWF0Y2hpbmcgbmFtZS5cbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb258bnVsbH0gQ29uc3RydWN0b3Igb2YgcGFyZW50IGNsYXNzOyBvciBhbmNlc3RvciBjbGFzcyB3aXRoIG1hdGNoaW5nIG5hbWU7IG9yIG51bGxcbiAgICAgKi9cbiAgICBDb25zdHJ1Y3Rvci5wYXJlbnQgPSBwYXJlbnRDb25zdHJ1Y3RvcjtcblxuICAgIHZhciBwcm90b3R5cGUgPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHRoaXMucHJvdG90eXBlKTtcbiAgICBwcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcblxuICAgIGV4dGVuZGVkQ2xhc3NOYW1lID0gZXh0ZW5kZWRDbGFzc05hbWUgfHwgcHJvdG90eXBlLiQkQ0xBU1NfTkFNRSB8fCBwcm90b3R5cGUubmFtZTtcbiAgICBpZiAoZXh0ZW5kZWRDbGFzc05hbWUpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCAnbmFtZScsIHsgdmFsdWU6IGV4dGVuZGVkQ2xhc3NOYW1lLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgICAgIHByb3RvdHlwZS4kJENMQVNTX05BTUUgPSBleHRlbmRlZENsYXNzTmFtZTtcbiAgICB9XG5cbiAgICAvLyBkZWZpbmUgZWFjaCBwcm90b3R5cGUgYWRkaXRpb24gb24gdGhlIHByb3RvdHlwZSAoaW5jbHVkaW5nIGdldHRlci9zZXR0ZXJzKVxuICAgIHZhciBrZXksIGRlc2NyaXB0b3I7XG4gICAgZm9yIChrZXkgaW4gcHJvdG90eXBlQWRkaXRpb25zKSB7XG4gICAgICAgIGlmICgoZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG90eXBlQWRkaXRpb25zLCBrZXkpKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5wb3N0RXh0ZW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucG9zdEV4dGVuZChwcm90b3R5cGUpO1xuICAgIH1cblxuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gQmFzZSgpIHt9XG5CYXNlLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBCYXNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcixcblxuICAgIGdldENsYXNzTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLiQkQ0xBU1NfTkFNRSB8fFxuICAgICAgICAgICAgdGhpcy5uYW1lIHx8XG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgLy8gdHJ5IEZ1bmN0aW9uLnByb3RvdHlwZS5uYW1lIGFzIGxhc3QgcmVzb3J0XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFjY2VzcyBhIG1lbWJlciBvZiB0aGUgc3VwZXIgY2xhc3MuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXQgc3VwZXIoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBtZW1iZXIgb24gcHJvdG90eXBlIGNoYWluIGJlZ2lubmluZyB3aXRoIHN1cGVyIGNsYXNzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZW1iZXJOYW1lXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZHwqfSBgdW5kZWZpbmVkYCBpZiBub3QgZm91bmQ7IHZhbHVlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzdXBlck1lbWJlcjogZnVuY3Rpb24obWVtYmVyTmFtZSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5zdXBlcjtcbiAgICAgICAgZG8geyBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyZW50KTsgfSB3aGlsZSAoIXBhcmVudC5oYXNPd25Qcm9wZXJ0eShtZW1iZXJOYW1lKSk7XG4gICAgICAgIHJldHVybiBwYXJlbnQgJiYgcGFyZW50W21lbWJlck5hbWVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIG1ldGhvZCBvbiBwcm90b3R5cGUgY2hhaW4gYmVnaW5uaW5nIHdpdGggc3VwZXIgY2xhc3MuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWVcbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgc3VwZXJNZXRob2Q6IGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMuc3VwZXJNZW1iZXIobWV0aG9kTmFtZSk7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzLicgKyBtZXRob2ROYW1lICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgbWV0aG9kIG9uIHByb3RvdHlwZSBjaGFpbiBiZWdpbm5pbmcgd2l0aCBzdXBlciBjbGFzcyBhbmQgY2FsbCBpdCB3aXRoIHJlbWFpbmluZyBhcmdzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgY2FsbFN1cGVyTWV0aG9kOiBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyTWV0aG9kKG1ldGhvZE5hbWUpLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cbn07XG5CYXNlLmV4dGVuZCA9IGV4dGVuZDtcbmV4dGVuZC5CYXNlID0gQmFzZTtcblxuLyoqXG4gKiBPcHRpb25hbCBzdGF0aWMgbWV0aG9kIGlzIGNhbGxlZCB3aXRoIG5ldyBcImNsYXNzXCIgKGNvbnN0cnVjdG9yKSBhZnRlciBleHRlbmRpbmcuXG4gKiBUaGlzIHBlcm1pdHMgbWlzY2VsbGFuZW91cyB0d2Vha2luZyBhbmQgY2xlYW51cCBvZiB0aGUgbmV3IGNsYXNzLlxuICogQG1ldGhvZCBwb3N0RXh0ZW5kXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvdG90eXBlXG4gKiBAbWVtYmVyT2YgQmFzZVxuICovXG5cbi8qKiBAdHlwZWRlZiB7ZnVuY3Rpb259IGV4dGVuZGVkQ29uc3RydWN0b3JcbiAqIEBwcm9wZXJ0eSBwcm90b3R5cGUuc3VwZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgcHJvdG90eXBlIHRoaXMgY29uc3RydWN0b3Igd2FzIGV4dGVuZGVkIGZyb20uXG4gKiBAcHJvcGVydHkgW2V4dGVuZF0gLSBJZiBgcHJvdG90eXBlQWRkaXRpb25zLmV4dGVuZGFibGVgIHdhcyB0cnV0aHksIHRoaXMgd2lsbCBiZSBhIHJlZmVyZW5jZSB0byB7QGxpbmsgZXh0ZW5kLmV4dGVuZHxleHRlbmR9LlxuICovXG5cbi8qKiBAdHlwZWRlZiB7b2JqZWN0fSBleHRlbmRlZFByb3RvdHlwZUFkZGl0aW9uc09iamVjdFxuICogQGRlc2MgQWxsIG1lbWJlcnMgYXJlIGNvcGllZCB0byB0aGUgbmV3IG9iamVjdC4gVGhlIGZvbGxvd2luZyBoYXZlIHNwZWNpYWwgbWVhbmluZy5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtpbml0aWFsaXplXSAtIEFkZGl0aW9uYWwgY29uc3RydWN0b3IgY29kZSBmb3IgbmV3IG9iamVjdC4gVGhpcyBtZXRob2QgaXMgYWRkZWQgdG8gdGhlIG5ldyBjb25zdHJ1Y3RvcidzIHByb3RvdHlwZS4gR2V0cyBwYXNzZWQgbmV3IG9iamVjdCBhcyBjb250ZXh0ICsgc2FtZSBhcmdzIGFzIGNvbnN0cnVjdG9yIGl0c2VsZi4gQ2FsbGVkIG9uIGluc3RhbnRpYXRpb24gYWZ0ZXIgc2ltaWxhciBmdW5jdGlvbiBpbiBhbGwgYW5jZXN0b3JzIGNhbGxlZCB3aXRoIHNhbWUgc2lnbmF0dXJlLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW3ByZUluaXRpYWxpemVdIC0gQ2FsbGVkIGJlZm9yZSB0aGUgYGluaXRpYWxpemVgIGNhc2NhZGUuIEdldHMgcGFzc2VkIG5ldyBvYmplY3QgYXMgY29udGV4dCArIHNhbWUgYXJncyBhcyBjb25zdHJ1Y3RvciBpdHNlbGYuIElmIG5vdCBkZWZpbmVkIGhlcmUsIHRoZSB0b3AtbW9zdCAoYW5kIG9ubHkgdGhlIHRvcC1tb3N0KSBkZWZpbml0aW9uIGZvdW5kIG9uIHRoZSBwcm90b3R5cGUgY2hhaW4gaXMgY2FsbGVkLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW3Bvc3RJbml0aWFsaXplXSAtIENhbGxlZCBhZnRlciB0aGUgYGluaXRpYWxpemVgIGNhc2NhZGUuIEdldHMgcGFzc2VkIG5ldyBvYmplY3QgYXMgY29udGV4dCArIHNhbWUgYXJncyBhcyBjb25zdHJ1Y3RvciBpdHNlbGYuIElmIG5vdCBkZWZpbmVkIGhlcmUsIHRoZSB0b3AtbW9zdCAoYW5kIG9ubHkgdGhlIHRvcC1tb3N0KSBkZWZpbml0aW9uIGZvdW5kIG9uIHRoZSBwcm90b3R5cGUgY2hhaW4gaXMgY2FsbGVkLlxuICovXG5cbi8qKiBAc3VtbWFyeSBDYWxsIGFsbCBgaW5pdGlhbGl6ZWAgbWV0aG9kcyBmb3VuZCBpbiBwcm90b3R5cGUgY2hhaW4sIGJlZ2lubmluZyB3aXRoIHRoZSBtb3N0IHNlbmlvciBhbmNlc3RvcidzIGZpcnN0LlxuICogQGRlc2MgVGhpcyByZWN1cnNpdmUgcm91dGluZSBpcyBjYWxsZWQgYnkgdGhlIGNvbnN0cnVjdG9yLlxuICogMS4gV2Fsa3MgYmFjayB0aGUgcHJvdG90eXBlIGNoYWluIHRvIGBPYmplY3RgJ3MgcHJvdG90eXBlXG4gKiAyLiBXYWxrcyBmb3J3YXJkIHRvIG5ldyBvYmplY3QsIGNhbGxpbmcgYW55IGBpbml0aWFsaXplYCBtZXRob2RzIGl0IGZpbmRzIGFsb25nIHRoZSB3YXkgd2l0aCB0aGUgc2FtZSBjb250ZXh0IGFuZCBhcmd1bWVudHMgd2l0aCB3aGljaCB0aGUgY29uc3RydWN0b3Igd2FzIGNhbGxlZC5cbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyT2YgZXh0ZW5kLW1lXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVQcm90b3R5cGVDaGFpbigpIHtcbiAgICB2YXIgdGVybSA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmVjdXIodGVybSk7XG5cbiAgICBmdW5jdGlvbiByZWN1cihvYmopIHtcbiAgICAgICAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgICAgIGlmIChwcm90by5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gICAgICAgICAgICByZWN1cihwcm90byk7XG4gICAgICAgICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJ2luaXRpYWxpemUnKSkge1xuICAgICAgICAgICAgICAgIHByb3RvLmluaXRpYWxpemUuYXBwbHkodGVybSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldENsYXNzTmFtZSgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLnByb3RvdHlwZS4kJENMQVNTX05BTUUgfHxcbiAgICAgICAgdGhpcy5wcm90b3R5cGUubmFtZSB8fFxuICAgICAgICB0aGlzLm5hbWUgLy8gdHJ5IEZ1bmN0aW9uLnByb3RvdHlwZS5uYW1lIGFzIGxhc3QgcmVzb3J0XG4gICAgKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Q29uc3RydWN0b3IoYW5jZXN0b3JDb25zdHJ1Y3Rvck5hbWUpIHtcbiAgICB2YXIgcHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XG4gICAgaWYgKHByb3RvdHlwZSkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKTtcbiAgICAgICAgfSB3aGlsZSAoYW5jZXN0b3JDb25zdHJ1Y3Rvck5hbWUgJiYgcHJvdG90eXBlICYmIHByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lICE9PSBhbmNlc3RvckNvbnN0cnVjdG9yTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBwcm90b3R5cGUgJiYgcHJvdG90eXBlLmNvbnN0cnVjdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4dGVuZDtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhdXRvbWF0ID0gcmVxdWlyZSgnYXV0b21hdCcpO1xuXG4vKipcbiAqIEBzdW1tYXJ5IEluamVjdHMgdGhlIG5hbWVkIHN0eWxlc2hlZXQgaW50byBgPGhlYWQ+YC5cbiAqIEBkZXNjIFN0eWxlc2hlZXRzIGFyZSBpbnNlcnRlZCBjb25zZWN1dGl2ZWx5IGF0IGVuZCBvZiBgPGhlYWQ+YCB1bmxlc3MgYGJlZm9yZSA9PT0gdHJ1ZWAgKG9yIG9taXR0ZWQgYW5kIGBpbmplY3RTdHlsZXNoZWV0VGVtcGxhdGUuYmVmb3JlYCB0cnV0aHkpIGluIHdoaWNoIGNhc2UgdGhleSBhcmUgaW5zZXJ0ZWQgY29uc2VjdXRpdmVseSBiZWZvcmUgZmlyc3Qgc3R5bGVzaGVldCBmb3VuZCBpbiBgPGhlYWQ+YCAoaWYgYW55KSBhdCBsb2FkIHRpbWUuXG4gKlxuICogVGhlIGNhbGxpbmcgY29udGV4dCAoYHRoaXNgKSBpcyBhIHN0eWxlc2hlZXQgcmVnaXN0cnkuXG4gKiBJZiBgdGhpc2AgaXMgdW5kZWZpbmVkLCB0aGUgZ2xvYmFsIHN0eWxlc2hlZXQgcmVnaXN0cnkgKGNzcy9pbmRleC5qcykgaXMgdXNlZC5cbiAqIEB0aGlzIHtvYmplY3R9XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtiZWZvcmU9aW5qZWN0U3R5bGVzaGVldFRlbXBsYXRlLmJlZm9yZV0gLSBBZGQgc3R5bGVzaGVldCBiZWZvcmUgaW50aWFsbHkgbG9hZGVkIHN0eWxlc2hlZXRzLlxuICpcbiAqIF9JZiBvbWl0dGVkOl9cbiAqIDEuIGBpZGAgaXMgcHJvbW90ZWQgdG8gZmlyc3QgYXJndW1lbnQgcG9zaXRpb25cbiAqIDIuIGBpbmplY3RTdHlsZXNoZWV0VGVtcGxhdGUuYmVmb3JlYCBpcyBgdHJ1ZWAgYnkgZGVmYXVsdFxuICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIG5hbWUgb2YgdGhlIHN0eWxlIHNoZWV0IGluIGB0aGlzYCwgYSBzdHlsZXNoZWV0IFwicmVnaXN0cnlcIiAoaGFzaCBvZiBzdHlsZXNoZWV0cykuXG4gKiBAcmV0dXJucyB7RWxlbWVudHwqfVxuICovXG5mdW5jdGlvbiBpbmplY3RTdHlsZXNoZWV0VGVtcGxhdGUoYmVmb3JlLCBpZCkge1xuICAgIHZhciBvcHRpb25hbEFyZ3NTdGFydEF0LCBzdHlsZXNoZWV0LCBoZWFkLCByZWZOb2RlLCBjc3MsIGFyZ3MsXG4gICAgICAgIHByZWZpeCA9IGluamVjdFN0eWxlc2hlZXRUZW1wbGF0ZS5wcmVmaXg7XG5cbiAgICBpZiAodHlwZW9mIGJlZm9yZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIG9wdGlvbmFsQXJnc1N0YXJ0QXQgPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlkID0gYmVmb3JlO1xuICAgICAgICBiZWZvcmUgPSBpbmplY3RTdHlsZXNoZWV0VGVtcGxhdGUuYmVmb3JlO1xuICAgICAgICBvcHRpb25hbEFyZ3NTdGFydEF0ID0gMTtcbiAgICB9XG5cbiAgICBzdHlsZXNoZWV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocHJlZml4ICsgaWQpO1xuXG4gICAgaWYgKCFzdHlsZXNoZWV0KSB7XG4gICAgICAgIGhlYWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkJyk7XG5cbiAgICAgICAgaWYgKGJlZm9yZSkge1xuICAgICAgICAgICAgLy8gbm90ZSBwb3NpdGlvbiBvZiBmaXJzdCBzdHlsZXNoZWV0XG4gICAgICAgICAgICByZWZOb2RlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaGVhZC5jaGlsZHJlbikuZmluZChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IGNoaWxkLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQudGFnTmFtZSA9PT0gJ1NUWUxFJyAmJiAoIWlkIHx8IGlkLmluZGV4T2YocHJlZml4KSAhPT0gcHJlZml4KSB8fFxuICAgICAgICAgICAgICAgICAgICBjaGlsZC50YWdOYW1lID09PSAnTElOSycgJiYgY2hpbGQuZ2V0QXR0cmlidXRlKCdyZWwnKSA9PT0gJ3N0eWxlc2hlZXQnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjc3MgPSB0aGlzW2lkXTtcblxuICAgICAgICBpZiAoIWNzcykge1xuICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIHRvIGZpbmQgbWVtYmVyIGAnICsgaWQgKyAnYCBpbiBjYWxsaW5nIGNvbnRleHQuJztcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ3MgPSBbXG4gICAgICAgICAgICAnPHN0eWxlPlxcbicgKyBjc3MgKyAnXFxuPC9zdHlsZT5cXG4nLFxuICAgICAgICAgICAgaGVhZCxcbiAgICAgICAgICAgIHJlZk5vZGUgfHwgbnVsbCAvLyBleHBsaWNpdGx5IG51bGwgcGVyIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlL2luc2VydEJlZm9yZVxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgb3B0aW9uYWxBcmdzU3RhcnRBdCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGVzaGVldCA9IGF1dG9tYXQuYXBwZW5kLmFwcGx5KG51bGwsIGFyZ3MpWzBdO1xuICAgICAgICBzdHlsZXNoZWV0LmlkID0gcHJlZml4ICsgaWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlc2hlZXQ7XG59XG5cbmluamVjdFN0eWxlc2hlZXRUZW1wbGF0ZS5iZWZvcmUgPSB0cnVlO1xuaW5qZWN0U3R5bGVzaGVldFRlbXBsYXRlLnByZWZpeCA9ICdpbmplY3RlZC1zdHlsZXNoZWV0LSc7XG5cbm1vZHVsZS5leHBvcnRzID0gaW5qZWN0U3R5bGVzaGVldFRlbXBsYXRlO1xuIiwiLyohXG4gKiBtdXN0YWNoZS5qcyAtIExvZ2ljLWxlc3Mge3ttdXN0YWNoZX19IHRlbXBsYXRlcyB3aXRoIEphdmFTY3JpcHRcbiAqIGh0dHA6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanNcbiAqL1xuXG4vKmdsb2JhbCBkZWZpbmU6IGZhbHNlIE11c3RhY2hlOiB0cnVlKi9cblxuKGZ1bmN0aW9uIGRlZmluZU11c3RhY2hlIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmIHR5cGVvZiBleHBvcnRzLm5vZGVOYW1lICE9PSAnc3RyaW5nJykge1xuICAgIGZhY3RvcnkoZXhwb3J0cyk7IC8vIENvbW1vbkpTXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KTsgLy8gQU1EXG4gIH0gZWxzZSB7XG4gICAgZ2xvYmFsLk11c3RhY2hlID0ge307XG4gICAgZmFjdG9yeShnbG9iYWwuTXVzdGFjaGUpOyAvLyBzY3JpcHQsIHdzaCwgYXNwXG4gIH1cbn0odGhpcywgZnVuY3Rpb24gbXVzdGFjaGVGYWN0b3J5IChtdXN0YWNoZSkge1xuXG4gIHZhciBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5UG9seWZpbGwgKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNGdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICAvKipcbiAgICogTW9yZSBjb3JyZWN0IHR5cGVvZiBzdHJpbmcgaGFuZGxpbmcgYXJyYXlcbiAgICogd2hpY2ggbm9ybWFsbHkgcmV0dXJucyB0eXBlb2YgJ29iamVjdCdcbiAgICovXG4gIGZ1bmN0aW9uIHR5cGVTdHIgKG9iaikge1xuICAgIHJldHVybiBpc0FycmF5KG9iaikgPyAnYXJyYXknIDogdHlwZW9mIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cCAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bXFwtXFxbXFxde30oKSorPy4sXFxcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpO1xuICB9XG5cbiAgLyoqXG4gICAqIE51bGwgc2FmZSB3YXkgb2YgY2hlY2tpbmcgd2hldGhlciBvciBub3QgYW4gb2JqZWN0LFxuICAgKiBpbmNsdWRpbmcgaXRzIHByb3RvdHlwZSwgaGFzIGEgZ2l2ZW4gcHJvcGVydHlcbiAgICovXG4gIGZ1bmN0aW9uIGhhc1Byb3BlcnR5IChvYmosIHByb3BOYW1lKSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIChwcm9wTmFtZSBpbiBvYmopO1xuICB9XG5cbiAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9pc3N1ZXMuYXBhY2hlLm9yZy9qaXJhL2Jyb3dzZS9DT1VDSERCLTU3N1xuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanMvaXNzdWVzLzE4OVxuICB2YXIgcmVnRXhwVGVzdCA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdDtcbiAgZnVuY3Rpb24gdGVzdFJlZ0V4cCAocmUsIHN0cmluZykge1xuICAgIHJldHVybiByZWdFeHBUZXN0LmNhbGwocmUsIHN0cmluZyk7XG4gIH1cblxuICB2YXIgbm9uU3BhY2VSZSA9IC9cXFMvO1xuICBmdW5jdGlvbiBpc1doaXRlc3BhY2UgKHN0cmluZykge1xuICAgIHJldHVybiAhdGVzdFJlZ0V4cChub25TcGFjZVJlLCBzdHJpbmcpO1xuICB9XG5cbiAgdmFyIGVudGl0eU1hcCA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5OycsXG4gICAgJy8nOiAnJiN4MkY7JyxcbiAgICAnYCc6ICcmI3g2MDsnLFxuICAgICc9JzogJyYjeDNEOydcbiAgfTtcblxuICBmdW5jdGlvbiBlc2NhcGVIdG1sIChzdHJpbmcpIHtcbiAgICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZSgvWyY8PlwiJ2A9XFwvXS9nLCBmdW5jdGlvbiBmcm9tRW50aXR5TWFwIChzKSB7XG4gICAgICByZXR1cm4gZW50aXR5TWFwW3NdO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHdoaXRlUmUgPSAvXFxzKi87XG4gIHZhciBzcGFjZVJlID0gL1xccysvO1xuICB2YXIgZXF1YWxzUmUgPSAvXFxzKj0vO1xuICB2YXIgY3VybHlSZSA9IC9cXHMqXFx9LztcbiAgdmFyIHRhZ1JlID0gLyN8XFxefFxcL3w+fFxce3wmfD18IS87XG5cbiAgLyoqXG4gICAqIEJyZWFrcyB1cCB0aGUgZ2l2ZW4gYHRlbXBsYXRlYCBzdHJpbmcgaW50byBhIHRyZWUgb2YgdG9rZW5zLiBJZiB0aGUgYHRhZ3NgXG4gICAqIGFyZ3VtZW50IGlzIGdpdmVuIGhlcmUgaXQgbXVzdCBiZSBhbiBhcnJheSB3aXRoIHR3byBzdHJpbmcgdmFsdWVzOiB0aGVcbiAgICogb3BlbmluZyBhbmQgY2xvc2luZyB0YWdzIHVzZWQgaW4gdGhlIHRlbXBsYXRlIChlLmcuIFsgXCI8JVwiLCBcIiU+XCIgXSkuIE9mXG4gICAqIGNvdXJzZSwgdGhlIGRlZmF1bHQgaXMgdG8gdXNlIG11c3RhY2hlcyAoaS5lLiBtdXN0YWNoZS50YWdzKS5cbiAgICpcbiAgICogQSB0b2tlbiBpcyBhbiBhcnJheSB3aXRoIGF0IGxlYXN0IDQgZWxlbWVudHMuIFRoZSBmaXJzdCBlbGVtZW50IGlzIHRoZVxuICAgKiBtdXN0YWNoZSBzeW1ib2wgdGhhdCB3YXMgdXNlZCBpbnNpZGUgdGhlIHRhZywgZS5nLiBcIiNcIiBvciBcIiZcIi4gSWYgdGhlIHRhZ1xuICAgKiBkaWQgbm90IGNvbnRhaW4gYSBzeW1ib2wgKGkuZS4ge3tteVZhbHVlfX0pIHRoaXMgZWxlbWVudCBpcyBcIm5hbWVcIi4gRm9yXG4gICAqIGFsbCB0ZXh0IHRoYXQgYXBwZWFycyBvdXRzaWRlIGEgc3ltYm9sIHRoaXMgZWxlbWVudCBpcyBcInRleHRcIi5cbiAgICpcbiAgICogVGhlIHNlY29uZCBlbGVtZW50IG9mIGEgdG9rZW4gaXMgaXRzIFwidmFsdWVcIi4gRm9yIG11c3RhY2hlIHRhZ3MgdGhpcyBpc1xuICAgKiB3aGF0ZXZlciBlbHNlIHdhcyBpbnNpZGUgdGhlIHRhZyBiZXNpZGVzIHRoZSBvcGVuaW5nIHN5bWJvbC4gRm9yIHRleHQgdG9rZW5zXG4gICAqIHRoaXMgaXMgdGhlIHRleHQgaXRzZWxmLlxuICAgKlxuICAgKiBUaGUgdGhpcmQgYW5kIGZvdXJ0aCBlbGVtZW50cyBvZiB0aGUgdG9rZW4gYXJlIHRoZSBzdGFydCBhbmQgZW5kIGluZGljZXMsXG4gICAqIHJlc3BlY3RpdmVseSwgb2YgdGhlIHRva2VuIGluIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZS5cbiAgICpcbiAgICogVG9rZW5zIHRoYXQgYXJlIHRoZSByb290IG5vZGUgb2YgYSBzdWJ0cmVlIGNvbnRhaW4gdHdvIG1vcmUgZWxlbWVudHM6IDEpIGFuXG4gICAqIGFycmF5IG9mIHRva2VucyBpbiB0aGUgc3VidHJlZSBhbmQgMikgdGhlIGluZGV4IGluIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSBhdFxuICAgKiB3aGljaCB0aGUgY2xvc2luZyB0YWcgZm9yIHRoYXQgc2VjdGlvbiBiZWdpbnMuXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVRlbXBsYXRlICh0ZW1wbGF0ZSwgdGFncykge1xuICAgIGlmICghdGVtcGxhdGUpXG4gICAgICByZXR1cm4gW107XG5cbiAgICB2YXIgc2VjdGlvbnMgPSBbXTsgICAgIC8vIFN0YWNrIHRvIGhvbGQgc2VjdGlvbiB0b2tlbnNcbiAgICB2YXIgdG9rZW5zID0gW107ICAgICAgIC8vIEJ1ZmZlciB0byBob2xkIHRoZSB0b2tlbnNcbiAgICB2YXIgc3BhY2VzID0gW107ICAgICAgIC8vIEluZGljZXMgb2Ygd2hpdGVzcGFjZSB0b2tlbnMgb24gdGhlIGN1cnJlbnQgbGluZVxuICAgIHZhciBoYXNUYWcgPSBmYWxzZTsgICAgLy8gSXMgdGhlcmUgYSB7e3RhZ319IG9uIHRoZSBjdXJyZW50IGxpbmU/XG4gICAgdmFyIG5vblNwYWNlID0gZmFsc2U7ICAvLyBJcyB0aGVyZSBhIG5vbi1zcGFjZSBjaGFyIG9uIHRoZSBjdXJyZW50IGxpbmU/XG5cbiAgICAvLyBTdHJpcHMgYWxsIHdoaXRlc3BhY2UgdG9rZW5zIGFycmF5IGZvciB0aGUgY3VycmVudCBsaW5lXG4gICAgLy8gaWYgdGhlcmUgd2FzIGEge3sjdGFnfX0gb24gaXQgYW5kIG90aGVyd2lzZSBvbmx5IHNwYWNlLlxuICAgIGZ1bmN0aW9uIHN0cmlwU3BhY2UgKCkge1xuICAgICAgaWYgKGhhc1RhZyAmJiAhbm9uU3BhY2UpIHtcbiAgICAgICAgd2hpbGUgKHNwYWNlcy5sZW5ndGgpXG4gICAgICAgICAgZGVsZXRlIHRva2Vuc1tzcGFjZXMucG9wKCldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BhY2VzID0gW107XG4gICAgICB9XG5cbiAgICAgIGhhc1RhZyA9IGZhbHNlO1xuICAgICAgbm9uU3BhY2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgb3BlbmluZ1RhZ1JlLCBjbG9zaW5nVGFnUmUsIGNsb3NpbmdDdXJseVJlO1xuICAgIGZ1bmN0aW9uIGNvbXBpbGVUYWdzICh0YWdzVG9Db21waWxlKSB7XG4gICAgICBpZiAodHlwZW9mIHRhZ3NUb0NvbXBpbGUgPT09ICdzdHJpbmcnKVxuICAgICAgICB0YWdzVG9Db21waWxlID0gdGFnc1RvQ29tcGlsZS5zcGxpdChzcGFjZVJlLCAyKTtcblxuICAgICAgaWYgKCFpc0FycmF5KHRhZ3NUb0NvbXBpbGUpIHx8IHRhZ3NUb0NvbXBpbGUubGVuZ3RoICE9PSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGFnczogJyArIHRhZ3NUb0NvbXBpbGUpO1xuXG4gICAgICBvcGVuaW5nVGFnUmUgPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cCh0YWdzVG9Db21waWxlWzBdKSArICdcXFxccyonKTtcbiAgICAgIGNsb3NpbmdUYWdSZSA9IG5ldyBSZWdFeHAoJ1xcXFxzKicgKyBlc2NhcGVSZWdFeHAodGFnc1RvQ29tcGlsZVsxXSkpO1xuICAgICAgY2xvc2luZ0N1cmx5UmUgPSBuZXcgUmVnRXhwKCdcXFxccyonICsgZXNjYXBlUmVnRXhwKCd9JyArIHRhZ3NUb0NvbXBpbGVbMV0pKTtcbiAgICB9XG5cbiAgICBjb21waWxlVGFncyh0YWdzIHx8IG11c3RhY2hlLnRhZ3MpO1xuXG4gICAgdmFyIHNjYW5uZXIgPSBuZXcgU2Nhbm5lcih0ZW1wbGF0ZSk7XG5cbiAgICB2YXIgc3RhcnQsIHR5cGUsIHZhbHVlLCBjaHIsIHRva2VuLCBvcGVuU2VjdGlvbjtcbiAgICB3aGlsZSAoIXNjYW5uZXIuZW9zKCkpIHtcbiAgICAgIHN0YXJ0ID0gc2Nhbm5lci5wb3M7XG5cbiAgICAgIC8vIE1hdGNoIGFueSB0ZXh0IGJldHdlZW4gdGFncy5cbiAgICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwob3BlbmluZ1RhZ1JlKTtcblxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCB2YWx1ZUxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaSA8IHZhbHVlTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjaHIgPSB2YWx1ZS5jaGFyQXQoaSk7XG5cbiAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGNocikpIHtcbiAgICAgICAgICAgIHNwYWNlcy5wdXNoKHRva2Vucy5sZW5ndGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub25TcGFjZSA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9rZW5zLnB1c2goWyAndGV4dCcsIGNociwgc3RhcnQsIHN0YXJ0ICsgMSBdKTtcbiAgICAgICAgICBzdGFydCArPSAxO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIHdoaXRlc3BhY2Ugb24gdGhlIGN1cnJlbnQgbGluZS5cbiAgICAgICAgICBpZiAoY2hyID09PSAnXFxuJylcbiAgICAgICAgICAgIHN0cmlwU3BhY2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBNYXRjaCB0aGUgb3BlbmluZyB0YWcuXG4gICAgICBpZiAoIXNjYW5uZXIuc2NhbihvcGVuaW5nVGFnUmUpKVxuICAgICAgICBicmVhaztcblxuICAgICAgaGFzVGFnID0gdHJ1ZTtcblxuICAgICAgLy8gR2V0IHRoZSB0YWcgdHlwZS5cbiAgICAgIHR5cGUgPSBzY2FubmVyLnNjYW4odGFnUmUpIHx8ICduYW1lJztcbiAgICAgIHNjYW5uZXIuc2Nhbih3aGl0ZVJlKTtcblxuICAgICAgLy8gR2V0IHRoZSB0YWcgdmFsdWUuXG4gICAgICBpZiAodHlwZSA9PT0gJz0nKSB7XG4gICAgICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwoZXF1YWxzUmUpO1xuICAgICAgICBzY2FubmVyLnNjYW4oZXF1YWxzUmUpO1xuICAgICAgICBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nVGFnUmUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAneycpIHtcbiAgICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nQ3VybHlSZSk7XG4gICAgICAgIHNjYW5uZXIuc2NhbihjdXJseVJlKTtcbiAgICAgICAgc2Nhbm5lci5zY2FuVW50aWwoY2xvc2luZ1RhZ1JlKTtcbiAgICAgICAgdHlwZSA9ICcmJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwoY2xvc2luZ1RhZ1JlKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWF0Y2ggdGhlIGNsb3NpbmcgdGFnLlxuICAgICAgaWYgKCFzY2FubmVyLnNjYW4oY2xvc2luZ1RhZ1JlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmNsb3NlZCB0YWcgYXQgJyArIHNjYW5uZXIucG9zKTtcblxuICAgICAgdG9rZW4gPSBbIHR5cGUsIHZhbHVlLCBzdGFydCwgc2Nhbm5lci5wb3MgXTtcbiAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcblxuICAgICAgaWYgKHR5cGUgPT09ICcjJyB8fCB0eXBlID09PSAnXicpIHtcbiAgICAgICAgc2VjdGlvbnMucHVzaCh0b2tlbik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICcvJykge1xuICAgICAgICAvLyBDaGVjayBzZWN0aW9uIG5lc3RpbmcuXG4gICAgICAgIG9wZW5TZWN0aW9uID0gc2VjdGlvbnMucG9wKCk7XG5cbiAgICAgICAgaWYgKCFvcGVuU2VjdGlvbilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vub3BlbmVkIHNlY3Rpb24gXCInICsgdmFsdWUgKyAnXCIgYXQgJyArIHN0YXJ0KTtcblxuICAgICAgICBpZiAob3BlblNlY3Rpb25bMV0gIT09IHZhbHVlKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5jbG9zZWQgc2VjdGlvbiBcIicgKyBvcGVuU2VjdGlvblsxXSArICdcIiBhdCAnICsgc3RhcnQpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbmFtZScgfHwgdHlwZSA9PT0gJ3snIHx8IHR5cGUgPT09ICcmJykge1xuICAgICAgICBub25TcGFjZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICc9Jykge1xuICAgICAgICAvLyBTZXQgdGhlIHRhZ3MgZm9yIHRoZSBuZXh0IHRpbWUgYXJvdW5kLlxuICAgICAgICBjb21waWxlVGFncyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoZXJlIGFyZSBubyBvcGVuIHNlY3Rpb25zIHdoZW4gd2UncmUgZG9uZS5cbiAgICBvcGVuU2VjdGlvbiA9IHNlY3Rpb25zLnBvcCgpO1xuXG4gICAgaWYgKG9wZW5TZWN0aW9uKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmNsb3NlZCBzZWN0aW9uIFwiJyArIG9wZW5TZWN0aW9uWzFdICsgJ1wiIGF0ICcgKyBzY2FubmVyLnBvcyk7XG5cbiAgICByZXR1cm4gbmVzdFRva2VucyhzcXVhc2hUb2tlbnModG9rZW5zKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tYmluZXMgdGhlIHZhbHVlcyBvZiBjb25zZWN1dGl2ZSB0ZXh0IHRva2VucyBpbiB0aGUgZ2l2ZW4gYHRva2Vuc2AgYXJyYXlcbiAgICogdG8gYSBzaW5nbGUgdG9rZW4uXG4gICAqL1xuICBmdW5jdGlvbiBzcXVhc2hUb2tlbnMgKHRva2Vucykge1xuICAgIHZhciBzcXVhc2hlZFRva2VucyA9IFtdO1xuXG4gICAgdmFyIHRva2VuLCBsYXN0VG9rZW47XG4gICAgZm9yICh2YXIgaSA9IDAsIG51bVRva2VucyA9IHRva2Vucy5sZW5ndGg7IGkgPCBudW1Ub2tlbnM7ICsraSkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIGlmICh0b2tlbikge1xuICAgICAgICBpZiAodG9rZW5bMF0gPT09ICd0ZXh0JyAmJiBsYXN0VG9rZW4gJiYgbGFzdFRva2VuWzBdID09PSAndGV4dCcpIHtcbiAgICAgICAgICBsYXN0VG9rZW5bMV0gKz0gdG9rZW5bMV07XG4gICAgICAgICAgbGFzdFRva2VuWzNdID0gdG9rZW5bM107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3F1YXNoZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgbGFzdFRva2VuID0gdG9rZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3F1YXNoZWRUb2tlbnM7XG4gIH1cblxuICAvKipcbiAgICogRm9ybXMgdGhlIGdpdmVuIGFycmF5IG9mIGB0b2tlbnNgIGludG8gYSBuZXN0ZWQgdHJlZSBzdHJ1Y3R1cmUgd2hlcmVcbiAgICogdG9rZW5zIHRoYXQgcmVwcmVzZW50IGEgc2VjdGlvbiBoYXZlIHR3byBhZGRpdGlvbmFsIGl0ZW1zOiAxKSBhbiBhcnJheSBvZlxuICAgKiBhbGwgdG9rZW5zIHRoYXQgYXBwZWFyIGluIHRoYXQgc2VjdGlvbiBhbmQgMikgdGhlIGluZGV4IGluIHRoZSBvcmlnaW5hbFxuICAgKiB0ZW1wbGF0ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGVuZCBvZiB0aGF0IHNlY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBuZXN0VG9rZW5zICh0b2tlbnMpIHtcbiAgICB2YXIgbmVzdGVkVG9rZW5zID0gW107XG4gICAgdmFyIGNvbGxlY3RvciA9IG5lc3RlZFRva2VucztcbiAgICB2YXIgc2VjdGlvbnMgPSBbXTtcblxuICAgIHZhciB0b2tlbiwgc2VjdGlvbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbnVtVG9rZW5zID0gdG9rZW5zLmxlbmd0aDsgaSA8IG51bVRva2VuczsgKytpKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgc3dpdGNoICh0b2tlblswXSkge1xuICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgY29sbGVjdG9yLnB1c2godG9rZW4pO1xuICAgICAgICAgIHNlY3Rpb25zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbGxlY3RvciA9IHRva2VuWzRdID0gW107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgIHNlY3Rpb24gPSBzZWN0aW9ucy5wb3AoKTtcbiAgICAgICAgICBzZWN0aW9uWzVdID0gdG9rZW5bMl07XG4gICAgICAgICAgY29sbGVjdG9yID0gc2VjdGlvbnMubGVuZ3RoID4gMCA/IHNlY3Rpb25zW3NlY3Rpb25zLmxlbmd0aCAtIDFdWzRdIDogbmVzdGVkVG9rZW5zO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbGxlY3Rvci5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmVzdGVkVG9rZW5zO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2ltcGxlIHN0cmluZyBzY2FubmVyIHRoYXQgaXMgdXNlZCBieSB0aGUgdGVtcGxhdGUgcGFyc2VyIHRvIGZpbmRcbiAgICogdG9rZW5zIGluIHRlbXBsYXRlIHN0cmluZ3MuXG4gICAqL1xuICBmdW5jdGlvbiBTY2FubmVyIChzdHJpbmcpIHtcbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB0aGlzLnRhaWwgPSBzdHJpbmc7XG4gICAgdGhpcy5wb3MgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSB0YWlsIGlzIGVtcHR5IChlbmQgb2Ygc3RyaW5nKS5cbiAgICovXG4gIFNjYW5uZXIucHJvdG90eXBlLmVvcyA9IGZ1bmN0aW9uIGVvcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFpbCA9PT0gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWVzIHRvIG1hdGNoIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAqIFJldHVybnMgdGhlIG1hdGNoZWQgdGV4dCBpZiBpdCBjYW4gbWF0Y2gsIHRoZSBlbXB0eSBzdHJpbmcgb3RoZXJ3aXNlLlxuICAgKi9cbiAgU2Nhbm5lci5wcm90b3R5cGUuc2NhbiA9IGZ1bmN0aW9uIHNjYW4gKHJlKSB7XG4gICAgdmFyIG1hdGNoID0gdGhpcy50YWlsLm1hdGNoKHJlKTtcblxuICAgIGlmICghbWF0Y2ggfHwgbWF0Y2guaW5kZXggIT09IDApXG4gICAgICByZXR1cm4gJyc7XG5cbiAgICB2YXIgc3RyaW5nID0gbWF0Y2hbMF07XG5cbiAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwuc3Vic3RyaW5nKHN0cmluZy5sZW5ndGgpO1xuICAgIHRoaXMucG9zICs9IHN0cmluZy5sZW5ndGg7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTa2lwcyBhbGwgdGV4dCB1bnRpbCB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uIGNhbiBiZSBtYXRjaGVkLiBSZXR1cm5zXG4gICAqIHRoZSBza2lwcGVkIHN0cmluZywgd2hpY2ggaXMgdGhlIGVudGlyZSB0YWlsIGlmIG5vIG1hdGNoIGNhbiBiZSBtYWRlLlxuICAgKi9cbiAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblVudGlsID0gZnVuY3Rpb24gc2NhblVudGlsIChyZSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMudGFpbC5zZWFyY2gocmUpLCBtYXRjaDtcblxuICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgIGNhc2UgLTE6XG4gICAgICAgIG1hdGNoID0gdGhpcy50YWlsO1xuICAgICAgICB0aGlzLnRhaWwgPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIG1hdGNoID0gJyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbWF0Y2ggPSB0aGlzLnRhaWwuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgdGhpcy50YWlsID0gdGhpcy50YWlsLnN1YnN0cmluZyhpbmRleCk7XG4gICAgfVxuXG4gICAgdGhpcy5wb3MgKz0gbWF0Y2gubGVuZ3RoO1xuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgcmVuZGVyaW5nIGNvbnRleHQgYnkgd3JhcHBpbmcgYSB2aWV3IG9iamVjdCBhbmRcbiAgICogbWFpbnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBjb250ZXh0LlxuICAgKi9cbiAgZnVuY3Rpb24gQ29udGV4dCAodmlldywgcGFyZW50Q29udGV4dCkge1xuICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgdGhpcy5jYWNoZSA9IHsgJy4nOiB0aGlzLnZpZXcgfTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudENvbnRleHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBjb250ZXh0IHVzaW5nIHRoZSBnaXZlbiB2aWV3IHdpdGggdGhpcyBjb250ZXh0XG4gICAqIGFzIHRoZSBwYXJlbnQuXG4gICAqL1xuICBDb250ZXh0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAodmlldykge1xuICAgIHJldHVybiBuZXcgQ29udGV4dCh2aWV3LCB0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIG5hbWUgaW4gdGhpcyBjb250ZXh0LCB0cmF2ZXJzaW5nXG4gICAqIHVwIHRoZSBjb250ZXh0IGhpZXJhcmNoeSBpZiB0aGUgdmFsdWUgaXMgYWJzZW50IGluIHRoaXMgY29udGV4dCdzIHZpZXcuXG4gICAqL1xuICBDb250ZXh0LnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbiBsb29rdXAgKG5hbWUpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXG4gICAgdmFyIHZhbHVlO1xuICAgIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgdmFsdWUgPSBjYWNoZVtuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLCBuYW1lcywgaW5kZXgsIGxvb2t1cEhpdCA9IGZhbHNlO1xuXG4gICAgICB3aGlsZSAoY29udGV4dCkge1xuICAgICAgICBpZiAobmFtZS5pbmRleE9mKCcuJykgPiAwKSB7XG4gICAgICAgICAgdmFsdWUgPSBjb250ZXh0LnZpZXc7XG4gICAgICAgICAgbmFtZXMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgICAgaW5kZXggPSAwO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVXNpbmcgdGhlIGRvdCBub3Rpb24gcGF0aCBpbiBgbmFtZWAsIHdlIGRlc2NlbmQgdGhyb3VnaCB0aGVcbiAgICAgICAgICAgKiBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFRvIGJlIGNlcnRhaW4gdGhhdCB0aGUgbG9va3VwIGhhcyBiZWVuIHN1Y2Nlc3NmdWwsIHdlIGhhdmUgdG9cbiAgICAgICAgICAgKiBjaGVjayBpZiB0aGUgbGFzdCBvYmplY3QgaW4gdGhlIHBhdGggYWN0dWFsbHkgaGFzIHRoZSBwcm9wZXJ0eVxuICAgICAgICAgICAqIHdlIGFyZSBsb29raW5nIGZvci4gV2Ugc3RvcmUgdGhlIHJlc3VsdCBpbiBgbG9va3VwSGl0YC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFRoaXMgaXMgc3BlY2lhbGx5IG5lY2Vzc2FyeSBmb3Igd2hlbiB0aGUgdmFsdWUgaGFzIGJlZW4gc2V0IHRvXG4gICAgICAgICAgICogYHVuZGVmaW5lZGAgYW5kIHdlIHdhbnQgdG8gYXZvaWQgbG9va2luZyB1cCBwYXJlbnQgY29udGV4dHMuXG4gICAgICAgICAgICoqL1xuICAgICAgICAgIHdoaWxlICh2YWx1ZSAhPSBudWxsICYmIGluZGV4IDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IG5hbWVzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgIGxvb2t1cEhpdCA9IGhhc1Byb3BlcnR5KHZhbHVlLCBuYW1lc1tpbmRleF0pO1xuXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlW25hbWVzW2luZGV4KytdXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBjb250ZXh0LnZpZXdbbmFtZV07XG4gICAgICAgICAgbG9va3VwSGl0ID0gaGFzUHJvcGVydHkoY29udGV4dC52aWV3LCBuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb29rdXBIaXQpXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQucGFyZW50O1xuICAgICAgfVxuXG4gICAgICBjYWNoZVtuYW1lXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSlcbiAgICAgIHZhbHVlID0gdmFsdWUuY2FsbCh0aGlzLnZpZXcpO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIFdyaXRlciBrbm93cyBob3cgdG8gdGFrZSBhIHN0cmVhbSBvZiB0b2tlbnMgYW5kIHJlbmRlciB0aGVtIHRvIGFcbiAgICogc3RyaW5nLCBnaXZlbiBhIGNvbnRleHQuIEl0IGFsc28gbWFpbnRhaW5zIGEgY2FjaGUgb2YgdGVtcGxhdGVzIHRvXG4gICAqIGF2b2lkIHRoZSBuZWVkIHRvIHBhcnNlIHRoZSBzYW1lIHRlbXBsYXRlIHR3aWNlLlxuICAgKi9cbiAgZnVuY3Rpb24gV3JpdGVyICgpIHtcbiAgICB0aGlzLmNhY2hlID0ge307XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIGFsbCBjYWNoZWQgdGVtcGxhdGVzIGluIHRoaXMgd3JpdGVyLlxuICAgKi9cbiAgV3JpdGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IHt9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW5kIGNhY2hlcyB0aGUgZ2l2ZW4gYHRlbXBsYXRlYCBhbmQgcmV0dXJucyB0aGUgYXJyYXkgb2YgdG9rZW5zXG4gICAqIHRoYXQgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIHBhcnNlLlxuICAgKi9cbiAgV3JpdGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlICh0ZW1wbGF0ZSwgdGFncykge1xuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGU7XG4gICAgdmFyIHRva2VucyA9IGNhY2hlW3RlbXBsYXRlXTtcblxuICAgIGlmICh0b2tlbnMgPT0gbnVsbClcbiAgICAgIHRva2VucyA9IGNhY2hlW3RlbXBsYXRlXSA9IHBhcnNlVGVtcGxhdGUodGVtcGxhdGUsIHRhZ3MpO1xuXG4gICAgcmV0dXJuIHRva2VucztcbiAgfTtcblxuICAvKipcbiAgICogSGlnaC1sZXZlbCBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIHJlbmRlciB0aGUgZ2l2ZW4gYHRlbXBsYXRlYCB3aXRoXG4gICAqIHRoZSBnaXZlbiBgdmlld2AuXG4gICAqXG4gICAqIFRoZSBvcHRpb25hbCBgcGFydGlhbHNgIGFyZ3VtZW50IG1heSBiZSBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGVcbiAgICogbmFtZXMgYW5kIHRlbXBsYXRlcyBvZiBwYXJ0aWFscyB0aGF0IGFyZSB1c2VkIGluIHRoZSB0ZW1wbGF0ZS4gSXQgbWF5XG4gICAqIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gbG9hZCBwYXJ0aWFsIHRlbXBsYXRlcyBvbiB0aGUgZmx5XG4gICAqIHRoYXQgdGFrZXMgYSBzaW5nbGUgYXJndW1lbnQ6IHRoZSBuYW1lIG9mIHRoZSBwYXJ0aWFsLlxuICAgKi9cbiAgV3JpdGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscykge1xuICAgIHZhciB0b2tlbnMgPSB0aGlzLnBhcnNlKHRlbXBsYXRlKTtcbiAgICB2YXIgY29udGV4dCA9ICh2aWV3IGluc3RhbmNlb2YgQ29udGV4dCkgPyB2aWV3IDogbmV3IENvbnRleHQodmlldyk7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVG9rZW5zKHRva2VucywgY29udGV4dCwgcGFydGlhbHMsIHRlbXBsYXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogTG93LWxldmVsIG1ldGhvZCB0aGF0IHJlbmRlcnMgdGhlIGdpdmVuIGFycmF5IG9mIGB0b2tlbnNgIHVzaW5nXG4gICAqIHRoZSBnaXZlbiBgY29udGV4dGAgYW5kIGBwYXJ0aWFsc2AuXG4gICAqXG4gICAqIE5vdGU6IFRoZSBgb3JpZ2luYWxUZW1wbGF0ZWAgaXMgb25seSBldmVyIHVzZWQgdG8gZXh0cmFjdCB0aGUgcG9ydGlvblxuICAgKiBvZiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgdGhhdCB3YXMgY29udGFpbmVkIGluIGEgaGlnaGVyLW9yZGVyIHNlY3Rpb24uXG4gICAqIElmIHRoZSB0ZW1wbGF0ZSBkb2Vzbid0IHVzZSBoaWdoZXItb3JkZXIgc2VjdGlvbnMsIHRoaXMgYXJndW1lbnQgbWF5XG4gICAqIGJlIG9taXR0ZWQuXG4gICAqL1xuICBXcml0ZXIucHJvdG90eXBlLnJlbmRlclRva2VucyA9IGZ1bmN0aW9uIHJlbmRlclRva2VucyAodG9rZW5zLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSkge1xuICAgIHZhciBidWZmZXIgPSAnJztcblxuICAgIHZhciB0b2tlbiwgc3ltYm9sLCB2YWx1ZTtcbiAgICBmb3IgKHZhciBpID0gMCwgbnVtVG9rZW5zID0gdG9rZW5zLmxlbmd0aDsgaSA8IG51bVRva2VuczsgKytpKSB7XG4gICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgc3ltYm9sID0gdG9rZW5bMF07XG5cbiAgICAgIGlmIChzeW1ib2wgPT09ICcjJykgdmFsdWUgPSB0aGlzLnJlbmRlclNlY3Rpb24odG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJ14nKSB2YWx1ZSA9IHRoaXMucmVuZGVySW52ZXJ0ZWQodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJz4nKSB2YWx1ZSA9IHRoaXMucmVuZGVyUGFydGlhbCh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAnJicpIHZhbHVlID0gdGhpcy51bmVzY2FwZWRWYWx1ZSh0b2tlbiwgY29udGV4dCk7XG4gICAgICBlbHNlIGlmIChzeW1ib2wgPT09ICduYW1lJykgdmFsdWUgPSB0aGlzLmVzY2FwZWRWYWx1ZSh0b2tlbiwgY29udGV4dCk7XG4gICAgICBlbHNlIGlmIChzeW1ib2wgPT09ICd0ZXh0JykgdmFsdWUgPSB0aGlzLnJhd1ZhbHVlKHRva2VuKTtcblxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGJ1ZmZlciArPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVyU2VjdGlvbiA9IGZ1bmN0aW9uIHJlbmRlclNlY3Rpb24gKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYnVmZmVyID0gJyc7XG4gICAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHJlbmRlciBhbiBhcmJpdHJhcnkgdGVtcGxhdGVcbiAgICAvLyBpbiB0aGUgY3VycmVudCBjb250ZXh0IGJ5IGhpZ2hlci1vcmRlciBzZWN0aW9ucy5cbiAgICBmdW5jdGlvbiBzdWJSZW5kZXIgKHRlbXBsYXRlKSB7XG4gICAgICByZXR1cm4gc2VsZi5yZW5kZXIodGVtcGxhdGUsIGNvbnRleHQsIHBhcnRpYWxzKTtcbiAgICB9XG5cbiAgICBpZiAoIXZhbHVlKSByZXR1cm47XG5cbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGZvciAodmFyIGogPSAwLCB2YWx1ZUxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaiA8IHZhbHVlTGVuZ3RoOyArK2opIHtcbiAgICAgICAgYnVmZmVyICs9IHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LnB1c2godmFsdWVbal0pLCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgYnVmZmVyICs9IHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LnB1c2godmFsdWUpLCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbFRlbXBsYXRlICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIGhpZ2hlci1vcmRlciBzZWN0aW9ucyB3aXRob3V0IHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZScpO1xuXG4gICAgICAvLyBFeHRyYWN0IHRoZSBwb3J0aW9uIG9mIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSB0aGF0IHRoZSBzZWN0aW9uIGNvbnRhaW5zLlxuICAgICAgdmFsdWUgPSB2YWx1ZS5jYWxsKGNvbnRleHQudmlldywgb3JpZ2luYWxUZW1wbGF0ZS5zbGljZSh0b2tlblszXSwgdG9rZW5bNV0pLCBzdWJSZW5kZXIpO1xuXG4gICAgICBpZiAodmFsdWUgIT0gbnVsbClcbiAgICAgICAgYnVmZmVyICs9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIgKz0gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfTtcblxuICBXcml0ZXIucHJvdG90eXBlLnJlbmRlckludmVydGVkID0gZnVuY3Rpb24gcmVuZGVySW52ZXJ0ZWQgKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSkge1xuICAgIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcblxuICAgIC8vIFVzZSBKYXZhU2NyaXB0J3MgZGVmaW5pdGlvbiBvZiBmYWxzeS4gSW5jbHVkZSBlbXB0eSBhcnJheXMuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzL2lzc3Vlcy8xODZcbiAgICBpZiAoIXZhbHVlIHx8IChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApKVxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJQYXJ0aWFsID0gZnVuY3Rpb24gcmVuZGVyUGFydGlhbCAodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzKSB7XG4gICAgaWYgKCFwYXJ0aWFscykgcmV0dXJuO1xuXG4gICAgdmFyIHZhbHVlID0gaXNGdW5jdGlvbihwYXJ0aWFscykgPyBwYXJ0aWFscyh0b2tlblsxXSkgOiBwYXJ0aWFsc1t0b2tlblsxXV07XG4gICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJUb2tlbnModGhpcy5wYXJzZSh2YWx1ZSksIGNvbnRleHQsIHBhcnRpYWxzLCB2YWx1ZSk7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS51bmVzY2FwZWRWYWx1ZSA9IGZ1bmN0aW9uIHVuZXNjYXBlZFZhbHVlICh0b2tlbiwgY29udGV4dCkge1xuICAgIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbClcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBXcml0ZXIucHJvdG90eXBlLmVzY2FwZWRWYWx1ZSA9IGZ1bmN0aW9uIGVzY2FwZWRWYWx1ZSAodG9rZW4sIGNvbnRleHQpIHtcbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICByZXR1cm4gbXVzdGFjaGUuZXNjYXBlKHZhbHVlKTtcbiAgfTtcblxuICBXcml0ZXIucHJvdG90eXBlLnJhd1ZhbHVlID0gZnVuY3Rpb24gcmF3VmFsdWUgKHRva2VuKSB7XG4gICAgcmV0dXJuIHRva2VuWzFdO1xuICB9O1xuXG4gIG11c3RhY2hlLm5hbWUgPSAnbXVzdGFjaGUuanMnO1xuICBtdXN0YWNoZS52ZXJzaW9uID0gJzIuMy4wJztcbiAgbXVzdGFjaGUudGFncyA9IFsgJ3t7JywgJ319JyBdO1xuXG4gIC8vIEFsbCBoaWdoLWxldmVsIG11c3RhY2hlLiogZnVuY3Rpb25zIHVzZSB0aGlzIHdyaXRlci5cbiAgdmFyIGRlZmF1bHRXcml0ZXIgPSBuZXcgV3JpdGVyKCk7XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgY2FjaGVkIHRlbXBsYXRlcyBpbiB0aGUgZGVmYXVsdCB3cml0ZXIuXG4gICAqL1xuICBtdXN0YWNoZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSAoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRXcml0ZXIuY2xlYXJDYWNoZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW5kIGNhY2hlcyB0aGUgZ2l2ZW4gdGVtcGxhdGUgaW4gdGhlIGRlZmF1bHQgd3JpdGVyIGFuZCByZXR1cm5zIHRoZVxuICAgKiBhcnJheSBvZiB0b2tlbnMgaXQgY29udGFpbnMuIERvaW5nIHRoaXMgYWhlYWQgb2YgdGltZSBhdm9pZHMgdGhlIG5lZWQgdG9cbiAgICogcGFyc2UgdGVtcGxhdGVzIG9uIHRoZSBmbHkgYXMgdGhleSBhcmUgcmVuZGVyZWQuXG4gICAqL1xuICBtdXN0YWNoZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlICh0ZW1wbGF0ZSwgdGFncykge1xuICAgIHJldHVybiBkZWZhdWx0V3JpdGVyLnBhcnNlKHRlbXBsYXRlLCB0YWdzKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgYHRlbXBsYXRlYCB3aXRoIHRoZSBnaXZlbiBgdmlld2AgYW5kIGBwYXJ0aWFsc2AgdXNpbmcgdGhlXG4gICAqIGRlZmF1bHQgd3JpdGVyLlxuICAgKi9cbiAgbXVzdGFjaGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICh0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpIHtcbiAgICBpZiAodHlwZW9mIHRlbXBsYXRlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0ZW1wbGF0ZSEgVGVtcGxhdGUgc2hvdWxkIGJlIGEgXCJzdHJpbmdcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2J1dCBcIicgKyB0eXBlU3RyKHRlbXBsYXRlKSArICdcIiB3YXMgZ2l2ZW4gYXMgdGhlIGZpcnN0ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYXJndW1lbnQgZm9yIG11c3RhY2hlI3JlbmRlcih0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRXcml0ZXIucmVuZGVyKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscyk7XG4gIH07XG5cbiAgLy8gVGhpcyBpcyBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIDAuNC54LixcbiAgLyplc2xpbnQtZGlzYWJsZSAqLyAvLyBlc2xpbnQgd2FudHMgY2FtZWwgY2FzZWQgZnVuY3Rpb24gbmFtZVxuICBtdXN0YWNoZS50b19odG1sID0gZnVuY3Rpb24gdG9faHRtbCAodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzLCBzZW5kKSB7XG4gICAgLyplc2xpbnQtZW5hYmxlKi9cblxuICAgIHZhciByZXN1bHQgPSBtdXN0YWNoZS5yZW5kZXIodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKHNlbmQpKSB7XG4gICAgICBzZW5kKHJlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgZXNjYXBpbmcgZnVuY3Rpb24gc28gdGhhdCB0aGUgdXNlciBtYXkgb3ZlcnJpZGUgaXQuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qcy9pc3N1ZXMvMjQ0XG4gIG11c3RhY2hlLmVzY2FwZSA9IGVzY2FwZUh0bWw7XG5cbiAgLy8gRXhwb3J0IHRoZXNlIG1haW5seSBmb3IgdGVzdGluZywgYnV0IGFsc28gZm9yIGFkdmFuY2VkIHVzYWdlLlxuICBtdXN0YWNoZS5TY2FubmVyID0gU2Nhbm5lcjtcbiAgbXVzdGFjaGUuQ29udGV4dCA9IENvbnRleHQ7XG4gIG11c3RhY2hlLldyaXRlciA9IFdyaXRlcjtcblxuICByZXR1cm4gbXVzdGFjaGU7XG59KSk7XG4iLCIvKiBvYmplY3QtaXRlcmF0b3JzLmpzIC0gTWluaSBVbmRlcnNjb3JlIGxpYnJhcnlcbiAqIGJ5IEpvbmF0aGFuIEVpdGVuXG4gKlxuICogVGhlIG1ldGhvZHMgYmVsb3cgb3BlcmF0ZSBvbiBvYmplY3RzIChidXQgbm90IGFycmF5cykgc2ltaWxhcmx5XG4gKiB0byBVbmRlcnNjb3JlIChodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jY29sbGVjdGlvbnMpLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2pvbmVpdC9vYmplY3QtaXRlcmF0b3JzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHN1bW1hcnkgV3JhcCBhbiBvYmplY3QgZm9yIG9uZSBtZXRob2QgY2FsbC5cbiAqIEBEZXNjIE5vdGUgdGhhdCB0aGUgYG5ld2Aga2V5d29yZCBpcyBub3QgbmVjZXNzYXJ5LlxuICogQHBhcmFtIHtvYmplY3R8bnVsbHx1bmRlZmluZWR9IG9iamVjdCAtIGBudWxsYCBvciBgdW5kZWZpbmVkYCBpcyB0cmVhdGVkIGFzIGFuIGVtcHR5IHBsYWluIG9iamVjdC5cbiAqIEByZXR1cm4ge1dyYXBwZXJ9IFRoZSB3cmFwcGVkIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gV3JhcHBlcihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgV3JhcHBlcikge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JhcHBlcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXcmFwcGVyKG9iamVjdCk7XG4gICAgfVxuICAgIHRoaXMub3JpZ2luYWxWYWx1ZSA9IG9iamVjdDtcbiAgICB0aGlzLm8gPSBvYmplY3QgfHwge307XG59XG5cbi8qKlxuICogQG5hbWUgV3JhcHBlci5jaGFpblxuICogQHN1bW1hcnkgV3JhcCBhbiBvYmplY3QgZm9yIGEgY2hhaW4gb2YgbWV0aG9kIGNhbGxzLlxuICogQERlc2MgQ2FsbHMgdGhlIGNvbnN0cnVjdG9yIGBXcmFwcGVyKClgIGFuZCBtb2RpZmllcyB0aGUgd3JhcHBlciBmb3IgY2hhaW5pbmcuXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtXcmFwcGVyfSBUaGUgd3JhcHBlZCBvYmplY3QuXG4gKi9cbldyYXBwZXIuY2hhaW4gPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIHdyYXBwZWQgPSBXcmFwcGVyKG9iamVjdCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuICAgIHdyYXBwZWQuY2hhaW5pbmcgPSB0cnVlO1xuICAgIHJldHVybiB3cmFwcGVkO1xufTtcblxuV3JhcHBlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogVW53cmFwIGFuIG9iamVjdCB3cmFwcGVkIHdpdGgge0BsaW5rIFdyYXBwZXIuY2hhaW58V3JhcHBlci5jaGFpbigpfS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R8bnVsbHx1bmRlZmluZWR9IFRoZSB2YWx1ZSBvcmlnaW5hbGx5IHdyYXBwZWQgYnkgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqIEBtZW1iZXJPZiBXcmFwcGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsVmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIE1pbWljcyBVbmRlcnNjb3JlJ3MgW2VhY2hdKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNlYWNoKSBtZXRob2Q6IEl0ZXJhdGUgb3ZlciB0aGUgbWVtYmVycyBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIGNhbGxpbmcgYGl0ZXJhdGVlKClgIHdpdGggZWFjaC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSAtIEZvciBlYWNoIG1lbWJlciBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggdGhyZWUgYXJndW1lbnRzOiBgKHZhbHVlLCBrZXksIG9iamVjdClgLiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgZnVuY3Rpb24gaXMgdW5kZWZpbmVkOyBhbiBgLmVhY2hgIGxvb3AgY2Fubm90IGJlIGJyb2tlbiBvdXQgb2YgKHVzZSB7QGxpbmsgV3JhcHBlciNmaW5kfC5maW5kfSBpbnN0ZWFkKS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdIC0gSWYgZ2l2ZW4sIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gdGhpcyBvYmplY3QuIEluIG90aGVyIHdvcmRzLCB0aGlzIG9iamVjdCBiZWNvbWVzIHRoZSBgdGhpc2AgdmFsdWUgaW4gdGhlIGNhbGxzIHRvIGBpdGVyYXRlZWAuIChPdGhlcndpc2UsIHRoZSBgdGhpc2AgdmFsdWUgd2lsbCBiZSB0aGUgdW53cmFwcGVkIG9iamVjdC4pXG4gICAgICogQHJldHVybiB7V3JhcHBlcn0gVGhlIHdyYXBwZWQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICAgKiBAbWVtYmVyT2YgV3JhcHBlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBlYWNoOiBmdW5jdGlvbiAoaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaXRlcmF0ZWUuY2FsbCh0aGlzLCBvW2tleV0sIGtleSwgbyk7XG4gICAgICAgIH0sIGNvbnRleHQgfHwgbyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBNaW1pY3MgVW5kZXJzY29yZSdzIFtmaW5kXShodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jZmluZCkgbWV0aG9kOiBMb29rIHRocm91Z2ggZWFjaCBtZW1iZXIgb2YgdGhlIHdyYXBwZWQgb2JqZWN0LCByZXR1cm5pbmcgdGhlIGZpcnN0IG9uZSB0aGF0IHBhc3NlcyBhIHRydXRoIHRlc3QgKGBwcmVkaWNhdGVgKSwgb3IgYHVuZGVmaW5lZGAgaWYgbm8gdmFsdWUgcGFzc2VzIHRoZSB0ZXN0LiBUaGUgZnVuY3Rpb24gcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGFjY2VwdGFibGUgbWVtYmVyLCBhbmQgZG9lc24ndCBuZWNlc3NhcmlseSB0cmF2ZXJzZSB0aGUgZW50aXJlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcmVkaWNhdGUgLSBGb3IgZWFjaCBtZW1iZXIgb2YgdGhlIHdyYXBwZWQgb2JqZWN0LCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogYCh2YWx1ZSwga2V5LCBvYmplY3QpYC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSB0cnV0aHkgaWYgdGhlIG1lbWJlciBwYXNzZXMgdGhlIHRlc3QgYW5kIGZhbHN5IG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdIC0gSWYgZ2l2ZW4sIGBwcmVkaWNhdGVgIGlzIGJvdW5kIHRvIHRoaXMgb2JqZWN0LiBJbiBvdGhlciB3b3JkcywgdGhpcyBvYmplY3QgYmVjb21lcyB0aGUgYHRoaXNgIHZhbHVlIGluIHRoZSBjYWxscyB0byBgcHJlZGljYXRlYC4gKE90aGVyd2lzZSwgdGhlIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIHRoZSB1bndyYXBwZWQgb2JqZWN0LilcbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgZm91bmQgcHJvcGVydHkncyB2YWx1ZSwgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cbiAgICAgKiBAbWVtYmVyT2YgV3JhcHBlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBmaW5kOiBmdW5jdGlvbiAocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5vO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgcmVzdWx0ID0gT2JqZWN0LmtleXMobykuZmluZChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWRpY2F0ZS5jYWxsKHRoaXMsIG9ba2V5XSwga2V5LCBvKTtcbiAgICAgICAgICAgIH0sIGNvbnRleHQgfHwgbyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBvW3Jlc3VsdF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgTWltaWNzIFVuZGVyc2NvcmUncyBbZmlsdGVyXShodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jZmlsdGVyKSBtZXRob2Q6IExvb2sgdGhyb3VnaCBlYWNoIG1lbWJlciBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIHJldHVybmluZyB0aGUgdmFsdWVzIG9mIGFsbCBtZW1iZXJzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QgKGBwcmVkaWNhdGVgKSwgb3IgZW1wdHkgYXJyYXkgaWYgbm8gdmFsdWUgcGFzc2VzIHRoZSB0ZXN0LiBUaGUgZnVuY3Rpb24gYWx3YXlzIHRyYXZlcnNlcyB0aGUgZW50aXJlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcmVkaWNhdGUgLSBGb3IgZWFjaCBtZW1iZXIgb2YgdGhlIHdyYXBwZWQgb2JqZWN0LCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogYCh2YWx1ZSwga2V5LCBvYmplY3QpYC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSB0cnV0aHkgaWYgdGhlIG1lbWJlciBwYXNzZXMgdGhlIHRlc3QgYW5kIGZhbHN5IG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdIC0gSWYgZ2l2ZW4sIGBwcmVkaWNhdGVgIGlzIGJvdW5kIHRvIHRoaXMgb2JqZWN0LiBJbiBvdGhlciB3b3JkcywgdGhpcyBvYmplY3QgYmVjb21lcyB0aGUgYHRoaXNgIHZhbHVlIGluIHRoZSBjYWxscyB0byBgcHJlZGljYXRlYC4gKE90aGVyd2lzZSwgdGhlIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIHRoZSB1bndyYXBwZWQgb2JqZWN0LilcbiAgICAgKiBAcmV0dXJuIHsqfSBBbiBhcnJheSBjb250YWluaW5nIHRoZSBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQG1lbWJlck9mIFdyYXBwZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgZmlsdGVyOiBmdW5jdGlvbiAocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5vO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpcywgb1trZXldLCBrZXksIG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9ba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgY29udGV4dCB8fCBvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBNaW1pY3MgVW5kZXJzY29yZSdzIFttYXBdKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNtYXApIG1ldGhvZDogUHJvZHVjZXMgYSBuZXcgYXJyYXkgb2YgdmFsdWVzIGJ5IG1hcHBpbmcgZWFjaCB2YWx1ZSBpbiBsaXN0IHRocm91Z2ggYSB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiAoYGl0ZXJhdGVlYCkuIFRoZSBmdW5jdGlvbiBhbHdheXMgdHJhdmVyc2VzIHRoZSBlbnRpcmUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIC0gRm9yIGVhY2ggbWVtYmVyIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6IGAodmFsdWUsIGtleSwgb2JqZWN0KWAuIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBmdW5jdGlvbiBpcyBjb25jYXRlbmF0ZWQgdG8gdGhlIGVuZCBvZiB0aGUgbmV3IGFycmF5LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBnaXZlbiwgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byB0aGlzIG9iamVjdC4gSW4gb3RoZXIgd29yZHMsIHRoaXMgb2JqZWN0IGJlY29tZXMgdGhlIGB0aGlzYCB2YWx1ZSBpbiB0aGUgY2FsbHMgdG8gYHByZWRpY2F0ZWAuIChPdGhlcndpc2UsIHRoZSBgdGhpc2AgdmFsdWUgd2lsbCBiZSB0aGUgdW53cmFwcGVkIG9iamVjdC4pXG4gICAgICogQHJldHVybiB7Kn0gQW4gYXJyYXkgY29udGFpbmluZyB0aGUgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBtZW1iZXJPZiBXcmFwcGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIG1hcDogZnVuY3Rpb24gKGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5vO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpdGVyYXRlZS5jYWxsKHRoaXMsIG9ba2V5XSwga2V5LCBvKSk7XG4gICAgICAgICAgICB9LCBjb250ZXh0IHx8IG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIE1pbWljcyBVbmRlcnNjb3JlJ3MgW3JlZHVjZV0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvI3JlZHVjZSkgbWV0aG9kOiBCb2lsIGRvd24gdGhlIHZhbHVlcyBvZiBhbGwgdGhlIG1lbWJlcnMgb2YgdGhlIHdyYXBwZWQgb2JqZWN0IGludG8gYSBzaW5nbGUgdmFsdWUuIGBtZW1vYCBpcyB0aGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLCBhbmQgZWFjaCBzdWNjZXNzaXZlIHN0ZXAgb2YgaXQgc2hvdWxkIGJlIHJldHVybmVkIGJ5IGBpdGVyYXRlZSgpYC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSAtIEZvciBlYWNoIG1lbWJlciBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggZm91ciBhcmd1bWVudHM6IGAobWVtbywgdmFsdWUsIGtleSwgb2JqZWN0KWAuIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBmdW5jdGlvbiBiZWNvbWVzIHRoZSBuZXcgdmFsdWUgb2YgYG1lbW9gIGZvciB0aGUgbmV4dCBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbbWVtb10gLSBJZiBubyBtZW1vIGlzIHBhc3NlZCB0byB0aGUgaW5pdGlhbCBpbnZvY2F0aW9uIG9mIHJlZHVjZSwgdGhlIGl0ZXJhdGVlIGlzIG5vdCBpbnZva2VkIG9uIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBsaXN0LiBUaGUgZmlyc3QgZWxlbWVudCBpcyBpbnN0ZWFkIHBhc3NlZCBhcyB0aGUgbWVtbyBpbiB0aGUgaW52b2NhdGlvbiBvZiB0aGUgaXRlcmF0ZWUgb24gdGhlIG5leHQgZWxlbWVudCBpbiB0aGUgbGlzdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdIC0gSWYgZ2l2ZW4sIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gdGhpcyBvYmplY3QuIEluIG90aGVyIHdvcmRzLCB0aGlzIG9iamVjdCBiZWNvbWVzIHRoZSBgdGhpc2AgdmFsdWUgaW4gdGhlIGNhbGxzIHRvIGBpdGVyYXRlZWAuIChPdGhlcndpc2UsIHRoZSBgdGhpc2AgdmFsdWUgd2lsbCBiZSB0aGUgdW53cmFwcGVkIG9iamVjdC4pXG4gICAgICogQHJldHVybiB7Kn0gVGhlIHZhbHVlIG9mIGBtZW1vYCBcInJlZHVjZWRcIiBhcyBwZXIgYGl0ZXJhdGVlYC5cbiAgICAgKiBAbWVtYmVyT2YgV3JhcHBlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICByZWR1Y2U6IGZ1bmN0aW9uIChpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgICB2YXIgbyA9IHRoaXMubztcbiAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgbWVtbyA9ICghaWR4ICYmIG1lbW8gPT09IHVuZGVmaW5lZCkgPyBvW2tleV0gOiBpdGVyYXRlZShtZW1vLCBvW2tleV0sIGtleSwgbyk7XG4gICAgICAgICAgICB9LCBjb250ZXh0IHx8IG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBNaW1pY3MgVW5kZXJzY29yZSdzIFtleHRlbmRdKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNleHRlbmQpIG1ldGhvZDogQ29weSBhbGwgb2YgdGhlIHByb3BlcnRpZXMgaW4gZWFjaCBvZiB0aGUgYHNvdXJjZWAgb2JqZWN0IHBhcmFtZXRlcihzKSBvdmVyIHRvIHRoZSAod3JhcHBlZCkgZGVzdGluYXRpb24gb2JqZWN0ICh0aHVzIG11dGF0aW5nIGl0KS4gSXQncyBpbi1vcmRlciwgc28gdGhlIHByb3BlcnRpZXMgb2YgdGhlIGxhc3QgYHNvdXJjZWAgb2JqZWN0IHdpbGwgb3ZlcnJpZGUgcHJvcGVydGllcyB3aXRoIHRoZSBzYW1lIG5hbWUgaW4gcHJldmlvdXMgYXJndW1lbnRzIG9yIGluIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogPiBUaGlzIG1ldGhvZCBjb3BpZXMgb3duIG1lbWJlcnMgYXMgd2VsbCBhcyBtZW1iZXJzIGluaGVyaXRlZCBmcm9tIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgKiBAcGFyYW0gey4uLm9iamVjdHxudWxsfHVuZGVmaW5lZH0gc291cmNlIC0gVmFsdWVzIG9mIGBudWxsYCBvciBgdW5kZWZpbmVkYCBhcmUgdHJlYXRlZCBhcyBlbXB0eSBwbGFpbiBvYmplY3RzLlxuICAgICAqIEByZXR1cm4ge1dyYXBwZXJ8b2JqZWN0fSBUaGUgd3JhcHBlZCBkZXN0aW5hdGlvbiBvYmplY3QgaWYgY2hhaW5pbmcgaXMgaW4gZWZmZWN0OyBvdGhlcndpc2UgdGhlIHVud3JhcHBlZCBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQG1lbWJlck9mIFdyYXBwZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgZXh0ZW5kOiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5vO1xuICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgb1trZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhaW5pbmcgPyB0aGlzIDogbztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgTWltaWNzIFVuZGVyc2NvcmUncyBbZXh0ZW5kT3duXShodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jZXh0ZW5kT3duKSBtZXRob2Q6IExpa2Uge0BsaW5rIFdyYXBwZXIjZXh0ZW5kfGV4dGVuZH0sIGJ1dCBvbmx5IGNvcGllcyBpdHMgXCJvd25cIiBwcm9wZXJ0aWVzIG92ZXIgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLm9iamVjdHxudWxsfHVuZGVmaW5lZH0gc291cmNlIC0gVmFsdWVzIG9mIGBudWxsYCBvciBgdW5kZWZpbmVkYCBhcmUgdHJlYXRlZCBhcyBlbXB0eSBwbGFpbiBvYmplY3RzLlxuICAgICAqIEByZXR1cm4ge1dyYXBwZXJ8b2JqZWN0fSBUaGUgd3JhcHBlZCBkZXN0aW5hdGlvbiBvYmplY3QgaWYgY2hhaW5pbmcgaXMgaW4gZWZmZWN0OyBvdGhlcndpc2UgdGhlIHVud3JhcHBlZCBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQG1lbWJlck9mIFdyYXBwZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgZXh0ZW5kT3duOiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5vO1xuICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICAgICAgV3JhcHBlcihvYmplY3QpLmVhY2goZnVuY3Rpb24gKHZhbCwga2V5KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuICAgICAgICAgICAgICAgIG9ba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhaW5pbmcgPyB0aGlzIDogbztcbiAgICB9XG59O1xuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maW5kXG5pZiAoIUFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXh0ZW5kLW5hdGl2ZVxuICAgICAgICBpZiAodGhpcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLmZpbmQgY2FsbGVkIG9uIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ByZWRpY2F0ZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoID4+PiAwO1xuICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaSwgbGlzdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyYXBwZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAbW9kdWxlIG92ZXJyaWRlciAqL1xuXG4vKipcbiAqIE1peGVzIG1lbWJlcnMgb2YgYWxsIGBzb3VyY2VzYCBpbnRvIGB0YXJnZXRgLCBoYW5kbGluZyBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHByb3Blcmx5LlxuICpcbiAqIEFueSBudW1iZXIgb2YgYHNvdXJjZXNgIG9iamVjdHMgbWF5IGJlIGdpdmVuIGFuZCBlYWNoIGlzIGNvcGllZCBpbiB0dXJuLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgb3ZlcnJpZGVyID0gcmVxdWlyZSgnb3ZlcnJpZGVyJyk7XG4gKiB2YXIgdGFyZ2V0ID0geyBhOiAxIH0sIHNvdXJjZTEgPSB7IGI6IDIgfSwgc291cmNlMiA9IHsgYzogMyB9O1xuICogdGFyZ2V0ID09PSBvdmVycmlkZXIodGFyZ2V0LCBzb3VyY2UxLCBzb3VyY2UyKTsgLy8gdHJ1ZVxuICogLy8gdGFyZ2V0IG9iamVjdCBub3cgaGFzIGEsIGIsIGFuZCBjOyBzb3VyY2Ugb2JqZWN0cyB1bnRvdWNoZWRcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0IC0gVGhlIHRhcmdldCBvYmplY3QgdG8gcmVjZWl2ZSBzb3VyY2VzLlxuICogQHBhcmFtIHsuLi5vYmplY3R9IFtzb3VyY2VzXSAtIE9iamVjdChzKSBjb250YWluaW5nIG1lbWJlcnMgdG8gY29weSB0byBgdGFyZ2V0YC4gKE9taXR0aW5nIGlzIGEgbm8tb3AuKVxuICogQHJldHVybnMge29iamVjdH0gVGhlIHRhcmdldCBvYmplY3QgKGB0YXJnZXRgKVxuICovXG5mdW5jdGlvbiBvdmVycmlkZXIodGFyZ2V0LCBzb3VyY2VzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBtaXhJbi5jYWxsKHRhcmdldCwgYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIE1peCBgdGhpc2AgbWVtYmVycyBpbnRvIGB0YXJnZXRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBLiBTaW1wbGUgdXNhZ2UgKHVzaW5nIC5jYWxsKTpcbiAqIHZhciBtaXhJblRvID0gcmVxdWlyZSgnb3ZlcnJpZGVyJykubWl4SW5UbztcbiAqIHZhciB0YXJnZXQgPSB7IGE6IDEgfSwgc291cmNlID0geyBiOiAyIH07XG4gKiB0YXJnZXQgPT09IG92ZXJyaWRlci5taXhJblRvLmNhbGwoc291cmNlLCB0YXJnZXQpOyAvLyB0cnVlXG4gKiAvLyB0YXJnZXQgb2JqZWN0IG5vdyBoYXMgYm90aCBhIGFuZCBiOyBzb3VyY2Ugb2JqZWN0IHVudG91Y2hlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBCLiBTZW1hbnRpYyB1c2FnZSAod2hlbiB0aGUgc291cmNlIGhvc3RzIHRoZSBtZXRob2QpOlxuICogdmFyIG1peEluVG8gPSByZXF1aXJlKCdvdmVycmlkZXInKS5taXhJblRvO1xuICogdmFyIHRhcmdldCA9IHsgYTogMSB9LCBzb3VyY2UgPSB7IGI6IDIsIG1peEluVG86IG1peEluVG8gfTtcbiAqIHRhcmdldCA9PT0gc291cmNlLm1peEluVG8odGFyZ2V0KTsgLy8gdHJ1ZVxuICogLy8gdGFyZ2V0IG9iamVjdCBub3cgaGFzIGJvdGggYSBhbmQgYjsgc291cmNlIG9iamVjdCB1bnRvdWNoZWRcbiAqXG4gKiBAdGhpcyB7b2JqZWN0fSBUYXJnZXQuXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgdGFyZ2V0IG9iamVjdCAoYHRhcmdldGApXG4gKiBAbWVtYmVyT2YgbW9kdWxlOm92ZXJyaWRlclxuICovXG5mdW5jdGlvbiBtaXhJblRvKHRhcmdldCkge1xuICAgIHZhciBkZXNjcmlwdG9yO1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzKSB7XG4gICAgICAgIGlmICgoZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcywga2V5KSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBNaXggYHNvdXJjZWAgbWVtYmVycyBpbnRvIGB0aGlzYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQS4gU2ltcGxlIHVzYWdlICh1c2luZyAuY2FsbCk6XG4gKiB2YXIgbWl4SW4gPSByZXF1aXJlKCdvdmVycmlkZXInKS5taXhJbjtcbiAqIHZhciB0YXJnZXQgPSB7IGE6IDEgfSwgc291cmNlID0geyBiOiAyIH07XG4gKiB0YXJnZXQgPT09IG92ZXJyaWRlci5taXhJbi5jYWxsKHRhcmdldCwgc291cmNlKSAvLyB0cnVlXG4gKiAvLyB0YXJnZXQgb2JqZWN0IG5vdyBoYXMgYm90aCBhIGFuZCBiOyBzb3VyY2Ugb2JqZWN0IHVudG91Y2hlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBCLiBTZW1hbnRpYyB1c2FnZSAod2hlbiB0aGUgdGFyZ2V0IGhvc3RzIHRoZSBtZXRob2QpOlxuICogdmFyIG1peEluID0gcmVxdWlyZSgnb3ZlcnJpZGVyJykubWl4SW47XG4gKiB2YXIgdGFyZ2V0ID0geyBhOiAxLCBtaXhJbjogbWl4SW4gfSwgc291cmNlID0geyBiOiAyIH07XG4gKiB0YXJnZXQgPT09IHRhcmdldC5taXhJbihzb3VyY2UpIC8vIHRydWVcbiAqIC8vIHRhcmdldCBub3cgaGFzIGJvdGggYSBhbmQgYiAoYW5kIG1peEluKTsgc291cmNlIHVudG91Y2hlZFxuICpcbiAqIEBwYXJhbSBzb3VyY2VcbiAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSB0YXJnZXQgb2JqZWN0IChgdGhpc2ApXG4gKiBAbWVtYmVyT2Ygb3ZlcnJpZGVyXG4gKiBAbWVtYmVyT2YgbW9kdWxlOm92ZXJyaWRlclxuICovXG5mdW5jdGlvbiBtaXhJbihzb3VyY2UpIHtcbiAgICB2YXIgZGVzY3JpcHRvcjtcbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmICgoZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbm92ZXJyaWRlci5taXhJblRvID0gbWl4SW5Ubztcbm92ZXJyaWRlci5taXhJbiA9IG1peEluO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJyaWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWVudiBub2RlLCBicm93c2VyICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyByZWFkLW9ubHkgcHJvcGVydHkgYW5kIGF0dGFjaGVzIGl0IHRvIHRoZSBwcm92aWRlZCBjb250ZXh0LlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBmb3IgbmV3IHByb3BlcnR5LlxuICogQHBhcmFtIHsqfSBbdmFsdWVdIC0gVmFsdWUgb2YgbmV3IHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBhZGRSZWFkT25seVByb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWUsIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3IgUG9pbnRcbiAqXG4gKiBAZGVzYyBUaGlzIG9iamVjdCByZXByZXNlbnRzIGEgc2luZ2xlIHBvaW50IGluIGFuIGFic3RyYWN0IDItZGltZW5zaW9uYWwgbWF0cml4LlxuICpcbiAqIFRoZSB1bml0IG9mIG1lYXN1cmUgaXMgdHlwaWNhbGx5IHBpeGVscy5cbiAqIChJZiB1c2VkIHRvIG1vZGVsIGNvbXB1dGVyIGdyYXBoaWNzLCB2ZXJ0aWNhbCBjb29yZGluYXRlcyBhcmUgdHlwaWNhbGx5IG1lYXN1cmVkIGRvd253YXJkc1xuICogZnJvbSB0aGUgdG9wIG9mIHRoZSB3aW5kb3cuIFRoaXMgY29udmVudGlvbiBob3dldmVyIGlzIG5vdCBpbmhlcmVudCBpbiB0aGlzIG9iamVjdC4pXG4gKlxuICogTm90ZTogVGhpcyBvYmplY3Qgc2hvdWxkIGJlIGluc3RhbnRpYXRlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIG5ldyBwb2ludCdzIGB4YCBwcm9wZXJ0eVxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgbmV3IHBvaW50J3MgYHlgIHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIHhcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBzdW1tYXJ5IFRoaXMgcG9pbnQncyBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQGRlc2MgQ3JlYXRlZCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGluayBQb2ludHxjb25zdHJ1Y3Rvcn0uXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIGFkZFJlYWRPbmx5UHJvcGVydHkuY2FsbCh0aGlzLCAneCcsIE51bWJlcih4KSB8fCAwKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIHlcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBzdW1tYXJ5IFRoaXMgcG9pbnQncyB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICAgICAqIEBkZXNjIENyZWF0ZWQgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmsgUG9pbnR8Y29uc3RydWN0b3J9LlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBhZGRSZWFkT25seVByb3BlcnR5LmNhbGwodGhpcywgJ3knLCBOdW1iZXIoeSkgfHwgMCk7XG5cbn1cblxuUG9pbnQucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1BvaW50fSBBIG5ldyBwb2ludCB3aGljaCBpcyB0aGlzIHBvaW50J3MgcG9zaXRpb24gaW5jcmVhc2VkIGJ5IGNvb3JkaW5hdGVzIG9mIGdpdmVuIGBvZmZzZXRgLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IG9mZnNldCAtIEhvcml6b250YWwgYW5kIHZlcnRpY2FsIHZhbHVlcyB0byBhZGQgdG8gdGhpcyBwb2ludCdzIGNvb3JkaW5hdGVzLlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwbHVzOiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgIHRoaXMueCArIG9mZnNldC54LFxuICAgICAgICAgICAgdGhpcy55ICsgb2Zmc2V0LnlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1BvaW50fSBBIG5ldyBwb2ludCB3aGljaCBpcyB0aGlzIHBvaW50J3MgcG9zaXRpb24gaW5jcmVhc2VkIGJ5IGdpdmVuIG9mZnNldHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXRYPTBdIC0gVmFsdWUgdG8gYWRkIHRvIHRoaXMgcG9pbnQncyBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXRZPTBdIC0gVmFsdWUgdG8gYWRkIHRvIHRoaXMgcG9pbnQncyBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIHBsdXNYWTogZnVuY3Rpb24ob2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgdGhpcy54ICsgKG9mZnNldFggfHwgMCksXG4gICAgICAgICAgICB0aGlzLnkgKyAob2Zmc2V0WSB8fCAwKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IEEgbmV3IHBvaW50IHdoaWNoIGlzIHRoaXMgcG9pbnQncyBwb3NpdGlvbiBkZWNyZWFzZWQgYnkgY29vcmRpbmF0ZXMgb2YgZ2l2ZW4gYG9mZnNldGAuXG4gICAgICogQHBhcmFtIHtQb2ludH0gb2Zmc2V0IC0gSG9yaXpvbnRhbCBhbmQgdmVydGljYWwgdmFsdWVzIHRvIHN1YnRyYWN0IGZyb20gdGhpcyBwb2ludCdzIGNvb3JkaW5hdGVzLlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBtaW51czogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICB0aGlzLnggLSBvZmZzZXQueCxcbiAgICAgICAgICAgIHRoaXMueSAtIG9mZnNldC55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQb2ludH0gQSBuZXcgYFBvaW50YCBwb3NpdGlvbmVkIHRvIGxlYXN0IHggYW5kIGxlYXN0IHkgb2YgdGhpcyBwb2ludCBhbmQgZ2l2ZW4gYG9mZnNldGAuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIHBvaW50IHRvIGNvbXBhcmUgdG8gdGhpcyBwb2ludC5cbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgbWluOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgTWF0aC5taW4odGhpcy54LCBwb2ludC54KSxcbiAgICAgICAgICAgIE1hdGgubWluKHRoaXMueSwgcG9pbnQueSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1BvaW50fSBBIG5ldyBgUG9pbnRgIHBvc2l0aW9uZWQgdG8gZ3JlYXRlc3QgeCBhbmQgZ3JlYXRlc3QgeSBvZiB0aGlzIHBvaW50IGFuZCBnaXZlbiBgcG9pbnRgLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCB0byBjb21wYXJlIHRvIHRoaXMgcG9pbnQuXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIG1heDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgIE1hdGgubWF4KHRoaXMueCwgcG9pbnQueCksXG4gICAgICAgICAgICBNYXRoLm1heCh0aGlzLnksIHBvaW50LnkpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IERpc3RhbmNlIGJldHdlZW4gZ2l2ZW4gYHBvaW50YCBhbmQgdGhpcyBwb2ludCB1c2luZyBQeXRoYWdvcmVhbiBUaGVvcmVtIGZvcm11bGEuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIHBvaW50IGZyb20gd2hpY2ggdG8gY29tcHV0ZSB0aGUgZGlzdGFuY2UgdG8gdGhpcyBwb2ludC5cbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgZGlzdGFuY2U6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHZhciBkZWx0YVggPSBwb2ludC54IC0gdGhpcy54LFxuICAgICAgICAgICAgZGVsdGFZID0gcG9pbnQueSAtIHRoaXMueTtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgZGVsdGFYICogZGVsdGFYICtcbiAgICAgICAgICAgIGRlbHRhWSAqIGRlbHRhWVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBfKEZvcm1lcmx5OiBgZXF1YWxgLilfXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgX2JvdGhfIGNvb3JkaW5hdGVzIG9mIHRoaXMgcG9pbnQgYXJlIGV4YWN0bHkgZXF1YWwgdG8gdGhvc2Ugb2YgZ2l2ZW4gYHBvaW50YC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIEEgcG9pbnQgdG8gY29tcGFyZSB0byB0aGlzIHBvaW50LlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgdGhpcy54ID09PSBwb2ludC54ICYmXG4gICAgICAgICAgICAgICAgdGhpcy55ID09PSBwb2ludC55O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgX2JvdGhfIGNvb3JkaW5hdGVzIG9mIHRoaXMgcG9pbnQgYXJlIGdyZWF0ZXIgdGhhbiB0aG9zZSBvZiBnaXZlbiBgcG9pbnRgLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCB0byBjb21wYXJlIHRvIHRoaXMgcG9pbnRcbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgZ3JlYXRlclRoYW46IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnggPiBwb2ludC54ICYmXG4gICAgICAgICAgICB0aGlzLnkgPiBwb2ludC55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIF9ib3RoXyBjb29yZGluYXRlcyBvZiB0aGlzIHBvaW50IGFyZSBsZXNzIHRoYW4gdGhvc2Ugb2YgZ2l2ZW4gYHBvaW50YC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIEEgcG9pbnQgdG8gY29tcGFyZSB0byB0aGlzIHBvaW50XG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIGxlc3NUaGFuOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy54IDwgcG9pbnQueCAmJlxuICAgICAgICAgICAgdGhpcy55IDwgcG9pbnQueVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBfKEZvcm1lcmx5IGBncmVhdGVyVGhhbkVxdWFsVG9gLilfXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgX2JvdGhfIGNvb3JkaW5hdGVzIG9mIHRoaXMgcG9pbnQgYXJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aG9zZSBvZiBnaXZlbiBgcG9pbnRgLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCB0byBjb21wYXJlIHRvIHRoaXMgcG9pbnRcbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgZ3JlYXRlclRoYW5PckVxdWFsVG86IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnggPj0gcG9pbnQueCAmJlxuICAgICAgICAgICAgdGhpcy55ID49IHBvaW50LnlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogXyhGb3JtZXJseSBgbGVzc1RoYW5FcXVhbFRvYC4pX1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIF9ib3RoXyBjb29yZGluYXRlcyBvZiB0aGlzIHBvaW50IGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhvc2Ugb2YgZ2l2ZW4gYHBvaW50YC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIEEgcG9pbnQgdG8gY29tcGFyZSB0byB0aGlzIHBvaW50LlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBsZXNzVGhhbk9yRXF1YWxUbzogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMueCA8PSBwb2ludC54ICYmXG4gICAgICAgICAgICB0aGlzLnkgPD0gcG9pbnQueVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBfKEZvcm1lcmx5IGBpc0NvbnRhaW5lZFdpdGhpblJlY3RhbmdsZWAuKV9cbiAgICAgKiBAcGFyYW0gcmVjdCB7UmVjdGFuZ2xlfSAtIFJlY3RhbmdsZSB0byB0ZXN0IHRoaXMgcG9pbnQgYWdhaW5zdC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiB0aGlzIHBvaW50IGlzIHdpdGhpbiBnaXZlbiBgcmVjdGAuXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIHdpdGhpbjogZnVuY3Rpb24ocmVjdCkge1xuICAgICAgICB2YXIgbWluWCA9IHJlY3Qub3JpZ2luLngsXG4gICAgICAgICAgICBtYXhYID0gbWluWCArIHJlY3QuZXh0ZW50Lng7XG4gICAgICAgIHZhciBtaW5ZID0gcmVjdC5vcmlnaW4ueSxcbiAgICAgICAgICAgIG1heFkgPSBtaW5ZICsgcmVjdC5leHRlbnQueTtcblxuICAgICAgICBpZiAocmVjdC5leHRlbnQueCA8IDApIHtcbiAgICAgICAgICAgIG1pblggPSBtYXhYO1xuICAgICAgICAgICAgbWF4WCA9IHJlY3Qub3JpZ2luLng7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjdC5leHRlbnQueSA8IDApIHtcbiAgICAgICAgICAgIG1pblkgPSBtYXhZO1xuICAgICAgICAgICAgbWF4WSA9IHJlY3Qub3JpZ2luLnk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbWluWCA8PSB0aGlzLnggJiYgdGhpcy54IDwgbWF4WCAmJlxuICAgICAgICAgICAgbWluWSA8PSB0aGlzLnkgJiYgdGhpcy55IDwgbWF4WVxuICAgICAgICApO1xuICAgIH1cbn07XG5cblBvaW50LnByb3RvdHlwZS5FUSA9IFBvaW50LnByb3RvdHlwZS5lcXVhbHM7XG5Qb2ludC5wcm90b3R5cGUuR1QgPSBQb2ludC5wcm90b3R5cGUuZ3JlYXRlclRoYW47XG5Qb2ludC5wcm90b3R5cGUuTFQgPSBQb2ludC5wcm90b3R5cGUubGVzc1RoYW47XG5Qb2ludC5wcm90b3R5cGUuR0UgPSBQb2ludC5wcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsVG87XG5Qb2ludC5wcm90b3R5cGUuTEUgPSBQb2ludC5wcm90b3R5cGUubGVzc1RoYW5PckVxdWFsVG87XG5cblxuLyoqXG4gKiBAY29uc3RydWN0b3IgUmVjdGFuZ2xlXG4gKlxuICogQGRlc2MgVGhpcyBvYmplY3QgcmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGFyZWEgd2l0aGluIGFuIGFic3RyYWN0IDItZGltZW5zaW9uYWwgbWF0cml4LlxuICpcbiAqIFRoZSB1bml0IG9mIG1lYXN1cmUgaXMgdHlwaWNhbGx5IHBpeGVscy5cbiAqIChJZiB1c2VkIHRvIG1vZGVsIGNvbXB1dGVyIGdyYXBoaWNzLCB2ZXJ0aWNhbCBjb29yZGluYXRlcyBhcmUgdHlwaWNhbGx5IG1lYXN1cmVkIGRvd253YXJkc1xuICogZnJvbSB0aGUgdG9wIG9mIHRoZSB3aW5kb3cuIFRoaXMgY29udmVudGlvbiBob3dldmVyIGlzIG5vdCBpbmhlcmVudCBpbiB0aGlzIG9iamVjdC4pXG4gKlxuICogTm9ybWFsbHksIHRoZSBgeGAgYW5kIGB5YCBwYXJhbWV0ZXJzIHRvIHRoZSBjb25zdHJ1Y3RvciBkZXNjcmliZSB0aGUgdXBwZXIgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3QuXG4gKiBIb3dldmVyLCBuZWdhdGl2ZSB2YWx1ZXMgb2YgYHdpZHRoYCBhbmQgYGhlaWdodGAgd2lsbCBiZSBhZGRlZCB0byB0aGUgZ2l2ZW4gYHhgIGFuZCBgeWAuIFRoYXQgaXMsXG4gKiBhIG5lZ2F0aXZlIHZhbHVlIG9mIHRoZSBgd2lkdGhgIHBhcmFtZXRlciB3aWxsIGV4dGVuZCB0aGUgcmVjdCB0byB0aGUgbGVmdCBvZiB0aGUgZ2l2ZW4gYHhgIGFuZFxuICogYSBuZWdhdGl2ZSB2YWx1ZSBvZiB0aGUgYGhlaWdodGAgcGFyYW1ldGVyIHdpbGwgZXh0ZW5kIHRoZSByZWN0IGFib3ZlIHRoZSBnaXZlbiBgeWAuXG4gKiBJbiBhbnkgY2FzZSwgYWZ0ZXIgaW5zdGFudGlhdGlvbiB0aGUgZm9sbG93aW5nIGFyZSBndWFyYW50ZWVkIHRvIGFsd2F5cyBiZSB0cnVlOlxuICogKiBUaGUgYGV4dGVudGAsIGB3aWR0aGAsIGFuZCBgaGVpZ2h0YCBwcm9wZXJ0aWVzIF9hbHdheXNfIGdpdmUgcG9zaXRpdmUgdmFsdWVzLlxuICogKiBUaGUgYG9yaWdpbmAsIGB0b3BgLCBhbmQgYGxlZnRgIHByb3BlcnRpZXMgX2Fsd2F5c18gcmVmbGVjdCB0aGUgdXBwZXIgbGVmdCBjb3JuZXIuXG4gKiAqIFRoZSBgY29ybmVyYCwgYGJvdHRvbWAsIGFuZCBgcmlnaHRgIHByb3BlcnRpZXMgX2Fsd2F5c18gcmVmbGVjdCB0aGUgbG93ZXIgcmlnaHQgY29ybmVyLlxuICpcbiAqIE5vdGU6IFRoaXMgb2JqZWN0IHNob3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIGNvb3JkaW5hdGUgb2Ygc29tZSBjb3JuZXIgb2YgdGhlIHJlY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBjb29yZGluYXRlIG9mIHNvbWUgY29ybmVyIG9mIHRoZSByZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD0wXSAtIFdpZHRoIG9mIHRoZSBuZXcgcmVjdC4gTWF5IGJlIG5lZ2F0aXZlIChzZWUgYWJvdmUpLlxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9MF0gLSBIZWlnaHQgb2YgdGhlIG5ldyByZWN0LiBNYXkgYmUgbmVnYXRpdmUgKHNlZSBhYm92ZSkuXG4gKi9cbmZ1bmN0aW9uIFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgICB4ID0gTnVtYmVyKHgpIHx8IDA7XG4gICAgeSA9IE51bWJlcih5KSB8fCAwO1xuICAgIHdpZHRoID0gTnVtYmVyKHdpZHRoKSB8fCAwO1xuICAgIGhlaWdodCA9IE51bWJlcihoZWlnaHQpIHx8IDA7XG5cbiAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgIHggKz0gd2lkdGg7XG4gICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgIH1cblxuICAgIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgIHkgKz0gaGVpZ2h0O1xuICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIG9yaWdpblxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAc3VtbWFyeSBVcHBlciBsZWZ0IGNvcm5lciBvZiB0aGlzIHJlY3QuXG4gICAgICogQGRlc2MgQ3JlYXRlZCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGlua3BsYWluIFJlY3RhbmdsZXxjb25zdHJ1Y3Rvcn0uXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBhZGRSZWFkT25seVByb3BlcnR5LmNhbGwodGhpcywgJ29yaWdpbicsIG5ldyBQb2ludCh4LCB5KSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBleHRlbnRcbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQHN1bW1hcnkgdGhpcyByZWN0J3Mgd2lkdGggYW5kIGhlaWdodC5cbiAgICAgKiBAZGVzYyBVbmxpa2UgdGhlIG90aGVyIGBQb2ludGAgcHJvcGVydGllcywgYGV4dGVudGAgaXMgbm90IGEgZ2xvYmFsIGNvb3JkaW5hdGUgcGFpcjsgcmF0aGVyIGl0IGNvbnNpc3RzIG9mIGEgX3dpZHRoXyAoYHhgLCBhbHdheXMgcG9zaXRpdmUpIGFuZCBhIF9oZWlnaHRfIChgeWAsIGFsd2F5cyBwb3NpdGl2ZSkuXG4gICAgICpcbiAgICAgKiBUaGlzIG9iamVjdCBtaWdodCBiZSBtb3JlIGxlZ2l0aW1hdGVseSB0eXBlZCBhcyBzb21ldGhpbmcgbGlrZSBgQXJlYWAgd2l0aCBwcm9wZXJ0aWVzIGB3aWR0aGAgYW5kIGBoZWlnaHRgOyBob3dldmVyIHdlIHdhbnRlZCBpdCB0byBiZSBhYmxlIHRvIHVzZSBpdCBlZmZpY2llbnRseSB3aXRoIGEgcG9pbnQncyBgcGx1c2AgYW5kIGBtaW51c2AgbWV0aG9kcyAodGhhdCBpcywgd2l0aG91dCB0aG9zZSBtZXRob2RzIGhhdmluZyB0byBjaGVjayBhbmQgYnJhbmNoIG9uIHRoZSB0eXBlIG9mIGl0cyBwYXJhbWV0ZXIpLlxuICAgICAqXG4gICAgICogQ3JlYXRlZCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGlua3BsYWluIFJlY3RhbmdsZXxjb25zdHJ1Y3Rvcn0uXG4gICAgICogQHNlZSBUaGUge0BsaW5rIFJlY3RhbmdsZSNjb3JuZXJ8Y29ybmVyfSBtZXRob2QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBhZGRSZWFkT25seVByb3BlcnR5LmNhbGwodGhpcywgJ2V4dGVudCcsIG5ldyBQb2ludCh3aWR0aCwgaGVpZ2h0KSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBjb3JuZXJcbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQHN1bW1hcnkgTG93ZXIgcmlnaHQgY29ybmVyIG9mIHRoaXMgcmVjdC5cbiAgICAgKiBAZGVzYyBUaGlzIGlzIGEgY2FsY3VsYXRlZCB2YWx1ZSBjcmVhdGVkIHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rcGxhaW4gUmVjdGFuZ2xlfGNvbnN0cnVjdG9yfS4gSXQgaXMgYG9yaWdpbmAgb2Zmc2V0IGJ5IGBleHRlbnRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZXNlIGNvb3JkaW5hdGVzIGFjdHVhbGx5IHBvaW50IHRvIHRoZSBwaXhlbCBvbmUgYmVsb3cgYW5kIG9uZSB0byB0aGUgcmlnaHQgb2YgdGhlIHJlY3QncyBhY3R1YWwgbG93ZXIgcmlnaHQgcGl4ZWwuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBhZGRSZWFkT25seVByb3BlcnR5LmNhbGwodGhpcywgJ2Nvcm5lcicsIG5ldyBQb2ludCh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGNlbnRlclxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAc3VtbWFyeSBDZW50ZXIgb2YgdGhpcyByZWN0LlxuICAgICAqIEBkZXNjIENyZWF0ZWQgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmtwbGFpbiBSZWN0YW5nbGV8Y29uc3RydWN0b3J9LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgYWRkUmVhZE9ubHlQcm9wZXJ0eS5jYWxsKHRoaXMsICdjZW50ZXInLCBuZXcgUG9pbnQoeCArICh3aWR0aCAvIDIpLCB5ICsgKGhlaWdodCAvIDIpKSk7XG5cbn1cblxuUmVjdGFuZ2xlLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgKiBAc3VtbWFyeSBNaW5pbXVtIHZlcnRpY2FsIGNvb3JkaW5hdGUgb2YgdGhpcyByZWN0LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0IHRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgKiBAc3VtbWFyeSBNaW5pbXVtIGhvcml6b250YWwgY29vcmRpbmF0ZSBvZiB0aGlzIHJlY3QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luLng7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgKiBAc3VtbWFyeSBNYXhpbXVtIHZlcnRpY2FsIGNvb3JkaW5hdGUgb2YgdGhpcyByZWN0ICsgMS5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldCBib3R0b20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcm5lci55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZXNjIF8oRm9ybWVybHkgYSBmdW5jdGlvbjsgbm93IGEgZ2V0dGVyLilfXG4gICAgICogQHN1bW1hcnkgTWF4aW11bSBob3Jpem9udGFsIGNvb3JkaW5hdGUgb2YgdGhpcyByZWN0ICsgMS5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ybmVyLng7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgKiBAc3VtbWFyeSBXaWR0aCBvZiB0aGlzIHJlY3QgKGFsd2F5cyBwb3NpdGl2ZSkuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVudC54O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZXNjIF8oRm9ybWVybHkgYSBmdW5jdGlvbjsgbm93IGEgZ2V0dGVyLilfXG4gICAgICogQHN1bW1hcnkgSGVpZ2h0IG9mIHRoaXMgcmVjdCAoYWx3YXlzIHBvc2l0aXZlKS5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVudC55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZXNjIF8oRm9ybWVybHkgYSBmdW5jdGlvbjsgbm93IGEgZ2V0dGVyLilfXG4gICAgICogQHN1bW1hcnkgQXJlYSBvZiB0aGlzIHJlY3QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQgYXJlYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggKiB0aGlzLmhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gQSBjb3B5IG9mIHRoaXMgcmVjdCBidXQgd2l0aCBob3Jpem9udGFsIHBvc2l0aW9uIHJlc2V0IHRvIGdpdmVuIGB4YCBhbmQgbm8gd2lkdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBIb3Jpem9udGFsIGNvb3JkaW5hdGUgb2YgdGhlIG5ldyByZWN0LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZmxhdHRlblhBdDogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh4LCB0aGlzLm9yaWdpbi55LCAwLCB0aGlzLmV4dGVudC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gQSBjb3B5IG9mIHRoaXMgcmVjdCBidXQgd2l0aCB2ZXJ0aWNhbCBwb3NpdGlvbiByZXNldCB0byBnaXZlbiBgeWAgYW5kIG5vIGhlaWdodC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFZlcnRpY2FsIGNvb3JkaW5hdGUgb2YgdGhlIG5ldyByZWN0LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZmxhdHRlbllBdDogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLm9yaWdpbi54LCB5LCB0aGlzLmV4dGVudC54LCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgZ2l2ZW4gYHBvaW50YCBlbnRpcmVseSBjb250YWluZWQgd2l0aGluIHRoaXMgcmVjdC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludE9yUmVjdCAtIFRoZSBwb2ludCBvciByZWN0IHRvIHRlc3QgZm9yIGNvbnRhaW5tZW50LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgY29udGFpbnM6IGZ1bmN0aW9uKHBvaW50T3JSZWN0KSB7XG4gICAgICAgIHJldHVybiBwb2ludE9yUmVjdC53aXRoaW4odGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIF8oRm9ybWVybHkgYGlzQ29udGFpbmVkV2l0aGluUmVjdGFuZ2xlYC4pX1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIGB0aGlzYCByZWN0IGlzIGVudGlyZWx5IGNvbnRhaW5lZCB3aXRoaW4gZ2l2ZW4gYHJlY3RgLlxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IC0gUmVjdGFuZ2xlIHRvIHRlc3QgYWdhaW5zdCB0aGlzIHJlY3QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB3aXRoaW46IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJlY3Qub3JpZ2luLmxlc3NUaGFuT3JFcXVhbFRvKHRoaXMub3JpZ2luKSAmJlxuICAgICAgICAgICAgcmVjdC5jb3JuZXIuZ3JlYXRlclRoYW5PckVxdWFsVG8odGhpcy5jb3JuZXIpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIF8oRm9ybWVybHk6IGBpbnNldEJ5YC4pX1xuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IFRoYXQgaXMgZW5sYXJnZWQvc2hydW5rIGJ5IGdpdmVuIGBwYWRkaW5nYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZyAtIEFtb3VudCBieSB3aGljaCB0byBpbmNyZWFzZSAoKykgb3IgZGVjcmVhc2UgKC0pIHRoaXMgcmVjdFxuICAgICAqIEBzZWUgVGhlIHtAbGluayBSZWN0YW5nbGUjc2hyaW5rQnl8c2hyaW5rQnl9IG1ldGhvZC5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdyb3dCeTogZnVuY3Rpb24ocGFkZGluZykge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgICAgIHRoaXMub3JpZ2luLnggKyBwYWRkaW5nLFxuICAgICAgICAgICAgdGhpcy5vcmlnaW4ueSArIHBhZGRpbmcsXG4gICAgICAgICAgICB0aGlzLmV4dGVudC54IC0gcGFkZGluZyAtIHBhZGRpbmcsXG4gICAgICAgICAgICB0aGlzLmV4dGVudC55IC0gcGFkZGluZyAtIHBhZGRpbmcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBUaGF0IGlzIGVubGFyZ2VkL3NocnVuayBieSBnaXZlbiBgcGFkZGluZ2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmcgLSBBbW91bnQgYnkgd2hpY2ggdG8gZGVjcmVhc2UgKCspIG9yIGluY3JlYXNlICgtKSB0aGlzIHJlY3QuXG4gICAgICogQHNlZSBUaGUge0BsaW5rIFJlY3RhbmdsZSNncm93Qnl8Z3Jvd0J5fSBtZXRob2QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzaHJpbmtCeTogZnVuY3Rpb24ocGFkZGluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm93QnkoLXBhZGRpbmcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBCb3VuZGluZyByZWN0IHRoYXQgY29udGFpbnMgYm90aCB0aGlzIHJlY3QgYW5kIHRoZSBnaXZlbiBgcmVjdGAuXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3QgLSBUaGUgcmVjdGFuZ2xlIHRvIHVuaW9uIHdpdGggdGhpcyByZWN0LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgdW5pb246IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMub3JpZ2luLm1pbihyZWN0Lm9yaWdpbiksXG4gICAgICAgICAgICBjb3JuZXIgPSB0aGlzLmNvcm5lci5tYXgocmVjdC5jb3JuZXIpLFxuICAgICAgICAgICAgZXh0ZW50ID0gY29ybmVyLm1pbnVzKG9yaWdpbik7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgICBvcmlnaW4ueCwgb3JpZ2luLnksXG4gICAgICAgICAgICBleHRlbnQueCwgZXh0ZW50LnlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaXRlcmF0ZSBvdmVyIGFsbCBwb2ludHMgd2l0aGluIHRoaXMgcmVjdCwgaW52b2tpbmcgYGl0ZXJhdGVlYCBmb3IgZWFjaC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcixudW1iZXIpfSBpdGVyYXRlZSAtIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggcG9pbnQuXG4gICAgICogQm91bmQgdG8gYGNvbnRleHRgIHdoZW4gZ2l2ZW47IG90aGVyd2lzZSBpdCBpcyBib3VuZCB0byB0aGlzIHJlY3QuXG4gICAgICogRWFjaCBpbnZvY2F0aW9uIG9mIGBpdGVyYXRlZWAgaXMgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50czpcbiAgICAgKiB0aGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dD10aGlzXSAtIENvbnRleHQgdG8gYmluZCB0byBgaXRlcmF0ZWVgICh3aGVuIG5vdCBgdGhpc2ApLlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcbiAgICAgICAgZm9yICh2YXIgeCA9IHRoaXMub3JpZ2luLngsIHgyID0gdGhpcy5jb3JuZXIueDsgeCA8IHgyOyB4KyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSB0aGlzLm9yaWdpbi55LCB5MiA9IHRoaXMuY29ybmVyLnk7IHkgPCB5MjsgeSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0ZWUuY2FsbChjb250ZXh0LCB4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBPbmUgb2Y6XG4gICAgICogKiBfSWYgdGhpcyByZWN0IGludGVyc2VjdHMgd2l0aCB0aGUgZ2l2ZW4gYHJlY3RgOl9cbiAgICAgKiAgICAgIGEgbmV3IHJlY3QgcmVwcmVzZW50aW5nIHRoYXQgaW50ZXJzZWN0aW9uLlxuICAgICAqICogX0lmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IGFuZCBgaWZOb25lQWN0aW9uYCBkZWZpbmVkOl9cbiAgICAgKiAgICAgIHJlc3VsdCBvZiBjYWxsaW5nIGBpZk5vbmVBY3Rpb25gLlxuICAgICAqICogX0lmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IGFuZCBgaWZOb25lQWN0aW9uYCB1bmRlZmluZWQ6X1xuICAgICAqICAgICAgYG51bGxgLlxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IC0gVGhlIHJlY3RhbmdsZSB0byBpbnRlcnNlY3Qgd2l0aCB0aGlzIHJlY3QuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihSZWN0YW5nbGUpfSBbaWZOb25lQWN0aW9uXSAtIFdoZW4gbm8gaW50ZXJzZWN0aW9uLCBpbnZva2UgYW5kIHJldHVybiByZXN1bHQuXG4gICAgICogQm91bmQgdG8gYGNvbnRleHRgIHdoZW4gZ2l2ZW47IG90aGVyd2lzZSBib3VuZCB0byB0aGlzIHJlY3QuXG4gICAgICogSW52b2tlZCB3aXRoIGByZWN0YCBhcyBzb2xlIHBhcmFtZXRlci5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHQ9dGhpc10gLSBDb250ZXh0IHRvIGJpbmQgdG8gYGlmTm9uZUFjdGlvbmAgKHdoZW4gbm90IGB0aGlzYCkuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uKHJlY3QsIGlmTm9uZUFjdGlvbiwgY29udGV4dCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbCxcbiAgICAgICAgICAgIG9yaWdpbiA9IHRoaXMub3JpZ2luLm1heChyZWN0Lm9yaWdpbiksXG4gICAgICAgICAgICBjb3JuZXIgPSB0aGlzLmNvcm5lci5taW4ocmVjdC5jb3JuZXIpLFxuICAgICAgICAgICAgZXh0ZW50ID0gY29ybmVyLm1pbnVzKG9yaWdpbik7XG5cbiAgICAgICAgaWYgKGV4dGVudC54ID4gMCAmJiBleHRlbnQueSA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgICAgICAgb3JpZ2luLngsIG9yaWdpbi55LFxuICAgICAgICAgICAgICAgIGV4dGVudC54LCBleHRlbnQueVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaWZOb25lQWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpZk5vbmVBY3Rpb24uY2FsbChjb250ZXh0IHx8IHRoaXMsIHJlY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgdGhpcyByZWN0IG92ZXJsYXBzIHdpdGggZ2l2ZW4gYHJlY3RgLlxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IC0gVGhlIHJlY3RhbmdsZSB0byBpbnRlcnNlY3Qgd2l0aCB0aGlzIHJlY3QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbnRlcnNlY3RzOiBmdW5jdGlvbihyZWN0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICByZWN0LmNvcm5lci54ID4gdGhpcy5vcmlnaW4ueCAmJlxuICAgICAgICAgICAgcmVjdC5jb3JuZXIueSA+IHRoaXMub3JpZ2luLnkgJiZcbiAgICAgICAgICAgIHJlY3Qub3JpZ2luLnggPCB0aGlzLmNvcm5lci54ICYmXG4gICAgICAgICAgICByZWN0Lm9yaWdpbi55IDwgdGhpcy5jb3JuZXIueVxuICAgICAgICApO1xuICAgIH1cbn07XG5cbi8vIEludGVyZmFjZVxuZXhwb3J0cy5Qb2ludCA9IFBvaW50O1xuZXhwb3J0cy5SZWN0YW5nbGUgPSBSZWN0YW5nbGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludC1lbnYgbm9kZSwgYnJvd3NlciAqL1xuXG4oZnVuY3Rpb24gKG1vZHVsZSkgeyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblxuICAgIC8vIFRoaXMgY2xvc3VyZSBzdXBwb3J0cyBOb2RlSlMtbGVzcyBjbGllbnQgc2lkZSBpbmNsdWRlcyB3aXRoIDxzY3JpcHQ+IHRhZ3MuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vam9uZWl0L21ubS5cblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvciBSYW5nZVNlbGVjdGlvbk1vZGVsXG4gICAgICpcbiAgICAgKiBAZGVzYyBUaGlzIG9iamVjdCBtb2RlbHMgc2VsZWN0aW9uIG9mIFwiY2VsbHNcIiB3aXRoaW4gYW4gYWJzdHJhY3Qgc2luZ2xlLWRpbWVuc2lvbmFsIG1hdHJpeC5cbiAgICAgKlxuICAgICAqIERpc2pvaW50IHNlbGVjdGlvbnMgY2FuIGJlIGJ1aWx0IHdpdGggY2FsbHMgdG8gdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICAgICAqICoge0BsaW5rIFJhbmdlU2VsZWN0aW9uTW9kZWwjc2VsZWN0fHNlbGVjdChzdGFydCwgc3RvcCl9IC0gQWRkIGEgcmFuZ2UgdG8gdGhlIG1hdHJpeC5cbiAgICAgKiAqIHtAbGluayBSYW5nZVNlbGVjdGlvbk1vZGVsI2Rlc2VsZWN0fGRlc2VsZWN0KHN0YXJ0LCBzdG9wKX0gLSBSZW1vdmUgYSByYW5nZSBmcm9tIHRoZSBtYXRyaXguXG4gICAgICpcbiAgICAgKiBUd28gbW9yZSBtZXRob2RzIGFyZSBhdmFpbGFibGU6XG4gICAgICogKiBUZXN0IGEgY2VsbCB0byBzZWUgaWYgaXQge0BsaW5rIFJhbmdlU2VsZWN0aW9uTW9kZWwjaXNTZWxlY3RlZHxpc1NlbGVjdGVkKGNlbGwpfVxuICAgICAqICoge0BsaW5rIFJhbmdlU2VsZWN0aW9uTW9kZWwjY2xlYXJ8Y2xlYXIoKX0gdGhlIG1hdHJpeFxuICAgICAqXG4gICAgICogSW50ZXJuYWxseSwgdGhlIHNlbGVjdGlvbiBpcyBydW4tbGVuZ3RoLWVuY29kZWQuIEl0IGlzIHRoZXJlZm9yZSBhIFwic3BhcnNlXCIgbWF0cml4XG4gICAgICogd2l0aCB1bmRlZmluZWQgYm91bmRzLiBBIHNpbmdsZSBkYXRhIHByb3BlcnR5IGNhbGxlZCBgc2VsZWN0aW9uYCBpcyBhbiBhcnJheSB0aGF0XG4gICAgICogY29udGFpbnMgYWxsIHRoZSBcInJ1bnNcIiAocmFuZ2VzKSBvZiBzZWxlY3RlZCBjZWxscyBhbGJlaXQgaW4gbm8gcGFydGljdWxhciBvcmRlci5cbiAgICAgKiBUaGlzIHByb3BlcnR5IHNob3VsZCBub3Qgbm9ybWFsbHkgbmVlZCB0byBiZSBhY2Nlc3NlZCBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgb2JqZWN0IHNob3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtSYW5nZVNlbGVjdGlvbk1vZGVsfSBTZWxmIChpLmUuLCBgdGhpc2Agb2JqZWN0KS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSYW5nZVNlbGVjdGlvbk1vZGVsKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgc2VsZWN0aW9uXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS5BcnJheS5udW1iZXJ9XG4gICAgICAgICAqIEBzdW1tYXJ5IFVub3JkZXJlZCBsaXN0IG9mIHJ1bnMuXG4gICAgICAgICAqIEBkZXNjIEEgXCJydW5cIiBpcyBkZWZpbmVkIGFzIGFuIEFycmF5KDIpIHdoZXJlOlxuICAgICAgICAgKiAqIGVsZW1lbnQgWzBdIGlzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJ1blxuICAgICAgICAgKiAqIGVsZW1lbnQgWzFdIGlzIHRoZSBlbmQgb2YgdGhlIHJ1biAoaW5jbHVzaXZlKSBhbmQgaXMgYWx3YXlzID49IGVsZW1lbnQgWzBdXG4gICAgICAgICAqIFRoZSBvcmRlciBvZiB0aGUgcnVucyB3aXRoaW4gaXMgdW5kZWZpbmVkLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmFuZ2VTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IFtdO1xuXG4gICAgICAgIC8vd2UgbmVlZCB0byBiZSBhYmxlIHRvIGdvIGJhY2sgaW4gdGltZVxuICAgICAgICAvL3RoZSBzdGF0ZXMgZmllbGRcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBbXTtcblxuICAgICAgICAvL2Nsb25lIGFuZCBzdG9yZSBteSBjdXJyZW50IHN0YXRlXG4gICAgICAgIC8vc28gd2UgY2FuIHVud2luZCBjaGFuZ2VzIGlmIG5lZWQgYmVcbiAgICAgICAgdGhpcy5zdG9yZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbHMgPSB0aGlzLnNlbGVjdGlvbjtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IFtdO1xuICAgICAgICAgICAgdmFyIGNvcHk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3B5ID0gW10uY29uY2F0KHNlbHNbaV0pO1xuICAgICAgICAgICAgICAgIHN0YXRlLnB1c2goY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgQWRkIGEgY29udGlndW91cyBydW4gb2YgcG9pbnRzIHRvIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgICAqIEBkZXNjIEluc2VydCBhIG5ldyBydW4gaW50byBgdGhpcy5zZWxlY3Rpb25gLlxuICAgICAgICAgKiBUaGUgbmV3IHJ1biB3aWxsIGJlIG1lcmdlZCB3aXRoIG92ZXJsYXBwaW5nIGFuZCBhZGphY2VudCBydW5zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgdHdvIHBhcmFtZXRlcnMgbWF5IGJlIGdpdmVuIGluIGVpdGhlciBvcmRlci5cbiAgICAgICAgICogVGhlIHN0YXJ0IGFuZCBzdG9wIGVsZW1lbnRzIGluIHRoZSByZXN1bHRpbmcgcnVuIHdpbGwgaG93ZXZlciBhbHdheXMgYmUgb3JkZXJlZC5cbiAgICAgICAgICogKEhvd2V2ZXIsIG5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlIHJ1bnMgd2l0aGluIGB0aGlzLnNlbGVjdGlvbmAgaXMgaXRzZWxmIGFsd2F5cyB1bm9yZGVyZWQuKVxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgYHRoaXMuc2VsZWN0aW9uYCBpcyB1cGRhdGVkIGluIHBsYWNlLCBwcmVzZXJ2aW5nIHZhbGlkaXR5IG9mIGFueSBleHRlcm5hbCByZWZlcmVuY2VzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBTdGFydCBvZiBydW4uIE1heSBiZSBncmVhdGVyIHRoYW4gYHN0b3BgLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0b3A9c3RvcF0gLSBFbmQgb2YgcnVuIChpbmNsdXNpdmUpLiBNYXkgYmUgbGVzcyB0aGFuIGBzdGFydGAuXG4gICAgICAgICAqIEByZXR1cm5zIHtSYW5nZVNlbGVjdGlvbk1vZGVsfSBTZWxmIChpLmUuLCBgdGhpc2ApLCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0OiBmdW5jdGlvbiAoc3RhcnQsIHN0b3ApIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmVTdGF0ZSgpO1xuICAgICAgICAgICAgdmFyIHJ1biA9IG1ha2VSdW4oc3RhcnQsIHN0b3ApO1xuICAgICAgICAgICAgdmFyIHNwbGljZXIgPSBbMCwgMV07XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChlYWNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBzKGVhY2gsIHJ1bikgfHwgYWJ1dHMoZWFjaCwgcnVuKSkge1xuICAgICAgICAgICAgICAgICAgICBydW4gPSBtZXJnZShlYWNoLCBydW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGljZXIucHVzaChlYWNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNwbGljZXIucHVzaChydW4pO1xuICAgICAgICAgICAgc3BsaWNlclsxXSA9IHRoaXMuc2VsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNwbGljZS5hcHBseSh0aGlzLnNlbGVjdGlvbiwgc3BsaWNlcik7IC8vIHVwZGF0ZSBpbiBwbGFjZSB0byBwcmVzZXJ2ZSBleHRlcm5hbCByZWZlcmVuY2VzXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgUmVtb3ZlIGEgY29udGlndW91cyBydW4gb2YgcG9pbnRzIGZyb20gdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICogQGRlc2MgVHJ1bmNhdGUgYW5kL29yIHJlbW92ZSBydW4ocykgZnJvbSBgdGhpcy5zZWxlY3Rpb25gLlxuICAgICAgICAgKiBSZW1vdmluZyBwYXJ0IG9mIGV4aXN0aW5nIHJ1bnMgd2lsbCAoY29ycmVjdGx5KSBzaG9ydGVuIHRoZW0gb3IgYnJlYWsgdGhlbSBpbnRvIHR3byBmcmFnbWVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSB0d28gcGFyYW1ldGVycyBtYXkgYmUgZ2l2ZW4gaW4gZWl0aGVyIG9yZGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgYHRoaXMuc2VsZWN0aW9uYCBpcyB1cGRhdGVkIGluIHBsYWNlLCBwcmVzZXJ2aW5nIHZhbGlkaXR5IG9mIGFueSBleHRlcm5hbCByZWZlcmVuY2VzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBTdGFydCBvZiBydW4uIE1heSBiZSBncmVhdGVyIHRoYW4gYHN0b3BgLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0b3A9c3RvcF0gLSBFbmQgb2YgcnVuIChpbmNsdXNpdmUpLiBNYXkgYmUgbGVzcyB0aGFuIGBzdGFydGAuXG4gICAgICAgICAqIEByZXR1cm5zIHtSYW5nZVNlbGVjdGlvbk1vZGVsfSBTZWxmIChpLmUuLCBgdGhpc2ApLCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZGVzZWxlY3Q6IGZ1bmN0aW9uIChzdGFydCwgc3RvcCkge1xuICAgICAgICAgICAgdmFyIHJ1biA9IG1ha2VSdW4oc3RhcnQsIHN0b3ApO1xuICAgICAgICAgICAgdmFyIHNwbGljZXIgPSBbMCwgMF07XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChlYWNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBzKGVhY2gsIHJ1bikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBpZWNlcyA9IHN1YnRyYWN0KGVhY2gsIHJ1bik7XG4gICAgICAgICAgICAgICAgICAgIHNwbGljZXIgPSBzcGxpY2VyLmNvbmNhdChwaWVjZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGljZXIucHVzaChlYWNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNwbGljZXJbMV0gPSB0aGlzLnNlbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zcGxpY2UuYXBwbHkodGhpcy5zZWxlY3Rpb24sIHNwbGljZXIpOyAvLyB1cGRhdGUgaW4gcGxhY2UgdG8gcHJlc2VydmUgZXh0ZXJuYWwgcmVmZXJlbmNlc1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IEVtcHRpZXMgYHRoaXMuc2VsZWN0aW9uYCwgZWZmZWN0aXZlbHkgcmVtb3ZpbmcgYWxsIHJ1bnMuXG4gICAgICAgICAqIEByZXR1cm5zIHtSYW5nZVNlbGVjdGlvbk1vZGVsfSBTZWxmIChpLmUuLCBgdGhpc2ApLCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5sZW5ndGggPSAwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB0aGlzLnN0YXRlcy5wb3AoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gYGNlbGxgIGlzIHNlbGVjdGVkLlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBnaXZlbiBgY2VsbGAgaXMgd2l0aGluIGFueSBvZiB0aGUgcnVucyBpbiBgdGhpcy5zZWxlY3Rpb25gLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY2VsbCAtIFRoZSBjZWxsIHRvIHRlc3QgZm9yIGluY2x1c2lvbiBpbiB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmFuZ2VTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uc29tZShmdW5jdGlvbiAoZWFjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlYWNoWzBdIDw9IGNlbGwgJiYgY2VsbCA8PSBlYWNoWzFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNFbXB0eTogZnVuY3Rpb24gKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24ubGVuZ3RoID09PSAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGluZGV4ZXMgdGhhdCBhcmUgc2VsZWN0ZWQuXG4gICAgICAgICAqIEBkZXNjIFJldHVybiB0aGUgaW5kZXhlcyB0aGF0IGFyZSBzZWxlY3RlZC5cbiAgICAgICAgICogQHJldHVybnMge0FycmF5LkFycmF5Lm51bWJlcn1cbiAgICAgICAgICogQG1lbWJlck9mIFJhbmdlU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTZWxlY3Rpb25zOiBmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24gKGVhY2gpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gZWFjaFswXTsgaSA8PSBlYWNoWzFdOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQuc29ydChmdW5jdGlvbiAoYSwgYil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc3VtbWFyeSBQcmVwcyBgc3RhcnRgIGFuZCBgc3RvcGAgcGFyYW1zIGludG8gb3JkZXIgYXJyYXlcbiAgICAgKiBAZnVuY3Rpb24gbWFrZVJ1blxuICAgICAqIEBkZXNjIFV0aWxpdHkgZnVuY3Rpb24gY2FsbGVkIGJ5IGJvdGggYHNlbGVjdCgpYCBhbmQgYGRlc2VsZWN0KClgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBzdGFydCAtIFN0YXJ0IG9mIHJ1bi4gaWYgYXJyYXksIGBzdGFydGAgYW5kIGBzdG9wYCBhcmUgdGFrZW4gZnJvbSBmaXJzdCB0d28gZWxlbWVudHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdG9wPXN0YXJ0XSAtIEVuZCBvZiBydW4gKGluY2x1c2l2ZSkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZVJ1bihzdGFydCwgc3RvcCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgc3RhcnQgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgICAgID8gbWFrZVJ1bi5hcHBseSh0aGlzLCBzdGFydCkgLy8gZXh0cmFjdCBwYXJhbXMgZnJvbSBnaXZlbiBhcnJheVxuICAgICAgICAgICAgICAgIDogc3RvcCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBbIHN0YXJ0LCBzdGFydCBdIC8vIHNpbmdsZSBwYXJhbSBpcyBhIHJ1biB0aGF0IHN0b3BzIHdoZXJlIGl0IHN0YXJ0c1xuICAgICAgICAgICAgICAgIDogc3RhcnQgPD0gc3RvcFxuICAgICAgICAgICAgICAgID8gWyBzdGFydCwgc3RvcCBdXG4gICAgICAgICAgICAgICAgOiBbIHN0b3AsIHN0YXJ0IF0gLy8gcmV2ZXJzZSBkZXNjZW5kaW5nIHBhcmFtcyBpbnRvIGFzY2VuZGluZyBvcmRlclxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZ1bmN0aW9uIG92ZXJsYXBzXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgYHJ1bjFgIG92ZXJsYXBzIGBydW4yYFxuICAgICAqIEBzdW1tYXJ5IENvbXBhcmlzb24gb3BlcmF0b3IgdGhhdCBkZXRlcm1pbmVzIGlmIGdpdmVuIHJ1bnMgb3ZlcmxhcCB3aXRoIG9uZSBhbm90aGVyLlxuICAgICAqIEBkZXNjIEJvdGggcGFyYW1ldGVycyBhcmUgYXNzdW1lZCB0byBiZSBfb3JkZXJlZF8gYXJyYXlzLlxuICAgICAqXG4gICAgICogT3ZlcmxhcCBpcyBkZWZpbmVkIHRvIGluY2x1ZGUgdGhlIGNhc2Ugd2hlcmUgb25lIHJ1biBjb21wbGV0ZWx5IGNvbnRhaW5zIHRoZSBvdGhlci5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgb3BlcmF0b3IgaXMgY29tbXV0YXRpdmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcnVuMSAtIGZpcnN0IHJ1blxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjIgLSBzZWNvbmQgcnVuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3ZlcmxhcHMocnVuMSwgcnVuMikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcnVuMVswXSA8PSBydW4yWzBdICYmIHJ1bjJbMF0gPD0gcnVuMVsxXSB8fCAvLyBydW4yJ3Mgc3RhcnQgaXMgd2l0aGluIHJ1bjEgT1IuLi5cbiAgICAgICAgICAgIHJ1bjFbMF0gPD0gcnVuMlsxXSAmJiBydW4yWzFdIDw9IHJ1bjFbMV0gfHwgLy8gcnVuMidzIHN0b3AgaXMgd2l0aGluIHJ1bjEgT1IuLi5cbiAgICAgICAgICAgIHJ1bjJbMF0gPCAgcnVuMVswXSAmJiBydW4xWzFdIDwgIHJ1bjJbMV0gICAgLy8gcnVuMiBjb21wbGV0ZWx5IGNvbnRhaW5zIHJ1bjFcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvbiBhYnV0c1xuICAgICAqIEBzdW1tYXJ5IENvbXBhcmlzb24gb3BlcmF0b3IgdGhhdCBkZXRlcm1pbmVzIGlmIGdpdmVuIHJ1bnMgYXJlIGNvbnNlY3V0aXZlIHdpdGggb25lIGFub3RoZXIuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgYHJ1bjFgIGlzIGNvbnNlY3V0aXZlIHdpdGggYHJ1bjJgXG4gICAgICogQGRlc2MgQm90aCBwYXJhbWV0ZXJzIGFyZSBhc3N1bWVkIHRvIGJlIF9vcmRlcmVkXyBhcnJheXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG9wZXJhdG9yIGlzIGNvbW11dGF0aXZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjEgLSBmaXJzdCBydW5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBydW4yIC0gc2Vjb25kIHJ1blxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFidXRzKHJ1bjEsIHJ1bjIpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJ1bjFbMV0gPT09IHJ1bjJbMF0gLSAxIHx8IC8vIHJ1bjEncyB0b3AgaW1tZWRpYXRlbHkgcHJlY2VkZXMgcnVuMidzIHN0YXJ0IE9SLi4uXG4gICAgICAgICAgICBydW4yWzFdID09PSBydW4xWzBdIC0gMSAgICAvLyBydW4yJ3MgdG9wIGltbWVkaWF0ZWx5IHByZWNlZGVzIHJ1bjEncyBzdGFydFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZ1bmN0aW9uIHN1YnRyYWN0XG4gICAgICogQHN1bW1hcnkgT3BlcmF0b3IgdGhhdCBzdWJ0cmFjdHMgb25lIHJ1biBmcm9tIGFub3RoZXIuXG4gICAgICogQHJldHVybnMge0FycmF5LkFycmF5Lm51bWJlcn0gVGhlIHJlbWFpbmluZyBwaWVjZXMgb2YgYG1pbnVlbmRgIGFmdGVyIHJlbW92aW5nIGBzdWJ0cmFoZW5kYC5cbiAgICAgKiBAZGVzYyBCb3RoIHBhcmFtZXRlcnMgYXJlIGFzc3VtZWQgdG8gYmUgX29yZGVyZWRfIGFycmF5cy5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gX2RvZXMgbm90IGFzc3VtZXNfIHRoYXQgYG92ZXJsYXAoKWAgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQgd2l0aCB0aGUgc2FtZSBydW5zIGFuZCBoYXMgcmV0dXJuZWQgYHRydWVgLlxuICAgICAqXG4gICAgICogUmV0dXJuZWQgYXJyYXkgY29udGFpbnMgMCwgMSwgb3IgMiBydW5zIHdoaWNoIGFyZSB0aGUgcG9ydGlvbihzKSBvZiBgbWludWVuZGAgdGhhdCBkbyBfbm90XyBpbmNsdWRlIGBzdWJ0cmFoZW5kYC5cbiAgICAgKlxuICAgICAqIENhdmVhdDogVGhpcyBvcGVyYXRvciBpcyAqbm90KiBjb21tdXRhdGl2ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBtaW51ZW5kIC0gYSBydW4gZnJvbSB3aGljaCB0byBcInN1YnRyYWN0XCIgYHN1YnRyYWhlbmRgXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gc3VidHJhaGVuZCAtIGEgcnVuIHRvIFwic3VidHJhY3RlZFwiIGZyb20gYG1pbnVlbmRgXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VidHJhY3QobWludWVuZCwgc3VidHJhaGVuZCkge1xuICAgICAgICB2YXIgbTAgPSBtaW51ZW5kWzBdO1xuICAgICAgICB2YXIgbTEgPSBtaW51ZW5kWzFdO1xuICAgICAgICB2YXIgczAgPSBzdWJ0cmFoZW5kWzBdO1xuICAgICAgICB2YXIgczEgPSBzdWJ0cmFoZW5kWzFdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYgKHMwIDw9IG0wICYmIHMxIDwgbTEpIHtcbiAgICAgICAgICAgIC8vc3VidHJhaGVuZCBleHRlbmRzIGJlZm9yZSBtaW51ZW5kOiByZXR1cm4gcmVtYWluaW5nIHBpZWNlIG9mIGBtaW51ZW5kYFxuICAgICAgICAgICAgcmVzdWx0LnB1c2goW3MxICsgMSwgbTFdKTtcbiAgICAgICAgfSBlbHNlIGlmIChzMCA+IG0wICYmIHMxID49IG0xKSB7XG4gICAgICAgICAgICAvL3N1YnRyYWhlbmQgZXh0ZW5kcyBhZnRlciBtaW51ZW5kOiByZXR1cm4gcmVtYWluaW5nIHBpZWNlIG9mIGBtaW51ZW5kYFxuICAgICAgICAgICAgcmVzdWx0LnB1c2goW20wLCBzMCAtIDFdKTtcbiAgICAgICAgfSBlbHNlIGlmIChtMCA8IHMwICYmIHMxIDwgbTEpIHtcbiAgICAgICAgICAgIC8vY29tcGxldGVseSBpbnNpZGU6IHJldHVybiAyIHNtYWxsZXIgcGllY2VzIHJlc3VsdGluZyBmcm9tIHRoZSBob2xlXG4gICAgICAgICAgICByZXN1bHQucHVzaChbbTAsIHMwIC0gMV0pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW3MxICsgMSwgbTFdKTtcbiAgICAgICAgfSBlbHNlIGlmIChzMSA8IG0wIHx8IHMwID4gbTEpIHtcbiAgICAgICAgICAgIC8vIGNvbXBsZXRlbHkgb3V0c2lkZTogcmV0dXJuIGBtaW51ZW5kYCB1bnRvdWNoZWRcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1pbnVlbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9lbHNlIHN1YnRyYWhlbmQgbXVzdCBjb21wbGV0ZWx5IG92ZXJsYXAgbWludWVuZCBzbyByZXR1cm4gbm8gcGllY2VzXG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cblxuICAgIC8vIExvY2FsIHV0aWxpdHkgZnVuY3Rpb25zXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvbiBtZXJnZVxuICAgICAqIEBzdW1tYXJ5IE9wZXJhdG9yIHRoYXQgbWVyZ2VzIGdpdmVuIHJ1bnMuXG4gICAgICogQHJldHVybnMge251bWJlcltdfSBBIHNpbmdsZSBtZXJnZWQgcnVuLlxuICAgICAqIEBkZXNjIEJvdGggcGFyYW1ldGVycyBhcmUgYXNzdW1lZCB0byBiZSBfb3JkZXJlZF8gYXJyYXlzLlxuICAgICAqXG4gICAgICogVGhlIHJ1bnMgYXJlIGFzc3VtZWQgdG8gYmUgb3ZlcmxhcHBpbmcgb3IgYWRqYWNlbnQgdG8gb25lIGFub3RoZXIuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG9wZXJhdG9yIGlzIGNvbW11dGF0aXZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjEgLSBhIHJ1biB0byBtZXJnZSB3aXRoIGBydW4yYFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjIgLSBhIHJ1biB0byBtZXJnZSB3aXRoIGBydW4xYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlKHJ1bjEsIHJ1bjIpIHtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKE1hdGgubWluLmFwcGx5KE1hdGgsIHJ1bjEpLCBNYXRoLm1pbi5hcHBseShNYXRoLCBydW4yKSk7XG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heChNYXRoLm1heC5hcHBseShNYXRoLCBydW4xKSwgTWF0aC5tYXguYXBwbHkoTWF0aCwgcnVuMikpO1xuICAgICAgICByZXR1cm4gW21pbiwgbWF4XTtcbiAgICB9XG5cbiAgICAvLyBJbnRlcmZhY2VcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJhbmdlU2VsZWN0aW9uTW9kZWw7XG59KShcbiAgICB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUgfHwgKHdpbmRvdy5SYW5nZVNlbGVjdGlvbk1vZGVsID0ge30pLFxuICAgIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzIHx8ICh3aW5kb3cuUmFuZ2VTZWxlY3Rpb25Nb2RlbC5leHBvcnRzID0ge30pXG4pIHx8IChcbiAgICB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyB8fCAod2luZG93LlJhbmdlU2VsZWN0aW9uTW9kZWwgPSB3aW5kb3cuUmFuZ2VTZWxlY3Rpb25Nb2RlbC5leHBvcnRzKVxuKTtcblxuLyogQWJvdXQgdGhlIGFib3ZlIElJRkU6XG4gKiBUaGlzIGZpbGUgaXMgYSBcIm1vZGlmaWVkIG5vZGUgbW9kdWxlLlwiIEl0IGZ1bmN0aW9ucyBhcyB1c3VhbCBpbiBOb2RlLmpzICphbmQqIGlzIGFsc28gdXNhYmxlIGRpcmVjdGx5IGluIHRoZSBicm93c2VyLlxuICogMS4gTm9kZS5qczogVGhlIElJRkUgaXMgc3VwZXJmbHVvdXMgYnV0IGlubm9jdW91cy5cbiAqIDIuIEluIHRoZSBicm93c2VyOiBUaGUgSUlGRSBjbG9zdXJlIHNlcnZlcyB0byBrZWVwIGludGVybmFsIGRlY2xhcmF0aW9ucyBwcml2YXRlLlxuICogMi5hLiBJbiB0aGUgYnJvd3NlciBhcyBhIGdsb2JhbDogVGhlIGxvZ2ljIGluIHRoZSBhY3R1YWwgcGFyYW1ldGVyIGV4cHJlc3Npb25zICsgdGhlIHBvc3QtaW52b2NhdGlvbiBleHByZXNzaW9uXG4gKiB3aWxsIHB1dCB5b3VyIEFQSSBpbiBgd2luZG93LlJhbmdlU2VsZWN0aW9uTW9kZWxgLlxuICogMi5iLiBJbiB0aGUgYnJvd3NlciBhcyBhIG1vZHVsZTogSWYgeW91IHByZWRlZmluZSBhIGB3aW5kb3cubW9kdWxlYCBvYmplY3QsIHRoZSByZXN1bHRzIHdpbGwgYmUgaW4gYG1vZHVsZS5leHBvcnRzYC5cbiAqIFRoZSBib3dlciBjb21wb25lbnQgYG1ubWAgbWFrZXMgdGhpcyBlYXN5IGFuZCBhbHNvIHByb3ZpZGVzIGEgZ2xvYmFsIGByZXF1aXJlKClgIGZ1bmN0aW9uIGZvciByZWZlcmVuY2luZyB5b3VyIG1vZHVsZVxuICogZnJvbSBvdGhlciBjbG9zdXJlcy4gSW4gZWl0aGVyIGNhc2UsIHRoaXMgd29ya3Mgd2l0aCBib3RoIE5vZGVKcy1zdHlsZSBleHBvcnQgbWVjaGFuaXNtcyAtLSBhIHNpbmdsZSBBUEkgYXNzaWdubWVudCxcbiAqIGBtb2R1bGUuZXhwb3J0cyA9IHlvdXJBUElgICpvciogYSBzZXJpZXMgb2YgaW5kaXZpZHVhbCBwcm9wZXJ0eSBhc3NpZ25tZW50cywgYG1vZHVsZS5leHBvcnRzLnByb3BlcnR5ID0gcHJvcGVydHlgLlxuICpcbiAqIEJlZm9yZSB0aGUgSUlGRSBydW5zLCB0aGUgYWN0dWFsIHBhcmFtZXRlciBleHByZXNzaW9ucyBhcmUgZXhlY3V0ZWQ6XG4gKiAxLiBJZiBgd2luZG93YCBvYmplY3QgdW5kZWZpbmVkLCB3ZSdyZSBpbiBOb2RlSnMgc28gYXNzdW1lIHRoZXJlIGlzIGEgYG1vZHVsZWAgb2JqZWN0IHdpdGggYW4gYGV4cG9ydHNgIHByb3BlcnR5XG4gKiAyLiBJZiBgd2luZG93YCBvYmplY3QgZGVmaW5lZCwgd2UncmUgaW4gYnJvd3NlclxuICogMi5hLiBJZiBgbW9kdWxlYCBvYmplY3QgcHJlZGVmaW5lZCwgdXNlIGl0XG4gKiAyLmIuIElmIGBtb2R1bGVgIG9iamVjdCB1bmRlZmluZWQsIGNyZWF0ZSBhIGBSYW5nZVNlbGVjdGlvbk1vZGVsYCBvYmplY3RcbiAqXG4gKiBBZnRlciB0aGUgSUlGRSByZXR1cm5zOlxuICogQmVjYXVzZSBpdCBhbHdheXMgcmV0dXJucyB1bmRlZmluZWQsIHRoZSBleHByZXNzaW9uIGFmdGVyIHRoZSB8fCB3aWxsIGV4ZWN1dGU6XG4gKiAxLiBJZiBgd2luZG93YCBvYmplY3QgdW5kZWZpbmVkLCB0aGVuIHdlJ3JlIGluIE5vZGVKcyBzbyB3ZSdyZSBkb25lXG4gKiAyLiBJZiBgd2luZG93YCBvYmplY3QgZGVmaW5lZCwgdGhlbiB3ZSdyZSBpbiBicm93c2VyXG4gKiAyLmEuIElmIGBtb2R1bGVgIG9iamVjdCBwcmVkZWZpbmVkLCB3ZSdyZSBkb25lOyByZXN1bHRzIGFyZSBpbiBgbW91ZHVsZS5leHBvcnRzYFxuICogMi5iLiBJZiBgbW9kdWxlYCBvYmplY3QgdW5kZWZpbmVkLCByZWRlZmluZWBSYW5nZVNlbGVjdGlvbk1vZGVsYCB0byBiZSB0aGUgYFJhbmdlU2VsZWN0aW9uTW9kZWwuZXhwb3J0c2Agb2JqZWN0XG4gKi9cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJmaW4taHlwZXJncmlkXCIsXG4gICAgXCJ2ZXJzaW9uXCI6IFwiMy4wLjBcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQ2FudmFzLWJhc2VkIGhpZ2gtcGVyZm9ybWFuY2UgZ3JpZCBleHRlbmRlZFwiLFxuICAgIFwibWFpblwiOiBcInNyYy9IeXBlcmdyaWRcIixcbiAgICBcInJlcG9zaXRvcnlcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICAgICAgXCJ1cmxcIjogXCJnaXQ6Ly9naXRodWIuY29tL2FsZXgta2xzL2NvcmUuZ2l0XCJcbiAgICB9LFxuICAgIFwiYXV0aG9yXCI6IFwiU1dpcnRzLCBKRWl0ZW4sIERKb25lcywgTk1pY2hhdWQsIEFLbGlzaGNoZXZza2l5XCIsXG4gICAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gICAgXCJyZWFkbWVGaWxlbmFtZVwiOiBcIlJFQURNRS5tZFwiLFxuICAgIFwiZ2l0SGVhZFwiOiBcIlwiLFxuICAgIFwia2V5d29yZHNcIjogW1xuICAgICAgICBcInNwcmVhZHNoZWV0XCIsXG4gICAgICAgIFwiZ3JpZFwiLFxuICAgICAgICBcImNhbnZhc1wiXG4gICAgXSxcbiAgICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgICAgIFwiY2hhaVwiOiBcIl40LjEuMlwiLFxuICAgICAgICBcImRlZXAtZXF1YWxcIjogXCJeMS4wLjFcIixcbiAgICAgICAgXCJleHRlbmQtbWVcIjogXCJeMi43LjBcIixcbiAgICAgICAgXCJmaW4taHlwZXJncmlkLWV2ZW50LWxvZ2dlclwiOiBcIl4xLjAuNFwiLFxuICAgICAgICBcImZpbmJhcnNcIjogXCIxLjUuMlwiLFxuICAgICAgICBcImluamVjdC1zdHlsZXNoZWV0LXRlbXBsYXRlXCI6IFwiXjEuMC4xXCIsXG4gICAgICAgIFwibXVzdGFjaGVcIjogXCJeMi4zLjBcIixcbiAgICAgICAgXCJvYmplY3QtaXRlcmF0b3JzXCI6IFwiMS4zLjBcIixcbiAgICAgICAgXCJvdmVycmlkZXJcIjogXCJeMFwiLFxuICAgICAgICBcInJlY3Rhbmd1bGFyXCI6IFwiMS4wLjFcIixcbiAgICAgICAgXCJzcGFyc2UtYm9vbGVhbi1hcnJheVwiOiBcIjEuMC4xXCJcbiAgICB9LFxuICAgIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICAgICAgXCJiYWJlbC1jb3JlXCI6IFwiXjYuMjYuMFwiLFxuICAgICAgICBcImJhYmVsLXByZXNldC1lczIwMTVcIjogXCJeNi4yNC4xXCIsXG4gICAgICAgIFwiYmFiZWwtcHJlc2V0LWVzMjAxNlwiOiBcIl42LjI0LjFcIixcbiAgICAgICAgXCJiYWJlbGlmeVwiOiBcIl44LjAuMFwiLFxuICAgICAgICBcImJyb3dzZXItc3luY1wiOiBcIl4yLjIzLjZcIixcbiAgICAgICAgXCJicm93c2VyaWZ5XCI6IFwiXjE2LjEuMVwiLFxuICAgICAgICBcImNzcy1pbmplY3RvclwiOiBcIl4xLjEuMFwiLFxuICAgICAgICBcImd1bHBcIjogXCJeMy45LjBcIixcbiAgICAgICAgXCJndWxwLWNvbmNhdFwiOiBcIl4yLjYuMFwiLFxuICAgICAgICBcImd1bHAtZWFjaFwiOiBcIl4wLjEuMVwiLFxuICAgICAgICBcImd1bHAtZXNsaW50XCI6IFwiXjQuMC4yXCIsXG4gICAgICAgIFwiZ3VscC1leGNsdWRlLWdpdGlnbm9yZVwiOiBcIl4xLjIuMFwiLFxuICAgICAgICBcImd1bHAtZm9vdGVyXCI6IFwiXjEuMS4xXCIsXG4gICAgICAgIFwiZ3VscC1oZWFkZXJcIjogXCJeMS44LjJcIixcbiAgICAgICAgXCJndWxwLWltYWdpbmUtNjRcIjogXCJeMS4wLjFcIixcbiAgICAgICAgXCJndWxwLWxvYWQtcGx1Z2luc1wiOiBcIl4xLjEuMFwiLFxuICAgICAgICBcImd1bHAtbWlycm9yXCI6IFwiXjEuMC4wXCIsXG4gICAgICAgIFwiZ3VscC1tb2NoYVwiOiBcIl4yLjIuMFwiLFxuICAgICAgICBcImd1bHAtcmVuYW1lXCI6IFwiXjEuMi4yXCIsXG4gICAgICAgIFwiZ3VscC1yZXBsYWNlXCI6IFwiXjAuNi4xXCIsXG4gICAgICAgIFwiZ3VscC11Z2xpZnlcIjogXCJeMy4wLjBcIixcbiAgICAgICAgXCJndWxwLXV0aWxcIjogXCJeMy4wLjhcIixcbiAgICAgICAgXCJndXRpbFwiOiBcIl4xLjYuNFwiLFxuICAgICAgICBcImhlYWRlclwiOiBcIl4wLjEuMVwiLFxuICAgICAgICBcIm11bHRpcGlwZVwiOiBcIl4yLjAuM1wiLFxuICAgICAgICBcIm11bHRpcGxlXCI6IFwiXjAuMi4xXCIsXG4gICAgICAgIFwicnVuLXNlcXVlbmNlXCI6IFwiXjEuMS40XCIsXG4gICAgICAgIFwidGhyb3VnaDJcIjogXCJeMi4wLjNcIixcbiAgICAgICAgXCJ2aW55bC1idWZmZXJcIjogXCJeMS4wLjFcIixcbiAgICAgICAgXCJ2aW55bC1zb3VyY2Utc3RyZWFtXCI6IFwiXjIuMC4wXCJcbiAgICB9XG59XG4iLCIvKiBnbG9iYWxzIGFsZXJ0ICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBkZXNjIEV4dGVuZCBmcm9tIHRoaXMgYmFzZSBjbGFzcyB1c2luZyBgQmFzZS5leHRlbmRgIHBlciBleGFtcGxlLlxuICogQGV4YW1wbGVcbiAqIHZhciBwcm90b3R5cGUgPSB7IC4uLiB9O1xuICogdmFyIGRlc2NlbmRhbnRDbGFzcyA9IEJhc2UuZXh0ZW5kKHByb3RvdHlwZX07XG4gKiBAY2xhc3NkZXNjIFRoaXMgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzcyBhdmFpbGFibGUgZm9yIGFsbCBIeXBlcmdyaWQgY2xhc3Nlcy5cbiAqL1xudmFyIEJhc2UgPSByZXF1aXJlKCdleHRlbmQtbWUnKS5CYXNlO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZS5wcm90b3R5cGUsICd2ZXJzaW9uJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IGZhbHNlLCAvLyByZWFkLW9ubHlcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG59KTtcblxuQmFzZS5wcm90b3R5cGUuZGVwcmVjYXRlZCA9IHJlcXVpcmUoJy4vbGliL2RlcHJlY2F0ZWQnKTtcbkJhc2UucHJvdG90eXBlLkh5cGVyZ3JpZEVycm9yID0gcmVxdWlyZSgnLi9saWIvZXJyb3InKTtcblxuQmFzZS5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24obWVzc2FnZSwgb25lcnJvcikge1xuICAgIHN3aXRjaCAob25lcnJvcikge1xuICAgICAgICBjYXNlICd3YXJuJzogY29uc29sZS53YXJuKG1lc3NhZ2UpOyBicmVhaztcbiAgICAgICAgY2FzZSAnYWxlcnQnOiBhbGVydChtZXNzYWdlKTsgYnJlYWs7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYWxlcnRcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IHRoaXMuSHlwZXJncmlkRXJyb3IobWVzc2FnZSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgZ2V0dGluZyB0aGUgdmFsdWUgd2hlbiB0aGF0IHZhbHVlIGNhbiBiZSBkZWZpbmVkIGFzIGEgZnVuY3Rpb24gdGhhdCBuZWVkcyB0byBiZSBjYWxsZWQgdG8gZ2V0IHRoZSBhY3R1YWwgKHByaW1pdGl2ZSkgdmFsdWUuXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEByZXR1cm5zIHsqfVxuICovXG5CYXNlLnByb3RvdHlwZS51bndyYXAgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICgodHlwZW9mIHZhbHVlKVswXSA9PT0gJ2YnKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kXG4gKiBAc3VtbWFyeSBNaXhlcyBzb3VyY2UgbWVtYmVycyBpbnRvIGNhbGxpbmcgY29udGV4dC5cbiAqIEBkZXNjIENvbnRleHQgaXMgdHlwaWNhbGx5IGVpdGhlciBhbiBpbnN0YW5jZSBvciB0aGUgKHNoYXJlZCkgcHJvdG90eXBlIG9mIGEgXCJjbGFzc1wiIGV4dGVuZGVkIGZyb20ge0BsaW5rIEJhc2V9IChzZWUgZXhhbXBsZXMpLlxuICpcbiAqIFR5cGljYWxseSB1c2VkIGJ5IHBsdWctaW5zLlxuICogQGV4YW1wbGVcbiAqIC8vIGRlZmluZSBpbnN0YW5jZSBtZW1iZXJzOiBteUdyaWQuZml4KCksIGV0Yy5cbiAqIG15R3JpZC5taXhJbih7IGZpeDogZnVuY3Rpb24oKSB7Li4ufSwgLi4uIH0pO1xuICogQGV4YW1wbGVcbiAqIC8vIGRlZmluZSBwcm90b3R5cGUgbWVtYmVyczogSHlwZXJncmlkLnByb3RvdHlwZS5maXgoKSwgZXRjLlxuICogSHlwZXJncmlkLnByb3RvdHlwZS5taXhJbih7IGZpeDogZnVuY3Rpb24oKSB7Li4ufSwgLi4uIH0pO1xuICogQFNlZSB7QGxpbmsgaHR0cHM6Ly9qb25laXQuZ2l0aHViLmlvL292ZXJyaWRlci9tb2R1bGUtb3ZlcnJpZGVyLmh0bSMubWl4SW59XG4gKiBAcGFyYW0ge29iamVjdH0gc291cmNlXG4gKi9cbkJhc2UucHJvdG90eXBlLm1peEluID0gcmVxdWlyZSgnb3ZlcnJpZGVyJykubWl4SW47XG5cblxuLyoqXG4gKiBAbWV0aG9kXG4gKiBAc3VtbWFyeSBJbnN0YW50aWF0ZSBhbiBvYmplY3Qgd2l0aCBkaXNjcmV0ZSArIHZhcmlhYmxlIGFyZ3MuXG4gKiBAZGVzYyBUaGUgZGlzY3JldGUgYXJncyBhcmUgcGFzc2VkIGZpcnN0LCBmb2xsb3dlZCBieSB0aGUgdmFyaWFibGUgYXJncy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSB2YXJpYWJsZUFyZ0FycmF5XG4gKiBAcGFyYW0gey4uLip9IGRpc2NyZXRlQXJnc1xuICogQHJldHVybnMge29iamVjdH0gT2JqZWN0IG9mIHR5cGUgYENvbnN0cnVjdG9yYCBuZXdseSBjb25zdHJ1Y3RvciB1c2luZyB0aGUgYXJndW1lbnRzIGluIGBhcnJheU9mQXJnc2AuXG4gKi9cbkJhc2UucHJvdG90eXBlLmNyZWF0ZUFwcGx5ID0gZnVuY3Rpb24oQ29uc3RydWN0b3IsIHZhcmlhYmxlQXJnQXJyYXksIGRpc2NyZXRlQXJncykge1xuICAgIHZhciBkaXNjcmV0ZUFyZ0FycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgICAgYXJncyA9IFtudWxsXSAvLyBudWxsIGlzIGNvbnRleHQgZm9yIGBiaW5kYCBjYWxsIGJlbG93XG4gICAgICAgICAgICAuY29uY2F0KGRpc2NyZXRlQXJnQXJyYXkpIC8vIGRpc2NyZXRlIGFyZ3VtZW50c1xuICAgICAgICAgICAgLmNvbmNhdCh2YXJpYWJsZUFyZ0FycmF5KSwgLy8gdmFyaWFibGUgYXJndW1lbnRzXG4gICAgICAgIEJvdW5kQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3Rvci5iaW5kLmFwcGx5KENvbnN0cnVjdG9yLCBhcmdzKTtcblxuICAgIHJldHVybiBuZXcgQm91bmRDb25zdHJ1Y3Rvcjtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBEYXRhU291cmNlQmFzZSgpIHt9XG5cbkRhdGFTb3VyY2VCYXNlLmV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZC1tZScpOyAvLyBtYWtlIGBleHRlbmRgLWFibGVcblxuRGF0YVNvdXJjZUJhc2UucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBEYXRhU291cmNlQmFzZS5wcm90b3R5cGUuY29uc3RydWN0b3IsXG5cbiAgICAkJENMQVNTX05BTUU6ICdEYXRhU291cmNlQmFzZScsXG5cbiAgICBpc051bGxPYmplY3Q6IHRydWUsXG5cbiAgICBkcmlsbERvd25DaGFyTWFwOiB7XG4gICAgICAgIHRydWU6ICdcXHUyNWJjJywgLy8gQkxBQ0sgRE9XTi1QT0lOVElORyBUUklBTkdMRSBha2EgJ+KWvCdcbiAgICAgICAgZmFsc2U6ICdcXHUyNWI2JywgLy8gQkxBQ0sgUklHSFQtUE9JTlRJTkcgVFJJQU5HTEUgYWthICfilrYnXG4gICAgICAgIHVuZGVmaW5lZDogJycsIC8vIGxlYWYgcm93cyBoYXZlIG5vIGNvbnRyb2wgZ2x5cGhcbiAgICAgICAgbnVsbDogJyAgICcgLy8gaW5kZW50XG4gICAgfSxcblxuICAgIERhdGFTb3VyY2VFcnJvcjogRGF0YVNvdXJjZUVycm9yLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24obmV4dERhdGFTb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG5leHREYXRhU291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBuZXh0RGF0YVNvdXJjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5zdGFsbChPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAaW1wbGVtZW50cyBkYXRhTW9kZWxBUEkjbmVlZHNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2Zpbi1oeXBlcmdyaWQuZ2l0aHViLmlvL2NvcmUvZG9jL2RhdGFNb2RlbEFQSS5odG1sI25lZWRzfG5lZWRzfVxuICAgICAqL1xuICAgIG5lZWRzOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVyID0gdGhpcywgc291cmNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtZXJba2V5XSAmJiB0cmFuc2Zvcm1lcltrZXldICE9PSBEYXRhU291cmNlQmFzZS5wcm90b3R5cGVba2V5XSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZSA9IHRyYW5zZm9ybWVyO1xuICAgICAgICAgICAgdHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lci5uZXh0O1xuICAgICAgICB9IHdoaWxlICh0cmFuc2Zvcm1lcik7XG5cbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGltcGxlbWVudHMgZGF0YU1vZGVsQVBJI2luc3RhbGxcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2Zpbi1oeXBlcmdyaWQuZ2l0aHViLmlvL2NvcmUvZG9jL2RhdGFNb2RlbEFQSS5odG1sI2luc3RhbGx8aW5zdGFsbH1cbiAgICAgKi9cbiAgICBpbnN0YWxsOiBmdW5jdGlvbihhcGksIGluc3RhbGwpIHtcbiAgICAgICAgdmFyIGRhdGFNb2RlbCA9IHRoaXMsXG4gICAgICAgICAgICBrZXlzID0gZ2V0RmlsdGVyZWRLZXlzKGFwaSA9IGFwaSB8fCB0aGlzKTtcblxuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFsbCkge1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBkYXRhTW9kZWwubmVlZHMuY2FsbChkYXRhTW9kZWwsIGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2Vba2V5XSA9IGFwaVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFEYXRhU291cmNlQmFzZS5wcm90b3R5cGVba2V5XSkge1xuICAgICAgICAgICAgICAgIERhdGFTb3VyY2VCYXNlLnByb3RvdHlwZVtrZXldID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRba2V5XS5hcHBseSh0aGlzLm5leHQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH0sXG5cblxuICAgIC8vIFNZTk9OWU1TXG5cbiAgICBpc1RyZWU6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNEcmlsbERvd24oeCk7XG4gICAgfSxcblxuICAgIGdldERhdGFJbmRleDogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSb3dJbmRleCh5KTtcbiAgICB9LFxuXG5cbiAgICAvLyBERUJVR0dJTkcgQUlEU1xuXG4gICAgZHVtcDogZnVuY3Rpb24obWF4KSB7XG4gICAgICAgIG1heCA9IE1hdGgubWluKHRoaXMuZ2V0Um93Q291bnQoKSwgbWF4IHx8IE1hdGgubWF4KDEwMCwgdGhpcy5nZXRSb3dDb3VudCgpKSk7XG4gICAgICAgIHZhciBkYXRhID0gW107XG4gICAgICAgIHZhciBzY2hlbWEgPSB0aGlzLmdldFNjaGVtYSgpO1xuICAgICAgICB2YXIgZmllbGRzID0gc2NoZW1hID8gc2NoZW1hLm1hcChmdW5jdGlvbihjcykgeyByZXR1cm4gY3MubmFtZTsgfSkgOiB0aGlzLmdldEhlYWRlcnMoKTtcbiAgICAgICAgdmFyIGNDb3VudCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIHZpZXdNYWtlc1NlbnNlID0gdGhpcy52aWV3TWFrZXNTZW5zZTtcbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBtYXg7IHIrKykge1xuICAgICAgICAgICAgdmFyIHJvdyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjQ291bnQ7IGMrKykge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLmdldFZhbHVlKGMsIHIpO1xuICAgICAgICAgICAgICAgIGlmIChjID09PSAwICYmIHZpZXdNYWtlc1NlbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHRoaXMuZml4SW5kZW50Rm9yVGFibGVEaXNwbGF5KHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJvd1tmaWVsZHNbY11dID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YVtyXSA9IHJvdztcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLnRhYmxlKGRhdGEpO1xuICAgIH1cbn07XG5cbi8vIGFwaSBjYW4gYmUgYXJyYXkgb3Igb2JqZWN0XG5mdW5jdGlvbiBnZXRGaWx0ZXJlZEtleXMoYXBpKSB7XG4gICAgdmFyIHdoaXRlbGlzdCA9IGFwaS5oYXNPd25Qcm9wZXJ0eSgnISFrZXlzJykgJiYgYXBpWychIWtleXMnXSxcbiAgICAgICAgYmxhY2tsaXN0ID0gYXBpLmhhc093blByb3BlcnR5KCcha2V5cycpICYmIGFwaVsnIWtleXMnXSxcbiAgICAgICAga2V5cyA9IEFycmF5LmlzQXJyYXkoYXBpKSA/IGFwaSA6IE9iamVjdC5rZXlzKGFwaSkuZmlsdGVyKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcGlba2V5XSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgfSk7XG5cbiAgICByZXR1cm4ga2V5cy5maWx0ZXIoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdpbml0aWFsaXplJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbnN0cnVjdG9yJzpcbiAgICAgICAgICAgIGNhc2UgJyEha2V5cyc6XG4gICAgICAgICAgICBjYXNlICcha2V5cyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEoXG4gICAgICAgICAgICB3aGl0ZWxpc3QgJiYgd2hpdGVsaXN0LmluZGV4T2Yoa2V5KSA8IDAgfHxcbiAgICAgICAgICAgIGJsYWNrbGlzdCAmJiBibGFja2xpc3QuaW5kZXhPZihrZXkpID49IDBcbiAgICAgICAgKTtcbiAgICB9KTtcbn1cblxuXG4vLyBEYXRhU291cmNlRXJyb3JcblxuZnVuY3Rpb24gRGF0YVNvdXJjZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG4vLyBleHRlbmQgZnJvbSBgRXJyb3JgXG5EYXRhU291cmNlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuXG4vLyBvdmVycmlkZSBlcnJvciBuYW1lIGRpc3BsYXllZCBpbiBjb25zb2xlXG5EYXRhU291cmNlRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnRGF0YVNvdXJjZUVycm9yJztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2VCYXNlO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERhdGFTb3VyY2VCYXNlID0gcmVxdWlyZSgnLi4vRGF0YXNhdXJCYXNlJyk7XG5cbi8qKiBAdHlwZWRlZiB7b2JqZWN0fSBjb2x1bW5TY2hlbWFPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIHJlcXVpcmVkIGNvbHVtbiBuYW1lLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtoZWFkZXJdIC0gQW4gb3ZlcnJpZGUgZm9yIGRlcml2ZWQgaGVhZGVyXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbY2FsY3VsYXRvcl0gLSBBIGZ1bmN0aW9uIGZvciBhIGNvbXB1dGVkIGNvbHVtbi4gVW5kZWZpbmVkIGZvciBub3JtYWwgZGF0YSBjb2x1bW5zLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0eXBlXSAtIFVzZWQgZm9yIHNvcnRpbmcgd2hlbiBhbmQgb25seSB3aGVuIGNvbXBhcmF0b3Igbm90IGdpdmVuLlxuICogQHByb3BlcnR5IHtvYmplY3R9IFtjb21wYXJhdG9yXSAtIEZvciBzb3J0aW5nLCBib3RoIG9mIGZvbGxvd2luZyByZXF1aXJlZDpcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGNvbXBhcmF0b3IuYXNjIC0gYXNjZW5kaW5nIGNvbXBhcmF0b3JcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGNvbXBhcmF0b3IuZGVzYyAtIGRlc2NlbmRpbmcgY29tcGFyYXRvclxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge29iamVjdFtdfSBbb3B0aW9ucy5kYXRhXVxuICogQHBhcmFtIHtvYmplY3RbXX0gW29wdGlvbnMuc2NoZW1hXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEYXRhU291cmNlTG9jYWwgPSBEYXRhU291cmNlQmFzZS5leHRlbmQoJ0RhdGFTb3VyY2VMb2NhbCcsIHtcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG5leHREYXRhU291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBUaGUgYXJyYXkgb2YgY29sdW1uIHNjaGVtYSBvYmplY3RzLlxuICAgICAgICAgKiBAbmFtZSBzY2hlbWFcbiAgICAgICAgICogQHR5cGUge2NvbHVtblNjaGVtYU9iamVjdFtdfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUxvY2FsI1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY2hlbWEgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgVGhlIGFycmF5IG9mIHVuaWZvcm0gZGF0YSBvYmplY3RzLlxuICAgICAgICAgKiBAbmFtZSBkYXRhXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3RbXX1cbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VMb2NhbCNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLmNhY2hlID0gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVzdGFibGlzaCBuZXcgZGF0YSBhbmQgc2NoZW1hLlxuICAgICAqIElmIG5vIGRhdGEgcHJvdmlkZWQsIGRhdGEgd2lsbCBiZSBzZXQgdG8gMCByb3dzLlxuICAgICAqIElmIG5vIHNjaGVtYSBwcm92aWRlZCBBTkQgbm8gcHJldmlvdXNseSBzZXQgc2NoZW1hLCBuZXcgc2NoZW1hIHdpbGwgYmUgZGVyaXZlZCBmcm9tIGRhdGEuXG4gICAgICogQHBhcmFtIHtvYmplY3RbXX0gW2RhdGE9W11dIC0gQXJyYXkgb2YgdW5pZm9ybSBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIGdyaWQgZGF0YS5cbiAgICAgKiBAcGFyYW0ge2NvbHVtblNjaGVtYU9iamVjdFtdfSBbc2NoZW1hPVtdXVxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlTG9jYWwjXG4gICAgICovXG4gICAgc2V0RGF0YTogZnVuY3Rpb24oZGF0YSwgc2NoZW1hKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBUaGUgYXJyYXkgb2YgdW5pZm9ybSBkYXRhIG9iamVjdHMuXG4gICAgICAgICAqIEBuYW1lIGRhdGFcbiAgICAgICAgICogQHR5cGUge29iamVjdFtdfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUxvY2FsI1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YSB8fCBbXTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuXG4gICAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2NoZW1hKHNjaGVtYSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLmxlbmd0aCAmJiAhdGhpcy5zY2hlbWEubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnNldFNjaGVtYShbXSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIG5ldyBkYXRhIGFuZCBzY2hlbWEuXG4gICAgICogSWYgbm8gZGF0YSBwcm92aWRlZCwgZGF0YSB3aWxsIGJlIGFzIGlzLlxuICAgICAqIElmIG5vIHNjaGVtYSBwcm92aWRlZCBBTkQgbm8gcHJldmlvdXNseSBzZXQgc2NoZW1hLCBuZXcgc2NoZW1hIHdpbGwgYmUgZGVyaXZlZCBmcm9tIGRhdGEuXG4gICAgICogQHBhcmFtIHtvYmplY3RbXX0gW2RhdGE9W11dIC0gQXJyYXkgb2YgdW5pZm9ybSBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIGdyaWQgZGF0YS5cbiAgICAgKiBAcGFyYW0ge2NvbHVtblNjaGVtYU9iamVjdFtdfSBbc2NoZW1hPVtdXVxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlTG9jYWwjXG4gICAgICovXG4gICAgYWRkRGF0YTogZnVuY3Rpb24oZGF0YSwgc2NoZW1hKSB7XG4gICAgICAgIHRoaXMuZGF0YS5wdXNoLmFwcGx5KHRoaXMuZGF0YSwgZGF0YSB8fCBbXSk7XG4gICAgICAgIHRoaXMub25DaGFuZ2UoKTtcblxuICAgICAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgICAgICB0aGlzLnNldFNjaGVtYShzY2hlbWEpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5sZW5ndGggJiYgIXRoaXMuc2NoZW1hLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTY2hlbWEoW10pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZmluLWh5cGVyZ3JpZC5naXRodWIuaW8vMy4wLjAvZG9jL2RhdGFNb2RlbEFQSSNnZXRTY2hlbWF9XG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VMb2NhbCNcbiAgICAgKi9cbiAgICBnZXRTY2hlbWE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWE7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2Zpbi1oeXBlcmdyaWQuZ2l0aHViLmlvLzMuMC4wL2RvYy9kYXRhTW9kZWxBUEkjc2V0U2NoZW1hfVxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlTG9jYWwjXG4gICAgICovXG4gICAgc2V0U2NoZW1hOiBmdW5jdGlvbihuZXdTY2hlbWEpIHtcbiAgICAgICAgaWYgKCFuZXdTY2hlbWEubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhUm93ID0gdGhpcy5kYXRhLmZpbmQoZGF0YVJvdyA9PiBkYXRhUm93KTtcbiAgICAgICAgICAgIGlmIChkYXRhUm93KSB7XG4gICAgICAgICAgICAgICAgbmV3U2NoZW1hID0gT2JqZWN0LmtleXMoZGF0YVJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNjaGVtYSA9IG5ld1NjaGVtYTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdkYXRhLXNjaGVtYS1jaGFuZ2VkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHBhcmFtIHRyZWVMZXZlbFxuICAgICAqIEByZXR1cm5zIHtkYXRhUm93T2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlTG9jYWwjXG4gICAgICovXG4gICAgZ2V0Um93OiBmdW5jdGlvbih5LCB0cmVlTGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFJvd0J5VHJlZUxldmVsKHRoaXMuZGF0YVt5XSwgdHJlZUxldmVsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIG9yIGJsYW5rIHJvdyBpbiBwbGFjZS5cbiAgICAgKlxuICAgICAqIF9Ob3RlIHBhcmFtZXRlciBvcmRlciBpcyB0aGUgcmV2ZXJzZSBvZiBgYWRkUm93YC5fXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2RhdGFSb3ddIC0gaWYgb21pdHRlZCBvciBvdGhlcndpc2UgZmFsc3ksIHJvdyByZW5kZXJzIGFzIGJsYW5rXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VMb2NhbCNcbiAgICAgKi9cbiAgICBzZXRSb3c6IGZ1bmN0aW9uKHksIGRhdGFSb3cpIHtcbiAgICAgICAgdGhpcy5kYXRhW3ldID0gZGF0YVJvdyB8fCB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9maW4taHlwZXJncmlkLmdpdGh1Yi5pby8zLjAuMC9kb2MvZGF0YU1vZGVsQVBJI2dldFJvd01ldGFkYXRhfVxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlTG9jYWwjXG4gICAgICovXG4gICAgZ2V0Um93TWV0YWRhdGE6IGZ1bmN0aW9uKHksIHByb3RvdHlwZSkge1xuICAgICAgICB2YXIgZGF0YVJvdyA9IHRoaXMuZGF0YVt5XTtcbiAgICAgICAgcmV0dXJuIGRhdGFSb3cgJiYgKGRhdGFSb3cuX19NRVRBIHx8IChwcm90b3R5cGUgIT09IHVuZGVmaW5lZCAmJiAoZGF0YVJvdy5fX01FVEEgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSkpKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZmluLWh5cGVyZ3JpZC5naXRodWIuaW8vMy4wLjAvZG9jL2RhdGFNb2RlbEFQSSNzZXRSb3dNZXRhZGF0YX1cbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUxvY2FsI1xuICAgICAqL1xuICAgIHNldFJvd01ldGFkYXRhOiBmdW5jdGlvbih5LCBtZXRhZGF0YSkge1xuICAgICAgICB2YXIgZGF0YVJvdyA9IHRoaXMuZGF0YVt5XTtcbiAgICAgICAgaWYgKGRhdGFSb3cpIHtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIGRhdGFSb3cuX19NRVRBID0gbWV0YWRhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhUm93Ll9fTUVUQTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISFkYXRhUm93O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgb3IgYXBwZW5kIGEgbmV3IHJvdy5cbiAgICAgKlxuICAgICAqIF9Ob3RlIHBhcmFtZXRlciBvcmRlciBpcyB0aGUgcmV2ZXJzZSBvZiBgc2V0Um93YC5fXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGFSb3dcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9SW5maW5pdHldIC0gVGhlIGluZGV4IG9mIHRoZSBuZXcgcm93LiBJZiBgeWAgPj0gcm93IGNvdW50LCByb3cgaXMgYXBwZW5kZWQgdG8gZW5kOyBvdGhlcndpc2Ugcm93IGlzIGluc2VydGVkIGF0IGB5YCBhbmQgcm93IGluZGV4ZXMgb2YgYWxsIHJlbWFpbmluZyByb3dzIGFyZSBpbmNyZW1lbnRlZC5cbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUxvY2FsI1xuICAgICAqL1xuICAgIGFkZFJvdzogZnVuY3Rpb24oZGF0YVJvdywgeSkge1xuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkIHx8IHkgPj0gdGhpcy5nZXRSb3dDb3VudCgpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEucHVzaChkYXRhUm93KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UoeSwgMCwgZGF0YVJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2RhdGEtc2hhcGUtY2hhbmdlZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgb3IgYXBwZW5kIGEgbmV3IHJvd3MuXG4gICAgICpcbiAgICAgKiBfTm90ZSBwYXJhbWV0ZXIgb3JkZXIgaXMgdGhlIHJldmVyc2Ugb2YgYHNldFJvd2AuX1xuICAgICAqIEBwYXJhbSB7YXJyYXl9IGRhdGFSb3dzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PUluZmluaXR5XSAtIFRoZSBpbmRleCBvZiB0aGUgbmV3IHJvdy4gSWYgYHlgID49IHJvdyBjb3VudCwgcm93IGlzIGFwcGVuZGVkIHRvIGVuZDsgb3RoZXJ3aXNlIHJvdyBpcyBpbnNlcnRlZCBhdCBgeWAgYW5kIHJvdyBpbmRleGVzIG9mIGFsbCByZW1haW5pbmcgcm93cyBhcmUgaW5jcmVtZW50ZWQuXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VMb2NhbCNcbiAgICAgKi9cbiAgICBhZGRSb3dzOiBmdW5jdGlvbihkYXRhUm93cywgeSkge1xuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkIHx8IHkgPj0gdGhpcy5nZXRSb3dDb3VudCgpKSB7XG4gICAgICAgICAgICB5ID0gdGhpcy5nZXRSb3dDb3VudCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YS5zcGxpY2UoeSwgMCwgLi4uZGF0YVJvd3MpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnZGF0YS1zaGFwZS1jaGFuZ2VkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvd3MgYXJlIHJlbW92ZWQgZW50aXJlbHkgYW5kIG5vIGxvbmdlciByZW5kZXIuXG4gICAgICogSW5kZXhlcyBvZiBhbGwgcmVtYWluaW5nIHJvd3MgYXJlIGRlY3JlYXNlZCBieSBgcm93Q291bnRgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyb3dDb3VudD0xXVxuICAgICAqIEByZXR1cm5zIHtkYXRhUm93T2JqZWN0W119XG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VMb2NhbCNcbiAgICAgKi9cbiAgICBkZWxSb3c6IGZ1bmN0aW9uKHksIHJvd0NvdW50KSB7XG4gICAgICAgIHZhciByb3dzID0gdGhpcy5kYXRhLnNwbGljZSh5LCByb3dDb3VudCA9PT0gdW5kZWZpbmVkID8gMSA6IHJvd0NvdW50KTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICBpZiAocm93cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnZGF0YS1zaGFwZS1jaGFuZ2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldERhdGFSb3dPYmplY3Q6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGUgJiYgKHggaW4gdGhpcy5jYWNoZSkgJiYgKHkgaW4gdGhpcy5jYWNoZVt4XSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlW3hdW3ldO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoeCBpbiB0aGlzLmNhY2hlKSkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZVt4XSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5kYXRhW3ldO1xuXG4gICAgICAgIGlmICghcm93IHx8IHggPiB0aGlzLmdldENvbHVtbkNvdW50KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAodGhpcy5jYWNoZVt4XVt5XSA9IHRoaXMuX2dldERhdGFSb3dPYmplY3RCeVJvd0FuZENvbHVtbkluZGV4KHJvdywgeCkpO1xuICAgIH0sXG5cbiAgICBpbmRleE9mOiBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7XG5cbiAgICAgICAgbGV0IGluZGV4ID0gZGF0YS5pbmRleE9mKHJvdyk7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgMCAmJiBkYXRhLnNvbWUoZCA9PiBkKSkge1xuICAgICAgICAgICAgZGF0YSA9IGRhdGEubWFwKGQgPT4gZC4kJGNoaWxkcmVuICYmIGQuJCRjaGlsZHJlblswXSk7XG4gICAgICAgICAgICBpbmRleCA9IGRhdGEuaW5kZXhPZihyb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICBfZ2V0Um93QnlUcmVlTGV2ZWw6IGZ1bmN0aW9uKHJvdywgdHJlZUxldmVsKSB7XG4gICAgICAgIGlmIChyb3cgJiYgcm93LiQkY2hpbGRyZW4gJiYgcm93Ll9fdHJlZUxldmVsICE9PSB0cmVlTGV2ZWwpIHtcbiAgICAgICAgICAgIHdoaWxlIChyb3cuX190cmVlTGV2ZWwgIT09IHRyZWVMZXZlbCkge1xuICAgICAgICAgICAgICAgIGlmIChyb3cuJCRjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXQgbGFzdCBsZXZlbCB1c2UgdGhpcyBsZXZlbFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJvdy4kJG9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXQgb3BlbiByb3csIHdlIG5lZWQgdG8gZ28gZGVlcGVyXG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IHJvdy4kJGNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0IGNsb3NlZCByb3cgdXNlIHBhcmVudCByb3dcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3c7XG4gICAgfSxcblxuICAgIF9nZXREYXRhUm93T2JqZWN0QnlSb3dBbmRDb2x1bW5JbmRleDogZnVuY3Rpb24ocm93LCB4KSB7XG4gICAgICAgIGNvbnN0IGNvbHVtbk5hbWUgPSB0aGlzLmdldENvbHVtbk5hbWUoeCk7XG4gICAgICAgIGNvbnN0IHRyZWVMZXZlbCA9IHRoaXMuZ2V0Q29sdW1uVHJlZUxldmVsKHgpO1xuXG4gICAgICAgIHJvdyA9IHRoaXMuX2dldFJvd0J5VHJlZUxldmVsKHJvdywgdHJlZUxldmVsKTtcblxuICAgICAgICBpZiAoY29sdW1uTmFtZSBpbiByb3cpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGZvdW5kZWRWYWx1ZTogcm93W2NvbHVtbk5hbWVdIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdmFsdWUgaWYga2V5IGNvbnNpc3RzIG9mIGpvaW5lZCBrZXlzXG4gICAgICAgIGxldCBmb3VuZGVkVmFsdWUsIHNraXBOZWVkZWQgPSBmYWxzZTtcbiAgICAgICAgZm91bmRlZFZhbHVlID0gcm93W09iamVjdC5rZXlzKHJvdykuZmluZCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBsZXQgY29tYmluZWRDb2x1bW5zID0ga2V5LnNwbGl0KCcvJyk7XG4gICAgICAgICAgICBza2lwTmVlZGVkID0gc2tpcE5lZWRlZCB8fCBjb21iaW5lZENvbHVtbnMuaW5jbHVkZXMoY29sdW1uTmFtZSkgJiYgY29tYmluZWRDb2x1bW5zWzBdICE9PSBjb2x1bW5OYW1lO1xuICAgICAgICAgICAgcmV0dXJuIGNvbWJpbmVkQ29sdW1uc1swXSA9PT0gY29sdW1uTmFtZTtcbiAgICAgICAgfSldO1xuXG4gICAgICAgIHJldHVybiB7IGZvdW5kZWRWYWx1ZSwgc2tpcE5lZWRlZCB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBnZXQgY291bnQgdmFsdWUgZm9yIHNvbWUgY2VsbCBvZiBkYXRhIGdyaWRcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUxvY2FsI1xuICAgICAqL1xuICAgIGdldENvdW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzLl9nZXREYXRhUm93T2JqZWN0KHgsIHkpLmZvdW5kZWRWYWx1ZTtcblxuICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwgJiYgdmFsLmNvdW50ICYmIHZhbC5jb3VudCAhPT0gbnVsbCA/IHZhbC5jb3VudCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRDaGlsZENvbHVtbnNGcm9tQ2VsbDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcy5fZ2V0RGF0YVJvd09iamVjdCh4LCB5KS5mb3VuZGVkVmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHZhbFxuICAgICAgICAgICAgJiYgdmFsLmNoaWxkQ29sdW1uRGVmc1xuICAgICAgICAgICAgJiYgdmFsLmNoaWxkQ29sdW1uRGVmcyAhPT0gbnVsbFxuICAgICAgICAgICAgJiYgdmFsLmNoaWxkQ29sdW1uRGVmcyAhPT0gdW5kZWZpbmVkID8gdmFsLmNoaWxkQ29sdW1uRGVmcyA6IFtdO1xuICAgIH0sXG5cbiAgICBnZXRIYXNDaGlsZENvbHVtbnNGcm9tQ2VsbDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBjb25zdCBjaGlsZENvbHVtbnNBcnJheSA9IHRoaXMuZ2V0Q2hpbGRDb2x1bW5zRnJvbUNlbGwoeCwgeSk7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkQ29sdW1uc0FycmF5ICYmIGNoaWxkQ29sdW1uc0FycmF5Lmxlbmd0aCAhPT0gdW5kZWZpbmVkID8gY2hpbGRDb2x1bW5zQXJyYXkubGVuZ3RoID4gMCA6IGZhbHNlO1xuICAgIH0sXG5cbiAgICBnZXRJc0NvbHVtbk9wZW5CeURlZmF1bHRGcm9tQ2VsbDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcy5fZ2V0RGF0YVJvd09iamVjdCh4LCB5KS5mb3VuZGVkVmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsICYmIHZhbC5jb2x1bW5PcGVuQnlEZWZhdWx0ICYmIHZhbC5jb2x1bW5PcGVuQnlEZWZhdWx0ICE9PSBudWxsID8gdmFsLmNvbHVtbk9wZW5CeURlZmF1bHQgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRJc0NvbHVtbkdyb3VwU2hvd0Zyb21DZWxsOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzLl9nZXREYXRhUm93T2JqZWN0KHgsIHkpLmZvdW5kZWRWYWx1ZTtcblxuICAgICAgICBjb25zdCBzaG93blZhbHVlcyA9IFsnYWx3YXlzLXNob3dpbmcnLCAnb3BlbiddO1xuXG4gICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHZhbC5jb2x1bW5Hcm91cFNob3cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsICYmIHZhbC5jb2x1bW5Hcm91cFNob3dcbiAgICAgICAgICAgICAgICA/IHNob3duVmFsdWVzLmluZGV4T2YodmFsLmNvbHVtbkdyb3VwU2hvdykgPiAtMVxuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uR3JvdXBJZEZyb21DZWxsOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzLl9nZXREYXRhUm93T2JqZWN0KHgsIHkpLmZvdW5kZWRWYWx1ZTtcblxuICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwgJiYgdmFsLmdyb3VwSWQgJiYgdmFsLmdyb3VwSWQgIT09IG51bGwgPyB2YWwuZ3JvdXBJZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2Zpbi1oeXBlcmdyaWQuZ2l0aHViLmlvLzMuMC4wL2RvYy9kYXRhTW9kZWxBUEkjZ2V0VmFsdWV9XG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VMb2NhbCNcbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBsZXQgZm91bmRlZERhdGFSb3dWYWx1ZSA9IHRoaXMuX2dldERhdGFSb3dPYmplY3QoeCwgeSkuZm91bmRlZFZhbHVlO1xuXG4gICAgICAgIGlmIChmb3VuZGVkRGF0YVJvd1ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZGVkRGF0YVJvd1ZhbHVlICYmIGZvdW5kZWREYXRhUm93VmFsdWUudmFsdWUgPyBmb3VuZGVkRGF0YVJvd1ZhbHVlLnZhbHVlIDogZm91bmRlZERhdGFSb3dWYWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2Zpbi1oeXBlcmdyaWQuZ2l0aHViLmlvLzMuMC4wL2RvYy9kYXRhTW9kZWxBUEkjc2V0VmFsdWV9XG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VMb2NhbCNcbiAgICAgKi9cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IGZvdW5kZWREYXRhUm93VmFsdWUgPSB0aGlzLl9nZXREYXRhUm93T2JqZWN0KHgsIHkpLmZvdW5kZWRWYWx1ZTtcblxuICAgICAgICBpZiAoZm91bmRlZERhdGFSb3dWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3VuZGVkRGF0YVJvd1ZhbHVlID09PSAnb2JqZWN0JyAmJiAhIWZvdW5kZWREYXRhUm93VmFsdWUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmb3VuZGVkRGF0YVJvd1ZhbHVlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvdW5kZWREYXRhUm93VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFbeV1bdGhpcy5nZXRDb2x1bW5OYW1lKHgpXSA9IGZvdW5kZWREYXRhUm93VmFsdWU7XG4gICAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9maW4taHlwZXJncmlkLmdpdGh1Yi5pby8zLjAuMC9kb2MvZGF0YU1vZGVsQVBJI2dldFZhbHVlfVxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlTG9jYWwjXG4gICAgICovXG4gICAgZ2V0RGVmaW5lZENlbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIGxldCBmb3VuZGVkRGF0YVJvd1ZhbHVlID0gdGhpcy5fZ2V0RGF0YVJvd09iamVjdCh4LCB5KS5mb3VuZGVkVmFsdWU7XG5cbiAgICAgICAgaWYgKGZvdW5kZWREYXRhUm93VmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIGZvdW5kZWREYXRhUm93VmFsdWUgPT09ICdvYmplY3QnICYmICEhZm91bmRlZERhdGFSb3dWYWx1ZS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZm91bmRlZERhdGFSb3dWYWx1ZS5wcm9wZXJ0aWVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAZGVzYyBnZXQgY29sc3BhbiBvZiBhbiBjZWxsLCBpZiBleGlzdC4gT3RoZXJ3aXNlLCByZXR1cm5zIDA7XG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICovXG4gICAgZ2V0Q29sc3BhbjogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBsZXQgZGF0YVJvd09iamVjdCA9IHRoaXMuX2dldERhdGFSb3dPYmplY3QoeCwgeSk7XG4gICAgICAgIGNvbnN0IGZvdW5kZWREYXRhUm93VmFsdWUgPSBkYXRhUm93T2JqZWN0LmZvdW5kZWRWYWx1ZTtcblxuICAgICAgICBpZiAoZm91bmRlZERhdGFSb3dWYWx1ZSAmJiB0eXBlb2YgZm91bmRlZERhdGFSb3dWYWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChmb3VuZGVkRGF0YVJvd1ZhbHVlLmNvbHNwYW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmRlZERhdGFSb3dWYWx1ZS5jb2xzcGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRhdGFSb3dPYmplY3Quc2tpcE5lZWRlZCkge1xuICAgICAgICAgICAgbGV0IGkgPSB4O1xuICAgICAgICAgICAgd2hpbGUgKGRhdGFSb3dPYmplY3Quc2tpcE5lZWRlZCkge1xuICAgICAgICAgICAgICAgIGRhdGFSb3dPYmplY3QgPSB0aGlzLl9nZXREYXRhUm93T2JqZWN0KC0taSwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YVJvd09iamVjdC5mb3VuZGVkVmFsdWUgPyBkYXRhUm93T2JqZWN0LmZvdW5kZWRWYWx1ZS5jb2xzcGFuIC0gKHggLSBpKSA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgZ2V0IGFkZGl0aW9uYWwgd2lkdGggYmFzZWQgb24gY29sc3BhblxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldEFkZGl0aW9uYWxXaWR0aDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBsZXQgYWRkaXRpb25hbCA9IDA7XG4gICAgICAgIGNvbnN0IGNvbHNwYW4gPSB0aGlzLmdldENvbHNwYW4oeCwgeSk7XG4gICAgICAgIGZvciAobGV0IGkgPSB4ICsgMTsgaSA8PSB4ICsgY29sc3BhbjsgaSsrKSB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsICs9IHRoaXMuZ3JpZC5nZXRDb2x1bW5XaWR0aChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkaXRpb25hbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBkZXNjIGdldCByb3dzcGFuIG9mIGFuIGNlbGwsIGlmIGV4aXN0LiBPdGhlcndpc2UsIHJldHVybnMgMDtcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICBnZXRSb3dzcGFuOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIGxldCBmb3VuZGVkRGF0YVJvd1ZhbHVlID0gdGhpcy5fZ2V0RGF0YVJvd09iamVjdCh4LCB5KS5mb3VuZGVkVmFsdWU7XG5cbiAgICAgICAgaWYgKGZvdW5kZWREYXRhUm93VmFsdWUgJiYgdHlwZW9mIGZvdW5kZWREYXRhUm93VmFsdWUgPT09ICdvYmplY3QnICYmICEhZm91bmRlZERhdGFSb3dWYWx1ZS5yb3dzcGFuKSB7XG4gICAgICAgICAgICByZXR1cm4gZm91bmRlZERhdGFSb3dWYWx1ZS5yb3dzcGFuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgZ2V0IGFkZGl0aW9uYWwgaGVpZ2h0IGJhc2VkIG9uIGNvbHNwYW5cbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRBZGRpdGlvbmFsSGVpZ2h0OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIGxldCBhZGRpdGlvbmFsID0gMDtcbiAgICAgICAgY29uc3Qgcm93c3BhbiA9IHRoaXMuZ2V0Um93c3Bhbih4LCB5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHkgKyAxOyBpIDw9IHkgKyByb3dzcGFuOyBpKyspIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWwgKz0gdGhpcy5ncmlkLmdldFJvd0hlaWdodChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkaXRpb25hbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqL1xuICAgIGlzQ29sc3BhbmVkQnlMZWZ0Q29sdW1uOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIGxldCByb3dWYWx1ZSA9IHRoaXMuX2dldERhdGFSb3dPYmplY3QoeCwgeSk7XG5cbiAgICAgICAgcmV0dXJuICEhcm93VmFsdWUuZm91bmRlZFZhbHVlICYmIHJvd1ZhbHVlLmZvdW5kZWRWYWx1ZS5pc0NvbHNwYW5lZEJ5Q29sdW1uO1xuICAgICAgICAvLyByZXR1cm4gdGhpcy5fZ2V0RGF0YVJvd09iamVjdCh4LCB5KS5za2lwTmVlZGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICovXG4gICAgZ2V0Um93c3Bhbk1haW5Sb3c6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgbGV0IGNlbGxPblJvdyA9IHRoaXMuX2dldERhdGFSb3dPYmplY3QoeCwgeSk7XG5cbiAgICAgICAgcmV0dXJuICEhY2VsbE9uUm93LmZvdW5kZWRWYWx1ZSAmJiBjZWxsT25Sb3cuZm91bmRlZFZhbHVlLnJvd3NwYW5lZEJ5Um93ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gY2VsbE9uUm93LmZvdW5kZWRWYWx1ZS5yb3dzcGFuZWRCeVJvd1xuICAgICAgICAgICAgOiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICovXG4gICAgZ2V0Q29sc3Bhbk1haW5Db2x1bW5OYW1lOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIGxldCBjZWxsT25Sb3cgPSB0aGlzLl9nZXREYXRhUm93T2JqZWN0KHgsIHkpO1xuXG4gICAgICAgIHJldHVybiAhIWNlbGxPblJvdy5mb3VuZGVkVmFsdWUgJiYgY2VsbE9uUm93LmZvdW5kZWRWYWx1ZS5jb2xzcGFuZWRCeUNvbHVtbiA/IGNlbGxPblJvdy5mb3VuZGVkVmFsdWUuY29sc3BhbmVkQnlDb2x1bW4gOiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICovXG4gICAgaXNSb3dzcGFuZWRCeVJvdzogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBsZXQgY2VsbE9uUm93ID0gdGhpcy5fZ2V0RGF0YVJvd09iamVjdCh4LCB5KTtcblxuICAgICAgICByZXR1cm4gISFjZWxsT25Sb3cuZm91bmRlZFZhbHVlICYmIGNlbGxPblJvdy5mb3VuZGVkVmFsdWUuaXNSb3dzcGFuZWRCeVJvdztcbiAgICB9LFxuXG4gICAgaXNSZW5kZXJTa2lwTmVlZGVkOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzUm93c3BhbmVkQnlSb3coeCwgeSkgfHwgdGhpcy5pc0NvbHNwYW5lZEJ5TGVmdENvbHVtbih4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9maW4taHlwZXJncmlkLmdpdGh1Yi5pby8zLjAuMC9kb2MvZGF0YU1vZGVsQVBJI2dldFJvd0NvdW50fVxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlTG9jYWwjXG4gICAgICovXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9maW4taHlwZXJncmlkLmdpdGh1Yi5pby8zLjAuMC9kb2MvZGF0YU1vZGVsQVBJI2dldENvbHVtbkNvdW50fVxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlTG9jYWwjXG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWEubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5OYW1lOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHgpWzBdID09PSAnbicgJiYgdGhpcy5zY2hlbWFbeF0gPyB0aGlzLnNjaGVtYVt4XS5uYW1lIDogeDtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uVHJlZUxldmVsOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHgpWzBdID09PSAnbicgJiYgdGhpcy5zY2hlbWFbeF0gJiYgdGhpcy5zY2hlbWFbeF0uY29sRGVmID8gdGhpcy5zY2hlbWFbeF0uY29sRGVmLnRyZWVMZXZlbCA6IHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgZ2V0Um93c1dpdGhWYWx1ZXNDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuZmlsdGVyKGQgPT4gIWQuJCRibGFua19ub2RlKS5sZW5ndGggLSB0aGlzLmdyaWQuZ2V0RmljdGl2ZUhlYWRlclJvd3NDb3VudCgpO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5zV2l0aFZhbHVlc0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5iZWhhdmlvci5jb2x1bW5zLmZpbHRlcihjID0+ICEhYy5jb2xEZWYpLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgdGVsbHMgaWYgdmFsdWUgaXMgbGluayBvciBhcnJheSBjb250YWlucyBsaW5rXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNWYWx1ZVVybCh2YWx1ZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmdVcmwodikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGlzU3RyaW5nVXJsKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8vIG5leHQgdHdvIG1ldGhvZHMgY29waWVkIGZyb20gZGF0YWRvY3NcbiAgICBnZXRIaWdobGlnaHRSZWdleChtYXRjaCwgc2VhcmNoVHlwZSkge1xuICAgICAgICBjb25zdCB3b3JkcyA9IG1hdGNoLnNwbGl0KC9bICxdKyhcXCguKj9cXCkpPy8pLmZpbHRlcihlID0+ICEhZSkuam9pbignfCcpO1xuICAgICAgICBjb25zdCBmbGFncyA9ICdnaSc7XG4gICAgICAgIGNvbnN0IGFudGlUYWdSZWdFeHAgPSAnKD8hW148Pl0qKChbXFwvXFxcIlxcJ118XV18XFxiKT4pKSc7XG4gICAgICAgIGlmIChzZWFyY2hUeXBlID09PSAnRVhBQ1RfTUFUQ0gnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXFxcXGInICsgd29yZHMgKyAnXFxcXGInICsgYW50aVRhZ1JlZ0V4cCwgZmxhZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKHNlYXJjaFR5cGUgPT09ICdFREdFJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJ1xcXFxiJyArIHdvcmRzICsgYW50aVRhZ1JlZ0V4cCwgZmxhZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKHNlYXJjaFR5cGUgPT09ICdGVUxMJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAod29yZHMgKyBhbnRpVGFnUmVnRXhwLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0SGlnaGxpZ2h0ZWRWYWx1ZShzdHIsIG1hdGNoLCBzZWFyY2hUeXBlKSB7XG4gICAgICAgIGlmICghbWF0Y2ggfHwgIXN0ciB8fCBzZWFyY2hUeXBlID09PSAnTk9ORScgfHwgc2VhcmNoVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWcgPSB0aGlzLmdldEhpZ2hsaWdodFJlZ2V4KG1hdGNoLCBzZWFyY2hUeXBlKTtcblxuICAgICAgICBpZiAoIXJlZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoc3RyICsgJycpLnJlcGxhY2UocmVnLCAnPG1hcms+JCY8L21hcms+Jyk7XG4gICAgfSxcblxuICAgIG9uQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLmNhY2hlID0gW107XG4gICAgICAgIHRoaXMuX2RhdGEgPSB0aGlzLl9kYXRhLmZpbHRlcihkID0+ICFkLiQkYmxhbmtfbm9kZSk7XG4gICAgICAgIGNvbnN0IG1pbmltdW1Sb3dDb3VudCA9IHRoaXMuZ3JpZCAmJiB0aGlzLmdyaWQucHJvcGVydGllcy5taW5pbXVtUm93Q291bnQgfHwgNTA7XG4gICAgICAgIHdoaWxlICh0aGlzLl9kYXRhLmxlbmd0aCA8IG1pbmltdW1Sb3dDb3VudCkge1xuICAgICAgICAgICAgdGhpcy5fZGF0YS5wdXNoKHsgWyckJGJsYW5rX25vZGUnXTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfSxcbiAgICBzZXQgZGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmNhY2hlID0gW107XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nVXJsKHN0cmluZykge1xuICAgIGlmICghc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgVVJMX1JFR0VYUCA9IC9eKFxccyooaHR0cHxodHRwc3xmdHB8ZnRwc3xpdG1zcylcXDpcXC9cXC9bYS16QS1aMC05XFwtXFwuXStcXC5bYS16QS1aXXsyLDZ9KFxcL1teXFxzLDtdKik/KSQvZzsgLy8gY29weSBmcm9tIGRhdGFkb2NcbiAgICByZXR1cm4gVVJMX1JFR0VYUC50ZXN0KHN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNvdXJjZUxvY2FsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4vKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi9cblxuY29uc3Qgb3JpZW50YXRpb25IYXNoZXMgPSByZXF1aXJlKCcuL29yaWVudGF0aW9uSGFzaGVzJyk7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBmaW5CYXJcbiAqIEB0eXBlIHtGaW5CYXJ9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgRmluQmFyVG91Y2gge1xuICAgIGNvbnN0cnVjdG9yKGZpbkJhcikge1xuICAgICAgICB0aGlzLmZpbkJhciA9IGZpbkJhcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgZmxhZyB0byBkZXRlY3QgaXMgbW91c2Ugd2FzIGNvbnRpbnVvdXNseSBjbGlja2VkIG92ZXIgc2Nyb2xsYmFyIChub3QgdGh1bWIpXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAbWVtYmVyT2YgRmluQmFyVG91Y2gucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzVG91Y2hIb2xkT3ZlckJhciA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBmbGFnIHRvIGRldGVjdCBpcyB1c2VyIHRvdWNoIHN0YXJ0cyBvdmVyIGNvbnRhaW5lciAodXNlZCB0byBzbW9vdGggc2Nyb2xsIG9uIG1vYmlsZSBkZXZpY2VzKVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQG1lbWJlck9mIEZpbkJhclRvdWNoLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc1RvdWNoSG9sZE92ZXJDb250YWluZXIgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgY29udGFpbnMgbGFzdCBkZXRlY3RlZCBwb3NpdGlvbiBvZiB1c2VyIHRvdWNoXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ8bnVsbH1cbiAgICAgICAgICogQG1lbWJlck9mIEZpbkJhclRvdWNoLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250YWluZXJMYXN0VG91Y2hQb3MgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBjb250YWlucyBsYXN0IGRldGVjdGVkIHVzZXIgdG91Y2ggdGltZSAodGltZXN0YW1wKVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfG51bGx9XG4gICAgICAgICAqIEBtZW1iZXJPZiBGaW5CYXJUb3VjaC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGFpbmVyTGFzdFRvdWNoVGltZSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IGNvbnRhaW5zIGN1cnJlbnQgdXNlciB0b3VjaCBtb3ZlIHZlbG9jaXR5XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBtZW1iZXJPZiBGaW5CYXJUb3VjaC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGFpbmVyVG91Y2hWZWxvY2l0eSA9IDA7XG5cbiAgICAgICAgLy8gLyoqXG4gICAgICAgIC8vICAqIEBzdW1tYXJ5IGNvbnRhaW5zIGN1cnJlbnQgdXNlciB0b3VjaCBtb3ZlIHZlbG9jaXR5IGxpbWl0XG4gICAgICAgIC8vICAqIEBkZXNjcmlwdGlvbiB1c2UgdGhpcyB2YXJpYWJsZSBmb3IgdHVuaW5nIGtpbmV0aWMgc2Nyb2xsIHNwZWVkXG4gICAgICAgIC8vICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgIC8vICAqIEBtZW1iZXJPZiBGaW5CYXJUb3VjaC5wcm90b3R5cGVcbiAgICAgICAgLy8gICovXG4gICAgICAgIC8vIHRoaXMuY29udGFpbmVyVG91Y2hWZWxvY2l0eU1heCA9IDIwMDAwO1xuXG4gICAgICAgIC8vIC8qKlxuICAgICAgICAvLyAgKiBAZGVwcmVjYXRlZCB1c2UgY29udGFpbmVyVG91Y2hWZWxvY2l0eU1vZGlmaWVyIGZyb20gaGFzaGVkIGluc3RlYWRcbiAgICAgICAgLy8gICogQHN1bW1hcnkgbXVsdGlwbGllciBmb3Igc3RhcnQgc2Nyb2xsIHNwZWVkIGNhbGN1bGF0aW9uXG4gICAgICAgIC8vICAqIEBkZXNjcmlwdGlvbiB1c2UgdGhpcyB2YXJpYWJsZSBmb3IgdHVuaW5nIGtpbmV0aWMgc2Nyb2xsIHNwZWVkXG4gICAgICAgIC8vICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgIC8vICAqIEBtZW1iZXJPZiBGaW5CYXJUb3VjaC5wcm90b3R5cGVcbiAgICAgICAgLy8gICovXG4gICAgICAgIC8vIHRoaXMuY29udGFpbmVyVG91Y2hWZWxvY2l0eU1vZGlmaWVyID0gNC4yO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBjb250YWlucyBjdXJyZW50IHVzZXIgdG91Y2ggbW92ZSBhbXBsaXR1ZGVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQG1lbWJlck9mIEZpbkJhclRvdWNoLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250YWluZXJUb3VjaEFtcGxpdHVkZSA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IGNvbnRhaW5zIGN1cnJlbnQgc21vb3RoIHRvdWNoIHNjcm9sbCBpbnRlcnZhbC4gVXNlZCB0byBzbW9vdGhseSBzY3JvbGwgY29udGVudFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRmluQmFyVG91Y2gucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRhaW5lclRvdWNoU2Nyb2xsSW50ZXJ2YWwgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBjb250YWlucyBjdXJyZW50IHVzZXIgdG91Y2ggbW92ZSBvZmZzZXRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQG1lbWJlck9mIEZpbkJhclRvdWNoLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250YWluZXJUb3VjaFNjcm9sbE9mZnNldCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IGNvbnRhaW5zIGN1cnJlbnQgdXNlciB0b3VjaCBtb3ZlIHRhcmdldC4gVXNlZCB0byBkZXRlY3QgZW5kIHBvc2l0aW9uIG9mIHNtb290aCBzY3JvbGxcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQG1lbWJlck9mIEZpbkJhclRvdWNoLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250YWluZXJUb3VjaFNjcm9sbFRhcmdldCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5pc0xhc3RUb3VjaE92ZXJCYXIgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBpbnRlcnZhbCB3aGljaCB1c2VkIHdoZW4gbW91c2UgaG9sZCBzY3JvbGwgcGVyZm9ybWVkXG4gICAgICAgICAqIEBkZXNjIHRhYmxlIHdpbGwgYmUgc2Nyb2xsZWQgb24gb25lIGZ1bGwgcGFnZSB3aXRoIHRoaXMgaW50ZXJ2YWwgdW50aWwgbW91c2UgaG9sZCBlbmRzXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBtZW1iZXJPZiBGaW5CYXJUb3VjaC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubW91c2VIb2xkUGVyZm9ybUludGVydmFsUmF0ZSA9IDUwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAc3VtbWFyeSB1dGlsaXR5IGZpZWxkIHRoYXQgY29udGFpbnMgbW91c2VIb2xkIHByb2Nlc3NpbmcgaW50ZXJ2YWwgaWRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQG1lbWJlck9mIEZpbkJhclRvdWNoLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3VzZUhvbGRQZXJmb3JtSW50ZXJ2YWwgPSAwO1xuXG4gICAgICAgIHRoaXMubW91c2VIb2xkUGVyZm9ybUludGVydmFsQ3VycmVudENvb3Jkc09iaiA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBzdW1tYXJ5IHV0aWxpdHkgZmllbGQgdGhhdCBjb250YWlucyB0aW1lb3V0IGlkLCB3aGljaCB1c2VkIHdoZW4gbW9zZUhvbGQgcHJvY2Vzc2luZyBzdGFydHNcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQG1lbWJlck9mIEZpbkJhclRvdWNoLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3VzZUhvbGRQZXJmb3JtVGltZW91dCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBzdW1tYXJ5IGZsYWcgdG8gZGV0ZWN0IHRoYXQgdXNlciBjbGlja2VkIG92ZXIgdGh1bWIsIGFuZCBzY3JvbGwgbmVlZCB0byBiZSBwZXJmb3JtZWQgZXhhY3RseSB0byB0aGF0IHBvaW50XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAbWVtYmVyT2YgRmluQmFyVG91Y2gucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzVGh1bWJEcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBzdW1tYXJ5IGZsYWcgdG8gZGV0ZWN0IHRoYXQgdXNlciBzdGFydCB0b3VjaCBtb3ZlIG92ZXIgdGh1bWIsIGFuZCBzY3JvbGwgbmVlZCB0byBiZSBwbGFjZWQgYmFzZWQgb24gbW91c2UgcG9zaXRpb25cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBtZW1iZXJPZiBGaW5CYXJUb3VjaC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNUaHVtYlRvdWNoRHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBuYW1lIHBhZ2luZ1xuICAgICAgICAgKiBAc3VtbWFyeSBFbmFibGUgcGFnZSB1cC9kbiBjbGlja3MuXG4gICAgICAgICAqIEBkZXNjIFNldCBieSB0aGUgY29uc3RydWN0b3IuIFNlZSB0aGUgc2ltaWxhcmx5IG5hbWVkIHByb3BlcnR5IGluIHRoZSB7QGxpbmsgZmluYmFyT3B0aW9uc30gb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0cnV0aHksIGxpc3RlbiBmb3IgY2xpY2tzIGluIHBhZ2UtdXAgYW5kIHBhZ2UtZG93biByZWdpb25zIG9mIHNjcm9sbGJhci5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYW4gb2JqZWN0LCBjYWxsIGAucGFnaW5nLnVwKClgIG9uIHBhZ2UtdXAgY2xpY2tzIGFuZCBgLnBhZ2luZy5kb3duKClgIHdpbGwgYmUgY2FsbGVkIG9uIHBhZ2UtZG93biBjbGlja3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIENoYW5naW5nIHRoZSB0cnV0aGluZXNzIG9mIHRoaXMgdmFsdWUgYWZ0ZXIgaW5zdGFudGlhdGlvbiBjdXJyZW50bHkgaGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW58b2JqZWN0fVxuICAgICAgICAgKiBAbWVtYmVyT2YgRmluQmFyVG91Y2gucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhZ2luZyA9IHRydWU7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzdW1tYXJ5IHV0aWxpdHkgbWV0aG9kIHRvIHVuaWZ5IGxvZ2ljIHdoZW4gdXNlciBzdG9wcyBob2xkaW5nIG1vdXNlIG9uIGVtcHR5IHNjcm9sbCBiYXIgc3BhY2VcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXJUb3VjaC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwZXJmb3JtTW91c2VIb2xkT3ZlckJhckVuZCgpIHtcbiAgICAgICAgdGhpcy5pc1RvdWNoSG9sZE92ZXJCYXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb3VzZUhvbGRQZXJmb3JtSW50ZXJ2YWxDdXJyZW50Q29vcmRzT2JqID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMubW91c2VIb2xkUGVyZm9ybUludGVydmFsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMubW91c2VIb2xkUGVyZm9ybUludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMubW91c2VIb2xkUGVyZm9ybUludGVydmFsID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xlYXJNb3VzZUhvbGRUaW1lb3V0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc3VtbWFyeSB1dGlsaXR5IG1ldGhvZCB0byBwZXJmb3JtIGNsZWFyaW5nIG9mIGFuIG1vdXNlSG9sZCB0aW1lb3V0LFxuICAgICAqIGlmIHVzZXIgc3RvcHMgaG9sZGluZyBtb3VzZSBiZWZvcmUgdGltZW91dCBmdW5jdGlvbiBmb3JrXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyVG91Y2gucHJvdG90eXBlXG4gICAgICovXG4gICAgY2xlYXJNb3VzZUhvbGRUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy5tb3VzZUhvbGRQZXJmb3JtVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubW91c2VIb2xkUGVyZm9ybVRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5tb3VzZUhvbGRQZXJmb3JtVGltZW91dCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfYWRkRXZ0KGV2dE5hbWUpIHtcbiAgICAgICAgY29uc3Qgc3B5ID0gdGhpcy50ZXN0UGFuZWxJdGVtICYmIHRoaXMudGVzdFBhbmVsSXRlbVtldnROYW1lXTtcbiAgICAgICAgaWYgKHNweSkge1xuICAgICAgICAgICAgc3B5LmNsYXNzTGlzdC5hZGQoJ2xpc3RlbmluZycpO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2dE5hbWUsIHRoaXNbJ29uJyArIGV2dE5hbWVdKTtcbiAgICB9XG5cbiAgICBfcmVtb3ZlRXZ0KGV2dE5hbWUpIHtcbiAgICAgICAgY29uc3Qgc3B5ID0gdGhpcy50ZXN0UGFuZWxJdGVtICYmIHRoaXMudGVzdFBhbmVsSXRlbVtldnROYW1lXTtcbiAgICAgICAgaWYgKHNweSkge1xuICAgICAgICAgICAgc3B5LmNsYXNzTGlzdC5yZW1vdmUoJ2xpc3RlbmluZycpO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGV2dE5hbWUsIHRoaXNbJ29uJyArIGV2dE5hbWVdKTtcbiAgICB9XG5cbiAgICBzaG9ydFN0b3AoZXZ0KSB7XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICBvbndoZWVsKGV2dCkge1xuICAgICAgICBsZXQga2V5ID0gdGhpcy5kZWx0YVByb3A7XG4gICAgICAgIC8vIHN3YXAgY29vcmRpbmF0ZXMgaWYgc2hpZnQga2V5IHByZXNzZWRcbiAgICAgICAgaWYgKGV2dC5zaGlmdEtleSkge1xuICAgICAgICAgICAga2V5ID0gb3JpZW50YXRpb25IYXNoZXNba2V5ID09PSBvcmllbnRhdGlvbkhhc2hlcy5ob3Jpem9udGFsLmRlbHRhID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJ10uZGVsdGE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleCArPSBldnRba2V5XTtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBvbmNsaWNrKGV2dCkge1xuICAgICAgICB0aGlzLnRodW1iLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBmdW5jdGlvbiB3YWl0Rm9ySXQoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB3YWl0Rm9ySXQpO1xuICAgICAgICAgICAgdGhpcy5vbm1vdXNldXAoZXZ0KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgb25tb3VzZW91dChldnQpIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtTW91c2VIb2xkT3ZlckJhckVuZCgpO1xuICAgIH1cblxuICAgIG9ubW91c2Vkb3duKGV2dCkge1xuICAgICAgICBjb25zdCB0aHVtYkJveCA9IHRoaXMudGh1bWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMucGluT2Zmc2V0ID0gZXZ0W3RoaXMub2guYXhpc10gLSB0aHVtYkJveFt0aGlzLm9oLmxlYWRpbmddICsgdGhpcy5iYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbdGhpcy5vaC5sZWFkaW5nXSArIHRoaXMudGh1bWJNYXJnaW5MZWFkaW5nO1xuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuXG4gICAgICAgIHRoaXMuX2FkZEV2dCgnbW91c2Vtb3ZlJyk7XG4gICAgICAgIHRoaXMuX2FkZEV2dCgnbW91c2V1cCcpO1xuXG4gICAgICAgIHRoaXMuX3BlcmZvcm1DdXJzb3JEb3duKGV2dCk7XG5cbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBvbmJhcnRvdWNoc3RhcnQoZXZ0KSB7XG4gICAgICAgIGNvbnN0IHRodW1iQm94ID0gdGhpcy50aHVtYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5waW5PZmZzZXQgPSBldnQudG91Y2hlc1swXVt0aGlzLm9oLmNvb3JkaW5hdGVdIC0gdGh1bWJCb3hbdGhpcy5vaC5sZWFkaW5nXSArIHRoaXMuYmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW3RoaXMub2gubGVhZGluZ10gKyB0aGlzLnRodW1iTWFyZ2luTGVhZGluZztcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcblxuICAgICAgICB0aGlzLl9hZGRFdnQoJ3RvdWNoZW5kJyk7XG4gICAgICAgIHRoaXMuX2FkZEV2dCgndG91Y2htb3ZlJyk7XG5cbiAgICAgICAgdGhpcy5fcGVyZm9ybUN1cnNvckRvd24oZXZ0LnRvdWNoZXNbMF0pO1xuICAgICAgICB0aGlzLmlzTGFzdFRvdWNoT3ZlckJhciA9IHRydWU7XG5cbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBfcGVyZm9ybUN1cnNvckRvd24oY29vcmRzT2JqZWN0KSB7XG4gICAgICAgIGxldCB0aHVtYkJveCA9IHRoaXMudGh1bWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBtb3VzZU92ZXJUaHVtYiA9IHRodW1iQm94LmxlZnQgPD0gY29vcmRzT2JqZWN0LmNsaWVudFggJiYgY29vcmRzT2JqZWN0LmNsaWVudFggPD0gdGh1bWJCb3gucmlnaHQgJiZcbiAgICAgICAgICAgIHRodW1iQm94LnRvcCA8PSBjb29yZHNPYmplY3QuY2xpZW50WSAmJiBjb29yZHNPYmplY3QuY2xpZW50WSA8PSB0aHVtYkJveC5ib3R0b20sXG4gICAgICAgICAgICBtb3VzZU92ZXJUaHVtYkNlbnRlciA9IGZhbHNlLFxuICAgICAgICAgICAgZ29pbmdVcCA9IGZhbHNlLFxuICAgICAgICAgICAgaW5jcmVtZW50VmFsdWUgPSAwO1xuXG4gICAgICAgIGlmICghbW91c2VPdmVyVGh1bWIpIHtcbiAgICAgICAgICAgIGdvaW5nVXAgPSBjb29yZHNPYmplY3RbdGhpcy5vaC5jb29yZGluYXRlXSA8IHRodW1iQm94W3RoaXMub2gubGVhZGluZ107XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wYWdpbmcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMucGFnaW5nW2dvaW5nVXAgPyAndXAnIDogJ2Rvd24nXShNYXRoLnJvdW5kKHRoaXMuaW5kZXgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSBnb2luZ1VwID8gLXRoaXMuaW5jcmVtZW50IDogdGhpcy5pbmNyZW1lbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY2xlYXJNb3VzZUhvbGRUaW1lb3V0KCk7XG4gICAgICAgICAgICB0aGlzLm1vdXNlSG9sZFBlcmZvcm1UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1RvdWNoSG9sZE92ZXJCYXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNUaHVtYkRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB0aGlzLm1vdXNlSG9sZFBlcmZvcm1JbnRlcnZhbEN1cnJlbnRDb29yZHNPYmogPSBjb29yZHNPYmplY3Q7XG5cbiAgICAgICAgICAgICAgICB0aGlzLm1vdXNlSG9sZFBlcmZvcm1JbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY28gPSB0aGlzLm1vdXNlSG9sZFBlcmZvcm1JbnRlcnZhbEN1cnJlbnRDb29yZHNPYmo7XG4gICAgICAgICAgICAgICAgICAgIHRodW1iQm94ID0gdGhpcy50aHVtYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgbW91c2VPdmVyVGh1bWIgPSB0aHVtYkJveC5sZWZ0IDw9IGNvLmNsaWVudFggJiYgY28uY2xpZW50WCA8PSB0aHVtYkJveC5yaWdodCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJCb3gudG9wIDw9IGNvLmNsaWVudFkgJiYgY28uY2xpZW50WSA8PSB0aHVtYkJveC5ib3R0b207XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGh1bWJDZW50ZXJMZWFkaW5nU2lkZSA9ICh0aHVtYkJveFt0aGlzLm9oLmxlYWRpbmddICsgdGh1bWJCb3hbdGhpcy5vaC5zaXplXSAvIDMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aHVtYkNlbnRlclRyYWlsaW5nU2lkZSA9ICh0aHVtYkJveFt0aGlzLm9oLnRyYWlsaW5nXSAtIHRodW1iQm94W3RoaXMub2guc2l6ZV0gLyAzKTtcbiAgICAgICAgICAgICAgICAgICAgbW91c2VPdmVyVGh1bWJDZW50ZXIgPSBtb3VzZU92ZXJUaHVtYlxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKHRodW1iQ2VudGVyTGVhZGluZ1NpZGUgPD0gY29bdGhpcy5vaC5jb29yZGluYXRlXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmICh0aHVtYkNlbnRlclRyYWlsaW5nU2lkZSA+PSBjb1t0aGlzLm9oLmNvb3JkaW5hdGVdKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBnb2luZ1VwIHZhbHVlIGNoYW5nZWQgb25seSBpZiB0aHVtYiBub3QgaW4gY3Vyc29yIHlldC5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGNhbiB0aGluaywgdGhhdCBzY3JvbGwgY29udGludW91cyBhbmQgZ29pbmdVcCBkb24ndCBuZWVkIHRvIGJlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtb3VzZU92ZXJUaHVtYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ29pbmdVcCA9IGNvW3RoaXMub2guY29vcmRpbmF0ZV0gPCB0aHVtYkJveFt0aGlzLm9oLmxlYWRpbmddO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50VmFsdWUgPSBnb2luZ1VwID8gLXRoaXMuaW5jcmVtZW50IDogdGhpcy5pbmNyZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNUb3VjaEhvbGRPdmVyQmFyICYmICFtb3VzZU92ZXJUaHVtYkNlbnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdvaW5nVXAgJiYgKGNvW3RoaXMub2guY29vcmRpbmF0ZV0gPD0gdGh1bWJDZW50ZXJMZWFkaW5nU2lkZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoKHRoaXMuaW5kZXggKyBpbmNyZW1lbnRWYWx1ZSkgPD0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSBpbmNyZW1lbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVG91Y2hIb2xkT3ZlckJhciAmJiBtb3VzZU92ZXJUaHVtYkNlbnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmb3JtTW91c2VIb2xkT3ZlckJhckVuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGhpcy5tb3VzZUhvbGRQZXJmb3JtSW50ZXJ2YWxSYXRlKTtcbiAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNUb3VjaEhvbGRPdmVyQmFyKSB7XG4gICAgICAgICAgICB0aGlzLmlzVGh1bWJEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbm1vdXNlbW92ZShldnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNUaHVtYkRyYWdnaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWQgPSBNYXRoLm1pbih0aGlzLnRodW1iTWF4LCBNYXRoLm1heCgwLCBldnRbdGhpcy5vaC5heGlzXSAtIHRoaXMucGluT2Zmc2V0KSk7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBzY2FsZWQgLyB0aGlzLnRodW1iTWF4ICogKHRoaXMubWF4IC0gdGhpcy5taW4pICsgdGhpcy5taW47XG5cbiAgICAgICAgICAgIHRoaXMuX3NldFNjcm9sbChpZHgsIHNjYWxlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc1RvdWNoSG9sZE92ZXJCYXIpIHtcbiAgICAgICAgICAgIHRoaXMubW91c2VIb2xkUGVyZm9ybUludGVydmFsQ3VycmVudENvb3Jkc09iaiA9IGV2dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgb25tb3VzZXVwKGV2dCkge1xuICAgICAgICB0aGlzLnBlcmZvcm1Nb3VzZUhvbGRPdmVyQmFyRW5kKCk7XG4gICAgICAgIHRoaXMuaXNUaHVtYkRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZ0KCdtb3VzZW1vdmUnKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZ0KCdtb3VzZXVwJyk7XG5cbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmN1cnNvciA9ICdhdXRvJztcblxuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHRyYWNrVG91Y2hTY3JvbGwoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBlbGFwc2VkID0gY3VycmVudFRpbWVzdGFtcCAtIHRoaXMuY29udGFpbmVyTGFzdFRvdWNoVGltZTtcbiAgICAgICAgdGhpcy5jb250YWluZXJMYXN0VG91Y2hUaW1lID0gY3VycmVudFRpbWVzdGFtcDtcbiAgICAgICAgY29uc3QgZGVsdGEgPSB0aGlzLmNvbnRhaW5lclRvdWNoU2Nyb2xsT2Zmc2V0IC0gdGhpcy5fdG91Y2hTY3JvbGxGcmFtZTtcbiAgICAgICAgdGhpcy5fdG91Y2hTY3JvbGxGcmFtZSA9IHRoaXMuY29udGFpbmVyVG91Y2hTY3JvbGxPZmZzZXQ7XG4gICAgICAgIGNvbnN0IHYgPSAxMDAwICogZGVsdGEgLyAoMSArIGVsYXBzZWQpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lclRvdWNoVmVsb2NpdHkgPSB0aGlzLm9oLmNvbnRhaW5lclRvdWNoVmVsb2NpdHlNb2RpZmllciAqIHYgKyAwLjIgKiB0aGlzLmNvbnRhaW5lclRvdWNoVmVsb2NpdHk7XG4gICAgICAgIC8vIGNvcnJlY3QgdmVsb2NpdHkgd2l0aCBtYXggdmFsdWVcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyVG91Y2hWZWxvY2l0eSA8IC10aGlzLm9oLmNvbnRhaW5lclRvdWNoVmVsb2NpdHlNYXgpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyVG91Y2hWZWxvY2l0eSA9IC10aGlzLm9oLmNvbnRhaW5lclRvdWNoVmVsb2NpdHlNYXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyVG91Y2hWZWxvY2l0eSA+IHRoaXMub2guY29udGFpbmVyVG91Y2hWZWxvY2l0eU1heCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJUb3VjaFZlbG9jaXR5ID0gdGhpcy5vaC5jb250YWluZXJUb3VjaFZlbG9jaXR5TWF4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb250b3VjaHN0YXJ0KGV2dCkge1xuICAgICAgICB0aGlzLmlzVG91Y2hIb2xkT3ZlckNvbnRhaW5lciA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNUaHVtYlRvdWNoRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb250YWluZXJMYXN0VG91Y2hQb3MgPSBldnQudG91Y2hlc1swXVt0aGlzLm9oLmNvb3JkaW5hdGVdO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckxhc3RUb3VjaFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIHRoaXMuX3RvdWNoU2Nyb2xsRnJhbWUgPSB0aGlzLmNvbnRhaW5lclRvdWNoU2Nyb2xsT2Zmc2V0O1xuICAgICAgICB0aGlzLmNvbnRhaW5lclRvdWNoVmVsb2NpdHkgPSB0aGlzLmNvbnRhaW5lclRvdWNoQW1wbGl0dWRlID0gMDtcblxuICAgICAgICB0aGlzLmlzTGFzdFRvdWNoT3ZlckJhciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnRhaW5lclRvdWNoU2Nyb2xsT2Zmc2V0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgdGhpcy5jb250YWluZXJUb3VjaFNjcm9sbEludGVydmFsID0gc2V0SW50ZXJ2YWwodGhpcy50cmFja1RvdWNoU2Nyb2xsLCAxMDApO1xuXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgZ2V0UG9zKGUpIHtcbiAgICAgICAgLy8gdG91Y2ggZXZlbnRcbiAgICAgICAgaWYgKGUudGFyZ2V0VG91Y2hlcyAmJiAoZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA+PSAxKSkge1xuICAgICAgICAgICAgcmV0dXJuIGUudGFyZ2V0VG91Y2hlc1swXVt0aGlzLm9oLmNvb3JkaW5hdGVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLnRvdWNoZXMgJiYgKGUudG91Y2hlcy5sZW5ndGggPj0gMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlLnRvdWNoZXNbMF1bdGhpcy5vaC5jb29yZGluYXRlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1vdXNlIGV2ZW50XG4gICAgICAgIHJldHVybiBlW3RoaXMub2guY29vcmRpbmF0ZV07XG4gICAgfVxuXG4gICAgb250aHVtYnRvdWNoc3RhcnQoZXZ0KSB7XG4gICAgICAgIGNvbnN0IHRodW1iQm94ID0gdGhpcy50aHVtYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IGN1cnJlbnRNb3ZlUG9zID0gdGhpcy5nZXRQb3MoZXZ0KTtcbiAgICAgICAgdGhpcy5waW5PZmZzZXQgPSBjdXJyZW50TW92ZVBvcyAtIHRodW1iQm94W3RoaXMub2gubGVhZGluZ10gKyB0aGlzLmJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVt0aGlzLm9oLmxlYWRpbmddICsgdGhpcy50aHVtYk1hcmdpbkxlYWRpbmc7XG5cbiAgICAgICAgdGhpcy5pc1RodW1iVG91Y2hEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuY29udGFpbmVyTGFzdFRvdWNoUG9zID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9hZGRFdnQoJ3RvdWNoZW5kJyk7XG4gICAgICAgIHRoaXMuX2FkZEV2dCgndG91Y2htb3ZlJyk7XG5cbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBvbnRvdWNoZW5kKGV2dCkge1xuICAgICAgICBpZiAodGhpcy5pc1RvdWNoSG9sZE92ZXJDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaXNUb3VjaEhvbGRPdmVyQ29udGFpbmVyID0gZmFsc2U7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY29udGFpbmVyVG91Y2hTY3JvbGxJbnRlcnZhbCk7XG4gICAgICAgICAgICB0aGlzLnRyYWNrVG91Y2hTY3JvbGwoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5lclRvdWNoVmVsb2NpdHkgPiAxMCB8fCB0aGlzLmNvbnRhaW5lclRvdWNoVmVsb2NpdHkgPCAtMTApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lclRvdWNoQW1wbGl0dWRlID0gMC44ICogdGhpcy5jb250YWluZXJUb3VjaFZlbG9jaXR5O1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyVG91Y2hTY3JvbGxUYXJnZXQgPSBNYXRoLnJvdW5kKHRoaXMuY29udGFpbmVyVG91Y2hTY3JvbGxPZmZzZXQgKyB0aGlzLmNvbnRhaW5lclRvdWNoQW1wbGl0dWRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lckxhc3RUb3VjaFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9wZXJmb3JtVG91Y2hBdXRvU2Nyb2xsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgdGhpcy5pc1RodW1iVG91Y2hEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzVG91Y2hIb2xkT3ZlckNvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckxhc3RUb3VjaFBvcyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5wZXJmb3JtTW91c2VIb2xkT3ZlckJhckVuZCgpO1xuXG4gICAgICAgIHRoaXMuX3JlbW92ZUV2dCgndG91Y2hlbmQnKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZ0KCd0b3VjaG1vdmUnKTtcblxuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIF9wZXJmb3JtVG91Y2hBdXRvU2Nyb2xsKCkge1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXJUb3VjaEFtcGxpdHVkZSkge1xuICAgICAgICAgICAgY29uc3QgZWxhcHNlZCA9IERhdGUubm93KCkgLSB0aGlzLmNvbnRhaW5lckxhc3RUb3VjaFRpbWU7XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IC10aGlzLmNvbnRhaW5lclRvdWNoQW1wbGl0dWRlICogTWF0aC5leHAoLWVsYXBzZWQgLyAzMjUpO1xuICAgICAgICAgICAgaWYgKGRlbHRhID4gMC41IHx8IGRlbHRhIDwgLTAuNSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlcmZvcm1Ub3VjaFNjcm9sbCh0aGlzLmNvbnRhaW5lclRvdWNoU2Nyb2xsVGFyZ2V0ICsgZGVsdGEpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9wZXJmb3JtVG91Y2hBdXRvU2Nyb2xsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVyZm9ybVRvdWNoU2Nyb2xsKHRoaXMuY29udGFpbmVyVG91Y2hTY3JvbGxUYXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3BlcmZvcm1Ub3VjaFNjcm9sbCh5KSB7XG4gICAgICAgIGNvbnN0IG5ld09mZnNldCA9ICh5ID4gdGhpcy5tYXgpID8gdGhpcy5tYXggOiAoeSA8IHRoaXMubWluKSA/IHRoaXMubWluIDogeTtcbiAgICAgICAgaWYgKG5ld09mZnNldCAhPT0gdGhpcy5jb250YWluZXJUb3VjaFNjcm9sbE9mZnNldCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJUb3VjaFNjcm9sbE9mZnNldCA9IG5ld09mZnNldDtcbiAgICAgICAgICAgIHRoaXMuX3NldFNjcm9sbCh0aGlzLmNvbnRhaW5lclRvdWNoU2Nyb2xsT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9udG91Y2htb3ZlKGV2dCkge1xuICAgICAgICBpZiAodGhpcy5pc1RodW1iVG91Y2hEcmFnZ2luZykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRNb3ZlUG9zID0gdGhpcy5nZXRQb3MoZXZ0KTtcblxuICAgICAgICAgICAgbGV0IHNjYWxlZCA9IE1hdGgubWluKHRoaXMudGh1bWJNYXgsIE1hdGgubWF4KDAsIGN1cnJlbnRNb3ZlUG9zIC0gdGhpcy5waW5PZmZzZXQpKTtcbiAgICAgICAgICAgIGxldCBpZHggPSBzY2FsZWQgLyB0aGlzLnRodW1iTWF4ICogKHRoaXMubWF4IC0gdGhpcy5taW4pICsgdGhpcy5taW47XG5cbiAgICAgICAgICAgIHRoaXMuX3NldFNjcm9sbChpZHgsIHNjYWxlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1RvdWNoSG9sZE92ZXJDb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zKGV2dCk7XG4gICAgICAgICAgICBsZXQgZGVsdGEgPSB0aGlzLmNvbnRhaW5lckxhc3RUb3VjaFBvcyAtIHBvcztcbiAgICAgICAgICAgIGRlbHRhID0gZGVsdGEgKiB0aGlzLm9oLnRvdWNoVG9TY3JvbGxQaXhlbHNDb2VmZmljaWVudDtcbiAgICAgICAgICAgIGlmIChkZWx0YSA+IDIgKiB0aGlzLm9oLnRvdWNoVG9TY3JvbGxQaXhlbHNDb2VmZmljaWVudCB8fCBkZWx0YSA8IC0yICogdGhpcy5vaC50b3VjaFRvU2Nyb2xsUGl4ZWxzQ29lZmZpY2llbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lckxhc3RUb3VjaFBvcyA9IHBvcztcbiAgICAgICAgICAgICAgICB0aGlzLl9wZXJmb3JtVG91Y2hTY3JvbGwodGhpcy5jb250YWluZXJUb3VjaFNjcm9sbE9mZnNldCArIGRlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzTGFzdFRvdWNoT3ZlckJhcikge1xuICAgICAgICAgICAgY29uc3QgYm91bmRzQm94ID0gdGhpcy5iYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjb25zdCB0b3VjaE92ZXJCYXIgPSBib3VuZHNCb3gubGVmdCA8PSBldnQudG91Y2hlc1swXS5jbGllbnRYICYmIGV2dC50b3VjaGVzWzBdLmNsaWVudFggPD0gYm91bmRzQm94LnJpZ2h0ICYmXG4gICAgICAgICAgICAgICAgYm91bmRzQm94LnRvcCA8PSBldnQudG91Y2hlc1swXS5jbGllbnRZICYmIGV2dC50b3VjaGVzWzBdLmNsaWVudFkgPD0gYm91bmRzQm94LmJvdHRvbTtcblxuICAgICAgICAgICAgaWYgKCF0b3VjaE92ZXJCYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1Nb3VzZUhvbGRPdmVyQmFyRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tb3VzZUhvbGRQZXJmb3JtSW50ZXJ2YWxDdXJyZW50Q29vcmRzT2JqKSB7XG4gICAgICAgICAgICB0aGlzLm1vdXNlSG9sZFBlcmZvcm1JbnRlcnZhbEN1cnJlbnRDb29yZHNPYmogPSBldnQudG91Y2hlc1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgX3NldFNjcm9sbChpZHgsIHNjYWxlZCkge1xuICAgICAgICB0aGlzLmZpbkJhci5fc2V0U2Nyb2xsKGlkeCwgc2NhbGVkKTtcbiAgICB9XG5cbiAgICBnZXQgbWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5CYXIubWluO1xuICAgIH1cblxuICAgIGdldCBtYXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbkJhci5tYXg7XG4gICAgfVxuXG4gICAgZ2V0IGJhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluQmFyLmJhcjtcbiAgICB9XG5cbiAgICBnZXQgdGh1bWIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbkJhci50aHVtYjtcbiAgICB9XG5cbiAgICBnZXQgdGh1bWJNYXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbkJhci50aHVtYk1heDtcbiAgICB9XG5cbiAgICBnZXQgb2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbkJhci5vaDtcbiAgICB9XG5cbiAgICBnZXQgZGVsdGFQcm9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5CYXIuZGVsdGFQcm9wO1xuICAgIH1cblxuICAgIGdldCB0aHVtYk1hcmdpbkxlYWRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbkJhci50aHVtYk1hcmdpbkxlYWRpbmc7XG4gICAgfVxuXG4gICAgZ2V0IHRlc3RQYW5lbEl0ZW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbkJhci50ZXN0UGFuZWxJdGVtO1xuICAgIH1cblxuICAgIHNldCBpbmRleCh2YWwpIHtcbiAgICAgICAgdGhpcy5maW5CYXIuaW5kZXggPSB2YWw7XG4gICAgfVxuXG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5CYXIuaW5kZXg7XG4gICAgfVxuXG4gICAgZ2V0IGluY3JlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluQmFyLmluY3JlbWVudDtcbiAgICB9XG59XG5cbi8vIEludGVyZmFjZVxubW9kdWxlLmV4cG9ydHMgPSBGaW5CYXJUb3VjaDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qIGVzbGludC1lbnYgbm9kZSwgYnJvd3NlciAqL1xuXG5jb25zdCBjc3NJbmplY3RvciA9IHJlcXVpcmUoJ2Nzcy1pbmplY3RvcicpO1xuY29uc3QgZXZlbnRzID0gcmVxdWlyZSgnLi9ldmVudHMnKTtcbmNvbnN0IG9yaWVudGF0aW9uSGFzaGVzID0gcmVxdWlyZSgnLi9vcmllbnRhdGlvbkhhc2hlcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBGaW5CYXJcbiAqIEBzdW1tYXJ5IENyZWF0ZSBhIHNjcm9sbGJhciBvYmplY3QuXG4gKiBAZGVzYyBDcmVhdGluZyBhIHNjcm9sbGJhciBpcyBhIHRocmVlLXN0ZXAgcHJvY2VzczpcbiAqXG4gKiAxLiBJbnN0YW50aWF0ZSB0aGUgc2Nyb2xsYmFyIG9iamVjdCBieSBjYWxsaW5nIHRoaXMgY29uc3RydWN0b3IgZnVuY3Rpb24uIFVwb24gaW5zdGFudGlhdGlvbiwgdGhlIERPTSBlbGVtZW50IGZvciB0aGUgc2Nyb2xsYmFyICh3aXRoIGEgc2luZ2xlIGNoaWxkIGVsZW1lbnQgZm9yIHRoZSBzY3JvbGxiYXIgXCJ0aHVtYlwiKSBpcyBjcmVhdGVkIGJ1dCBpcyBub3QgaW5zZXJ0IGl0IGludG8gdGhlIERPTS5cbiAqIDIuIEFmdGVyIGluc3RhbnRpYXRpb24sIGl0IGlzIHRoZSBjYWxsZXIncyByZXNwb25zaWJpbGl0eSB0byBpbnNlcnQgdGhlIHNjcm9sbGJhciwge0BsaW5rIEZpbkJhciNiYXJ8dGhpcy5iYXJ9LCBpbnRvIHRoZSBET00uXG4gKiAzLiBBZnRlciBpbnNlcnRpb24sIHRoZSBjYWxsZXIgbXVzdCBjYWxsIHtAbGluayBGaW5CYXIjcmVzaXplfHJlc2l6ZSgpfSBhdCBsZWFzdCBvbmNlIHRvIHNpemUgYW5kIHBvc2l0aW9uIHRoZSBzY3JvbGxiYXIgYW5kIGl0cyB0aHVtYi4gQWZ0ZXIgdGhhdCwgYHJlc2l6ZSgpYCBzaG91bGQgYWxzbyBiZSBjYWxsZWQgcmVwZWF0ZWRseSBvbiByZXNpemUgZXZlbnRzIChhcyB0aGUgY29udGVudCBlbGVtZW50IGlzIGJlaW5nIHJlc2l6ZWQpLlxuICpcbiAqIFN1Z2dlc3RlZCBjb25maWd1cmF0aW9uczpcbiAqICogXyoqVW5ib3VuZCoqXzxici8+XG4gKiBUaGUgc2Nyb2xsYmFyIHNlcnZlcyBtZXJlbHkgYXMgYSBzaW1wbGUgcmFuZ2UgKHNsaWRlcikgY29udHJvbC4gT21pdCBib3RoIGBvcHRpb25zLm9uY2hhbmdlYCBhbmQgYG9wdGlvbnMuY29udGVudGAuXG4gKiAqIF8qKkJvdW5kIHRvIHZpcnR1YWwgY29udGVudCBlbGVtZW50KipfPGJyLz5cbiAqIFZpcnR1YWwgY29udGVudCBpcyBwcm9qZWN0ZWQgaW50byB0aGUgZWxlbWVudCB1c2luZyBhIGN1c3RvbSBldmVudCBoYW5kbGVyIHN1cHBsaWVkIGJ5IHRoZSBwcm9ncmFtbWVyIGluIGBvcHRpb25zLm9uY2hhbmdlYC4gQSB0eXBpY2FsIHVzZSBjYXNlIHdvdWxkIGJlIHRvIGhhbmRsZSBzY3JvbGxpbmcgb2YgdGhlIHZpcnR1YWwgY29udGVudC4gT3RoZXIgdXNlIGNhc2VzIGluY2x1ZGUgZGF0YSB0cmFuc2Zvcm1hdGlvbnMsIGdyYXBoaWNzIHRyYW5zZm9ybWF0aW9ucywgX2V0Yy5fXG4gKiAqIF8qKkJvdW5kIHRvIHJlYWwgY29udGVudCoqXzxici8+XG4gKiBTZXQgYG9wdGlvbnMuY29udGVudGAgdG8gdGhlIFwicmVhbFwiIGNvbnRlbnQgZWxlbWVudCBidXQgb21pdCBgb3B0aW9ucy5vbmNoYW5nZWAuIFRoaXMgd2lsbCBjYXVzZSB0aGUgc2Nyb2xsYmFyIHRvIHVzZSB0aGUgYnVpbHQtaW4gZXZlbnQgaGFuZGxlciAoYHRoaXMuc2Nyb2xsUmVhbENvbnRlbnRgKSB3aGljaCBpbXBsZW1lbnRzIHNtb290aCBzY3JvbGxpbmcgb2YgdGhlIGNvbnRlbnQgZWxlbWVudCB3aXRoaW4gdGhlIGNvbnRhaW5lci5cbiAqXG4gKiBAcGFyYW0ge2ZpbmJhck9wdGlvbnN9IFtvcHRpb25zPXt9XSAtIE9wdGlvbnMgb2JqZWN0LiBTZWUgdGhlIHR5cGUgZGVmaW5pdGlvbiBmb3IgbWVtYmVyIGRldGFpbHMuXG4gKi9cbmZ1bmN0aW9uIEZpbkJhcihvcHRpb25zKSB7XG4gICAgY29uc3QgYm91bmQgPSB0aGlzLmV2ZW50cyA9IG5ldyBldmVudHModGhpcyk7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJvdW5kKSlcbiAgICAgICAgLmZpbHRlcihmID0+IHR5cGVvZiBib3VuZFtmXSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgLmZvckVhY2goZiA9PiBib3VuZFtmXSA9IGJvdW5kW2ZdLmJpbmQoYm91bmQpKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIHRodW1iXG4gICAgICogQHN1bW1hcnkgVGhlIGdlbmVyYXRlZCBzY3JvbGxiYXIgdGh1bWIgZWxlbWVudC5cbiAgICAgKiBAZGVzYyBUaGUgdGh1bWIgZWxlbWVudCdzIHBhcmVudCBlbGVtZW50IGlzIGFsd2F5cyB0aGUge0BsaW5rIEZpbkJhciNiYXJ8YmFyfSBlbGVtZW50LlxuICAgICAqXG4gICAgICogVGhpcyBwcm9wZXJ0eSBpcyB0eXBpY2FsbHkgcmVmZXJlbmNlZCBpbnRlcm5hbGx5IG9ubHkuIFRoZSBzaXplIGFuZCBwb3NpdGlvbiBvZiB0aGUgdGh1bWIgZWxlbWVudCBpcyBtYWludGFpbmVkIGJ5IGBfY2FsY1RodW1iKClgLlxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgY29uc3QgdGh1bWIgPSB0aGlzLnRodW1iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGh1bWIuY2xhc3NMaXN0LmFkZCgndGh1bWInKTtcbiAgICB0aHVtYi5vbmNsaWNrID0gYm91bmQuc2hvcnRTdG9wO1xuICAgIHRodW1iLm9udG91Y2hzdGFydCA9IGJvdW5kLm9udGh1bWJ0b3VjaHN0YXJ0O1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgYmFyXG4gICAgICogQHN1bW1hcnkgVGhlIGdlbmVyYXRlZCBzY3JvbGxiYXIgZWxlbWVudC5cbiAgICAgKiBAZGVzYyBUaGUgY2FsbGVyIGluc2VydHMgdGhpcyBlbGVtZW50IGludG8gdGhlIERPTSAodHlwaWNhbGx5IGludG8gdGhlIGNvbnRlbnQgY29udGFpbmVyKSBhbmQgdGhlbiBjYWxscyBpdHMge0BsaW5rIEZpbkJhciNyZXNpemV8cmVzaXplKCl9IG1ldGhvZC5cbiAgICAgKlxuICAgICAqIFRodXMgdGhlIG5vZGUgdHJlZSBpcyB0eXBpY2FsbHk6XG4gICAgICogKiBBICoqY29udGVudCBjb250YWluZXIqKiBlbGVtZW50LCB3aGljaCBjb250YWluczpcbiAgICAgKiAgICogVGhlIGNvbnRlbnQgZWxlbWVudChzKVxuICAgICAqICAgKiBUaGlzICoqc2Nyb2xsYmFyIGVsZW1lbnQqKiwgd2hpY2ggaW4gdHVybiBjb250YWluczpcbiAgICAgKiAgICAgKiBUaGUgKip0aHVtYiBlbGVtZW50KipcbiAgICAgKlxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgY29uc3QgYmFyID0gdGhpcy5iYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBiYXIuY2xhc3NMaXN0LmFkZCgnZmluYmFyLXZlcnRpY2FsJyk7XG4gICAgYmFyLm9ubW91c2Vkb3duID0gYm91bmQub25tb3VzZWRvd247XG4gICAgaWYgKHRoaXMucGFnaW5nKSB7XG4gICAgICAgIGJhci5vbmNsaWNrID0gYm91bmQub25jbGljaztcbiAgICB9XG4gICAgYmFyLmFwcGVuZENoaWxkKHRodW1iKTtcbiAgICBiYXIub250b3VjaHN0YXJ0ID0gYm91bmQub25iYXJ0b3VjaHN0YXJ0O1xuICAgIGJhci5vbm1vdXNlb3V0ID0gYm91bmQub25tb3VzZW91dDtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIG1vdW50RGl2XG4gICAgICogQHN1bW1hcnkgVGhlIGdlbmVyYXRlZCBzY3JvbGxiYXIgZGVjb3JhdGl2ZSBlbGVtZW50IHRoYXQgcmVuZGVycyBiZWhpbmQgc2Nyb2xsYmFyIGFuZCBjYW4gYmUgc3R5bGVkLlxuICAgICAqIEBkZXNjIFRoZSBjYWxsZXIgaW5zZXJ0cyB0aGlzIGVsZW1lbnQgaW50byB0aGUgRE9NICh0eXBpY2FsbHkgaW50byB0aGUgY29udGVudCBjb250YWluZXIpIGFuZCB0aGVuIGNhbGxzIGl0cyB7QGxpbmsgRmluQmFyI3Jlc2l6ZXxyZXNpemUoKX0gbWV0aG9kLlxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgY29uc3QgbW91bnREaXYgPSB0aGlzLm1vdW50RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbW91bnREaXYuYXBwZW5kQ2hpbGQoYmFyKTtcblxuICAgIC8vIHByZXNldHNcbiAgICB0aGlzLm9yaWVudGF0aW9uID0gJ3ZlcnRpY2FsJztcbiAgICB0aGlzLm1pbiA9IHRoaXMuX2luZGV4ID0gMDtcbiAgICB0aGlzLm1heCA9IDEwMDtcblxuICAgIC8vIG9wdGlvbnNcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbiA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdpbmRleCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gb3B0aW9uO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3JhbmdlJzpcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRSYW5nZShvcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbiA9IG9wdGlvbi5taW47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF4ID0gb3B0aW9uLm1heDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50U2l6ZSA9IG9wdGlvbi5tYXggLSBvcHRpb24ubWluICsgMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdvbkJhclZpc2liaWxpdHlDaGFuZ2VkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkJhclZpc2liaWxpdHlDaGFuZ2VkID0gb3B0aW9uO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleS5jaGFyQXQoMCkgIT09ICdfJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIEZpbkJhci5wcm90b3R5cGVba2V5XSAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG92ZXJyaWRlIHByb3RvdHlwZSBkZWZhdWx0cyBmb3Igc3RhbmRhcmQgO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXh0ZW5kIHdpdGggYWRkaXRpb25hbCBwcm9wZXJ0aWVzIChmb3IgdXNlIGluIG9uY2hhbmdlIGV2ZW50IGhhbmRsZXJzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gb3B0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjc3NJbmplY3Rvcihjc3NGaW5CYXJzLCAnZmluYmFyLWJhc2UnLCBvcHRpb25zLmNzc1N0eWxlc2hlZXRSZWZlcmVuY2VFbGVtZW50KTtcblxuICAgIGlmICh0aGlzLm9uQmFyVmlzaWJpbGl0eUNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5vbkJhclZpc2liaWxpdHlDaGFuZ2VkKHRydWUpO1xuICAgIH1cbn1cblxuRmluQmFyLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFRoZSBzY3JvbGxiYXIgb3JpZW50YXRpb24uXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3RvciB0byBlaXRoZXIgYCd2ZXJ0aWNhbCdgIG9yIGAnaG9yaXpvbnRhbCdgLiBTZWUgdGhlIHNpbWlsYXJseSBuYW1lZCBwcm9wZXJ0eSBpbiB0aGUge0BsaW5rIGZpbmJhck9wdGlvbnN9IG9iamVjdC5cbiAgICAgKlxuICAgICAqIFVzZWZ1bCB2YWx1ZXMgYXJlIGAndmVydGljYWwnYCAodGhlIGRlZmF1bHQpIG9yIGAnaG9yaXpvbnRhbCdgLlxuICAgICAqXG4gICAgICogU2V0dGluZyB0aGlzIHByb3BlcnR5IHJlc2V0cyBgdGhpcy5vaGAgYW5kIGB0aGlzLmRlbHRhUHJvcGAgYW5kIGNoYW5nZXMgdGhlIGNsYXNzIG5hbWVzIHNvIGFzIHRvIHJlcG9zaXRpb24gdGhlIHNjcm9sbGJhciBhcyBwZXIgdGhlIENTUyBydWxlcyBmb3IgdGhlIG5ldyBvcmllbnRhdGlvbi5cbiAgICAgKiBAZGVmYXVsdCAndmVydGljYWwnXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldCBvcmllbnRhdGlvbihvcmllbnRhdGlvbikge1xuICAgICAgICBpZiAob3JpZW50YXRpb24gPT09IHRoaXMuX29yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQG5hbWUgb2hcbiAgICAgICAgICogQHN1bW1hcnkgPHU+TzwvdT5yaWVudGF0aW9uIDx1Pmg8L3U+YXNoIGZvciB0aGlzIHNjcm9sbGJhci5cbiAgICAgICAgICogQGRlc2MgU2V0IGJ5IHRoZSBgb3JpZW50YXRpb25gIHNldHRlciB0byBlaXRoZXIgdGhlIHZlcnRpY2FsIG9yIHRoZSBob3Jpem9udGFsIG9yaWVudGF0aW9uIGhhc2guIFRoZSBwcm9wZXJ0eSBzaG91bGQgYWx3YXlzIGJlIHN5bmNocm9uaXplZCB3aXRoIGBvcmllbnRhdGlvbmA7IGRvIG5vdCB1cGRhdGUgZGlyZWN0bHkhXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgb2JqZWN0IGlzIHVzZWQgaW50ZXJuYWxseSB0byBhY2Nlc3Mgc2Nyb2xsYmFycycgRE9NIGVsZW1lbnQgcHJvcGVydGllcyBpbiBhIGdlbmVyYWxpemVkIHdheSB3aXRob3V0IG5lZWRpbmcgdG8gY29uc3RhbnRseSBxdWVyeSB0aGUgc2Nyb2xsYmFyIG9yaWVudGF0aW9uLiBGb3IgZXhhbXBsZSwgaW5zdGVhZCBvZiBleHBsaWNpdGx5IGNvZGluZyBgdGhpcy5iYXIudG9wYCBmb3IgYSB2ZXJ0aWNhbCBzY3JvbGxiYXIgYW5kIGB0aGlzLmJhci5sZWZ0YCBmb3IgYSBob3Jpem9udGFsIHNjcm9sbGJhciwgc2ltcGx5IGNvZGUgYHRoaXMuYmFyW3RoaXMub2gubGVhZGluZ11gIGluc3RlYWQuIFNlZSB0aGUge0BsaW5rIG9yaWVudGF0aW9uSGFzaFR5cGV9IGRlZmluaXRpb24gZm9yIGRldGFpbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgb2JqZWN0IGlzIHVzZWZ1bCBleHRlcm5hbGx5IGZvciBjb2RpbmcgZ2VuZXJhbGl6ZWQge0BsaW5rIGZpbmJhck9uQ2hhbmdlfSBldmVudCBoYW5kbGVyIGZ1bmN0aW9ucyB0aGF0IHNlcnZlIGJvdGggaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgc2Nyb2xsYmFycy5cbiAgICAgICAgICogQHR5cGUge29yaWVudGF0aW9uSGFzaFR5cGV9XG4gICAgICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9oID0gb3JpZW50YXRpb25IYXNoZXNbdGhpcy5fb3JpZW50YXRpb25dO1xuXG4gICAgICAgIGlmICghdGhpcy5vaCkge1xuICAgICAgICAgICAgZXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIGBvcHRpb25zLl9vcmllbnRhdGlvbi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBkZWx0YVByb3BcbiAgICAgICAgICogQHN1bW1hcnkgVGhlIG5hbWUgb2YgdGhlIGBXaGVlbEV2ZW50YCBwcm9wZXJ0eSB0aGlzIHNjcm9sbGJhciBzaG91bGQgbGlzdGVuIHRvLlxuICAgICAgICAgKiBAZGVzYyBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yLiBTZWUgdGhlIHNpbWlsYXJseSBuYW1lZCBwcm9wZXJ0eSBpbiB0aGUge0BsaW5rIGZpbmJhck9wdGlvbnN9IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogVXNlZnVsIHZhbHVlcyBhcmUgYCdkZWx0YVgnYCwgYCdkZWx0YVknYCwgb3IgYCdkZWx0YVonYC4gQSB2YWx1ZSBvZiBgbnVsbGAgbWVhbnMgdG8gaWdub3JlIG1vdXNlIHdoZWVsIGV2ZW50cyBlbnRpcmVseS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIG1vdXNlIHdoZWVsIGlzIG9uZS1kaW1lbnNpb25hbCBhbmQgb25seSBlbWl0cyBldmVudHMgd2l0aCBgZGVsdGFZYCBkYXRhLiBUaGlzIHByb3BlcnR5IGlzIHByb3ZpZGVkIHNvIHRoYXQgeW91IGNhbiBvdmVycmlkZSB0aGUgZGVmYXVsdCBvZiBgJ2RlbHRhWCdgIHdpdGggYSB2YWx1ZSBvZiBgJ2RlbHRhWSdgIG9uIHlvdXIgaG9yaXpvbnRhbCBzY3JvbGxiYXIgcHJpbWFyaWx5IHRvIGFjY29tbW9kYXRlIGNlcnRhaW4gXCJwYW5vcmFtaWNcIiBpbnRlcmZhY2UgZGVzaWducyB3aGVyZSB0aGUgbW91c2Ugd2hlZWwgc2hvdWxkIGNvbnRyb2wgaG9yaXpvbnRhbCByYXRoZXIgdGhhbiB2ZXJ0aWNhbCBzY3JvbGxpbmcuIEp1c3QgZ2l2ZSBgeyBkZWx0YVByb3A6ICdkZWx0YVknIH1gIGluIHlvdXIgaG9yaXpvbnRhbCBzY3JvbGxiYXIgaW5zdGFudGlhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQ2F2ZWF0OiBOb3RlIHRoYXQgYSAyLWZpbmdlciBkcmFnIG9uIGFuIEFwcGxlIHRyYWNrcGFkIGVtaXRzIGV2ZW50cyB3aXRoIF9ib3RoXyBgZGVsdGFYIGAgYW5kIGBkZWx0YVlgIGRhdGEgc28geW91IG1pZ2h0IHdhbnQgdG8gZGVsYXkgbWFraW5nIHRoZSBhYm92ZSBhZGp1c3RtZW50IHVudGlsIHlvdSBjYW4gZGV0ZXJtaW5lIHRoYXQgeW91IGFyZSBnZXR0aW5nIFkgZGF0YSBvbmx5IHdpdGggbm8gWCBkYXRhIGF0IGFsbCAod2hpY2ggaXMgYSBzdXJlIGJldCB5b3Ugb24gYSBtb3VzZSB3aGVlbCByYXRoZXIgdGhhbiBhIHRyYWNrcGFkKS5cblxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fG51bGx9XG4gICAgICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlbHRhUHJvcCA9IHRoaXMub2guZGVsdGE7XG5cbiAgICAgICAgdGhpcy5iYXIuY2xhc3NOYW1lID0gdGhpcy5iYXIuY2xhc3NOYW1lLnJlcGxhY2UoLyh2ZXJ0aWNhbHxob3Jpem9udGFsKS9nLCBvcmllbnRhdGlvbik7XG5cbiAgICAgICAgaWYgKHRoaXMuYmFyLnN0eWxlLmNzc1RleHQgfHwgdGhpcy50aHVtYi5zdHlsZS5jc3NUZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmJhci5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICAgICB0aGlzLnRodW1iLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldCBvcmllbnRhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDYWxsYmFjayBmb3Igc2Nyb2xsIGV2ZW50cy5cbiAgICAgKiBAZGVzYyBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yIHZpYSB0aGUgc2ltaWxhcmx5IG5hbWVkIHByb3BlcnR5IGluIHRoZSB7QGxpbmsgZmluYmFyT3B0aW9uc30gb2JqZWN0LiBBZnRlciBpbnN0YW50aWF0aW9uLCBgdGhpcy5vbmNoYW5nZWAgbWF5IGJlIHVwZGF0ZWQgZGlyZWN0bHkuXG4gICAgICpcbiAgICAgKiBUaGlzIGV2ZW50IGhhbmRsZXIgaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSB2YWx1ZSBvZiB0aGUgc2Nyb2xsYmFyIGlzIGNoYW5nZWQgdGhyb3VnaCB1c2VyIGludGVyYWN0aW9uLiBUaGUgdHlwaWNhbCB1c2UgY2FzZSBpcyB3aGVuIHRoZSBjb250ZW50IGlzIHNjcm9sbGVkLiBJdCBpcyBjYWxsZWQgd2l0aCB0aGUgYEZpbkJhcmAgb2JqZWN0IGFzIGl0cyBjb250ZXh0IGFuZCB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgc2Nyb2xsYmFyIChpdHMgaW5kZXgsIHJvdW5kZWQpIGFzIHRoZSBvbmx5IHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIFNldCB0aGlzIHByb3BlcnR5IHRvIGBudWxsYCB0byBzdG9wIGVtaXR0aW5nIHN1Y2ggZXZlbnRzLlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIpfG51bGx9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBvbmNoYW5nZTogbnVsbCxcblxuICAgIG9uQmFyVmlzaWJpbGl0eUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBBZGQgYSBDU1MgY2xhc3MgbmFtZSB0byB0aGUgYmFyIGVsZW1lbnQncyBjbGFzcyBsaXN0LlxuICAgICAqIEBkZXNjIFNldCBieSB0aGUgY29uc3RydWN0b3IuIFNlZSB0aGUgc2ltaWxhcmx5IG5hbWVkIHByb3BlcnR5IGluIHRoZSB7QGxpbmsgZmluYmFyT3B0aW9uc30gb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdCB3aWxsIGFsd2F5cyBpbmNsdWRlIGBmaW5iYXItdmVydGljYWxgIChvciBgZmluYmFyLWhvcml6b250YWxgIGJhc2VkIG9uIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uKS4gV2hlbmV2ZXIgdGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gc29tZSB2YWx1ZSwgZmlyc3QgdGhlIG9sZCBwcmVmaXgrb3JpZW50YXRpb24gaXMgcmVtb3ZlZCBmcm9tIHRoZSBiYXIgZWxlbWVudCdzIGNsYXNzIGxpc3Q7IHRoZW4gdGhlIG5ldyBwcmVmaXgrb3JpZW50YXRpb24gaXMgYWRkZWQgdG8gdGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdC4gVGhpcyBwcm9wZXJ0eSBjYXVzZXMgX2FuIGFkZGl0aW9uYWxfIGNsYXNzIG5hbWUgdG8gYmUgYWRkZWQgdG8gdGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdC4gVGhlcmVmb3JlLCB0aGlzIHByb3BlcnR5IHdpbGwgb25seSBhZGQgYXQgbW9zdCBvbmUgYWRkaXRpb25hbCBjbGFzcyBuYW1lIHRvIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogVG8gcmVtb3ZlIF9jbGFzc25hbWUtb3JpZW50YXRpb25fIGZyb20gdGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdCwgc2V0IHRoaXMgcHJvcGVydHkgdG8gYSBmYWxzeSB2YWx1ZSwgc3VjaCBhcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiA+IE5PVEU6IFlvdSBvbmx5IG5lZWQgdG8gc3BlY2lmeSBhbiBhZGRpdGlvbmFsIGNsYXNzIG5hbWUgd2hlbiB5b3UgbmVlZCB0byBoYXZlIG11bGx0aXBsZSBkaWZmZXJlbnQgc3R5bGVzIG9mIHNjcm9sbGJhcnMgb24gdGhlIHNhbWUgcGFnZS4gSWYgdGhpcyBpcyBub3QgYSByZXF1aXJlbWVudCwgdGhlbiB5b3UgZG9uJ3QgbmVlZCB0byBtYWtlIGEgbmV3IGNsYXNzOyB5b3Ugd291bGQganVzdCBjcmVhdGUgc29tZSBhZGRpdGlvbmFsIHJ1bGVzIHVzaW5nIHRoZSBzYW1lIHNlbGVjdG9ycyBpbiB0aGUgYnVpbHQtaW4gc3R5bGVzaGVldCAoLi4vY3NzL2ZpbmJhcnMuY3NzKTpcbiAgICAgKiAqYGRpdi5maW5iYXItdmVydGljYWxgIChvciBgZGl2LmZpbmJhci1ob3Jpem9udGFsYCkgZm9yIHRoZSBzY3JvbGxiYXJcbiAgICAgKiAqYGRpdi5maW5iYXItdmVydGljYWwgPiBkaXZgIChvciBgZGl2LmZpbmJhci1ob3Jpem9udGFsID4gZGl2YCkgZm9yIHRoZSBcInRodW1iLlwiXG4gICAgICpcbiAgICAgKiBPZiBjb3Vyc2UsIHlvdXIgcnVsZXMgc2hvdWxkIGNvbWUgYWZ0ZXIgdGhlIGJ1aWx0LWlucy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0IGNsYXNzUHJlZml4KHByZWZpeCkge1xuICAgICAgICBpZiAodGhpcy5fY2xhc3NQcmVmaXgpIHtcbiAgICAgICAgICAgIHRoaXMuYmFyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fY2xhc3NQcmVmaXggKyB0aGlzLm9yaWVudGF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NsYXNzUHJlZml4ID0gcHJlZml4O1xuXG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHRoaXMuYmFyLmNsYXNzTGlzdC5hZGQocHJlZml4ICsgJy0nICsgdGhpcy5vcmllbnRhdGlvbik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldCBjbGFzc1ByZWZpeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzUHJlZml4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBpbmNyZW1lbnRcbiAgICAgKiBAc3VtbWFyeSBOdW1iZXIgb2Ygc2Nyb2xsYmFyIGluZGV4IHVuaXRzIHJlcHJlc2VudGluZyBhIHBhZ2VmdWwuIFVzZWQgZXhjbHVzaXZlbHkgZm9yIHBhZ2luZyB1cCBhbmQgZG93biBhbmQgZm9yIHNldHRpbmcgdGh1bWIgc2l6ZSByZWxhdGl2ZSB0byBjb250ZW50IHNpemUuXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBDYW4gYWxzbyBiZSBnaXZlbiBhcyBhIHBhcmFtZXRlciB0byB0aGUge0BsaW5rIEZpbkJhciNyZXNpemV8cmVzaXplfSBtZXRob2QsIHdoaWNoIGlzIHBlcnRpbmVudCBiZWNhdXNlIGNvbnRlbnQgYXJlYSBzaXplIGNoYW5nZXMgYWZmZWN0IHRoZSBkZWZpbml0aW9uIG9mIGEgXCJwYWdlZnVsLlwiIEhvd2V2ZXIsIHlvdSBvbmx5IG5lZWQgdG8gZG8gdGhpcyBpZiB0aGlzIHZhbHVlIGlzIGJlaW5nIHVzZWQuIEl0IG5vdCB1c2VkIHdoZW46XG4gICAgICogKiB5b3UgZGVmaW5lIGBwYWdpbmcudXBgIGFuZCBgcGFnaW5nLmRvd25gXG4gICAgICogKiB5b3VyIHNjcm9sbGJhciBpcyB1c2luZyBgc2Nyb2xsUmVhbENvbnRlbnRgXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGluY3JlbWVudDogMSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGJhclN0eWxlc1xuICAgICAqIEBzdW1tYXJ5IFNjcm9sbGJhciBzdHlsZXMgdG8gYmUgYXBwbGllZCBieSB7QGxpbmsgRmluQmFyI3Jlc2l6ZXxyZXNpemUoKX0uXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgdmFsdWUgdG8gYmUgYXNzaWduZWQgdG8ge0BsaW5rIEZpbkJhciNzdHlsZXN8c3R5bGVzfSBvbiBlYWNoIGNhbGwgdG8ge0BsaW5rIEZpbkJhciNyZXNpemV8cmVzaXplKCl9LiBUaGF0IGlzLCBhIGhhc2ggb2YgdmFsdWVzIHRvIGJlIGNvcGllZCB0byB0aGUgc2Nyb2xsYmFyIGVsZW1lbnQncyBzdHlsZSBvYmplY3Qgb24gcmVzaXplOyBvciBgbnVsbGAgZm9yIG5vbmUuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBGaW5CYXIjc3R5bGV8c3R5bGV9XG4gICAgICogQHR5cGUge2ZpbmJhclN0eWxlc3xudWxsfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgYmFyU3R5bGVzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgc3R5bGVcbiAgICAgKiBAc3VtbWFyeSBBZGRpdGlvbmFsIHNjcm9sbGJhciBzdHlsZXMuXG4gICAgICogQGRlc2MgU2VlIHR5cGUgZGVmaW5pdGlvbiBmb3IgbW9yZSBkZXRhaWxzLiBUaGVzZSBzdHlsZXMgYXJlIGFwcGxpZWQgZGlyZWN0bHkgdG8gdGhlIHNjcm9sbGJhcidzIGBiYXJgIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBWYWx1ZXMgYXJlIGFkanVzdGVkIGFzIGZvbGxvd3MgYmVmb3JlIGJlaW5nIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQ6XG4gICAgICogMS4gSW5jbHVkZWQgXCJwc2V1ZG8tcHJvcGVydHlcIiBuYW1lcyBmcm9tIHRoZSBzY3JvbGxiYXIncyBvcmllbnRhdGlvbiBoYXNoLCB7QGxpbmsgRmluQmFyI29ofG9ofSwgYXJlIHRyYW5zbGF0ZWQgdG8gYWN0dWFsIHByb3BlcnR5IG5hbWVzIGJlZm9yZSBiZWluZyBhcHBsaWVkLlxuICAgICAqIDIuIFdoZW4gdGhlcmUgYXJlIG1hcmdpbnMsIHBlcmNlbnRhZ2VzIGFyZSB0cmFuc2xhdGVkIHRvIGFic29sdXRlIHBpeGVsIHZhbHVlcyBiZWNhdXNlIENTUyBpZ25vcmVzIG1hcmdpbnMgaW4gaXRzIHBlcmNlbnRhZ2UgY2FsY3VsYXRpb25zLlxuICAgICAqIDMuIElmIHlvdSBnaXZlIGEgdmFsdWUgd2l0aG91dCBhIHVuaXQgKGEgcmF3IG51bWJlciksIFwicHhcIiB1bml0IGlzIGFwcGVuZGVkLlxuICAgICAqXG4gICAgICogR2VuZXJhbCBub3RlczpcbiAgICAgKiAxLiBJdCBpcyBhbHdheXMgcHJlZmVyYWJsZSB0byBzcGVjaWZ5IHN0eWxlcyB2aWEgYSBzdHlsZXNoZWV0LiBPbmx5IHNldCB0aGlzIHByb3BlcnR5IHdoZW4geW91IG5lZWQgdG8gc3BlY2lmaWNhbGx5IG92ZXJyaWRlIChhKSBzdHlsZXNoZWV0IHZhbHVlKHMpLlxuICAgICAqIDIuIENhbiBiZSBzZXQgZGlyZWN0bHkgb3IgdmlhIGNhbGxzIHRvIHRoZSB7QGxpbmsgRmluQmFyI3Jlc2l6ZXxyZXNpemV9IG1ldGhvZC5cbiAgICAgKiAzLiBTaG91bGQgb25seSBiZSBzZXQgYWZ0ZXIgdGhlIHNjcm9sbGJhciBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAgICogNC4gQmVmb3JlIGFwcGx5aW5nIHRoZXNlIG5ldyB2YWx1ZXMgdG8gdGhlIGVsZW1lbnQsIF9hbGxfIGluLWxpbmUgc3R5bGUgdmFsdWVzIGFyZSByZXNldCAoYnkgcmVtb3ZpbmcgdGhlIGVsZW1lbnQncyBgc3R5bGVgIGF0dHJpYnV0ZSksIGV4cG9zaW5nIGluaGVyaXRlZCB2YWx1ZXMgKGZyb20gc3R5bGVzaGVldHMpLlxuICAgICAqIDUuIEVtcHR5IG9iamVjdCBoYXMgbm8gZWZmZWN0LlxuICAgICAqIDYuIEZhbHNleSB2YWx1ZSBpbiBwbGFjZSBvZiBvYmplY3QgaGFzIG5vIGVmZmVjdC5cbiAgICAgKlxuICAgICAqID4gQ0FWRUFUOiBEbyBub3QgYXR0ZW1wdCB0byB0cmVhdCB0aGUgb2JqZWN0IHlvdSBhc3NpZ24gdG8gdGhpcyBwcm9wZXJ0eSBhcyBpZiBpdCB3ZXJlIGB0aGlzLmJhci5zdHlsZWAuIFNwZWNpZmljYWxseSwgY2hhbmdpbmcgdGhpcyBvYmplY3QgYWZ0ZXIgYXNzaWduaW5nIGl0IHdpbGwgaGF2ZSBubyBlZmZlY3Qgb24gdGhlIHNjcm9sbGJhci4gWW91IG11c3QgYXNzaWduIGl0IGFnYWluIGlmIHlvdSB3YW50IGl0IHRvIGhhdmUgYW4gZWZmZWN0LlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgRmluQmFyI2JhclN0eWxlc3xiYXJTdHlsZXN9XG4gICAgICogQHR5cGUge2ZpbmJhclN0eWxlc31cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldCBzdHlsZShzdHlsZXMpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHN0eWxlcyA9IGV4dGVuZCh7fSwgc3R5bGVzLCB0aGlzLl9hdXhTdHlsZXMpKTtcblxuICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhciA9IHRoaXMuYmFyLFxuICAgICAgICAgICAgICAgIGJhclJlY3QgPSBiYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gYmFyLnBhcmVudEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgICBvaCA9IHRoaXMub2g7XG5cbiAgICAgICAgICAgIC8vIEJlZm9yZSBhcHBseWluZyBuZXcgc3R5bGVzLCByZXZlcnQgYWxsIHN0eWxlcyB0byB2YWx1ZXMgaW5oZXJpdGVkIGZyb20gc3R5bGVzaGVldHNcbiAgICAgICAgICAgIC8vIGJhci5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG5cbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsID0gc3R5bGVzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbiBvaCkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBvaFtrZXldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaXNOYU4oTnVtYmVyKHZhbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9ICh2YWwgfHwgMCkgKyAncHgnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoLyUkLy50ZXN0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBiYXIgc2l6ZSBnaXZlbiBhcyBwZXJjZW50YWdlIG9mIGNvbnRhaW5lciwgaWYgYmFyIGhhcyBtYXJnaW5zLCByZXN0YXRlIHNpemUgaW4gcGl4ZWxzIGxlc3MgbWFyZ2lucy5cbiAgICAgICAgICAgICAgICAgICAgLy8gKElmIGxlZnQgYXMgcGVyY2VudGFnZSwgQ1NTJ3MgY2FsY3VsYXRpb24gd2lsbCBub3QgZXhjbHVkZSBtYXJnaW5zLilcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZW50ZWQgPSBheGlzW2tleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5zID0gYmFyUmVjdFtvcmllbnRlZC5tYXJnaW5MZWFkaW5nXSArIGJhclJlY3Rbb3JpZW50ZWQubWFyZ2luVHJhaWxpbmddO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFyZ2lucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VJbnQodmFsLCAxMCkgLyAxMDAgKiBjb250YWluZXJSZWN0W29yaWVudGVkLnNpemVdIC0gbWFyZ2lucyArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBiYXIuc3R5bGVba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXN0eWxlTW91bnREaXYoKTtcbiAgICB9LFxuXG4gICAgc2V0IHRodW1iU3R5bGUoc3R5bGVzKSB7XG4gICAgICAgIGNvbnN0IHRodW1iID0gdGhpcy50aHVtYjtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHN0eWxlcyA9IGV4dGVuZCh7fSwgc3R5bGVzKSk7XG5cbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbCA9IHN0eWxlc1trZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihOdW1iZXIodmFsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gKHZhbCB8fCAwKSArICdweCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGh1bWIuc3R5bGVba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGh1bWIuc3R5bGUub3BhY2l0eSA9ICcxLjAnO1xuXG4gICAgICAgIHRoaXMuX3NldFRodW1iU2l6ZSgpO1xuICAgIH0sXG5cbiAgICBzZXQgbW91bnRTdHlsZShzdHlsZXMpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHN0eWxlcyA9IGV4dGVuZCh7fSwgc3R5bGVzKSk7XG5cbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBtb3VudCA9IHRoaXMubW91bnREaXY7XG5cbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsID0gc3R5bGVzW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKE51bWJlcih2YWwpKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSAodmFsIHx8IDApICsgJ3B4JztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb3VudC5zdHlsZVtrZXldID0gdmFsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG5hbWUgcGFnaW5nXG4gICAgICogQHN1bW1hcnkgRW5hYmxlIHBhZ2UgdXAvZG4gY2xpY2tzLlxuICAgICAqIEBkZXNjIFNldCBieSB0aGUgY29uc3RydWN0b3IuIFNlZSB0aGUgc2ltaWxhcmx5IG5hbWVkIHByb3BlcnR5IGluIHRoZSB7QGxpbmsgZmluYmFyT3B0aW9uc30gb2JqZWN0LlxuICAgICAqXG4gICAgICogSWYgdHJ1dGh5LCBsaXN0ZW4gZm9yIGNsaWNrcyBpbiBwYWdlLXVwIGFuZCBwYWdlLWRvd24gcmVnaW9ucyBvZiBzY3JvbGxiYXIuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QsIGNhbGwgYC5wYWdpbmcudXAoKWAgb24gcGFnZS11cCBjbGlja3MgYW5kIGAucGFnaW5nLmRvd24oKWAgd2lsbCBiZSBjYWxsZWQgb24gcGFnZS1kb3duIGNsaWNrcy5cbiAgICAgKlxuICAgICAqIENoYW5naW5nIHRoZSB0cnV0aGluZXNzIG9mIHRoaXMgdmFsdWUgYWZ0ZXIgaW5zdGFudGlhdGlvbiBjdXJyZW50bHkgaGFzIG5vIGVmZmVjdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnxvYmplY3R9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwYWdpbmc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSByYW5nZVxuICAgICAqIEBzdW1tYXJ5IFNldHRlciBmb3IgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gc2Nyb2xsIHZhbHVlcy5cbiAgICAgKiBAZGVzYyBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yLiBUaGVzZSB2YWx1ZXMgYXJlIHRoZSBsaW1pdHMgZm9yIHtAbGluayBGb29CYXIjaW5kZXh8aW5kZXh9LlxuICAgICAqXG4gICAgICogVGhlIHNldHRlciBhY2NlcHRzIGFuIG9iamVjdCB3aXRoIGV4YWN0bHkgdHdvIG51bWVyaWMgcHJvcGVydGllczogYC5taW5gIHdoaWNoIG11c3QgYmUgbGVzcyB0aGFuIGAubWF4YC4gVGhlIHZhbHVlcyBhcmUgZXh0cmFjdGVkIGFuZCB0aGUgb2JqZWN0IGlzIGRpc2NhcmRlZC5cbiAgICAgKlxuICAgICAqIFRoZSBnZXR0ZXIgcmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCBgLm1pbmAgYW5kICcubWF4YC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtyYW5nZVR5cGV9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXQgcmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgdmFsaWRSYW5nZShyYW5nZSk7XG4gICAgICAgIHRoaXMubWluID0gcmFuZ2UubWluO1xuICAgICAgICB0aGlzLm1heCA9IHJhbmdlLm1heDtcbiAgICAgICAgdGhpcy5jb250ZW50U2l6ZSA9IHJhbmdlLm1heCAtIHJhbmdlLm1pbiArIDE7XG4gICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLmluZGV4OyAvLyByZS1jbGFtcFxuICAgIH0sXG4gICAgZ2V0IHJhbmdlKCkge1xuICAgICAgICByZXR1cm4geyBtaW46IHRoaXMubWluLCBtYXg6IHRoaXMubWF4IH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEluZGV4IHZhbHVlIG9mIHRoZSBzY3JvbGxiYXIuXG4gICAgICogQGRlc2MgVGhpcyBpcyB0aGUgcG9zaXRpb24gb2YgdGhlIHNjcm9sbCB0aHVtYi5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyB2YWx1ZSBjbGFtcHMgaXQgdG8ge0BsaW5rIEZpbkJhciNtaW58bWlufS4ue0BsaW5rIEZpbkJhciNtYXh8bWF4fSwgc2Nyb2xsIHRoZSBjb250ZW50LCBhbmQgbW92ZXMgdGh1bWIuXG4gICAgICpcbiAgICAgKiBHZXR0aW5nIHRoaXMgdmFsdWUgcmV0dXJucyB0aGUgY3VycmVudCBpbmRleC4gVGhlIHJldHVybmVkIHZhbHVlIHdpbGwgYmUgaW4gdGhlIHJhbmdlIGBtaW5gLi5gbWF4YC4gSXQgaXMgaW50ZW50aW9uYWxseSBub3Qgcm91bmRlZC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIHZhbHVlIGFzIGFuIGFsdGVybmF0aXZlIHRvIChvciBpbiBhZGRpdGlvbiB0bykgdXNpbmcgdGhlIHtAbGluayBGaW5CYXIjb25jaGFuZ2V8b25jaGFuZ2V9IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgRmluQmFyI19zZXRTY3JvbGx8X3NldFNjcm9sbH1cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0IGluZGV4KGlkeCkge1xuICAgICAgICBpZHggPSBNYXRoLm1pbih0aGlzLm1heCwgTWF0aC5tYXgodGhpcy5taW4sIGlkeCkpOyAvLyBjbGFtcCBpdFxuICAgICAgICB0aGlzLl9zZXRTY3JvbGwoaWR4KTtcbiAgICB9LFxuICAgIGdldCBpbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzdW1tYXJ5IE1vdmUgdGhlIHRodW1iLlxuICAgICAqIEBkZXNjIEFsc28gZGlzcGxheXMgdGhlIGluZGV4IHZhbHVlIGluIHRoZSB0ZXN0IHBhbmVsIGFuZCBpbnZva2VzIHRoZSBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0gaWR4IC0gVGhlIG5ldyBzY3JvbGwgaW5kZXgsIGEgdmFsdWUgaW4gdGhlIHJhbmdlIGBtaW5gLi5gbWF4YC5cbiAgICAgKiBAcGFyYW0gW3NjYWxlZD1mKGlkeCldIC0gVGhlIG5ldyB0aHVtYiBwb3NpdGlvbiBpbiBwaXhlbHMgYW5kIHNjYWxlZCByZWxhdGl2ZSB0byB0aGUgY29udGFpbmluZyB7QGxpbmsgRmluQmFyI2JhcnxiYXJ9IGVsZW1lbnQsIGkuZS4sIGEgcHJvcG9ydGlvbmFsIG51bWJlciBpbiB0aGUgcmFuZ2UgYDBgLi5gdGh1bWJNYXhgLiBXaGVuIG9taXR0ZWQsIGEgZnVuY3Rpb24gb2YgYGlkeGAgaXMgdXNlZC5cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIF9zZXRTY3JvbGw6IGZ1bmN0aW9uKGlkeCwgc2NhbGVkKSB7XG4gICAgICAgIHRoaXMuX2luZGV4ID0gaWR4O1xuXG4gICAgICAgIC8vIERpc3BsYXkgdGhlIGluZGV4IHZhbHVlIGluIHRoZSB0ZXN0IHBhbmVsXG4gICAgICAgIGlmICh0aGlzLnRlc3RQYW5lbEl0ZW0gJiYgdGhpcy50ZXN0UGFuZWxJdGVtLmluZGV4IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy50ZXN0UGFuZWxJdGVtLmluZGV4LmlubmVySFRNTCA9IE1hdGgucm91bmQoaWR4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGwgdGhlIGNhbGxiYWNrXG4gICAgICAgIGlmICh0aGlzLm9uY2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLm9uY2hhbmdlLmNhbGwodGhpcywgTWF0aC5yb3VuZChpZHgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1vdmUgdGhlIHRodW1iXG4gICAgICAgIGlmIChzY2FsZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2NhbGVkID0gKGlkeCAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSAqIHRoaXMudGh1bWJNYXg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHVtYi5zdHlsZVt0aGlzLm9oLmxlYWRpbmddID0gc2NhbGVkICsgJ3B4JztcbiAgICB9LFxuXG4gICAgc2Nyb2xsUmVhbENvbnRlbnQ6IGZ1bmN0aW9uKGlkeCkge1xuICAgICAgICBjb25zdCBjb250YWluZXJSZWN0ID0gdGhpcy5jb250ZW50LnBhcmVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICBzaXplUHJvcCA9IHRoaXMub2guc2l6ZSxcbiAgICAgICAgICAgIG1heFNjcm9sbCA9IE1hdGgubWF4KDAsIHRoaXMuY29udGVudFtzaXplUHJvcF0gLSBjb250YWluZXJSZWN0W3NpemVQcm9wXSksXG4gICAgICAgICAgICBzY3JvbGwgPSAoaWR4IC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pICogbWF4U2Nyb2xsO1xuXG4gICAgICAgIHRoaXMuY29udGVudC5zdHlsZVt0aGlzLm9oLmxlYWRpbmddID0gLXNjcm9sbCArICdweCc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJlY2FsY3VsYXRlIHRodW1iIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGRlc2MgVGhpcyBtZXRob2QgcmVjYWxjdWxhdGVzIHRoZSB0aHVtYiBzaXplIGFuZCBwb3NpdGlvbi4gQ2FsbCBpdCBvbmNlIGFmdGVyIGluc2VydGluZyB5b3VyIHNjcm9sbGJhciBpbnRvIHRoZSBET00sIGFuZCByZXBlYXRlZGx5IHdoaWxlIHJlc2l6aW5nIHRoZSBzY3JvbGxiYXIgKHdoaWNoIHR5cGljYWxseSBoYXBwZW5zIHdoZW4gdGhlIHNjcm9sbGJhcidzIHBhcmVudCBpcyByZXNpemVkIGJ5IHVzZXIuXG4gICAgICpcbiAgICAgKiA+IFRoaXMgZnVuY3Rpb24gc2hpZnRzIGFyZ3MgaWYgZmlyc3QgYXJnIG9taXR0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2luY3JlbWVudD10aGlzLmluY3JlbWVudF0gLSBSZXNldHMge0BsaW5rIEZvb0JhciNpbmNyZW1lbnR8aW5jcmVtZW50fSAoc2VlKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YmFyU3R5bGVzfSBbYmFyU3R5bGVzPXRoaXMuYmFyU3R5bGVzXSAtIChTZWUgdHlwZSBkZWZpbml0aW9uIGZvciBkZXRhaWxzLikgU2Nyb2xsYmFyIHN0eWxlcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBiYXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge2NvbnRlbnRGdWxsV2lkdGh9IFtjb250ZW50RnVsbFdpZHRoPXRoaXMuY29udGVudFNpemVdIC0gQ29udGVudCBmdWxsIHdpZHRoIGluIHB4XG4gICAgICpcbiAgICAgKiBPbmx5IHNwZWNpZnkgYSBgYmFyU3R5bGVzYCBvYmplY3Qgd2hlbiB5b3UgbmVlZCB0byBvdmVycmlkZSBzdHlsZXNoZWV0IHZhbHVlcy4gSWYgcHJvdmlkZWQsIGJlY29tZXMgdGhlIG5ldyBkZWZhdWx0IChgdGhpcy5iYXJTdHlsZXNgKSwgZm9yIHVzZSBhcyBhIGRlZmF1bHQgb24gc3Vic2VxdWVudCBjYWxscy5cbiAgICAgKlxuICAgICAqIEl0IGlzIGdlbmVyYWxseSB0aGUgY2FzZSB0aGF0IHRoZSBzY3JvbGxiYXIncyBuZXcgcG9zaXRpb24gaXMgc3VmZmljaWVudGx5IGRlc2NyaWJlZCBieSB0aGUgY3VycmVudCBzdHlsZXMuIFRoZXJlZm9yZSwgaXQgaXMgdW51c3VhbCB0byBuZWVkIHRvIHByb3ZpZGUgYSBgYmFyU3R5bGVzYCBvYmplY3Qgb24gZXZlcnkgY2FsbCB0byBgcmVzaXplYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtGaW5CYXJ9IFNlbGYgZm9yIGNoYWluaW5nLlxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbihpbmNyZW1lbnQsIGJhclN0eWxlcywgY29udGVudEZ1bGxXaWR0aCkge1xuICAgICAgICBpZiAoY29udGVudEZ1bGxXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRTaXplID0gY29udGVudEZ1bGxXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJhciA9IHRoaXMuYmFyO1xuXG4gICAgICAgIGlmICghYmFyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gbm90IGluIERPTSB5ZXQgc28gbm90aGluZyB0byBkb1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5tb3VudERpdi5wYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAvLyBzaGlmdCBhcmdzIGlmIGlmIDFzdCBhcmcgb21pdHRlZFxuICAgICAgICBpZiAodHlwZW9mIGluY3JlbWVudCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGJhclN0eWxlcyA9IGluY3JlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3R5bGUgPSB0aGlzLmJhclN0eWxlcyA9IGJhclN0eWxlcyB8fCB0aGlzLmJhclN0eWxlcztcblxuICAgICAgICAvLyBCb3VuZCB0byByZWFsIGNvbnRlbnQ6IENvbnRlbnQgd2FzIGdpdmVuIGJ1dCBubyBvbmNoYW5nZSBoYW5kbGVyLlxuICAgICAgICAvLyBTZXQgdXAgLm9uY2hhbmdlLCAuY29udGFpbmVyU2l6ZSwgYW5kIC5pbmNyZW1lbnQuXG4gICAgICAgIC8vIE5vdGUgdGhpcyBvbmx5IG1ha2VzIHNlbnNlIGlmIHlvdXIgaW5kZXggdW5pdCBpcyBwaXhlbHMuXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5vbmNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25jaGFuZ2UgPSB0aGlzLnNjcm9sbFJlYWxDb250ZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFNpemUgPSB0aGlzLmNvbnRlbnRbdGhpcy5vaC5zaXplXTtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbiA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXggPSB0aGlzLmNvbnRlbnRTaXplIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29udGFpbmVyU2l6ZSA9IGNvbnRhaW5lclJlY3RbdGhpcy5vaC5zaXplXTtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnQgPSB0aGlzLmNvbnRhaW5lclNpemUgLyAzO1xuXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgdGhpcy50ZXN0UGFuZWxJdGVtID0gdGhpcy50ZXN0UGFuZWxJdGVtIHx8IHRoaXMuX2FkZFRlc3RQYW5lbEl0ZW0oKTtcbiAgICAgICAgdGhpcy5fc2V0VGh1bWJTaXplKCk7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5yZXN0eWxlTW91bnREaXYoKTtcblxuICAgICAgICBpZiAodGhpcy5kZWx0YVByb3AgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuZXZlbnRzLm9ud2hlZWwpO1xuICAgICAgICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLmV2ZW50cy5vbnRvdWNoc3RhcnQpO1xuICAgICAgICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuZXZlbnRzLm9udG91Y2htb3ZlKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuZXZlbnRzLm9udG91Y2hlbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlc3R5bGVNb3VudERpdjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5iYXIpO1xuXG4gICAgICAgIGlmICh0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHRoaXMubW91bnREaXYuc3R5bGUuaGVpZ2h0ID0gY29tcHV0ZWRTdHlsZXMuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5tb3VudERpdi5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgICAgIHRoaXMubW91bnREaXYuc3R5bGUuYm90dG9tID0gJzAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb3VudERpdi5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgICAgICB0aGlzLm1vdW50RGl2LnN0eWxlLndpZHRoID0gY29tcHV0ZWRTdHlsZXMud2lkdGg7XG4gICAgICAgICAgICB0aGlzLm1vdW50RGl2LnN0eWxlLnJpZ2h0ID0gJzAnO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNob3J0ZW4gdHJhaWxpbmcgZW5kIG9mIHNjcm9sbGJhciBieSB0aGlja25lc3Mgb2Ygc29tZSBvdGhlciBzY3JvbGxiYXIuXG4gICAgICogQGRlc2MgSW4gdGhlIFwiY2xhc3NpY2FsXCIgc2NlbmFyaW8gd2hlcmUgdmVydGljYWwgc2Nyb2xsIGJhciBpcyBvbiB0aGUgcmlnaHQgYW5kIGhvcml6b250YWwgc2Nyb2xsYmFyIGlzIG9uIHRoZSBib3R0b20sIHlvdSB3YW50IHRvIHNob3J0ZW4gdGhlIFwidHJhaWxpbmcgZW5kXCIgKGJvdHRvbSBhbmQgcmlnaHQgZW5kcywgcmVzcGVjdGl2ZWx5KSBvZiBhdCBsZWFzdCBvbmUgb2YgdGhlbSBzbyB0aGV5IGRvbid0IG92ZXJsYXkuXG4gICAgICpcbiAgICAgKiBUaGlzIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGlzIGFuIHByb2dyYW1tYXRpYyBhbHRlcm5hdGl2ZSB0byBoYXJkY29kaW5nIHRoZSBjb3JyZWN0IHN0eWxlIHdpdGggdGhlIGNvcnJlY3QgdmFsdWUgaW4geW91ciBzdHlsZXNoZWV0OyBvciBzZXR0aW5nIHRoZSBjb3JyZWN0IHN0eWxlIHdpdGggdGhlIGNvcnJlY3QgdmFsdWUgaW4gdGhlIHtAbGluayBGaW5CYXIjYmFyU3R5bGVzfGJhclN0eWxlc30gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgRmluQmFyI2ZvcmVzaG9ydGVuQnl8Zm9yZXNob3J0ZW5CeX0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ZpbkJhcnxudWxsfSBvdGhlckZpbkJhciAtIE90aGVyIHNjcm9sbGJhciB0byBhdm9pZCBieSBzaG9ydGVuaW5nIHRoaXMgb25lOyBgbnVsbGAgcmVtb3ZlcyB0aGUgdHJhaWxpbmcgc3BhY2VcbiAgICAgKiBAcmV0dXJucyB7RmluQmFyfSBGb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBzaG9ydGVuQnk6IGZ1bmN0aW9uKG90aGVyRmluQmFyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3J0ZW5FbmRCeSgndHJhaWxpbmcnLCBvdGhlckZpbkJhcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNob3J0ZW4gbGVhZGluZyBlbmQgb2Ygc2Nyb2xsYmFyIGJ5IHRoaWNrbmVzcyBvZiBzb21lIG90aGVyIHNjcm9sbGJhci5cbiAgICAgKiBAZGVzYyBTdXBwb3J0cyBub24tY2xhc3NpY2FsIHNjcm9sbGJhciBzY2VuYXJpb3Mgd2hlcmUgdmVydGljYWwgc2Nyb2xsIGJhciBtYXkgYmUgb24gbGVmdCBhbmQgaG9yaXpvbnRhbCBzY3JvbGxiYXIgbWF5IGJlIG9uIHRvcCwgaW4gd2hpY2ggY2FzZSB5b3Ugd2FudCB0byBzaG9ydGVuIHRoZSBcImxlYWRpbmcgZW5kXCIgcmF0aGVyIHRoYW4gdGhlIHRyYWlsaW5nIGVuZC5cbiAgICAgKiBAc2VlIHtAbGluayBGaW5CYXIjc2hvcnRlbkJ5fHNob3J0ZW5CeX0uXG4gICAgICogQHBhcmFtIHtGaW5CYXJ8bnVsbH0gb3RoZXJGaW5CYXIgLSBPdGhlciBzY3JvbGxiYXIgdG8gYXZvaWQgYnkgc2hvcnRlbmluZyB0aGlzIG9uZTsgYG51bGxgIHJlbW92ZXMgdGhlIHRyYWlsaW5nIHNwYWNlXG4gICAgICogQHJldHVybnMge0ZpbkJhcn0gRm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgZm9yZXNob3J0ZW5CeTogZnVuY3Rpb24ob3RoZXJGaW5CYXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvcnRlbkVuZEJ5KCdsZWFkaW5nJywgb3RoZXJGaW5CYXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZW5lcmFsaXplZCBzaG9ydGVuaW5nIGZ1bmN0aW9uLlxuICAgICAqIEBzZWUge0BsaW5rIEZpbkJhciNzaG9ydGVuQnl8c2hvcnRlbkJ5fS5cbiAgICAgKiBAc2VlIHtAbGluayBGaW5CYXIjZm9yZXNob3J0ZW5CeXxmb3Jlc2hvcnRlbkJ5fS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2hpY2hFbmQgLSBhIENTUyBzdHlsZSBwcm9wZXJ0eSBuYW1lIG9yIGFuIG9yaWVudGF0aW9uIGhhc2ggbmFtZSB0aGF0IHRyYW5zbGF0ZXMgdG8gYSBDU1Mgc3R5bGUgcHJvcGVydHkgbmFtZS5cbiAgICAgKiBAcGFyYW0ge0ZpbkJhcnxudWxsfSBvdGhlckZpbkJhciAtIE90aGVyIHNjcm9sbGJhciB0byBhdm9pZCBieSBzaG9ydGVuaW5nIHRoaXMgb25lOyBgbnVsbGAgcmVtb3ZlcyB0aGUgdHJhaWxpbmcgc3BhY2VcbiAgICAgKiBAcmV0dXJucyB7RmluQmFyfSBGb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBzaG9ydGVuRW5kQnk6IGZ1bmN0aW9uKHdoaWNoRW5kLCBvdGhlckZpbkJhcikge1xuICAgICAgICBpZiAoIW90aGVyRmluQmFyKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYXV4U3R5bGVzO1xuICAgICAgICB9IGVsc2UgaWYgKG90aGVyRmluQmFyIGluc3RhbmNlb2YgRmluQmFyICYmIG90aGVyRmluQmFyLm9yaWVudGF0aW9uICE9PSB0aGlzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBvdGhlclN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUob3RoZXJGaW5CYXIuYmFyKSxcbiAgICAgICAgICAgICAgICBvb2ggPSBvcmllbnRhdGlvbkhhc2hlc1tvdGhlckZpbkJhci5vcmllbnRhdGlvbl07XG4gICAgICAgICAgICB0aGlzLl9hdXhTdHlsZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX2F1eFN0eWxlc1t3aGljaEVuZF0gPSBvdGhlclN0eWxlW29vaC50aGlja25lc3NdIC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG4gICAgfSxcblxuICAgIHNob3J0ZW5FbmRCeVZhbHVlOiBmdW5jdGlvbih3aGljaEVuZCwgc2hvcnRlblZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2F1eFN0eWxlcyA9IHRoaXMuX2F1eFN0eWxlcyA/IHRoaXMuX2F1eFN0eWxlcyA6IHt9O1xuICAgICAgICB0aGlzLl9hdXhTdHlsZXNbd2hpY2hFbmRdID0gc2hvcnRlblZhbHVlICsgJ3B4JztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHN1bW1hcnkgU2V0cyB0aGUgcHJvcG9ydGlvbmFsIHRodW1iIHNpemUgYW5kIGhpZGVzIHRodW1iIHdoZW4gMTAwJS5cbiAgICAgKiBAZGVzYyBUaGUgdGh1bWIgc2l6ZSBoYXMgYW4gYWJzb2x1dGUgbWluaW11bSBvZiAyMCAocGl4ZWxzKS5cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIF9zZXRUaHVtYlNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBvaCA9IHRoaXMub2gsXG4gICAgICAgICAgICB0aHVtYkNvbXAgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLnRodW1iKSxcbiAgICAgICAgICAgIHRodW1iTWFyZ2luTGVhZGluZyA9IHBhcnNlSW50KHRodW1iQ29tcFtvaC5tYXJnaW5MZWFkaW5nXSksXG4gICAgICAgICAgICB0aHVtYk1hcmdpblRyYWlsaW5nID0gcGFyc2VJbnQodGh1bWJDb21wW29oLm1hcmdpblRyYWlsaW5nXSksXG4gICAgICAgICAgICB0aHVtYk1hcmdpbnMgPSB0aHVtYk1hcmdpbkxlYWRpbmcgKyB0aHVtYk1hcmdpblRyYWlsaW5nLFxuICAgICAgICAgICAgYmFyU2l6ZSA9IHRoaXMuYmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW29oLnNpemVdIC0gdGh1bWJNYXJnaW5zLFxuICAgICAgICAgICAgdGh1bWJTaXplID0gTWF0aC5tYXgoMjAsIGJhclNpemUgKiB0aGlzLmNvbnRhaW5lclNpemUgLyB0aGlzLmNvbnRlbnRTaXplKTtcblxuICAgICAgICBjb25zdCBvbGRWaXNpYmlsaXR5ID0gdGhpcy5tb3VudERpdi5zdHlsZS52aXNpYmlsaXR5O1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXJTaXplIDwgdGhpcy5jb250ZW50U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5tb3VudERpdi5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICAgICAgdGhpcy50aHVtYi5zdHlsZVtvaC5zaXplXSA9IHRodW1iU2l6ZSArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vdW50RGl2LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvbGRWaXNpYmlsaXR5ICE9PSB0aGlzLm1vdW50RGl2LnN0eWxlLnZpc2liaWxpdHkgJiYgdGhpcy5vbkJhclZpc2liaWxpdHlDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLm9uQmFyVmlzaWJpbGl0eUNoYW5nZWQodGhpcy5tb3VudERpdi5zdHlsZS52aXNpYmlsaXR5ID09PSAndmlzaWJsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBuYW1lIHRodW1iTWF4XG4gICAgICAgICAqIEBzdW1tYXJ5IE1heGltdW0gb2Zmc2V0IG9mIHRodW1iJ3MgbGVhZGluZyBlZGdlLlxuICAgICAgICAgKiBAZGVzYyBUaGlzIGlzIHRoZSBwaXhlbCBvZmZzZXQgd2l0aGluIHRoZSBzY3JvbGxiYXIgb2YgdGhlIHRodW1iIHdoZW4gaXQgaXMgYXQgaXRzIG1heGltdW0gcG9zaXRpb24gYXQgdGhlIGV4dHJlbWUgZW5kIG9mIGl0cyByYW5nZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyB2YWx1ZSB0YWtlcyBpbnRvIGFjY291bnQgdGhlIG5ld2x5IGNhbGN1bGF0ZWQgc2l6ZSBvZiB0aGUgdGh1bWIgZWxlbWVudCAoaW5jbHVkaW5nIGl0cyBtYXJnaW5zKSBhbmQgdGhlIGlubmVyIHNpemUgb2YgdGhlIHNjcm9sbGJhciAodGhlIHRodW1iJ3MgY29udGFpbmluZyBlbGVtZW50LCBpbmNsdWRpbmcgX2l0c18gbWFyZ2lucykuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5PVEU6IFNjcm9sbGJhciBwYWRkaW5nIGlzIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgYW5kIGFzc3VtZWQgdG8gYmUgMCBpbiB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBhbmQgaXMgYXNzdW1lZCB0byBiZSBgMGA7IHVzZSB0aHVtYiBtYXJnaW5zIGluIHBsYWNlIG9mIHNjcm9sbGJhciBwYWRkaW5nLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aHVtYk1heCA9IGJhclNpemUgLSB0aHVtYlNpemUgLSB0aHVtYk1hcmdpbnM7XG5cbiAgICAgICAgdGhpcy50aHVtYk1hcmdpbkxlYWRpbmcgPSB0aHVtYk1hcmdpbkxlYWRpbmc7IC8vIHVzZWQgaW4gbW91c2Vkb3duXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJlbW92ZSB0aGUgc2Nyb2xsYmFyLlxuICAgICAqIEBkZXNjIFVuaG9va3MgYWxsIHRoZSBldmVudCBoYW5kbGVycyBhbmQgdGhlbiByZW1vdmVzIHRoZSBlbGVtZW50IGZyb20gdGhlIERPTS4gQWx3YXlzIGNhbGwgdGhpcyBtZXRob2QgcHJpb3IgdG8gZGlzcG9zaW5nIG9mIHRoZSBzY3JvbGxiYXIgb2JqZWN0LlxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5iYXIub25tb3VzZWRvd24gPSBudWxsO1xuICAgICAgICB0aGlzLl9yZW1vdmVFdnQoJ21vdXNlbW92ZScpO1xuICAgICAgICB0aGlzLl9yZW1vdmVFdnQoJ21vdXNldXAnKTtcblxuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLm1vdW50RGl2LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGlmIChjb250YWluZXIuX3JlbW92ZUV2dCkge1xuICAgICAgICAgICAgY29udGFpbmVyLl9yZW1vdmVFdnQoJ3doZWVsJywgdGhpcy5ldmVudHMub253aGVlbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJhci5vbmNsaWNrID1cbiAgICAgICAgICAgIHRoaXMudGh1bWIub25jbGljayA9XG4gICAgICAgICAgICAgICAgdGhpcy50aHVtYi50cmFuc2l0aW9uZW5kID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aHVtYi5vbm1vdXNlb3V0ID0gbnVsbDtcblxuICAgICAgICB0aGlzLmJhci5yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb24gX2FkZFRlc3RQYW5lbEl0ZW1cbiAgICAgKiBAc3VtbWFyeSBBcHBlbmQgYSB0ZXN0IHBhbmVsIGVsZW1lbnQuXG4gICAgICogQGRlc2MgSWYgdGhlcmUgaXMgYSB0ZXN0IHBhbmVsIGluIHRoZSBET00gKHR5cGljYWxseSBhbiBgPG9sPi4uLjwvb2w+YCBlbGVtZW50KSB3aXRoIGNsYXNzIG5hbWVzIG9mIGJvdGggYHRoaXMuY2xhc3NQcmVmaXhgIGFuZCBgJ3Rlc3QtcGFuZWwnYCAob3IsIGJhcnJpbmcgdGhhdCwgYW55IGVsZW1lbnQgd2l0aCBjbGFzcyBuYW1lIGAndGVzdC1wYW5lbCdgKSwgYW4gYDxsaT4uLi48L2xpPmAgZWxlbWVudCB3aWxsIGJlIGNyZWF0ZWQgYW5kIGFwcGVuZGVkIHRvIGl0LiBUaGlzIG5ldyBlbGVtZW50IHdpbGwgY29udGFpbiBhIHNwYW4gZm9yIGVhY2ggY2xhc3MgbmFtZSBnaXZlbi5cbiAgICAgKlxuICAgICAqIFlvdSBzaG91bGQgZGVmaW5lIGEgQ1NTIHNlbGVjdG9yIGAubGlzdGVuaW5nYCBmb3IgdGhlc2Ugc3BhbnMuIFRoaXMgY2xhc3Mgd2lsbCBiZSBhZGRlZCB0byB0aGUgc3BhbnMgdG8gYWx0ZXIgdGhlaXIgYXBwZWFyYW5jZSB3aGVuIGEgbGlzdGVuZXIgaXMgYWRkZWQgd2l0aCB0aGF0IGNsYXNzIG5hbWUgKHByZWZpeGVkIHdpdGggJ29uJykuXG4gICAgICpcbiAgICAgKiAoVGhpcyBpcyBhbiBpbnRlcm5hbCBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbmNlIGJ5IHRoZSBjb25zdHJ1Y3RvciBvbiBldmVyeSBpbnN0YW50aWF0aW9uLilcbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudHx1bmRlZmluZWR9IFRoZSBhcHBlbmRlZCBgPGxpPi4uLjwvbGk+YCBlbGVtZW50IG9yIGB1bmRlZmluZWRgIGlmIHRoZXJlIGlzIG5vIHRlc3QgcGFuZWwuXG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBfYWRkVGVzdFBhbmVsSXRlbTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGxldCB0ZXN0UGFuZWxJdGVtLFxuICAgICAgICAgICAgdGVzdFBhbmVsRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYC4ke3RoaXMuX2NsYXNzUHJlZml4fS50ZXN0LXBhbmVsYCkgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRlc3QtcGFuZWwnKTtcblxuICAgICAgICBpZiAodGVzdFBhbmVsRWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgdGVzdFBhbmVsSXRlbVBhcnROYW1lcyA9IFsnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdtb3VzZXVwJywgJ2luZGV4J10sXG4gICAgICAgICAgICAgICAgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG5cbiAgICAgICAgICAgIHRlc3RQYW5lbEl0ZW1QYXJ0TmFtZXMuZm9yRWFjaChmdW5jdGlvbihwYXJ0TmFtZSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uaW5uZXJIVE1MICs9ICc8c3BhbiBjbGFzcz1cIicgKyBwYXJ0TmFtZSArICdcIj4nICsgcGFydE5hbWUucmVwbGFjZSgnbW91c2UnLCAnJykgKyAnPC9zcGFuPic7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGVzdFBhbmVsRWxlbWVudC5hcHBlbmRDaGlsZChpdGVtKTtcblxuICAgICAgICAgICAgdGVzdFBhbmVsSXRlbSA9IHt9O1xuICAgICAgICAgICAgdGVzdFBhbmVsSXRlbVBhcnROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKHBhcnROYW1lKSB7XG4gICAgICAgICAgICAgICAgdGVzdFBhbmVsSXRlbVtwYXJ0TmFtZV0gPSBpdGVtLmdldEVsZW1lbnRzQnlDbGFzc05hbWUocGFydE5hbWUpWzBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGVzdFBhbmVsSXRlbTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZUV2dDogZnVuY3Rpb24oZXZ0TmFtZSkge1xuICAgICAgICB0aGlzLmV2ZW50cy5fcmVtb3ZlRXZ0KGV2dE5hbWUpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGV4dGVuZChvYmopIHtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBvYmpuID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpZiAob2Jqbikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2Jqbikge1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0gb2JqbltrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIHZhbGlkUmFuZ2UocmFuZ2UpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocmFuZ2UpLFxuICAgICAgICB2YWxpZCA9IGtleXMubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICB0eXBlb2YgcmFuZ2UubWluID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgdHlwZW9mIHJhbmdlLm1heCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHJhbmdlLm1pbiA8PSByYW5nZS5tYXg7XG5cbiAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIC5yYW5nZSBvYmplY3QuJyk7XG4gICAgfVxufVxuXG5jb25zdCBheGlzID0ge1xuICAgIHRvcDogJ3ZlcnRpY2FsJyxcbiAgICBib3R0b206ICd2ZXJ0aWNhbCcsXG4gICAgaGVpZ2h0OiAndmVydGljYWwnLFxuICAgIGxlZnQ6ICdob3Jpem9udGFsJyxcbiAgICByaWdodDogJ2hvcml6b250YWwnLFxuICAgIHdpZHRoOiAnaG9yaXpvbnRhbCdcbn07XG5cbmxldCBjc3NGaW5CYXJzOyAvLyBkZWZpbml0aW9uIGluc2VydGVkIGJ5IGd1bHBmaWxlIGJldHdlZW4gZm9sbG93aW5nIGNvbW1lbnRzXG4vKiBpbmplY3Q6Y3NzICovXG5jc3NGaW5CYXJzID0gJ2Rpdi5maW5iYXItaG9yaXpvbnRhbCxkaXYuZmluYmFyLXZlcnRpY2Fse3Bvc2l0aW9uOmFic29sdXRlO21hcmdpbjozcHh9ZGl2LmZpbmJhci1ob3Jpem9udGFsPi50aHVtYixkaXYuZmluYmFyLXZlcnRpY2FsPi50aHVtYntwb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kLWNvbG9yOiNkM2QzZDM7LXdlYmtpdC1ib3gtc2hhZG93OjAgMCAxcHggIzAwMDstbW96LWJveC1zaGFkb3c6MCAwIDFweCAjMDAwO2JveC1zaGFkb3c6MCAwIDFweCAjMDAwO2JvcmRlci1yYWRpdXM6NHB4O21hcmdpbjoycHg7b3BhY2l0eTouNDt0cmFuc2l0aW9uOm9wYWNpdHkgLjVzfWRpdi5maW5iYXItaG9yaXpvbnRhbD4udGh1bWIuaG92ZXIsZGl2LmZpbmJhci12ZXJ0aWNhbD4udGh1bWIuaG92ZXJ7b3BhY2l0eToxO3RyYW5zaXRpb246b3BhY2l0eSAuNXN9ZGl2LmZpbmJhci12ZXJ0aWNhbHt0b3A6MDtib3R0b206MDtyaWdodDowO3dpZHRoOjExcHh9ZGl2LmZpbmJhci12ZXJ0aWNhbD4udGh1bWJ7dG9wOjA7cmlnaHQ6MDt3aWR0aDo3cHh9ZGl2LmZpbmJhci1ob3Jpem9udGFse2xlZnQ6MDtyaWdodDowO2JvdHRvbTowO2hlaWdodDoxMXB4fWRpdi5maW5iYXItaG9yaXpvbnRhbD4udGh1bWJ7bGVmdDowO2JvdHRvbTowO2hlaWdodDo3cHh9JztcblxuLyogZW5kaW5qZWN0ICovXG5cbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICAgIHRocm93ICdmaW5iYXJzOiAnICsgbXNnO1xufVxuXG4vLyBJbnRlcmZhY2Vcbm1vZHVsZS5leHBvcnRzID0gRmluQmFyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgdmVydGljYWw6IHtcbiAgICAgICAgY29vcmRpbmF0ZTogJ2NsaWVudFknLFxuICAgICAgICBheGlzOiAncGFnZVknLFxuICAgICAgICBzaXplOiAnaGVpZ2h0JyxcbiAgICAgICAgb3V0c2lkZTogJ3JpZ2h0JyxcbiAgICAgICAgaW5zaWRlOiAnbGVmdCcsXG4gICAgICAgIGxlYWRpbmc6ICd0b3AnLFxuICAgICAgICB0cmFpbGluZzogJ2JvdHRvbScsXG4gICAgICAgIG1hcmdpbkxlYWRpbmc6ICdtYXJnaW5Ub3AnLFxuICAgICAgICBtYXJnaW5UcmFpbGluZzogJ21hcmdpbkJvdHRvbScsXG4gICAgICAgIHRoaWNrbmVzczogJ3dpZHRoJyxcbiAgICAgICAgZGVsdGE6ICdkZWx0YVknLFxuICAgICAgICAvLyBncmlkT2Zmc2V0UHJvcGVydHk6ICdjYW52YXNXaWR0aE9mZnNldCcsXG4gICAgICAgIGNvbnRhaW5lclRvdWNoVmVsb2NpdHlNb2RpZmllcjogNC4yLFxuICAgICAgICBjb250YWluZXJUb3VjaFZlbG9jaXR5TWF4OiAyMDAwMCxcbiAgICAgICAgdG91Y2hUb1Njcm9sbFBpeGVsc0NvZWZmaWNpZW50OiAxXG4gICAgfSxcbiAgICBob3Jpem9udGFsOiB7XG4gICAgICAgIGNvb3JkaW5hdGU6ICdjbGllbnRYJyxcbiAgICAgICAgYXhpczogJ3BhZ2VYJyxcbiAgICAgICAgc2l6ZTogJ3dpZHRoJyxcbiAgICAgICAgb3V0c2lkZTogJ2JvdHRvbScsXG4gICAgICAgIGluc2lkZTogJ3RvcCcsXG4gICAgICAgIGxlYWRpbmc6ICdsZWZ0JyxcbiAgICAgICAgdHJhaWxpbmc6ICdyaWdodCcsXG4gICAgICAgIG1hcmdpbkxlYWRpbmc6ICdtYXJnaW5MZWZ0JyxcbiAgICAgICAgbWFyZ2luVHJhaWxpbmc6ICdtYXJnaW5SaWdodCcsXG4gICAgICAgIHRoaWNrbmVzczogJ2hlaWdodCcsXG4gICAgICAgIGRlbHRhOiAnZGVsdGFYJyxcbiAgICAgICAgLy8gZ3JpZE9mZnNldFByb3BlcnR5OiAnY2FudmFzSGVpZ2h0T2Zmc2V0J1xuICAgICAgICBjb250YWluZXJUb3VjaFZlbG9jaXR5TW9kaWZpZXI6IDIsXG4gICAgICAgIGNvbnRhaW5lclRvdWNoVmVsb2NpdHlNYXg6IDIwMDAwLFxuICAgICAgICB0b3VjaFRvU2Nyb2xsUGl4ZWxzQ29lZmZpY2llbnQ6IDIuNFxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuY29uc3QgZXF1YWwgPSByZXF1aXJlKCdkZWVwLWVxdWFsJyk7XG5cbi8vIGhlbHBlciBtZXRob2RzXG5cbmZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBzdG9wKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaWR4ID0gc3RhcnQuY2hhckNvZGVBdCgwKSwgZW5kID0gc3RvcC5jaGFyQ29kZUF0KDApOyBpZHggPD0gZW5kOyArK2lkeCkge1xuICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGlkeCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBheiA9IHJhbmdlKCdBJywgJ1onKTtcblxuZnVuY3Rpb24gaWRPZihpKSB7XG4gICAgcmV0dXJuIChpID49IDI2ID8gaWRPZihheiwgKGkgLyAyNiA+PiAwKSAtIDEpIDogJycpICsgYXpbaSAlIDI2ID4+IDBdO1xufVxuXG5mdW5jdGlvbiBnZXRGb3JtYXR0ZXIoY29sRGVmKSB7XG4gICAgY29uc3QgZm9ybWF0dGVyTWFwcGVyID0gKGYpID0+IHtcbiAgICAgICAgbGV0IGZvcm1hdHRlciA9IGY7XG4gICAgICAgIGlmIChmb3JtYXR0ZXIgJiYgdHlwZW9mIGZvcm1hdHRlciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9IGZvcm1hdHRlci5wcm90b3R5cGUudXBkYXRlID8gZm9ybWF0dGVyLnByb3RvdHlwZS51cGRhdGUgOiBmb3JtYXR0ZXI7XG4gICAgICAgICAgICBmb3JtYXR0ZXIgPSB2YWx1ZSA9PiB1cGRhdGUoeyBjb2xEZWYsIHZhbHVlLCBjb2x1bW46IGNvbERlZiB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyO1xuICAgIH07XG5cbiAgICBsZXQgZGF0YUZvcm1hdHRlciA9IGZvcm1hdHRlck1hcHBlcihjb2xEZWYgJiYgY29sRGVmLmNlbGxSZW5kZXJlcik7XG4gICAgbGV0IGhlYWRlckZvcm1hdHRlciA9IGZvcm1hdHRlck1hcHBlcihjb2xEZWYgJiYgY29sRGVmLmhlYWRlckNlbGxSZW5kZXJlcik7XG5cbiAgICBjb25zdCBjaGVja2VyID0gKGZ1bmMsIC4uLmFyZ3MpID0+IChmdW5jICYmIHR5cGVvZiBmdW5jID09PSAnZnVuY3Rpb24nKSA/IGZ1bmMoLi4uYXJncykgOiBhcmdzWzBdO1xuXG4gICAgcmV0dXJuICh2YWx1ZSwgaXNIZWFkZXIpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpc0hlYWRlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlzSGVhZGVyID0gaXNIZWFkZXIucm93UHJvcGVydGllcyA/IGlzSGVhZGVyLnJvd1Byb3BlcnRpZXMuaGVhZGVyUm93IDogaXNIZWFkZXIuaGVhZGVyUm93O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaXNIZWFkZXIgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgaXNIZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hlY2tlcihpc0hlYWRlciA/IGhlYWRlckZvcm1hdHRlciA6IGRhdGFGb3JtYXR0ZXIsIHZhbHVlKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0Q29sRGVmcyhjb2xEZWZzKSB7XG4gICAgY29uc3Qgc2NoZW1hID0gW107XG5cbiAgICBjb25zdCBoZWFkZXJzRm9udCA9IHRoaXMucHJvcGVydGllcy5jb2x1bW5IZWFkZXJGb250Qm9sZDtcbiAgICBjb25zdCBtYXhpbXVtQ29sdW1uV2lkdGggPSB0aGlzLnByb3BlcnRpZXMubWF4aW11bUNvbHVtbldpZHRoO1xuXG4gICAgY29uc3QgZ2V0Q29udGV4dE1lbnVJdGVtcyA9IHRoaXMuZ2V0Q29udGV4dE1lbnVJdGVtcztcblxuICAgIGNvbnN0IHNob3dBZGRpdGlvbmFsSW5mbyA9IHRoaXMucHJvcGVydGllcy5zaG93QWRkaXRpb25hbEluZm87XG5cbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIGNvbnN0IGRhdGEgPSBbXTtcblxuICAgIGNvbnN0IGF6ID0gcmFuZ2UoJ0EnLCAnWicpO1xuXG4gICAgbGV0IHNjaGVtYUNvbHVtbnNDb3VudCA9IDA7XG4gICAgbGV0IG1heFRyZWVMZXZlbCA9IDA7XG5cbiAgICBmdW5jdGlvbiBjb3VudE1heFRyZWVMZXZlbChwcmV2TGV2ZWwsIGNvbERlZnNUb0RldGVjdCwgaXNUb3BHcm91cENvbGxhcHNlZCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBjdXJyZW50TGV2ZWwgPSBwcmV2TGV2ZWwgKyAxO1xuICAgICAgICBsZXQgaGFzVmlzaWJsZUNvbHVtbnMgPSBmYWxzZTtcblxuICAgICAgICBjb2xEZWZzVG9EZXRlY3QuZm9yRWFjaCgoY2QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzQWx3YXlzRGlzcGxheWVkQ29sRGVmID0gY2QuY29sbGFwc2VkSGVhZGVyTmFtZSB8fCBjZC5pc1RvdGFsO1xuXG4gICAgICAgICAgICBjb25zdCBpc0NvbERlZlZpc2libGUgPSAhaXNUb3BHcm91cENvbGxhcHNlZCB8fCBpc0Fsd2F5c0Rpc3BsYXllZENvbERlZjtcbiAgICAgICAgICAgIGlmIChpc0NvbERlZlZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBoYXNWaXNpYmxlQ29sdW1ucyA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JvdXBDb2xsYXBzZWQgPSBjZC5jb2x1bW5Hcm91cFNob3cgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAmJiBjZC5jb2x1bW5Hcm91cFNob3cgIT09ICdvcGVuJ1xuICAgICAgICAgICAgICAgICAgICAmJiBjZC5jb2x1bW5Hcm91cFNob3cgIT09ICdhbHdheXMtc2hvd2luZyc7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2QuY2hpbGRyZW4gJiYgY2QuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudE1heFRyZWVMZXZlbChjdXJyZW50TGV2ZWwsIGNkLmNoaWxkcmVuLCBncm91cENvbGxhcHNlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY3VycmVudExldmVsID4gbWF4VHJlZUxldmVsICYmIGhhc1Zpc2libGVDb2x1bW5zKSB7XG4gICAgICAgICAgICBtYXhUcmVlTGV2ZWwgPSBjdXJyZW50TGV2ZWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFbXB0eUhlYWRlclJvdygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9fTUVUQToge1xuICAgICAgICAgICAgICAgIF9fUk9XOiB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlclJvdzogdHJ1ZSwgLy8gdXNlZCBmb3IgcHJldmVudGluZyBkdXBsaWNhdGVzXG4gICAgICAgICAgICAgICAgICAgIGZvbnQ6IGhlYWRlcnNGb250LCAvLyBzZXQgYm9sZCBmb250IGZvciB0aXRsZSByb3dcbiAgICAgICAgICAgICAgICAgICAgZm9yZWdyb3VuZFNlbGVjdGlvbkZvbnQ6IGhlYWRlcnNGb250LCAvLyBzZXQgYm9sZCBmb250IGZvciB0aXRsZSByb3dcbiAgICAgICAgICAgICAgICAgICAgZWRpdGFibGU6IHRydWUsIC8vIGFsbG93IGVkaXQgY29udGVudFxuICAgICAgICAgICAgICAgICAgICBjZWxsQ29udGV4dE1lbnU6IHNlbGYuZ2V0TWFpbk1lbnVJdGVtcyA/IHNlbGYuZ2V0TWFpbk1lbnVJdGVtcyA6IHNlbGYucHJvcGVydGllcy5oZWFkZXJDb250ZXh0TWVudSwgLy8gc2V0IGNvbnRleHQgbWVudSBpdGVtcyB3aXRoIGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgICAgICBoYWxpZ246ICdsZWZ0JyxcbiAgICAgICAgICAgICAgICAgICAgc2hvd0NlbGxDb250ZXh0TWVudUljb246IHNob3dBZGRpdGlvbmFsSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgc2hvd0NvbHVtblR5cGU6IHNob3dBZGRpdGlvbmFsSW5mb1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb3VudE1heFRyZWVMZXZlbCgwLCBjb2xEZWZzKTtcblxuICAgIGZ1bmN0aW9uIGNvbERlZk1hcHBlcihzaW5nbGVDb2xEZWYsIGhlYWRlckxldmVsID0gMCwgdG9wR3JvdXBDb2xsYXBzZWQgPSBmYWxzZSwgdG9wR3JvdXBzSWRzID0gW10pIHtcbiAgICAgICAgY29uc3QgbGV0dGVyID0gaWRPZihzY2hlbWFDb2x1bW5zQ291bnQpO1xuXG4gICAgICAgIGNvbnN0IHNjaGVtYU1hcHBlciA9IChoZWFkZXIsIG5hbWUpID0+ICh7XG4gICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdG9wR3JvdXBzSWRzLFxuICAgICAgICAgICAgd2lkdGg6IHNpbmdsZUNvbERlZi53aWR0aCxcbiAgICAgICAgICAgIGhhbGlnbjogc2luZ2xlQ29sRGVmLmhhbGlnbixcbiAgICAgICAgICAgIGNvbFR5cGVTaWduOiBzaW5nbGVDb2xEZWYuY29sVHlwZVNpZ24sXG4gICAgICAgICAgICBmb3JtYXR0ZXI6IGdldEZvcm1hdHRlcihzaW5nbGVDb2xEZWYpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZvcm1hdDogbmFtZSxcbiAgICAgICAgICAgIGhlYWRlclByZWZpeDogc2luZ2xlQ29sRGVmLmhlYWRlclByZWZpeCxcbiAgICAgICAgICAgIGNlbGxDb250ZXh0TWVudTogZ2V0Q29udGV4dE1lbnVJdGVtcyxcbiAgICAgICAgICAgIGNvbERlZjogc2luZ2xlQ29sRGVmXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzaW5nbGVDb2xEZWYpIHtcbiAgICAgICAgICAgIGlmICh0b3BHcm91cENvbGxhcHNlZCAmJiAhc2luZ2xlQ29sRGVmLmNvbGxhcHNlZEhlYWRlck5hbWUgJiYgIXNpbmdsZUNvbERlZi5pc1RvdGFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISFzaW5nbGVDb2xEZWYuY2hpbGRyZW4gJiYgc2luZ2xlQ29sRGVmLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zZXJ0ZWRDb2x1bW5OYW1lcyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VwQ29sbGFwc2VkID0gc2luZ2xlQ29sRGVmLmNvbHVtbkdyb3VwU2hvd1xuICAgICAgICAgICAgICAgICAgICAmJiBzaW5nbGVDb2xEZWYuY29sdW1uR3JvdXBTaG93ICE9PSAnb3BlbidcbiAgICAgICAgICAgICAgICAgICAgJiYgc2luZ2xlQ29sRGVmLmNvbHVtbkdyb3VwU2hvdyAhPT0gJ2Fsd2F5cy1zaG93aW5nJztcbiAgICAgICAgICAgICAgICBzaW5nbGVDb2xEZWYuY2hpbGRyZW4uZm9yRWFjaCgoY2gpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VG9wR3JvdXBzQXJyYXkgPSBbLi4udG9wR3JvdXBzSWRzLCBzaW5nbGVDb2xEZWYuZ3JvdXBJZF07XG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkQ29sdW1uTmFtZXMgPSBbLi4uaW5zZXJ0ZWRDb2x1bW5OYW1lcywgLi4uY29sRGVmTWFwcGVyKGNoLCBoZWFkZXJMZXZlbCArIDEsIGdyb3VwQ29sbGFwc2VkLCBuZXdUb3BHcm91cHNBcnJheSldO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluc2VydGVkQ29sdW1uTmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsRmllbGQgPSBzaW5nbGVDb2xEZWYuY29sdW1uTmFtZSArICdfJCRjbHVzdGVyX3NpemUnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gb3JpZ2luYWxGaWVsZCB8fCBsZXR0ZXI7XG5cbiAgICAgICAgICAgICAgICAgICAgdG9wR3JvdXBzSWRzID0gWy4uLnRvcEdyb3Vwc0lkcywgc2luZ2xlQ29sRGVmLmdyb3VwSWRdO1xuICAgICAgICAgICAgICAgICAgICBzY2hlbWEucHVzaChzY2hlbWFNYXBwZXIobGV0dGVyIHx8ICcnLCBuYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYUNvbHVtbnNDb3VudCsrO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGFbaGVhZGVyTGV2ZWxdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtoZWFkZXJMZXZlbF0gPSBnZXRFbXB0eUhlYWRlclJvdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJvd3NwYW4gPSBtYXhUcmVlTGV2ZWwgLSBoZWFkZXJMZXZlbCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29sdW1uTmFtZSA9ICh0b3BHcm91cENvbGxhcHNlZCAmJiBzaW5nbGVDb2xEZWYuY29sbGFwc2VkSGVhZGVyTmFtZSAmJiBzaW5nbGVDb2xEZWYuY29sbGFwc2VkSGVhZGVyTmFtZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzaW5nbGVDb2xEZWYuY29sbGFwc2VkSGVhZGVyTmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc2luZ2xlQ29sRGVmLmhlYWRlck5hbWUgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2hlYWRlckxldmVsXVtvcmlnaW5hbEZpZWxkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dzcGFuOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb2x1bW5OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiBzaW5nbGVDb2xEZWYuY291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRDb2x1bW5EZWZzOiBzaW5nbGVDb2xEZWYuY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZDogc2luZ2xlQ29sRGVmLmdyb3VwSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uT3BlbkJ5RGVmYXVsdDogc2luZ2xlQ29sRGVmLm9wZW5CeURlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uR3JvdXBTaG93OiBzaW5nbGVDb2xEZWYuY29sdW1uR3JvdXBTaG93XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93c3BhbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dzcGFuLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtoZWFkZXJMZXZlbCArIDFdW29yaWdpbmFsRmllbGRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dzcGFuOiByb3dzcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ0NvdW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IHNpbmdsZUNvbERlZi5jb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3dzcGFuID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBoZWFkZXJMZXZlbCArIDI7IGkgPCBtYXhUcmVlTGV2ZWw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGFbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaV0gPSBnZXRFbXB0eUhlYWRlclJvdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaV1bb3JpZ2luYWxGaWVsZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dzcGFuOiByb3dzcGFuIC0gaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUm93c3BhbmVkQnlSb3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dzcGFuZWRCeVJvdzogaGVhZGVyTGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudDogc2luZ2xlQ29sRGVmLmNvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtuYW1lXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGFbaGVhZGVyTGV2ZWxdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2hlYWRlckxldmVsXSA9IGdldEVtcHR5SGVhZGVyUm93KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xzcGFuID0gaW5zZXJ0ZWRDb2x1bW5OYW1lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2x1bW5OYW1lID0gKHRvcEdyb3VwQ29sbGFwc2VkICYmIHNpbmdsZUNvbERlZi5jb2xsYXBzZWRIZWFkZXJOYW1lICYmIHNpbmdsZUNvbERlZi5jb2xsYXBzZWRIZWFkZXJOYW1lLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2luZ2xlQ29sRGVmLmNvbGxhcHNlZEhlYWRlck5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2luZ2xlQ29sRGVmLmhlYWRlck5hbWUgfHwgJyc7XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YVtoZWFkZXJMZXZlbF1baW5zZXJ0ZWRDb2x1bW5OYW1lc1swXV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xzcGFuOiBjb2xzcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbHVtbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlVmFsdWVQcmVmaXg6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IHNpbmdsZUNvbERlZi5jb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkQ29sdW1uRGVmczogc2luZ2xlQ29sRGVmLmNoaWxkcmVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZDogc2luZ2xlQ29sRGVmLmdyb3VwSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5PcGVuQnlEZWZhdWx0OiBzaW5nbGVDb2xEZWYub3BlbkJ5RGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbkdyb3VwU2hvdzogc2luZ2xlQ29sRGVmLmNvbHVtbkdyb3VwU2hvd1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaW5zZXJ0ZWRDb2x1bW5OYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtoZWFkZXJMZXZlbF1baW5zZXJ0ZWRDb2x1bW5OYW1lc1tpXV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sc3BhbjogY29sc3BhbiAtIGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb2xzcGFuZWRCeUNvbHVtbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xzcGFuZWRCeUNvbHVtbjogaW5zZXJ0ZWRDb2x1bW5OYW1lc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudDogc2luZ2xlQ29sRGVmLmNvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkQ29sdW1uRGVmczogc2luZ2xlQ29sRGVmLmNoaWxkcmVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSWQ6IHNpbmdsZUNvbERlZi5ncm91cElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbk9wZW5CeURlZmF1bHQ6IHNpbmdsZUNvbERlZi5vcGVuQnlEZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbkdyb3VwU2hvdzogc2luZ2xlQ29sRGVmLmNvbHVtbkdyb3VwU2hvd1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnNlcnRlZENvbHVtbk5hbWVzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbEZpZWxkID0gc2luZ2xlQ29sRGVmLmZpZWxkO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBvcmlnaW5hbEZpZWxkIHx8IGxldHRlcjtcblxuICAgICAgICAgICAgICAgIHNjaGVtYS5wdXNoKHNjaGVtYU1hcHBlcihsZXR0ZXIgfHwgJycsIG5hbWUpKTtcbiAgICAgICAgICAgICAgICBzY2hlbWFDb2x1bW5zQ291bnQrKztcblxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YVtoZWFkZXJMZXZlbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaGVhZGVyTGV2ZWxdID0gZ2V0RW1wdHlIZWFkZXJSb3coKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3dzcGFuID0gbWF4VHJlZUxldmVsIC0gaGVhZGVyTGV2ZWwgLSAxO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29sdW1uTmFtZSA9ICh0b3BHcm91cENvbGxhcHNlZCAmJiBzaW5nbGVDb2xEZWYuY29sbGFwc2VkSGVhZGVyTmFtZSAmJiBzaW5nbGVDb2xEZWYuY29sbGFwc2VkSGVhZGVyTmFtZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNpbmdsZUNvbERlZi5jb2xsYXBzZWRIZWFkZXJOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNpbmdsZUNvbERlZi5oZWFkZXJOYW1lIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2hlYWRlckxldmVsXVtvcmlnaW5hbEZpZWxkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd3NwYW46IHJvd3NwYW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29sdW1uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiBzaW5nbGVDb2xEZWYuY291bnRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGhlYWRlckxldmVsICsgMSwgaXQgPSAxOyBpIDwgbWF4VHJlZUxldmVsOyBpKyssIGl0KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGF0YVtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaV0gPSBnZXRFbXB0eUhlYWRlclJvdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpXVtvcmlnaW5hbEZpZWxkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dzcGFuOiByb3dzcGFuIC0gaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1Jvd3NwYW5lZEJ5Um93OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd3NwYW5lZEJ5Um93OiBoZWFkZXJMZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudDogc2luZ2xlQ29sRGVmLmNvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2hlbWEucHVzaCh7XG4gICAgICAgICAgICAgICAgaGVhZGVyOiBsZXR0ZXIgfHwgJycsXG4gICAgICAgICAgICAgICAgbmFtZTogbGV0dGVyLFxuICAgICAgICAgICAgICAgIG1heFdpZHRoOiBtYXhpbXVtQ29sdW1uV2lkdGgsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBuYW1lLFxuICAgICAgICAgICAgICAgIGNlbGxDb250ZXh0TWVudTogZ2V0Q29udGV4dE1lbnVJdGVtc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzY2hlbWFDb2x1bW5zQ291bnQrKztcbiAgICAgICAgICAgIHJldHVybiBbbGV0dGVyXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb2xEZWZzLmZvckVhY2goc2luZ2xlQ29sRGVmID0+IGNvbERlZk1hcHBlcihzaW5nbGVDb2xEZWYpKTtcblxuICAgIGlmIChzY2hlbWFDb2x1bW5zQ291bnQgPCBhei5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHNjaGVtYUNvbHVtbnNDb3VudDsgaSA8IGF6Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb2xEZWZNYXBwZXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IHNjaGVtYTogc2NoZW1hLCBkYXRhOiBkYXRhLCBmaWN0aXZlSGVhZGVyUm93c0NvdW50OiBtYXhUcmVlTGV2ZWwgfTtcbn1cblxuLy8gZnVuY3Rpb24gZ2V0T3BlbkxpbmtGdW5jKGxpbmspIHtcbi8vICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4vLyAgICAgICAgIHdpbmRvdy5vcGVuKGxpbmssICdfYmxhbmsnKTtcbi8vICAgICB9O1xuLy8gfVxuXG4vLyBhcGkgbWV0aG9kc1xuXG5jb25zdCByb3dNb2RlbCA9IHtcbiAgICB2aXJ0dWFsUGFnZUNhY2hlOiB7XG4gICAgICAgIHVwZGF0ZUhlaWdodEZvckFsbFJvd3M6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNldEV4cGFuZGVkOiBmdW5jdGlvbihpZCwgZXhwYW5kZWQpIHtcblxuICAgIH1cbn07XG5cbmNvbnN0IHJhbmdlQ29udHJvbGxlciA9IHtcbiAgICBhbGxSb3dzU2VsZWN0ZWQ6IGZhbHNlLFxuICAgIHNlbGVjdGVkQ29sczogW10sXG4gICAgcmVmcmVzaEJvcmRlcnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgfSxcbiAgICBzZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuXG4gICAgfVxufTtcblxuY29uc3QgZ3JpZFBhbmVsID0ge1xuICAgIHJlc2V0VmVydGljYWxTY3JvbGxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubG9nKCdyZXNldFZlcnRpY2FsU2Nyb2xsUG9zaXRpb24nKTtcbiAgICAgICAgdGhpcy52U2Nyb2xsVmFsdWUgPSAwO1xuICAgIH0sXG4gICAgc2V0VmVydGljYWxTY3JvbGxQb3NpdGlvbjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5sb2coJ3NldFZlcnRpY2FsU2Nyb2xsUG9zaXRpb24nKTtcbiAgICAgICAgdGhpcy52U2Nyb2xsVmFsdWUgPSB2YWx1ZTtcbiAgICB9LFxuICAgIGdldFZlcnRpY2FsU2Nyb2xsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmxvZygnZ2V0VmVydGljYWxTY3JvbGxQb3NpdGlvbicpO1xuICAgICAgICByZXR1cm4gdGhpcy52U2Nyb2xsVmFsdWU7XG4gICAgfSxcbiAgICByZXNldEhvcml6b250YWxTY3JvbGxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubG9nKCdyZXNldEhvcml6b250YWxTY3JvbGxQb3NpdGlvbicpO1xuICAgICAgICB0aGlzLmhTY3JvbGxWYWx1ZSA9IDA7XG4gICAgfSxcbiAgICBzZXRIb3Jpem9udGFsU2Nyb2xsUG9zaXRpb246IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubG9nKCdzZXRIb3Jpem9udGFsU2Nyb2xsUG9zaXRpb24nKTtcbiAgICAgICAgdGhpcy5oU2Nyb2xsVmFsdWUgPSB2YWx1ZTtcbiAgICB9LFxuICAgIGdldEhvcml6b250YWxTY3JvbGxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubG9nKCdnZXRIb3Jpem9udGFsU2Nyb2xsUG9zaXRpb24nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaFNjcm9sbFZhbHVlO1xuICAgIH1cbn07XG5cbmNvbnN0IGNvbHVtbkNvbnRyb2xsZXIgPSB7XG4gICAgZ2V0QWxsR3JpZENvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmxvZygnZ2V0QWxsR3JpZENvbHVtbnMnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWN0aXZlQ29sdW1ucygpO1xuICAgIH0sXG4gICAgdXBkYXRlRGlzcGxheWVkQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubG9nKCd1cGRhdGVEaXNwbGF5ZWRDb2x1bW5zJyk7XG4gICAgfVxufTtcblxuY29uc3QgZmxvYXRpbmdSb3dNb2RlbCA9IHtcbiAgICBmbG9hdGluZ1RvcFJvd3M6IFtdLFxuICAgIGZsYXR0ZW5TdGFnZToge1xuICAgICAgICBleGVjdXRlOiBmdW5jdGlvbihyb290Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5sb2cocm9vdE5vZGUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzZXRFeHBhbmRlZDogZnVuY3Rpb24oaWQsIGV4cGFuZGVkKSB7XG4gICAgICAgIHRoaXMubG9nKGlkLCBleHBhbmRlZCk7XG4gICAgfVxufTtcblxuY29uc3QgdmlydHVhbFBhZ2VSb3dNb2RlbCA9IHtcbiAgICB2aXJ0dWFsUGFnZUNhY2hlOiB7XG4gICAgICAgIHVwZGF0ZUFsbFJvd1RvcEZyb21JbmRleGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCd1cGRhdGVBbGxSb3dUb3BGcm9tSW5kZXhlcycpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHJvd0luZGV4LCBkb250Q3JlYXRlUGFnZSkge1xuICAgICAgICB0aGlzLmxvZygnZ2V0Um93Jywgcm93SW5kZXgsIGRvbnRDcmVhdGVQYWdlKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBnZXRWaXNpYmxlQ29sRGVmcyhjb2xEZWZzKSB7XG4gICAgY29uc3QgcmVzID0gY29sRGVmcy5maWx0ZXIoKGNkKSA9PiAhY2QuaXNIaWRkZW4pO1xuXG4gICAgcmVzLmZpbHRlcihjZCA9PiBjZC5jaGlsZHJlbikuZm9yRWFjaChjZCA9PiB7XG4gICAgICAgIGNkLmNoaWxkcmVuID0gZ2V0VmlzaWJsZUNvbERlZnMoY2QuY2hpbGRyZW4pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gc2V0Q29sdW1uRGVmcyhjb2xEZWZzKSB7XG4gICAgdGhpcy5sb2coJ3NldENvbHVtbkRlZnMnLCBjb2xEZWZzKTtcblxuICAgIHRoaXMuY29sdW1uRGVmcyA9IGNvbERlZnM7XG4gICAgdGhpcy52aXNpYmxlQ29sdW1uRGVmcyA9IGdldFZpc2libGVDb2xEZWZzKHRoaXMuY29sdW1uRGVmcyk7XG5cbiAgICBjb25zdCBzY2hlbWEgPSBjb252ZXJ0Q29sRGVmcy5jYWxsKHRoaXMsIHRoaXMudmlzaWJsZUNvbHVtbkRlZnMpO1xuICAgIHRoaXMubG9nKCdzY2hlbWEnLCBzY2hlbWEpO1xuICAgIGNvbnN0IGZpcnN0Um93c0RhdGEgPSBzY2hlbWEuZGF0YTtcbiAgICBsZXQgZGF0YSA9IHRoaXMuYmVoYXZpb3IuZ2V0RGF0YSgpO1xuXG4gICAgaWYgKHRoaXMuZ2V0TWFpbk1lbnVJdGVtcykge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmdyaWQucHJvcGVydGllcy5oZWFkZXJDb250ZXh0TWVudSA9IHRoaXMuZ2V0TWFpbk1lbnVJdGVtcztcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgZmlyc3Qgcm93IGZyb20gaGVhZGVyc1xuICAgIGlmICh0aGlzLmJlaGF2aW9yLmdyaWQucHJvcGVydGllcy51c2VIZWFkZXJzKSB7XG4gICAgICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGF0YSA9IFsuLi5maXJzdFJvd3NEYXRhXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEuZmljdGl2ZUhlYWRlclJvd3NDb3VudCA8IHRoaXMuYmVoYXZpb3IuZ3JpZC5wcm9wZXJ0aWVzLmZpY3RpdmVIZWFkZXJSb3dzQ291bnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmID0gdGhpcy5iZWhhdmlvci5ncmlkLnByb3BlcnRpZXMuZmljdGl2ZUhlYWRlclJvd3NDb3VudCAtIHNjaGVtYS5maWN0aXZlSGVhZGVyUm93c0NvdW50O1xuICAgICAgICAgICAgICAgIGRhdGEuc3BsaWNlKHNjaGVtYS5maWN0aXZlSGVhZGVyUm93c0NvdW50IC0gMSwgZGlmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yLmdyaWQucHJvcGVydGllcy5maWN0aXZlSGVhZGVyUm93c0NvdW50ID0gc2NoZW1hLmZpY3RpdmVIZWFkZXJSb3dzQ291bnQ7XG4gICAgICAgICAgICBmaXJzdFJvd3NEYXRhLmZvckVhY2goKGQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWVxdWFsKGRhdGFbMF0sIGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJlaGF2aW9yLmdldFJvd1Byb3BlcnRpZXMoaSkuaGVhZGVyUm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2ldID0gZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc3BsaWNlKGksIDAsIGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcGkubmVlZENvbHVtbnNUb0ZpdCA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5sb2coJ3NjaGVtYS5zY2hlbWEnLCBzY2hlbWEuc2NoZW1hKTtcblxuICAgIHRoaXMuYmVoYXZpb3Iuc2V0RGF0YSh7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hLnNjaGVtYVxuICAgIH0pO1xuICAgIHRoaXMuYWxsb3dFdmVudHModHJ1ZSk7XG4gICAgdGhpcy5iZWhhdmlvci5kYXRhTW9kZWwuc2V0U2NoZW1hKHNjaGVtYS5zY2hlbWEpO1xuICAgIHRoaXMuY2xlYXJTZWxlY3Rpb25zKCk7XG59XG5cbmZ1bmN0aW9uIHNldFJvd0RhdGEocm93RGF0YSkge1xuICAgIHRoaXMubG9nKCdzZXRSb3dEYXRhJywgcm93RGF0YSk7XG5cbiAgICAvLyB0b2RvIHJlbW92ZSB0aGlzIGluIGZ1dHVyZVxuICAgIGlmIChyb3dEYXRhLmxlbmd0aCA9PT0gMTAwMCAmJiB0aGlzLmJlaGF2aW9yLmdyaWQucHJvcGVydGllcy51c2VIZWFkZXJzKSB7XG4gICAgICAgIHJvd0RhdGEucG9wKCk7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhID0gcm93RGF0YTtcblxuICAgIHRoaXMuc2V0RGF0YSh7IGRhdGE6IHJvd0RhdGEgfSk7XG4gICAgdGhpcy5iZWhhdmlvci5idWlsZEZsYXRNb2RlKCk7XG5cbiAgICBpZiAodGhpcy5jb2x1bW5EZWZzKSB7XG4gICAgICAgIHRoaXMuYXBpLnNldENvbHVtbkRlZnModGhpcy5jb2x1bW5EZWZzKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNpemVDb2x1bW5zVG9GaXQoKSB7XG4gICAgdGhpcy5sb2coJ3NpemVDb2x1bW5zVG9GaXQnKTtcblxuICAgIGlmICh0aGlzLmFwaS5uZWVkQ29sdW1uc1RvRml0KSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IuZml0Q29sdW1ucygpO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZXNpemUoZmFsc2UpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Zpbi1ncmlkLXJlbmRlcmVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcGkubmVlZENvbHVtbnNUb0ZpdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnJlc2l6ZU5vdGlmaWNhdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBpLm5lZWRDb2x1bW5zVG9GaXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3kodG90YWwpIHtcbiAgICB0aGlzLmxvZygnZGVzdHJveScsIHRvdGFsKTtcblxuICAgIHRoaXMuc2V0SGlnaGxpZ2h0VGV4dCgnJyk7XG5cbiAgICB0aGlzLmNhbmNlbEVkaXRpbmcoKTtcblxuICAgIHRoaXMuc2JQcmV2VlNjcm9sbFZhbHVlID0gbnVsbDtcbiAgICB0aGlzLnNiUHJldkhTY3JvbGxWYWx1ZSA9IG51bGw7XG4gICAgdGhpcy5ob3ZlckNlbGwgPSBudWxsO1xuICAgIHRoaXMuc2Nyb2xsaW5nTm93ID0gZmFsc2U7XG5cbiAgICB0aGlzLmJlaGF2aW9yLnJlc2V0KCk7XG4gICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5yZXNldCgpO1xuICAgIHRoaXMucmVuZGVyZXIucmVzZXQoKTtcblxuICAgIHRoaXMuYXBpLnJhbmdlQ29udHJvbGxlci5zZWxlY3RlZENvbHMgPSBbXTtcblxuICAgIGlmICh0b3RhbCB8fCAhdGhpcy5pc0FsaXZlKCkpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95U2Nyb2xsYmFycygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlc2l6ZSgpO1xuICAgICAgICB0aGlzLmJlaGF2aW9yQ2hhbmdlZCgpO1xuICAgICAgICB0aGlzLnJlZnJlc2hQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplKHRoaXMuZGl2KTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmJlaGF2aW9yLmdyaWQuZmlyZVN5bnRoZXRpY0FwaURlc3Ryb3lDYWxsZWQodG90YWwpO1xufVxuXG5mdW5jdGlvbiBnZXRSYW5nZVNlbGVjdGlvbnMoKSB7XG4gICAgdGhpcy5sb2coJ2dldFJhbmdlU2VsZWN0aW9ucycpO1xuICAgIHJldHVybiB0aGlzLmdldFNlbGVjdGlvbnMoKTtcbn1cblxuZnVuY3Rpb24gY29weVNlbGVjdGVkUmFuZ2VUb0NsaXBib2FyZChpbmNsdWRlSGVhZGVycykge1xuICAgIHRoaXMubG9nKCdjb3B5U2VsZWN0ZWRSYW5nZVRvQ2xpcGJvYXJkJywgaW5jbHVkZUhlYWRlcnMpO1xuICAgIHRoaXMuY29weUluY2x1ZGVIZWFkZXJzID0gaW5jbHVkZUhlYWRlcnM7XG4gICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2NvcHknKTtcbiAgICBkZWxldGUgdGhpcy5jb3B5SW5jbHVkZUhlYWRlcnM7XG59XG5cbmZ1bmN0aW9uIGdldFNlbGVjdGVkQ29sdW1ucygpIHtcbiAgICB0aGlzLmxvZygnZ2V0U2VsZWN0ZWRDb2x1bW5zJyk7XG4gICAgcmV0dXJuIHRoaXMuYXBpLnJhbmdlQ29udHJvbGxlci5zZWxlY3RlZENvbHM7XG59XG5cbmZ1bmN0aW9uIGdldE1vZGVsKCkge1xuICAgIHRoaXMubG9nKCdnZXRNb2RlbCcpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvd3NUb0Rpc3BsYXk6IFtdLFxuICAgICAgICBnZXRSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5sb2coJ2dldFJvdycpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYXBwbHlQcm9wZXJ0aWVzKG5ld1Byb3BzKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLnByb3BlcnRpZXMsIG5ld1Byb3BzKTtcbiAgICB0aGlzLnJlcGFpbnQoKTtcbn1cblxuZnVuY3Rpb24gcmVmcmVzaFZpZXcoKSB7XG4gICAgdGhpcy5sb2coJ3JlZnJlc2hWaWV3Jyk7XG4gICAgdGhpcy5yZXBhaW50KCk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUl0ZW1zKHJvd05vZGVzKSB7XG4gICAgdGhpcy5sb2coJ3JlbW92ZUl0ZW1zJywgcm93Tm9kZXMpO1xuXG59XG5cbmZ1bmN0aW9uIGluc2VydEl0ZW1zQXRJbmRleChpbmRleCwgaXRlbXMpIHtcbiAgICB0aGlzLmxvZygnaW5zZXJ0SXRlbXNBdEluZGV4JywgaW5kZXgsIGl0ZW1zKTtcbn1cblxuZnVuY3Rpb24gY2xlYXJSYW5nZVNlbGVjdGlvbigpIHtcbiAgICB0aGlzLmxvZygnY2xlYXJSYW5nZVNlbGVjdGlvbicpO1xuICAgIHRoaXMuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgdGhpcy5yZXBhaW50KCk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyRm9jdXNlZENlbGwoKSB7XG4gICAgdGhpcy5sb2coJ2NsZWFyRm9jdXNlZENlbGwnKTtcbiAgICB0aGlzLmNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbigpO1xuICAgIHRoaXMucmVwYWludCgpO1xufVxuXG5mdW5jdGlvbiBnZXRGbG9hdGluZ1RvcFJvd0RhdGEoKSB7XG4gICAgdGhpcy5sb2coJ2dldEZsb2F0aW5nVG9wUm93RGF0YScpO1xufVxuXG5mdW5jdGlvbiBnZXRGbG9hdGluZ1RvcFJvd0NvdW50KCkge1xuICAgIHRoaXMubG9nKCdnZXRGbG9hdGluZ1RvcFJvd0NvdW50Jyk7XG59XG5cbmZ1bmN0aW9uIHNob3dOb1Jvd3NPdmVybGF5KCkge1xuICAgIHRoaXMubG9nKCdzaG93Tm9Sb3dzT3ZlcmxheScpO1xufVxuXG5mdW5jdGlvbiBoaWRlT3ZlcmxheSgpIHtcbiAgICB0aGlzLmxvZygnaGlkZU92ZXJsYXknKTtcbn1cblxuZnVuY3Rpb24gcmVmcmVzaENlbGxzKHJvd05vZGVzLCBjb2xJZHMsIGFuaW1hdGUpIHtcbiAgICB0aGlzLmxvZygncmVmcmVzaENlbGxzJywgcm93Tm9kZXMsIGNvbElkcywgYW5pbWF0ZSk7XG59XG5cbmZ1bmN0aW9uIHNldERhdGFzb3VyY2UoZGF0YXNvdXJjZSkge1xuICAgIHRoaXMubG9nKCdzZXREYXRhc291cmNlJywgZGF0YXNvdXJjZSk7XG4gICAgdGhpcy5hcGkuZGF0YXNvdXJjZSA9IGRhdGFzb3VyY2U7XG5cbiAgICB0aGlzLnNldEhpZ2hsaWdodFRleHQoZGF0YXNvdXJjZS5zZWFyY2ggfHwgJycpO1xuXG4gICAgY29uc3Qgc3RhcnRSb3cgPSB0aGlzLmRhdGEubGVuZ3RoIHx8IDA7XG5cbiAgICBpZiAoc3RhcnRSb3cgPCBkYXRhc291cmNlLnRvdGFsU2l6ZSB8fCBzdGFydFJvdyA9PT0gMCkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICBzdGFydFJvdzogc3RhcnRSb3csIC8vIHJlcGxhY2Ugd2l0aCBjb3JyZWN0IGdldHRlclxuICAgICAgICAgICAgZW5kUm93OiBzdGFydFJvdyArIHRoaXMucGFnaW5hdGlvblBhZ2VTaXplLCAvLyByZXBsYWNlIHdpdGggY29ycmVjdCBnZXR0ZXJcbiAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjazogKHJvd3MsIGxhc3RSb3dJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKCdzdWNjZXNzQ2FsbGJhY2snLCByb3dzLCBsYXN0Um93SW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgLy8gdG9kbyByZW1vdmUgdGhpcyBpbiBmdXR1cmVcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRSb3cgPT09IDAgJiYgcm93cy5sZW5ndGggPT09IDEwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgcm93cy5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBbXS5wdXNoLmFwcGx5KHRoaXMuZGF0YSwgcm93cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGREYXRhKHsgZGF0YTogcm93cyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmJlaGF2aW9yLmJ1aWxkRmxhdE1vZGUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmYWlsQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKCdmYWlsQ2FsbGJhY2snKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZERhdGEoeyBkYXRhOiBbXSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb3J0TW9kZWw6IGRhdGFzb3VyY2Uuc29ydE1vZGVsLFxuICAgICAgICAgICAgZmlsdGVyTW9kZWw6IHt9LFxuICAgICAgICAgICAgY29udGV4dDogdW5kZWZpbmVkXG4gICAgICAgIH07XG5cbiAgICAgICAgZGF0YXNvdXJjZS5nZXRSb3dzKHBhcmFtcyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBvbkdyb3VwRXhwYW5kZWRPckNvbGxhcHNlZChyZWZyZXNoRnJvbUluZGV4KSB7XG4gICAgdGhpcy5sb2coJ29uR3JvdXBFeHBhbmRlZE9yQ29sbGFwc2VkJywgcmVmcmVzaEZyb21JbmRleCk7XG59XG5cbmZ1bmN0aW9uIGdldFNvcnRNb2RlbCgpIHtcbiAgICB0aGlzLmxvZygnZ2V0U29ydE1vZGVsJyk7XG4gICAgcmV0dXJuIFtdO1xufVxuXG5mdW5jdGlvbiBkb0xheW91dCgpIHtcbiAgICAvLyB0aGlzLmxvZygnZG9MYXlvdXQnKTtcbn1cblxuZnVuY3Rpb24gcmVmcmVzaEluTWVtb3J5Um93TW9kZWwoKSB7XG4gICAgdGhpcy5sb2coJ3JlZnJlc2hJbk1lbW9yeVJvd01vZGVsJyk7XG59XG5cbmZ1bmN0aW9uIGF0dGFjaExpbmtUb0RhdGFDZWxsKHgsIHksIGxpbmspIHtcbiAgICB0aGlzLmJlaGF2aW9yLnNldENlbGxQcm9wZXJ0eSh4LCB5LCAnbGluaycsIGxpbmspO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckNlbGxFZGl0ZWRFdmVudExpc3RlbmVyKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5hZGRJbnRlcm5hbEV2ZW50TGlzdGVuZXIoJ2Zpbi1hZnRlci1jZWxsLWVkaXQnLCBjYWxsYmFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8vIGZpZWxkc1xuICAgIHJvd01vZGVsOiByb3dNb2RlbCxcbiAgICByYW5nZUNvbnRyb2xsZXI6IHJhbmdlQ29udHJvbGxlcixcbiAgICBncmlkUGFuZWw6IGdyaWRQYW5lbCxcbiAgICBjb2x1bW5Db250cm9sbGVyOiBjb2x1bW5Db250cm9sbGVyLFxuICAgIGZsb2F0aW5nUm93TW9kZWw6IGZsb2F0aW5nUm93TW9kZWwsXG4gICAgdmlydHVhbFBhZ2VSb3dNb2RlbDogdmlydHVhbFBhZ2VSb3dNb2RlbCxcblxuICAgIC8vIGZ1bmN0aW9uc1xuICAgIHNldENvbHVtbkRlZnM6IHNldENvbHVtbkRlZnMsXG4gICAgc2V0Um93RGF0YTogc2V0Um93RGF0YSxcbiAgICBzaXplQ29sdW1uc1RvRml0OiBzaXplQ29sdW1uc1RvRml0LFxuICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgZ2V0UmFuZ2VTZWxlY3Rpb25zOiBnZXRSYW5nZVNlbGVjdGlvbnMsXG4gICAgY29weVNlbGVjdGVkUmFuZ2VUb0NsaXBib2FyZDogY29weVNlbGVjdGVkUmFuZ2VUb0NsaXBib2FyZCxcbiAgICBnZXRTZWxlY3RlZENvbHVtbnM6IGdldFNlbGVjdGVkQ29sdW1ucyxcbiAgICBnZXRNb2RlbDogZ2V0TW9kZWwsXG4gICAgcmVmcmVzaFZpZXc6IHJlZnJlc2hWaWV3LFxuICAgIHJlbW92ZUl0ZW1zOiByZW1vdmVJdGVtcyxcbiAgICBpbnNlcnRJdGVtc0F0SW5kZXg6IGluc2VydEl0ZW1zQXRJbmRleCxcbiAgICBjbGVhclJhbmdlU2VsZWN0aW9uOiBjbGVhclJhbmdlU2VsZWN0aW9uLFxuICAgIGNsZWFyRm9jdXNlZENlbGw6IGNsZWFyRm9jdXNlZENlbGwsXG4gICAgZ2V0RmxvYXRpbmdUb3BSb3dEYXRhOiBnZXRGbG9hdGluZ1RvcFJvd0RhdGEsXG4gICAgZ2V0RmxvYXRpbmdUb3BSb3dDb3VudDogZ2V0RmxvYXRpbmdUb3BSb3dDb3VudCxcbiAgICBzaG93Tm9Sb3dzT3ZlcmxheTogc2hvd05vUm93c092ZXJsYXksXG4gICAgaGlkZU92ZXJsYXk6IGhpZGVPdmVybGF5LFxuICAgIHJlZnJlc2hDZWxsczogcmVmcmVzaENlbGxzLFxuICAgIHNldERhdGFzb3VyY2U6IHNldERhdGFzb3VyY2UsXG4gICAgb25Hcm91cEV4cGFuZGVkT3JDb2xsYXBzZWQ6IG9uR3JvdXBFeHBhbmRlZE9yQ29sbGFwc2VkLFxuICAgIGdldFNvcnRNb2RlbDogZ2V0U29ydE1vZGVsLFxuICAgIGRvTGF5b3V0OiBkb0xheW91dCxcbiAgICByZWZyZXNoSW5NZW1vcnlSb3dNb2RlbDogcmVmcmVzaEluTWVtb3J5Um93TW9kZWwsXG4gICAgYXR0YWNoTGlua1RvRGF0YUNlbGw6IGF0dGFjaExpbmtUb0RhdGFDZWxsLFxuICAgIHJlZ2lzdGVyQ2VsbEVkaXRlZEV2ZW50TGlzdGVuZXI6IHJlZ2lzdGVyQ2VsbEVkaXRlZEV2ZW50TGlzdGVuZXIsXG4gICAgYXBwbHlQcm9wZXJ0aWVzOiBhcHBseVByb3BlcnRpZXNcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZ2V0QWxsR3JpZENvbHVtbnMoKSB7XG4gICAgdGhpcy5sb2coJ2dldEFsbEdyaWRDb2x1bW5zJyk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QWN0aXZlQ29sdW1ucygpO1xufVxuXG5mdW5jdGlvbiBzZXRDb2x1bW5WaXNpYmxlKGtleSwgdmlzaWJsZSkge1xuICAgIHRoaXMubG9nKCdzZXRDb2x1bW5WaXNpYmxlJywga2V5LCB2aXNpYmxlKTtcblxuICAgIHNldENvbHVtbnNWaXNpYmxlLmNhbGwodGhpcywgW2tleV0sIHZpc2libGUpO1xufVxuXG5mdW5jdGlvbiBzZXRDb2x1bW5zVmlzaWJsZShrZXlzLCB2aXNpYmxlKSB7XG4gICAgdGhpcy5sb2coJ3NldENvbHVtbnNWaXNpYmxlJywga2V5cywgdmlzaWJsZSk7XG4gICAgbGV0IGNvbERlZiA9IHRoaXMuY29sdW1uRGVmcztcbiAgICBsZXQgY29sdW1uc1N0YXRlQ2hhbmdlZCA9IGZhbHNlO1xuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIHRoaXMuZ2V0Q29sRGVmcyhrZXkpLmZvckVhY2goY2QgPT4ge1xuICAgICAgICAgICAgY2QuaXNIaWRkZW4gPSAhdmlzaWJsZTtcbiAgICAgICAgICAgIGNvbHVtbnNTdGF0ZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGlmIChjb2x1bW5zU3RhdGVDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuYXBpLnNldENvbHVtbkRlZnMoY29sRGVmKTtcbiAgICAgICAgdGhpcy5hcGkubmVlZENvbHVtbnNUb0ZpdCA9IHRydWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjaGFuZ2VQaW5uZWRSYW5nZShjb3VudFRvUGluKSB7XG4gICAgdGhpcy5sb2coJ2NoYW5nZVBpbm5lZFJhbmdlJywgY291bnRUb1Bpbik7XG59XG5cbmZ1bmN0aW9uIGdldEFsbENvbHVtbnMoKSB7XG4gICAgdGhpcy5sb2coJ2dldEFsbENvbHVtbnMnKTtcbiAgICByZXR1cm4gdGhpcy5nZXRBY3RpdmVDb2x1bW5zKCkuZmlsdGVyKGMgPT4gYy5jb2xEZWYpO1xufVxuXG5mdW5jdGlvbiByZXNldENvbHVtblN0YXRlKCkge1xuICAgIHRoaXMubG9nKCdyZXNldENvbHVtblN0YXRlJyk7XG59XG5cbmZ1bmN0aW9uIGdldENvbHVtbihrZXkpIHtcbiAgICB0aGlzLmxvZygnZ2V0Q29sdW1uJywga2V5KTtcblxufVxuXG5mdW5jdGlvbiBtb3ZlQ29sdW1uKGZyb21JbmRleCwgdG9JbmRleCkge1xuICAgIHRoaXMubW92ZUNvbHVtbnMoZnJvbUluZGV4LCAxLCB0b0luZGV4LCBmYWxzZSwgdHJ1ZSk7XG4gICAgdGhpcy5sb2coJ21vdmVDb2x1bW4nLCBmcm9tSW5kZXgsIHRvSW5kZXgpO1xufVxuXG5mdW5jdGlvbiBnZXRBbGxEaXNwbGF5ZWRWaXJ0dWFsQ29sdW1ucygpIHtcbiAgICB0aGlzLmxvZygnZ2V0QWxsRGlzcGxheWVkVmlydHVhbENvbHVtbnMnKTtcbiAgICByZXR1cm4gdGhpcy5nZXRBY3RpdmVDb2x1bW5zKCk7XG59XG5cbmZ1bmN0aW9uIGF1dG9TaXplQ29sdW1ucyhjb2x1bW5zLCBmb3JjZSkge1xuICAgIHRoaXMubG9nKCdhdXRvU2l6ZUNvbHVtbnMnLCBjb2x1bW5zLCBmb3JjZSk7XG4gICAgY29sdW1ucy5mb3JFYWNoKGMgPT4gdGhpcy5iZWhhdmlvci5maXRDb2x1bW4oYywgZm9yY2UpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLy8gZnVuY3Rpb25zXG4gICAgZ2V0QWxsR3JpZENvbHVtbnM6IGdldEFsbEdyaWRDb2x1bW5zLFxuICAgIHNldENvbHVtblZpc2libGU6IHNldENvbHVtblZpc2libGUsXG4gICAgc2V0Q29sdW1uc1Zpc2libGU6IHNldENvbHVtbnNWaXNpYmxlLFxuICAgIGNoYW5nZVBpbm5lZFJhbmdlOiBjaGFuZ2VQaW5uZWRSYW5nZSxcbiAgICBnZXRBbGxDb2x1bW5zOiBnZXRBbGxDb2x1bW5zLFxuICAgIHJlc2V0Q29sdW1uU3RhdGU6IHJlc2V0Q29sdW1uU3RhdGUsXG4gICAgZ2V0Q29sdW1uOiBnZXRDb2x1bW4sXG4gICAgbW92ZUNvbHVtbjogbW92ZUNvbHVtbixcbiAgICBnZXRBbGxEaXNwbGF5ZWRWaXJ0dWFsQ29sdW1uczogZ2V0QWxsRGlzcGxheWVkVmlydHVhbENvbHVtbnMsXG4gICAgYXV0b1NpemVDb2x1bW5zOiBhdXRvU2l6ZUNvbHVtbnNcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkaXNwYXRjaEV2ZW50ID0gcmVxdWlyZSgnLi4vZXZlbnRzLmpzJykuZGlzcGF0Y2hFdmVudDtcbnZhciBzY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYScpO1xuXG52YXIgaGFuZGxlcnNCeUV2ZW50U3RyaW5nO1xuXG4vKipcbiAqIEh5cGVyZ3JpZC9pbmRleC5qcyBtaXhlcyB0aGlzIG1vZHVsZSBpbnRvIGl0cyBwcm90b3R5cGUuXG4gKiBAbWl4aW5cbiAqL1xudmFyIG1peGluID0ge1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1kYXRhLXNjaGVtYS1jaGFuZ2VkYCBldmVudC5cbiAgICAgKiBAc2VlIHtAbGluayBkYXRhTW9kZWxBUEkjZXZlbnQ6ZGF0YS1zY2hlbWEtY2hhbmdlZCBkYXRhLXNjaGVtYS1jaGFuZ2VkfVxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNEYXRhU2NoZW1hQ2hhbmdlZEV2ZW50OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBzY2hlbWEuZW5yaWNoLmNhbGwodGhpcywgZXZlbnQgJiYgZXZlbnQuc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLWRhdGEtc2NoZW1hLWNoYW5nZWQnLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tZGF0YS1jaGFuZ2VkYCBldmVudC5cbiAgICAgKiBAc2VlIHtAbGluayBkYXRhTW9kZWxBUEkjZXZlbnQ6ZGF0YS1jaGFuZ2VkIGRhdGEtY2hhbmdlZH1cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljRGF0YUNoYW5nZWRFdmVudDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50LmNhbGwodGhpcywgJ2Zpbi1kYXRhLWNoYW5nZWQnLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tZGF0YS1zaGFwZS1jaGFuZ2VkYCBldmVudC5cbiAgICAgKiBAc2VlIHtAbGluayBkYXRhTW9kZWxBUEkjZXZlbnQ6ZGF0YS1zaGFwZS1jaGFuZ2VkIGRhdGEtc2hhcGUtY2hhbmdlZH1cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljRGF0YVNoYXBlQ2hhbmdlZEV2ZW50OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yU2hhcGVDaGFuZ2VkKCk7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50LmNhbGwodGhpcywgJ2Zpbi1kYXRhLXNoYXBlLWNoYW5nZWQnLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tZGF0YS1wcmVpbmRleGAgZXZlbnQuXG4gICAgICogQHNlZSB7QGxpbmsgZGF0YU1vZGVsQVBJI2V2ZW50OmRhdGEtcHJlcmVpbmRleCBkYXRhLXByZXJlaW5kZXh9XG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY0RhdGFQcmVyZWluZGV4RXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRSb3dTb3VyY2VJbmRleGVzID0gZ2V0VW5kZXJseWluZ0luZGV4ZXNPZlNlbGVjdGVkUm93cy5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsICdmaW4tZGF0YS1wcmVyZWluZGV4JywgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWRhdGEtcG9zdGluZGV4YCBldmVudC5cbiAgICAgKiBAc2VlIHtAbGluayBkYXRhTW9kZWxBUEkjZXZlbnQ6ZGF0YS1wb3N0cmVpbmRleCBkYXRhLXBvc3RyZWluZGV4fVxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNEYXRhUG9zdHJlaW5kZXhFdmVudDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRSb3dTb3VyY2VJbmRleGVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZFJvd1NvdXJjZUluZGV4ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzZWxlY3RSb3dzQnlVbmRlcmx5aW5nSW5kZXhlcy5jYWxsKHRoaXMsIHRoaXMuc2VsZWN0ZWRSb3dTb3VyY2VJbmRleGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNlbGVjdGVkUm93U291cmNlSW5kZXhlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsICdmaW4tZGF0YS1wb3N0cmVpbmRleCcsIGV2ZW50KSAmJlxuICAgICAgICAgICAgdGhpcy5maXJlU3ludGhldGljRGF0YVNoYXBlQ2hhbmdlZEV2ZW50KGV2ZW50KTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVEYXRhRXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoaGFuZGxlcnNCeUV2ZW50U3RyaW5nKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50U3RyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGFFdmVudExpc3RlbmVyKGV2ZW50U3RyaW5nLCBoYW5kbGVyc0J5RXZlbnRTdHJpbmdbZXZlbnRTdHJpbmddKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIGFkZERhdGFFdmVudExpc3RlbmVyOiBmdW5jdGlvbihldmVudFN0cmluZywgaGFuZGxlcikge1xuICAgICAgICB2YXIgZ3JpZCA9IHRoaXM7XG5cbiAgICAgICAgZ3JpZC5hZGRJbnRlcm5hbEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtJyArIGV2ZW50U3RyaW5nLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKGdyaWQsIGV2ZW50IHx8IHt9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG59O1xuXG5cbmhhbmRsZXJzQnlFdmVudFN0cmluZyA9IHtcbiAgICAnZGF0YS1zY2hlbWEtY2hhbmdlZCc6IG1peGluLmZpcmVTeW50aGV0aWNEYXRhU2NoZW1hQ2hhbmdlZEV2ZW50LFxuICAgICdkYXRhLWNoYW5nZWQnOiBtaXhpbi5maXJlU3ludGhldGljRGF0YUNoYW5nZWRFdmVudCxcbiAgICAnZGF0YS1zaGFwZS1jaGFuZ2VkJzogbWl4aW4uZmlyZVN5bnRoZXRpY0RhdGFTaGFwZUNoYW5nZWRFdmVudCxcbiAgICAnZGF0YS1wcmVyZWluZGV4JzogbWl4aW4uZmlyZVN5bnRoZXRpY0RhdGFQcmVyZWluZGV4RXZlbnQsXG4gICAgJ2RhdGEtcG9zdHJlaW5kZXgnOiBtaXhpbi5maXJlU3ludGhldGljRGF0YVBvc3RyZWluZGV4RXZlbnRcbn07XG5cblxuLyoqXG4gKiBTYXZlIHVuZGVybHlpbmcgZGF0YSByb3cgaW5kZXhlcyBiYWNraW5nIGN1cnJlbnQgZ3JpZCByb3cgc2VsZWN0aW9ucy5cbiAqIFRoaXMgY2FsbCBzaG91bGQgYmUgcGFpcmVkIHdpdGggYSBzdWJzZXF1ZW50IGNhbGwgdG8gYHJlc2VsZWN0R3JpZFJvd3NCYWNrZWRCeVNlbGVjdGVkRGF0YVJvd3NgLlxuICogQHByaXZhdGVcbiAqIEB0aGlzIHtCZWhhdmlvcn1cbiAqL1xuZnVuY3Rpb24gZ2V0VW5kZXJseWluZ0luZGV4ZXNPZlNlbGVjdGVkUm93cygpIHtcbiAgICB2YXIgc291cmNlSW5kZXhlcyA9IFtdLFxuICAgICAgICBkYXRhTW9kZWwgPSB0aGlzLmRhdGFNb2RlbDtcblxuICAgIGlmICh0aGlzLnByb3BlcnRpZXMua2VlcFJvd1NlbGVjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5nZXRTZWxlY3RlZFJvd3MoKS5mb3JFYWNoKGZ1bmN0aW9uKHNlbGVjdGVkUm93SW5kZXgpIHtcbiAgICAgICAgICAgIHNvdXJjZUluZGV4ZXMucHVzaChkYXRhTW9kZWwuZ2V0Um93SW5kZXgoc2VsZWN0ZWRSb3dJbmRleCkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlSW5kZXhlcztcbn1cblxuLyoqXG4gKiBSZS1lc3RhYmxpc2ggZ3JpZCByb3cgc2VsZWN0aW9ucyBiYXNlZCBvbiB1bmRlcmx5aW5nIGRhdGEgcm93IGluZGV4ZXMgc2F2ZWQgYnkgYGdldFNlbGVjdGVkRGF0YVJvd3NCYWNraW5nU2VsZWN0ZWRHcmlkUm93c2Agd2hpY2ggc2hvdWxkIGJlIGNhbGxlZCBmaXJzdC5cbiAqIEBwcml2YXRlXG4gKiBAdGhpcyB7QmVoYXZpb3J9XG4gKi9cbmZ1bmN0aW9uIHJlc2VsZWN0Um93c0J5VW5kZXJseWluZ0luZGV4ZXMoc291cmNlSW5kZXhlcykge1xuICAgIHZhciBpLCByLFxuICAgICAgICBkYXRhTW9kZWwgPSB0aGlzLmRhdGFNb2RlbCxcbiAgICAgICAgcm93Q291bnQgPSBkYXRhTW9kZWwuZ2V0Um93Q291bnQoKSxcbiAgICAgICAgc2VsZWN0ZWRSb3dDb3VudCA9IHNvdXJjZUluZGV4ZXMubGVuZ3RoLFxuICAgICAgICByb3dJbmRleGVzID0gW10sXG4gICAgICAgIHNlbGVjdGlvbk1vZGVsID0gdGhpcy5zZWxlY3Rpb25Nb2RlbDtcblxuICAgIHNlbGVjdGlvbk1vZGVsLmNsZWFyUm93U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLmtlZXBSb3dTZWxlY3Rpb25zKSB7XG4gICAgICAgIGZvciAociA9IDA7IHNlbGVjdGVkUm93Q291bnQgJiYgciA8IHJvd0NvdW50OyArK3IpIHtcbiAgICAgICAgICAgIGkgPSBzb3VyY2VJbmRleGVzLmluZGV4T2YoZGF0YU1vZGVsLmdldFJvd0luZGV4KHIpKTtcbiAgICAgICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgICAgICByb3dJbmRleGVzLnB1c2gocik7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNvdXJjZUluZGV4ZXNbaV07IC8vIG1pZ2h0IG1ha2UgaW5kZXhPZiBpbmNyZWFzaW5nbHkgZmFzdGVyIGFzIGRlbGV0ZWQgZWxlbWVudHMgYXJlIG5vdCBlbnVtZXJhYmxlXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRSb3dDb3VudC0tOyAvLyBjb3VudCBkb3duIHNvIHdlIGNhbiBiYWlsIGVhcmx5IGlmIGFsbCBmb3VuZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcm93SW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uKHJvd0luZGV4KSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbC5zZWxlY3RSb3cocm93SW5kZXgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm93SW5kZXhlcy5sZW5ndGg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG1peGluOiBtaXhpbixcbiAgICBoYW5kbGVyczogaGFuZGxlcnNCeUV2ZW50U3RyaW5nXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBtb2R1bGUgZGF0YU1vZGVsL3NjaGVtYVxuICovXG5cbnZhciBoZWFkZXJpZmllcnMgPSByZXF1aXJlKCcuLi8uLi9saWIvaGVhZGVyaWZpZXJzJyk7XG5cbi8qKlxuICogQGZ1bmN0aW9uIG1vZHVsZTpkYXRhTW9kZWwvc2NoZW1hLmVucmljaFxuICogQHN1bW1hcnkgQ2FsbGVkIHZpYSBgZGF0YS1zY2hlbWEtY2hhbmdlZGAgZXZlbnQgYnkgZGF0YSBtb2RlbCBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0U2NoZW1hYCB3aGVuIGltcGxlbWVudGVkLCBvdGhlcndpc2UgYnkgYGdldFNjaGVtYWAsIHdoZW5ldmVyIHRoZSBzY2hlbWEgY2hhbmdlcy5cbiAqXG4gKiBFbnJpY2hlcyBzY2hlbWEuIEZvciBlYWNoIFwiY29sdW1uIHNjaGVtYVwiIChlbGVtZW50IG9mIHNjaGVtYSBhcnJheSk6XG4gKlxuICogMS4gT2JqZWN0aWZ5IGNvbHVtbiBzY2hlbWF0YTxicj5cbiAqIEVuc3VyZXMgZWFjaCBjb2x1bW4gc2NoZW1hIGlzIGFuIG9iamVjdCB3aXRoIGEgYG5hbWVgIHByb3BlcnR5LlxuICogMi4gSW5kZXggc2NoZW1hIHNjaGVtYXRhPGJyPlxuICogQWRkcyBhbiBgaW5kZXhgIHByb3BlcnR5IHRvIGVhY2ggY29sdW1uIHNjaGVtYSBlbGVtZW50LlxuICogMy4gQ3JlYXRlIGVudW0gZW50cmllczxicj5cbiAqIENvbnN0cnVjdHMgYW4gZW51bSBkaXJlY3RseSBvbiB0aGUgc2NoZW1hIGFycmF5IG9iamVjdCBpdHNlbGYuIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBmZWF0dXJlLCBoZWxwZnVsIGZvciBsb29raW5nIHVwIGNvbHVtbiBzY2hlbWEgYnkgY29sdW1uIG5hbWUgcmF0aGVyIHRoYW4gYnkgaW5kZXguIFRvIGdldCB0aGUgaW5kZXggb2YgYSBjb2x1bW4gd2hlbiB5b3Uga25vdyB0aGUgbmFtZTpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBzY2hlbWEgPSBkYXRhTW9kZWwuZ2V0U2NoZW1hKCk7XG4gKiB2YXIgY29sdW1uTmFtZSA9ICdmb28nO1xuICogdmFyIGNvbHVtbkluZGV4ID0gc2NoZW1hW2NvbHVtbk5hbWVdLmluZGV4O1xuICogYGBgXG4gKiA0LiBDcmVhdGUgZGF0YSByb3cgcHJveHk8YnI+XG4gKiBDcmVhdGVzIGEgcHJveHkgb2JqZWN0IHdpdGggZ2V0dGVycyBmb3IgZWFjaCBmaWVsZCB0byBiZSB1c2VkIGFzIGEgZmFsbGJhY2sgd2hlbiBgZ2V0Um93YCBpcyBub3QgaW1wbGVtZW50ZWQuXG4gKlxuICogQHBhcmFtIHtkYXRhUm93T2JqZWN0W119XG4gKlxuICogQHRoaXMge0h5cGVyZ3JpZH1cbiAqL1xuZXhwb3J0cy5lbnJpY2ggPSBmdW5jdGlvbihzY2hlbWEpIHtcbiAgICB2YXIgZGF0YU1vZGVsID0gdGhpcy5iZWhhdmlvci5kYXRhTW9kZWw7XG5cbiAgICBzY2hlbWEgPSBzY2hlbWEgfHwgZGF0YU1vZGVsLmdldFNjaGVtYSgpO1xuXG4gICAgLy8gTWFrZSBzdXJlIGVhY2ggZWxlbWVudCBvZiBgc2NoZW1hYCBpcyBhbiBvYmplY3Qgd2l0aCBhIGBuYW1lYCBwcm9wZXJ0eS5cbiAgICBzY2hlbWEuZm9yRWFjaChmdW5jdGlvbihjb2x1bW5TY2hlbWEsIGluZGV4KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29sdW1uU2NoZW1hID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2NoZW1hW2luZGV4XSA9IHsgbmFtZTogY29sdW1uU2NoZW1hIH07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRoZXJlIHNob3VsZG4ndCBiZSBhbnkgbWV0YSBkYXRhIGNvbHVtbnMgaW4gdGhlIHNjaGVtYSBwcm9wZXIuXG4gICAgc2NoZW1hID0gc2NoZW1hLmZpbHRlcihmdW5jdGlvbihjb2x1bW5TY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIGNvbHVtblNjaGVtYS5uYW1lLnN1YnN0cigwLCAyKSAhPT0gJ19fJztcbiAgICB9KTtcblxuICAgIC8vIFNldCBgaW5kZXhgIHByb3BlcnR5LlxuICAgIHNjaGVtYS5mb3JFYWNoKGZ1bmN0aW9uKGNvbHVtblNjaGVtYSwgaW5kZXgpIHtcbiAgICAgICAgY29sdW1uU2NoZW1hLmluZGV4ID0gaW5kZXg7XG4gICAgfSk7XG5cbiAgICAvLyBTZXQgYGhlYWRlcmAgcHJvcGVydHkuXG4gICAgdmFyIGhlYWRlcmlmaWVyID0gaGVhZGVyaWZpZXJzW3RoaXMucHJvcGVydGllcy5oZWFkZXJpZnldO1xuICAgIGlmIChoZWFkZXJpZmllcikge1xuICAgICAgICBzY2hlbWEuZm9yRWFjaChmdW5jdGlvbihjb2x1bW5TY2hlbWEpIHtcbiAgICAgICAgICAgIGlmICghY29sdW1uU2NoZW1hLmhlYWRlcikge1xuICAgICAgICAgICAgICAgIGNvbHVtblNjaGVtYS5oZWFkZXIgPSBoZWFkZXJpZmllcihjb2x1bW5TY2hlbWEubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGluaXRTY2hlbWFFbnVtLmNhbGwoZGF0YU1vZGVsKTtcblxuICAgIGluaXREYXRhUm93UHJveHkuY2FsbChkYXRhTW9kZWwpO1xufTtcblxuLy8gc2NoZW1hIGRpY3Rpb25hcnkgKGVudW0pXG5cbi8vIGFsbCBpbnN0YW5jZXMgb2YgeFggb3IgX1hcbnZhciBSRUdFWF9DQU1FTF9DQVNFX09SX1VOREVSU0NPUkUgPSAvKFteX0EtWl0pKFtBLVpdKykvZztcbnZhciBSRUdFWF9BTExfUFVOQ19SVU4gPSAvW15hLXowLTldKy9naTtcblxuLy8gYWxsIGluc3RhbmNlcyBvZiBfeFxudmFyIFJFR0VYX0FMTF9QVU5DX1JVTl9CRUZPUkVfTEVUVEVSID0gL1teYS16MC05XSsoW2EtejAtOV0pPy9pZztcbmZ1bmN0aW9uIFdJVEhfVVBQRVJfQ0FTRShtYXRjaCwgY2hhcikgeyByZXR1cm4gY2hhciA9PT0gdW5kZWZpbmVkID8gJycgOiBjaGFyLnRvVXBwZXJDYXNlKCk7IH1cblxudmFyIFJFR0VYX0lOSVRJQUxfRElHSVQgPSAvXihcXGQpLztcbnZhciBXSVRIX0RPTExBUl9QUkVGSVggPSAnJCQkMSc7XG5cbnZhciBSRUdFWF9JTklUSUFMX0NBUElUQUwgPSAvXihbQS1aXSkvO1xuZnVuY3Rpb24gV0lUSF9MT1dFUl9DQVNFKG1hdGNoLCBjaGFyKSB7IHJldHVybiBjaGFyLnRvTG93ZXJDYXNlKCk7IH1cblxuLy8gUGFzcyB0aHJvdWdoIGFzIGlzLlxuZnVuY3Rpb24gcGFzc1Rocm91Z2goa2V5KSB7XG4gICAgcmV0dXJuIGtleTtcbn1cblxuLy8gQ29udmVydCBydW5zIG9mIHB1bmN0dWF0aW9uIHRvIGNhbWVsIGNhc2UgYnkgY2FwdGlhbGl6aW5nIGZvbGxvd2luZyBsZXR0ZXIuXG4vLyBPdGhlcndpc2UsIGxlYXZlcyBvdGhlciBsZXR0ZXJzJyBjYXNlIGFzIHRoZXkgd2VyZS5cbi8vIElmIHJlc3VsdCBzdGFydHMgd2l0aCBkaWdpdCwgcHJlZml4IHdpdGggJyQnLlxuZnVuY3Rpb24gdG9DYW1lbENhc2Uoa2V5KSB7XG4gICAgcmV0dXJuIGtleVxuICAgICAgICAucmVwbGFjZShSRUdFWF9BTExfUFVOQ19SVU5fQkVGT1JFX0xFVFRFUiwgV0lUSF9VUFBFUl9DQVNFKVxuICAgICAgICAucmVwbGFjZShSRUdFWF9JTklUSUFMX0RJR0lULCBXSVRIX0RPTExBUl9QUkVGSVgpXG4gICAgICAgIC5yZXBsYWNlKFJFR0VYX0lOSVRJQUxfQ0FQSVRBTCwgV0lUSF9MT1dFUl9DQVNFKTtcbn1cblxuLy8gQ29udmVydCBhbGwgcnVucyBvZiBwdW5jdHVhdGlvbiBhbmQgY2FtZWwgY2FzZSB0cmFuc2l0aW9ucyB0byB1bmRlcnNjb3JlLlxuLy8gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIGRpZ2l0LCBwcmVmaXggd2l0aCAnJCcuXG4vLyBDb252ZXJ0IHJlc3VsdCB0byBhbGwgY2Fwcy5cbmZ1bmN0aW9uIHRvQWxsQ2FwcyhrZXkpIHtcbiAgICByZXR1cm4ga2V5XG4gICAgICAgIC5yZXBsYWNlKFJFR0VYX0FMTF9QVU5DX1JVTiwgJ18nKVxuICAgICAgICAucmVwbGFjZShSRUdFWF9DQU1FTF9DQVNFX09SX1VOREVSU0NPUkUsICckMV8kMicpXG4gICAgICAgIC5yZXBsYWNlKFJFR0VYX0lOSVRJQUxfRElHSVQsIFdJVEhfRE9MTEFSX1BSRUZJWClcbiAgICAgICAgLnRvVXBwZXJDYXNlKCk7XG59XG5cbnZhciBjb252ZXJ0ZXJzID0gW3Bhc3NUaHJvdWdoLCB0b0NhbWVsQ2FzZSwgdG9BbGxDYXBzXTtcblxuLyoqXG4gKiBAc3VtbWFyeSBCdWlsZCBzY2hlbWEgZGljdGlvbmFyeSAoZW51bSlcbiAqIEBkZXNjIEZvciBlYWNoIGNvbHVtbiBzY2hlbWEgaW4gdGhlIHNjaGVtYSBhcnJheSwgYWRkcyB0aHJlZSBwcm9wZXJ0aWVzIHRvIHRoZSBhcnJheSBvYmplY3Q6XG4gKiAqIG5hbWUsIHZlcmJhdGltXG4gKiAqIG5hbWUsIHRyYW5zZm9ybWVkIHRvIGFsbC1jYXBzIHdpdGggcnVucyBvZiBwdW5jdHVhdGlvbiBhbmQgY2FtZWwgY2FzZSB0cmFuc2l0aW9ucyB0byB1bmRlcnNjb3JlIGNvbnZlcnRlZCB0byB1bmRlcnNjb3JlXG4gKiAqIG5hbWUsIHRyYW5zZm9ybWVkIHRvIGNhbWVsQ2FzZSB3aXRoIHJ1bnMgb2YgcHVuY3R1YXRpb24gcmVtb3ZlZCBhbmQgdGhlIG5leHQgbGV0dGVyIGNhcGl0YWxpemVkXG4gKlxuICogQ29uZmxpY3RzIGNhbiBvYnZpb3VzbHkgYXJpc2UsIGluIHdoaWNoIGNhc2Ugd2hvJ3MgZXZlciBmaXJzdCB3aW5zLlxuICogQHRoaXMge2RhdGFNb2RlbEFQSX1cbiAqL1xuZnVuY3Rpb24gaW5pdFNjaGVtYUVudW0oKSB7XG4gICAgdmFyIHNjaGVtYSA9IHRoaXMuZ2V0U2NoZW1hKCk7XG5cbiAgICBzY2hlbWEuZm9yRWFjaChmdW5jdGlvbihjb2x1bW5TY2hlbWEsIGNvbHVtbkluZGV4KSB7XG4gICAgICAgIGNvbnZlcnRlcnMuZm9yRWFjaChmdW5jdGlvbihjb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgIHZhciBjb252ZXJ0ZWRLZXkgPSBjb252ZXJ0ZXIoY29sdW1uU2NoZW1hLm5hbWUpO1xuICAgICAgICAgICAgaWYgKCEoY29udmVydGVkS2V5IGluIHNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICBzY2hlbWFbY29udmVydGVkS2V5XSA9IHNjaGVtYVtjb2x1bW5JbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5cbi8qKlxuICogQHN1bW1hcnkgQnVpbGQgdGhlIGBkYXRhUm93UHJveHlgIGdldHRlciBjb2xsZWN0aW9uIGJhc2VkIG9uIGN1cnJlbnQgYHNjaGVtYWAuXG4gKlxuICogQGRlc2MgVGhlIGBkYXRhUm93UHJveHlgIGNvbGxlY3Rpb24gaXMgcmV0dXJuZWQgYnkgdGhlIGBnZXRSb3dgIGZhbGxiYWNrLlxuICpcbiAqIGBkYXRhUm93UHJveHlgIGNvbGxlY3Rpb24gaXMgYSBkYXRhUm93LWxpa2Ugb2JqZWN0IChhIGhhc2ggb2YgY29sdW1uIHZhbHVlcyBrZXllZCBieSBjb2x1bW4gbmFtZSlcbiAqIGZvciB0aGUgcGFydGljdWxhciByb3cgd2hvc2UgaW5kZXggaXMgaW4gdGhlIGAkeSRgIHByb3BlcnR5LlxuICpcbiAqIFRoZSByb3cgaW5kZXggY2FuIGJlIGNvbnZlbmllbnRseSBzZXQgd2l0aCBhIGNhbGwgdG8gYGZhbGxiYWNrcy5nZXRSb3coKWAsXG4gKiB3aGljaCBzZXRzIHRoZSByb3cgaW5kZXggYW5kIHJldHVybnMgdGhlIGFjY2Vzc29yIGl0c2VsZi5cbiAqXG4gKiBgJHkkYCBpcyBhIFwiaGlkZGVuXCIgcHJvcGVydHksIG5vbi1lbnVtZXJhYmxlIGl0IHdvbid0IHNob3cgdXAgaW4gYE9iamVjdC5rZXlzKC4uLilgLlxuICpcbiAqIFRoaXMgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gaXMgXCJsYXp5XCI6IFRoZSBlbnVtZXJhYmxlIG1lbWJlcnMgYXJlIGFsbCBnZXR0ZXJzIHRoYXQgaW52b2tlIGBnZXRWYWx1ZWAgYW5kIHNldHRlcnMgdGhhdCBpbnZva2UgYHNldFZhbHVlYC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgZWFjaCB0aW1lIGEgbmV3IHNjaGVtYSBpcyBzZXQuXG4gKlxuICogQHRoaXMge2RhdGFNb2RlbEFQSX1cbiAqL1xuZnVuY3Rpb24gaW5pdERhdGFSb3dQcm94eSgpIHtcbiAgICB2YXIgZGF0YU1vZGVsID0gdGhpcyxcbiAgICAgICAgZGF0YVJvd1Byb3h5ID0ge307XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YVJvd1Byb3h5LCAnJHkkJywge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSwgLy8gbm90IGEgcmVhbCBkYXRhIGZpZWxkXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlIC8vIHNldCBsYXRlciBvbiBjYWxscyB0byBmYWxsYmFja3MuZ2V0Um93KHkpIHRvIHlcbiAgICB9KTtcblxuICAgIGRhdGFNb2RlbC5nZXRTY2hlbWEoKS5mb3JFYWNoKGZ1bmN0aW9uKGNvbHVtblNjaGVtYSwgY29sdW1uSW5kZXgpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFSb3dQcm94eSwgY29sdW1uU2NoZW1hLm5hbWUsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIC8vIGlzIGEgcmVhbCBkYXRhIGZpZWxkXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhTW9kZWwuZ2V0VmFsdWUoY29sdW1uSW5kZXgsIHRoaXMuJHkkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFNb2RlbC5zZXRWYWx1ZShjb2x1bW5JbmRleCwgdGhpcy4keSQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkYXRhTW9kZWwuZGF0YVJvd1Byb3h5ID0gZGF0YVJvd1Byb3h5O1xufVxuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdvYmplY3QtaXRlcmF0b3JzJyk7XG5cbi8qKlxuICogSHlwZXJncmlkL2luZGV4LmpzIG1peGVzIHRoaXMgbW9kdWxlIGludG8gaXRzIHByb3RvdHlwZS5cbiAqIEBtaXhpblxuICovXG52YXIgbWl4aW4gPSB7XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gbWUuXG4gICAgICogQGRlc2MgTGlzdGVuZXJzIGFkZGVkIGJ5IHRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIHJlbW92ZWQgYnkge0BsaW5rIEh5cGVyZ3JpZCNyZW1vdmVFdmVudExpc3RlbmVyfGdyaWQucmVtb3ZlRXZlbnRMaXN0ZW5lcn0gKG9yIHtAbGluayBIeXBlcmdyaWQjcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnN8Z3JpZC5yZW1vdmVBbGxFdmVudExpc3RlbmVyc30pLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBUaGUgdHlwZSBvZiBldmVudCB3ZSBhcmUgaW50ZXJlc3RlZCBpbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBldmVudCBoYW5kbGVyLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVybmFsPWZhbHNlXSAtIFVzZWQgYnkge0BsaW5rIEh5cGVyZ3JpZCNhZGRJbnRlcm5hbEV2ZW50TGlzdGVuZXJ8Z3JpZC5hZGRJbnRlcm5hbEV2ZW50TGlzdGVuZXJ9IChzZWUpLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oZXZlbnROYW1lLCBsaXN0ZW5lciwgaW50ZXJuYWwpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSA9IHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0gfHwgW10sXG4gICAgICAgICAgICBhbHJlYWR5QXR0YWNoZWQgPSBsaXN0ZW5lcnMuZmluZChmdW5jdGlvbihpbmZvKSB7IHJldHVybiBpbmZvLmxpc3RlbmVyID09PSBsaXN0ZW5lcjsgfSk7XG5cbiAgICAgICAgaWYgKCFhbHJlYWR5QXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICAgICAgIGludGVybmFsOiBpbnRlcm5hbCxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgICAgICAgICAgICAgZGVjb3JhdG9yOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmFsbG93RXZlbnRIYW5kbGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2goaW5mbyk7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaW5mby5kZWNvcmF0b3IpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEFkZCBhbiBpbnRlcm5hbCBldmVudCBsaXN0ZW5lciB0byBtZS5cbiAgICAgKiBAZGVzYyBUaGUgbmV3IGxpc3RlbmVyIGlzIGZsYWdnZWQgYXMgXCJpbnRlcm5hbC5cIiBJbnRlcm5hbCBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQgYXMgdXN1YWwgYnkge0BsaW5rIEh5cGVyZ3JpZCNyZW1vdmVFdmVudExpc3RlbmVyfGdyaWQucmVtb3ZlRXZlbnRMaXN0ZW5lcn0uIEhvd2V2ZXIsIHRoZXkgYXJlIGlnbm9yZWQgYnkge0BsaW5rIEh5cGVyZ3JpZCNyZW1vdmVBbGxFdmVudExpc3RlbmVyc3xncmlkLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCl9IChhcyBjYWxsZWQgYnkge0BsaW5rIEh5cGVyZ3JpZCNyZXNldHxyZXNldH0pLiAoQnV0IHNlZSB7QGxpbmsgSHlwZXJncmlkI3JlbW92ZUFsbEV2ZW50TGlzdGVuZXJzfGdyaWQucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnModHJ1ZSl9LilcbiAgICAgKlxuICAgICAqIExpc3RlbmVycyBhZGRlZCBieSB0aGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSByZW1vdmVkIGJ5IHtAbGluayBIeXBlcmdyaWQjcmVtb3ZlRXZlbnRMaXN0ZW5lcnxncmlkLnJlbW92ZUV2ZW50TGlzdGVuZXJ9IChvciB7QGxpbmsgSHlwZXJncmlkI3JlbW92ZUFsbEV2ZW50TGlzdGVuZXJzfGdyaWQucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnModHJ1ZSl9KS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gVGhlIHR5cGUgb2YgZXZlbnQgd2UgYXJlIGludGVyZXN0ZWQgaW4uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgZXZlbnQgaGFuZGxlci5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIGFkZEludGVybmFsRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lcnMuXG4gICAgICogQGRlc2MgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXIgd2l0aCBtYXRjaGluZyBuYW1lIGFuZCBmdW5jdGlvbiB0aGF0IHdhcyBhZGRlZCBieSB7QGxpbmsgSHlwZXJncmlkI2FkZEV2ZW50TGlzdGVuZXJ8Z3JpZC5hZGRFdmVudExpc3RlbmVyfS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgbWV0aG9kIGNhbm5vdCByZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGFkZGVkIGJ5IG90aGVyIG1lYW5zLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgbGlzdGVuZXJMaXN0ID0gdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXTtcblxuICAgICAgICBpZiAobGlzdGVuZXJMaXN0KSB7XG4gICAgICAgICAgICBsaXN0ZW5lckxpc3QuZmluZChmdW5jdGlvbihpbmZvLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChpbmZvLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJMaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lckxpc3Quc3BsaWNlKGluZGV4LCAxKTsgLy8gcmVtb3ZlIGl0IGZyb20gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaW5mby5kZWNvcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZW1vdmUgYWxsIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKiBAZGVzYyBSZW1vdmVzIGFsbCBldmVudCBsaXN0ZW5lcnMgYWRkZWQgd2l0aCB7QGxpbmsgSHlwZXJncmlkI2FkZEV2ZW50TGlzdGVuZXJ8Z3JpZC5hZGRFdmVudExpc3RlbmVyfSBleGNlcHQgdGhvc2UgYWRkZWQgYXMgXCJpbnRlcm5hbC5cIlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVybmFsPWZhbHNlXSAtIEluY2x1ZGUgaW50ZXJuYWwgbGlzdGVuZXJzLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uKGludGVybmFsKSB7XG4gICAgICAgIF8odGhpcy5saXN0ZW5lcnMpLmVhY2goZnVuY3Rpb24obGlzdGVuZXJMaXN0LCBrZXkpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyTGlzdC5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24oaW5mbykge1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbCB8fCAhaW5mby5pbnRlcm5hbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoa2V5LCBpbmZvLmxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIGFsbG93RXZlbnRzOiBmdW5jdGlvbihhbGxvdyl7XG4gICAgICAgIHRoaXMuYWxsb3dFdmVudEhhbmRsZXJzID0gISFhbGxvdztcblxuICAgICAgICBpZiAodGhpcy5iZWhhdmlvci5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIGlmIChhbGxvdyl7XG4gICAgICAgICAgICAgICAgdGhpcy5iZWhhdmlvci5mZWF0dXJlQ2hhaW4uYXR0YWNoQ2hhaW4oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iZWhhdmlvci5mZWF0dXJlQ2hhaW4uZGV0YWNoQ2hhaW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYmVoYXZpb3IuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjIC0gZ3JpZCBjb2x1bW4gaW5kZXguXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0ga2V5c1xuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNDb2x1bW5Tb3J0RXZlbnQ6IGZ1bmN0aW9uKGMsIGtleXMpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLWNvbHVtbi1zb3J0Jywge1xuICAgICAgICAgICAgY29sdW1uOiBjLFxuICAgICAgICAgICAga2V5czoga2V5c1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0VkaXRvcktleVVwRXZlbnQ6IGZ1bmN0aW9uKGlucHV0Q29udHJvbCwga2V5RXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLWVkaXRvci1rZXl1cCcsIHtcbiAgICAgICAgICAgIGlucHV0OiBpbnB1dENvbnRyb2wsXG4gICAgICAgICAgICBrZXlFdmVudDoga2V5RXZlbnQsXG4gICAgICAgICAgICBjaGFyOiB0aGlzLmNhbnZhcy5nZXRDaGFyTWFwKClba2V5RXZlbnQua2V5Q29kZV1ba2V5RXZlbnQuc2hpZnRLZXkgPyAxIDogMF1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZpcmVTeW50aGV0aWNBcGlEZXN0cm95Q2FsbGVkOiBmdW5jdGlvbih0b3RhbCkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsICdmaW4tYXBpLWRlc3Ryb3ktY2FsbGVkJywge3RvdGFsfSk7XG4gICAgfSxcblxuXG4gICAgZmlyZVN5bnRoZXRpY0VkaXRvcktleURvd25FdmVudDogZnVuY3Rpb24oaW5wdXRDb250cm9sLCBrZXlFdmVudCkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsICdmaW4tZWRpdG9yLWtleWRvd24nLCB7XG4gICAgICAgICAgICBpbnB1dDogaW5wdXRDb250cm9sLFxuICAgICAgICAgICAga2V5RXZlbnQ6IGtleUV2ZW50LFxuICAgICAgICAgICAgY2hhcjogdGhpcy5jYW52YXMuZ2V0Q2hhck1hcCgpW2tleUV2ZW50LmtleUNvZGVdW2tleUV2ZW50LnNoaWZ0S2V5ID8gMSA6IDBdXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljRWRpdG9yS2V5UHJlc3NFdmVudDogZnVuY3Rpb24oaW5wdXRDb250cm9sLCBrZXlFdmVudCkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsICdmaW4tZWRpdG9yLWtleXByZXNzJywge1xuICAgICAgICAgICAgaW5wdXQ6IGlucHV0Q29udHJvbCxcbiAgICAgICAgICAgIGtleUV2ZW50OiBrZXlFdmVudCxcbiAgICAgICAgICAgIGNoYXI6ICh0aGlzLmNhbnZhcy5nZXRDaGFyTWFwKClba2V5RXZlbnQua2V5Q29kZV0gfHwge30pW2tleUV2ZW50LnNoaWZ0S2V5ID8gMSA6IDBdXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljRWRpdG9yRGF0YUNoYW5nZUV2ZW50OiBmdW5jdGlvbihpbnB1dENvbnRyb2wsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsICdmaW4tZWRpdG9yLWRhdGEtY2hhbmdlJywgdHJ1ZSwge1xuICAgICAgICAgICAgaW5wdXQ6IGlucHV0Q29udHJvbCxcbiAgICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZSxcbiAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0NvbHVtbnNNb3ZlZEV2ZW50OiBmdW5jdGlvbihjb2x1bW5zLCB0b0luZGV4KSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50LmNhbGwodGhpcywgJ2Zpbi1jb2x1bW5zLW1vdmVkJywgdHJ1ZSwge1xuICAgICAgICAgICAgY29sdW1uczogY29sdW1ucyxcbiAgICAgICAgICAgIHRvSW5kZXg6IHRvSW5kZXhcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tcm93LXNlbGVjdGlvbi1jaGFuZ2VkYCBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljUm93U2VsZWN0aW9uQ2hhbmdlZEV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLXJvdy1zZWxlY3Rpb24tY2hhbmdlZCcsIHRoaXMuc2VsZWN0aW9uRGV0YWlsR2V0dGVycyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tY29sdW1uLXNlbGVjdGlvbi1jaGFuZ2VkYCBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljQ29sdW1uU2VsZWN0aW9uQ2hhbmdlZEV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLWNvbHVtbi1zZWxlY3Rpb24tY2hhbmdlZCcsIHRoaXMuc2VsZWN0aW9uRGV0YWlsR2V0dGVycyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tZ3JpZC1kYXRhLWFkZGVkYCBldmVudC5cbiAgICAgKiBAcGFyYW0ge2FycmF5fSBkYXRhUm93cyAtIGFkZGVkIGRhdGEgcm93c1xuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNHcmlkRGF0YUFkZGVkRXZlbnQ6IGZ1bmN0aW9uKGRhdGFSb3dzKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50LmNhbGwodGhpcywgJ2Zpbi1ncmlkLWRhdGEtYWRkZWQnLCB0cnVlLCB7XG4gICAgICAgICAgICBkYXRhUm93czogZGF0YVJvd3NcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tY29udGV4dC1tZW51YCBldmVudFxuICAgICAqIEBwYXJhbSB7a2V5RXZlbnR9IGV2ZW50IC0gVGhlIGNhbnZhcyBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljQ29udGV4dE1lbnVFdmVudDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZXZlbnQsIHRoaXMuc2VsZWN0aW9uRGV0YWlsR2V0dGVyRGVzY3JpcHRvcnMpO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsICdmaW4tY29udGV4dC1tZW51Jywge30sIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY01vdXNlVXBFdmVudDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZXZlbnQsIHRoaXMuc2VsZWN0aW9uRGV0YWlsR2V0dGVyRGVzY3JpcHRvcnMpO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsICdmaW4tbW91c2V1cCcsIHt9LCBldmVudCk7XG4gICAgfSxcblxuICAgIGZpcmVTeW50aGV0aWNNb3VzZURvd25FdmVudDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZXZlbnQsIHRoaXMuc2VsZWN0aW9uRGV0YWlsR2V0dGVyRGVzY3JpcHRvcnMpO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsICdmaW4tbW91c2Vkb3duJywge30sIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY01vdXNlTW92ZUV2ZW50OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsICdmaW4tbW91c2Vtb3ZlJywge30sIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0J1dHRvblByZXNzZWRFdmVudDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIHN1YnJlY3RzID0gdGhpcy5pc1ZpZXdhYmxlQnV0dG9uKGV2ZW50LmRhdGFDZWxsLngsIGV2ZW50LmdyaWRDZWxsLnkpO1xuICAgICAgICBpZiAoc3VicmVjdHMpIHtcbiAgICAgICAgICAgIHZhciBzdWJyb3cgPSBzdWJyZWN0cy5maW5kSW5kZXgoZnVuY3Rpb24oYm91bmRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vdXNlID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBib3VuZHMueSA8PSBtb3VzZS55ICYmIG1vdXNlLnkgPCBib3VuZHMueSArIGJvdW5kcy5oZWlnaHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzdWJyb3cgPj0gMCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnN1YnJvdyA9IHN1YnJvdztcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsICdmaW4tYnV0dG9uLXByZXNzZWQnLCB7fSwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tY29sdW1uLWRyYWctc3RhcnRgIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNPbkNvbHVtbnNDaGFuZ2VkRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsICdmaW4tY29sdW1uLWNoYW5nZWQtZXZlbnQnLCB7fSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tY29sdW1uLWRyYWctc3RhcnRgIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNPbkNvbHVtblJlc2l6ZWRFdmVudDogZnVuY3Rpb24oY29sdW1uT3JJbmRleCwgd2lkdGgpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgY29sdW1uT3JJbmRleDogY29sdW1uT3JJbmRleCxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsICdmaW4tY29sdW1uLXJlc2l6ZWQtZXZlbnQnLCB7fSwgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWZpeGVkLWNvbHVtbi1jb3VudC1jaGFuZ2VkYCBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljT25GaXhlZENvbHVtbkNvdW50Q2hhbmdlZEV2ZW50OiBmdW5jdGlvbihvbGRGaXhlZENvdW50LCBuZXdGaXhlZENvdW50KSB7XG4gICAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAgIG9sZEZpeGVkQ291bnQ6IG9sZEZpeGVkQ291bnQsXG4gICAgICAgICAgICBuZXdGaXhlZENvdW50OiBuZXdGaXhlZENvdW50XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50LmNhbGwodGhpcywgJ2Zpbi1maXhlZC1jb2x1bW4tY291bnQtY2hhbmdlZCcsIHt9LCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tZml4ZWQtcm93LWNvdW50LWNoYW5nZWRgIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNPbkZpeGVkUm93Q291bnRDaGFuZ2VkRXZlbnQ6IGZ1bmN0aW9uKG9sZEZpeGVkQ291bnQsIG5ld0ZpeGVkQ291bnQpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgb2xkRml4ZWRDb3VudDogb2xkRml4ZWRDb3VudCxcbiAgICAgICAgICAgIG5ld0ZpeGVkQ291bnQ6IG5ld0ZpeGVkQ291bnRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLWZpeGVkLXJvdy1jb3VudC1jaGFuZ2VkJywge30sIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1rZXlkb3duYCBldmVudC5cbiAgICAgKiBAcGFyYW0ge2tleUV2ZW50fSBldmVudCAtIFRoZSBjYW52YXMgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY0tleWRvd25FdmVudDogZnVuY3Rpb24oa2V5RXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLWtleWRvd24nLCBrZXlFdmVudC5kZXRhaWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWtleXVwYCBldmVudC5cbiAgICAgKiBAcGFyYW0ge2tleUV2ZW50fSBldmVudCAtIFRoZSBjYW52YXMgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY0tleXVwRXZlbnQ6IGZ1bmN0aW9uKGtleUV2ZW50KSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50LmNhbGwodGhpcywgJ2Zpbi1rZXl1cCcsIGtleUV2ZW50LmRldGFpbCk7XG4gICAgfSxcblxuICAgIGZpcmVTeW50aGV0aWNGaWx0ZXJBcHBsaWVkRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsICdmaW4tZmlsdGVyLWFwcGxpZWQnLCB7fSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tY2VsbC1lbnRlcmAgZXZlbnRcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBjZWxsIGluIHdoaWNoIHRoZSBjbGljayBldmVudCBvY2N1cnJlZC5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gVGhlIHN5c3RlbSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljT25DZWxsRW50ZXJFdmVudDogZnVuY3Rpb24oY2VsbEV2ZW50KSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50LmNhbGwodGhpcywgJ2Zpbi1jZWxsLWVudGVyJywgY2VsbEV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1jZWxsLWV4aXRgIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGNlbGwgLSBUaGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIGNlbGwgaW4gd2hpY2ggdGhlIGNsaWNrIGV2ZW50IG9jY3VyZWQuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIFRoZSBzeXN0ZW0gbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY09uQ2VsbEV4aXRFdmVudDogZnVuY3Rpb24oY2VsbEV2ZW50KSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50LmNhbGwodGhpcywgJ2Zpbi1jZWxsLWV4aXQnLCBjZWxsRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWNlbGwtY2xpY2tgIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGNlbGwgLSBUaGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIGNlbGwgaW4gd2hpY2ggdGhlIGNsaWNrIGV2ZW50IG9jY3VyZWQuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIFRoZSBzeXN0ZW0gbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY0NsaWNrRXZlbnQ6IGZ1bmN0aW9uKGNlbGxFdmVudCkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsICdmaW4tY2xpY2snLCB7fSwgY2VsbEV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1kb3VibGUtY2xpY2tgIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSBUaGUgc3lzdGVtIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNEb3VibGVDbGlja0V2ZW50OiBmdW5jdGlvbihjZWxsRXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFib3J0RWRpdGluZygpKSB7IHJldHVybjsgfVxuXG4gICAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50LmNhbGwodGhpcywgJ2Zpbi1kb3VibGUtY2xpY2snLCB7fSwgY2VsbEV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgcmVuZGVyZWQgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY0dyaWRSZW5kZXJlZEV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsICdmaW4tZ3JpZC1yZW5kZXJlZCcsIHsgc291cmNlOiB0aGlzIH0pO1xuICAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljVGlja0V2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLXRpY2snLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0dyaWRSZXNpemVkRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLWdyaWQtcmVzaXplZCcsIGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBzY3JvbGwgZXZlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBTaG91bGQgYmUgZWl0aGVyIGBmaW4tc2Nyb2xsLXhgIG9yIGBmaW4tc2Nyb2xsLXlgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvbGRWYWx1ZSAtIFRoZSBvbGQgc2Nyb2xsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdWYWx1ZSAtIFRoZSBuZXcgc2Nyb2xsIHZhbHVlLlxuICAgICAqL1xuICAgIGZpcmVTY3JvbGxFdmVudDogZnVuY3Rpb24oZXZlbnROYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCBldmVudE5hbWUsIHtcbiAgICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZmlyZVJlcXVlc3RDZWxsRWRpdDogZnVuY3Rpb24oY2VsbEV2ZW50LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsICdmaW4tcmVxdWVzdC1jZWxsLWVkaXQnLCB0cnVlLCB7IHZhbHVlOiB2YWx1ZSB9LCBjZWxsRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBmaW4tYmVmb3JlLWNlbGwtZWRpdCBldmVudC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gVGhlIHgseSBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSBUaGUgY3VycmVudCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUHJvY2VlZCAoZG9uJ3QgY2FuY2VsKS5cbiAgICAgKi9cbiAgICBmaXJlQmVmb3JlQ2VsbEVkaXQ6IGZ1bmN0aW9uKGNlbGxFdmVudCwgb2xkVmFsdWUsIG5ld1ZhbHVlLCBjb250cm9sKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50LmNhbGwodGhpcywgJ2Zpbi1iZWZvcmUtY2VsbC1lZGl0JywgdHJ1ZSwge1xuICAgICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlLFxuICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgaW5wdXQ6IGNvbnRyb2xcbiAgICAgICAgfSwgY2VsbEV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7UmVuZGVyZXJ9IHN1Yi1jb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gVGhlIHgseSBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWUgLSBUaGUgb2xkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdWYWx1ZSAtIFRoZSBuZXcgdmFsdWUuXG4gICAgICovXG4gICAgZmlyZUFmdGVyQ2VsbEVkaXQ6IGZ1bmN0aW9uKGNlbGxFdmVudCwgb2xkVmFsdWUsIG5ld1ZhbHVlLCBjb250cm9sKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50LmNhbGwodGhpcywgJ2Zpbi1hZnRlci1jZWxsLWVkaXQnLCB7XG4gICAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWUsXG4gICAgICAgICAgICBpbnB1dDogY29udHJvbFxuICAgICAgICB9LCBjZWxsRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIHtSZW5kZXJlcn0gc3ViLWNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGNlbGwgLSBUaGUgeCx5IGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZSAtIFRoZSBvbGQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5ld1ZhbHVlIC0gVGhlIG5ldyB2YWx1ZS5cbiAgICAgKi9cbiAgICBmaXJlQWZ0ZXJIZWFkZXJDZWxsRWRpdDogZnVuY3Rpb24oY2VsbEV2ZW50LCBvbGRWYWx1ZSwgbmV3VmFsdWUsIGNvbnRyb2wpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLWFmdGVyLWhlYWRlci1jZWxsLWVkaXQnLCB7XG4gICAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWUsXG4gICAgICAgICAgICBpbnB1dDogY29udHJvbFxuICAgICAgICB9LCBjZWxsRXZlbnQpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZUNhbnZhc0V2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBncmlkID0gdGhpcztcblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZUV2ZW50KGUsIGNiKSB7XG4gICAgICAgICAgICBpZiAoZ3JpZC5nZXRMb2dpY2FsUm93Q291bnQoKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGMgPSBncmlkLmdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQoZS5kZXRhaWwubW91c2UpLFxuICAgICAgICAgICAgICAgIHByaW1pdGl2ZUV2ZW50LFxuICAgICAgICAgICAgICAgIGRlY29yYXRlZEV2ZW50O1xuXG4gICAgICAgICAgICAvLyBObyBldmVudHMgb24gdGhlIHdoaXRlc3BhY2Ugb2YgdGhlIGdyaWQgdW5sZXNzIHRoZXkncmUgZHJhZyBldmVudHNcbiAgICAgICAgICAgIGlmIChjICYmICghYy5mYWtlIHx8IGUuZGV0YWlsLmRyYWdzdGFydCkpIHtcbiAgICAgICAgICAgICAgICBwcmltaXRpdmVFdmVudCA9IGMuY2VsbEV2ZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJpbWl0aXZlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBkZWNvcmF0ZWRFdmVudCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgcHJpbWl0aXZlRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICdwcmltaXRpdmVFdmVudCcsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKGdyaWQsIGRlY29yYXRlZEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRkSW50ZXJuYWxFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLXJlc2l6ZWQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBncmlkLnJlc2l6ZWQoKTtcbiAgICAgICAgICAgIGdyaWQuZmlyZVN5bnRoZXRpY0dyaWRSZXNpemVkRXZlbnQoZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkSW50ZXJuYWxFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLW1vdXNlbW92ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChncmlkLnByb3BlcnRpZXMucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVNb3VzZUV2ZW50KGUsIGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlTW91c2VNb3ZlKG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY01vdXNlTW92ZUV2ZW50KG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkSW50ZXJuYWxFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLW1vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChncmlkLnByb3BlcnRpZXMucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWdyaWQuYWJvcnRFZGl0aW5nKCkpIHtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhbmRsZU1vdXNlRXZlbnQoZSwgZnVuY3Rpb24obW91c2VFdmVudCkge1xuICAgICAgICAgICAgICAgIG1vdXNlRXZlbnQua2V5cyA9IGUuZGV0YWlsLmtleXM7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZURvd25TdGF0ZSA9IG1vdXNlRXZlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZU1vdXNlRG93bihtb3VzZUV2ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVTeW50aGV0aWNNb3VzZURvd25FdmVudChtb3VzZUV2ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEludGVybmFsRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1vdXRzaWRlLW1vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGdyaWQuZGVsZWdhdGVDYW52YXNPdXRzaWRlTW91c2Vkb3duKGV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRJbnRlcm5hbEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoZ3JpZC5wcm9wZXJ0aWVzLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlTW91c2VFdmVudChlLCBmdW5jdGlvbihtb3VzZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgbW91c2VFdmVudC5rZXlzID0gZS5kZXRhaWwua2V5czsgLy8gdG9kbzogdGhpcyB3YXMgaW4gZmluLXRhcCBidXQgd2Fzbid0IGhlcmVcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVTeW50aGV0aWNDbGlja0V2ZW50KG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGVDbGljayhtb3VzZUV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEludGVybmFsRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1tb3VzZXVwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGdyaWQucHJvcGVydGllcy5yZWFkT25seSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyaWQuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgICAgICBncmlkLnNldFNjcm9sbGluZ05vdyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JpZC5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZykge1xuICAgICAgICAgICAgICAgIGdyaWQuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZU1vdXNlRXZlbnQoZSwgZnVuY3Rpb24obW91c2VFdmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGVNb3VzZVVwKG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChncmlkLm1vdXNlRG93blN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQuZmlyZVN5bnRoZXRpY0J1dHRvblByZXNzZWRFdmVudChncmlkLm1vdXNlRG93blN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZURvd25TdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlU3ludGhldGljTW91c2VVcEV2ZW50KG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkSW50ZXJuYWxFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLWRibGNsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGdyaWQucHJvcGVydGllcy5yZWFkT25seSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZU1vdXNlRXZlbnQoZSwgZnVuY3Rpb24obW91c2VFdmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY0RvdWJsZUNsaWNrRXZlbnQobW91c2VFdmVudCwgZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZURvdWJsZUNsaWNrKG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkSW50ZXJuYWxFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLWRyYWcnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoZ3JpZC5wcm9wZXJ0aWVzLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JpZC5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICBoYW5kbGVNb3VzZUV2ZW50KGUsIGdyaWQuZGVsZWdhdGVNb3VzZURyYWcpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEludGVybmFsRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1rZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGdyaWQucHJvcGVydGllcy5yZWFkT25seSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyaWQuZmlyZVN5bnRoZXRpY0tleWRvd25FdmVudChlKTtcbiAgICAgICAgICAgIGdyaWQuZGVsZWdhdGVLZXlEb3duKGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEludGVybmFsRXZlbnRMaXN0ZW5lcignZmluLWFwaS1kZXN0cm95LWNhbGxlZCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGdyaWQuZGVsZWdhdGVBcGlEZXN0cm95Q2FsbGVkKGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEludGVybmFsRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1rZXl1cCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChncmlkLnByb3BlcnRpZXMucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmlkLmZpcmVTeW50aGV0aWNLZXl1cEV2ZW50KGUpO1xuICAgICAgICAgICAgZ3JpZC5kZWxlZ2F0ZUtleVVwKGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEludGVybmFsRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy13aGVlbG1vdmVkJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaGFuZGxlTW91c2VFdmVudChlLCBncmlkLmRlbGVnYXRlV2hlZWxNb3ZlZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkSW50ZXJuYWxFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLW1vdXNlb3V0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGdyaWQucHJvcGVydGllcy5yZWFkT25seSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZU1vdXNlRXZlbnQoZSwgZ3JpZC5kZWxlZ2F0ZU1vdXNlRXhpdCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkSW50ZXJuYWxFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLWNvbnRleHQtbWVudScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZU1vdXNlRXZlbnQoZSwgZnVuY3Rpb24obW91c2VFdmVudCl7XG4gICAgICAgICAgICAgICAgZ3JpZC5kZWxlZ2F0ZUNvbnRleHRNZW51KG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgICAgIGdyaWQuZmlyZVN5bnRoZXRpY0NvbnRleHRNZW51RXZlbnQobW91c2VFdmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRJbnRlcm5hbEV2ZW50TGlzdGVuZXIoJ2Zpbi1ncmlkLXJlbmRlcmVkJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZ3JpZC5kZWxlZ2F0ZUdyaWRSZW5kZXJlZChldmVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vUmVnaXN0ZXIgYSBsaXN0ZW5lciBmb3IgdGhlIGNvcHkgZXZlbnQgc28gd2UgY2FuIGNvcHkgb3VyIHNlbGVjdGVkIHJlZ2lvbiB0byB0aGUgcGFzdGVidWZmZXIgaWYgY29uZGl0aW9ucyBhcmUgcmlnaHQuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY29weScsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgZ3JpZC5jaGVja0NsaXBib2FyZENvcHkoZXZ0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXZ0LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9odG1sJykpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEludGVybmFsRXZlbnRMaXN0ZW5lcignZmluLWNvbHVtbi1yZXNpemVkLWV2ZW50JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZ3JpZC5kZWxlZ2F0ZUNvbHVtblJlc2l6ZWRFdmVudChldmVudCk7XG5cbiAgICAgICAgICAgIGdyaWQuc3luY2hyb25pemVTY3JvbGxiYXJzVmlzdWFsaXphdGlvbigpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEludGVybmFsRXZlbnRMaXN0ZW5lcignZmluLWZpeGVkLWNvbHVtbi1jb3VudC1jaGFuZ2VkJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZ3JpZC5zeW5jaHJvbml6ZVNjcm9sbGJhcnNWaXN1YWxpemF0aW9uKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkSW50ZXJuYWxFdmVudExpc3RlbmVyKCdmaW4tZml4ZWQtcm93LWNvdW50LWNoYW5nZWQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBncmlkLnN5bmNocm9uaXplU2Nyb2xsYmFyc1Zpc3VhbGl6YXRpb24oKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRJbnRlcm5hbEV2ZW50TGlzdGVuZXIoJ2Zpbi1hZnRlci1jZWxsLWVkaXQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVyUm93WSA9IGdyaWQucHJvcGVydGllcy51c2VIZWFkZXJzID8gZ3JpZC5nZXRGaWN0aXZlSGVhZGVyUm93c0NvdW50KCkgOiAwO1xuICAgICAgICAgICAgaWYgKGUuZGV0YWlsLnByaW1pdGl2ZUV2ZW50LnkgPD0gaGVhZGVyUm93WSkge1xuICAgICAgICAgICAgICAgIGdyaWQuZmlyZUFmdGVySGVhZGVyQ2VsbEVkaXQoZS5kZXRhaWwucHJpbWl0aXZlRXZlbnQsIGUuZGV0YWlsLm9sZFZhbHVlLCBlLmRldGFpbC5uZXdWYWx1ZSwgZS5kZXRhaWwuaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEludGVybmFsRXZlbnRMaXN0ZW5lcignZmluLWFmdGVyLWhlYWRlci1jZWxsLWVkaXQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoZS5kZXRhaWwubmV3VmFsdWUgIT09IGUuZGV0YWlsLm9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sdW1uID0gZ3JpZC5iZWhhdmlvci5nZXRBY3RpdmVDb2x1bW4oZS5kZXRhaWwucHJpbWl0aXZlRXZlbnQueCk7XG4gICAgICAgICAgICAgICAgZ3JpZC5iZWhhdmlvci5maXRDb2x1bW4oY29sdW1uKTsgLy8gcmVjYWxjdWxhdGUgcHJlZmVycmVkV2lkdGggZm9yIGNvbHVtblxuICAgICAgICAgICAgICAgIGlmIChncmlkLm9uVXBkYXRlQ29sdW1uTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmlkLm9uVXBkYXRlQ29sdW1uTmFtZShjb2x1bW4sIGUuZGV0YWlsLm5ld1ZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVmcmVzaCBuYW1lcyBmcm9tIGNvbERlZnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvd1Byb3BzID0gZ3JpZC5iZWhhdmlvci5nZXRSb3dQcm9wZXJ0aWVzKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd1Byb3BzICYmIHJvd1Byb3BzLmhlYWRlclJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IGdyaWQuZ2V0Um93KDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZC5nZXRDb2x1bW5zKCkuZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMuY29sRGVmICYmIHJvd1tjLm5hbWVdICE9PSBjLmNvbERlZi5oZWFkZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dbYy5uYW1lXSA9IGMuY29sRGVmLmhlYWRlck5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRJbnRlcm5hbEV2ZW50TGlzdGVuZXIoJ2Zpbi1ncmlkLWRhdGEtYWRkZWQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBncmlkLmRlbGVnYXRlR3JpZERhdGFBZGRlZChlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgRGVsZWdhdGUgdGhlIHdoZWVsIG1vdmVkIGV2ZW50IHRvIHRoZSBiZWhhdmlvci5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBwZXJ0aW5lbnQgZXZlbnQuXG4gICAgICovXG4gICAgZGVsZWdhdGVXaGVlbE1vdmVkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLm9uV2hlZWxNb3ZlZCh0aGlzLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgRGVsZWdhdGUgTW91c2VFeGl0IHRvIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIHBlcnRpbmVudCBldmVudC5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZU1vdXNlRXhpdDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5oYW5kbGVNb3VzZUV4aXQodGhpcywgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIERlbGVnYXRlIE1vdXNlRXhpdCB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBwZXJ0aW5lbnQgZXZlbnQuXG4gICAgICovXG4gICAgZGVsZWdhdGVDb250ZXh0TWVudTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbkNvbnRleHRNZW51KHRoaXMsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBHcmlkUmVuZGVyZWQgdG8gdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgcGVydGluZW50IGV2ZW50LlxuICAgICAqL1xuICAgIGRlbGVnYXRlR3JpZFJlbmRlcmVkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLm9uR3JpZFJlbmRlcmVkKHRoaXMsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVDb2x1bW5SZXNpemVkRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iub25Db2x1bW5SZXNpemVkRXZlbnQodGhpcywgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIERlbGVnYXRlIE1vdXNlTW92ZSB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge21vdXNlRGV0YWlsc30gbW91c2VEZXRhaWxzIC0gQW4gZW5yaWNoZWQgbW91c2UgZXZlbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqL1xuICAgIGRlbGVnYXRlTW91c2VNb3ZlOiBmdW5jdGlvbihtb3VzZURldGFpbHMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbk1vdXNlTW92ZSh0aGlzLCBtb3VzZURldGFpbHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIERlbGVnYXRlIG1vdXNlZG93biB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge21vdXNlRGV0YWlsc30gbW91c2VEZXRhaWxzIC0gQW4gZW5yaWNoZWQgbW91c2UgZXZlbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqL1xuICAgIGRlbGVnYXRlTW91c2VEb3duOiBmdW5jdGlvbihtb3VzZURldGFpbHMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5oYW5kbGVNb3VzZURvd24odGhpcywgbW91c2VEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBtb3VzZWRvd24gdG8gdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHttb3VzZURldGFpbHN9IG1vdXNlRGV0YWlscyAtIEFuIGVucmljaGVkIG1vdXNlIGV2ZW50IGZyb20gZmluLWNhbnZhcy5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZUNhbnZhc091dHNpZGVNb3VzZWRvd246IGZ1bmN0aW9uKG1vdXNlRGV0YWlscykge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmhhbmRsZUNhbnZhc091dHNpZGVNb3VzZURvd24odGhpcywgbW91c2VEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBtb3VzZXVwIHRvIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7bW91c2VEZXRhaWxzfSBtb3VzZURldGFpbHMgLSBBbiBlbnJpY2hlZCBtb3VzZSBldmVudCBmcm9tIGZpbi1jYW52YXMuXG4gICAgICovXG4gICAgZGVsZWdhdGVNb3VzZVVwOiBmdW5jdGlvbihtb3VzZURldGFpbHMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbk1vdXNlVXAodGhpcywgbW91c2VEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBjbGljayB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge21vdXNlRGV0YWlsc30gbW91c2VEZXRhaWxzIC0gQW4gZW5yaWNoZWQgbW91c2UgZXZlbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqL1xuICAgIGRlbGVnYXRlQ2xpY2s6IGZ1bmN0aW9uKG1vdXNlRGV0YWlscykge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLm9uQ2xpY2sodGhpcywgbW91c2VEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBtb3VzZURyYWcgdG8gdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHttb3VzZURldGFpbHN9IG1vdXNlRGV0YWlscyAtIEFuIGVucmljaGVkIG1vdXNlIGV2ZW50IGZyb20gZmluLWNhbnZhcy5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZU1vdXNlRHJhZzogZnVuY3Rpb24obW91c2VEZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iub25Nb3VzZURyYWcodGhpcywgbW91c2VEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBXZSd2ZSBiZWVuIGRvdWJsZWNsaWNrZWQgb24uIERlbGVnYXRlIHRocm91Z2ggdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHttb3VzZURldGFpbHN9IG1vdXNlRGV0YWlscyAtIEFuIGVucmljaGVkIG1vdXNlIGV2ZW50IGZyb20gZmluLWNhbnZhcy5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZURvdWJsZUNsaWNrOiBmdW5jdGlvbihtb3VzZURldGFpbHMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbkRvdWJsZUNsaWNrKHRoaXMsIG1vdXNlRGV0YWlscyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHN1bW1hcnkgR2VuZXJhdGUgYSBmdW5jdGlvbiBuYW1lIGFuZCBjYWxsIGl0IG9uIHNlbGYuXG4gICAgICogQGRlc2MgVGhpcyBzaG91bGQgYWxzbyBiZSBkZWxlZ2F0ZWQgdGhyb3VnaCBCZWhhdmlvciBrZWVwaW5nIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGhlcmUgdGhvdWdoLlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGV2ZW50IC0gVGhlIHBlcnRpbmVudCBldmVudC5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZUtleURvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iub25LZXlEb3duKHRoaXMsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAc3VtbWFyeSBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG5hbWUgYW5kIGNhbGwgaXQgb24gc2VsZi5cbiAgICAgKiBAZGVzYyBUaGlzIHNob3VsZCBhbHNvIGJlIGRlbGVnYXRlZCB0aHJvdWdoIEJlaGF2aW9yIGtlZXBpbmcgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaGVyZSB0aG91Z2guXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgcGVydGluZW50IGV2ZW50LlxuICAgICAqL1xuICAgIGRlbGVnYXRlQXBpRGVzdHJveUNhbGxlZDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbkFwaURlc3Ryb3lDYWxsZWQodGhpcywgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IEdlbmVyYXRlIGEgZnVuY3Rpb24gbmFtZSBhbmQgY2FsbCBpdCBvbiBzZWxmLlxuICAgICAqIEBkZXNjIFRoaXMgc2hvdWxkIGFsc28gYmUgZGVsZWdhdGVkIHRocm91Z2ggQmVoYXZpb3Iga2VlcGluZyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBoZXJlIHRob3VnaC5cbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBldmVudCAtIFRoZSBwZXJ0aW5lbnQgZXZlbnQuXG4gICAgICovXG4gICAgZGVsZWdhdGVLZXlVcDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbktleVVwKHRoaXMsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAc3VtbWFyeSBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG5hbWUgYW5kIGNhbGwgaXQgb24gc2VsZi5cbiAgICAgKiBAZGVzYyBUaGlzIHNob3VsZCBhbHNvIGJlIGRlbGVnYXRlZCB0aHJvdWdoIEJlaGF2aW9yIGtlZXBpbmcgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaGVyZSB0aG91Z2guXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgcGVydGluZW50IGV2ZW50LlxuICAgICAqL1xuICAgIGRlbGVnYXRlR3JpZERhdGFBZGRlZDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbkRhdGFBZGRlZCh0aGlzLCBldmVudCk7XG4gICAgfVxufTtcblxudmFyIGRldGFpbHMgPSBbXG4gICAgJ2dyaWRDZWxsJyxcbiAgICAnZGF0YUNlbGwnLFxuICAgICdtb3VzZVBvaW50JyxcbiAgICAna2V5cycsXG4gICAgJ3Jvdydcbl07XG5cbi8qKlxuICogQHRoaXMge0h5cGVyZ3JpZH1cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NhbmNlbGFibGU9ZmFsc2VdXG4gKiBAcGFyYW0ge29iamVjdH0gZXZlbnRcbiAqIEBwYXJhbSB7Q2VsbEV2ZW50fE1vdXNlRXZlbnR8S2V5Ym9hcmRFdmVudHxvYmplY3R9IFtwcmltaXRpdmVFdmVudF1cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChldmVudE5hbWUsIGNhbmNlbGFibGUsIGV2ZW50LCBwcmltaXRpdmVFdmVudCkge1xuICAgIHZhciBkZXRhaWwsIHJlc3VsdDtcblxuICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2FuY2VsYWJsZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHByaW1pdGl2ZUV2ZW50ID0gZXZlbnQ7IC8vIHByb3Btb3RlIHByaW1pdGl2ZUV2ZW50IHRvIDNyZCBwb3NpdGlvblxuICAgICAgICBldmVudCA9IGNhbmNlbGFibGU7IC8vIHByb21vdGUgZXZlbnQgdG8gMm5kIHBvc2l0aW9uXG4gICAgICAgIGNhbmNlbGFibGUgPSBmYWxzZTsgLy8gZGVmYXVsdCB3aGVuIG9taXR0ZWRcbiAgICB9XG5cbiAgICBpZiAoIWV2ZW50LmRldGFpbCkge1xuICAgICAgICBldmVudCA9IHsgZGV0YWlsOiBldmVudCB9O1xuICAgIH1cblxuICAgIGRldGFpbCA9IGV2ZW50LmRldGFpbDtcblxuICAgIGlmICghZGV0YWlsLmdyaWQpIHsgLy8gQ2VsbEV2ZW50IG9iamVjdHMgYWxyZWFkeSBoYXZlIGEgKHJlYWQtb25seSkgYGdyaWRgIHByb3BcbiAgICAgICAgZGV0YWlsLmdyaWQgPSB0aGlzO1xuICAgIH1cblxuICAgIGRldGFpbC50aW1lID0gRGF0ZS5ub3coKTtcblxuICAgIGlmIChwcmltaXRpdmVFdmVudCkge1xuICAgICAgICBpZiAoIWRldGFpbC5wcmltaXRpdmVFdmVudCkge1xuICAgICAgICAgICAgZGV0YWlsLnByaW1pdGl2ZUV2ZW50ID0gcHJpbWl0aXZlRXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWlscy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSBpbiBwcmltaXRpdmVFdmVudCAmJiAhKGtleSBpbiBkZXRhaWwpKSB7XG4gICAgICAgICAgICAgICAgZGV0YWlsW2tleV0gPSBwcmltaXRpdmVFdmVudFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCdkYXRhUm93JyBpbiBwcmltaXRpdmVFdmVudCkge1xuICAgICAgICAgICAgLy8gcmVmZXJlbmNlICh3aXRob3V0IGludm9raW5nKSBjZWxsRXZlbnQncyBgZGF0YVJvd2AgZ2V0dGVyIHdoZW4gYXZhaWxhYmxlXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGV0YWlsLCAncm93JywgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gcHJpbWl0aXZlRXZlbnQuZGF0YVJvdzsgfSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjYW5jZWxhYmxlKSB7XG4gICAgICAgIGV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgZXZlbnQpKTtcblxuICAgIHJldHVybiAhY2FuY2VsYWJsZSB8fCByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG1peGluOiBtaXhpbixcbiAgICBkaXNwYXRjaEV2ZW50OiBkaXNwYXRjaEV2ZW50XG59O1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vbGliL3BvbHlmaWxscycpOyAvLyBJbnN0YWxscyBtaXNjLiBwb2x5ZmlsbHMgaW50byBnbG9iYWwgb2JqZWN0cywgYXMgbmVlZGVkXG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3JlY3Rhbmd1bGFyJykuUG9pbnQ7XG52YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgncmVjdGFuZ3VsYXInKS5SZWN0YW5nbGU7XG52YXIgXyA9IHJlcXVpcmUoJ29iamVjdC1pdGVyYXRvcnMnKTsgLy8gZnlpOiBpbnN0YWxscyB0aGUgQXJyYXkucHJvdG90eXBlLmZpbmQgcG9seWZpbGwsIGFzIG5lZWRlZFxudmFyIGluamVjdENTUyA9IHJlcXVpcmUoJ2luamVjdC1zdHlsZXNoZWV0LXRlbXBsYXRlJykuYmluZChyZXF1aXJlKCcuLi8uLi9jc3MnKSk7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi4vQmFzZScpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcbnZhciBkeW5hbWljUHJvcGVydHlEZXNjcmlwdG9ycyA9IHJlcXVpcmUoJy4uL2xpYi9keW5hbWljUHJvcGVydGllcycpO1xudmFyIENhbnZhcyA9IHJlcXVpcmUoJy4uL2xpYi9DYW52YXMnKTtcbnZhciBSZW5kZXJlciA9IHJlcXVpcmUoJy4uL3JlbmRlcmVyJyk7XG52YXIgU2VsZWN0aW9uTW9kZWwgPSByZXF1aXJlKCcuLi9saWIvU2VsZWN0aW9uTW9kZWwnKTtcbnZhciBMb2NhbGl6YXRpb24gPSByZXF1aXJlKCcuLi9saWIvTG9jYWxpemF0aW9uJyk7XG52YXIgQmVoYXZpb3IgPSByZXF1aXJlKCcuLi9iZWhhdmlvcnMvQmVoYXZpb3InKTtcbnZhciBiZWhhdmlvckpTT04gPSByZXF1aXJlKCcuLi9iZWhhdmlvcnMvTG9jYWwnKTtcbnZhciBjZWxsUmVuZGVyZXJzID0gcmVxdWlyZSgnLi4vY2VsbFJlbmRlcmVycycpO1xudmFyIGNlbGxFZGl0b3JzID0gcmVxdWlyZSgnLi4vY2VsbEVkaXRvcnMnKTtcbnZhciBtb2R1bGVzID0gcmVxdWlyZSgnLi9tb2R1bGVzJyk7XG5cbnZhciBFREdFX1NUWUxFUyA9IFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0J10sXG4gICAgUkVDVF9TVFlMRVMgPSBFREdFX1NUWUxFUy5jb25jYXQoWyd3aWR0aCcsICdoZWlnaHQnLCAncG9zaXRpb24nXSk7XG5cbi8qKlxuICogQG1peGVzIHNjcm9sbGluZy5taXhpblxuICogQG1peGVzIGV2ZW50cy5taXhpblxuICogQG1peGVzIHNlbGVjdGlvbi5taXhpblxuICogQG1peGVzIHRoZW1lcy5pbnN0YW5jZU1peGluXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfEVsZW1lbnR9IFtjb250YWluZXJdIC0gQ1NTIHNlbGVjdG9yIG9yIEVsZW1lbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBJZiBgb3B0aW9ucy5kYXRhYCBwcm92aWRlZCwgcGFzc2VkIHRvIHtAbGluayBIeXBlcmdyaWQjc2V0RGF0YSBzZXREYXRhfTsgZWxzZSBpZiBgb3B0aW9ucy5CZWhhdmlvcmAgcHJvdmlkZWQsIHBhc3NlZCB0byB7QGxpbmsgSHlwZXJncmlkI3NldEJlaGF2aW9yIHNldEJlaGF2aW9yfS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLkJlaGF2aW9yPUxvY2FsXSAtIF9QZXIge0BsaW5rIEJlaGF2aW9yI3NldERhdGF9Ll9cbiAqIEBwYXJhbSB7ZGF0YU1vZGVsQVBJfSBbb3B0aW9ucy5kYXRhTW9kZWxdIC0gX1Bhc3NlZCB0byBiZWhhdmlvciB7QGxpbmsgQmVoYXZpb3IgY29uc3RydWN0b3J9Ll9cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLkRhdGFNb2RlbD1yZXF1aXJlKCdkYXRhc2F1ci1sb2NhbCcpXSAtIF9QYXNzZWQgdG8gYmVoYXZpb3Ige0BsaW5rIEJlaGF2aW9yIGNvbnN0cnVjdG9yfS5fXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufG9iamVjdFtdfSBbb3B0aW9ucy5kYXRhXSAtIF9QYXNzZWQgdG8gYmVoYXZpb3Ige0BsaW5rIEJlaGF2aW9yIGNvbnN0cnVjdG9yfS5fXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufG1lbnVJdGVtW119IFtvcHRpb25zLnNjaGVtYV0gLSBfUGFzc2VkIHRvIGJlaGF2aW9yIHtAbGluayBCZWhhdmlvciBjb25zdHJ1Y3Rvcn0uX1xuICogQHBhcmFtIHtkYXRhTW9kZWxBUEl9IFtvcHRpb25zLm1ldGFkYXRhXSAtIF9QYXNzZWQgdG8gYmVoYXZpb3Ige0BsaW5rIEJlaGF2aW9yIGNvbnN0cnVjdG9yfS5fXG4gKiAqIEEgc2NoZW1hIGFycmF5XG4gKiBAcGFyYW0ge3N1YmdyaWRTcGVjW119IFtvcHRpb25zLnN1YmdyaWRzPXRoaXMucHJvcGVydGllcy5zdWJncmlkc10gLSBfUGVyIHtAbGluayBCZWhhdmlvciNzZXREYXRhfS5fXG4gKlxuICogQHBhcmFtIHtwbHVnaW5TcGVjfHBsdWdpblNwZWNbXX0gW29wdGlvbnMucGx1Z2luc11cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuc3RhdGVdXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8RWxlbWVudH0gW29wdGlvbnMuY29udGFpbmVyXSAtIENTUyBzZWxlY3RvciBvciBFbGVtZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsaXphdGlvbj1IeXBlcmdyaWQubG9jYWxpemF0aW9uXVxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFtvcHRpb25zLmxvY2FsaXphdGlvbi5sb2NhbGU9SHlwZXJncmlkLmxvY2FsaXphdGlvbi5sb2NhbGVdIC0gVGhlIGRlZmF1bHQgbG9jYWxlIHRvIHVzZSB3aGVuIGFuIGV4cGxpY2l0IGBsb2NhbGVgIGlzIG9taXR0ZWQgZnJvbSBsb2NhbGl6ZXIgY29uc3RydWN0b3IgY2FsbHMuIFBhc3NlZCB0byBJbnRsLk51bWJlckZvbXJhdGAgYW5kIGBJbnRsLkRhdGVGb21yYXRgLiBTZWUge0AgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSW50bCNMb2NhbGVfaWRlbnRpZmljYXRpb25fYW5kX25lZ290aWF0aW9ufExvY2FsZSBpZGVudGlmaWNhdGlvbiBhbmQgbmVnb3RpYXRpb259IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsaXphdGlvbi5udW1iZXJPcHRpb25zPUh5cGVyZ3JpZC5sb2NhbGl6YXRpb24ubnVtYmVyT3B0aW9uc10gLSBPcHRpb25zIHBhc3NlZCB0byBgSW50bC5OdW1iZXJGb3JtYXRgIGZvciBjcmVhdGluZyB0aGUgYmFzaWMgXCJudW1iZXJcIiBsb2NhbGl6ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubG9jYWxpemF0aW9uLmRhdGVPcHRpb25zPUh5cGVyZ3JpZC5sb2NhbGl6YXRpb24uZGF0ZU9wdGlvbnNdIC0gT3B0aW9ucyBwYXNzZWQgdG8gYEludGwuRGF0ZUZvbXJhdGAgZm9yIGNyZWF0aW5nIHRoZSBiYXNpYyBcImRhdGVcIiBsb2NhbGl6ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLm1hcmdpbl0gLSBPcHRpb25hbCBjYW52YXMgXCJtYXJnaW5zXCIgYXBwbGllZCB0byBjb250YWluaW5nIGRpdiBhcyAubGVmdCwgLnRvcCwgLnJpZ2h0LCAuYm90dG9tLiAoRGVmYXVsdCB2YWx1ZXMgYWN0dWFsbHkgZGVyaXZlIGZyb20gJ2dyaWQnIHN0eWxlc2hlZXQncyBgLmh5cGVyZ3JpZC1jb250YWluZXJgIHJ1bGUuKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1hcmdpbi50b3A9JzBweCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWFyZ2luLnJpZ2h0PScwcHgnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1hcmdpbi5ib3R0b209JzBweCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWFyZ2luLmxlZnQ9JzBweCddXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmJvdW5kaW5nUmVjdF0gLSBPcHRpb25hbCBncmlkIGNvbnRhaW5lciBzaXplICYgcG9zaXRpb24uIChEZWZhdWx0IHZhbHVlcyBhY3R1YWxseSBkZXJpdmUgZnJvbSAnZ3JpZCcgc3R5bGVzaGVldCdzIGAuaHlwZXJncmlkLWNvbnRhaW5lciA+IGRpdjpmaXJzdC1jaGlsZGAgcnVsZS4pXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYm91bmRpbmdSZWN0LmhlaWdodD0nNTAwcHgnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmJvdW5kaW5nUmVjdC53aWR0aD0nYXV0byddXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYm91bmRpbmdSZWN0LmxlZnQ9J2F1dG8nXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmJvdW5kaW5nUmVjdC50b3A9J2F1dG8nXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmJvdW5kaW5nUmVjdC5yaWdodD0nYXV0byddXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYm91bmRpbmdSZWN0LmJvdHRvbT0nYXV0byddXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYm91bmRpbmdSZWN0LnBvc2l0aW9uPSdyZWxhdGl2ZSddXG4gKi9cbnZhciBIeXBlcmdyaWQgPSBCYXNlLmV4dGVuZCgnSHlwZXJncmlkJywge1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkluaXRpYWxpemUoKTtcblxuICAgICAgICAvL09wdGlvbmFsIGNvbnRhaW5lciBhcmd1bWVudFxuICAgICAgICBpZiAoISh0eXBlb2YgY29udGFpbmVyID09PSAnc3RyaW5nJykgJiYgIShjb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBjb250YWluZXI7XG4gICAgICAgICAgICBjb250YWluZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdGhpcy5jbGVhclN0YXRlKCk7XG5cbiAgICAgICAgLy9TZXQgdXAgdGhlIGNvbnRhaW5lciBmb3IgYSBncmlkIGluc3RhbmNlXG4gICAgICAgIHRoaXMuc2V0Q29udGFpbmVyKFxuICAgICAgICAgICAgY29udGFpbmVyIHx8XG4gICAgICAgICAgICBvcHRpb25zLmNvbnRhaW5lciB8fFxuICAgICAgICAgICAgZmluZE9yQ3JlYXRlQ29udGFpbmVyKG9wdGlvbnMuYm91bmRpbmdSZWN0KVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEluc3RhbGwgc2hhcmVkIHBsdWctaW5zICh0aG9zZSB3aXRoIGEgYHByZWluc3RhbGxgIG1ldGhvZClcbiAgICAgICAgSHlwZXJncmlkLnByb3RvdHlwZS5pbnN0YWxsUGx1Z2lucyhvcHRpb25zLnBsdWdpbnMpO1xuXG4gICAgICAgIHRoaXMubGFzdEVkZ2VTZWxlY3Rpb24gPSBbMCwgMF07XG4gICAgICAgIHRoaXMuaXNXZWJraXQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignd2Via2l0JykgPiAtMTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwucmVzZXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwgPSBuZXcgU2VsZWN0aW9uTW9kZWwodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbmRlck92ZXJyaWRlc0NhY2hlID0ge307XG4gICAgICAgIHRoaXMuYWxsb3dFdmVudEhhbmRsZXJzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kcmFnRXh0ZW50ID0gbmV3IFBvaW50KDAsIDApO1xuICAgICAgICB0aGlzLm51bVJvd3MgPSAwO1xuICAgICAgICB0aGlzLm51bUNvbHVtbnMgPSAwO1xuICAgICAgICB0aGlzLmNsZWFyTW91c2VEb3duKCk7XG4gICAgICAgIHRoaXMuc2V0Rm9ybWF0dGVyKG9wdGlvbnMubG9jYWxpemF0aW9uKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgY2VsbFJlbmRlcmVyc1xuICAgICAgICAgKiBAdHlwZSB7UmVnaXN0cnl9XG4gICAgICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNlbGxSZW5kZXJlcnMgPSBjZWxsUmVuZGVyZXJzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcml2YXRlIHZlcnNpb24gb2YgY2VsbCBlZGl0b3JzIHJlZ2lzdHJ5IHdpdGggYSBib3VuZCBgY3JlYXRlYCBtZXRob2QgZm9yIHVzZSBieSBgZ2V0Q2VsbEVkaXRvckF0YC5cbiAgICAgICAgICogQG5hbWUgY2VsbEVkaXRvcnNcbiAgICAgICAgICogQHR5cGUge1JlZ2lzdHJ5fVxuICAgICAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jZWxsRWRpdG9ycyA9IE9iamVjdC5jcmVhdGUoY2VsbEVkaXRvcnMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5jZWxsRWRpdG9ycywgJ2NyZWF0ZScsIHsgdmFsdWU6IGNyZWF0ZUNlbGxFZGl0b3IuYmluZCh0aGlzKSB9KTtcblxuICAgICAgICB0aGlzLmluaXRDYW52YXMob3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5zZXREYXRhKG9wdGlvbnMuZGF0YSwgb3B0aW9ucyk7IC8vIGlmIG5vIGJlaGF2aW9yIGhhcyB5ZXQgYmVlbiBzZXQsIGBzZXREYXRhYCBzZXRzIGEgZGVmYXVsdCBiZWhhdmlvclxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYmVoYXZpb3VyIHNob3VsZCBiZVxuICAgICAgICAgICAgaWYgKCF0aGlzLmJlaGF2aW9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRCZWhhdmlvcihvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5pdFNjcm9sbGJhcnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRTdGF0ZShvcHRpb25zLnN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnRoZW1lKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5VGhlbWUob3B0aW9ucy50aGVtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgYXBpXG4gICAgICAgICAqIEBzdW1tYXJ5IGFwaSBmb3IgdXNpbmcgd2l0aCBkYXRhZG9jcyBsaWtlIGFnLWdyaWRcbiAgICAgICAgICogQGRlc2Mgc2V0IG9mIG1ldGhvZHMgd2hpY2ggd2FzIHVzZWQgaW4gYWctZ3JpZFxuICAgICAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAgICAgKi9cbiAgICAgICAgLy8gY3JlYXRlIGFwaVxuICAgICAgICB0aGlzLmFwaSA9IG9wdGlvbnMuYXBpIHx8IHt9O1xuICAgICAgICB0aGlzLmNvbHVtbkFwaSA9IG9wdGlvbnMuY29sdW1uQXBpIHx8IHt9O1xuICAgICAgICAvLyBtZXJnZSBhcGkgbWl4aW5zXG4gICAgICAgIHZhciBiaW5kQWxsRnVuY3Rpb25zID0gZnVuY3Rpb24oZnJvbSwgdG8sIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gZnJvbSkge1xuICAgICAgICAgICAgICAgIGlmIChmcm9tLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZnJvbVtrXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9ba10gPSBmcm9tW2tdLmJpbmQoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZyb20gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9tW2tdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvW2tdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvW2tdID0gZnJvbVtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kQWxsRnVuY3Rpb25zKHRvW2tdLCBmcm9tW2tdLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBiaW5kQWxsRnVuY3Rpb25zKHJlcXVpcmUoJy4vYXBpJyksIHRoaXMuYXBpLCB0aGlzKTtcbiAgICAgICAgYmluZEFsbEZ1bmN0aW9ucyhyZXF1aXJlKCcuL2NvbHVtbkFwaScpLCB0aGlzLmNvbHVtbkFwaSwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5jb2x1bW5EZWZzID0gb3B0aW9ucy5jb2x1bW5EZWZzIHx8IFtdO1xuICAgICAgICB0aGlzLnZpc2libGVDb2x1bW5EZWZzID0gdGhpcy5jb2x1bW5EZWZzLmZpbHRlcigoY2QpID0+ICFjZC5pc0hpZGRlbik7XG4gICAgICAgIHRoaXMuZGF0YSA9IG9wdGlvbnMuZGF0YSB8fCBbXTtcbiAgICAgICAgdGhpcy5yb3dEYXRhID0gb3B0aW9ucy5yb3dEYXRhIHx8IFtdO1xuICAgICAgICB0aGlzLnBhZ2luYXRpb25QYWdlU2l6ZSA9IG9wdGlvbnMucGFnaW5hdGlvblBhZ2VTaXplIHx8IHRoaXMucGFnaW5hdGlvblBhZ2VTaXplIHx8IDEwMDA7XG5cbiAgICAgICAgWyAvLyByZXVzZSBmdW5jdGlvbnNcbiAgICAgICAgICAgICdvbkNvbHVtblJlc2l6ZWQnLFxuICAgICAgICAgICAgJ29uVXBkYXRlQ29sdW1uTmFtZScsXG4gICAgICAgICAgICAnb25Db2x1bW5zTW92ZWQnLFxuICAgICAgICAgICAgJ2dldE1haW5NZW51SXRlbXMnLFxuICAgICAgICAgICAgJ2dldENvbnRleHRNZW51SXRlbXMnLFxuICAgICAgICAgICAgJ29uQWdncmVnYXRlZENlbGxDbGljaycsXG4gICAgICAgICAgICAnb25DdHJsQW5kWicsXG4gICAgICAgICAgICAnb25DdHJsU2hpZnRBbmRaJyxcbiAgICAgICAgICAgICdsb2dFbmFibGUnLFxuICAgICAgICBdLmZvckVhY2goayA9PiB7XG4gICAgICAgICAgICB0aGlzW2tdID0gb3B0aW9uc1trXSB8fCB0aGlzW2tdO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5vbkNvbHVtbnNNb3ZlZCkge1xuICAgICAgICAgICAgdGhpcy5hZGRJbnRlcm5hbEV2ZW50TGlzdGVuZXIoJ2Zpbi1jb2x1bW5zLW1vdmVkJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29sdW1uc01vdmVkKGUuZGV0YWlsLmNvbHVtbnMsIGUuZGV0YWlsLnRvSW5kZXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgcGx1Z2luc1xuICAgICAgICAgKiBAc3VtbWFyeSBEaWN0aW9uYXJ5IG9mIG5hbWVkIGluc3RhbmNlIHBsdWctaW5zLlxuICAgICAgICAgKiBAZGVzYyBTZWUgZXhhbXBsZXMgZm9yIGhvdyB0byByZWZlcmVuY2UgKGFsYmVpdCB0aGVyZSBpcyBub3JtYWxseSBubyBuZWVkIHRvIHJlZmVyZW5jZSBwbHVnaW5zIGRpcmVjdGx5KS5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIHRoZSBkaWN0aW9uYXJ5IG9mIF9zaGFyZWRfIHBsdWdpbnMsIHNlZSB7QGxpbmsgSHlwZXJncmlkLnBsdWdpbnN8cGx1Z2luc30gKGEgcHJvcGVydHkgb2YgdGhlIGNvbnN0cnVjdG9yKS5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogdmFyIGluc3RhbmNlUGx1Z2lucyA9IG15R3JpZC5wbHVnaW5zO1xuICAgICAgICAgKiB2YXIgaW5zdGFuY2VQbHVnaW5zID0gdGhpcy5wbHVnaW5zOyAvLyBpbnRlcm5hbCB1c2VcbiAgICAgICAgICogdmFyIG15SW5zdGFuY2VQbHVnaW4gPSBteUdyaWQucGx1Z2lucy5teUluc3RhbmNlUGx1Z2luO1xuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wbHVnaW5zID0ge307XG5cbiAgICAgICAgLy8gSW5zdGFsbCBpbnN0YW5jZSBwbHVnLWlucyAodGhvc2UgdGhhdCBhcmUgY29uc3RydWN0b3JzIE9SIGhhdmUgYW4gYGluc3RhbGxgIG1ldGhvZClcbiAgICAgICAgdGhpcy5pbnN0YWxsUGx1Z2lucyhvcHRpb25zLnBsdWdpbnMpO1xuXG4gICAgICAgIC8vIExpc3RlbiBmb3IgcHJvcGFnYXRlZCBtb3VzZWNsaWNrcy4gVXNlZCBmb3IgYWJvcnRpbmcgZWRpdCBtb2RlLlxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlQ2F0Y2hlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5hYm9ydEVkaXRpbmcoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICBzZXRUaW1lb3V0KHRoaXMucmVwYWludC5iaW5kKHRoaXMpKTtcblxuICAgICAgICBIeXBlcmdyaWQuZ3JpZHMucHVzaCh0aGlzKTtcblxuICAgICAgICB0aGlzLnJlc2V0R3JpZEJvcmRlcignVG9wJyk7XG4gICAgICAgIHRoaXMucmVzZXRHcmlkQm9yZGVyKCdSaWdodCcpO1xuICAgICAgICB0aGlzLnJlc2V0R3JpZEJvcmRlcignQm90dG9tJyk7XG4gICAgICAgIHRoaXMucmVzZXRHcmlkQm9yZGVyKCdMZWZ0Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJlIGEgcmVzcG9uc2libGUgY2l0aXplbiBhbmQgY2FsbCB0aGlzIGZ1bmN0aW9uIG9uIGluc3RhbmNlIGRpc3Bvc2FsIVxuICAgICAqL1xuICAgIHRlcm1pbmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubW91c2VDYXRjaGVyKTtcbiAgICAgICAgdGhpcy5jYW52YXMuc3RvcCgpO1xuICAgICAgICBpZiAodGhpcy5ncmlkcykge1xuICAgICAgICAgICAgSHlwZXJncmlkLmdyaWRzLnNwbGljZSh0aGlzLmdyaWRzLmluZGV4T2YodGhpcyksIDEpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qXG4gICAgKiBjaGVjayBpZiBncmlkIGFsaXZlXG4gICAgICovXG4gICAgaXNBbGl2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIGRpdiBzdGlsbCBpbiBET01cbiAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRoaXMuZGl2KSkge1xuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIHRoaXMuZGl2ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICByZXNldEdyaWRCb3JkZXI6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgICAgZWRnZSA9IGVkZ2UgfHwgJyc7XG5cbiAgICAgICAgdmFyIHByb3BOYW1lID0gJ2dyaWRCb3JkZXInICsgZWRnZSxcbiAgICAgICAgICAgIHN0eWxlTmFtZSA9ICdib3JkZXInICsgZWRnZSxcbiAgICAgICAgICAgIHByb3BzID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgYm9yZGVyID0gcHJvcHNbcHJvcE5hbWVdO1xuXG4gICAgICAgIHN3aXRjaCAoYm9yZGVyKSB7XG4gICAgICAgICAgICBjYXNlIHRydWU6XG4gICAgICAgICAgICAgICAgYm9yZGVyID0gcHJvcHMubGluZVdpZHRoICsgJ3B4IHNvbGlkICcgKyBwcm9wcy5saW5lQ29sb3I7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGZhbHNlOlxuICAgICAgICAgICAgICAgIGJvcmRlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW52YXMuY2FudmFzLnN0eWxlW3N0eWxlTmFtZV0gPSBib3JkZXI7XG4gICAgfSxcblxuICAgIG1vZHVsZXM6IG1vZHVsZXMsIC8vIE11dGF0ZSBvciByZXBsYWNlIHByb3RvdHlwZSBwcm9wIHRvIGFmZmVjdCBhbGwgZ3JpZCBpbnN0YW5jZXM7IHNldCBpbnN0YW5jZSBwcm9wIHRvIGFmZmVjdCBqdXN0IGluc3RhbmNlLlxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIG51bGwgb2JqZWN0IGJlaGF2aW9yIHNlcnZlcyBhcyBhIHBsYWNlIGhvbGRlci5cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgYmVoYXZpb3I6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgcmVzdWxhbn1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIGlzV2Via2l0OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHBpeGVsIGxvY2F0aW9uIG9mIGFuIGluaXRpYWwgbW91c2Vkb3duIGNsaWNrLCBlaXRoZXIgZm9yIGVkaXRpbmcgYSBjZWxsIG9yIGZvciBkcmFnZ2luZyBhIHNlbGVjdGlvbi5cbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBtb3VzZURvd246IFtdLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGV4dGVudCBmcm9tIHRoZSBtb3VzZWRvd24gcG9pbnQgZHVyaW5nIGEgZHJhZyBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG5cbiAgICBkcmFnRXh0ZW50OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtmaW4taHlwZXJncmlkLXNlbGVjdGlvbi1tb2RlbH0gc2VsZWN0aW9uTW9kZWwgLSBBIFtmaW4taHlwZXJncmlkLXNlbGVjdGlvbi1tb2RlbF0obW9kdWxlLS5fc2VsZWN0aW9uLW1vZGVsLmh0bWwpIGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgc2VsZWN0aW9uTW9kZWw6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2Zpbi1oeXBlcmdyaWQtY2VsbC1lZGl0b3J9IGNlbGxFZGl0b3IgLSBUaGUgY3VycmVudCBpbnN0YW5jZSBvZiBbZmluLWh5cGVyZ3JpZC1jZWxsLWVkaXRvcl0obW9kdWxlLWNlbGwtZWRpdG9yc19iYXNlLmh0bWwpLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgY2VsbEVkaXRvcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7ZmluLXZhbXBpcmUtYmFyfSBzYkhTY3JvbGxlciAtIEFuIGluc3RhbmNlIG9mIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vb3BlbmZpbi9maW5iYXJzfEZpbkJhcn0uXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBzYkhTY3JvbGxlcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGlzIHRoZSBzaG9ydCB0ZXJtIG1lbW9yeSBvZiB3aGF0IGNvbHVtbiBJIG1pZ2h0IGJlIGRyYWdnaW5nIGFyb3VuZFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cblxuICAgIHJlbmRlck92ZXJyaWRlc0NhY2hlOiB7fSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgY3VycmVudCBob3ZlcmVkIGNlbGwuXG4gICAgICogQHRvZG8gTmVlZCB0byBkZXRlY3QgaG92ZXJpbmcgb3ZlciBib3R0b20gdG90YWxzLlxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIGhvdmVyQ2VsbDogbnVsbCxcblxuICAgIGxhc3RFZGdlU2VsZWN0aW9uOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBzZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uKGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIGNsZWFyU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgcHJvcGVydGllc1xuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAc3VtbWFyeSBPYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ3JpZC5cbiAgICAgICAgICogQGRlc2MgR3JpZCBwcm9wZXJ0aWVzIG9iamVjdHMgaGF2ZSB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbiAgICAgICAgICogMS4gVXNlci1jb25maWd1cmVkIHByb3BlcnRpZXMgYW5kIGR5bmFtaWMgcHJvcGVydGllcyBhcmUgaW4gdGhlIFwib3duXCIgbGF5ZXIuXG4gICAgICAgICAqIDIuIEV4dGVuZHMgZnJvbSB0aGUgdGhlbWUgb2JqZWN0LlxuICAgICAgICAgKiAzLiBUaGUgdGhlbWUgb2JqZWN0IGluIHR1cm4gZXh0ZW5kcyBmcm9tIHRoZSB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzfGRlZmF1bHRzfSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGU6IEFueSBjaGFuZ2VzIHRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgbWF5IHdpc2ggdG8gbWFrZSB0byB0aGUge0BsaW5rIG1vZHVsZTpkZWZhdWx0c3xkZWZhdWx0c31cbiAgICAgICAgICogb2JqZWN0IHNob3VsZCBiZSBtYWRlIF9iZWZvcmVfIHJlYWNoaW5nIHRoaXMgcG9pbnQgKF9pLmUuLF8gcHJpb3IgdG8gYW55IGdyaWQgaW5zdGFudGlhdGlvbnMpLlxuICAgICAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcy5pbml0VGhlbWVMYXllcigpLCB7XG4gICAgICAgICAgICBncmlkOiB7IHZhbHVlOiB0aGlzIH0sXG4gICAgICAgICAgICB2YXI6IHsgdmFsdWU6IG5ldyBWYXIoKSB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZvciBhbGwgYWxsIGRlZmF1bHQgcHJvcHMgb2Ygb2JqZWN0IHR5cGUsIGlmIGEgZHluYW1pYyBwcm9wLCBpbnZva2Ugc2V0dGVyOyBlbHNlIGRlZXAgY2xvbmUgaXQgc28gY2hhbmdlc1xuICAgICAgICAvLyBtYWRlIHRvIGlubmVyIHByb3BzIHdvbid0IGdvIHRvIG9iamVjdCBvbiB0aGVtZSBvciBkZWZhdWx0cyBsYXllcnMgd2hpY2ggYXJlIHNoYXJlZCBieSBvdGhlciBpbnN0YW5jZXMuXG4gICAgICAgIE9iamVjdC5rZXlzKGRlZmF1bHRzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZGVmYXVsdHNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGR5bmFtaWNQcm9wZXJ0eURlc2NyaXB0b3JzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gdmFsdWU7IC8vIGludm9rZSBkeW5hbWljIHByb3Agc2V0dGVyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gZGVlcENsb25lKHZhbHVlKTsgLy8ganVzdCBhIHBsYWluIG9iamVjdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5wcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgQ2xlYXIgb3V0IGFsbCBzdGF0ZSBzZXR0aW5ncywgZGF0YSAocm93cyksIGFuZCBzY2hlbWEgKGNvbHVtbnMpIG9mIGEgZ3JpZCBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLnN1YmdyaWRzXSAtIENvbnN1bWVkIGJ5IHtAbGluayBCZWhhdmlvciNyZXNldH0uXG4gICAgICogSWYgb21pdHRlZCwgcHJldmlvdXNseSBlc3RhYmxpc2hlZCBzdWJncmlkcyBsaXN0IGlzIHJldXNlZC5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY2xlYXJTdGF0ZSgpO1xuXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgICAgICB0aGlzLmxhc3RFZGdlU2VsZWN0aW9uID0gWzAsIDBdO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLnJlc2V0KCk7XG4gICAgICAgIHRoaXMucmVuZGVyT3ZlcnJpZGVzQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5jbGVhck1vdXNlRG93bigpO1xuICAgICAgICB0aGlzLmRyYWdFeHRlbnQgPSBuZXcgUG9pbnQoMCwgMCk7XG5cbiAgICAgICAgdGhpcy5udW1Sb3dzID0gMDtcbiAgICAgICAgdGhpcy5udW1Db2x1bW5zID0gMDtcblxuICAgICAgICB0aGlzLnZTY3JvbGxWYWx1ZSA9IDA7XG4gICAgICAgIHRoaXMuaFNjcm9sbFZhbHVlID0gMDtcblxuICAgICAgICB0aGlzLmNhbmNlbEVkaXRpbmcoKTtcblxuICAgICAgICB0aGlzLnNiUHJldlZTY3JvbGxWYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2JQcmV2SFNjcm9sbFZhbHVlID0gbnVsbDtcblxuICAgICAgICB0aGlzLmhvdmVyQ2VsbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2Nyb2xsaW5nTm93ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdEVkZ2VTZWxlY3Rpb24gPSBbMCwgMF07XG5cbiAgICAgICAgdGhpcy5iZWhhdmlvci5yZXNldCh7XG4gICAgICAgICAgICBzdWJncmlkczogb3B0aW9ucyAmJiBvcHRpb25zLnN1YmdyaWRzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVzZXQoKTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVzaXplKCk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3JDaGFuZ2VkKCk7XG5cbiAgICAgICAgdGhpcy5yZWZyZXNoUHJvcGVydGllcygpO1xuICAgIH0sXG5cbiAgICAvKiogQHR5cGVkZWYge29iamVjdHxmdW5jdGlvbnxBcnJheX0gcGx1Z2luU3BlY1xuICAgICAqIEBkZXNjIE9uZSBvZjpcbiAgICAgKiAqIHNpbXBsZSBBUEkgLSBhIHBsYWluIG9iamVjdCB3aXRoIGFuIGBpbnN0YWxsYCBtZXRob2RcbiAgICAgKiAqIG9iamVjdCBBUEkgLSBhbiBvYmplY3QgY29uc3RydWN0b3JcbiAgICAgKiAqIGFycmF5OlxuICAgICAqICAgICogZmlyc3QgZWxlbWVudCBpcyBhbiBvcHRpb25hbCBuYW1lIGZvciB0aGUgQVBJIG9yIHRoZSBuZXdseSBpbnN0YW50aWF0ZWQgb2JqZWN0XG4gICAgICogICAgKiBuZXh0IGVsZW1lbnQgKG9yIGZpcnN0IGVsZW1lbnQgd2hlbiBub3QgYSBzdHJpbmcpIGlzIHRoZSBzaW1wbGUgb3Igb2JqZWN0IEFQSVxuICAgICAqICAgICogcmVtYWluaW5nIGFyZ3VtZW50cyBhcmUgb3B0aW9uYWwgYXJndW1lbnRzIGZvciB0aGUgb2JqZWN0IGNvbnN0cnVjdG9yXG4gICAgICogKiBmYWxzeSB2YWx1ZSBzdWNoIGFzIGB1bmRlZmluZWRgIC0gaWdub3JlZFxuICAgICAqXG4gICAgICogVGhlIEFQSSBtYXkgaGF2ZSBhIGBuYW1lYCBvciBgJCRDTEFTU19OQU1FYCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBJbnN0YWxsIHBsdWdpbnMuXG4gICAgICogQGRlc2MgUGx1Z2luIGluc3RhbGxhdGlvbjpcbiAgICAgKiAqIEVhY2ggc2ltcGxlIEFQSSBpcyBpbnN0YWxsZWQgYnkgY2FsbGluZyBpdCdzIGBpbnN0YWxsYCBtZXRob2Qgd2l0aCBgdGhpc2AgYXMgZmlyc3QgYXJnICsgYW55IGFkZGl0aW9uYWwgYXJncyBsaXN0ZWQgaW4gdGhlIGBwbHVnaW5TcGVjYCAod2hlbiBpdCBpcyBhbiBhcnJheSkuXG4gICAgICogKiBFYWNoIG9iamVjdCBBUEkgaXMgaW5zdGFsbGVkIGJ5IGluc3RhbnRpYXRpbmcgaXQncyBjb25zdHJ1Y3RvciB3aXRoIGB0aGlzYCBhcyBmaXJzdCBhcmcgKyBhbnkgYWRkaXRpb25hbCBhcmdzIGxpc3RlZCBpbiB0aGUgYHBsdWdpblNwZWNgICh3aGVuIGl0IGlzIGFuIGFycmF5KS5cbiAgICAgKlxuICAgICAqIFRoZSByZXN1bHRpbmcgcGxhaW4gb2JqZWN0IG9yIGluc3RhbnRpYXRlZCBvYmplY3RzIG1heSBiZSBuYW1lZCBieSAoaW4gcHJpb3JpdHkgb3JkZXIpOlxuICAgICAqIDEuIGlmIGBwbHVnaW5TcGVjYCBjb250YWlucyBhbiBhcnJheSBhbmQgZmlyc3QgZWxlbWVudCBpcyBhIHN0cmluZ1xuICAgICAqIDIuIG9iamVjdCBoYXMgYSBgbmFtZWAgcHJvcGVydHlcbiAgICAgKiAzLiBvYmplY3QgaGFzIGEgYCQkQ0xBU1NfTkFNRWAgcHJvcGVydHlcbiAgICAgKlxuICAgICAqIElmIG5hbWVkLCBhIHJlZmVyZW5jZSB0byBlYWNoIG9iamVjdCBpcyBzYXZlZCBpbiBgdGhpcy5wbHVnaW5zYC4gSWYgdGhlIHBsdWctaW4gaXMgdW5uYW1lZCwgbm8gcmVmZXJlbmNlIGlzIGtlcHQuXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgdHdvIHR5cGVzIG9mIHBsdWdpbiBpbnN0YWxsYXRpb25zOlxuICAgICAqICogUHJlaW5zdGFsbGVkIHBsdWdpbnMgd2hpY2ggYXJlIGluc3RhbGxlZCBvbiB0aGUgcHJvdG90eXBlLiBUaGVzZSBhcmUgc2ltcGxlIEFQSSBwbHVnaW5zIHdpdGggYSBgcHJlaW5zdGFsbGAgbWV0aG9kIGNhbGxlZCB3aXRoIHRoZSBgaW5zdGFsbFBsdWdpbnNgIGNhbGxpbmcgY29udGV4dCBhcyB0aGUgZmlyc3QgYXJndW1lbnQuIFByZWluc3RhbGxhdGlvbnMgYXJlIGF1dG9tYXRpY2FsbHkgcGVyZm9ybWVkIHdoZW5ldmVyIGEgZ3JpZCBpcyBpbnN0YW50aWF0ZWQgKGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbnN0cnVjdG9yKSwgYnkgY2FsbGluZyBgaW5zdGFsbFBsdWdpbnNgIHdpdGggYEh5cGVyZ3JpZC5wcm90b3R5cGVgIGFzIHRoZSBjYWxsaW5nIGNvbnRleHQuXG4gICAgICogKiBSZWd1bGFyIHBsdWdpbnMgd2hpY2ggYXJlIGluc3RhbGxlZCBvbiB0aGUgaW5zdGFuY2UuIFRoZXNlIGFyZSBzaW1wbGUgQVBJIHBsdWdpbnMgd2l0aCBhbiBgaW5zdGFsbGAgbWV0aG9kLCBhcyB3ZWxsIGFzIGFsbCBvYmplY3QgQVBJIHBsdWdpbnMgKGNvbnN0cnVjdG9ycyksIGNhbGxlZCB3aXRoIHRoZSBgaW5zdGFsbFBsdWdpbnNgIGNhbGxpbmcgY29udGV4dCBhcyB0aGUgZmlyc3QgYXJndW1lbnQuIFRoZXNlIGluc3RhbGxhdGlvbnMgYXJlIGF1dG9tYXRpY2FsbHkgcGVyZm9ybWVkIHdoZW5ldmVyIGEgZ3JpZCBpcyBpbnN0YW50aWF0ZWQgKGF0IHRoZSBlbmQgb2YgdGhlIGNvbnN0cnVjdG9yKSwgY2FsbGVkIHdpdGggdGhlIG5ldyBncmlkIGluc3RhbmNlIGFzIHRoZSBjYWxsaW5nIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBUaGUgXCJgaW5zdGFsbFBsdWdpbnNgIGNhbGxpbmcgY29udGV4dFwiIG1lYW5zIGVpdGhlciB0aGUgZ3JpZCBpbnN0YW5jZSBvciBpdHMgcHJvdG90eXBlLCBkZXBlbmRpbmcgb24gaG93IHRoaXMgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIFBsdWdpbnMgbWF5IGhhdmUgYm90aCBgcHJlaW5zdGFsbGAgX2FuZF8gYGluc3RhbGxgIG1ldGhvZHMsIGluIHdoaWNoIGNhc2UgYm90aCB3aWxsIGJlIGNhbGxlZC4gSG93ZXZlciwgbm90ZSB0aGF0IGluIGFueSBjYXNlLCBgaW5zdGFsbGAgbWV0aG9kcyBvbiBvYmplY3QgQVBJIHBsdWdpbnMgYXJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBAdGhpcyB7SHlwZXJncmlkfVxuICAgICAqIEBwYXJhbSB7cGx1Z2luU3BlY3xwbHVnaW5TcGVjW119IFtwbHVnaW5zXSAtIFRoZSBwbHVnaW5zIHRvIGluc3RhbGwuIElmIG9taXR0ZWQsIHRoZSBjYWxsIGlzIGEgbm8tb3AuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBpbnN0YWxsUGx1Z2luczogZnVuY3Rpb24ocGx1Z2lucykge1xuICAgICAgICB2YXIgc2hhcmVkID0gdGhpcyA9PT0gSHlwZXJncmlkLnByb3RvdHlwZTsgLy8gRG8gc2hhcmVkIChcInByZWluc3RhbGxlZFwiKSBwbHVnaW5zIChpZiBhbnkpXG5cbiAgICAgICAgaWYgKCFwbHVnaW5zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocGx1Z2lucykpIHtcbiAgICAgICAgICAgIHBsdWdpbnMgPSBbcGx1Z2luc107XG4gICAgICAgIH1cblxuICAgICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSwgYXJncywgaGFzaDtcblxuICAgICAgICAgICAgaWYgKCFwbHVnaW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIGlnbm9yZSBmYWxzeSBwbHVnaW4gc3BlY1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXQgZmlyc3QgYXJnIG9mIGNvbnN0cnVjdG9yIHRvIGB0aGlzYCAodGhlIGdyaWQgaW5zdGFuY2UpXG4gICAgICAgICAgICAvLyBzZXQgZmlyc3QgYXJnIG9mIGBpbnN0YWxsYCBtZXRob2QgdG8gYHRoaXNgICh0aGUgZ3JpZCBpbnN0YW5jZSlcbiAgICAgICAgICAgIC8vIHNldCBmaXJzdCB0d28gYXJncyBvZiBgcHJlaW5zdGFsbGAgbWV0aG9kIHRvIGB0aGlzYCAodGhlIEh5cGVyZ3JpZCBwcm90b3R5cGUpIGFuZCB0aGUgQmVoYXZpb3IgcHJvdG90eXBlXG4gICAgICAgICAgICBhcmdzID0gW3RoaXNdO1xuICAgICAgICAgICAgaWYgKHNoYXJlZCkge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChCZWhhdmlvci5wcm90b3R5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwbHVnaW4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwbHVnaW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW5bMF0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChwbHVnaW4uc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW4gPSBwbHVnaW5bMF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwbHVnaW4ubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KHBsdWdpbi5zbGljZSgyKSk7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBwbHVnaW5bMF07XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbiA9IHBsdWdpblsxXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXBsdWdpbikge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gaWdub3JlIGVtcHR5IGFycmF5IG9yIGFycmF5IHdpdGggc2luZ2xlIHN0cmluZyBlbGVtZW50XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERlcml2ZSBBUEkgbmFtZSBpZiBub3QgZ2l2ZW4gaW4gcGx1Z2luU3BlY1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUgfHwgcGx1Z2luLm5hbWUgfHwgcGx1Z2luLiQkQ0xBU1NfTkFNRTtcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJhbnNsYXRlIGZpcnN0IGNoYXJhY3RlciB0byBsb3dlciBjYXNlXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDAsIDEpLnRvTG93ZXJDYXNlKCkgKyBuYW1lLnN1YnN0cigxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNoYXJlZCkge1xuICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIGBwcmVpbnN0YWxsYCBtZXRob2RcbiAgICAgICAgICAgICAgICBoYXNoID0gdGhpcy5jb25zdHJ1Y3Rvci5wbHVnaW5zO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4ucHJlaW5zdGFsbCAmJiAhaGFzaFtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW4ucHJlaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGluc3RhbmNlIHBsdWctaW5zOlxuICAgICAgICAgICAgICAgIGhhc2ggPSB0aGlzLnBsdWdpbnM7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGFsbCBcIm9iamVjdCBBUElcIiBieSBpbnN0YW50aWF0aW5nXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbiA9IHRoaXMuY3JlYXRlQXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBsdWdpbi5pbnN0YWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluc3RhbGwgXCJzaW1wbGUgQVBJXCIgYnkgY2FsbGluZyBpdHMgYGluc3RhbGxgIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXBsdWdpbi5wcmVpbnN0YWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCYXNlLnByb3RvdHlwZS5IeXBlcmdyaWRFcnJvcignRXhwZWN0ZWQgcGx1Z2luIChhIGNvbnN0cnVjdG9yOyBvciBhbiBBUEkgd2l0aCBhIGBwcmVpbnN0YWxsYCBtZXRob2QgYW5kL29yIGFuIGBpbnN0YWxsYCBtZXRob2QpLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBoYXNoW25hbWVdID0gcGx1Z2luO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBVbmluc3RhbGwgYWxsIHVuaW5zdGFsbGFibGUgcGx1Z2lucyBvciBqdXN0IG5hbWVkIHBsdWdpbnMuXG4gICAgICogQGRlc2MgQ2FsbHMgYHVuaW5zdGFsbGAgb24gcGx1Z2lucyB0aGF0IGRlZmluZSBzdWNoIGEgbWV0aG9kLlxuICAgICAqXG4gICAgICogVG8gdW5pbnN0YWxsIFwicHJlaW5zdGFsbGVkXCIgcGx1Z2lucywgY2FsbCB3aXRoIGBIeXBlcmdyaWQucHJvdG90eXBlYCBhcyBjb250ZXh0LlxuICAgICAqXG4gICAgICogRm9yIGNvbnZlbmllbmNlLCB0aGUgZm9sbG93aW5nIGFyZ3MgYXJlIHBhc3NlZCB0byB0aGUgY2FsbDpcbiAgICAgKiAqIGB0aGlzYCAtIHRoZSBwbHVnaW4gdG8gYmUgdW5pbnN0YWxsZWRcbiAgICAgKiAqIGBncmlkYCAtIHRoZSBoeXBlcmdyaWQgb2JqZWN0XG4gICAgICogKiBga2V5YCAtIG5hbWUgb2YgdGhlIHBsdWdpbiB0byBiZSB1bmluc3RhbGxlZCAoX2kuZS4sXyBrZXkgaW4gYHBsdWdpbnNgKVxuICAgICAqICogYHBsdWdpbnNgIC0gdGhlIHBsdWdpbnMgaGFzaCAoYS5rLmEuIGBncmlkLnBsdWdpbnNgKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0aXJuZ1tdfSBbcGx1Z2luTmFtZXNdIElmIHByb3ZpZGVkLCBsaW1pdCB1bmluc3RhbGwgdG8gdGhlIG5hbWVkIHBsdWdpbiAoc3RyaW5nKSBvciBwbHVnaW5zIChzdHJpbmdbXSkuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICB1bmluc3RhbGxQbHVnaW5zOiBmdW5jdGlvbihwbHVnaW5OYW1lcykge1xuICAgICAgICBpZiAoIXBsdWdpbk5hbWVzKSB7XG4gICAgICAgICAgICBwbHVnaW5OYW1lcyA9IFtdO1xuICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHBsdWdpbk5hbWVzKSkge1xuICAgICAgICAgICAgcGx1Z2luTmFtZXMgPSBbcGx1Z2luTmFtZXNdO1xuICAgICAgICB9XG4gICAgICAgIF8odGhpcy5wbHVnaW5zKS5lYWNoKGZ1bmN0aW9uKHBsdWdpbiwga2V5LCBwbHVnaW5zKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmXG4gICAgICAgICAgICAgICAgcGx1Z2luTmFtZXMuaW5kZXhPZihrZXkpID49IDAgJiZcbiAgICAgICAgICAgICAgICBwbHVnaW4udW5pbnN0YWxsXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBwbHVnaW4udW5pbnN0YWxsKHRoaXMsIGtleSwgcGx1Z2lucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICBjb21wdXRlQ2VsbHNCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmNvbXB1dGVDZWxsc0JvdW5kcygpO1xuICAgIH0sXG5cbiAgICBzZXRGb3JtYXR0ZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbmV3IExvY2FsaXphdGlvbihcbiAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlIHx8IEh5cGVyZ3JpZC5sb2NhbGl6YXRpb24ubG9jYWxlLFxuICAgICAgICAgICAgb3B0aW9ucy5udW1iZXJPcHRpb25zIHx8IEh5cGVyZ3JpZC5sb2NhbGl6YXRpb24ubnVtYmVyT3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0ZU9wdGlvbnMgfHwgSHlwZXJncmlkLmxvY2FsaXphdGlvbi5kYXRlT3B0aW9uc1xuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBnZXRGb3JtYXR0ZXI6IGZ1bmN0aW9uKGxvY2FsaXplck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLmdldChsb2NhbGl6ZXJOYW1lKS5mb3JtYXQ7XG4gICAgfSxcblxuICAgIGZvcm1hdFZhbHVlOiBmdW5jdGlvbihsb2NhbGl6ZXJOYW1lLCB2YWx1ZSwgaXNIZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB0aGlzLmdldEZvcm1hdHRlcihsb2NhbGl6ZXJOYW1lKSh2YWx1ZSwgaXNIZWFkZXIpIDogJyc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU2V0IHRoZSBjZWxsIHVuZGVyIHRoZSBjdXJzb3IuXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR9IGNlbGxFdmVudFxuICAgICAqL1xuICAgIHNldEhvdmVyQ2VsbDogZnVuY3Rpb24oY2VsbEV2ZW50KSB7XG4gICAgICAgIHZhciBob3ZlckNlbGwgPSB0aGlzLmhvdmVyQ2VsbDtcbiAgICAgICAgaWYgKCFob3ZlckNlbGwgfHwgIWhvdmVyQ2VsbC5lcXVhbHMoY2VsbEV2ZW50LmdyaWRDZWxsKSkge1xuICAgICAgICAgICAgdGhpcy5ob3ZlckNlbGwgPSBjZWxsRXZlbnQuZ3JpZENlbGw7XG4gICAgICAgICAgICBpZiAoaG92ZXJDZWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlU3ludGhldGljT25DZWxsRXhpdEV2ZW50KGNlbGxFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpcmVTeW50aGV0aWNPbkNlbGxFbnRlckV2ZW50KGNlbGxFdmVudCk7XG4gICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIEFtZW5kIHByb3BlcnRpZXMgZm9yIHRoaXMgaHlwZXJncmlkIG9ubHkuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG1vcmVQcm9wZXJ0aWVzIC0gQSBzaW1wbGUgcHJvcGVydGllcyBoYXNoLlxuICAgICAqL1xuICAgIGFkZFByb3BlcnRpZXM6IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnByb3BlcnRpZXMsIHByb3BlcnRpZXMpO1xuICAgICAgICB0aGlzLnJlZnJlc2hQcm9wZXJ0aWVzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0b2RvIGRlcHJlY2F0ZSB0aGlzIGluIGZhdm9yIG9mIG1ha2luZyBwcm9wZXJ0aWVzIGR5bmFtaWMgaW5zdGVhZCAoZm9yIHRob3NlIHRoYXQgbmVlZCB0byBiZSlcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFV0aWxpdHkgZnVuY3Rpb24gdG8gcHVzaCBvdXQgcHJvcGVydGllcyBpZiB3ZSBjaGFuZ2UgdGhlbS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcGVydGllcyAtIEFuIG9iamVjdCBvZiB2YXJpb3VzIGtleSB2YWx1ZSBwYWlycy5cbiAgICAgKi9cbiAgICByZWZyZXNoUHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3JTaGFwZUNoYW5nZWQoKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5kZWZhdWx0Um93SGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5hdXRvc2l6ZUFsbENvbHVtbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBTZXQgdGhlIHN0YXRlIG9iamVjdCB0byByZXR1cm4gdG8gdGhlIGdpdmVuIHVzZXIgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc3RhdGUgLSBBIG1lbWVudG8gb2JqZWN0LlxuICAgICAqIEBzZWUgW01lbWVudG8gcGF0dGVybl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZW1lbnRvX3BhdHRlcm4pXG4gICAgICovXG4gICAgc2V0U3RhdGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0U3RhdGUoc3RhdGUpO1xuICAgICAgICB0aGlzLnJlZnJlc2hQcm9wZXJ0aWVzKCk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3JDaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIGdldFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0U3RhdGUoKTtcbiAgICB9LFxuXG4gICAgbG9hZFN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLnNldFN0YXRlKHN0YXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHRvZG8gT25seSBvdXRwdXQgdmFsdWVzIHdoZW4gdGhleSBkaWZmZXIgZnJvbSBkZWZhdWx0cyAoZGVlcCBjb21wYXJlIG5lZWRlZCkuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IFtvcHRpb25zLmJsYWNrbGlzdF0gLSBMaXN0IG9mIGdyaWQgcHJvcGVydGllcyB0byBleGNsdWRlLiBQZXJ0YWlucyB0byBncmlkIG93biBwcm9wZXJ0aWVzIG9ubHkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jb21wYWN0XSAtIFJ1biBnYXJiYWdlIGNvbGxlY3Rpb24gZmlyc3QuIFRoZSBvbmx5IHByb3BlcnR5IHRoaXMgY3VycmVudCBhZmZlY3RzIGlzIGBwcm9wZXJ0aWVzLmNhbGN1bGF0b3JzYCAocmVtb3ZlcyB1bnVzZWQgY2FsY3VsYXRvcnMpLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdGlvbnMuc3BhY2U9J1xcdCddIC0gRm9yIG5vIHNwYWNlLCBnaXZlIGAwYC4gKFNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTG9jYWwvc3RyaW5naWZ5fEpTT04uc3RyaW5naWZ5fSdzIGBzcGFjZWAgcGFyYW0gb3RoZXIgb3B0aW9ucy4pXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuaGVhZGVyaWZ5XSAtIElmIHlvdXIgaGVhZGVycyB3ZXJlIGdlbmVyYXRlZCBieSBhIGZ1bmN0aW9uICh0YWtpbmcgY29sdW1uIG5hbWUgYXMgYSBwYXJhbWV0ZXIpLCBnaXZlIGEgcmVmZXJlbmNlIHRvIHRoYXQgZnVuY3Rpb24gaGVyZSB0byBhdm9pZCBwZXJzaXN0aW5nIGhlYWRlcnMgdGhhdCBtYXRjaCB0aGUgZ2VuZXJhdGVkIHN0cmluZy5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIHNhdmVTdGF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB2YXIgc3BhY2UgPSBvcHRpb25zLnNwYWNlID09PSB1bmRlZmluZWQgPyAnXFx0JyA6IG9wdGlvbnMuc3BhY2UsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgY2FsY3VsYXRvcnMgPSBwcm9wZXJ0aWVzLmNhbGN1bGF0b3JzO1xuXG4gICAgICAgIGlmIChjYWxjdWxhdG9ycykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29tcGFjdCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW5zID0gdGhpcy5iZWhhdmlvci5nZXRDb2x1bW5zKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoY2FsY3VsYXRvcnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29sdW1ucy5maW5kKGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW4ucHJvcGVydGllcy5jYWxjdWxhdG9yID09PSBjYWxjdWxhdG9yc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWxjdWxhdG9yc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxjdWxhdG9ycy50b0pTT04gPSBzdHJpbmdpZnlGdW5jdGlvbnM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZW1wb3JhcmlseSBjb3B5IHRoZSBnaXZlbiBoZWFkZXJpZnkgZnVuY3Rpb24gZm9yIGFjY2VzcyBieSBjb2x1bW5zIGdldHRlclxuICAgICAgICB0aGlzLmhlYWRlcmlmeSA9IG9wdGlvbnMuaGVhZGVyaWZ5O1xuXG4gICAgICAgIHZhciBqc29uID0gSlNPTi5zdHJpbmdpZnkocHJvcGVydGllcywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYmxhY2tsaXN0ICYmIHRoaXMgPT09IHByb3BlcnRpZXMgJiYgb3B0aW9ucy5ibGFja2xpc3QuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnY2FsY3VsYXRvcicpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsY3VsYXRvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCBmdW5jdGlvbiByZWZlcmVuY2UgdG8gcmVnaXN0cnkga2V5XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gT2JqZWN0LmtleXMoY2FsY3VsYXRvcnMpLmZpbmQoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRvcnNba2V5XSA9PT0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlZ2lzdHJ5IG1heSBub3QgZXhpc3QgaWYgQ29sdW1uLmNhbGN1bGF0b3Igc2V0dGVyIHdhcyB1c2VkIGRpcmVjdGx5IHNvIGp1c3Qgc2F2ZSBhcyBpc1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LCBzcGFjZSk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSB0ZW1wb3JhcnkgY29weVxuICAgICAgICBkZWxldGUgdGhpcy5oZWFkZXJpZnk7XG5cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHJldHVybnMge29iamVjdH0gVGhlIGluaXRpYWwgbW91c2UgcG9zaXRpb24gb24gYSBtb3VzZSBkb3duIGV2ZW50IGZvciBjZWxsIGVkaXRpbmcgb3IgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIGdldE1vdXNlRG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlRG93bi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vdXNlRG93blt0aGlzLm1vdXNlRG93bi5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFJlbW92ZSB0aGUgbGFzdCBpdGVtIGZyb20gdGhlIG1vdXNlIGRvd24gc3RhY2suXG4gICAgICovXG4gICAgcG9wTW91c2VEb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKHRoaXMubW91c2VEb3duLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tb3VzZURvd24ucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBFbXB0eSBvdXQgdGhlIG1vdXNlIGRvd24gc3RhY2suXG4gICAgICovXG4gICAgY2xlYXJNb3VzZURvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm1vdXNlRG93biA9IFtuZXcgUG9pbnQoLTEsIC0xKV07XG4gICAgICAgIHRoaXMuZHJhZ0V4dGVudCA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbW91c2UgcG9pbnQgdGhhdCBpbml0aWF0ZWQgYSBjZWxsIGVkaXQgb3IgZHJhZyBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIHNldE1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgdGhpcy5tb3VzZURvd24ucHVzaChwb2ludCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHJldHVybnMge1BvaW50fSBUaGUgZXh0ZW50IHBvaW50IG9mIHRoZSBjdXJyZW50IGRyYWcgc2VsZWN0aW9uIHJlY3RhbmdsZS5cbiAgICAgKi9cbiAgICBnZXREcmFnRXh0ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0V4dGVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAc3VtbWFyeSBTZXQgdGhlIGV4dGVudCBwb2ludCBvZiB0aGUgY3VycmVudCBkcmFnIHNlbGVjdGlvbiBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAgICAgKi9cbiAgICBzZXREcmFnRXh0ZW50OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICB0aGlzLmRyYWdFeHRlbnQgPSBwb2ludDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBUaGlzIGZ1bmN0aW9uIGlzIGEgY2FsbGJhY2sgZnJvbSB0aGUgSHlwZXJncmlkUmVuZGVyZXIgc3ViLWNvbXBvbmVudC4gSXQgaXMgY2FsbGVkIGFmdGVyIGVhY2ggcGFpbnQgb2YgdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICBncmlkUmVuZGVyZWROb3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jZWxsRWRpdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmNlbGxFZGl0b3IuZ3JpZFJlbmRlcmVkTm90aWZpY2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0NvbHVtbkF1dG9zaXppbmcoKTtcbiAgICAgICAgdGhpcy5maXJlU3ludGhldGljR3JpZFJlbmRlcmVkRXZlbnQoKTtcbiAgICB9LFxuXG4gICAgdGlja05vdGlmaWNhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY1RpY2tFdmVudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFRoZSBncmlkIGhhcyBqdXN0IGJlZW4gcmVuZGVyZWQsIG1ha2Ugc3VyZSB0aGUgY29sdW1uIHdpZHRocyBhcmUgb3B0aW1hbC5cbiAgICAgKi9cbiAgICBjaGVja0NvbHVtbkF1dG9zaXppbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmF1dG9TaXplUm93TnVtYmVyQ29sdW1uKCk7XG4gICAgICAgIGlmICh0aGlzLmJlaGF2aW9yLmNoZWNrQ29sdW1uQXV0b3NpemluZyhmYWxzZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3JTaGFwZUNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IENvbmRpdGlvbmFsbHkgY29weSB0byBjbGlwYm9hcmQuXG4gICAgICogQGRlc2MgSWYgd2UgaGF2ZSBmb2N1cywgY29weSBvdXIgY3VycmVudCBzZWxlY3Rpb24gZGF0YSB0byB0aGUgc3lzdGVtIGNsaXBib2FyZC5cbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBldmVudCAtIFRoZSBjb3B5IHN5c3RlbSBldmVudC5cbiAgICAgKi9cbiAgICBjaGVja0NsaXBib2FyZENvcHk6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0ZvY3VzKCkgfHwgdGhpcy5tZW51Q2xpY2spIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgY3N2RGF0YSA9IHRoaXMuZ2V0U2VsZWN0aW9uQXNUU1YoKTtcbiAgICAgICAgICAgIGV2ZW50LmNsaXBib2FyZERhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsIGNzdkRhdGEudGV4dCk7XG4gICAgICAgICAgICBldmVudC5jbGlwYm9hcmREYXRhLnNldERhdGEoJ3RleHQvaHRtbCcsIGNzdkRhdGEuaHRtbCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2UgaGF2ZSBmb2N1cy5cbiAgICAgKi9cbiAgICBoYXNGb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5oYXNGb2N1cygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IFNldCB0aGUgQmVoYXZpb3Igb2JqZWN0IGZvciB0aGlzIGdyaWQgY29udHJvbC5cbiAgICAgKiBAZGVzYyBDYWxsZWQgd2hlbiBgb3B0aW9ucy5CZWhhdmlvcmAgZnJvbTpcbiAgICAgKiAqIEh5cGVyZ3JpZCBjb25zdHJ1Y3RvclxuICAgICAqICogYHNldERhdGFgIHdoZW4gbm90IGNhbGxlZCBleHBsaWNpdGx5IGJlZm9yZSB0aGVuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIF9QZXIge0BsaW5rIEJlaGF2aW9yI3NldERhdGF9Ll9cbiAgICAgKiBAcGFyYW0ge0JlaGF2aW9yfSBbb3B0aW9ucy5CZWhhdmlvcj1Mb2NhbF0gLSBUaGUgYmVoYXZpb3IgKG1vZGVsKSBjYW4gYmUgZWl0aGVyIGEgY29uc3RydWN0b3Igb3IgYW4gaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtkYXRhTW9kZWxBUEl9IFtvcHRpb25zLmRhdGFNb2RlbF0gLSBBIGZ1bGx5IGluc3RhbnRpYXRlZCBkYXRhIG1vZGVsIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5EYXRhTW9kZWw9cmVxdWlyZSgnZGF0YXNhdXItbG9jYWwnKV0gLSBEYXRhIG1vZGVsIHdpbGwgYmUgaW5zdGFudGlhdGVkIGZyb20gdGhpcyBjb25zdHJ1Y3RvciB1bmxlc3MgYG9wdGlvbnMuZGF0YU1vZGVsYCB3YXMgZ2l2ZW4uXG4gICAgICogQHBhcmFtIHtkYXRhTW9kZWxBUEl9IFtvcHRpb25zLm1ldGFkYXRhXSAtIFZhbHVlIHRvIGJlIHBhc3NlZCB0byBzZXRNZXRhZGF0YVN0b3JlIGlmIHRoZSBkYXRhIG1vZGVsIGhhcyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7ZGF0YVJvd09iamVjdFtdfSBbb3B0aW9ucy5kYXRhXSAtIF9QZXIge0BsaW5rIEJlaGF2aW9yI3NldERhdGF9Ll9cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufG1lbnVJdGVtW119IFtvcHRpb25zLnNjaGVtYV0gLSBfUGVyIHtAbGluayBCZWhhdmlvciNzZXREYXRhfS5cbiAgICAgKi9cbiAgICBzZXRCZWhhdmlvcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgQmVoYXZpb3IgPSBvcHRpb25zICYmIG9wdGlvbnMuQmVoYXZpb3IgfHwgYmVoYXZpb3JKU09OO1xuICAgICAgICB0aGlzLmJlaGF2aW9yID0gbmV3IEJlaGF2aW9yKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmluaXRTY3JvbGxiYXJzKCk7XG4gICAgICAgIHRoaXMucmVmcmVzaFByb3BlcnRpZXMoKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5yZWluZGV4KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHN1bW1hcnkgU2V0IHRoZSB1bmRlcmx5aW5nIGRhdGFzb3VyY2UuXG4gICAgICogQGRlc2MgVGhpcyBjYW4gYmUgZG9uZSBkeW5hbWljYWxseS5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufG9iamVjdFtdfSBkYXRhUm93cyAtIE1heSBiZTpcbiAgICAgKiAqIEFuIGFycmF5IG9mIGNvbmdydWVudCByYXcgZGF0YSBvYmplY3RzLlxuICAgICAqICogQSBmdW5jdGlvbiByZXR1cm5pbmcgc2FtZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gXyhTZWUgYWxzbyB7QGxpbmsgQmVoYXZpb3Ijc2V0RGF0YX0gZm9yIGFkZGl0aW9uYWwgb3B0aW9ucy4pX1xuICAgICAqIEBwYXJhbSB7QmVoYXZpb3J9IFtvcHRpb25zLkJlaGF2aW9yPUxvY2FsXSAtIFRoZSBiZWhhdmlvciAobW9kZWwpIGNhbiBiZSBlaXRoZXIgYSBjb25zdHJ1Y3RvciBvciBhbiBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge2RhdGFNb2RlbEFQSX0gW29wdGlvbnMuZGF0YU1vZGVsXSAtIF9QYXNzZWQgdG8gYmVoYXZpb3Ige0BsaW5rIEJlaGF2aW9yIGNvbnN0cnVjdG9yfSAod2hlbiBgb3B0aW9ucy5CZWhhdmlvcmAgZ2l2ZW4pLl9cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5EYXRhTW9kZWw9cmVxdWlyZSgnZGF0YXNhdXItbG9jYWwnKV0gLSBfUGFzc2VkIHRvIGJlaGF2aW9yIHtAbGluayBCZWhhdmlvciBjb25zdHJ1Y3Rvcn0gKHdoZW4gYG9wdGlvbnMuQmVoYXZpb3JgIGdpdmVuKS5fXG4gICAgICogQHBhcmFtIHtkYXRhTW9kZWxBUEl9IFtvcHRpb25zLm1ldGFkYXRhXSAtIF9QYXNzZWQgdG8gYmVoYXZpb3Ige0BsaW5rIEJlaGF2aW9yIGNvbnN0cnVjdG9yfSAod2hlbiBgb3B0aW9ucy5CZWhhdmlvcmAgZ2l2ZW4pLl9cbiAgICAgKiBAcGFyYW0ge2RhdGFSb3dPYmplY3RbXX0gW29wdGlvbnMuZGF0YV0gLSBfUGFzc2VkIHRvIGJlaGF2aW9yIHtAbGluayBCZWhhdmlvciBjb25zdHJ1Y3Rvcn0gKHdoZW4gYG9wdGlvbnMuQmVoYXZpb3JgIGdpdmVuKS5fXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbnxtZW51SXRlbVtdfSBbb3B0aW9ucy5zY2hlbWFdIC0gX1Bhc3NlZCB0byBiZWhhdmlvciB7QGxpbmsgQmVoYXZpb3IgY29uc3RydWN0b3J9ICh3aGVuIGBvcHRpb25zLkJlaGF2aW9yYCBnaXZlbikuX1xuICAgICAqL1xuICAgIHNldERhdGE6IGZ1bmN0aW9uKGRhdGFSb3dzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5iZWhhdmlvcikge1xuICAgICAgICAgICAgdGhpcy5zZXRCZWhhdmlvcihvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJlaGF2aW9yLnNldERhdGEoZGF0YVJvd3MsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNldEluZm8oZGF0YVJvd3MubGVuZ3RoID8gJycgOiB0aGlzLnByb3BlcnRpZXMubm9EYXRhTWVzc2FnZSk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IuY2hhbmdlZCgpO1xuICAgICAgICB0aGlzLmZpcmVTeW50aGV0aWNHcmlkRGF0YUFkZGVkRXZlbnQoZGF0YVJvd3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IEFkZCB0aGUgdW5kZXJseWluZyBkYXRhc291cmNlLlxuICAgICAqIEBkZXNjIFRoaXMgY2FuIGJlIGRvbmUgZHluYW1pY2FsbHkuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbnxvYmplY3RbXX0gZGF0YVJvd3MgLSBNYXkgYmU6XG4gICAgICogKiBBbiBhcnJheSBvZiBjb25ncnVlbnQgcmF3IGRhdGEgb2JqZWN0cy5cbiAgICAgKiAqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHNhbWUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIF8oU2VlIGFsc28ge0BsaW5rIEJlaGF2aW9yI3NldERhdGF9IGZvciBhZGRpdGlvbmFsIG9wdGlvbnMuKV9cbiAgICAgKiBAcGFyYW0ge0JlaGF2aW9yfSBbb3B0aW9ucy5CZWhhdmlvcj1Mb2NhbF0gLSBUaGUgYmVoYXZpb3IgKG1vZGVsKSBjYW4gYmUgZWl0aGVyIGEgY29uc3RydWN0b3Igb3IgYW4gaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtkYXRhTW9kZWxBUEl9IFtvcHRpb25zLmRhdGFNb2RlbF0gLSBfUGFzc2VkIHRvIGJlaGF2aW9yIHtAbGluayBCZWhhdmlvciBjb25zdHJ1Y3Rvcn0gKHdoZW4gYG9wdGlvbnMuQmVoYXZpb3JgIGdpdmVuKS5fXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuRGF0YU1vZGVsPXJlcXVpcmUoJ2RhdGFzYXVyLWxvY2FsJyldIC0gX1Bhc3NlZCB0byBiZWhhdmlvciB7QGxpbmsgQmVoYXZpb3IgY29uc3RydWN0b3J9ICh3aGVuIGBvcHRpb25zLkJlaGF2aW9yYCBnaXZlbikuX1xuICAgICAqIEBwYXJhbSB7ZGF0YU1vZGVsQVBJfSBbb3B0aW9ucy5tZXRhZGF0YV0gLSBfUGFzc2VkIHRvIGJlaGF2aW9yIHtAbGluayBCZWhhdmlvciBjb25zdHJ1Y3Rvcn0gKHdoZW4gYG9wdGlvbnMuQmVoYXZpb3JgIGdpdmVuKS5fXG4gICAgICogQHBhcmFtIHtkYXRhUm93T2JqZWN0W119IFtvcHRpb25zLmRhdGFdIC0gX1Bhc3NlZCB0byBiZWhhdmlvciB7QGxpbmsgQmVoYXZpb3IgY29uc3RydWN0b3J9ICh3aGVuIGBvcHRpb25zLkJlaGF2aW9yYCBnaXZlbikuX1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb258bWVudUl0ZW1bXX0gW29wdGlvbnMuc2NoZW1hXSAtIF9QYXNzZWQgdG8gYmVoYXZpb3Ige0BsaW5rIEJlaGF2aW9yIGNvbnN0cnVjdG9yfSAod2hlbiBgb3B0aW9ucy5CZWhhdmlvcmAgZ2l2ZW4pLl9cbiAgICAgKi9cbiAgICBhZGREYXRhOiBmdW5jdGlvbihkYXRhUm93cywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuYmVoYXZpb3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QmVoYXZpb3Iob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLnNjaGVtYSkge1xuICAgICAgICAgICAgb3B0aW9ucy5zY2hlbWEgPSB0aGlzLmJlaGF2aW9yLmRhdGFNb2RlbC5nZXRTY2hlbWEoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJlaGF2aW9yLmFkZERhdGEoZGF0YVJvd3MsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNldEluZm8odGhpcy5iZWhhdmlvci5kYXRhTW9kZWwuZ2V0RGF0YSgpLmxlbmd0aCA/ICcnIDogdGhpcy5wcm9wZXJ0aWVzLm5vRGF0YU1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmNoYW5nZWQoKTtcbiAgICAgICAgdGhpcy5maXJlU3ludGhldGljR3JpZERhdGFBZGRlZEV2ZW50KGRhdGFSb3dzKTtcbiAgICB9LFxuXG4gICAgc2V0SW5mbzogZnVuY3Rpb24obWVzc2FnZXMpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRJbmZvKG1lc3NhZ2VzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBJJ3ZlIGJlZW4gbm90aWZpZWQgdGhhdCB0aGUgYmVoYXZpb3IgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgYmVoYXZpb3JDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZGl2Q2FudmFzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5udW1Db2x1bW5zICE9PSB0aGlzLmdldENvbHVtbkNvdW50KCkgfHwgdGhpcy5udW1Sb3dzICE9PSB0aGlzLmdldFJvd0NvdW50KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm51bUNvbHVtbnMgPSB0aGlzLmdldENvbHVtbkNvdW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5udW1Sb3dzID0gdGhpcy5nZXRSb3dDb3VudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYmVoYXZpb3JTaGFwZUNoYW5nZWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iZWhhdmlvclN0YXRlQ2hhbmdlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgVGhlIGRpbWVuc2lvbnMgb2YgdGhlIGdyaWQgZGF0YSBoYXZlIGNoYW5nZWQuIFlvdSd2ZSBiZWVuIG5vdGlmaWVkLlxuICAgICAqL1xuICAgIGJlaGF2aW9yU2hhcGVDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5uZWVkc1NoYXBlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBncmlkIGRhdGEgaGF2ZSBjaGFuZ2VkLiBZb3UndmUgYmVlbiBub3RpZmllZC5cbiAgICAgKi9cbiAgICBiZWhhdmlvclN0YXRlQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubmVlZHNTdGF0ZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGZyb20gcmVuZGVyZXIvaW5kZXguanNcbiAgICAgKi9cbiAgICBkZWZlcnJlZEJlaGF2aW9yQ2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMubmVlZHNTaGFwZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpdkNhbnZhcykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnJlZnJlc2hCb3VuZHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRhcmllcygpOyAvLyBjYWxscyBjb21wdXRlQ2VsbHNCb3VuZHMgYW5kIHJlcGFpbnQgKHN0YXRlIGNoYW5nZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5lZWRzU3RhdGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXZDYW52YXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVDZWxsc0JvdW5kcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5uZWVkc1NoYXBlQ2hhbmdlZCA9IHRoaXMubmVlZHNTdGF0ZUNoYW5nZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBNeSBib3VuZHMuXG4gICAgICovXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0Qm91bmRzKCk7XG4gICAgfSxcblxuICAgIHJlcGFpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm93ID0gdGhpcy5wcm9wZXJ0aWVzLnJlcGFpbnRJbW1lZGlhdGVseTtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgICBpZiAobm93ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzLnBhaW50Tm93KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbnZhcy5yZXBhaW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBQYWludCBpbW1lZGlhdGVseSBpbiB0aGlzIG1pY3JvdGFzay5cbiAgICAgKi9cbiAgICBwYWludE5vdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLnBhaW50Tm93KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHN1bW1hcnkgU2V0IHRoZSBjb250YWluZXIgZm9yIGEgZ3JpZCBpbnN0YW5jZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc2V0Q29udGFpbmVyOiBmdW5jdGlvbihkaXYpIHtcbiAgICAgICAgdGhpcy5pbml0Q29udGFpbmVyKGRpdik7XG4gICAgICAgIHRoaXMuaW5pdFJlbmRlcmVyKCk7XG4gICAgICAgIC8vIGluamVjdEdyaWRFbGVtZW50cy5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IEluaXRpYWxpemUgY29udGFpbmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0Q29udGFpbmVyOiBmdW5jdGlvbihkaXYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkaXYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkaXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGRpdik7XG4gICAgICAgIH1cblxuICAgICAgICAvL0RlZmF1bHQgUG9zaXRpb24gYW5kIGhlaWdodCB0byBlbnN1cmUgRG5EIHdvcmtzXG4gICAgICAgIGlmICghZGl2LnN0eWxlLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICBkaXYuc3R5bGUucG9zaXRpb24gPSBudWxsOyAvLyByZXZlcnQgdG8gc3R5bGVzaGVldCB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpdi5jbGllbnRIZWlnaHQgPCAxKSB7XG4gICAgICAgICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gbnVsbDsgLy8gcmV2ZXJ0IHRvIHN0eWxlc2hlZXQgdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIGluamVjdENTUygnZ3JpZCcpO1xuXG4gICAgICAgIC8vcHJldmVudCB0aGUgZGVmYXVsdCBjb250ZXh0IG1lbnUgZm9yIGFwcGVhcmluZ1xuICAgICAgICBkaXYub25jb250ZXh0bWVudSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgZGl2LnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcblxuICAgICAgICBkaXYuY2xhc3NMaXN0LmFkZCgnaHlwZXJncmlkLWNvbnRhaW5lcicpO1xuICAgICAgICBkaXYuaWQgPSBkaXYuaWQgfHwgJ2h5cGVyZ3JpZCcgKyAoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmh5cGVyZ3JpZC1jb250YWluZXInKS5sZW5ndGggLSAxIHx8ICcnKTtcblxuICAgICAgICB0aGlzLmRpdiA9IGRpdjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAc3VtbWFyeSBJbml0aWFsaXplIGRyYXdpbmcgc3VyZmFjZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLm1hcmdpbl0gLSBPcHRpb25hbCBjYW52YXMgXCJtYXJnaW5zXCIgYXBwbGllZCB0byBjb250YWluaW5nIGRpdiBhcyAubGVmdCwgLnRvcCwgLnJpZ2h0LCAuYm90dG9tLiAoRGVmYXVsdCB2YWx1ZXMgYWN0dWFsbHkgZGVyaXZlIGZyb20gJ2dyaWQnIHN0eWxlc2hlZXQncyBgLmh5cGVyZ3JpZC1jb250YWluZXJgIHJ1bGUuKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5tYXJnaW4udG9wPScwcHgnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5tYXJnaW4ucmlnaHQ9JzBweCddXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1hcmdpbi5ib3R0b209JzBweCddXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1hcmdpbi5sZWZ0PScwcHgnXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW5pdENhbnZhczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMuZGl2Q2FudmFzKSB7XG4gICAgICAgICAgICB2YXIgZGl2Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgICAgIHNldFN0eWxlcyhkaXZDYW52YXMsIG9wdGlvbnMgJiYgb3B0aW9ucy5tYXJnaW4sIEVER0VfU1RZTEVTKTtcblxuICAgICAgICAgICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQoZGl2Q2FudmFzKTtcblxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IG5ldyBDYW52YXMoZGl2Q2FudmFzLCB0aGlzLnJlbmRlcmVyKTtcbiAgICAgICAgICAgIGNhbnZhcy5jYW52YXMuY2xhc3NMaXN0LmFkZCgnaHlwZXJncmlkJyk7XG5cbiAgICAgICAgICAgIHRoaXMuZGl2Q2FudmFzID0gZGl2Q2FudmFzO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG5cbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGVDYW52YXNFdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGVEYXRhRXZlbnRzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY29udmVydFZpZXdQb2ludFRvRGF0YVBvaW50OiBmdW5jdGlvbih1bnNjcm9sbGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmNvbnZlcnRWaWV3UG9pbnRUb0RhdGFQb2ludCh1bnNjcm9sbGVkKTtcbiAgICB9LFxuXG4gICAgY29udmVydERhdGFQb2ludFRvVmlld1BvaW50OiBmdW5jdGlvbihkYXRhUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuY29udmVydERhdGFQb2ludFRvVmlld1BvaW50KGRhdGFQb2ludCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU3dpdGNoIHRoZSBjdXJzb3IgZm9yIGEgZ3JpZCBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gY3Vyc29yTmFtZSAtIEEgd2VsbCBrbm93IGN1cnNvciBuYW1lLlxuICAgICAqIEBzZWUgW2N1cnNvciBuYW1lc10oaHR0cDovL3d3dy5qYXZhc2NyaXB0ZXIubmV0L2ZhcS9zdHlsZXNjLmh0bSlcbiAgICAgKi9cbiAgICBiZUN1cnNvcjogZnVuY3Rpb24oY3Vyc29yTmFtZSkge1xuICAgICAgICBpZiAoIWN1cnNvck5hbWUpIHtcbiAgICAgICAgICAgIGN1cnNvck5hbWUgPSBbJ2RlZmF1bHQnXTtcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShjdXJzb3JOYW1lKSkge1xuICAgICAgICAgICAgY3Vyc29yTmFtZSA9IFtjdXJzb3JOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgICAgICAgIGN1cnNvck5hbWUuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBuYW1lO1xuICAgICAgICAgICAgfSwgdGhpcy5kaXYuc3R5bGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNodXQgZG93biB0aGUgY3VycmVudCBjZWxsIGVkaXRvciBhbmQgc2F2ZSB0aGUgZWRpdGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBPbmUgb2Y6XG4gICAgICogKiBgZmFsc2VgIC0gRWRpdGluZyBCVVQgY291bGQgbm90IGFib3J0LlxuICAgICAqICogYHRydWVgIC0gTm90IGVkaXRpbmcgT1Igd2FzIGVkaXRpbmcgQU5EIGFib3J0IHdhcyBzdWNjZXNzZnVsLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgc3RvcEVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY2VsbEVkaXRvciB8fCB0aGlzLmNlbGxFZGl0b3Iuc3RvcEVkaXRpbmcoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU2h1dCBkb3duIHRoZSBjdXJyZW50IGNlbGwgZWRpdG9yIHdpdGhvdXQgc2F2aW5nIHRoZSBlZGl0ZWQgdmFsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IE9uZSBvZjpcbiAgICAgKiAqIGBmYWxzZWAgLSBFZGl0aW5nIEJVVCBjb3VsZCBub3QgYWJvcnQuXG4gICAgICogKiBgdHJ1ZWAgLSBOb3QgZWRpdGluZyBPUiB3YXMgZWRpdGluZyBBTkQgYWJvcnQgd2FzIHN1Y2Nlc3NmdWwuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBjYW5jZWxFZGl0aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNlbGxFZGl0b3IgfHwgdGhpcy5jZWxsRWRpdG9yLmNhbmNlbEVkaXRpbmcoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2l2ZSBjZWxsIGVkaXRvciBvcHBvcnR1bml0eSB0byBjYW5jZWwgKG9yIHNvbWV0aGluZykgaW5zdGVhZCBvZiBzdG9wIC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gT25lIG9mOlxuICAgICAqICogYGZhbHNlYCAtIEVkaXRpbmcgQlVUIGNvdWxkIG5vdCBhYm9ydC5cbiAgICAgKiAqIGB0cnVlYCAtIE5vdCBlZGl0aW5nIE9SIHdhcyBlZGl0aW5nIEFORCBhYm9ydCB3YXMgc3VjY2Vzc2Z1bC5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIGFib3J0RWRpdGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jZWxsRWRpdG9yIHx8IChcbiAgICAgICAgICAgIHRoaXMuY2VsbEVkaXRvci5hYm9ydEVkaXRpbmcgPyB0aGlzLmNlbGxFZGl0b3IuYWJvcnRFZGl0aW5nKCkgOiB0aGlzLmNlbGxFZGl0b3Iuc3RvcEVkaXRpbmcoKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IFRoZSBwaXhlbCBjb29yZGluYXRlcyBvZiBqdXN0IHRoZSBjZW50ZXIgJ21haW5cIiBkYXRhIGFyZWEuXG4gICAgICovXG4gICAgZ2V0RGF0YUJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5jYW52YXMuYm91bmRzO1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSgwLCAwLCBiLm9yaWdpbi54ICsgYi5leHRlbnQueCwgYi5vcmlnaW4ueSArIGIuZXh0ZW50LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IE9wZW4gdGhlIGNlbGwtZWRpdG9yIGZvciB0aGUgY2VsbCBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR9IGV2ZW50IC0gQ29vcmRpbmF0ZXMgb2YgXCJlZGl0IHBvaW50XCIgKGdyaWRDZWxsLngsIGRhdGFDZWxsLnkpLlxuICAgICAqIEByZXR1cm4ge3VuZGVmaW5lZHxDZWxsRWRpdG9yfSBUaGUgY2VsbEVkaXRvciBkZXRlcm1pbmVkIGZyb20gdGhlIGNlbGwncyByZW5kZXIgcHJvcGVydGllcywgd2hpY2ggbWF5IGJlIG1vZGlmaWVkIGJ5IGxvZ2ljIGFkZGVkIGJ5IG92ZXJyaWRpbmcge0BsaW5rIERhdGFNb2RlbCNnZXRDZWxsRWRpdG9yQXR8Z2V0Q2VsbEVkaXRvckF0fS5cbiAgICAgKi9cbiAgICBlZGl0QXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBjZWxsRWRpdG9yO1xuXG4gICAgICAgIHRoaXMuYWJvcnRFZGl0aW5nKCk7IC8vIGlmIGFub3RoZXIgZWRpdG9yIGlzIG9wZW4sIGNsb3NlIGl0IGZpcnN0XG5cbiAgICAgICAgbGV0IGVkaXRhYmxlWCA9IGV2ZW50LmRhdGFDZWxsLngsIGVkaXRhYmxlWSA9IGV2ZW50LmRhdGFDZWxsLnk7XG5cbiAgICAgICAgaWYgKGV2ZW50LmlzQ29sc3BhbmVkQnlMZWZ0Q29sdW1uICYmIGV2ZW50LmNvbHNwYW5NYWluQ29sdW1uTmFtZSkge1xuICAgICAgICAgICAgbGV0IG1haW5Db2x1bW4gPSB0aGlzLmJlaGF2aW9yLmdldEhlYWRlckNvbHVtbkJ5TmFtZShldmVudC5jb2xzcGFuTWFpbkNvbHVtbk5hbWUpO1xuICAgICAgICAgICAgbGV0IG1haW5Db2x1bW5JbmRleCA9IHRoaXMuYmVoYXZpb3IuY29sdW1ucy5pbmRleE9mKG1haW5Db2x1bW4pO1xuXG4gICAgICAgICAgICBpZiAobWFpbkNvbHVtbiAmJiBtYWluQ29sdW1uSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBlZGl0YWJsZVggPSBtYWluQ29sdW1uSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LnJvd3NwYW5NYWluUm93ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQucm93c3Bhbk1haW5Sb3cgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGVkaXRhYmxlWSA9IGV2ZW50LnJvd3NwYW5NYWluUm93O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVkaXRhYmxlWCAhPT0gZXZlbnQuZGF0YUNlbGwueCB8fCBlZGl0YWJsZVkgIT09IGV2ZW50LmRhdGFDZWxsLnkpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9NYWtlVmlzaWJsZShlZGl0YWJsZVgsIGVkaXRhYmxlWSk7XG4gICAgICAgICAgICB0aGlzLnBhaW50Tm93KCk7XG4gICAgICAgICAgICBldmVudCA9IG5ldyB0aGlzLmJlaGF2aW9yLkNlbGxFdmVudChlZGl0YWJsZVgsIGVkaXRhYmxlWSArIHRoaXMuZ2V0SGVhZGVyUm93Q291bnQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBldmVudC5pc0RhdGFDb2x1bW4gJiZcbiAgICAgICAgICAgIChjZWxsRWRpdG9yID0gdGhpcy5nZXRDZWxsRWRpdG9yQXQoZXZlbnQpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBuZWVkZWRWaXNpYmlsaXR5UHJvcCA9IGV2ZW50LmlzRGF0YVJvdyA/ICdlZGl0YWJsZScgOiAnZmlsdGVyYWJsZSc7XG4gICAgICAgICAgICB2YXIgaXNFZGl0YWJsZSA9IGV2ZW50LnJvd1Byb3BlcnRpZXNbbmVlZGVkVmlzaWJpbGl0eVByb3BdID9cbiAgICAgICAgICAgICAgICBldmVudC5yb3dQcm9wZXJ0aWVzW25lZWRlZFZpc2liaWxpdHlQcm9wXSA6XG4gICAgICAgICAgICAgICAgZXZlbnQucHJvcGVydGllc1tuZWVkZWRWaXNpYmlsaXR5UHJvcF07XG5cbiAgICAgICAgICAgIGlmIChpc0VkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgY2VsbEVkaXRvci5iZWdpbkVkaXRpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2VsbEVkaXRvci5zaG93UmVhZG9ubHlFZGl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2VsbEVkaXRvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXggLSBUaGUgY29sdW1uIGluZGV4IGluIHF1ZXN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY29sdW1uIGlzIGZ1bGx5IHZpc2libGUuXG4gICAgICovXG4gICAgaXNDb2x1bW5WaXNpYmxlOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5pc0NvbHVtblZpc2libGUoY29sdW1uSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByIC0gVGhlIHJhdyByb3cgaW5kZXggaW4gcXVlc3Rpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiByb3cgaXMgZnVsbHkgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpc0RhdGFSb3dWaXNpYmxlOiBmdW5jdGlvbihyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmlzRGF0YVJvd1Zpc2libGUocik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGMgLSBUaGUgY29sdW1uIGluZGV4IGluIHF1ZXN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBybiAtIFRoZSBncmlkIHJvdyBpbmRleCBpbiBxdWVzdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGdpdmVuIGNlbGwgaXMgZnVsbHkgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpc0RhdGFWaXNpYmxlOiBmdW5jdGlvbihjLCBybikge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0RhdGFSb3dWaXNpYmxlKHJuKSAmJiB0aGlzLmlzQ29sdW1uVmlzaWJsZShjKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAc3VtbWFyeSBTY3JvbGwgaW4gdGhlIGBvZmZzZXRYYCBkaXJlY3Rpb24gaWYgY29sdW1uIGluZGV4IGBjb2xJbmRleGAgaXMgbm90IHZpc2libGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4IC0gVGhlIGNvbHVtbiBpbmRleCBpbiBxdWVzdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIFRoZSBkaXJlY3Rpb24gYW5kIG1hZ25pdHVkZSB0byBzY3JvbGwgaWYgd2UgbmVlZCB0by5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBDb2x1bW4gaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpbnN1cmVNb2RlbENvbElzVmlzaWJsZTogZnVuY3Rpb24oY29sSW5kZXgsIG9mZnNldFgpIHtcbiAgICAgICAgY29uc3QgbWF4Q29scyA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSAtIDE7IC8vIC0xIGV4Y2x1ZGVzIHBhcnRpYWxseSB2aXNpYmxlIGNvbHVtbnNcbiAgICAgICAgY29uc3QgaW5kZXhUb0NoZWNrID0gY29sSW5kZXggKyBNYXRoLnNpZ24ob2Zmc2V0WCk7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc0NvbHVtblZpc2libGUoaW5kZXhUb0NoZWNrKSB8fCBjb2xJbmRleCA9PT0gbWF4Q29scztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAc3VtbWFyeSBTY3JvbGwgaW4gdGhlIGBvZmZzZXRZYCBkaXJlY3Rpb24gaWYgY29sdW1uIGluZGV4IGMgaXMgbm90IHZpc2libGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gVGhlIGNvbHVtbiBpbmRleCBpbiBxdWVzdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIFRoZSBkaXJlY3Rpb24gYW5kIG1hZ25pdHVkZSB0byBzY3JvbGwgaWYgd2UgbmVlZCB0by5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSb3cgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpbnN1cmVNb2RlbFJvd0lzVmlzaWJsZTogZnVuY3Rpb24ocm93SW5kZXgsIG9mZnNldFkpIHtcbiAgICAgICAgY29uc3QgbWF4Um93cyA9IHRoaXMuZ2V0Um93Q291bnQoKSAtIDE7IC8vIC0xIGV4Y2x1ZGVzIHBhcnRpYWxseSB2aXNpYmxlIHJvd3NcbiAgICAgICAgY29uc3Qgc2Nyb2xsT2Zmc2V0ID0gKG9mZnNldFkgPiAtMSkgPyAyIDogMDsgLy8gMiB0byBrZWVwIG9uZSBibGFuayBsaW5lIGJlbG93IGFjdGl2ZSBjZWxsLCAwIHRvIGtlZXAgemVybyBsaW5lcyBhYm92ZSBhY3RpdmUgY2VsbFxuICAgICAgICBjb25zdCBpbmRleFRvQ2hlY2sgPSByb3dJbmRleCArIHNjcm9sbE9mZnNldDtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzRGF0YVJvd1Zpc2libGUoaW5kZXhUb0NoZWNrKSB8fCByb3dJbmRleCA9PT0gbWF4Um93cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAc3VtbWFyeSBTY3JvbGwgaG9yaXpvbnRhbCBhbmQgdmVydGljYWxseSBieSB0aGUgcHJvdmlkZWQgb2Zmc2V0cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIFNjcm9sbCBpbiB0aGUgeCBkaXJlY3Rpb24gdGhpcyBtdWNoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0gU2Nyb2xsIGluIHRoZSB5IGRpcmVjdGlvbiB0aGlzIG11Y2guXG4gICAgICovXG4gICAgc2Nyb2xsQnk6IGZ1bmN0aW9uKG9mZnNldFgsIG9mZnNldFkpIHtcbiAgICAgICAgLy8gT1ZFUlJJREVEIEJZIHNjcm9sbGluZy5qcyBGSUxFXG4gICAgICAgIHRoaXMuc2Nyb2xsSEJ5KG9mZnNldFgpO1xuICAgICAgICB0aGlzLnNjcm9sbFZCeShvZmZzZXRZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAc3VtbWFyeSBTY3JvbGwgdmVydGljYWxseSBieSB0aGUgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0gU2Nyb2xsIGluIHRoZSB5IGRpcmVjdGlvbiB0aGlzIG11Y2guXG4gICAgICovXG4gICAgc2Nyb2xsVkJ5OiBmdW5jdGlvbihvZmZzZXRZKSB7XG4gICAgICAgIC8vIE9WRVJSSURFRCBCWSBzY3JvbGxpbmcuanMgRklMRVxuICAgICAgICB2YXIgbWF4ID0gdGhpcy5zYlZTY3JvbGxlci5yYW5nZS5tYXg7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudlNjcm9sbFZhbHVlO1xuICAgICAgICB2YXIgb2xkT2Zmc2V0ID0gdGhpcy5nZXRWU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gTWF0aC5taW4obWF4LCBvbGRWYWx1ZSArIG9mZnNldFkgKiB0aGlzLmJlaGF2aW9yLmdldFJvd0hlaWdodChNYXRoLm1heCgwLCBvbGRPZmZzZXQgKyBvZmZzZXRZKSkpO1xuICAgICAgICBpZiAobmV3VmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZTY3JvbGxWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAc3VtbWFyeSBTY3JvbGwgaG9yaXpvbnRhbGx5IGJ5IHRoZSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSBTY3JvbGwgaW4gdGhlIHggZGlyZWN0aW9uIHRoaXMgbXVjaC5cbiAgICAgKi9cbiAgICBzY3JvbGxIQnk6IGZ1bmN0aW9uKG9mZnNldFgpIHtcbiAgICAgICAgLy8gT1ZFUlJJREVEIEJZIHNjcm9sbGluZy5qcyBGSUxFXG4gICAgICAgIHZhciBtYXggPSB0aGlzLnNiSFNjcm9sbGVyLnJhbmdlLm1heDtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5oU2Nyb2xsVmFsdWU7XG4gICAgICAgIHZhciBvbGRPZmZzZXQgPSB0aGlzLmdldEhTY3JvbGxWYWx1ZSgpO1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSBNYXRoLm1pbihtYXgsIG9sZFZhbHVlICsgb2Zmc2V0WCAqIHRoaXMuYmVoYXZpb3IuZ2V0Q29sdW1uV2lkdGgoTWF0aC5tYXgoMCwgb2xkT2Zmc2V0ICsgb2Zmc2V0WCkpKTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRIU2Nyb2xsVmFsdWUobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNjcm9sbFRvTWFrZVZpc2libGU6IGZ1bmN0aW9uKGNvbHVtbiwgcm93KSB7XG4gICAgICAgIHZhciBkZWx0YSxcbiAgICAgICAgICAgIGR3ID0gdGhpcy5yZW5kZXJlci5kYXRhV2luZG93LFxuICAgICAgICAgICAgZml4ZWRDb2x1bW5Db3VudCA9IHRoaXMucHJvcGVydGllcy5maXhlZENvbHVtbkNvdW50LFxuICAgICAgICAgICAgZml4ZWRSb3dDb3VudCA9IHRoaXMucHJvcGVydGllcy5maXhlZFJvd0NvdW50O1xuXG4gICAgICAgIC8vIHNjcm9sbCBvbmx5IGlmIHRhcmdldCBub3QgaW4gZml4ZWQgY29sdW1uc1xuICAgICAgICBpZiAoY29sdW1uID49IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIC8vIHRhcmdldCBpcyB0byBsZWZ0IG9mIHNjcm9sbGFibGUgY29sdW1uczsgbmVnYXRpdmUgZGVsdGEgc2Nyb2xscyBsZWZ0XG4gICAgICAgICAgICBpZiAoKGRlbHRhID0gY29sdW1uIC0gZHcub3JpZ2luLngpIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIuaW5kZXggKz0gZGVsdGE7XG5cbiAgICAgICAgICAgICAgICAvLyB0YXJnZXQgaXMgdG8gcmlnaHQgb2Ygc2Nyb2xsYWJsZSBjb2x1bW5zOyBwb3NpdGl2ZSBkZWx0YSBzY3JvbGxzIHJpZ2h0XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogVGhlICsxIGZvcmNlcyByaWdodC1tb3N0IGNvbHVtbiB0byBzY3JvbGwgbGVmdCAoanVzdCBpbiBjYXNlIGl0IHdhcyBvbmx5IHBhcnRpYWxseSBpbiB2aWV3KVxuICAgICAgICAgICAgfSBlbHNlIGlmICgoY29sdW1uIC0gZHcuY29ybmVyLnggKyAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNiSFNjcm9sbGVyLmluZGV4ID0gdGhpcy5yZW5kZXJlci5nZXRNaW5pbXVtTGVmdFBvc2l0aW9uVG9TaG93Q29sdW1uKGNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICByb3cgPj0gZml4ZWRSb3dDb3VudCAmJiAvLyBzY3JvbGwgb25seSBpZiB0YXJnZXQgbm90IGluIGZpeGVkIHJvd3NcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAvLyB0YXJnZXQgaXMgYWJvdmUgc2Nyb2xsYWJsZSByb3dzOyBuZWdhdGl2ZSBkZWx0YSBzY3JvbGxzIHVwXG4gICAgICAgICAgICAgICAgKGRlbHRhID0gcm93IC0gZHcub3JpZ2luLnkpIDwgMCB8fFxuXG4gICAgICAgICAgICAgICAgLy8gdGFyZ2V0IGlzIGJlbG93IHNjcm9sbGFibGUgcm93czsgcG9zaXRpdmUgZGVsdGEgc2Nyb2xscyBkb3duXG4gICAgICAgICAgICAgICAgKGRlbHRhID0gcm93IC0gZHcuY29ybmVyLnkpID4gMFxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc2JWU2Nyb2xsZXIuaW5kZXggKz0gZGVsdGE7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VsZWN0Q2VsbEFuZFNjcm9sbFRvTWFrZVZpc2libGU6IGZ1bmN0aW9uKGMsIHIpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUb01ha2VWaXNpYmxlKGMsIHIpO1xuICAgICAgICB0aGlzLnNlbGVjdENlbGwoYywgciwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHN1bW1hcnkgQW5zd2VyIHdoaWNoIGRhdGEgY2VsbCBpcyB1bmRlciBhIHBpeGVsIHZhbHVlIG1vdXNlIHBvaW50LlxuICAgICAqIEBwYXJhbSB7bW91c2VQb2ludH0gbW91c2UgLSBUaGUgbW91c2UgcG9pbnQgdG8gaW50ZXJyb2dhdGUuXG4gICAgICovXG5cbiAgICBnZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50OiBmdW5jdGlvbihtb3VzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQb2ludH0gZ3JpZENlbGwgLSBUaGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIG1vdXNlIGluIHBoeXNpY2FsIGdyaWQgY29vcmRpbmF0ZXMuXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gVGhlIHBpeGVsIGJhc2VkIGJvdW5kcyByZWN0YW5nbGUgZ2l2ZW4gYSBkYXRhIGNlbGwgcG9pbnQuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBnZXRCb3VuZHNPZkNlbGw6IGZ1bmN0aW9uKGdyaWRDZWxsKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5yZW5kZXJlci5nZXRCb3VuZHNPZkNlbGwoZ3JpZENlbGwueCwgZ3JpZENlbGwueSk7XG5cbiAgICAgICAgLy9jb252ZXJ0IHRvIGEgcHJvcGVyIHJlY3RhbmdsZVxuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShiLngsIGIueSwgYi53aWR0aCwgYi5oZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSBmaW4tY2FudmFzIHdoZW4gYSByZXNpemUgb2NjdXJzLlxuICAgICAqL1xuICAgIHJlc2l6ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yU2hhcGVDaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIGludGVyY2VwdCBsaW5rIGNsaWNrcywgb3ZlcnJpZGUgdGhpcyBtZXRob2QgKGVpdGhlciBvbiB0aGUgcHJvdG90eXBlIHRvIGFwcGx5IHRvIGFsbCBncmlkIGluc3RhbmNlcyBvciBvbiBhbiBpbnN0YW5jZSB0byBhcHBseSB0byBhIHNwZWNpZmljIGdyaWQgaW5zdGFuY2UpLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgd2luZG93T3BlbjogZnVuY3Rpb24odXJsLCBuYW1lLCBmZWF0dXJlcywgcmVwbGFjZSkge1xuICAgICAgICByZXR1cm4gd2luZG93Lm9wZW4uYXBwbHkod2luZG93LCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2JlZ2luXVxuICAgICAqIEBwYXJhbSB7bnVibWVyfSBbZW5kXVxuICAgICAqICogQHJldHVybnMge0NvbHVtbltdfSBBIGNvcHkgb2YgdGhlIGFsbCBjb2x1bW5zIGFycmF5IGJ5IHBhc3NpbmcgdGhlIHBhcmFtcyB0byBgQXJyYXkucHJvdG90eXBlLnNsaWNlYC5cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5zOiBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XG4gICAgICAgIHZhciBjb2x1bW5zID0gdGhpcy5iZWhhdmlvci5nZXRDb2x1bW5zKCk7XG4gICAgICAgIHJldHVybiBjb2x1bW5zLnNsaWNlLmFwcGx5KGNvbHVtbnMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYmVnaW5dXG4gICAgICogQHBhcmFtIHtudWJtZXJ9IFtlbmRdXG4gICAgICogKiBAcmV0dXJucyB7Q29sdW1uW119IEEgY29weSBvZiB0aGUgYWN0aXZlIGNvbHVtbnMgYXJyYXkgYnkgcGFzc2luZyB0aGUgcGFyYW1zIHRvIGBBcnJheS5wcm90b3R5cGUuc2xpY2VgLlxuICAgICAqL1xuICAgIGdldEFjdGl2ZUNvbHVtbnM6IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcbiAgICAgICAgdmFyIGNvbHVtbnMgPSB0aGlzLmJlaGF2aW9yLmdldEFjdGl2ZUNvbHVtbnMoKTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbnMuc2xpY2UuYXBwbHkoY29sdW1ucywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgZ2V0SGlkZGVuQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vQSBub24gaW4tbWVtb3J5IGJlaGF2aW9yIHdpbGwgYmUgbW9yZSB0cm91Ymxlc29tZVxuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRIaWRkZW5Db2x1bW5zKCk7XG4gICAgfSxcblxuICAgIGlzVmlld2FibGVCdXR0b246IGZ1bmN0aW9uKGMsIHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuaXNWaWV3YWJsZUJ1dHRvbihjLCByKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBSZXF1ZXN0IGlucHV0IGZvY3VzLlxuICAgICAqL1xuICAgIHRha2VGb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB3YXNDZWxsRWRpdG9yID0gdGhpcy5jZWxsRWRpdG9yO1xuICAgICAgICB0aGlzLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgIGlmICghd2FzQ2VsbEVkaXRvcikge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMudGFrZUZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBSZXF1ZXN0IGZvY3VzIGZvciBvdXIgY2VsbCBlZGl0b3IuXG4gICAgICovXG4gICAgZWRpdG9yVGFrZUZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2VsbEVkaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbEVkaXRvci50YWtlRm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIEluaXRpYWxpemUgdGhlIHNjcm9sbCBiYXJzLlxuICAgICAqL1xuICAgIGluaXRTY3JvbGxiYXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2JIU2Nyb2xsZXIgJiYgdGhpcy5zYlZTY3JvbGxlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIFNjcm9sbGJhciA9IEh5cGVyZ3JpZC5tb2R1bGVzLnNjcm9sbGJhcjtcblxuICAgICAgICB2YXIgaG9yekJhciA9IG5ldyBTY3JvbGxiYXIoe1xuICAgICAgICAgICAgb3JpZW50YXRpb246ICdob3Jpem9udGFsJyxcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLnNldEhTY3JvbGxWYWx1ZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgY3NzU3R5bGVzaGVldFJlZmVyZW5jZUVsZW1lbnQ6IHRoaXMuZGl2XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB2ZXJ0QmFyID0gbmV3IFNjcm9sbGJhcih7XG4gICAgICAgICAgICBvcmllbnRhdGlvbjogJ3ZlcnRpY2FsJyxcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLnNldFZTY3JvbGxWYWx1ZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgcGFnaW5nOiB7XG4gICAgICAgICAgICAgICAgdXA6IHRoaXMucGFnZVVwLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgZG93bjogdGhpcy5wYWdlRG93bi5iaW5kKHRoaXMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIgPSBob3J6QmFyO1xuICAgICAgICB0aGlzLnNiVlNjcm9sbGVyID0gdmVydEJhcjtcblxuICAgICAgICB2YXIgaFByZWZpeCA9IHRoaXMucHJvcGVydGllcy5oU2Nyb2xsYmFyQ2xhc3NQcmVmaXg7XG4gICAgICAgIHZhciB2UHJlZml4ID0gdGhpcy5wcm9wZXJ0aWVzLnZTY3JvbGxiYXJDbGFzc1ByZWZpeDtcblxuICAgICAgICBpZiAoaFByZWZpeCAmJiBoUHJlZml4ICE9PSAnJykge1xuICAgICAgICAgICAgdGhpcy5zYkhTY3JvbGxlci5jbGFzc1ByZWZpeCA9IGhQcmVmaXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodlByZWZpeCAmJiB2UHJlZml4ICE9PSAnJykge1xuICAgICAgICAgICAgdGhpcy5zYlZTY3JvbGxlci5jbGFzc1ByZWZpeCA9IHZQcmVmaXg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZChob3J6QmFyLmJhcik7XG4gICAgICAgIHRoaXMuZGl2LmFwcGVuZENoaWxkKHZlcnRCYXIuYmFyKTtcblxuICAgICAgICB0aGlzLnN5bmNocm9uaXplU2Nyb2xsYmFyc1Zpc3VhbGl6YXRpb24oKTtcbiAgICB9LFxuXG4gICAgc3luY2hyb25pemVTY3JvbGxiYXJzVmlzdWFsaXphdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIuc2hvcnRlbkJ5KHRoaXMuc2JWU2Nyb2xsZXIpLnJlc2l6ZSgpO1xuICAgICAgICAvL3RoaXMuc2JWU2Nyb2xsZXIuc2hvcnRlbkJ5KHRoaXMuc2JIU2Nyb2xsZXIpO1xuICAgICAgICB0aGlzLnNiVlNjcm9sbGVyLnJlc2l6ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFNjcm9sbCB2YWx1ZXMgaGF2ZSBjaGFuZ2VkLCB3ZSd2ZSBiZWVuIG5vdGlmaWVkLlxuICAgICAqL1xuICAgIHNldFZTY3JvbGxiYXJWYWx1ZXM6IGZ1bmN0aW9uKG1heCkge1xuICAgICAgICB0aGlzLnNiVlNjcm9sbGVyLnJhbmdlID0ge1xuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiBtYXhcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgc2V0SFNjcm9sbGJhclZhbHVlczogZnVuY3Rpb24obWF4KSB7XG4gICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIucmFuZ2UgPSB7XG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBtYXg6IG1heFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBzY3JvbGxWYWx1ZUNoYW5nZWROb3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmhTY3JvbGxWYWx1ZSAhPT0gdGhpcy5zYlByZXZIU2Nyb2xsVmFsdWUgfHxcbiAgICAgICAgICAgIHRoaXMudlNjcm9sbFZhbHVlICE9PSB0aGlzLnNiUHJldlZTY3JvbGxWYWx1ZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc2JQcmV2SFNjcm9sbFZhbHVlID0gdGhpcy5oU2Nyb2xsVmFsdWU7XG4gICAgICAgICAgICB0aGlzLnNiUHJldlZTY3JvbGxWYWx1ZSA9IHRoaXMudlNjcm9sbFZhbHVlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jZWxsRWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jZWxsRWRpdG9yLnNjcm9sbFZhbHVlQ2hhbmdlZE5vdGlmaWNhdGlvbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVDZWxsc0JvdW5kcygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHN1bW1hcnkgR2V0IGRhdGEgdmFsdWUgYXQgZ2l2ZW4gY2VsbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgdmVydGljYWwgY29vcmRpbmF0ZS5cbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRWYWx1ZS5hcHBseSh0aGlzLmJlaGF2aW9yLCBhcmd1bWVudHMpOyAvLyBtdXN0IHVzZSAuYXBwbHkgKHNlZSB0aGlzLmJlaGF2aW9yLmdldFZhbHVlKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IFNldCBhIGRhdGEgdmFsdWUgb2YgYSBnaXZlbiBjZWxsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBOZXcgY2VsbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5zZXRWYWx1ZS5hcHBseSh0aGlzLmJlaGF2aW9yLCBhcmd1bWVudHMpOyAvLyBtdXN0IHVzZSAuYXBwbHkgKHNlZSB0aGlzLmJlaGF2aW9yLnNldFZhbHVlKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIE5vdGUgdGhhdCBcInZpZXdhYmxlIGNvbHVtbnNcIiBpbmNsdWRlcyBhbnkgcGFydGlhbGx5IHZpZXdhYmxlIGNvbHVtbnMuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiB2aWV3YWJsZSBjb2x1bW5zLlxuICAgICAqL1xuICAgIGdldFZpc2libGVDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0VmlzaWJsZUNvbHVtbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAc3VtbWFyeSBJbml0aWFsaXplIHRoZSByZW5kZXJlciBzdWItY29tcG9uZW50LlxuICAgICAqL1xuICAgIGluaXRSZW5kZXJlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyIHx8IG5ldyBSZW5kZXJlcih0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIGdpdmVuIGNvbHVtbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXggLSBUaGUgdW50cmFuc2xhdGVkIGNvbHVtbiBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5XaWR0aDogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Q29sdW1uV2lkdGgoY29sdW1uSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFNldCB0aGUgd2lkdGggb2YgdGhlIGdpdmVuIGNvbHVtbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXggLSBUaGUgdW50cmFuc2xhdGVkIGNvbHVtbiBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uV2lkdGggLSBUaGUgd2lkdGggaW4gcGl4ZWxzLlxuICAgICAqL1xuICAgIHNldENvbHVtbldpZHRoOiBmdW5jdGlvbihjb2x1bW5JbmRleCwgY29sdW1uV2lkdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWJvcnRFZGl0aW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0Q29sdW1uV2lkdGgoY29sdW1uSW5kZXgsIGNvbHVtbldpZHRoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB0b3RhbCB3aWR0aCBvZiBhbGwgdGhlIGZpeGVkIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRDb2x1bW5zV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRGaXhlZENvbHVtbnNXaWR0aCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBoZWlnaHQgb2YgdGhlIGdpdmVuIHJvd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIFRoZSB1bnRyYW5zbGF0ZWQgZml4ZWQgY29sdW1uIGluZGV4LlxuICAgICAqL1xuICAgIGdldFJvd0hlaWdodDogZnVuY3Rpb24ocm93SW5kZXgsIGRhdGFNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRSb3dIZWlnaHQocm93SW5kZXgsIGRhdGFNb2RlbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHJldHVybnMge251bWJlcn0gY291bnQgb2Ygcm93cywgdGhhdCB1c2VkIGFzIGZpY3RpdmUgaGVhZGVyc1xuICAgICAqL1xuICAgIGdldEZpY3RpdmVIZWFkZXJSb3dzQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRGaWN0aXZlSGVhZGVyUm93c0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU2V0IHRoZSBoZWlnaHQgb2YgdGhlIGdpdmVuIHJvdy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUaGUgcm93IGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dIZWlnaHQgLSBUaGUgd2lkdGggaW4gcGl4ZWxzLlxuICAgICAqL1xuICAgIHNldFJvd0hlaWdodDogZnVuY3Rpb24ocm93SW5kZXgsIHJvd0hlaWdodCwgZGF0YU1vZGVsKSB7XG4gICAgICAgIGlmICh0aGlzLmFib3J0RWRpdGluZygpKSB7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yLnNldFJvd0hlaWdodChyb3dJbmRleCwgcm93SGVpZ2h0LCBkYXRhTW9kZWwpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHRvdGFsIGZpeGVkIHJvd3MgaGVpZ2h0XG4gICAgICovXG4gICAgZ2V0Rml4ZWRSb3dzSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Rml4ZWRSb3dzSGVpZ2h0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBfdmlzaWJsZV8gY29sdW1ucy5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY29sdW1ucy5cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldEFjdGl2ZUNvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiByb3dzLlxuICAgICAqL1xuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Um93Q291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGZpeGVkIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGZpeGVkIHJvd3MuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldEZpeGVkUm93Q291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAc3VtbWFyeSBUaGUgdG9wIGxlZnQgYXJlYSBoYXMgYmVlbiBjbGlja2VkIG9uXG4gICAgICogQGRlc2MgRGVsZWdhdGVzIHRvIHRoZSBiZWhhdmlvci5cbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBtb3VzZSAtIFRoZSBldmVudCBkZXRhaWxzLlxuICAgICAqL1xuICAgIHRvcExlZnRDbGlja2VkOiBmdW5jdGlvbihtb3VzZSkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLnRvcExlZnRDbGlja2VkKHRoaXMsIG1vdXNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAc3VtbWFyeSBBIGZpeGVkIHJvdyBoYXMgYmVlbiBjbGlja2VkLlxuICAgICAqIEBkZXNjIERlbGVnYXRlcyB0byB0aGUgYmVoYXZpb3IuXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgZGV0YWlscy5cbiAgICAgKi9cbiAgICByb3dIZWFkZXJDbGlja2VkOiBmdW5jdGlvbihtb3VzZSkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLnJvd0hlYWRlckNsaWNrZWQodGhpcywgbW91c2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IEEgZml4ZWQgY29sdW1uIGhhcyBiZWVuIGNsaWNrZWQuXG4gICAgICogQGRlc2MgRGVsZWdhdGVzIHRvIHRoZSBiZWhhdmlvci5cbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBldmVudCAtIFRoZSBldmVudCBkZXRhaWxzLlxuICAgICAqL1xuICAgIGNvbHVtbkhlYWRlckNsaWNrZWQ6IGZ1bmN0aW9uKG1vdXNlKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IuY29sdW1uSGVhZGVyQ2xpY2tlZCh0aGlzLCBtb3VzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgQW4gZWRpdCBldmVudCBoYXMgb2NjdXJyZWQuIEFjdGl2YXRlIHRoZSBlZGl0b3IgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC5ncmlkQ2VsbC54IC0gVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQuZ3JpZENlbGwueSAtIFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V2ZW50LnByaW1pdGl2ZUV2ZW50LnR5cGVdXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZHxDZWxsRWRpdG9yfSBUaGUgZWRpdG9yIG9iamVjdCBvciBgdW5kZWZpbmVkYCBpZiBubyBlZGl0b3Igb3IgZWRpdG9yIGFscmVhZHkgb3Blbi5cbiAgICAgKi9cbiAgICBvbkVkaXRvckFjdGl2YXRlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0QXQoZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgY2VsbCBlZGl0b3IuXG4gICAgICogQGRlc2MgRGVsZWdhdGVzIHRvIHRoZSBiZWhhdmlvci5cbiAgICAgKiBAcmV0dXJucyBUaGUgY2VsbCBlZGl0b3IgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGNlbGxFdmVudCAtIFRoZSBncmlkIGNlbGwgY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgZ2V0Q2VsbEVkaXRvckF0OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRDZWxsRWRpdG9yQXQoZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IFRvZ2dsZSBIaURQSSBzdXBwb3J0LlxuICAgICAqIEBkZXNjIEhpRFBJIHN1cHBvcnQgaXMgbm93ICpvbiogYnkgZGVmYXVsdC5cbiAgICAgKiA+IFRoZXJlIHVzZWQgdG8gYmUgYSBidWcgaW4gQ2hyb21lIHRoYXQgY2F1c2VkIHNldmVyZSBzbG93IGRvd24gb24gYml0IGJsaXQgb2YgbGFyZ2UgaW1hZ2VzLCBzbyB0aGlzIEhpRFBJIG5lZWRlZCB0byBiZSBvcHRpb25hbC5cbiAgICAgKi9cbiAgICB0b2dnbGVIaURQSTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMudXNlSGlEUEkpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdoaWRwaScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2hpZHBpJywgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW52YXMucmVzaXplKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIEhpRFBJIHJhdGlvLlxuICAgICAqL1xuICAgIGdldEhpRFBJOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICYmIHRoaXMucHJvcGVydGllcy51c2VIaURQSSkge1xuICAgICAgICAgICAgdmFyIGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxuICAgICAgICAgICAgICAgIGJhY2tpbmdTdG9yZVJhdGlvID0gY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgICAgICBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSxcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSBnaXZlbiAocmVjZW50bHkgcmVuZGVyZWQpIGNvbHVtbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sSW5kZXggLSBUaGUgY29sdW1uIGluZGV4LlxuICAgICAqL1xuICAgIGdldFJlbmRlcmVkV2lkdGg6IGZ1bmN0aW9uKGNvbEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldFJlbmRlcmVkV2lkdGgoY29sSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBoZWlnaHQgb2YgdGhlIGdpdmVuIChyZWNlbnRseSByZW5kZXJlZCkgcm93LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIFRoZSByb3cgaW5kZXguXG4gICAgICovXG4gICAgZ2V0UmVuZGVyZWRIZWlnaHQ6IGZ1bmN0aW9uKHJvd0luZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldFJlbmRlcmVkSGVpZ2h0KHJvd0luZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBVcGRhdGUgdGhlIGN1cnNvciB1bmRlciB0aGUgaG92ZXIgY2VsbC5cbiAgICAgKi9cbiAgICB1cGRhdGVDdXJzb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3Vyc29yID0gdGhpcy5iZWhhdmlvci5nZXRDdXJzb3JBdCgtMSwgLTEpO1xuICAgICAgICB2YXIgaG92ZXJDZWxsID0gdGhpcy5ob3ZlckNlbGw7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGhvdmVyQ2VsbCAmJlxuICAgICAgICAgICAgaG92ZXJDZWxsLnggPiAtMSAmJlxuICAgICAgICAgICAgaG92ZXJDZWxsLnkgPiAtMVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciB4ID0gaG92ZXJDZWxsLnggKyB0aGlzLmdldEhTY3JvbGxWYWx1ZSgpO1xuICAgICAgICAgICAgY3Vyc29yID0gdGhpcy5iZWhhdmlvci5nZXRDdXJzb3JBdCh4LCBob3ZlckNlbGwueSArIHRoaXMuZ2V0VlNjcm9sbFZhbHVlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmVDdXJzb3IoY3Vyc29yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBSZXBhaW50IHRoZSBnaXZlbiBjZWxsLlxuICAgICAqIEBwYXJhbSB7eH0geCAtIFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHt5fSB5IC0gVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICovXG4gICAgcmVwYWludENlbGw6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZXBhaW50Q2VsbCh4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIHVzZXIgaXMgY3VycmVudGx5IGRyYWdnaW5nIGEgY29sdW1uIHRvIHJlb3JkZXIgaXQuXG4gICAgICovXG4gICAgaXNEcmFnZ2luZ0NvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0W119IE9iamVjdHMgd2l0aCB0aGUgdmFsdWVzIHRoYXQgd2VyZSBqdXN0IHJlbmRlcmVkLlxuICAgICAqL1xuICAgIGdldFJlbmRlcmVkRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldFZpc2libGVDZWxsTWF0cml4KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEF1dG9zaXplIGEgY29sdW1uIGZvciBiZXN0IGZpdC5cbiAgICAgKiBAcGFyYW0ge0NvbHVtbnxudW1iZXJ9IGNvbHVtbk9ySW5kZXggLSBUaGUgY29sdW1uIG9yIGFjdGl2ZSBjb2x1bW4gaW5kZXguXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBhdXRvc2l6ZUNvbHVtbjogZnVuY3Rpb24oY29sdW1uT3JJbmRleCkge1xuICAgICAgICB2YXIgY29sdW1uID0gY29sdW1uT3JJbmRleCA+PSAtMiA/IHRoaXMuYmVoYXZpb3IuZ2V0QWN0aXZlQ29sdW1uKGNvbHVtbk9ySW5kZXgpIDogY29sdW1uT3JJbmRleDtcbiAgICAgICAgY29sdW1uLmNoZWNrQ29sdW1uQXV0b3NpemluZyh0cnVlKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5maXRDb2x1bW4oY29sdW1uLCB0cnVlKTtcbiAgICAgICAgdGhpcy5jb21wdXRlQ2VsbHNCb3VuZHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBFbmFibGUvZGlzYWJsZSBpZiB0aGlzIGNvbXBvbmVudCBjYW4gcmVjZWl2ZSB0aGUgZm9jdXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSAtIGNhblJlY2VpdmVGb2N1c1xuICAgICAqL1xuICAgIHNldEZvY3VzYWJsZTogZnVuY3Rpb24oY2FuUmVjZWl2ZUZvY3VzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLnNldEZvY3VzYWJsZShjYW5SZWNlaXZlRm9jdXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY29sdW1ucyB0aGF0IHdlcmUganVzdCByZW5kZXJlZFxuICAgICAqL1xuICAgIGdldFZpc2libGVDb2x1bW5zQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRWaXNpYmxlQ29sdW1uc0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiByb3dzIHRoYXQgd2VyZSBqdXN0IHJlbmRlcmVkXG4gICAgICovXG4gICAgZ2V0VmlzaWJsZVJvd3NDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldFZpc2libGVSb3dzQ291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBVcGRhdGUgdGhlIHNpemUgb2YgYSBncmlkIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHVwZGF0ZVNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbnZhcy5jaGVja3NpemUoKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFN0b3AgdGhlIGdsb2JhbCByZXBhaW50aW5nIGZsYWcgdGhyZWFkLlxuICAgICAqL1xuICAgIHN0b3BQYWludFRocmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0b3BQYWludFRocmVhZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFN0b3AgdGhlIGdsb2JhbCByZXNpemUgY2hlY2sgZmxhZyB0aHJlYWQuXG4gICAgICovXG4gICAgc3RvcFJlc2l6ZVRocmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0b3BSZXNpemVUaHJlYWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBSZXN0YXJ0IHRoZSBnbG9iYWwgcmVzaXplIGNoZWNrIGZsYWcgdGhyZWFkLlxuICAgICAqL1xuICAgIHJlc3RhcnRSZXNpemVUaHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbnZhcy5yZXN0YXJ0UmVzaXplVGhyZWFkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgUmVzdGFydCB0aGUgZ2xvYmFsIHJlcGFpbnRpbmcgY2hlY2sgZmxhZyB0aHJlYWQuXG4gICAgICovXG4gICAgcmVzdGFydFBhaW50VGhyZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYW52YXMucmVzdGFydFBhaW50VGhyZWFkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIGNvbHVtbnMgZHJhZ2dpbmcgbm93IHBlcmZvcm1lZCBsaWtlIGluIGdvb2dsZSBzaGVldHMgKHBlcmZvcm1lZCBvbmx5IHdoZW4gdXNlciBzdG9wIGRyYWdnaW5nIG9uIG5ldyBwb3NpdGlvbilcbiAgICAgKi9cbiAgICBzd2FwQ29sdW1uczogZnVuY3Rpb24oc291cmNlLCB0YXJnZXQpIHtcbiAgICAgICAgLy9UdXJucyBvdXQgdGhpcyBpcyBjYWxsZWQgZHVyaW5nIGRyYWdnZWQgJ2kuZScgd2hlbiB0aGUgZmxvYXRlciBjb2x1bW4gaXMgcmVzaHVmZmxlZFxuICAgICAgICAvL2J5IHRoZSBjdXJyZW50bHkgZHJhZ2dlZCBjb2x1bW4uIFRoZSBjb2x1bW4gcG9zaXRpb25zIGFyZSBjb25zdGFudGx5IHJlc2h1ZmZsZWRcbiAgICAgICAgdGhpcy5iZWhhdmlvci5zd2FwQ29sdW1ucyhzb3VyY2UsIHRhcmdldCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHV0aWxpdHkgbWV0aG9kIHRvIHBlcmZvcm0gY29sdW1ucyByZW9yZGVyaW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZyb20gLSB2aXNpYmxlIGNvbHVtbnMgc3RhcnQgaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuIC0gbGVuZ3RoIG9mIGNvbHVtbnMgc2V0IHRvIHJlb3JkZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0IC0gbmV3IHN0YXJ0IGluZGV4IG9mIGFuIGNvbHVtbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW4/fSBicm9hZGNhc3RFdmVudCAtIG9wdGlvbmFsIHBhcmFtLiBJZiBzZXQgdG8gJ2ZhbHNlJywgc3ludGhldGljIGV2ZW50IHdpbGwgbm90IGJlIGZpcmVkLlxuICAgICAqIFVzZWZ1bCwgd2hlbiByZW9yZGVyaW5nIG5vdCBpbml0aWF0ZWQgYnkgdXNlciwgYW5kIGRvbid0IG5lZWQgdG8gYWZmZWN0IHNpZGUgZWZmZWN0c1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj99IGdpdmVuSGlkZGVuQ29sdW1ucyAtIGlmIHRydWUsIG1ldGhvZCBwZXJmb3JtZWQgbGlrZSBhbGwgdGhlIGNvbHVtbnMgaXMgc2hvd24gYW5kIGluZGV4ZXNcbiAgICAgKiBvZiB2aXNpYmxlIGNvbHVtbnMgYW5kIGFsbCBjb2x1bW5zIGFyZSBlcXVhbFxuICAgICAqL1xuICAgIG1vdmVDb2x1bW5zOiBmdW5jdGlvbihmcm9tLCBsZW4sIHRhcmdldCwgYnJvYWRjYXN0RXZlbnQsIGdpdmVuSGlkZGVuQ29sdW1ucykge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLm1vdmVDb2x1bW5zKGZyb20sIGxlbiwgdGFyZ2V0LCBicm9hZGNhc3RFdmVudCwgZ2l2ZW5IaWRkZW5Db2x1bW5zKTtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0ZWRDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0U2VsZWN0ZWRDb2x1bW5zKCk7XG4gICAgfSxcblxuICAgIGVuZERyYWdDb2x1bW5Ob3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmVuZERyYWdDb2x1bW5Ob3RpZmljYXRpb24oKTtcbiAgICB9LFxuXG4gICAgZ2V0Rml4ZWRDb2x1bW5zTWF4V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRGaXhlZENvbHVtbnNNYXhXaWR0aCgpO1xuICAgIH0sXG5cbiAgICBpc01vdXNlRG93bkluSGVhZGVyQXJlYTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IHRoaXMuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdmFyIG1vdXNlRG93biA9IHRoaXMuZ2V0TW91c2VEb3duKCk7XG4gICAgICAgIHJldHVybiBtb3VzZURvd24ueCA8IDAgfHwgbW91c2VEb3duLnkgPCBoZWFkZXJSb3dDb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbmRleH0geCAtIERhdGEgeCBjb29yZGluYXRlLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIHByb3BlcnRpZXMgZm9yIGEgc3BlY2lmaWMgY29sdW1uLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgZ2V0Q29sdW1uUHJvcGVydGllczogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRDb2x1bW5Qcm9wZXJ0aWVzKHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2luZGV4fSB4IC0gRGF0YSB4IGNvb3JkaW5hdGUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgcHJvcGVydGllcyBmb3IgYSBzcGVjaWZpYyBjb2x1bW4uXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBzZXRDb2x1bW5Qcm9wZXJ0aWVzOiBmdW5jdGlvbih4LCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0Q29sdW1uUHJvcGVydGllcyh4LCBwcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBjZWxsIHByb3BlcnRpZXMgb2YgZ2l2ZW4gY29sdW1uIG9yIG9mIGFsbCBjb2x1bW5zLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeF0gLSBPbWl0IGZvciBhbGwgY29sdW1ucy5cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICovXG4gICAgY2xlYXJBbGxDZWxsUHJvcGVydGllczogZnVuY3Rpb24oeCkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmNsZWFyQWxsQ2VsbFByb3BlcnRpZXMoeCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVzZXRBbGxDZWxsUHJvcGVydGllc0NhY2hlcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJSb3dJbmRleHxzZWN0aW9uUG9pbnR9IHJuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBpc0dyaWRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmJlaGF2aW9yLkNlbGxFdmVudCgwLCB5KS5pc0RhdGFSb3c7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB0b3RhbCBudW1iZXIgb2Ygcm93cyBvZiBhbGwgc3ViZ3JpZHMgcHJlY2VkaW5nIHRoZSBkYXRhIHN1YmdyaWQuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBnZXRIZWFkZXJSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB0b3RhbCBudW1iZXIgb2Ygcm93cyBvZiBhbGwgc3ViZ3JpZHMgZm9sbG93aW5nIHRoZSBkYXRhIHN1YmdyaWQuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBnZXRGb290ZXJSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldEZvb3RlclJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB0b3RhbCBudW1iZXIgb2YgbG9naWNhbCByb3dzIG9mIGFsbCBzdWJncmlkcy5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIGdldExvZ2ljYWxSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldExvZ2ljYWxSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICBoYXNUcmVlQ29sdW1uOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5oYXNUcmVlQ29sdW1uKGNvbHVtbkluZGV4KTtcbiAgICB9LFxuICAgIGxvb2t1cEZlYXR1cmU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5sb29rdXBGZWF0dXJlKGtleSk7XG4gICAgfSxcbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Um93KHkpO1xuICAgIH0sXG5cbiAgICBuZXdQb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHkpO1xuICAgIH0sXG4gICAgbmV3UmVjdGFuZ2xlOiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICBnZXQgY2hhck1hcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuY2hhck1hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgZmluZCBhbGwgY29sdW1uIGRlZnMgYnkgbmFtZVxuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICogQHBhcmFtIGNvbHVtbkRlZnNcbiAgICAgKi9cbiAgICBnZXRDb2xEZWZzOiBmdW5jdGlvbihuYW1lLCBjb2x1bW5EZWZzID0gdGhpcy5jb2x1bW5EZWZzKSB7XG4gICAgICAgIGlmICghY29sdW1uRGVmcykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvdW5kID0gY29sdW1uRGVmcy5maWx0ZXIoY2QgPT4gY2QuZmllbGQgPT09IG5hbWUgfHwgY2QuY29sSWQgPT09IG5hbWUgfHwgY2Qub3JpZ2luYWxGaWVsZCA9PT0gbmFtZSk7XG5cbiAgICAgICAgY29sdW1uRGVmcy5maWx0ZXIoY2QgPT4gY2QuY2hpbGRyZW4pLmZvckVhY2goY2QgPT4gW10ucHVzaC5hcHBseShmb3VuZCwgdGhpcy5nZXRDb2xEZWZzKG5hbWUsIGNkLmNoaWxkcmVuKSkpO1xuXG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uQnlOYW1lOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFjdGl2ZUNvbHVtbnMoKS5maW5kKGMgPT4gYy5uYW1lID09PSBuYW1lKTtcbiAgICB9LFxuXG4gICAgZ2V0RmllbGRzRXJyb3JzTWVzc2FnZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IE9iamVjdC5rZXlzKHRoaXMuYmVoYXZpb3IuZ2V0Q29sdW1uc0Vycm9ycygpKTtcbiAgICAgICAgcmV0dXJuIGBUaGUgZm9sbG93aW5nIGZpZWxkcyBoYXZlIHBvc3NpYmxlIGVycm9yczogJHtmaWVsZHMuam9pbignLCAnKX0uIFBsZWFzZSByZXZpZXcgdGhlbSBiZWZvcmUgc2F2aW5nIHlvdXIgZGF0YS5gO1xuICAgIH0sXG5cbiAgICBsb2coKSB7XG4gICAgICAgIGlmICh0aGlzLmxvZ0VuYWJsZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coLi4uYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBzZXQgdGV4dCB2YWx1ZSBmb3IgaGlnaGxpZ2h0aW5nIHdpdGhpbiBhbGwgdmFsdWVzIGluIHRhYmxlXG4gICAgICogQHBhcmFtIHRleHRcbiAgICAgKi9cbiAgICBzZXRIaWdobGlnaHRUZXh0KHRleHQpIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmhpZ2hMaWdodFRleHQgPSB0ZXh0O1xuICAgIH1cbn0pO1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSB2YXJpYWJsZSBiYWNrZXIgZm9yIHVzZSBieSB0aGUgZ2V0dGVycyBhbmQgc2V0dGVycyBkZXNjcmliZWQgaW4ge0BsaW5rIGR5bmFtaWNQcm9wZXJ0eURlc2NyaXB0b3JzfS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQG1lbWJlck9mIEh5cGVyZ3JpZH5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFZhcigpIHtcbiAgICB0aGlzLmdyaWRSZW5kZXJlciA9IGRlZmF1bHRzLmdyaWRSZW5kZXJlcjtcbiAgICB0aGlzLnJvd0hlYWRlckNoZWNrYm94ZXMgPSBkZWZhdWx0cy5yb3dIZWFkZXJDaGVja2JveGVzO1xuICAgIHRoaXMucm93SGVhZGVyTnVtYmVycyA9IGRlZmF1bHRzLnJvd0hlYWRlck51bWJlcnM7XG4gICAgdGhpcy5ncmlkQm9yZGVyID0gZGVmYXVsdHMuZ3JpZEJvcmRlcjtcbiAgICB0aGlzLmdyaWRCb3JkZXJUb3AgPSBkZWZhdWx0cy5ncmlkQm9yZGVyVG9wO1xuICAgIHRoaXMuZ3JpZEJvcmRlclJpZ2h0ID0gZGVmYXVsdHMuZ3JpZEJvcmRlclJpZ2h0O1xuICAgIHRoaXMuZ3JpZEJvcmRlckJvdHRvbSA9IGRlZmF1bHRzLmdyaWRCb3JkZXJCb3R0b207XG4gICAgdGhpcy5ncmlkQm9yZGVyTGVmdCA9IGRlZmF1bHRzLmdyaWRCb3JkZXJMZWZ0O1xufVxuXG5mdW5jdGlvbiBmaW5kT3JDcmVhdGVDb250YWluZXIoYm91bmRpbmdSZWN0KSB7XG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoeXBlcmdyaWQnKSxcbiAgICAgICAgdXNlZCA9IGRpdiAmJiAhZGl2LmZpcnN0RWxlbWVudENoaWxkO1xuXG4gICAgaWYgKCF1c2VkKSB7XG4gICAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBzZXRTdHlsZXMoZGl2LCBib3VuZGluZ1JlY3QsIFJFQ1RfU1RZTEVTKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgIH1cblxuICAgIHJldHVybiBkaXY7XG59XG5cbmZ1bmN0aW9uIHNldFN0eWxlcyhlbCwgc3R5bGUsIGtleXMpIHtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgdmFyIGVsU3R5bGUgPSBlbC5zdHlsZTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgaWYgKHN0eWxlW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGVsU3R5bGVba2V5XSA9IHN0eWxlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5RnVuY3Rpb25zKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcykucmVkdWNlKGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgICAgIGlmIChrZXkgIT09ICd0b0pTT04nKSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IC9eZnVuY3Rpb24gLy50ZXN0KGtleSlcbiAgICAgICAgICAgICAgICA/IG51bGwgLy8gYW5vbiBmdW5jOiBubyBwb2ludCBpbiBzYXZpbmcgYmVjYXVzZSBrZXkgaXRzZWxmIGlzIGFscmVhZHkgdGhlIHN0cmluZ2lmaWVkIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgOiBzZWxmW2tleV0udG9TdHJpbmcoKSAvLyBzdHJpbmdpZnkgdGhlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9eZnVuY3Rpb24gYW5vbnltb3VzXFwoLywgJ2Z1bmN0aW9uKCcpIC8vIGNsZWFuIHVwIENocm9taXVtIGFydGlmYWN0XG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdcXG4vKmBgKi8pJywgJyknKTsgLy8gY2xlYW4gdXAgQ2hyb21pdW0gYXJ0aWZhY3RcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKCk7IC8vIGNsb25lIGFycmF5XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7fSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModmFsdWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZWVwQ2xvbmUob2JqZWN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IGNsb25lKG9iamVjdCk7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVzdWx0LCBrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGRlZXBDbG9uZShkZXNjcmlwdG9yLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNlbGxFZGl0b3IobmFtZSwgcHJvcHMpIHtcbiAgICB2YXIgQ2VsbEVkaXRvciA9IGNlbGxFZGl0b3JzLmdldChuYW1lKTtcbiAgICBpZiAoQ2VsbEVkaXRvcikge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFZGl0b3IodGhpcywgcHJvcHMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbmFtZSBwbHVnaW5zXG4gKiBAbWVtYmVyT2YgSHlwZXJncmlkXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHN1bW1hcnkgSGFzaCBvZiByZWZlcmVuY2VzIHRvIHNoYXJlZCBwbHVnLWlucy5cbiAqIEBkZXNjIERpY3Rpb25hcnkgb2Ygc2hhcmVkIChwcmUtaW5zdGFsbGVkKSBwbHVnLWlucy4gVXNlZCBpbnRlcm5hbGx5LCBwcmltYXJpbHkgdG8gYXZvaWQgcmVpbnN0YWxsYXRpb25zLiBTZWUgZXhhbXBsZXMgZm9yIGhvdyB0byByZWZlcmVuY2UgKGFsYmVpdCB0aGVyZSBpcyBub3JtYWxseSBubyBuZWVkIHRvIHJlZmVyZW5jZSBwbHVnaW5zIGRpcmVjdGx5KS5cbiAqXG4gKiBGb3IgdGhlIGRpY3Rpb25hcnkgb2YgX2luc3RhbmNlXyBwbHVnaW5zLCBzZWUge0BsaW5rIEh5cGVyZ3JpZCNwbHVnaW5zfHBsdWdpbnN9IChkZWZpbmVkIGluIHRoZSB7QGxpbmsgSHlwZXJncmlkI2ludGlhbGl6ZXxIeXBlcmdyaWQgY29uc3RydWN0b3J9KS5cbiAqXG4gKiBUbyBmb3JjZSByZWluc3RhbGxhdGlvbiBvZiBhIHNoYXJlZCBwbHVnaW4gZGVsZXRlIGl0IGZpcnN0OlxuICogYGBgamF2YXNjcmlwdFxuICogZGVsZXRlIEh5cGVyZ3JpZC5wbHVnaW5zLm15U2hhcmVkUGx1Z2luO1xuICogYGBgXG4gKiBUbyBmb3JjZSByZWluc3RhbGxhdGlvbiBvZiBhbGwgc2hhcmVkIHBsdWdpbnM6XG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBIeXBlcmdyaWQucGx1Z2lucyA9IHt9O1xuICogYGBgXG4gKiBAZXhhbXBsZVxuICogdmFyIGFsbFNoYXJlZFBsdWdpbnMgPSBIeXBlcmdyaWQucGx1Z2lucztcbiAqIHZhciBteVNoYXJlZFBsdWdpbiA9IEh5cGVyZ3JpZC5wbHVnaW5zLm15U2hhcmVkUGx1Z2luO1xuICovXG5IeXBlcmdyaWQucGx1Z2lucyA9IHt9O1xuXG4vKipcbiAqIEBuYW1lIGxvY2FsaXphdGlvblxuICogQG1lbWJlck9mIEh5cGVyZ3JpZFxuICogQHR5cGUge29iamVjdH1cbiAqIEBzdW1tYXJ5IFNoYXJlZCBsb2NhbGl6YXRpb24gZGVmYXVsdHMgZm9yIGFsbCBncmlkIGluc3RhbmNlcy5cbiAqIEBkZXNjIFRoZXNlIHByb3BlcnR5IHZhbHVlcyBhcmUgb3ZlcnJpZGRlbiBieSB0aG9zZSBzdXBwbGllZCBpbiB0aGUgYEh5cGVyZ3JpZGAgY29uc3RydWN0b3IncyBgb3B0aW9ucy5sb2NhbGl6YXRpb25gLlxuICogQHByb3BlcnR5IHtzdHJpbmd8c3RyaW5nW119IFtsb2NhbGVdIC0gVGhlIGRlZmF1bHQgbG9jYWxlIHRvIHVzZSB3aGVuIGFuIGV4cGxpY2l0IGBsb2NhbGVgIGlzIG9taXR0ZWQgZnJvbSBsb2NhbGl6ZXIgY29uc3RydWN0b3IgY2FsbHMuIFBhc3NlZCB0byBJbnRsLk51bWJlckZvcm1hdGAgYW5kIGBJbnRsLkRhdGVGb3JtYXRgLiBTZWUge0AgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSW50bCNMb2NhbGVfaWRlbnRpZmljYXRpb25fYW5kX25lZ290aWF0aW9ufExvY2FsZSBpZGVudGlmaWNhdGlvbiBhbmQgbmVnb3RpYXRpb259IGZvciBtb3JlIGluZm9ybWF0aW9uLiBPbWl0dGluZyB3aWxsIHVzZSB0aGUgcnVudGltZSdzIGxvY2FsIGxhbmd1YWdlIGFuZCByZWdpb24uXG4gKiBAcHJvcGVydHkge29iamVjdH0gW251bWJlck9wdGlvbnNdIC0gT3B0aW9ucyBwYXNzZWQgdG8gYEludGwuTnVtYmVyRm9ybWF0YCBmb3IgY3JlYXRpbmcgdGhlIGJhc2ljIFwibnVtYmVyXCIgbG9jYWxpemVyLlxuICogQHByb3BlcnR5IHtvYmplY3R9IFtkYXRlT3B0aW9uc10gLSBPcHRpb25zIHBhc3NlZCB0byBgSW50bC5EYXRlRm9ybWF0YCBmb3IgY3JlYXRpbmcgdGhlIGJhc2ljIFwiZGF0ZVwiIGxvY2FsaXplci5cbiAqL1xuSHlwZXJncmlkLmxvY2FsaXphdGlvbiA9IHtcbiAgICBsb2NhbGU6ICdlbi1VUycsXG4gICAgbnVtYmVyT3B0aW9uczogeyBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDAgfVxufTtcblxuXG4vLyBtaXggaW4gdGhlIG1peGluc1xuXG5IeXBlcmdyaWQubWl4SW4gPSBIeXBlcmdyaWQucHJvdG90eXBlLm1peEluO1xuSHlwZXJncmlkLm1peEluKHJlcXVpcmUoJy4vdGhlbWVzJykuc2hhcmVkTWl4aW4pO1xuXG5IeXBlcmdyaWQucHJvdG90eXBlLm1peEluKHJlcXVpcmUoJy4vdGhlbWVzJykubWl4aW4pO1xuSHlwZXJncmlkLnByb3RvdHlwZS5taXhJbihyZXF1aXJlKCcuL2V2ZW50cycpLm1peGluKTtcbkh5cGVyZ3JpZC5wcm90b3R5cGUubWl4SW4ocmVxdWlyZSgnLi9kYXRhTW9kZWwvZXZlbnRzJykubWl4aW4pO1xuSHlwZXJncmlkLnByb3RvdHlwZS5taXhJbihyZXF1aXJlKCcuL3NlbGVjdGlvbicpLm1peGluKTtcbkh5cGVyZ3JpZC5wcm90b3R5cGUubWl4SW4ocmVxdWlyZSgnLi9zY3JvbGxpbmcnKS5taXhpbik7XG5cblxuLy8gZGVwcmVjYXRlZCBtb2R1bGUgYWNjZXNzXG5cbmZ1bmN0aW9uIHBsZWFzZVVzZShyZXF1aXJlU3RyaW5nLCBtb2R1bGUpIHtcbiAgICBpZiAoIXBsZWFzZVVzZS53YXJuZWRbcmVxdWlyZVN0cmluZ10pIHtcbiAgICAgICAgdmFyIGtleSA9IHJlcXVpcmVTdHJpbmcubWF0Y2goL1xcdyskLylbMF07XG4gICAgICAgIGNvbnNvbGUud2FybignUmVmZXJlbmNlIHRvICcgKyBrZXkgKyAnIGV4dGVybmFsIG1vZHVsZSB1c2luZycgK1xuICAgICAgICAgICAgJyBgSHlwZXJncmlkLicgKyBrZXkgKyAnLmAgaGFzIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2My4wLjAgaW4gZmF2b3Igb2YnICtcbiAgICAgICAgICAgICcgYHJlcXVpcmUoXFwnJyArIHJlcXVpcmVTdHJpbmcgKyAnXFwnKWAgZnJvbSB3aXRoaW4gYSBIeXBlcmdyaWQgQ2xpZW50IE1vZHVsZScgK1xuICAgICAgICAgICAgJyAob3RoZXJ3aXNlIHVzZSBgSHlwZXJncmlkLnJlcXVpcmUoLi4uKWApIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4nICtcbiAgICAgICAgICAgICcgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9maW4taHlwZXJncmlkL2NvcmUvd2lraS9DbGllbnQtTW9kdWxlcyNpbnRlcm5hbC1tb2R1bGVzLicpO1xuICAgICAgICBwbGVhc2VVc2Uud2FybmVkW3JlcXVpcmVTdHJpbmddID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZHVsZTtcbn1cblxucGxlYXNlVXNlLndhcm5lZCA9IHt9O1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEh5cGVyZ3JpZCwge1xuICAgIEJhc2U6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBwbGVhc2VVc2UoJ2Zpbi1oeXBlcmdyaWQvc3JjL0Jhc2UnLCByZXF1aXJlKCcuLi9CYXNlJykpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBpbWFnZXM6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBwbGVhc2VVc2UoJ2Zpbi1oeXBlcmdyaWQvaW1hZ2VzJywgcmVxdWlyZSgnLi4vLi4vaW1hZ2VzJykpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuLyoqXG4gKiBAc3VtbWFyeSBMaXN0IG9mIGdyaWQgaW5zdGFuY2VzLlxuICogQGRlc2MgQWRkZWQgaW4ge0BsaW5rIEh5cGVyZ3JpZCBjb25zdHJ1Y3Rvcn07IHJlbW92ZWQgaW4ge0BsaW5rIEh5cGVyZ3JpZCN0ZXJtaW5hdGUgdGVybWluYXRlKCl9LlxuICogVXNlZCBpbiB0aGVtZXMuanMuXG4gKiBAdHlwZSB7SHlwZXJncmlkW119XG4gKi9cbkh5cGVyZ3JpZC5ncmlkcyA9IFtdO1xuXG5cbi8qKiBAbmFtZSBkZWZhdWx0c1xuICogQG1lbWJlck9mIEh5cGVyZ3JpZFxuICogQHR5cGUge29iamVjdH1cbiAqIEBzdW1tYXJ5IFRoZSBgZGVmYXVsdHNgIGxheWVyIG9mIHRoZSBIeXBlcmdyaWQgcHJvcGVydGllcyBoaWVyYXJjaHkuXG4gKiBAZGVzYyBEZWZhdWx0IHZhbHVlcyBmb3IgYWxsIEh5cGVyZ3JpZCBwcm9wZXJ0aWVzLCBpbmNsdWRpbmcgZ3JpZC1sZXZlbCBwcm9wZXJ0aWVzIGFuZCBjb2x1bW4gcHJvcGVydHkgZGVmYXVsdHMuXG4gKlxuICogU3lub255bTogYHByb3BlcnRpZXNgXG4gKiBQcm9wZXJ0aWVzIGFyZSBkaXZpZGVkIGJyb2FkbHkgaW50byB0d28gY2F0ZWdvcmllczpcbiAqICogU3R5bGUgKGEuay5hLiBcImxuZlwiIGZvciBcImxvb2snbidmZWVsXCIpIHByb3BlcnRpZXNcbiAqICogQWxsIG90aGVyIHByb3BlcnRpZXMuXG4gKi9cbkh5cGVyZ3JpZC5kZWZhdWx0cyA9IEh5cGVyZ3JpZC5wcm9wZXJ0aWVzID0gZGVmYXVsdHM7XG5cblxuLy8gRGVmaW5lIG1vZHVsZXMgbmFtZXNwYWNlIGFuZCBpbnN0YWxsIG92ZXJyaWRhYmxlIGV4dGVybmFsIG1vZHVsZXMuXG4vLyBIeXBlcmdyaWQgY29yZSBjb2RlIHJlZmVyZW5jZXMgdGhlbSB2aWEgdGhpcyBvYmplY3Qg4oCUIHJhdGhlciB0aGFuIHJlcXVpcmUoKSDigJQgd2hlcmUgdXNlZC5cbi8vIE5vdGUgdGhhdCBgbW9kdWxlc2AgYWxzbyBzdXBwb3J0cyB0aGUgSHlwZXJncmlkIE1vZHVsZSBMb2FkZXIgKGluY2x1ZGVkIG9ubHkgd2l0aCB0aGUgYnVpbGQgZmlsZSkuXG5IeXBlcmdyaWQubW9kdWxlcyA9IG1vZHVsZXM7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBIeXBlcmdyaWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qXG4gKiBUaGlzIG1vZHVsZSBpcyB0aGUgbmFtZXNwYWNlIG9mIGxvYWRlZCBleHRlcm5hbCBtb2R1bGVzIGtub3duIHRvIGBIeXBlcmdyaWQucmVxdWlyZWAsXG4gKiB3aGljaCBtYXkgaW5jbHVkZSBsb2FkZWQgYXBwbGljYXRpb24gbW9kdWxlcywgZGF0YXNvdXJjZSBtb2R1bGVzLCBhbmQgcGx1Zy1pbiBtb2R1bGVzLlxuICpcbiAqIFRoZSBwcmUtbG9hZGVkIGV4dGVybmFsIG1vZHVsZXMgbGlzdGVkIGJlbG93IGNhbiBjb252ZW5pZW50bHkgYmUgb3ZlcnJpZGRlbiBieSB0aGVcbiAqIGFwcGxpY2F0aW9uIGRldmVsb3BlciBieSBsb2FkaW5nIGEgbmV3IG1vZHVsZSB1c2luZyB0aGUgc2FtZSBrZXkuXG4gKlxuICogRm9yIGV4YW1wbGUsIHRvIG92ZXJyaWRlIGBmaW5iYXJzYCB3aXRoIGFub3RoZXIgY29tcGF0aWJsZSBtb2R1bGUgKHRoYXQgY29uZm9ybXMgdG8gdGhlXG4gKiBzYW1lIGludGVyZmFjZSksIGp1c3QgYXNzaWduIGl0IGxpa2Ugc286IGBIeXBlcmdyaWQubW9kdWxlcy5TY3JvbGxiYXIgPSBteUZpbmJhclJlcGxhY2VtZW50O2BcbiAqXG4gKiBIeXBlcmdyaWQgdXNhZ2Ugb2YgdGhlc2UgbW9kdWxlcyBzaG91bGQgcmVmZXJlbmNlIHRoZSB2YWx1ZXMgZGVmaW5lZCBoZXJlIHRvIGJlIHN1cmUgdG9cbiAqIGdldCBhbnkgZGV2ZWxvcGVyIG92ZXJyaWRlcy4gRG8gX25vdF8gdXNlIGByZXF1aXJlYCB0byBsb2FkIHRoZW0gZGlyZWN0bHkhXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgU2Nyb2xsYmFyOiByZXF1aXJlKCcuLi9GaW5iYXJzL2luZGV4JyksXG4gICAgdGVtcGxhdGVyOiByZXF1aXJlKCdtdXN0YWNoZScpIC8vIGludGVyZmFjZSDDoCBsYSBtdXN0YWNoZTogeyByZW5kZXI6IGZ1bmN0aW9uKHRlbXBsYXRlLCBjb250ZXh0KSB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbmNvbnN0IFNjcm9sbGJhciA9IHJlcXVpcmUoJy4vbW9kdWxlcycpLlNjcm9sbGJhcjtcblxuLyoqXG4gKiBAc3VtbWFyeSBTY3JvbGxiYXIgc3VwcG9ydC5cbiAqIEBkZXNjIEh5cGVyZ3JpZC9pbmRleC5qcyBtaXhlcyB0aGlzIG1vZHVsZSBpbnRvIGl0cyBwcm90b3R5cGUuXG4gKiBAbWl4aW5cbiAqL1xuZXhwb3J0cy5taXhpbiA9IHtcblxuICAgIC8qKlxuICAgICAqIEEgZmxvYXQgdmFsdWUgYmV0d2VlbiAwLjAgLSAxLjAgb2YgdGhlIHZlcnRpY2FsIHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgdlNjcm9sbFZhbHVlOiAwLFxuXG4gICAgLyoqXG4gICAgICogQSBmbG9hdCB2YWx1ZSBiZXR3ZWVuIDAuMCAtIDEuMCBvZiB0aGUgaG9yaXpvbnRhbCBzY3JvbGwgcG9zaXRpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIGhTY3JvbGxWYWx1ZTogMCxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7RmluQmFyfSBzYlZTY3JvbGxlciAtIEFuIGluc3RhbmNlIG9mIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vb3BlbmZpbi9maW5iYXJzfEZpbkJhcn0uXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBzYlZTY3JvbGxlcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91cyB2YWx1ZSBvZiBzYlZTY3JvbGxWYWwuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIHNiUHJldlZTY3JvbGxWYWx1ZTogMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91cyB2YWx1ZSBvZiBzYkhTY3JvbGxWYWx1ZS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgc2JQcmV2SFNjcm9sbFZhbHVlOiAwLFxuXG4gICAgc2Nyb2xsaW5nTm93OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHN1bW1hcnkgU2V0IGZvciBgc2Nyb2xsaW5nTm93YCBmaWVsZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzSXROb3cgLSBUaGUgdHlwZSBvZiBldmVudCB3ZSBhcmUgaW50ZXJlc3RlZCBpbi5cbiAgICAgKi9cbiAgICBzZXRTY3JvbGxpbmdOb3c6IGZ1bmN0aW9uKGlzSXROb3cpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxpbmdOb3cgPSBpc0l0Tm93O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgYHNjcm9sbGluZ05vd2AgZmllbGQuXG4gICAgICovXG4gICAgaXNTY3JvbGxpbmdOb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxpbmdOb3c7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHN1bW1hcnkgU2Nyb2xsIGhvcml6b250YWwgYW5kIHZlcnRpY2FsbHkgYnkgdGhlIHByb3ZpZGVkIG9mZnNldHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSBTY3JvbGwgaW4gdGhlIHggZGlyZWN0aW9uIHRoaXMgbXVjaC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIFNjcm9sbCBpbiB0aGUgeSBkaXJlY3Rpb24gdGhpcyBtdWNoLlxuICAgICAqL1xuICAgIHNjcm9sbEJ5OiBmdW5jdGlvbihvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsSEJ5KG9mZnNldFgpO1xuICAgICAgICB0aGlzLnNjcm9sbFZCeShvZmZzZXRZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAc3VtbWFyeSBTY3JvbGwgdmVydGljYWxseSBieSB0aGUgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0gU2Nyb2xsIGluIHRoZSB5IGRpcmVjdGlvbiB0aGlzIG11Y2guXG4gICAgICovXG4gICAgc2Nyb2xsVkJ5OiBmdW5jdGlvbihvZmZzZXRZKSB7XG4gICAgICAgIGNvbnN0IG1heCA9IHRoaXMuc2JWU2Nyb2xsZXIucmFuZ2UubWF4O1xuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMudlNjcm9sbFZhbHVlO1xuICAgICAgICBjb25zdCBvbGRPZmZzZXQgPSB0aGlzLmdldFZTY3JvbGxWYWx1ZSgpO1xuICAgICAgICBjb25zdCByb3dIZWlnaHQgPSB0aGlzLmJlaGF2aW9yLmdldFJvd0hlaWdodChNYXRoLm1heCgwLCBvbGRPZmZzZXQgKyBvZmZzZXRZKSk7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gTWF0aC5taW4obWF4LCBvbGRWYWx1ZSArIG9mZnNldFkgKiByb3dIZWlnaHQpO1xuICAgICAgICBpZiAobmV3VmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZTY3JvbGxWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAc3VtbWFyeSBTY3JvbGwgaG9yaXpvbnRhbGx5IGJ5IHRoZSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSBTY3JvbGwgaW4gdGhlIHggZGlyZWN0aW9uIHRoaXMgbXVjaC5cbiAgICAgKi9cbiAgICBzY3JvbGxIQnk6IGZ1bmN0aW9uKG9mZnNldFgpIHtcbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5zYkhTY3JvbGxlci5yYW5nZS5tYXg7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5oU2Nyb2xsVmFsdWU7XG4gICAgICAgIGNvbnN0IG9sZE9mZnNldCA9IHRoaXMuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gTWF0aC5taW4obWF4LCBvbGRWYWx1ZSArIG9mZnNldFggKiB0aGlzLmJlaGF2aW9yLmdldENvbHVtbldpZHRoKE1hdGgubWF4KDAsIG9sZE9mZnNldCArIG9mZnNldFgpKSk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SFNjcm9sbFZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzY3JvbGxUb01ha2VWaXNpYmxlOiBmdW5jdGlvbihjb2x1bW4sIHJvdykge1xuICAgICAgICBjb25zdCB7IG9yaWdpbiwgY29ybmVyIH0gPSB0aGlzLnJlbmRlcmVyLmRhdGFXaW5kb3c7XG4gICAgICAgIGNvbnN0IHsgZml4ZWRDb2x1bW5Db3VudCwgZml4ZWRSb3dDb3VudCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuXG4gICAgICAgIGxldCBkZWx0YTtcbiAgICAgICAgbGV0IHB4RGVsdGEgPSAwO1xuXG4gICAgICAgIC8vIHNjcm9sbCBvbmx5IGlmIHRhcmdldCBub3QgaW4gZml4ZWQgY29sdW1uc1xuICAgICAgICBpZiAoY29sdW1uID49IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIGRlbHRhID0gY29sdW1uIC0gb3JpZ2luLng7XG4gICAgICAgICAgICAvLyB0YXJnZXQgaXMgdG8gbGVmdCBvZiBzY3JvbGxhYmxlIGNvbHVtbnM7IG5lZ2F0aXZlIGRlbHRhIHNjcm9sbHMgbGVmdFxuICAgICAgICAgICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgICAgIHB4RGVsdGEgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IE1hdGguYWJzKGRlbHRhKSArIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBweERlbHRhICs9IHRoaXMuZ2V0Q29sdW1uV2lkdGgob3JpZ2luLnggLSBpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNiSFNjcm9sbGVyLmluZGV4IC09IHB4RGVsdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbHRhID0gY29sdW1uIC0gY29ybmVyLng7XG4gICAgICAgICAgICBpZiAoZGVsdGEgPj0gMCkge1xuICAgICAgICAgICAgICAgIHB4RGVsdGEgPSAwO1xuICAgICAgICAgICAgICAgIC8vIHNjcm9sbCBtb3JlIHRoYW4ganVzdCBvbmUgY3V0IGNvbHVtblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IE1hdGguYWJzKGRlbHRhKSArIDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBweERlbHRhICs9IHRoaXMuZ2V0Q29sdW1uV2lkdGgoY29ybmVyLnggLSBpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNiSFNjcm9sbGVyLmluZGV4ICs9IHB4RGVsdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zYkhTY3JvbGxlci5pbmRleCA8PSB0aGlzLmdldENvbHVtbldpZHRoKDApKSB7XG4gICAgICAgICAgICB0aGlzLnNiSFNjcm9sbGVyLmluZGV4ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNjcm9sbCBvbmx5IGlmIHRhcmdldCBub3QgaW4gZml4ZWQgcm93c1xuICAgICAgICBpZiAocm93ID49IGZpeGVkUm93Q291bnQpIHtcbiAgICAgICAgICAgIGRlbHRhID0gcm93IC0gb3JpZ2luLnk7XG4gICAgICAgICAgICAvLyB0YXJnZXQgaXMgYWJvdmUgc2Nyb2xsYWJsZSByb3dzOyBuZWdhdGl2ZSBkZWx0YSBzY3JvbGxzIHVwXG4gICAgICAgICAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFQZXJjZW50ID0gKE1hdGguYWJzKGRlbHRhKSArIDIpIC8gdGhpcy5nZXRSb3dDb3VudCgpO1xuICAgICAgICAgICAgICAgIHB4RGVsdGEgPSB0aGlzLnNiVlNjcm9sbGVyLm1heCAqIGRlbHRhUGVyY2VudDtcblxuICAgICAgICAgICAgICAgIGlmIChweERlbHRhIDwgdGhpcy5wcm9wZXJ0aWVzLmRlZmF1bHRSb3dIZWlnaHQgKiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2JWU2Nyb2xsZXIuaW5kZXggLT0gcHhEZWx0YTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IHJvdyAtIGNvcm5lci55O1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhUGVyY2VudCA9IChNYXRoLmFicyhkZWx0YSkgKyAyKSAvIHRoaXMuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcHhEZWx0YSA9IHRoaXMuc2JWU2Nyb2xsZXIubWF4ICogZGVsdGFQZXJjZW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNiVlNjcm9sbGVyLmluZGV4IC09IHB4RGVsdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWx0YSA9IHJvdyAtIGNvcm5lci55O1xuICAgICAgICAgICAgaWYgKGRlbHRhID49IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YVBlcmNlbnQgPSAoZGVsdGEgKyAyKSAvIHRoaXMuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgICAgICAgICBweERlbHRhID0gdGhpcy5zYlZTY3JvbGxlci5tYXggKiBkZWx0YVBlcmNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAocHhEZWx0YSA8IHRoaXMucHJvcGVydGllcy5kZWZhdWx0Um93SGVpZ2h0ICogMykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNiVlNjcm9sbGVyLmluZGV4ICs9IHB4RGVsdGE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSBvcmlnaW4ueSAtIHJvdztcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWx0YVBlcmNlbnQgPSAoTWF0aC5hYnMoZGVsdGEpICsgMikgLyB0aGlzLmdldFJvd0NvdW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHB4RGVsdGEgPSB0aGlzLnNiVlNjcm9sbGVyLm1heCAqIGRlbHRhUGVyY2VudDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zYlZTY3JvbGxlci5pbmRleCArPSBweERlbHRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNiVlNjcm9sbGVyLmluZGV4IDw9IHRoaXMuZ2V0Um93SGVpZ2h0KDApKSB7XG4gICAgICAgICAgICB0aGlzLnNiVlNjcm9sbGVyLmluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZWxlY3RDZWxsQW5kU2Nyb2xsVG9NYWtlVmlzaWJsZTogZnVuY3Rpb24oYywgcikge1xuICAgICAgICB0aGlzLnNjcm9sbFRvTWFrZVZpc2libGUoYywgcik7XG4gICAgICAgIHRoaXMuc2VsZWN0Q2VsbChjLCByLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgYmluYXJ5IHNlYXJjaCBvZiBjZWxsIHdpdGggbmVlZGVkIHNjcm9sbCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHNjcm9sbFZhbHVlIC0gc2Nyb2xsIHZhbHVlIGluIHBpeGVsc1xuICAgICAqIEBwYXJhbSBmcm9tIC0gZmlyc3QgY2VsbCBpbmRleCBmb3Igc2VhcmNoaW5nXG4gICAgICogQHBhcmFtIHRvIC0gbGFzdCBjZWxsIGluZGV4IGZvciBzZWFyY2hpbmdcbiAgICAgKiBAcGFyYW0gY2hlY2tGdW5jdGlvbiAtIGZ1bmN0aW9uIGZvciBjaGVja2luZyBoZWlnaHQgb2YgaG9yaXpvbnRhbCBvciBjZXJ0aWNhbCBzY3JvbGxcbiAgICAgKi9cbiAgICBmaW5kQ2VsbEJ5U2Nyb2xsVmFsdWU6IGZ1bmN0aW9uKHNjcm9sbFZhbHVlLCBmcm9tLCB0bywgY2hlY2tGdW5jdGlvbikge1xuICAgICAgICBjb25zdCBzZWFyY2ggPSBNYXRoLnJvdW5kKChmcm9tICsgdG8pIC8gMik7XG5cbiAgICAgICAgaWYgKHNlYXJjaCA9PT0gZnJvbSB8fCBzZWFyY2ggPT09IHRvKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRIZWlnaHQgPSBjaGVja0Z1bmN0aW9uLmNhbGwodGhpcy5iZWhhdmlvciwgc2VhcmNoKTtcblxuICAgICAgICBpZiAoY3VycmVudEhlaWdodCA+IHNjcm9sbFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kQ2VsbEJ5U2Nyb2xsVmFsdWUoc2Nyb2xsVmFsdWUsIGZyb20sIHNlYXJjaCwgY2hlY2tGdW5jdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kQ2VsbEJ5U2Nyb2xsVmFsdWUoc2Nyb2xsVmFsdWUsIHNlYXJjaCwgdG8sIGNoZWNrRnVuY3Rpb24pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU2V0IHRoZSB2ZXJ0aWNhbCBzY3JvbGwgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1ZhbHVlIC0gVGhlIG5ldyBzY3JvbGwgdmFsdWUuXG4gICAgICovXG4gICAgc2V0VlNjcm9sbFZhbHVlOiBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgICBuZXdWYWx1ZSA9IE1hdGgubWluKHRoaXMuc2JWU2Nyb2xsZXIucmFuZ2UubWF4LCBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKG5ld1ZhbHVlKSkpO1xuICAgICAgICBpZiAobmV3VmFsdWUgIT09IHRoaXMudlNjcm9sbFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yLnNldFNjcm9sbFBvc2l0aW9uWShuZXdWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yLmNoYW5nZWQoKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZFkgPSB0aGlzLnZTY3JvbGxWYWx1ZTtcblxuICAgICAgICAgICAgdGhpcy52U2Nyb2xsVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVmFsdWVDaGFuZ2VkTm90aWZpY2F0aW9uKCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT4ge1xuICAgICAgICAgICAgICAgIC8vIHNlbGYuc2JWUmFuZ2VBZGFwdGVyLnN1YmplY3RDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlU2Nyb2xsRXZlbnQoJ2Zpbi1zY3JvbGwteScsIG9sZFksIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBzY3JvbGxiYXJcbiAgICAgICAgaWYgKHRoaXMuc2JWU2Nyb2xsZXIuaW5kZXggIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnNiVlNjcm9sbGVyLmluZGV4ID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB2ZXJ0aWNhbCBzY3JvbGwgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0VlNjcm9sbFZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZENlbGxCeVNjcm9sbFZhbHVlKHRoaXMudlNjcm9sbFZhbHVlLCAwLCB0aGlzLmdldFJvd0NvdW50KCksIHRoaXMuYmVoYXZpb3IuZ2V0Um93c0hlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU2V0IHRoZSBob3Jpem9udGFsIHNjcm9sbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3VmFsdWUgLSBUaGUgbmV3IHNjcm9sbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBzZXRIU2Nyb2xsVmFsdWU6IGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBuZXdWYWx1ZSA9IE1hdGgubWluKHRoaXMuc2JIU2Nyb2xsZXIucmFuZ2UubWF4LCBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKG5ld1ZhbHVlKSkpO1xuICAgICAgICBpZiAobmV3VmFsdWUgIT09IHRoaXMuaFNjcm9sbFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yLnNldFNjcm9sbFBvc2l0aW9uWChuZXdWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yLmNoYW5nZWQoKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZFggPSB0aGlzLmhTY3JvbGxWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuaFNjcm9sbFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFZhbHVlQ2hhbmdlZE5vdGlmaWNhdGlvbigpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zYkhTY3JvbGxlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIuaW5kZXggPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvL3NlbGYuc2JIUmFuZ2VBZGFwdGVyLnN1YmplY3RDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5maXJlU2Nyb2xsRXZlbnQoJ2Zpbi1zY3JvbGwteCcsIG9sZFgsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAvL3NlbGYuc3luY2hyb25pemVTY3JvbGxpbmdCb3VuZGFyaWVzKCk7IC8vIHRvZG86IENvbW1lbnRlZCBvZmYgdG8gcHJldmVudCB0aGUgZ3JpZCBmcm9tIGJvdW5jaW5nIGJhY2ssIGJ1dCB0aGVyZSBtYXkgYmUgcmVwZXJjdXNzaW9ucy4uLlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIHNjcm9sbGJhclxuICAgICAgICBpZiAodGhpcy5zYkhTY3JvbGxlci5pbmRleCAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIuaW5kZXggPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIFRoZSBob3Jpem9udGFsIHNjcm9sbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRIU2Nyb2xsVmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kQ2VsbEJ5U2Nyb2xsVmFsdWUodGhpcy5oU2Nyb2xsVmFsdWUsIDAsIHRoaXMuZ2V0Q29sdW1uQ291bnQoKSwgdGhpcy5iZWhhdmlvci5nZXRDb2x1bW5zV2lkdGgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIEluaXRpYWxpemUgdGhlIHNjcm9sbCBiYXJzLlxuICAgICAqL1xuICAgIGluaXRTY3JvbGxiYXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2JIU2Nyb2xsZXIgJiYgdGhpcy5zYlZTY3JvbGxlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgY29uc3QgaG9yekJhciA9IG5ldyBTY3JvbGxiYXIoe1xuICAgICAgICAgICAgb3JpZW50YXRpb246ICdob3Jpem9udGFsJyxcbiAgICAgICAgICAgIG9uQmFyVmlzaWJpbGl0eUNoYW5nZWQ6IGZ1bmN0aW9uKGlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHNlbGYucHJvcGVydGllcy5jYW52YXNIZWlnaHRPZmZzZXQgPSBpc1Zpc2libGVcbiAgICAgICAgICAgICAgICAgICAgPyBOdW1iZXIod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5tb3VudERpdikuaGVpZ2h0LnJlcGxhY2UoJ3B4JywgJycpKVxuICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICAgICAgc2VsZi5jYW52YXMucmVzaXplKGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmNoYW5nZTogc2VsZi5zZXRIU2Nyb2xsVmFsdWUuYmluZChzZWxmKSxcbiAgICAgICAgICAgIGNzc1N0eWxlc2hlZXRSZWZlcmVuY2VFbGVtZW50OiB0aGlzLmRpdixcbiAgICAgICAgICAgIHBhZ2luZzoge1xuICAgICAgICAgICAgICAgIHVwOiBzZWxmLnBhZ2VMZWZ0LmJpbmQoc2VsZiksXG4gICAgICAgICAgICAgICAgZG93bjogc2VsZi5wYWdlUmlnaHQuYmluZChzZWxmKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB2ZXJ0QmFyID0gbmV3IFNjcm9sbGJhcih7XG4gICAgICAgICAgICBvcmllbnRhdGlvbjogJ3ZlcnRpY2FsJyxcbiAgICAgICAgICAgIG9uQmFyVmlzaWJpbGl0eUNoYW5nZWQ6IGZ1bmN0aW9uKGlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHNlbGYucHJvcGVydGllcy5jYW52YXNXaWR0aE9mZnNldCA9IGlzVmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICA/IE51bWJlcih3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLm1vdW50RGl2KS53aWR0aC5yZXBsYWNlKCdweCcsICcnKSlcbiAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FudmFzLnJlc2l6ZShmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25jaGFuZ2U6IHNlbGYuc2V0VlNjcm9sbFZhbHVlLmJpbmQoc2VsZiksXG4gICAgICAgICAgICBwYWdpbmc6IHtcbiAgICAgICAgICAgICAgICB1cDogc2VsZi5wYWdlVXAuYmluZChzZWxmKSxcbiAgICAgICAgICAgICAgICBkb3duOiBzZWxmLnBhZ2VEb3duLmJpbmQoc2VsZilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zYkhTY3JvbGxlciA9IGhvcnpCYXI7XG4gICAgICAgIHRoaXMuc2JWU2Nyb2xsZXIgPSB2ZXJ0QmFyO1xuXG4gICAgICAgIGNvbnN0IGhQcmVmaXggPSB0aGlzLnByb3BlcnRpZXMuaFNjcm9sbGJhckNsYXNzUHJlZml4O1xuICAgICAgICBjb25zdCB2UHJlZml4ID0gdGhpcy5wcm9wZXJ0aWVzLnZTY3JvbGxiYXJDbGFzc1ByZWZpeDtcblxuICAgICAgICBpZiAoaFByZWZpeCAmJiBoUHJlZml4ICE9PSAnJykge1xuICAgICAgICAgICAgdGhpcy5zYkhTY3JvbGxlci5jbGFzc1ByZWZpeCA9IGhQcmVmaXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodlByZWZpeCAmJiB2UHJlZml4ICE9PSAnJykge1xuICAgICAgICAgICAgdGhpcy5zYlZTY3JvbGxlci5jbGFzc1ByZWZpeCA9IHZQcmVmaXg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZChob3J6QmFyLm1vdW50RGl2KTtcbiAgICAgICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQodmVydEJhci5tb3VudERpdik7XG5cbiAgICAgICAgdGhpcy5zeW5jaHJvbml6ZVNjcm9sbGJhcnNWaXN1YWxpemF0aW9uKCk7XG4gICAgfSxcblxuICAgIGRlc3Ryb3lTY3JvbGxiYXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2JIU2Nyb2xsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zYkhTY3JvbGxlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zYlZTY3JvbGxlcikge1xuICAgICAgICAgICAgdGhpcy5zYlZTY3JvbGxlci5yZW1vdmUoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNiVlNjcm9sbGVyO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHN5bmNocm9uaXplU2Nyb2xsYmFyc1Zpc3VhbGl6YXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zYkhTY3JvbGxlcikge1xuICAgICAgICAgICAgdGhpcy5zYkhTY3JvbGxlclxuICAgICAgICAgICAgICAgIC5zaG9ydGVuRW5kQnlWYWx1ZSgnbGVhZGluZycsIHRoaXMuZ2V0SFNjcm9sbGJhckxlZnRNYXJnaW4oKSlcbiAgICAgICAgICAgICAgICAuc2hvcnRlbkVuZEJ5VmFsdWUoJ3RyYWlsaW5nJywgdGhpcy5nZXRIU2Nyb2xsYmFyUmlnaHRNYXJnaW4oKSAtIDEpXG4gICAgICAgICAgICAgICAgLnJlc2l6ZShudWxsLCBudWxsLCB0aGlzLmdldEZ1bGxDb250ZW50V2lkdGgoKSk7XG5cbiAgICAgICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIuc3R5bGUgPSB0aGlzLnByb3BlcnRpZXMuc2Nyb2xsYmFySFN0eWxlO1xuICAgICAgICAgICAgdGhpcy5zYkhTY3JvbGxlci50aHVtYlN0eWxlID0gdGhpcy5wcm9wZXJ0aWVzLnNjcm9sbGJhckhUaHVtYlN0eWxlO1xuICAgICAgICAgICAgdGhpcy5zYkhTY3JvbGxlci5tb3VudFN0eWxlID0gdGhpcy5wcm9wZXJ0aWVzLnNjcm9sbGJhckhNb3VudFN0eWxlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNiVlNjcm9sbGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNiVlNjcm9sbGVyXG4gICAgICAgICAgICAgICAgLnNob3J0ZW5FbmRCeVZhbHVlKCdsZWFkaW5nJywgdGhpcy5nZXRWU2Nyb2xsYmFyVG9wTWFyZ2luKCkpXG4gICAgICAgICAgICAgICAgLnNob3J0ZW5FbmRCeVZhbHVlKCd0cmFpbGluZycsIHRoaXMuZ2V0VlNjcm9sbGJhckJvdHRvbU1hcmdpbigpIC0gMSlcbiAgICAgICAgICAgICAgICAucmVzaXplKG51bGwsIG51bGwsIHRoaXMuZ2V0RnVsbENvbnRlbnRIZWlnaHQoKSk7XG5cbiAgICAgICAgICAgIHRoaXMuc2JWU2Nyb2xsZXIuc3R5bGUgPSB0aGlzLnByb3BlcnRpZXMuc2Nyb2xsYmFyVlN0eWxlO1xuICAgICAgICAgICAgdGhpcy5zYlZTY3JvbGxlci50aHVtYlN0eWxlID0gdGhpcy5wcm9wZXJ0aWVzLnNjcm9sbGJhclZUaHVtYlN0eWxlO1xuICAgICAgICAgICAgdGhpcy5zYlZTY3JvbGxlci5tb3VudFN0eWxlID0gdGhpcy5wcm9wZXJ0aWVzLnNjcm9sbGJhclZNb3VudFN0eWxlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldEhTY3JvbGxiYXJMZWZ0TWFyZ2luOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGV0IHJlcyA9IDA7XG4gICAgICAgIGNvbnN0IHZpc2libGVDb2x1bW5zID0gdGhpcy5yZW5kZXJlci52aXNpYmxlQ29sdW1ucztcbiAgICAgICAgcmVzIC09IHRoaXMucHJvcGVydGllcy5ncmlkTGluZXNWID8gdGhpcy5wcm9wZXJ0aWVzLmdyaWRMaW5lc1dpZHRoIDogMDtcbiAgICAgICAgcmVzICs9IHRoaXMucHJvcGVydGllcy5ncmlkQm9yZGVyTGVmdCA/IHRoaXMucHJvcGVydGllcy5ncmlkTGluZXNXaWR0aCA6IDA7XG5cbiAgICAgICAgY29uc3QgbmVlZGVkQ29sdW1uID0gdmlzaWJsZUNvbHVtbnNbdGhpcy5iZWhhdmlvci5yb3dDb2x1bW5JbmRleF07XG4gICAgICAgIHJlcyArPSB0aGlzLnByb3BlcnRpZXMucm93SGVhZGVyTnVtYmVycyAmJiBuZWVkZWRDb2x1bW5cbiAgICAgICAgICAgID8gbmVlZGVkQ29sdW1uLnJpZ2h0XG4gICAgICAgICAgICA6IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnByb3BlcnRpZXMuZml4ZWRDb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gdGhpcy5iZWhhdmlvci5yb3dDb2x1bW5JbmRleCkge1xuICAgICAgICAgICAgICAgIHJlcyArPSB0aGlzLmdldENvbHVtbldpZHRoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzICs9IHRoaXMucHJvcGVydGllcy5maXhlZENvbHVtbkNvdW50ID8gdGhpcy5wcm9wZXJ0aWVzLmZpeGVkTGluZXNWV2lkdGggOiAwO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcblxuICAgIGdldEhTY3JvbGxiYXJSaWdodE1hcmdpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGxldCByZXMgPSAtMTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLnNjcm9sbGJhclZTdHlsZSAmJiB0aGlzLnByb3BlcnRpZXMuc2Nyb2xsYmFyVlN0eWxlLndpZHRoKSB7XG4gICAgICAgICAgICByZXMgKz0gdGhpcy5wcm9wZXJ0aWVzLnNjcm9sbGJhclZTdHlsZS53aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcblxuICAgIGdldFZTY3JvbGxiYXJUb3BNYXJnaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICBjb25zdCByb3dJbmRleCA9IHRoaXMucHJvcGVydGllcy5maXhlZFJvd0NvdW50O1xuXG4gICAgICAgIGxldCByb3cgPSB0aGlzLnJlbmRlcmVyLnZpc2libGVSb3dzW3Jvd0luZGV4XTtcbiAgICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgICAgIHJvdyA9IHRoaXMucmVuZGVyZXIudmlzaWJsZVJvd3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gcm93ID8gcm93LmJvdHRvbSA6IDA7XG5cbiAgICAgICAgcmVzIC09IHRoaXMucHJvcGVydGllcy5ncmlkTGluZXNIID8gdGhpcy5wcm9wZXJ0aWVzLmdyaWRMaW5lc1dpZHRoIDogMDtcblxuICAgICAgICByZXMgKz0gdGhpcy5wcm9wZXJ0aWVzLmZpeGVkUm93Q291bnQgPyB0aGlzLnByb3BlcnRpZXMuZml4ZWRMaW5lc0hXaWR0aCA6IDA7XG5cbiAgICAgICAgcmVzICs9IHRoaXMucHJvcGVydGllcy5ncmlkQm9yZGVyVG9wID8gdGhpcy5wcm9wZXJ0aWVzLmZpeGVkTGluZXNIV2lkdGggOiAwO1xuXG4gICAgICAgIC8vIHRvIGZ1bGx5IGltcGxlbWVudCBnb29nbGUgc2hlZXRzIHN0eWxlXG4gICAgICAgIHJlcyArPSAxO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcblxuICAgIGdldFZTY3JvbGxiYXJCb3R0b21NYXJnaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICBsZXQgcmVzID0gLTE7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5zY3JvbGxiYXJIU3R5bGUgJiYgdGhpcy5wcm9wZXJ0aWVzLnNjcm9sbGJhckhTdHlsZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIHJlcyArPSB0aGlzLnByb3BlcnRpZXMuc2Nyb2xsYmFySFN0eWxlLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcblxuICAgIGdldEZ1bGxDb250ZW50V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICBsZXQgcmVzID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB0aGlzLmdldENvbHVtbkNvdW50KCk7IGkrKyl7XG4gICAgICAgICAgICByZXMgKz0gdGhpcy5nZXRDb2x1bW5XaWR0aChpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBnZXRGdWxsQ29udGVudEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGxldCByZXMgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHRoaXMuZ2V0Um93Q291bnQoKTsgaSsrKXtcbiAgICAgICAgICAgIHJlcyArPSB0aGlzLmdldFJvd0hlaWdodChpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFNjcm9sbCB2YWx1ZXMgaGF2ZSBjaGFuZ2VkLCB3ZSd2ZSBiZWVuIG5vdGlmaWVkLlxuICAgICAqL1xuICAgIHNldFZTY3JvbGxiYXJWYWx1ZXM6IGZ1bmN0aW9uKG1heCkge1xuICAgICAgICB0aGlzLnNiVlNjcm9sbGVyLnJhbmdlID0ge1xuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiBtYXhcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgc2V0SFNjcm9sbGJhclZhbHVlczogZnVuY3Rpb24obWF4KSB7XG4gICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIucmFuZ2UgPSB7XG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBtYXg6IG1heFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBzY3JvbGxWYWx1ZUNoYW5nZWROb3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmhTY3JvbGxWYWx1ZSAhPT0gdGhpcy5zYlByZXZIU2Nyb2xsVmFsdWUgfHxcbiAgICAgICAgICAgIHRoaXMudlNjcm9sbFZhbHVlICE9PSB0aGlzLnNiUHJldlZTY3JvbGxWYWx1ZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc2JQcmV2SFNjcm9sbFZhbHVlID0gdGhpcy5oU2Nyb2xsVmFsdWU7XG4gICAgICAgICAgICB0aGlzLnNiUHJldlZTY3JvbGxWYWx1ZSA9IHRoaXMudlNjcm9sbFZhbHVlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jZWxsRWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jZWxsRWRpdG9yLnNjcm9sbFZhbHVlQ2hhbmdlZE5vdGlmaWNhdGlvbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiAodGhpcy5wcm9wZXJ0aWVzLm9uU2Nyb2xsRW5kTGltaXRUcmlnZ2VyID4gMCAmJiB0aGlzLnNiVlNjcm9sbGVyLnJhbmdlLm1heCAtIHRoaXMudlNjcm9sbFZhbHVlIDwgdGhpcy5wcm9wZXJ0aWVzLm9uU2Nyb2xsRW5kTGltaXRUcmlnZ2VyKSB7XG4gICAgICAgICAgICAvLyAgICAgLy8gZGF0YWRvYyBpbmZpbml0ZSBzY3JvbGxcbiAgICAgICAgICAgIC8vICAgICBpZiAodGhpcy5hcGkuZGF0YXNvdXJjZSAmJiAhdGhpcy5zY3JvbGxUcmlnZ2VyZWQpIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgdGhpcy5hcGkuc2V0RGF0YXNvdXJjZSh0aGlzLmFwaS5kYXRhc291cmNlKTtcbiAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgIHRoaXMuc2Nyb2xsVHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy5zY3JvbGxUcmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgdGhpcy5jb21wdXRlQ2VsbHNCb3VuZHMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFRoZSBkYXRhIGRpbWVuc2lvbnMgaGF2ZSBjaGFuZ2VkLCBvciBvdXIgcGl4ZWwgYm91bmRhcmllcyBoYXZlIGNoYW5nZWQuXG4gICAgICogQWRqdXN0IHRoZSBzY3JvbGxiYXIgcHJvcGVydGllcyBhcyBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgc3luY2hyb25pemVTY3JvbGxpbmdCb3VuZGFyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgbnVtQ29sdW1ucyA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgY29uc3QgbnVtUm93cyA9IHRoaXMuZ2V0Um93Q291bnQoKTtcblxuICAgICAgICBjb25zdCBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xuICAgICAgICBpZiAoIWJvdW5kcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZVdpZHRoID0gYm91bmRzLndpZHRoIC0gdGhpcy5iZWhhdmlvci5nZXRGaXhlZENvbHVtbnNNYXhXaWR0aCgpO1xuICAgICAgICBmb3IgKFxuICAgICAgICAgICAgdmFyIGNvbHVtbnNXaWR0aCA9IDAsIGxhc3RQYWdlQ29sdW1uQ291bnQgPSAwO1xuICAgICAgICAgICAgbGFzdFBhZ2VDb2x1bW5Db3VudCA8IG51bUNvbHVtbnMgJiYgY29sdW1uc1dpZHRoIDwgc2Nyb2xsYWJsZVdpZHRoO1xuICAgICAgICAgICAgbGFzdFBhZ2VDb2x1bW5Db3VudCsrXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29sdW1uc1dpZHRoICs9IHRoaXMuZ2V0Q29sdW1uV2lkdGgobnVtQ29sdW1ucyAtIGxhc3RQYWdlQ29sdW1uQ291bnQgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sdW1uc1dpZHRoID4gc2Nyb2xsYWJsZVdpZHRoKSB7XG4gICAgICAgICAgICBsYXN0UGFnZUNvbHVtbkNvdW50LS07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzY3JvbGxhYmxlSGVpZ2h0ID0gdGhpcy5yZW5kZXJlci5nZXRWaXNpYmxlU2Nyb2xsSGVpZ2h0KCk7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgICB2YXIgcm93c0hlaWdodCA9IDAsIGxhc3RQYWdlUm93Q291bnQgPSAwO1xuICAgICAgICAgICAgbGFzdFBhZ2VSb3dDb3VudCA8IG51bVJvd3MgJiYgcm93c0hlaWdodCA8IHNjcm9sbGFibGVIZWlnaHQ7XG4gICAgICAgICAgICBsYXN0UGFnZVJvd0NvdW50KytcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByb3dzSGVpZ2h0ICs9IHRoaXMuZ2V0Um93SGVpZ2h0KG51bVJvd3MgLSBsYXN0UGFnZVJvd0NvdW50IC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvd3NIZWlnaHQgPiBzY3JvbGxhYmxlSGVpZ2h0KSB7XG4gICAgICAgICAgICBsYXN0UGFnZVJvd0NvdW50LS07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbmZvcm0gc2Nyb2xsIGJhcnNcbiAgICAgICAgaWYgKHRoaXMuc2JIU2Nyb2xsZXIpIHtcbiAgICAgICAgICAgIGxldCBoTWF4ID0gTWF0aC5tYXgoMCwgdGhpcy5iZWhhdmlvci5nZXRDb2x1bW5zV2lkdGgodGhpcy5iZWhhdmlvci5nZXRBY3RpdmVDb2x1bW5Db3VudCgpIC0gbGFzdFBhZ2VDb2x1bW5Db3VudCArIDEpIC0gdGhpcy5iZWhhdmlvci5nZXRGaXhlZENvbHVtbnNXaWR0aCgpKTtcbiAgICAgICAgICAgIGhNYXggKz0gdGhpcy5iZWhhdmlvci5nZXRDb2x1bW5XaWR0aCh0aGlzLmJlaGF2aW9yLmdldEFjdGl2ZUNvbHVtbkNvdW50KCkpO1xuICAgICAgICAgICAgdGhpcy5zZXRIU2Nyb2xsYmFyVmFsdWVzKGhNYXgpO1xuICAgICAgICAgICAgdGhpcy5zZXRIU2Nyb2xsVmFsdWUoTWF0aC5taW4odGhpcy5oU2Nyb2xsVmFsdWUsIGhNYXgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zYlZTY3JvbGxlcikge1xuICAgICAgICAgICAgY29uc3Qgdk1heCA9IE1hdGgubWF4KDAsIHRoaXMuYmVoYXZpb3IuZ2V0Um93c0hlaWdodCh0aGlzLmJlaGF2aW9yLmdldFJvd0NvdW50KCkgLSBsYXN0UGFnZVJvd0NvdW50ICsgMikgLSB0aGlzLmJlaGF2aW9yLmdldEZpeGVkUm93c0hlaWdodCgpKTsgLy8gdG9kbyBkZXRlcm1pbmUgd2h5IDJcbiAgICAgICAgICAgIHRoaXMuc2V0VlNjcm9sbGJhclZhbHVlcyh2TWF4KTtcbiAgICAgICAgICAgIHRoaXMuc2V0VlNjcm9sbFZhbHVlKE1hdGgubWluKHRoaXMudlNjcm9sbFZhbHVlLCB2TWF4KSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbXB1dGVDZWxsc0JvdW5kcygpO1xuXG4gICAgICAgIC8vIHNjaGVkdWxlIHRvIGhhcHBlbiAqYWZ0ZXIqIHRoZSByZXBhaW50XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5zeW5jaHJvbml6ZVNjcm9sbGJhcnNWaXN1YWxpemF0aW9uLmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFNjcm9sbCB1cCBvbmUgZnVsbCBwYWdlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgcGFnZVVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3Qgcm93TnVtID0gdGhpcy5yZW5kZXJlci5nZXRQYWdlVXBSb3coKTtcbiAgICAgICAgY29uc3Qgcm93TnVtUGl4ZWxzID0gdGhpcy5iZWhhdmlvci5nZXRSb3dzSGVpZ2h0KHJvd051bSk7XG4gICAgICAgIHRoaXMuc2V0VlNjcm9sbFZhbHVlKHJvd051bVBpeGVscyk7XG4gICAgICAgIHJldHVybiByb3dOdW1QaXhlbHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU2Nyb2xsIGRvd24gb25lIGZ1bGwgcGFnZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHBhZ2VEb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3Qgcm93TnVtID0gdGhpcy5yZW5kZXJlci5nZXRQYWdlRG93blJvdygpO1xuICAgICAgICBjb25zdCByb3dOdW1QaXhlbHMgPSB0aGlzLmJlaGF2aW9yLmdldFJvd3NIZWlnaHQocm93TnVtKTtcbiAgICAgICAgdGhpcy5zZXRWU2Nyb2xsVmFsdWUocm93TnVtUGl4ZWxzKTtcbiAgICAgICAgcmV0dXJuIHJvd051bVBpeGVscztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBTY3JvbGwgbGVmdCBvbmUgZnVsbCBwYWdlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgcGFnZUxlZnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xuICAgICAgICBjb25zdCBjdXJyZW50U2Nyb2xsID0gdGhpcy5iZWhhdmlvci5nZXRTY3JvbGxQb3NpdGlvblgoKTtcbiAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZVdpZHRoID0gYm91bmRzLndpZHRoIC0gdGhpcy5iZWhhdmlvci5nZXRGaXhlZENvbHVtbnNNYXhXaWR0aCgpO1xuICAgICAgICBjb25zdCBsZWZ0UGl4ZWwgPSBjdXJyZW50U2Nyb2xsIC0gc2Nyb2xsYWJsZVdpZHRoO1xuICAgICAgICB0aGlzLnNldEhTY3JvbGxWYWx1ZShsZWZ0UGl4ZWwpO1xuICAgICAgICByZXR1cm4gbGVmdFBpeGVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFNjcm9sbCByaWdodCBvbmUgZnVsbCBwYWdlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgcGFnZVJpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICAgICAgY29uc3QgY3VycmVudFNjcm9sbCA9IHRoaXMuYmVoYXZpb3IuZ2V0U2Nyb2xsUG9zaXRpb25YKCk7XG4gICAgICAgIGNvbnN0IHNjcm9sbGFibGVXaWR0aCA9IGJvdW5kcy53aWR0aCAtIHRoaXMuYmVoYXZpb3IuZ2V0Rml4ZWRDb2x1bW5zTWF4V2lkdGgoKTtcbiAgICAgICAgY29uc3QgcmlnaHRQaXhlbCA9IGN1cnJlbnRTY3JvbGwgKyBzY3JvbGxhYmxlV2lkdGg7XG4gICAgICAgIHRoaXMuc2V0SFNjcm9sbFZhbHVlKHJpZ2h0UGl4ZWwpO1xuICAgICAgICByZXR1cm4gcmlnaHRQaXhlbDtcbiAgICB9XG59O1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJ3JlY3Rhbmd1bGFyJykuUmVjdGFuZ2xlO1xuXG4vKipcbiAqIEh5cGVyZ3JpZC9pbmRleC5qcyBtaXhlcyB0aGlzIG1vZHVsZSBpbnRvIGl0cyBwcm90b3R5cGUuXG4gKiBAbWl4aW5cbiAqL1xuZXhwb3J0cy5taXhpbiA9IHtcbiAgICBzZWxlY3Rpb25Jbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdyaWQgPSB0aGlzO1xuXG4gICAgICAgIC8qKiBmb3IgdXNlIGJ5IGZpbi1zZWxlY3Rpb24tY2hhbmdlZCwgZmluLXJvdy1zZWxlY3Rpb24tY2hhbmdlZCwgZmluLWNvbHVtbi1zZWxlY3Rpb24tY2hhbmdlZFxuICAgICAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25EZXRhaWxHZXR0ZXJzID0ge1xuICAgICAgICAgICAgZ2V0IHJvd3MoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyaWQuZ2V0U2VsZWN0ZWRSb3dzKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNvbHVtbnMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyaWQuZ2V0U2VsZWN0ZWRDb2x1bW5zKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHNlbGVjdGlvbnMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyaWQuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmb3IgdXNlIGJ5IGZpbi1jb250ZXh0LW1lbnUsIGZpbi1tb3VzZXVwLCBmaW4tbW91c2Vkb3duXG4gICAgICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkRldGFpbEdldHRlckRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModGhpcy5zZWxlY3Rpb25EZXRhaWxHZXR0ZXJzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2UgaGF2ZSBhbnkgc2VsZWN0aW9ucy5cbiAgICAgKi9cbiAgICBoYXNTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdldFNlbGVjdGlvbk1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIHdlcmUgbm90IGZ1bGx5IGluaXRpYWxpemVkIHlldFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGVsLmhhc1NlbGVjdGlvbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUYWIgc2VwYXJhdGVkIHZhbHVlIHN0cmluZyBmcm9tIHRoZSBzZWxlY3Rpb24gYW5kIG91ciBkYXRhLlxuICAgICAqL1xuICAgIGdldFNlbGVjdGlvbkFzVFNWOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNtID0gdGhpcy5zZWxlY3Rpb25Nb2RlbDtcbiAgICAgICAgaWYgKHNtLmhhc1NlbGVjdGlvbnMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF0cml4U2VsZWN0aW9uQXNUU1YodGhpcy5nZXRTZWxlY3Rpb25NYXRyaXgoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc20uaGFzUm93U2VsZWN0aW9ucygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXRyaXhTZWxlY3Rpb25Bc1RTVih0aGlzLmdldFJvd1NlbGVjdGlvbk1hdHJpeCgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChzbS5oYXNDb2x1bW5TZWxlY3Rpb25zKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE1hdHJpeFNlbGVjdGlvbkFzVFNWKHRoaXMuZ2V0Q29sdW1uU2VsZWN0aW9uTWF0cml4KCkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldE1hdHJpeFNlbGVjdGlvbkh0bWxTdHlsZXM6IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICAgIHJldHVybiBgPHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPlxudGFibGUge1xuYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcbmZvbnQ6IDEzcHggXCJIZWx2ZXRpY2EgTmV1ZVwiLEhlbHZldGljYSxBcmlhbCxzYW5zLXNlcmlmO1xufVxudGQge1xuYm9yZGVyOiAke3Byb3BzLmdyaWRMaW5lc1dpZHRofXB4IHNvbGlkICR7cHJvcHMuZ3JpZExpbmVzQ29sb3J9O1xubWF4LXdpZHRoOiAke3Byb3BzLm1heGltdW1Db2x1bW5XaWR0aH1weDtcbnBhZGRpbmc6ICR7cHJvcHMuY2VsbFBhZGRpbmd9cHggJHtwcm9wcy5jZWxsUGFkZGluZ0xlZnR9cHg7XG59XG5hIHtcbmNvbG9yOiAke3Byb3BzLmxpbmtDb2xvcn07XG50ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbn1cbi5oZWFkZXIge1xuZm9udDogJHtwcm9wcy5jb2x1bW5IZWFkZXJGb250Qm9sZH07XG59XG4ucHJlZml4IHtcbmZvbnQ6ICR7cHJvcHMuY29sdW1uVGl0bGVQcmVmaXhGb250fTtcbmNvbG9yOiAke3Byb3BzLmNvbHVtblRpdGxlUHJlZml4Q29sb3J9O1xucGFkZGluZy1yaWdodDogJHtwcm9wcy5jb2x1bW5UaXRsZVByZWZpeFJpZ2h0U3BhY2V9cHg7XG59XG4ucG9zdGZpeCB7XG5jb2xvcjogJHtwcm9wcy5jZWxsVmFsdWVQb3N0Zml4Q29sb3J9O1xuZm9udDogJHtwcm9wcy5jZWxsVmFsdWVQb3N0Zml4Rm9udH07XG5wYWRkaW5nLWxlZnQ6ICR7cHJvcHMuY2VsbFZhbHVlUG9zdGZpeExlZnRPZmZzZXR9cHg7XG59XG5tYXJrIHtcbmJhY2tncm91bmQtY29sb3I6ICR7cHJvcHMuaGlnaGxpZ2h0Q29sb3J9XG59XG48L3N0eWxlPmA7XG4gICAgfSxcblxuICAgIGdldE1hdHJpeFNlbGVjdGlvbkFzVFNWOiBmdW5jdGlvbihzZWxlY3Rpb25zKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICAgIGxldCBodG1sID0gJyc7XG5cbiAgICAgICAgLy8gb25seSB1c2UgdGhlIGRhdGEgZnJvbSB0aGUgbGFzdCBzZWxlY3Rpb25cbiAgICAgICAgaWYgKHNlbGVjdGlvbnMubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5wcm9wZXJ0aWVzO1xuXG4gICAgICAgICAgICBodG1sID0gdGhpcy5nZXRNYXRyaXhTZWxlY3Rpb25IdG1sU3R5bGVzKHByb3BzKSArICc8dGFibGU+JztcblxuICAgICAgICAgICAgbGV0IHdpZHRoID0gc2VsZWN0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gc2VsZWN0aW9uc1swXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbGFzdENvbCA9IHdpZHRoIC0gMSxcbiAgICAgICAgICAgICAgICAvL1doaXRlc3BhY2Ugd2lsbCBvbmx5IGJlIGFkZGVkIG9uIG5vbi1zaW5ndWxhciByb3dzLCBzZWxlY3Rpb25zXG4gICAgICAgICAgICAgICAgd2hpdGVTcGFjZURlbGltaXRlckZvclJvdyA9IChoZWlnaHQgPiAxID8gJ1xcbicgOiAnJyk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGggPSAwOyBoIDwgaGVpZ2h0OyBoKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB3ID0gMDsgdyA8IHdpZHRoOyB3KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gc2VsZWN0aW9uc1t3XVtoXTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBfdGV4dCA9IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnID8gdmFsLnRleHQgOiB2YWw7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gKF90ZXh0IHx8ICcnKSArICh3IDwgbGFzdENvbCA/ICdcXHQnIDogd2hpdGVTcGFjZURlbGltaXRlckZvclJvdyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzx0cj4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IF9odG1sID0gdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgPyB2YWwuaHRtbCA6IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9odG1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gYDx0ZCAke3ZhbC5jb2xzcGFuID8gYGNvbHNwYW49XCIke3ZhbC5jb2xzcGFuICsgMX1cImAgOiAnJ30gJHt2YWwucm93c3BhbiA/IGByb3dzcGFuPVwiJHt2YWwucm93c3BhbiArIDF9XCJgIDogJyd9PiR7X2h0bWwgfHwgJyd9PC90ZD5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHcgPT09IGxhc3RDb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8L3RyPic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGh0bWwgKz0gJzwvdGFibGU+JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHRleHQ6IHRleHQsIGh0bWw6IGh0bWwgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBDbGVhciBhbGwgdGhlIHNlbGVjdGlvbnMuXG4gICAgICovXG4gICAgY2xlYXJTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5jbGVhcih0aGlzLnByb3BlcnRpZXMua2VlcFJvd1NlbGVjdGlvbnMpO1xuICAgICAgICB0aGlzLmNsZWFyTW91c2VEb3duKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgQ2xlYXIgdGhlIG1vc3QgcmVjZW50IHNlbGVjdGlvbi5cbiAgICAgKi9cbiAgICBjbGVhck1vc3RSZWNlbnRTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLmNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbih0aGlzLnByb3BlcnRpZXMua2VlcFJvd1NlbGVjdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIENsZWFyIHRoZSBtb3N0IHJlY2VudCBjb2x1bW4gc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIGNsZWFyTW9zdFJlY2VudENvbHVtblNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuY2xlYXJNb3N0UmVjZW50Q29sdW1uU2VsZWN0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgQ2xlYXIgdGhlIG1vc3QgcmVjZW50IHJvdyBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgY2xlYXJNb3N0UmVjZW50Um93U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5jbGVhck1vc3RSZWNlbnRSb3dTZWxlY3Rpb24oKTtcbiAgICB9LFxuXG4gICAgY2xlYXJSb3dTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLmNsZWFyUm93U2VsZWN0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHN1bW1hcnkgU2VsZWN0IGdpdmVuIHJlZ2lvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3ggLSBvcmlnaW4geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBveSAtIG9yaWdpbiB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4IC0gZXh0ZW50IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXggLSBleHRlbnQgeVxuICAgICAqL1xuICAgIHNlbGVjdDogZnVuY3Rpb24ob3gsIG95LCBleCwgZXkpIHtcbiAgICAgICAgaWYgKG94IDwgMCB8fCBveSA8IDApIHtcbiAgICAgICAgICAgIC8vd2UgZG9uJ3Qgc2VsZWN0IG5lZ2F0aXZlIGFyZWFcbiAgICAgICAgICAgIC8vYWxzbyB0aGlzIG1lYW5zIHRoZXJlIGlzIG5vIG9yaWdpbiBtb3VzZSBkb3duIGZvciBhIHNlbGVjdGlvbiByZWN0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5zZWxlY3Qob3gsIG95LCBleCwgZXkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBHaXZlbiBwb2ludCBpcyBzZWxlY3RlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgdmVydGljYWwgY29vcmRpbmF0ZS5cbiAgICAgKi9cbiAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGVsLmlzU2VsZWN0ZWQoeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiBjb2x1bW4gaXMgc2VsZWN0ZWQgYW55d2hlcmUgaW4gdGhlIGVudGlyZSB0YWJsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSByb3cgaW5kZXguXG4gICAgICovXG4gICAgaXNDZWxsU2VsZWN0ZWRJblJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5pc0NlbGxTZWxlY3RlZEluUm93KHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gcm93IGlzIHNlbGVjdGVkIGFueXdoZXJlIGluIHRoZSBlbnRpcmUgdGFibGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgY29sdW1uIGluZGV4LlxuICAgICAqL1xuICAgIGlzQ2VsbFNlbGVjdGVkSW5Db2x1bW46IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTW9kZWwuaXNDZWxsU2VsZWN0ZWRJbkNvbHVtbih4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtib29sZWFufG51bWJlcltdfHN0cmluZ1tdfSBbaGlkZGVuQ29sdW1ucz1mYWxzZV0gLSBfUGVyIHtAbGluayBIeXBlcmdyaWR+Z2V0Q29sdW1uc30uX1xuICAgICAqIEByZXR1cm5zIHt7fX1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIGdldFJvd1NlbGVjdGlvbjogZnVuY3Rpb24oaGlkZGVuQ29sdW1ucykge1xuICAgICAgICB2YXIgZGF0YU1vZGVsID0gdGhpcy5iZWhhdmlvci5kYXRhTW9kZWwsXG4gICAgICAgICAgICBzZWxlY3RlZFJvd0luZGV4ZXMgPSB0aGlzLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGVkUm93cygpLFxuICAgICAgICAgICAgY29sdW1ucyA9IGdldENvbHVtbnMuY2FsbCh0aGlzLCBoaWRkZW5Db2x1bW5zKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGMgPSAwLCBDID0gY29sdW1ucy5sZW5ndGg7IGMgPCBDOyBjKyspIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBjb2x1bW5zW2NdLFxuICAgICAgICAgICAgICAgIHJvd3MgPSByZXN1bHRbY29sdW1uLm5hbWVdID0gbmV3IEFycmF5KHNlbGVjdGVkUm93SW5kZXhlcy5sZW5ndGgpO1xuICAgICAgICAgICAgc2VsZWN0ZWRSb3dJbmRleGVzLmZvckVhY2goZ2V0VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0VmFsdWUoc2VsZWN0ZWRSb3dJbmRleCwgaikge1xuICAgICAgICAgICAgdmFyIGRhdGFSb3cgPSBkYXRhTW9kZWwuZ2V0Um93KHNlbGVjdGVkUm93SW5kZXgpO1xuICAgICAgICAgICAgcm93c1tqXSA9IHZhbE9yRnVuYyhkYXRhUm93LCBjb2x1bW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtib29sZWFufG51bWJlcltdfHN0cmluZ1tdfSBbaGlkZGVuQ29sdW1ucz1mYWxzZV0gLSBfUGVyIHtAbGluayBIeXBlcmdyaWR+Z2V0Q29sdW1uc30uX1xuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIGdldFJvd1NlbGVjdGlvbk1hdHJpeDogZnVuY3Rpb24oaGlkZGVuQ29sdW1ucykge1xuICAgICAgICB2YXIgZGF0YU1vZGVsID0gdGhpcy5iZWhhdmlvci5kYXRhTW9kZWwsXG4gICAgICAgICAgICBzZWxlY3RlZFJvd0luZGV4ZXMgPSB0aGlzLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGVkUm93cygpLFxuICAgICAgICAgICAgY29sdW1ucyA9IGdldENvbHVtbnMuY2FsbCh0aGlzLCBoaWRkZW5Db2x1bW5zKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShjb2x1bW5zLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IDAsIEMgPSBjb2x1bW5zLmxlbmd0aDsgYyA8IEM7IGMrKykge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IGNvbHVtbnNbY107XG4gICAgICAgICAgICByZXN1bHRbY10gPSBuZXcgQXJyYXkoc2VsZWN0ZWRSb3dJbmRleGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBzZWxlY3RlZFJvd0luZGV4ZXMuZm9yRWFjaChnZXRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRWYWx1ZShzZWxlY3RlZFJvd0luZGV4LCByKSB7XG4gICAgICAgICAgICB2YXIgZGF0YVJvdyA9IGRhdGFNb2RlbC5nZXRSb3coc2VsZWN0ZWRSb3dJbmRleCk7XG4gICAgICAgICAgICByZXN1bHRbY11bcl0gPSB2YWxPckZ1bmMoZGF0YVJvdywgY29sdW1uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGdldENvbHVtblNlbGVjdGlvbk1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMuYmVoYXZpb3IsXG4gICAgICAgICAgICBkYXRhTW9kZWwgPSBiZWhhdmlvci5kYXRhTW9kZWwsXG4gICAgICAgICAgICBoZWFkZXJSb3dDb3VudCA9IHRoaXMuZ2V0SGVhZGVyUm93Q291bnQoKSxcbiAgICAgICAgICAgIHNlbGVjdGVkQ29sdW1uSW5kZXhlcyA9IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCksXG4gICAgICAgICAgICBudW1Sb3dzID0gdGhpcy5nZXRSb3dDb3VudCgpLFxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KHNlbGVjdGVkQ29sdW1uSW5kZXhlcy5sZW5ndGgpO1xuXG4gICAgICAgIHNlbGVjdGVkQ29sdW1uSW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uKHNlbGVjdGVkQ29sdW1uSW5kZXgsIGMpIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBiZWhhdmlvci5nZXRBY3RpdmVDb2x1bW4oc2VsZWN0ZWRDb2x1bW5JbmRleCksXG4gICAgICAgICAgICAgICAgdmFsdWVzID0gcmVzdWx0W2NdID0gbmV3IEFycmF5KG51bVJvd3MpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciByID0gaGVhZGVyUm93Q291bnQ7IHIgPCBudW1Sb3dzOyByKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVJvdyA9IGRhdGFNb2RlbC5nZXRSb3cocik7XG4gICAgICAgICAgICAgICAgdmFsdWVzW3JdID0gdmFsT3JGdW5jKGRhdGFSb3csIGNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGdldENvbHVtblNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMuYmVoYXZpb3IsXG4gICAgICAgICAgICBkYXRhTW9kZWwgPSBiZWhhdmlvci5kYXRhTW9kZWwsXG4gICAgICAgICAgICBoZWFkZXJSb3dDb3VudCA9IHRoaXMuZ2V0SGVhZGVyUm93Q291bnQoKSxcbiAgICAgICAgICAgIHNlbGVjdGVkQ29sdW1uSW5kZXhlcyA9IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCksXG4gICAgICAgICAgICByZXN1bHQgPSB7fSxcbiAgICAgICAgICAgIHJvd0NvdW50ID0gdGhpcy5nZXRSb3dDb3VudCgpO1xuXG4gICAgICAgIHNlbGVjdGVkQ29sdW1uSW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uKHNlbGVjdGVkQ29sdW1uSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBiZWhhdmlvci5nZXRBY3RpdmVDb2x1bW4oc2VsZWN0ZWRDb2x1bW5JbmRleCksXG4gICAgICAgICAgICAgICAgdmFsdWVzID0gcmVzdWx0W2NvbHVtbi5uYW1lXSA9IG5ldyBBcnJheShyb3dDb3VudCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHIgPSBoZWFkZXJSb3dDb3VudDsgciA8IHJvd0NvdW50OyByKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVJvdyA9IGRhdGFNb2RlbC5nZXRSb3cocik7XG4gICAgICAgICAgICAgICAgdmFsdWVzW3JdID0gdmFsT3JGdW5jKGRhdGFSb3csIGNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMuYmVoYXZpb3IsXG4gICAgICAgICAgICBkYXRhTW9kZWwgPSBiZWhhdmlvci5kYXRhTW9kZWwsXG4gICAgICAgICAgICBzZWxlY3Rpb25zID0gdGhpcy5nZXRTZWxlY3Rpb25zKCksXG4gICAgICAgICAgICByZWN0cyA9IG5ldyBBcnJheShzZWxlY3Rpb25zLmxlbmd0aCk7XG5cbiAgICAgICAgc2VsZWN0aW9ucy5mb3JFYWNoKGdldFJlY3QpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldFJlY3Qoc2VsZWN0aW9uUmVjdCwgaSkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBub3JtYWxpemVSZWN0KHNlbGVjdGlvblJlY3QpLFxuICAgICAgICAgICAgICAgIGNvbENvdW50ID0gcmVjdC5leHRlbnQueCArIDEsXG4gICAgICAgICAgICAgICAgcm93Q291bnQgPSByZWN0LmV4dGVudC55ICsgMSxcbiAgICAgICAgICAgICAgICBjb2x1bW5zID0ge307XG5cbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwLCB4ID0gcmVjdC5vcmlnaW4ueDsgYyA8IGNvbENvdW50OyBjKyssIHgrKykge1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSBiZWhhdmlvci5nZXRBY3RpdmVDb2x1bW4oeCksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IGNvbHVtbnNbY29sdW1uLm5hbWVdID0gbmV3IEFycmF5KHJvd0NvdW50KTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSAwLCB5ID0gcmVjdC5vcmlnaW4ueTsgciA8IHJvd0NvdW50OyByKyssIHkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YVJvdyA9IGRhdGFNb2RlbC5nZXRSb3coeSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1tyXSA9IHZhbE9yRnVuYyhkYXRhUm93LCBjb2x1bW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVjdHNbaV0gPSBjb2x1bW5zO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlY3RzO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3Rpb25NYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB7IGJlaGF2aW9yLCBiZWhhdmlvcjogeyBkYXRhTW9kZWwgfSB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9ucyA9IHRoaXMuZ2V0U2VsZWN0aW9ucygpO1xuXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvblJlY3QgPSBub3JtYWxpemVSZWN0KHNlbGVjdGlvbnNbc2VsZWN0aW9ucy5sZW5ndGggLSAxXSk7XG5cbiAgICAgICAgY29uc3QgY29sQ291bnQgPSBzZWxlY3Rpb25SZWN0LmV4dGVudC54ICsgMTtcbiAgICAgICAgY29uc3Qgcm93Q291bnQgPSBzZWxlY3Rpb25SZWN0LmV4dGVudC55ICsgMTtcbiAgICAgICAgY29uc3Qgcm93cyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGMgPSAwLCB4ID0gc2VsZWN0aW9uUmVjdC5vcmlnaW4ueDsgYyA8IGNvbENvdW50OyBjKyssIHgrKykge1xuICAgICAgICAgICAgY29uc3QgY29sUHJvcHMgPSBiZWhhdmlvci5nZXRDb2x1bW5Qcm9wZXJ0aWVzKHgpO1xuICAgICAgICAgICAgY29uc3QgY29sdW1uTmFtZSA9IGRhdGFNb2RlbC5nZXRDb2x1bW5OYW1lKHgpO1xuICAgICAgICAgICAgY29uc3Qgc2VhcmNoVHlwZSA9IGJlaGF2aW9yLmdldENvbHVtbih4KS5zZWFyY2hUeXBlO1xuICAgICAgICAgICAgY29uc3QgaXNBZ2dyZWdhdGlvblRyZWVDb2x1bW4gPSBjb2x1bW5OYW1lID09PSAnJCRhZ2dyZWdhdGlvbic7XG4gICAgICAgICAgICBsZXQgdmFsdWVzID0gcm93c1tjXSA9IG5ldyBBcnJheShyb3dDb3VudCk7XG4gICAgICAgICAgICBjb25zdCBhbHJlYWR5Q29waWVkID0gW107XG5cbiAgICAgICAgICAgIGNvbnN0IGdldEhlYWRlclZhbHVlID0gKHgsIHkpID0+IHtcbiAgICAgICAgICAgICAgICBhbHJlYWR5Q29waWVkLnB1c2goeSk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFNb2RlbC5pc1JlbmRlclNraXBOZWVkZWQoeCwgeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogJycgfTsgLy8gbm8gJ2h0bWwnIGtleSBiZWNhdXNlIHRoaXMgY2VsbCB3aWxsIGJlIG1lcmdlZCB3aXRoIGFub3RoZXIgb253XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRleHQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGh0bWwgPSAnJztcblxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgcHJlZml4XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xQcm9wcy5jb2xEZWYgJiYgY29sUHJvcHMuY29sRGVmLmhlYWRlclByZWZpeCAmJiAhZGF0YU1vZGVsLmdldERlZmluZWRDZWxsUHJvcGVydGllcyh4LCB5KS5pZ25vcmVWYWx1ZVByZWZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBjb2xQcm9wcy5jb2xEZWYuaGVhZGVyUHJlZml4ICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSBgPHNwYW4gY2xhc3M9XCJwcmVmaXhcIj4ke2NvbFByb3BzLmNvbERlZi5oZWFkZXJQcmVmaXh9PC9zcGFuPiBgO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSAoZGF0YU1vZGVsLmdldFZhbHVlKHgsIHkpIHx8ICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gdmFsO1xuICAgICAgICAgICAgICAgICAgICBodG1sICs9IGA8c3BhbiBjbGFzcz1cImhlYWRlclwiPiR7dmFsfTwvc3Bhbj5gO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBwb3N0Zml4XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc3RmaXggPSBkYXRhTW9kZWwuZ2V0Q291bnQoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3N0Zml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IGAgKCR7cG9zdGZpeH0pYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gYCA8c3BhbiBjbGFzcz1cInBvc3RmaXhcIj4oJHtwb3N0Zml4fSk8L3NwYW4+YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LnRyaW0oKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IGA8ZGl2PiR7aHRtbH08L2Rpdj5gLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sc3BhbjogZGF0YU1vZGVsLmdldENvbHNwYW4oeCwgeSksXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dzcGFuOiBkYXRhTW9kZWwuZ2V0Um93c3Bhbih4LCB5KVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAobGV0IHIgPSAwLCB5ID0gc2VsZWN0aW9uUmVjdC5vcmlnaW4ueTsgciA8IHJvd0NvdW50OyByKyssIHkrKykge1xuICAgICAgICAgICAgICAgIGlmIChiZWhhdmlvci5nZXRSb3dQcm9wZXJ0aWVzKHkpLmhlYWRlclJvdykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbcl0gPSBnZXRIZWFkZXJWYWx1ZSh4LCB5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsID0gZGF0YU1vZGVsLmdldFZhbHVlKHgsIHkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgfHwgdmFsID09PSBmYWxzZSB8fCB2YWwgPT09IDAgfHwgdmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29sb3IgPSB0aGlzLnByb3BlcnRpZXNbaXNBZ2dyZWdhdGlvblRyZWVDb2x1bW4gPyAnbGlua0NvbG9yJyA6ICdjb2xvciddO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGh0bWwgPSAnJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1ZhbHVlVXJsID0gZGF0YU1vZGVsLmlzVmFsdWVVcmwodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHRoaXMuZm9ybWF0VmFsdWUoY29sdW1uTmFtZSwgdmFsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLmhpZ2hMaWdodFRleHQgJiYgc2VhcmNoVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGRhdGFNb2RlbC5nZXRIaWdobGlnaHRlZFZhbHVlKHZhbCwgdGhpcy5wcm9wZXJ0aWVzLmhpZ2hMaWdodFRleHQsIHNlYXJjaFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCArPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sICs9IGA8c3BhbiBzdHlsZT1cImNvbG9yOiAke2NvbG9yfTsgJHtpc0FnZ3JlZ2F0aW9uVHJlZUNvbHVtbiA/ICd0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTsnIDogJyd9XCI+JHtpc1ZhbHVlVXJsID8gYDxhIGhyZWY9XCIke3ZhbH1cIj4ke3ZhbH08L2E+YCA6IHZhbH08L3NwYW4+YDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHBvc3RmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwb3N0Zml4ID0gaXNBZ2dyZWdhdGlvblRyZWVDb2x1bW4gPyBiZWhhdmlvci5nZXRBZ2dyZWdhdGlvbkNoaWxkQ291bnRCeUluZGV4KHkpIDogZGF0YU1vZGVsLmdldENvdW50KHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvc3RmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IGAgKCR7cG9zdGZpeH0pYDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sICs9IGA8c3BhbiBjbGFzcz1cInBvc3RmaXhcIj4oJHtwb3N0Zml4fSk8L3NwYW4+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzW3JdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQudHJpbSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IGA8ZGl2IHN0eWxlPVwidGV4dC1hbGlnbjogJHtjb2xQcm9wcy5oYWxpZ24gfHwgJ2xlZnQnfVwiPiR7aHRtbH08L2Rpdj5gXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzW3JdID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvcHlJbmNsdWRlSGVhZGVycykge1xuICAgICAgICAgICAgICAgIGxldCB5ID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJWYWx1ZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChiZWhhdmlvci5nZXRSb3dQcm9wZXJ0aWVzKHkpLmhlYWRlclJvdykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFscmVhZHlDb3BpZWQuaW5jbHVkZXMoeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlclZhbHVlcy5wdXNoKGdldEhlYWRlclZhbHVlKHgsIHkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICArK3k7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlclZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIFtdLnVuc2hpZnQuYXBwbHkodmFsdWVzLCBoZWFkZXJWYWx1ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByb3dzO1xuICAgIH0sXG5cbiAgICBzZWxlY3RDZWxsOiBmdW5jdGlvbih4LCB5LCBzaWxlbnQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5jbGVhcih0aGlzLnByb3BlcnRpZXMua2VlcFJvd1NlbGVjdGlvbnMpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLnNlbGVjdCh4LCB5LCAwLCAwLCBzaWxlbnQpO1xuICAgIH0sXG5cbiAgICB0b2dnbGVTZWxlY3RDb2x1bW46IGZ1bmN0aW9uKHgsIGtleXMpIHtcbiAgICAgICAga2V5cyA9IGtleXMgfHwgW107XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMuc2VsZWN0aW9uTW9kZWw7XG4gICAgICAgIHZhciBhbHJlYWR5U2VsZWN0ZWQgPSBtb2RlbC5pc0NvbHVtblNlbGVjdGVkKHgpO1xuICAgICAgICB2YXIgaGFzQ1RSTCA9IGtleXMuaW5kZXhPZignQ1RSTCcpID4gLTE7XG4gICAgICAgIHZhciBoYXNTSElGVCA9IGtleXMuaW5kZXhPZignU0hJRlQnKSA+IC0xO1xuXG4gICAgICAgIGlmICghaGFzQ1RSTCAmJiAhaGFzU0hJRlQpIHtcbiAgICAgICAgICAgIG1vZGVsLmNsZWFyKCk7XG4gICAgICAgICAgICBpZiAoIWFscmVhZHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIG1vZGVsLnNlbGVjdENvbHVtbih4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoYXNDVFJMKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFscmVhZHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kZXNlbGVjdENvbHVtbih4KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zZWxlY3RDb2x1bW4oeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFzU0hJRlQpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIG1vZGVsLnNlbGVjdENvbHVtbih0aGlzLmxhc3RFZGdlU2VsZWN0aW9uWzBdLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFscmVhZHlTZWxlY3RlZCAmJiAhaGFzU0hJRlQpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEVkZ2VTZWxlY3Rpb25bMF0gPSB4O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgICAgICB0aGlzLmZpcmVTeW50aGV0aWNDb2x1bW5TZWxlY3Rpb25DaGFuZ2VkRXZlbnQoKTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlU2VsZWN0Um93OiBmdW5jdGlvbih5LCBrZXlzKSB7XG4gICAgICAgIC8vd2UgY2FuIHNlbGVjdCB0aGUgdG90YWxzIHJvd3MgaWYgdGhleSBleGlzdCwgYnV0IG5vdCByb3dzIGFib3ZlIHRoYXRcbiAgICAgICAga2V5cyA9IGtleXMgfHwgW107XG5cbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLnNlbGVjdGlvbk1vZGVsO1xuICAgICAgICBjb25zdCBoYXNTSElGVCA9IGtleXMuaW5kZXhPZignU0hJRlQnKSA+IC0xO1xuICAgICAgICBjb25zdCBoYXNDVFJMID0ga2V5cy5pbmRleE9mKCdDVFJMJykgPiAtMTtcblxuICAgICAgICBpZiAoIWhhc0NUUkwgJiYgIWhhc1NISUZUKSB7XG4gICAgICAgICAgICBtb2RlbC5jbGVhcigpO1xuXG4gICAgICAgICAgICBtb2RlbC5zZWxlY3RSb3coeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGFzQ1RSTCkge1xuICAgICAgICAgICAgICAgIG1vZGVsLnNlbGVjdFJvdyh5KTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFzU0hJRlQpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIG1vZGVsLnNlbGVjdFJvdyh0aGlzLmxhc3RFZGdlU2VsZWN0aW9uWzFdLCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGFzU0hJRlQpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEVkZ2VTZWxlY3Rpb25bMV0gPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY1Jvd1NlbGVjdGlvbkNoYW5nZWRFdmVudCgpO1xuICAgIH0sXG5cbiAgICBzaW5nbGVTZWxlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wcm9wZXJ0aWVzLnNpbmdsZVJvd1NlbGVjdGlvbk1vZGU7XG5cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5jbGVhclJvd1NlbGVjdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgc2VsZWN0Vmlld3BvcnRDZWxsOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciB2YywgdnI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuZ2V0Um93Q291bnQoKSAmJlxuICAgICAgICAgICAgKHZjID0gdGhpcy5yZW5kZXJlci52aXNpYmxlQ29sdW1uc1t4XSkgJiZcbiAgICAgICAgICAgICh2ciA9IHRoaXMucmVuZGVyZXIudmlzaWJsZVJvd3NbeSArIHRoaXMuZ2V0SGVhZGVyUm93Q291bnQoKV0pXG4gICAgICAgICkge1xuICAgICAgICAgICAgeCA9IHZjLmNvbHVtbkluZGV4O1xuICAgICAgICAgICAgeSA9IHZyLnJvd0luZGV4O1xuICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KHgsIHksIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5zZXRNb3VzZURvd24odGhpcy5uZXdQb2ludCh4LCB5KSk7XG4gICAgICAgICAgICB0aGlzLnNldERyYWdFeHRlbnQodGhpcy5uZXdQb2ludCgwLCAwKSk7XG4gICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZWxlY3RUb1ZpZXdwb3J0Q2VsbDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgc2VsZWN0aW9ucywgdmMsIHZyO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAoc2VsZWN0aW9ucyA9IHRoaXMuZ2V0U2VsZWN0aW9ucygpKSAmJiBzZWxlY3Rpb25zLmxlbmd0aCAmJlxuICAgICAgICAgICAgKHZjID0gdGhpcy5yZW5kZXJlci52aXNpYmxlQ29sdW1uc1t4XSkgJiZcbiAgICAgICAgICAgICh2ciA9IHRoaXMucmVuZGVyZXIudmlzaWJsZVJvd3NbeSArIHRoaXMuZ2V0SGVhZGVyUm93Q291bnQoKV0pXG4gICAgICAgICkge1xuICAgICAgICAgICAgdmFyIG9yaWdpbiA9IHNlbGVjdGlvbnNbMF0ub3JpZ2luO1xuICAgICAgICAgICAgeCA9IHZjLmNvbHVtbkluZGV4O1xuICAgICAgICAgICAgeSA9IHZyLnJvd0luZGV4O1xuICAgICAgICAgICAgdGhpcy5zZXREcmFnRXh0ZW50KHRoaXMubmV3UG9pbnQoeCAtIG9yaWdpbi54LCB5IC0gb3JpZ2luLnkpKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KG9yaWdpbi54LCBvcmlnaW4ueSwgeCAtIG9yaWdpbi54LCB5IC0gb3JpZ2luLnkpO1xuICAgICAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VsZWN0VG9GaW5hbENlbGxPZkN1cnJlbnRSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdEZpbmFsQ2VsbE9mQ3VycmVudFJvdyh0cnVlKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0RmluYWxDZWxsT2ZDdXJyZW50Um93OiBmdW5jdGlvbih0bykge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0Um93Q291bnQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIGlmIChzZWxlY3Rpb25zICYmIHNlbGVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc2VsZWN0aW9uc1swXSxcbiAgICAgICAgICAgICAgICBvcmlnaW4gPSBzZWxlY3Rpb24ub3JpZ2luLFxuICAgICAgICAgICAgICAgIGV4dGVudCA9IHNlbGVjdGlvbi5leHRlbnQsXG4gICAgICAgICAgICAgICAgY29sdW1uQ291bnQgPSB0aGlzLmdldENvbHVtbkNvdW50KCk7XG5cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQnkoY29sdW1uQ291bnQsIDApO1xuXG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICAgICAgaWYgKHRvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Qob3JpZ2luLngsIG9yaWdpbi55LCBjb2x1bW5Db3VudCAtIG9yaWdpbi54IC0gMSwgZXh0ZW50LnkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdChjb2x1bW5Db3VudCAtIDEsIG9yaWdpbi55LCAwLCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VsZWN0VG9GaXJzdENlbGxPZkN1cnJlbnRSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdEZpcnN0Q2VsbE9mQ3VycmVudFJvdyh0cnVlKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0Rmlyc3RDZWxsT2ZDdXJyZW50Um93OiBmdW5jdGlvbih0bykge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0Um93Q291bnQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIGlmIChzZWxlY3Rpb25zICYmIHNlbGVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc2VsZWN0aW9uc1swXSxcbiAgICAgICAgICAgICAgICBvcmlnaW4gPSBzZWxlY3Rpb24ub3JpZ2luLFxuICAgICAgICAgICAgICAgIGV4dGVudCA9IHNlbGVjdGlvbi5leHRlbnQ7XG5cbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgICAgICBpZiAodG8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdChvcmlnaW4ueCwgb3JpZ2luLnksIC1vcmlnaW4ueCwgZXh0ZW50LnkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdCgwLCBvcmlnaW4ueSwgMCwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0SFNjcm9sbFZhbHVlKDApO1xuICAgICAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VsZWN0RmluYWxDZWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdldFJvd0NvdW50KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdENlbGxBbmRTY3JvbGxUb01ha2VWaXNpYmxlKHRoaXMuZ2V0Q29sdW1uQ291bnQoKSAtIDEsIHRoaXMuZ2V0Um93Q291bnQoKSAtIDEpO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0VG9GaW5hbENlbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0Um93Q291bnQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIGlmIChzZWxlY3Rpb25zICYmIHNlbGVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc2VsZWN0aW9uc1swXSxcbiAgICAgICAgICAgICAgICBvcmlnaW4gPSBzZWxlY3Rpb24ub3JpZ2luLFxuICAgICAgICAgICAgICAgIGNvbHVtbkNvdW50ID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpLFxuICAgICAgICAgICAgICAgIHJvd0NvdW50ID0gdGhpcy5nZXRSb3dDb3VudCgpO1xuXG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Qob3JpZ2luLngsIG9yaWdpbi55LCBjb2x1bW5Db3VudCAtIG9yaWdpbi54IC0gMSwgcm93Q291bnQgLSBvcmlnaW4ueSAtIDEpO1xuICAgICAgICAgICAgLy8gdGhpcy5zY3JvbGxCeShjb2x1bW5Db3VudCwgcm93Q291bnQpO1xuICAgICAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50bHkgc2VsZWN0aW9uIHJvdy5cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxzID0gdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIGlmIChzZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5iZWhhdmlvcixcbiAgICAgICAgICAgICAgICBjb2xDb3VudCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSxcbiAgICAgICAgICAgICAgICB0b3BSb3cgPSBzZWxzWzBdLm9yaWdpbi55LFxuICAgICAgICAgICAgICAgIHJvdyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy9oaWVyYXJjaHk6IGJlaGF2aW9yLmdldEZpeGVkQ29sdW1uVmFsdWUoMCwgdG9wUm93KVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY29sQ291bnQ7IGMrKykge1xuICAgICAgICAgICAgICAgIHJvd1tiZWhhdmlvci5nZXRBY3RpdmVDb2x1bW4oYykuaGVhZGVyXSA9IGJlaGF2aW9yLmdldFZhbHVlKGMsIHRvcFJvdyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBkaXNwYXRjaCBhIGBmaW4tc2VsZWN0aW9uLWNoYW5nZWRgIGV2ZW50LlxuICAgICAqL1xuICAgIHNlbGVjdGlvbkNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBQcm9qZWN0IHRoZSBjZWxsIHNlbGVjdGlvbiBpbnRvIHRoZSByb3dzXG4gICAgICAgIHRoaXMuc2VsZWN0Um93c0Zyb21DZWxscygpO1xuXG4gICAgICAgIC8vIFByb2plY3QgdGhlIGNlbGwgc2VsZWN0aW9uIGludG8gdGhlIGNvbHVtbnNcbiAgICAgICAgdGhpcy5zZWxlY3RDb2x1bW5zRnJvbUNlbGxzKCk7XG5cbiAgICAgICAgLy8gY2hhbmdlIGFwaSBkYXRhIGZvciBzZWxlY3RlZCBjb2x1bW5zXG4gICAgICAgIHRoaXMuc2VsZWN0Q29sRGVmc0ZvckFwaSgpO1xuXG4gICAgICAgIHZhciBzZWxlY3Rpb25FdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLXNlbGVjdGlvbi1jaGFuZ2VkJywge1xuICAgICAgICAgICAgZGV0YWlsOiB0aGlzLnNlbGVjdGlvbkRldGFpbEdldHRlcnNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoc2VsZWN0aW9uRXZlbnQpO1xuXG4gICAgfSxcblxuICAgIHNlbGVjdENvbERlZnNGb3JBcGk6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlQ29sdW1uRGVmcykge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRDb2x1bW5zID0gdGhpcy5nZXRTZWxlY3RlZENvbHVtbnMoKSB8fCBbXTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbnMgPSB0aGlzLmdldFNlbGVjdGlvbnMoKTtcblxuICAgICAgICAgICAgc2VsZWN0aW9ucy5mb3JFYWNoKHMgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBzLmxlZnQ7IGkgPD0gcy5yaWdodDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZWN0aW9ucy5pbmNsdWRlcyhpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRDb2x1bW5zLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkQ29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwaS5yYW5nZUNvbnRyb2xsZXIuc2VsZWN0ZWRDb2xzID0gdGhpcy5iZWhhdmlvci5nZXRBY3RpdmVDb2x1bW5zKCkuZmlsdGVyKGMgPT4gYy5jb2xEZWYgJiYgc2VsZWN0ZWRDb2x1bW5zLmluY2x1ZGVzKGMuaW5kZXgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcGkucmFuZ2VDb250cm9sbGVyLnNlbGVjdGVkQ29scyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hcGkucmFuZ2VDb250cm9sbGVyLnNlbGVjdGVkQ29scyA9IFtdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGlzQ29sdW1uT3JSb3dTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGVsLmlzQ29sdW1uT3JSb3dTZWxlY3RlZCgpO1xuICAgIH0sXG4gICAgc2VsZWN0Q29sdW1uOiBmdW5jdGlvbih4MSwgeDIpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5zZWxlY3RDb2x1bW4oeDEsIHgyKTtcbiAgICB9LFxuICAgIHNlbGVjdFJvdzogZnVuY3Rpb24oeTEsIHkyKSB7XG4gICAgICAgIGlmICh0aGlzLnNpbmdsZVNlbGVjdCgpKSB7XG4gICAgICAgICAgICB5MSA9IHkyO1xuICAgICAgICB9IGVsc2UgaWYgKHkyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIG11bHRpcGxlIHJvdyBzZWxlY3Rpb25cbiAgICAgICAgICAgIHkyID0geTE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLnNlbGVjdFJvdyh5MSwgeTIpO1xuICAgIH0sXG5cbiAgICBzZWxlY3RSb3dzRnJvbUNlbGxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BlcnRpZXMua2VlcFJvd1NlbGVjdGlvbnMgJiYgdGhpcy5wcm9wZXJ0aWVzLmF1dG9TZWxlY3RSb3dzKSB7XG4gICAgICAgICAgICB2YXIgbGFzdDtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuc2luZ2xlUm93U2VsZWN0aW9uTW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuc2VsZWN0Um93c0Zyb21DZWxscygwLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGxhc3QgPSB0aGlzLnNlbGVjdGlvbk1vZGVsLmdldExhc3RTZWxlY3Rpb24oKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdFJvdyhudWxsLCBsYXN0LmNvcm5lci55KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclJvd1NlbGVjdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5maXJlU3ludGhldGljUm93U2VsZWN0aW9uQ2hhbmdlZEV2ZW50KCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNlbGVjdENvbHVtbnNGcm9tQ2VsbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLmF1dG9TZWxlY3RDb2x1bW5zKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLnNlbGVjdENvbHVtbnNGcm9tQ2VsbHMoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZ2V0U2VsZWN0ZWRSb3dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0U2VsZWN0ZWRSb3dzKCk7XG4gICAgfSxcbiAgICBnZXRTZWxlY3RlZENvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRTZWxlY3RlZENvbHVtbnMoKTtcbiAgICB9LFxuICAgIGdldFNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRTZWxlY3Rpb25zKCk7XG4gICAgfSxcbiAgICBnZXRMYXN0U2VsZWN0aW9uVHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGVsLmdldExhc3RTZWxlY3Rpb25UeXBlKCk7XG4gICAgfSxcbiAgICBpc0luQ3VycmVudFNlbGVjdGlvblJlY3RhbmdsZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5pc0luQ3VycmVudFNlbGVjdGlvblJlY3RhbmdsZSh4LCB5KTtcbiAgICB9LFxuICAgIHNlbGVjdEFsbFJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLnNlbGVjdEFsbFJvd3MoKTtcbiAgICB9LFxuICAgIGFyZUFsbFJvd3NTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGVsLmFyZUFsbFJvd3NTZWxlY3RlZCgpO1xuICAgIH0sXG4gICAgdG9nZ2xlU2VsZWN0QWxsUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmFyZUFsbFJvd3NTZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLmNsZWFyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdEFsbFJvd3MoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgTW92ZSBjZWxsIHNlbGVjdGlvbiBieSBvZmZzZXQuXG4gICAgICogQGRlc2MgUmVwbGFjZSB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uIHdpdGggYSBzaW5nbGUgY2VsbCBzZWxlY3Rpb24gdGhhdCBpcyBtb3ZlZCAob2Zmc2V0WCxvZmZzZXRZKSBmcm9tIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24gZXh0ZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0geCBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIHkgb2Zmc2V0XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBtb3ZlU2luZ2xlU2VsZWN0OiBmdW5jdGlvbihvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgICAgIC8vIDExLjA1LjIwMTggY2xpZW50IHdhbnRzIHRvIGJlIGFibGUgY29udGludWUgY2VsbCBzZWxlY3Rpb24gZnJvbSBzYW1lIHBvaW50IGFmdGVyIGN0cmwrYVxuICAgICAgICB2YXIgbW91c2VDb3JuZXIgPSB0aGlzLmdldE1vdXNlRG93bigpOy8vLnBsdXModGhpcy5nZXREcmFnRXh0ZW50KCkpO1xuICAgICAgICB0aGlzLm1vdmVUb1NpbmdsZVNlbGVjdChcbiAgICAgICAgICAgIG1vdXNlQ29ybmVyLnggKyBvZmZzZXRYLFxuICAgICAgICAgICAgbW91c2VDb3JuZXIueSArIG9mZnNldFlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgTW92ZSBjZWxsIHNlbGVjdGlvbiBieSBvZmZzZXQuXG4gICAgICogQGRlc2MgUmVwbGFjZSB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uIHdpdGggYSBzaW5nbGUgY2VsbCBzZWxlY3Rpb24gdGhhdCBpcyBtb3ZlZCAob2Zmc2V0WCxvZmZzZXRZKSBmcm9tIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24gZXh0ZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdYIC0geCBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1kgLSB5IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIG1vdmVUb1NpbmdsZVNlbGVjdDogZnVuY3Rpb24obmV3WCwgbmV3WSkge1xuICAgICAgICB2YXIgbWF4Q29sdW1ucyA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSAtIDEsXG4gICAgICAgICAgICBtYXhSb3dzID0gdGhpcy5nZXRSb3dDb3VudCgpIC0gMSxcblxuICAgICAgICAgICAgbWF4Vmlld2FibGVDb2x1bW5zID0gdGhpcy5nZXRWaXNpYmxlQ29sdW1uc0NvdW50KCkgLSAxLFxuICAgICAgICAgICAgbWF4Vmlld2FibGVSb3dzID0gdGhpcy5nZXRWaXNpYmxlUm93c0NvdW50KCkgLSAxO1xuXG4gICAgICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLnNjcm9sbGluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgIG1heENvbHVtbnMgPSBNYXRoLm1pbihtYXhDb2x1bW5zLCBtYXhWaWV3YWJsZUNvbHVtbnMpO1xuICAgICAgICAgICAgbWF4Um93cyA9IE1hdGgubWluKG1heFJvd3MsIG1heFZpZXdhYmxlUm93cyk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdYID0gTWF0aC5taW4obWF4Q29sdW1ucywgTWF0aC5tYXgoMCwgbmV3WCkpO1xuICAgICAgICBuZXdZID0gTWF0aC5taW4obWF4Um93cywgTWF0aC5tYXgoMCwgbmV3WSkpO1xuXG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0KG5ld1gsIG5ld1ksIDAsIDApO1xuICAgICAgICB0aGlzLnNldE1vdXNlRG93bih0aGlzLm5ld1BvaW50KG5ld1gsIG5ld1kpKTtcbiAgICAgICAgdGhpcy5zZXREcmFnRXh0ZW50KHRoaXMubmV3UG9pbnQoMCwgMCkpO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0Q2VsbEFuZFNjcm9sbFRvTWFrZVZpc2libGUobmV3WCwgbmV3WSk7XG5cbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKiBAc3VtbWFyeSBFeHRlbmQgY2VsbCBzZWxlY3Rpb24gYnkgb2Zmc2V0LlxuICAgICAqIEBkZXNjIEF1Z21lbnQgdGhlIG1vc3QgcmVjZW50IHNlbGVjdGlvbiBleHRlbnQgYnkgKG9mZnNldFgsb2Zmc2V0WSkgYW5kIHNjcm9sbCBpZiBuZWNlc3NhcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSB4IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIHkgY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgZXh0ZW5kU2VsZWN0OiBmdW5jdGlvbihvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgICAgIHZhciBtYXhDb2x1bW5zID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpIC0gMSxcbiAgICAgICAgICAgIG1heFJvd3MgPSB0aGlzLmdldFJvd0NvdW50KCkgLSAxLFxuXG4gICAgICAgICAgICBtYXhWaWV3YWJsZUNvbHVtbnMgPSB0aGlzLnJlbmRlcmVyLnZpc2libGVDb2x1bW5zLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICBtYXhWaWV3YWJsZVJvd3MgPSB0aGlzLnJlbmRlcmVyLnZpc2libGVSb3dzLmxlbmd0aCAtIDEsXG5cbiAgICAgICAgICAgIG9yaWdpbiA9IHRoaXMuZ2V0TW91c2VEb3duKCksXG4gICAgICAgICAgICBleHRlbnQgPSB0aGlzLmdldERyYWdFeHRlbnQoKSxcblxuICAgICAgICAgICAgbmV3WCA9IGV4dGVudC54ICsgb2Zmc2V0WCxcbiAgICAgICAgICAgIG5ld1kgPSBleHRlbnQueSArIG9mZnNldFk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuc2Nyb2xsaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgbWF4Q29sdW1ucyA9IE1hdGgubWluKG1heENvbHVtbnMsIG1heFZpZXdhYmxlQ29sdW1ucyk7XG4gICAgICAgICAgICBtYXhSb3dzID0gTWF0aC5taW4obWF4Um93cywgbWF4Vmlld2FibGVSb3dzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld1ggPSBNYXRoLm1pbihtYXhDb2x1bW5zIC0gb3JpZ2luLngsIE1hdGgubWF4KC1vcmlnaW4ueCwgbmV3WCkpO1xuICAgICAgICBuZXdZID0gTWF0aC5taW4obWF4Um93cyAtIG9yaWdpbi55LCBNYXRoLm1heCgtb3JpZ2luLnksIG5ld1kpKTtcblxuICAgICAgICB0aGlzLmNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbigpO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0KG9yaWdpbi54LCBvcmlnaW4ueSwgbmV3WCwgbmV3WSk7XG4gICAgICAgIHRoaXMuc2V0RHJhZ0V4dGVudCh0aGlzLm5ld1BvaW50KG5ld1gsIG5ld1kpKTtcblxuICAgICAgICB2YXIgY29sU2Nyb2xsZWQgPSB0aGlzLmluc3VyZU1vZGVsQ29sSXNWaXNpYmxlKG5ld1ggKyBvcmlnaW4ueCwgb2Zmc2V0WCksXG4gICAgICAgICAgICByb3dTY3JvbGxlZCA9IHRoaXMuaW5zdXJlTW9kZWxSb3dJc1Zpc2libGUobmV3WSArIG9yaWdpbi55LCBvZmZzZXRZKTtcblxuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcblxuICAgICAgICBjb25zdCBuZWVkU2Nyb2xsID0gY29sU2Nyb2xsZWQgfHwgcm93U2Nyb2xsZWQ7XG5cbiAgICAgICAgaWYgKG5lZWRTY3JvbGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9NYWtlVmlzaWJsZShuZXdYICsgb3JpZ2luLngsIG5ld1kgKyBvcmlnaW4ueSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmVlZFNjcm9sbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZHxDZWxsRXZlbnR9XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdXNlQWxsQ2VsbHNdIC0gU2VhcmNoIGluIGFsbCByb3dzIGFuZCBjb2x1bW5zIGluc3RlYWQgb2Ygb25seSByZW5kZXJlZCBvbmVzLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgZ2V0R3JpZENlbGxGcm9tTGFzdFNlbGVjdGlvbjogZnVuY3Rpb24odXNlQWxsQ2VsbHMpIHtcbiAgICAgICAgdmFyIHNlbCA9IHRoaXMuc2VsZWN0aW9uTW9kZWwuZ2V0TGFzdFNlbGVjdGlvbigpO1xuICAgICAgICByZXR1cm4gc2VsICYmIChuZXcgdGhpcy5iZWhhdmlvci5DZWxsRXZlbnQpLnJlc2V0R3JpZFhEYXRhWShzZWwub3JpZ2luLngsIHNlbC5vcmlnaW4ueSwgbnVsbCwgdXNlQWxsQ2VsbHMpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtib29sZWFufG51bWJlcltdfHN0cmluZ1tdfSBbaGlkZGVuQ29sdW1ucz1mYWxzZV0gLSBPbmUgb2Y6XG4gKiBgZmFsc2VgIC0gQWN0aXZlIGNvbHVtbiBsaXN0XG4gKiBgdHJ1ZWAgLSBBbGwgY29sdW1uIGxpc3RcbiAqIGBBcnJheWAgLSBBY3RpdmUgY29sdW1uIGxpc3Qgd2l0aCBsaXN0ZWQgY29sdW1ucyBwcmVmaXhlZCBhcyBuZWVkZWQgKHdoZW4gbm90IGFscmVhZHkgaW4gdGhlIGxpc3QpLiBFYWNoIGl0ZW0gaW4gdGhlIGFycmF5IG1heSBiZSBlaXRoZXI6XG4gKiAqIGBudW1iZXJgIC0gaW5kZXggaW50byBhbGwgY29sdW1uIGxpc3RcbiAqICogYHN0cmluZ2AgLSBuYW1lIG9mIGEgY29sdW1uIGZyb20gdGhlIGFsbCBjb2x1bW4gbGlzdFxuICogQHJldHVybnMge0NvbHVtbltdfVxuICogQG1lbWJlck9mIEh5cGVyZ3JpZH5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29sdW1ucyhoaWRkZW5Db2x1bW5zKSB7XG4gICAgdmFyIGNvbHVtbnMsXG4gICAgICAgIGFsbENvbHVtbnMgPSB0aGlzLmJlaGF2aW9yLmdldENvbHVtbnMoKSxcbiAgICAgICAgYWN0aXZlQ29sdW1ucyA9IHRoaXMuYmVoYXZpb3IuZ2V0QWN0aXZlQ29sdW1ucygpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGlkZGVuQ29sdW1ucykpIHtcbiAgICAgICAgY29sdW1ucyA9IFtdO1xuICAgICAgICBoaWRkZW5Db2x1bW5zLmZvckVhY2goZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0eXBlb2YgaW5kZXggPT09ICdudW1iZXInID8gJ2luZGV4JyA6ICduYW1lJyxcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBhbGxDb2x1bW5zLmZpbmQoY29sdW1uID0+IGNvbHVtbltrZXldID09PSBpbmRleCk7XG4gICAgICAgICAgICBpZiAoYWN0aXZlQ29sdW1ucy5pbmRleE9mKGNvbHVtbikgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb2x1bW5zID0gY29sdW1ucy5jb25jYXQoYWN0aXZlQ29sdW1ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29sdW1ucyA9IGhpZGRlbkNvbHVtbnMgPyBhbGxDb2x1bW5zIDogYWN0aXZlQ29sdW1ucztcbiAgICB9XG5cbiAgICByZXR1cm4gY29sdW1ucztcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUmVjdChyZWN0KSB7XG4gICAgdmFyIG8gPSByZWN0Lm9yaWdpbixcbiAgICAgICAgYyA9IHJlY3QuY29ybmVyLFxuXG4gICAgICAgIG94ID0gTWF0aC5taW4oby54LCBjLngpLFxuICAgICAgICBveSA9IE1hdGgubWluKG8ueSwgYy55KSxcblxuICAgICAgICBjeCA9IE1hdGgubWF4KG8ueCwgYy54KSxcbiAgICAgICAgY3kgPSBNYXRoLm1heChvLnksIGMueSk7XG5cbiAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShveCwgb3ksIGN4IC0gb3gsIGN5IC0gb3kpO1xufVxuXG4vKipcbiAqIEB0aGlzIHtkYXRhUm93T2JqZWN0fVxuICogQHBhcmFtIGNvbHVtblxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdmFsT3JGdW5jKGRhdGFSb3csIGNvbHVtbikge1xuICAgIHZhciByZXN1bHQsIGNhbGN1bGF0b3I7XG4gICAgaWYgKGRhdGFSb3cpIHtcbiAgICAgICAgcmVzdWx0ID0gZGF0YVJvd1tjb2x1bW4ubmFtZV07XG4gICAgICAgIGNhbGN1bGF0b3IgPSAodHlwZW9mIHJlc3VsdClbMF0gPT09ICdmJyAmJiByZXN1bHQgfHwgY29sdW1uLmNhbGN1bGF0b3I7XG4gICAgICAgIGlmIChjYWxjdWxhdG9yKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjYWxjdWxhdG9yKGRhdGFSb3csIGNvbHVtbi5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzdWx0LnZhbHVlKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgfHwgcmVzdWx0ID09PSAwIHx8IHJlc3VsdCA9PT0gZmFsc2UgPyByZXN1bHQgOiAnJztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyBmaWxlIGNyZWF0ZXMgdGhlIEh5cGVyZ3JpZCB0aGVtZSByZWdpc3RyeSwgZXhwb3NlZCB2aWE6XG4vLyBzaGFyZWQgbWV0aG9kcyBgSHlwZXJncmlkLnJlZ2lzdGVyVGhlbWVgIGFuZCBgSHlwZXJncmlkLmFwcGx5VGhlbWVgXG4vLyBhbmQgaW5zdGFuY2UgbWV0aG9kcyBgbXlHcmlkLmFwcGx5VGhlbWVgLlxuLy8gVGhlIGluaXRpYWwgcmVnaXN0cnkgY29uc2lzdHMgb2YgYSBzaW5nbGUgdGhlbWUgKCdkZWZhdWx0JykuXG4vLyBBcHBsaWNhdGlvbiBkZXZlbG9wZXJzIGNhbiBhZGQgYWRkaXRpb25hbCB0aGVtZXMgdG8gdGhpcyByZWdpc3RyeS5cblxudmFyIF8gPSByZXF1aXJlKCdvYmplY3QtaXRlcmF0b3JzJyk7IC8vIGZ5aTogaW5zdGFsbHMgdGhlIEFycmF5LnByb3RvdHlwZS5maW5kIHBvbHlmaWxsLCBhcyBuZWVkZWRcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcbnZhciBkeW5hbWljUHJvcGVydHlEZXNjcmlwdG9ycyA9IHJlcXVpcmUoJy4uL2xpYi9keW5hbWljUHJvcGVydGllcycpO1xudmFyIEh5cGVyZ3JpZEVycm9yID0gcmVxdWlyZSgnLi4vbGliL2Vycm9yJyk7XG5cbnZhciBzdHlsZXMgPSBbXG4gICAgJ0JhY2tncm91bmRDb2xvcicsXG4gICAgJ0NvbG9yJyxcbiAgICAnRm9udCdcbl07XG5cbnZhciBzdHlsZXNXaXRoSGFsaWduID0gc3R5bGVzLmNvbmNhdChbXG4gICAgJ0hhbGlnbidcbl0pO1xuXG52YXIgZGF0YUNlbGxTdHlsZXMgPSBzdHlsZXNXaXRoSGFsaWduLmNvbmNhdChbXG4gICAgJ2NlbGxQYWRkaW5nJyxcbiAgICAnaWNvblBhZGRpbmcnXG5dKTtcblxudmFyIHN0eWxlcnMgPSBbXG4gICAgeyBwcmVmaXg6ICcnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IGRhdGFDZWxsU3R5bGVzIH0sXG4gICAgeyBwcmVmaXg6ICdmb3JlZ3JvdW5kU2VsZWN0aW9uJywgICAgICAgICAgICAgcHJvcHM6IHN0eWxlcyB9LFxuICAgIHsgcHJlZml4OiAnY29sdW1uSGVhZGVyJywgICAgICAgICAgICAgICAgICAgIHByb3BzOiBzdHlsZXNXaXRoSGFsaWduIH0sXG4gICAgeyBwcmVmaXg6ICdjb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uJywgcHJvcHM6IHN0eWxlcyB9LFxuICAgIHsgcHJlZml4OiAncm93SGVhZGVyJywgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBzdHlsZXMgfSxcbiAgICB7IHByZWZpeDogJ3Jvd0hlYWRlckZvcmVncm91bmRTZWxlY3Rpb24nLCAgICBwcm9wczogc3R5bGVzIH1cbl07XG5cbnZhciBkeW5hbWljQ29zbWV0aWNzID0ge1xuICAgIHJvd0hlYWRlckNoZWNrYm94ZXM6IGRlZmF1bHRzLnJvd0hlYWRlckNoZWNrYm94ZXMsXG4gICAgcm93SGVhZGVyTnVtYmVyczogZGVmYXVsdHMucm93SGVhZGVyTnVtYmVycyxcbiAgICBncmlkQm9yZGVyOiBkZWZhdWx0cy5ncmlkQm9yZGVyLFxuICAgIGdyaWRCb3JkZXJUb3A6IGRlZmF1bHRzLmdyaWRCb3JkZXJUb3AsXG4gICAgZ3JpZEJvcmRlclJpZ2h0OiBkZWZhdWx0cy5ncmlkQm9yZGVyUmlnaHQsXG4gICAgZ3JpZEJvcmRlckJvdHRvbTogZGVmYXVsdHMuZ3JpZEJvcmRlckJvdHRvbSxcbiAgICBncmlkQm9yZGVyTGVmdDogZGVmYXVsdHMuZ3JpZEJvcmRlckxlZnQsXG4gICAgZ3JpZFJlbmRlcmVyOiBkZWZhdWx0cy5ncmlkUmVuZGVyZXJcbn07XG5cbi8vIENyZWF0ZSB0aGUgYGRlZmF1bHRUaGVtZWAgdGhlbWUgYnkgY29weWluZyBvdmVyIHRoZSB0aGVtZSBwcm9wcyxcbi8vIHdoaWNoIGlzIGEgc3Vic2V0IG9mIGFsbCB0aGUgcHJvcHMgZGVmaW5lZCBpbiBkZWZhdWx0cy5qcywgYmVnaW5uaW5nIHdpdGhcbi8vIHRoZXkgZHluYW1pYyBjb3NtZXRpY3MgYW5kIGB0aGVtZU5hbWVgLi4uXG52YXIgZGVmYXVsdFRoZW1lID0gT2JqZWN0LmFzc2lnbih7fSwgZHluYW1pY0Nvc21ldGljcywge1xuICAgIHRoZW1lTmFtZTogZGVmYXVsdHMudGhlbWVOYW1lXG59KTtcblxuLy8gLi4uYW5kIHRoZW4gYWRkaW5nIG5vbi1keW5hbWljIGNvc21ldGljcyBpbnRvIGBkZWZhdWx0VGhlbWVgLCBieSBjb21iaW5pbmcgdGhlIGFib3ZlXG4vLyBwcmVmaXhlcyB3aXRoIHRoZWlyIHN0eWxlcyB0byBnZXQgcHJvcCBuYW1lcyBhbmQgdGhlbiBjb3B5IHRob3NlIHByb3BzIGZyb20gYGRlZmF1bHRzYC5cbnN0eWxlcnMucmVkdWNlKGZ1bmN0aW9uKHRoZW1lLCBzdHlsZXIpIHtcbiAgICByZXR1cm4gc3R5bGVyLnByb3BzLnJlZHVjZShmdW5jdGlvbih0aGVtZSwgcHJvcCkge1xuICAgICAgICBwcm9wID0gc3R5bGVyLnByZWZpeCArIHByb3A7XG4gICAgICAgIHByb3AgPSBwcm9wLnJlcGxhY2UoJ0ZvcmVncm91bmRTZWxlY3Rpb25CYWNrZ3JvdW5kJywgJ0JhY2tncm91bmRTZWxlY3Rpb24nKTsgLy8gdW5mb3J0dW5hdGUhXG4gICAgICAgIHByb3AgPSBwcm9wWzBdLnRvTG93ZXJDYXNlKCkgKyBwcm9wLnN1YnN0cigxKTtcbiAgICAgICAgdGhlbWVbcHJvcF0gPSBkZWZhdWx0c1twcm9wXTtcbiAgICAgICAgcmV0dXJuIHRoZW1lO1xuICAgIH0sIHRoZW1lKTtcbn0sIGRlZmF1bHRUaGVtZSk7XG5cbi8qKlxuICogQHN1bW1hcnkgVGhlIEh5cGVyZ3JpZCB0aGVtZSByZWdpc3RyeS5cbiAqIEBkZXNjIFRoZSBzdGFuZGFyZCByZWdpc3RyeSBjb25zaXN0cyBvZiBhIHNpbmdsZSB0aGVtZSwgYGRlZmF1bHRgLCBidWlsdCBmcm9tIHZhbHVlcyBpbiBkZWZhdWx0cy5qcy5cbiAqL1xudmFyIHJlZ2lzdHJ5ID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgZGVmYXVsdDogeyB2YWx1ZTogZGVmYXVsdFRoZW1lIH1cbn0pO1xudmFyIHBzZXVkb3Byb3BBZHZpY2UgPSB7XG4gICAgc2hvd1Jvd051bWJlcnM6ICdyb3dIZWFkZXJDaGVja2JveGVzIGFuZCByb3dIZWFkZXJOdW1iZXJzJyxcbiAgICBsaW5lQ29sb3I6ICdncmlkTGluZXNDb2xvciBhbmQgZ3JpZExpbmVzQ29sb3InLFxuICAgIGxpbmVXaWR0aDogJ2dyaWRMaW5lc1dpZHRoIGFuZCBncmlkTGluZXNXaWR0aCcsXG4gICAgZ3JpZEJvcmRlcjogJ2dyaWRCb3JkZXJMZWZ0LCBncmlkQm9yZGVyUmlnaHQsIGdyaWRCb3JkZXJUb3AsIGFuZCBncmlkQm9yZGVyQm90dG9tJ1xufTtcblxuZnVuY3Rpb24gYXBwbHlUaGVtZSh0aGVtZSkge1xuICAgIHZhciB0aGVtZUxheWVyLCBncmlkcywgcHJvcHM7XG5cbiAgICBpZiAodGhlbWUgJiYgdHlwZW9mIHRoZW1lID09PSAnb2JqZWN0JyAmJiAhT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhlbWUpLmxlbmd0aCkge1xuICAgICAgICB0aGVtZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3RoZW1lKSB7XG4gICAgICAgIGdyaWRzID0gW3RoaXNdO1xuICAgICAgICB0aGVtZUxheWVyID0gdGhpcy5fdGhlbWU7XG4gICAgICAgIHByb3BzID0gdGhpcy5wcm9wZXJ0aWVzO1xuXG4gICAgICAgIC8vIElmIHJlbW92aW5nIHRoZW1lLCByZXNldCBwcm9wcyB0byBkZWZhdWx0c1xuICAgICAgICBpZiAoIXRoZW1lKSB7XG4gICAgICAgICAgICAvLyBEZWxldGUgKG5vbi1keW5hbWljKSBncmlkIHByb3BzIG5hbWVkIGluIHRoaXMgdGhlbWUsIHJldmVhbGluZyBkZWZhdWx0c1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhlbWVMYXllcikuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gZHluYW1pY1Byb3BlcnR5RGVzY3JpcHRvcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBSZXNldCBkeW5hbWljIGNvc21ldGljIHByb3BzIHRvIGRlZmF1bHRzXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkeW5hbWljQ29zbWV0aWNzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIHByb3BzLnZhcltrZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVsZXRlIGFsbCBvd24gcHJvcHMgZnJvbSB0aGlzIGdyaWQgaW5zdGFuY2UncyB0aGVtZSBsYXllciAoZGVmaW5lZCBieSBhbiBlYXJpbGVyIGNhbGwpXG4gICAgICAgIE9iamVjdC5rZXlzKHRoZW1lTGF5ZXIpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBkZWxldGUgdGhlbWVMYXllcltrZXldO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBncmlkcyA9IHRoaXMuZ3JpZHM7XG4gICAgICAgIHRoZW1lTGF5ZXIgPSBkZWZhdWx0czsgLy8gZ2xvYmFsIHRoZW1lIGxheWVyXG4gICAgICAgIHRoZW1lID0gdGhlbWUgfHwgJ2RlZmF1bHQnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghcmVnaXN0cnlbdGhlbWVdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSHlwZXJncmlkRXJyb3IoJ1Vua25vd24gdGhlbWUgXCInICsgdGhlbWUgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGVtZSA9IHJlZ2lzdHJ5W3RoZW1lXTtcbiAgICB9XG5cbiAgICBpZiAodGhlbWUpIHtcbiAgICAgICAgLy8gV2hlbiBubyB0aGVtZSBuYW1lLCBzZXQgaXQgdG8gZXhwbGljaXQgYHVuZGVmaW5lZGAgKHRvIG1hc2sgZGVmYXVsdHMudGhlbWVOYW1lKS5cbiAgICAgICAgaWYgKCF0aGVtZS50aGVtZU5hbWUpIHtcbiAgICAgICAgICAgIHRoZW1lLnRoZW1lTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKHRoZW1lKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSBpbiBkeW5hbWljUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gZHluYW1pY0Nvc21ldGljcykge1xuICAgICAgICAgICAgICAgICAgICBncmlkcy5mb3JFYWNoKGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWQucHJvcGVydGllc1trZXldID0gdGhlbWVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRHluYW1pYyBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIG9uIHByb3BlcnRpZXMgbGF5ZXI7IGRlZmluaW5nIHRoZXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHItdmFsdWVzIG9uIHRoZSB0aGVtZSBsYXllciBpcyBpbmVmZmVjdGl2ZSBzbyBsZXQncyBub3QgYWxsb3cgaXQuXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gcHNldWRvcHJvcEFkdmljZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnSWdub3JpbmcgdW5leHBlY3RlZCBwc2V1ZG8tcHJvcCAnICsga2V5ICsgJyBpbiB0aGVtZSBvYmplY3QuIFVzZSBhY3R1YWwgcHJvcHMgJyArIG1lc3NhZ2UgKyAnIGluc3RlYWQuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiAnSWdub3JpbmcgaW52YWxpZCBwcm9wZXJ0eSAnICsga2V5ICsgJyBpbiB0aGVtZSBvYmplY3QuJztcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhlbWVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE5vIC5hc3NpZ24oKSBiZWNhdXNlIHRoZW1lTmFtZSBpcyByZWFkLW9ubHkgaW4gZGVmYXVsdHMgbGF5ZXJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhlbWVMYXllciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModGhlbWUpKTtcbiAgICB9XG5cbiAgICBncmlkcy5mb3JFYWNoKGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSk7XG59XG5cblxuLyoqXG4gKiBAc3VtbWFyeSBJbnN0YW5jZSB0aGVtZSBzdXBwb3J0LlxuICogQGRlc2MgSHlwZXJncmlkL2luZGV4LmpzIG1peGVzIHRoaXMgbW9kdWxlIGludG8gaXRzIHByb3RvdHlwZS5cbiAqIEBtaXhpblxuICovXG52YXIgbWl4aW4gPSB7XG4gICAgaW5pdFRoZW1lTGF5ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVzY2VuZHMgZnJvbSB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzfGRlZmF1bHRzfS5cbiAgICAgICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RoZW1lID0gT2JqZWN0LmNyZWF0ZShkZWZhdWx0cyk7XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcy5fdGhlbWUsIGR5bmFtaWNQcm9wZXJ0eURlc2NyaXB0b3JzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQXBwbHkgYSBncmlkIHRoZW1lLlxuICAgICAqIEBkZXNjIEFwcGx5IHByb3BzIGZyb20gdGhlIGdpdmVuIHRoZW1lIG9iamVjdCB0byB0aGUgZ3JpZCBpbnN0YW5jZSxcbiAgICAgKiB0aGUgaW5zdGFuY2UncyBgbXlHcmlkLnRoZW1lTGF5ZXJgIGxheWVyIGluIHRoZSBwcm9wZXJ0aWVzIGhpZXJhcmNoeS5cbiAgICAgKiBAdGhpcyB7SHlwZXJncmlkfVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gW3RoZW1lXSAtIE9uZSBvZjpcbiAgICAgKiAqICoqc3RyaW5nOioqIEEgcmVnaXN0ZXJlZCB0aGVtZSBuYW1lLlxuICAgICAqICogKipvYmplY3Q6KiogQSB1bnJlZ2lzdGVyZWQgKGFub255bW91cykgdGhlbWUgb2JqZWN0LiBFbXB0eSBvYmplY3QgcmVtb3ZlcyBncmlkIHRoZW1lLCBleHBvc2luZyBnbG9iYWwgdGhlbWUuXG4gICAgICogKiBfZmFsc3kgdmFsdWU6XyBBbHNvIHJlbW92ZXMgZ3JpZCB0aGVtZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IFt0aGVtZS50aGVtZU5hbWU9dW5kZWZpbmVkXVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgYXBwbHlUaGVtZTogYXBwbHlUaGVtZSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCBjdXJyZW50bHkgYWN0aXZlIHRoZW1lLlxuICAgICAqIEBkZXNjIE1heSByZXR1cm4gYSB0aGVtZSBuYW1lIG9yIGEgdGhlbWUgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfG9iamVjdH0gT25lIG9mOlxuICAgICAqICogKipzdHJpbmc6KiogVGhlbWUgbmFtZSAocmVnaXN0ZXJlZCB0aGVtZSkuXG4gICAgICogKiAqKm9iamVjdDoqKiBUaGVtZSBvYmplY3QgKHVucmVnaXN0ZXJlZCBhbm9ueW1vdXMgdGhlbWUpLlxuICAgICAqICogKip1bmRlZmluZWQ6KiogTm8gdGhlbWUgKGkuZS4sIHRoZSBkZWZhdWx0IHRoZW1lKS5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIGdldFRoZW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRoZW1lTGF5ZXIgPSB0aGlzLl90aGVtZSxcbiAgICAgICAgICAgIHRoZW1lTmFtZSA9IHRoZW1lTGF5ZXIudGhlbWVOYW1lO1xuICAgICAgICByZXR1cm4gdGhlbWVOYW1lID09PSAnZGVmYXVsdCcgfHwgIU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoZW1lTGF5ZXIpLmxlbmd0aFxuICAgICAgICAgICAgPyB1bmRlZmluZWQgLy8gZGVmYXVsdCB0aGVtZSBvciBubyB0aGVtZVxuICAgICAgICAgICAgOiB0aGVtZU5hbWUgaW4gcmVnaXN0cnlcbiAgICAgICAgICAgICAgICA/IHRoZW1lTmFtZSAvLyByZWdpc3RlcmVkIHRoZW1lIG5hbWVcbiAgICAgICAgICAgICAgICA6IHRoZW1lTGF5ZXI7IC8vIHVucmVnaXN0ZXJlZCB0aGVtZSBvYmplY3RcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1peGluLCAndGhlbWUnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IG1peGluLmFwcGx5VGhlbWUsXG4gICAgZ2V0OiBtaXhpbi5nZXRUaGVtZVxufSk7XG5cblxuLyoqXG4gKiBAc3VtbWFyeSBUaGVtZSByZWdpc3RyYXRpb24gYW5kIGdsb2JhbCB0aGVtZSBzdXBwb3J0LlxuICogQGRlc2MgSHlwZXJncmlkL2luZGV4LmpzIG1peGVzIHRoaXMgbW9kdWxlIGludG8gaXRzIFwic2hhcmVkIG5hbWVzcGFjZVwiIChfaS5lLixfIGFzIHByb3BlcnRpZXMgb2YgdGhlIGNvbnN0cnVjdG9yKS5cbiAqIEBtaXhpblxuICovXG52YXIgc2hhcmVkTWl4aW4gPSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSAtIEEgcmVnaXN0cnkgbmFtZSBmb3IgdGhlIG5ldyB0aGVtZS4gTWF5IGJlIG9taXR0ZWQgaWYgdGhlIHRoZW1lIGhhcyBhbiBlbWJlZGRlZCBuYW1lIChpbiBgdGhlbWUudGhlbWVOYW1lYCkuXG4gICAgICogX0lmIG9taXR0ZWQsIHRoZSAybmQgcGFyYW1ldGVyIChgdGhlbWVgKSBpcyBwcm9tb3RlZCB0byBmaXJzdCBwb3NpdGlvbi5fXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWRUaGVtZU9iamVjdH0gW3RoZW1lXVxuICAgICAqIFRvIGJ1aWxkIGEgSHlwZXJncmlkIHRoZW1lIG9iamVjdCBmcm9tIGEgbG9hZGVkIHtAbGluayBodHRwczovL3BvbHltZXJ0aGVtZXMuY29tIFBvbHltZXIgVGhlbWV9IENTUyBzdHlsZXNoZWV0OlxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiB2YXIgbXlUaGVtZSA9IHJlcXVpcmUoJ2Zpbi1oeXBlcmdyaWQtdGhlbWVzJykuYnVpbGRUaGVtZSgpO1xuICAgICAqIGBgYFxuICAgICAqIElmIG9taXR0ZWQsIHRoZSB0aGVtZSBuYW1lZCBpbiB0aGUgZmlyc3QgcGFyYW1ldGVyIGlzIHVucmVnaXN0ZXJlZC5cbiAgICAgKiBHcmlkIGluc3RhbmNlcyB0aGF0IGhhdmUgcHJldmlvdXNseSBhcHBsaWVkIHRoZSBuYW1lZCB0aGVtZSBhcmUgdW5hZmZlY3RlZCBieSB0aGlzIGFjdGlvbiAod2hldGhlciByZS1yZWdpc3RlcmluZyBvciB1bnJlZ2lzdGVyaW5nKS5cbiAgICAgKiBAdGhpcyB7SHlwZXJncmlkLmNvbnN0cnVjdG9yfVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQuXG4gICAgICovXG4gICAgcmVnaXN0ZXJUaGVtZTogZnVuY3Rpb24obmFtZSwgdGhlbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhlbWUgPSBuYW1lO1xuICAgICAgICAgICAgbmFtZSA9IHRoZW1lLnRoZW1lTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEh5cGVyZ3JpZEVycm9yKCdDYW5ub3QgcmVnaXN0ZXIgYW4gYW5vbnltb3VzIHRoZW1lLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hbWUgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEh5cGVyZ3JpZEVycm9yKCdDYW5ub3QgcmVnaXN0ZXIgb3IgdW5yZWdpc3RlciB0aGUgXCJkZWZhdWx0XCIgdGhlbWUuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhlbWUpIHtcbiAgICAgICAgICAgIHRoZW1lLnRoZW1lTmFtZSA9IG5hbWU7XG4gICAgICAgICAgICByZWdpc3RyeVtuYW1lXSA9IHRoZW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHJlZ2lzdHJ5W25hbWVdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcCBkZXZlbG9wZXJzIGFyZSBmcmVlIHRvIGFkZCBpbiBhZGRpdGlvbmFsIHRoZW1lcywgc3VjaCBhcyB0aG9zZSBpbiB7QGxpbmsgaHR0cHM6Ly9vcGVuZmluLmdpdGh1Yi5jb20vZmluLWh5cGVyZ3JpZC10aGVtZXMvdGhlbWVzfTpcbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogSHlwZXJncmluZC5yZWdpc3RlclRoZW1lcyhyZXF1aXJlKCdmaW4taHlwZXJncmlkLXRoZW1lcycpKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWVDb2xsZWN0aW9uXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5cbiAgICAgKi9cbiAgICByZWdpc3RlclRoZW1lczogZnVuY3Rpb24odGhlbWVDb2xsZWN0aW9uKSB7XG4gICAgICAgIGlmICh0aGVtZUNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIF8odGhlbWVDb2xsZWN0aW9uKS5lYWNoKGZ1bmN0aW9uKHRoZW1lLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlclRoZW1lKG5hbWUsIHRoZW1lKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocmVnaXN0cnkpLmZvckVhY2goZnVuY3Rpb24odGhlbWVOYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlclRoZW1lKHRoZW1lTmFtZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBBcHBseSBnbG9iYWwgdGhlbWUuXG4gICAgICogQGRlc2MgQXBwbHkgcHJvcHMgZnJvbSB0aGUgZ2l2ZW4gdGhlbWUgb2JqZWN0IHRvIHRoZSBnbG9iYWwgdGhlbWUgb2JqZWN0LFxuICAgICAqIHRoZSBgZGVmYXVsdHNgIGxheWVyIGF0IHRoZSBib3R0b20gb2YgdGhlIHByb3BlcnRpZXMgaGllcmFyY2h5LlxuICAgICAqIEB0aGlzIHtIeXBlcmdyaWQuY29uc3RydWN0b3J9XG4gICAgICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSBbdGhlbWU9cmVnaXN0cnkuZGVmYXVsdF0gLSBPbmUgb2Y6XG4gICAgICogKiAqKnN0cmluZzoqKiBBIHJlZ2lzdGVyZWQgdGhlbWUgbmFtZS5cbiAgICAgKiAqICoqb2JqZWN0OioqIEEgdGhlbWUgb2JqZWN0LiBFbXB0eSBvYmplY3QgcmVtb3ZlcyBnbG9iYWwgdGhlbSwgcmVzdG9yaW5nIGRlZmF1bHRzLlxuICAgICAqICogX2ZhbHN5IHZhbHVlOl8gQWxzbyByZXN0b3JlcyBkZWZhdWx0cy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IFt0aGVtZS50aGVtZU5hbWU9dW5kZWZpbmVkXVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQuXG4gICAgICovXG4gICAgYXBwbHlUaGVtZTogYXBwbHlUaGVtZVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaGFyZWRNaXhpbiwgJ3RoZW1lJywgeyAvLyBnbG9iYWwgdGhlbWUgc2V0dGVyL2dldHRlclxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgc2V0OiBhcHBseVRoZW1lLFxuICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBkZWZhdWx0czsgfSAvLyB0aGUgZGVmYXVsdHMgbGF5ZXIgKmlzKiB0aGUgZ2xvYmFsIHRoZW1lIGxheWVyXG59KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtaXhpbjogbWl4aW4sXG4gICAgc2hhcmVkTWl4aW46IHNoYXJlZE1peGluXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdyZWN0YW5ndWxhcicpLlBvaW50O1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4uL0Jhc2UnKTtcbnZhciBDb2x1bW4gPSByZXF1aXJlKCcuL0NvbHVtbicpO1xudmFyIGNlbGxFdmVudEZhY3RvcnkgPSByZXF1aXJlKCcuLi9saWIvY2VsbEV2ZW50RmFjdG9yeScpO1xudmFyIGZlYXR1cmVSZWdpc3RyeSA9IHJlcXVpcmUoJy4uL2ZlYXR1cmVzJyk7XG52YXIgcHJvcENsYXNzRW51bSA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzLmpzJykucHJvcENsYXNzRW51bTtcblxuXG52YXIgbm9FeHBvcnRQcm9wZXJ0aWVzID0gW1xuICAgICdjb2x1bW5IZWFkZXInLFxuICAgICdjb2x1bW5IZWFkZXJDb2x1bW5TZWxlY3Rpb24nLFxuICAgICdmaWx0ZXJQcm9wZXJ0aWVzJyxcbiAgICAncm93SGVhZGVyJyxcbiAgICAncm93SGVhZGVyUm93U2VsZWN0aW9uJyxcbiAgICAncm93TnVtYmVyc1Byb3BlcnRpZXMnLFxuICAgICd0cmVlQ29sdW1uUHJvcGVydGllcycsXG4gICAgJ3RyZWVDb2x1bW5Qcm9wZXJ0aWVzQ29sdW1uU2VsZWN0aW9uJyxcbl07XG5cbkFycmF5LnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24ob2xkSW5kZXgsIGxlbiwgbmV3SW5kZXgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHdoaWxlIChvbGRJbmRleCA8IDApIHtcbiAgICAgICAgb2xkSW5kZXggKz0gdGhpcy5sZW5ndGg7XG4gICAgfVxuICAgIHdoaWxlIChuZXdJbmRleCA8IDApIHtcbiAgICAgICAgbmV3SW5kZXggKz0gdGhpcy5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChuZXdJbmRleCA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICB2YXIgayA9IG5ld0luZGV4IC0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgoay0tKSArIDEpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRJbmRleCA8IG5ld0luZGV4KXtcbiAgICAgICAgbmV3SW5kZXggLT0gbGVuIC0gMTtcbiAgICB9XG4gICAgdGhpcy5zcGxpY2UuYXBwbHkodGhpcywgW25ld0luZGV4LCAwXS5jb25jYXQodGhpcy5zcGxpY2Uob2xkSW5kZXgsIGxlbikpKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQG1peGVzIGNlbGxQcm9wZXJ0aWVzLmJlaGF2aW9yTWl4aW5cbiAqIEBtaXhlcyByb3dQcm9wZXJ0aWVzLm1peGluXG4gKiBAbWl4ZXMgc3ViZ3JpZHMubWl4aW5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGRlc2MgQSBjb250cm9sbGVyIGZvciB0aGUgZGF0YSBtb2RlbC5cbiAqID4gVGhpcyBjb25zdHJ1Y3RvciAoYWN0dWFsbHkgYGluaXRpYWxpemVgKSB3aWxsIGJlIGNhbGxlZCB1cG9uIGluc3RhbnRpYXRpb24gb2YgdGhpcyBjbGFzcyBvciBvZiBhbnkgY2xhc3MgdGhhdCBleHRlbmRzIGZyb20gdGhpcyBjbGFzcy4gU2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vam9uZWl0L2V4dGVuZC1tZXxleHRlbmQtbWV9IGZvciBtb3JlIGluZm8uXG4gKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIF8oUGFzc2VkIHRvIHtAbGluayBCZWhhdmlvciNyZXNldCByZXNldH0pLl9cbiAqIEBwYXJhbSB7ZGF0YU1vZGVsQVBJfSBbb3B0aW9ucy5kYXRhTW9kZWxdIC0gX1BlciB7QGxpbmsgQmVoYXZpb3IjcmVzZXQgcmVzZXR9Ll9cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5tZXRhZGF0YV0gLSBfUGVyIHtAbGluayBCZWhhdmlvciNyZXNldCByZXNldH0uX1xuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuRGF0YU1vZGVsPXJlcXVpcmUoJ2RhdGFzYXVyLWxvY2FsJyldIC0gX1BlciB7QGxpbmsgQmVoYXZpb3IjcmVzZXQgcmVzZXR9Ll9cbiAqIEBwYXJhbSB7ZnVuY3Rpb258b2JqZWN0W119IFtvcHRpb25zLmRhdGFdIC0gX1BlciB7QGxpbmsgQmVoYXZpb3Ijc2V0RGF0YSBzZXREYXRhfS5fXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufG1lbnVJdGVtW119IFtvcHRpb25zLnNjaGVtYV0gLSBfUGVyIHtAbGluayBCZWhhdmlvciNzZXREYXRhIHNldERhdGF9Ll9cbiAqIEBwYXJhbSB7c3ViZ3JpZFNwZWNbXX0gW29wdGlvbnMuc3ViZ3JpZHM9dGhpcy5ncmlkLnByb3BlcnRpZXMuc3ViZ3JpZHNdIC0gX1BlciB7QGxpbmsgQmVoYXZpb3Ijc2V0RGF0YSBzZXREYXRhfS5fXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFwcGx5PXRydWVdIC0gX1BlciB7QGxpbmsgQmVoYXZpb3Ijc2V0RGF0YSBzZXREYXRhfS5fXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIEJlaGF2aW9yID0gQmFzZS5leHRlbmQoJ0JlaGF2aW9yJywge1xuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZ3JpZCwgb3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0h5cGVyZ3JpZH1cbiAgICAgICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncmlkID0gZ3JpZDtcblxuICAgICAgICB0aGlzLmluaXRpYWxpemVGZWF0dXJlQ2hhaW4oKTtcblxuICAgICAgICB0aGlzLmdyaWQuYmVoYXZpb3IgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlc2V0KG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBDcmVhdGUgdGhlIGZlYXR1cmUgY2hhaW4gLSB0aGlzIGlzIHRoZSBbY2hhaW4gb2YgcmVzcG9uc2liaWxpdHldKGh0dHA6Ly9jMi5jb20vY2dpL3dpa2k/Q2hhaW5PZlJlc3BvbnNpYmlsaXR5UGF0dGVybikgcGF0dGVybi5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gW2dyaWRdIFVubmVjZXNhcnkgbGVnYWN5IHBhcmFtZXRlci4gTWF5IGJlIG9taXR0ZWQuXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqL1xuICAgIGluaXRpYWxpemVGZWF0dXJlQ2hhaW46IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdmFyIGNvbnN0cnVjdG9ycztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgQ29udHJvbGxlciBjaGFpbiBvZiBjb21tYW5kLlxuICAgICAgICAgKiBAZGVzYyBFYWNoIGZlYXR1cmUgaXMgbGlua2VkIHRvIHRoZSBuZXh0IGZlYXR1cmUuXG4gICAgICAgICAqIEB0eXBlIHtGZWF0dXJlfVxuICAgICAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbiA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgSGFzaCBvZiBpbnN0YW50aWF0ZWQgZmVhdHVyZXMgYnkgY2xhc3MgbmFtZXMuXG4gICAgICAgICAqIEBkZXNjIEJ1aWx0IGhlcmUgYnV0IG90aGVyd2lzZSBub3QgaW4gdXNlLlxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZlYXR1cmVNYXAgPSB7fTtcblxuICAgICAgICB0aGlzLmZlYXR1cmVSZWdpc3RyeSA9IHRoaXMuZmVhdHVyZVJlZ2lzdHJ5IHx8IGZlYXR1cmVSZWdpc3RyeTtcblxuICAgICAgICBpZiAodGhpcy5ncmlkLnByb3BlcnRpZXMuZmVhdHVyZXMpIHtcbiAgICAgICAgICAgIHZhciBnZXRGZWF0dXJlQ29uc3RydWN0b3IgPSB0aGlzLmZlYXR1cmVSZWdpc3RyeS5nZXQuYmluZCh0aGlzLmZlYXR1cmVSZWdpc3RyeSk7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcnMgPSB0aGlzLmdyaWQucHJvcGVydGllcy5mZWF0dXJlcy5tYXAoZ2V0RmVhdHVyZUNvbnN0cnVjdG9yKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZlYXR1cmVzKSB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcnMgPSB0aGlzLmZlYXR1cmVzO1xuICAgICAgICAgICAgd2FybkJlaGF2aW9yRmVhdHVyZXNEZXByZWNhdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3RydWN0b3JzLmZvckVhY2goZnVuY3Rpb24oRmVhdHVyZUNvbnN0cnVjdG9yLCBpKSB7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZSA9IG5ldyBGZWF0dXJlQ29uc3RydWN0b3I7XG5cbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZU1hcFtmZWF0dXJlLiQkQ0xBU1NfTkFNRV0gPSBmZWF0dXJlO1xuXG4gICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLnNldE5leHQoZmVhdHVyZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluID0gZmVhdHVyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5pbml0aWFsaXplT24odGhpcy5ncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmZWF0dXJlczogW10sIC8vIG92ZXJyaWRlIGluIGltcGxlbWVudGluZyBjbGFzczsgb3IgcHJvdmlkZSBmZWF0dXJlIG5hbWVzIGluIGdyaWQucHJvcGVydGllcy5mZWF0dXJlczsgZWxzZSBubyBmZWF0dXJlc1xuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGJlaGF2aW9yLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBfU2FtZSBhcyBjb25zdHJ1Y3RvcidzIGBvcHRpb25zYC5fPGJyPlxuICAgICAqIF9QYXNzZWQgdG8ge0BsaW5rIEJlaGF2aW9yI3Jlc2V0RGF0YU1vZGVsIHJlc2V0RGF0YU1vZGVsfSBhbmQge0BsaW5rIEJlaGF2aW9yI3NldERhdGEgc2V0RGF0YX0gKGJvdGggb2Ygd2hpY2ggc2VlKS5fXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2NoZW1hT2xkID0gdGhpcy5zY2hlbWE7XG5cbiAgICAgICAgdmFyIGRhdGFNb2RlbENoYW5nZWQgPSB0aGlzLnJlc2V0RGF0YU1vZGVsKG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChkYXRhTW9kZWxDaGFuZ2VkKSB7XG4gICAgICAgICAgICAvLyByZWNyZWF0ZSBgQ2VsbEV2ZW50YCBjbGFzcyBzbyBpdCBjYW4gdXBkYXRlIGl0cyBjYWNoZWQgYGdyaWRgLCBgYmVoYXZpb3JgLCBhbmQgYGRhdGFNb2RlbGAgcHJvcGVydGllc1xuICAgICAgICAgICAgdGhpcy5DZWxsRXZlbnQgPSBjZWxsRXZlbnRGYWN0b3J5KHRoaXMuZ3JpZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uWCA9IHRoaXMuc2Nyb2xsUG9zaXRpb25ZID0gMDtcblxuICAgICAgICB0aGlzLmNyZWF0ZUNvbHVtbnMoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3JkZXJlZCBsaXN0IG9mIHN1YmdyaWRzIHRvIHJlbmRlci5cbiAgICAgICAgICogQHR5cGUge3N1YmdyaWRTcGVjW119XG4gICAgICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN1YmdyaWRzID0gb3B0aW9ucyAmJiBvcHRpb25zLnN1YmdyaWRzIHx8XG4gICAgICAgICAgICAhZGF0YU1vZGVsQ2hhbmdlZCAmJiB0aGlzLnN1YmdyaWRzIHx8XG4gICAgICAgICAgICB0aGlzLmdyaWQucHJvcGVydGllcy5zdWJncmlkcztcblxuICAgICAgICB0aGlzLnNldERhdGEob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBzdW1tYXJ5IFNldCBncmlkIGRhdGEuXG4gICAgICogQGRlc2MgRXhpdHMgd2l0aG91dCBkb2luZyBhbnl0aGluZyBpZiBubyBkYXRhIChgZGF0YVJvd3NgIHVuZGVmaW5lZCBvciBvbWl0dGVkIGFuZCBgb3B0aW9ucy5kYXRhYCB1bmRlZmluZWQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbnxvYmplY3RbXX0gW2RhdGFSb3dzPW9wdGlvbnMuZGF0YV0gLSBBcnJheSBvZiB1bmlmb3JtIGRhdGEgcm93IG9iamVjdHMgb3IgZnVuY3Rpb24gcmV0dXJuaW5nIHNhbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gXyhQcm9tb3RlZCB0byBmaXJzdCBhcmd1bWVudCBwb3NpdGlvbiB3aGVuIGBkYXRhUm93c2Agb21pdHRlZC4pX1xuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbnxvYmplY3RbXX0gW29wdGlvbnMuZGF0YV0gLSBQYXNzZWQgdG8gYmVoYXZpb3IgY29uc3RydWN0b3IuIE1heSBiZTpcbiAgICAgKiAqIEFuIGFycmF5IG9mIGNvbmdydWVudCByYXcgZGF0YSBvYmplY3RzXG4gICAgICogKiBBIGZ1bmN0aW9uIHJldHVybmluZyBzYW1lXG4gICAgICogKiBPbWl0IGZvciBub24tbG9jYWwgZGF0YXNvdXJjZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb258bWVudUl0ZW1bXX0gW29wdGlvbnMuc2NoZW1hXSAtIFBhc3NlZCB0byBiZWhhdmlvciBjb25zdHJ1Y3Rvci4gTWF5IGJlOlxuICAgICAqICogQSBzY2hlbWEgYXJyYXlcbiAgICAgKiAqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHNhbWUuIENhbGxlZCBhdCBmaWx0ZXIgcmVzZXQgdGltZSB3aXRoIGJlaGF2aW9yIGFzIGNvbnRleHQuXG4gICAgICogKiBPbWl0IHRvIGFsbG93IHRoZSBkYXRhIG1vZGVsIHRvIGdlbmVyYXRlIGEgYmFzaWMgc2NoZW1hIGZyb20gaXRzIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFwcGx5PXRydWVdIEFwcGx5IGRhdGEgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSBuZXcgZGF0YS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKi9cbiAgICBzZXREYXRhOiBmdW5jdGlvbihkYXRhUm93cywgb3B0aW9ucykge1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAc3VtbWFyeSBBZGQgZ3JpZCBkYXRhLlxuICAgICAqIEBkZXNjIEV4aXRzIHdpdGhvdXQgZG9pbmcgYW55dGhpbmcgaWYgbm8gZGF0YSAoYGRhdGFSb3dzYCB1bmRlZmluZWQgb3Igb21pdHRlZCBhbmQgYG9wdGlvbnMuZGF0YWAgdW5kZWZpbmVkKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb258b2JqZWN0W119IFtkYXRhUm93cz1vcHRpb25zLmRhdGFdIC0gQXJyYXkgb2YgdW5pZm9ybSBkYXRhIHJvdyBvYmplY3RzIG9yIGZ1bmN0aW9uIHJldHVybmluZyBzYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIF8oUHJvbW90ZWQgdG8gZmlyc3QgYXJndW1lbnQgcG9zaXRpb24gd2hlbiBgZGF0YVJvd3NgIG9taXR0ZWQuKV9cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb258b2JqZWN0W119IFtvcHRpb25zLmRhdGFdIC0gUGFzc2VkIHRvIGJlaGF2aW9yIGNvbnN0cnVjdG9yLiBNYXkgYmU6XG4gICAgICogKiBBbiBhcnJheSBvZiBjb25ncnVlbnQgcmF3IGRhdGEgb2JqZWN0c1xuICAgICAqICogQSBmdW5jdGlvbiByZXR1cm5pbmcgc2FtZVxuICAgICAqICogT21pdCBmb3Igbm9uLWxvY2FsIGRhdGFzb3VyY2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufG1lbnVJdGVtW119IFtvcHRpb25zLnNjaGVtYV0gLSBQYXNzZWQgdG8gYmVoYXZpb3IgY29uc3RydWN0b3IuIE1heSBiZTpcbiAgICAgKiAqIEEgc2NoZW1hIGFycmF5XG4gICAgICogKiBBIGZ1bmN0aW9uIHJldHVybmluZyBzYW1lLiBDYWxsZWQgYXQgZmlsdGVyIHJlc2V0IHRpbWUgd2l0aCBiZWhhdmlvciBhcyBjb250ZXh0LlxuICAgICAqICogT21pdCB0byBhbGxvdyB0aGUgZGF0YSBtb2RlbCB0byBnZW5lcmF0ZSBhIGJhc2ljIHNjaGVtYSBmcm9tIGl0cyBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hcHBseT10cnVlXSBBcHBseSBkYXRhIHRyYW5zZm9ybWF0aW9ucyB0byB0aGUgbmV3IGRhdGEuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICovXG4gICAgYWRkRGF0YTogZnVuY3Rpb24oZGF0YVJvd3MsIG9wdGlvbnMpIHtcbiAgICB9LFxuXG4gICAgZ2V0IHJlbmRlcmVkQ29sdW1uQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQucmVuZGVyZXIudmlzaWJsZUNvbHVtbnMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBnZXQgcmVuZGVyZWRSb3dDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5yZW5kZXJlci52aXNpYmxlUm93cy5sZW5ndGg7XG4gICAgfSxcblxuICAgIGdldCBsZWZ0TW9zdENvbEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnByb3BlcnRpZXMuc2hvd1Jvd051bWJlcnMgPyB0aGlzLnJvd0NvbHVtbkluZGV4IDogKHRoaXMuaGFzVHJlZUNvbHVtbigpID8gdGhpcy50cmVlQ29sdW1uSW5kZXggOiAwKTtcbiAgICB9LFxuXG4gICAgY2xlYXJDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNjaGVtYSA9IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgdHJlZUNvbHVtbkluZGV4ID0gdGhpcy50cmVlQ29sdW1uSW5kZXgsXG4gICAgICAgICAgICByb3dDb2x1bW5JbmRleCA9IHRoaXMucm93Q29sdW1uSW5kZXg7XG5cbiAgICAgICAgc2NoZW1hW3RyZWVDb2x1bW5JbmRleF0gPSBzY2hlbWFbdHJlZUNvbHVtbkluZGV4XSB8fCB7XG4gICAgICAgICAgICBpbmRleDogdHJlZUNvbHVtbkluZGV4LFxuICAgICAgICAgICAgbmFtZTogJ1RyZWUnLFxuICAgICAgICAgICAgaGVhZGVyOiAnVHJlZSdcbiAgICAgICAgfTtcblxuICAgICAgICBzY2hlbWFbcm93Q29sdW1uSW5kZXhdID0gc2NoZW1hW3Jvd0NvbHVtbkluZGV4XSB8fCB7XG4gICAgICAgICAgICBpbmRleDogcm93Q29sdW1uSW5kZXgsXG4gICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgIGhlYWRlcjogJydcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdHJlZUNvbHVtbk9sZCA9ICh0aGlzLmFsbENvbHVtbnMgJiYgdGhpcy5hbGxDb2x1bW5zW3RyZWVDb2x1bW5JbmRleF0pIHx8ICh0aGlzLmNvbHVtbnMgJiYgdGhpcy5jb2x1bW5zW3RyZWVDb2x1bW5JbmRleF0pO1xuICAgICAgICB2YXIgcm93Q29sdW1uT2xkID0gKHRoaXMuYWxsQ29sdW1ucyAmJiB0aGlzLmFsbENvbHVtbnNbcm93Q29sdW1uSW5kZXhdKSB8fCAodGhpcy5jb2x1bW5zICYmIHRoaXMuY29sdW1uc1tyb3dDb2x1bW5JbmRleF0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7Q29sdW1uW119XG4gICAgICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sdW1ucyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7Q29sdW1uW119XG4gICAgICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWxsQ29sdW1ucyA9IFtdO1xuXG4gICAgICAgIHRoaXMuYWxsQ29sdW1uc1t0cmVlQ29sdW1uSW5kZXhdID0gdGhpcy5jb2x1bW5zW3RyZWVDb2x1bW5JbmRleF0gPSB0aGlzLm5ld0NvbHVtbih0cmVlQ29sdW1uT2xkICYmIHRyZWVDb2x1bW5PbGQucHJvcGVydGllcyA/IHRyZWVDb2x1bW5PbGQucHJvcGVydGllcyA6IHtcbiAgICAgICAgICAgIGluZGV4OiB0cmVlQ29sdW1uSW5kZXgsXG4gICAgICAgICAgICBoZWFkZXI6IHNjaGVtYVt0cmVlQ29sdW1uSW5kZXhdLmhlYWRlcixcbiAgICAgICAgICAgIG5hbWU6IHNjaGVtYVt0cmVlQ29sdW1uSW5kZXhdLm5hbWUsXG4gICAgICAgICAgICBmaXhlZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hbGxDb2x1bW5zW3Jvd0NvbHVtbkluZGV4XSA9IHRoaXMuY29sdW1uc1tyb3dDb2x1bW5JbmRleF0gPSB0aGlzLm5ld0NvbHVtbihyb3dDb2x1bW5PbGQgJiYgcm93Q29sdW1uT2xkLnByb3BlcnRpZXMgPyByb3dDb2x1bW5PbGQucHJvcGVydGllcyA6IHtcbiAgICAgICAgICAgIGluZGV4OiByb3dDb2x1bW5JbmRleCxcbiAgICAgICAgICAgIGhlYWRlcjogc2NoZW1hW3Jvd0NvbHVtbkluZGV4XS5oZWFkZXIsXG4gICAgICAgICAgICBuYW1lOiBzY2hlbWFbcm93Q29sdW1uSW5kZXhdLm5hbWUsXG4gICAgICAgICAgICBjb2x1bW5BdXRvc2l6aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIG1pbldpZHRoOiB0aGlzLmdyaWQucHJvcGVydGllcy5jb2x1bW5IZWFkZXJJbml0V2lkdGgsXG4gICAgICAgICAgICBmaXhlZDogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmNvbHVtbnNbdHJlZUNvbHVtbkluZGV4XS5wcm9wZXJ0aWVzLnByb3BDbGFzc0xheWVycyA9IHRoaXMuY29sdW1uc1tyb3dDb2x1bW5JbmRleF0ucHJvcGVydGllcy5wcm9wQ2xhc3NMYXllcnMgPSBbcHJvcENsYXNzRW51bS5DT0xVTU5TXTtcblxuICAgICAgICAvLyBTaWduYWwgdGhlIHJlbmRlcmVyIHRvIHNpemUgdGhlIG5vdy1yZXNldCBoYW5kbGUgY29sdW1uIGJlZm9yZSBuZXh0IHJlbmRlclxuICAgICAgICB0aGlzLmdyaWQucmVuZGVyZXIucmVzZXRSb3dIZWFkZXJDb2x1bW5XaWR0aCgpO1xuICAgIH0sXG5cbiAgICBnZXRBY3RpdmVDb2x1bW46IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uc1t4XSB8fCB0aGlzLmNvbHVtbnNbcGFyc2VJbnQoeCwgMTApXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIFwiZ3JpZCBpbmRleFwiIGdpdmVuIGEgXCJkYXRhIGluZGV4XCIgKG9yIGNvbHVtbiBvYmplY3QpXG4gICAgICogQHBhcmFtIHtDb2x1bW58bnVtYmVyfSBjb2x1bW5PckluZGV4XG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZHxudW1iZXJ9IFRoZSBncmlkIGluZGV4IG9mIHRoZSBjb2x1bW4gb3IgdW5kZWZpbmVkIGlmIGNvbHVtbiBub3QgaW4gZ3JpZC5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIGdldEFjdGl2ZUNvbHVtbkluZGV4OiBmdW5jdGlvbihjb2x1bW5PckluZGV4KSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNvbHVtbk9ySW5kZXggaW5zdGFuY2VvZiBDb2x1bW4gPyBjb2x1bW5PckluZGV4LmluZGV4IDogY29sdW1uT3JJbmRleDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbHVtbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbHVtbnNbaV0uaW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFsbENvbHVtbnNbeF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0IGdldCBuZWFyZXN0IGNvbHVtbiB0byBYXG4gICAgICogQHBhcmFtIHggLSBpbmRleCBvZiBiYXNlIGNvbHVtblxuICAgICAqIEBwYXJhbSByaWdodFNoaWZ0IC0gYm9vbGVhbiBkaXJlY3Rpb24gZm9yIG5lYXIgY29sdW1uIGdldHRpbmcuIGB0cnVlYCAtIGlzIGRpcmVjdGlvbiB0byB0aGUgcmlnaHRcbiAgICAgKiBAcmV0dXJucyB7Q29sdW1ufHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5TaGlmdGVkOiBmdW5jdGlvbih4LCByaWdodFNoaWZ0KSB7XG4gICAgICAgIGlmIChyaWdodFNoaWZ0KSB7XG4gICAgICAgICAgICArK3g7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAtLXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeCA9PT0gdGhpcy50cmVlQ29sdW1uSW5kZXggJiYgIXRoaXMuZ3JpZC5wcm9wZXJ0aWVzLnNob3dUcmVlQ29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2x1bW5TaGlmdGVkKHgsIHJpZ2h0U2hpZnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHggPT09IHRoaXMucm93Q29sdW1uSW5kZXggJiYgIXRoaXMuZ3JpZC5wcm9wZXJ0aWVzLnJvd0hlYWRlck51bWJlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbHVtblNoaWZ0ZWQoeCwgcmlnaHRTaGlmdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2x1bW4oeCk7XG4gICAgfSxcblxuICAgIG5ld0NvbHVtbjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IENvbHVtbih0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgYWRkQ29sdW1uOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLm5ld0NvbHVtbihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5jb2x1bW5zLnB1c2goY29sdW1uKTtcbiAgICAgICAgdGhpcy5hbGxDb2x1bW5zLnB1c2goY29sdW1uKTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbjtcbiAgICB9LFxuXG4gICAgY3JlYXRlQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2xlYXJDb2x1bW5zKCk7XG4gICAgICAgIC8vY29uY3JldGUgaW1wbGVtZW50YXRpb24gaGVyZVxuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5XaWR0aDogZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5nZXRBY3RpdmVDb2x1bW4oeCk7XG4gICAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnByb3BlcnRpZXMuZGVmYXVsdENvbHVtbldpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2x1bW4uZ2V0V2lkdGgoKSArICh0aGlzLmdyaWQucHJvcGVydGllcy5ncmlkTGluZXNWID8gdGhpcy5ncmlkLnByb3BlcnRpZXMuZ3JpZExpbmVzV2lkdGggOiAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDb2x1bW58bnVtYmVyfSBjb2x1bW5PckluZGV4IC0gVGhlIGNvbHVtbiBvciBhY3RpdmUgY29sdW1uIGluZGV4LlxuICAgICAqIEBwYXJhbSB3aWR0aFxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgc2V0Q29sdW1uV2lkdGg6IGZ1bmN0aW9uKGNvbHVtbk9ySW5kZXgsIHdpZHRoKSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSBjb2x1bW5PckluZGV4ID49IC0yID8gdGhpcy5nZXRBY3RpdmVDb2x1bW4oY29sdW1uT3JJbmRleCkgOiBjb2x1bW5PckluZGV4O1xuICAgICAgICBjb2x1bW4uc2V0V2lkdGgod2lkdGgpO1xuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlZCgpO1xuICAgICAgICB0aGlzLmdyaWQuZmlyZVN5bnRoZXRpY09uQ29sdW1uUmVzaXplZEV2ZW50KGNvbHVtbk9ySW5kZXgsIHdpZHRoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIHV0aWxpdHkgZnVuY3Rpb24gdG8gZW1wdHkgYW4gb2JqZWN0IG9mIGl0cyBtZW1iZXJzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgdG8gZW1wdHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtleHBvcnRQcm9wc11cbiAgICAgKiAqIGB1bmRlZmluZWRgIChvbWl0dGVkKSAtIGRlbGV0ZSAqYWxsKiBwcm9wZXJ0aWVzXG4gICAgICogKiAqKmZhbHN5KiogLSBkZWxldGUgKm9ubHkqIHRoZSBleHBvcnQgcHJvcGVydGllc1xuICAgICAqICogKip0cnV0aHkqKiAtIGRlbGV0ZSBhbGwgcHJvcGVydGllcyAqZXhjZXB0KiB0aGUgZXhwb3J0IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBjbGVhck9iamVjdFByb3BlcnRpZXM6IGZ1bmN0aW9uKG9iaiwgZXhwb3J0UHJvcHMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0UHJvcHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAhZXhwb3J0UHJvcHMgJiYgbm9FeHBvcnRQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSA+PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydFByb3BzICYmIG5vRXhwb3J0UHJvcGVydGllcy5pbmRleE9mKGtleSkgPCAwXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vdGhpcyBpcyBlZmZlY3RpdmVseSBhIGNsb25lLCB3aXRoIGNlcnRhaW4gdGhpbmdzIHJlbW92ZWQuLi4uXG4gICAgZ2V0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29weSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5ncmlkLnByb3BlcnRpZXMpKTtcbiAgICAgICAgdGhpcy5jbGVhck9iamVjdFByb3BlcnRpZXMoY29weS5jb2x1bW5Qcm9wZXJ0aWVzLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIGNsZWFyIGFsbCB0YWJsZSBzdGF0ZVxuICAgICAqL1xuICAgIGNsZWFyU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdyaWQuY2xlYXJTdGF0ZSgpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbHVtbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIFJlc3RvcmUgdGhpcyB0YWJsZSB0byBhIHByZXZpb3VzIHN0YXRlLlxuICAgICAqIFNlZSB0aGUgW21lbWVudG8gcGF0dGVybl0oaHR0cDovL2MyLmNvbS9jZ2kvd2lraT9NZW1lbnRvUGF0dGVybikuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1lbWVudG8gLSBhc3NpZ25hYmxlIGdyaWQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIHNldFN0YXRlOiBmdW5jdGlvbihtZW1lbnRvKSB7XG4gICAgICAgIHRoaXMuY2xlYXJTdGF0ZSgpO1xuICAgICAgICB0aGlzLmFkZFN0YXRlKG1lbWVudG8pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2MgQWRkIG5ldyBzdGF0ZSB0byBwYXJhbXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gYXNzaWduYWJsZSBncmlkIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBhZGRTdGF0ZTogZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgdGhpcy5zZXRBbGxDb2x1bW5Qcm9wZXJ0aWVzKHByb3BlcnRpZXMuY29sdW1uUHJvcGVydGllcyk7XG4gICAgICAgIHRoaXMucmVpbmRleCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTZXRzIHByb3BlcnRpZXMgb2YgbXVsdGlwbGUgY29sdW1ucy5cbiAgICAgKiBAZGVzYyBTZXRzIGNvbHVtbiBwcm9wZXJ0aWVzIHRvIGVsZW1lbnRzIG9mIGdpdmVuIGFycmF5LlxuICAgICAqIFRoZSBhcnJheSBtYXkgYmUgc3BhcnNlOyBuZXZlciBkZWZpbmVkIG9yIGRlbGV0ZWQgZWxlbWVudHMgYXJlIGlnbm9yZWQuXG4gICAgICogSW4gYWRkaXRpb24sIGZhbHN5IGVsZW1lbnRzIGFyZSBpZ25vcmVkLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0W119IGNvbHVtblByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBzZXRBbGxDb2x1bW5Qcm9wZXJ0aWVzOiBmdW5jdGlvbihjb2x1bW5Qcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChjb2x1bW5Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBjb2x1bW5Qcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24ocHJvcGVydGllcywgaSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29sdW1uKGkpLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldENvbHVtbk9yZGVyOiBmdW5jdGlvbihjb2x1bW5JbmRleGVzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbHVtbkluZGV4ZXMpKXtcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucy5sZW5ndGggPSBjb2x1bW5JbmRleGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbHVtbkluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbihpbmRleCwgaSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uc1tpXSA9IHRoaXMuYWxsQ29sdW1uc1tpbmRleF07XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRDb2x1bW5PcmRlckJ5TmFtZTogZnVuY3Rpb24oY29sdW1uTmFtZXMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29sdW1uTmFtZXMpKXtcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucy5sZW5ndGggPSBjb2x1bW5OYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICBjb2x1bW5OYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGNvbHVtbk5hbWUsIGkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbnNbaV0gPSB0aGlzLmFsbENvbHVtbnMuZmluZChmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbi5uYW1lID09PSBjb2x1bW5OYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIFJlYnVpbGQgdGhlIGNvbHVtbiBvcmRlciBpbmRleGVzXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29sdW1uSW5kZXhlcyAtIGxpc3Qgb2YgY29sdW1uIGluZGV4ZXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdIC0gd2hldGhlciB0byB0cmlnZ2VyIGNvbHVtbiBjaGFuZ2VkIGV2ZW50XG4gICAgICovXG4gICAgc2V0Q29sdW1uSW5kZXhlczogZnVuY3Rpb24oY29sdW1uSW5kZXhlcywgc2lsZW50KSB7XG4gICAgICAgIHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLmNvbHVtbkluZGV4ZXMgPSBjb2x1bW5JbmRleGVzO1xuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmZpcmVTeW50aGV0aWNPbkNvbHVtbnNDaGFuZ2VkRXZlbnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTaG93IGluYWN0aXZlIGNvbHVtbihzKSBvciBtb3ZlIGFjdGl2ZSBjb2x1bW4ocykuXG4gICAgICpcbiAgICAgKiBAZGVzYyBBZGRzIG9uZSBvciBzZXZlcmFsIGNvbHVtbnMgdG8gdGhlIFwiYWN0aXZlXCIgY29sdW1uIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0FjdGl2ZUNvbHVtbkluZGV4ZXM9ZmFsc2VdIC0gV2hpY2ggbGlzdCBgY29sdW1uSW5kZXhlc2AgcmVmZXJzIHRvOlxuICAgICAqICogYHRydWVgIC0gVGhlIGFjdGl2ZSBjb2x1bW4gbGlzdC4gVGhpcyBjYW4gb25seSBtb3ZlIGNvbHVtbnMgYXJvdW5kIHdpdGhpbiB0aGUgYWN0aXZlIGNvbHVtbiBsaXN0OyBpdCBjYW5ub3QgYWRkIGluYWN0aXZlIGNvbHVtbnMgKGJlY2F1c2UgaXQgY2FuIG9ubHkgcmVmZXIgdG8gY29sdW1ucyBpbiB0aGUgYWN0aXZlIGNvbHVtbiBsaXN0KS5cbiAgICAgKiAqIGBmYWxzZWAgLSBUaGUgZnVsbCBjb2x1bW4gbGlzdCAoYXMgcGVyIGNvbHVtbiBzY2hlbWEgYXJyYXkpLiBUaGlzIGluc2VydHMgY29sdW1ucyBmcm9tIHRoZSBcImluYWN0aXZlXCIgY29sdW1uIGxpc3QsIG1vdmluZyBjb2x1bW5zIHRoYXQgYXJlIGFscmVhZHkgYWN0aXZlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8bnVtYmVyW119IGNvbHVtbkluZGV4ZXMgLSBDb2x1bW4gaW5kZXgoZXMpIGludG8gbGlzdCBhcyBkZXRlcm1pbmVkIGJ5IGBpc0FjdGl2ZUNvbHVtbkluZGV4ZXNgLiBPbmUgb2Y6XG4gICAgICogKiAqKlNjYWxhciBjb2x1bW4gaW5kZXgqKiAtIEFkZHMgc2luZ2xlIGNvbHVtbiBhdCBpbnNlcnRpb24gcG9pbnQuXG4gICAgICogKiAqKkFycmF5IG9mIGNvbHVtbiBpbmRleGVzKiogLSBBZGRzIG11bHRpcGxlIGNvbnNlY3V0aXZlIGNvbHVtbnMgYXQgaW5zZXJ0aW9uIHBvaW50LlxuICAgICAqXG4gICAgICogX1RoaXMgcmVxdWlyZWQgcGFyYW1ldGVyIGlzIHByb21vdGVkIGxlZnQgb25lIGFyZyBwb3NpdGlvbiB3aGVuIGBpc0FjdGl2ZUNvbHVtbkluZGV4ZXNgIG9taXR0ZWQuX1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyZWZlcmVuY2VJbmRleD10aGlzLmNvbHVtbnMubGVuZ3RoXSAtIEluc2VydGlvbiBwb2ludCwgX2kuZS4sXyB0aGUgZWxlbWVudCB0byBpbnNlcnQgYmVmb3JlLiBBIG5lZ2F0aXZlIHZhbHVlcyBza2lwcyB0aGUgcmVpbnNlcnQuIERlZmF1bHQgaXMgdG8gaW5zZXJ0IG5ldyBjb2x1bW5zIGF0IGVuZCBvZiBhY3RpdmUgY29sdW1uIGxpc3QuXG4gICAgICpcbiAgICAgKiBfUHJvbW90ZWQgbGVmdCBvbmUgYXJnIHBvc2l0aW9uIHdoZW4gYGlzQWN0aXZlQ29sdW1uSW5kZXhlc2Agb21pdHRlZC5fXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthbGxvd0R1cGxpY2F0ZUNvbHVtbnM9ZmFsc2VdIC0gVW5sZXNzIHRydWUsIGFscmVhZHkgdmlzaWJsZSBjb2x1bW5zIGFyZSByZW1vdmVkIGZpcnN0LlxuICAgICAqXG4gICAgICogX1Byb21vdGVkIGxlZnQgb25lIGFyZyBwb3NpdGlvbiB3aGVuIGBpc0FjdGl2ZUNvbHVtbkluZGV4ZXNgIG9taXR0ZWQgKyBvbmUgcG9zaXRpb24gd2hlbiBgcmVmZXJlbmNlSW5kZXhgIG9taXR0ZWQuX1xuICAgICAqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqL1xuICAgIHNob3dDb2x1bW5zOiBmdW5jdGlvbihpc0FjdGl2ZUNvbHVtbkluZGV4ZXMsIGNvbHVtbkluZGV4ZXMsIHJlZmVyZW5jZUluZGV4LCBhbGxvd0R1cGxpY2F0ZUNvbHVtbnMpIHtcbiAgICAgICAgLy8gUHJvbW90ZSBhcmdzIHdoZW4gaXNBY3RpdmVDb2x1bW5JbmRleGVzIG9taXR0ZWRcbiAgICAgICAgaWYgKHR5cGVvZiBpc0FjdGl2ZUNvbHVtbkluZGV4ZXMgPT09ICdudW1iZXInIHx8IEFycmF5LmlzQXJyYXkoaXNBY3RpdmVDb2x1bW5JbmRleGVzKSkge1xuICAgICAgICAgICAgYWxsb3dEdXBsaWNhdGVDb2x1bW5zID0gcmVmZXJlbmNlSW5kZXg7XG4gICAgICAgICAgICByZWZlcmVuY2VJbmRleCA9IGNvbHVtbkluZGV4ZXM7XG4gICAgICAgICAgICBjb2x1bW5JbmRleGVzID0gaXNBY3RpdmVDb2x1bW5JbmRleGVzO1xuICAgICAgICAgICAgaXNBY3RpdmVDb2x1bW5JbmRleGVzID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWN0aXZlQ29sdW1ucyA9IHRoaXMuY29sdW1ucyxcbiAgICAgICAgICAgIHNvdXJjZUNvbHVtbkxpc3QgPSBpc0FjdGl2ZUNvbHVtbkluZGV4ZXMgPyBhY3RpdmVDb2x1bW5zIDogdGhpcy5hbGxDb2x1bW5zO1xuXG4gICAgICAgIC8vIE5lc3Qgc2NhbGFyIGluZGV4XG4gICAgICAgIGlmICh0eXBlb2YgY29sdW1uSW5kZXhlcyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbHVtbkluZGV4ZXMgPSBbY29sdW1uSW5kZXhlc107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3Q29sdW1ucyA9IGNvbHVtbkluZGV4ZXNcbiAgICAgICAgICAgIC8vIExvb2sgdXAgY29sdW1ucyB1c2luZyBwcm92aWRlZCBpbmRleGVzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGluZGV4KSB7IHJldHVybiBzb3VyY2VDb2x1bW5MaXN0W2luZGV4XTsgfSlcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgdW5kZWZpbmVkIGNvbHVtbnNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oY29sdW1uKSB7IHJldHVybiBjb2x1bW47IH0pO1xuXG4gICAgICAgIC8vIERlZmF1bHQgaW5zZXJ0aW9uIHBvaW50IGlzIGVuZCAoaS5lLiwgYmVmb3JlIChsYXN0KzEpdGggZWxlbWVudClcbiAgICAgICAgaWYgKHR5cGVvZiByZWZlcmVuY2VJbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGFsbG93RHVwbGljYXRlQ29sdW1ucyA9IHJlZmVyZW5jZUluZGV4OyAvLyBhc3N1bWUgcmVmZXJlbmNlIGluZGV4IHdhcyBvbWl0dGVkIHdoZW4gbm90IGEgbnVtYmVyXG4gICAgICAgICAgICByZWZlcmVuY2VJbmRleCA9IGFjdGl2ZUNvbHVtbnMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIGFscmVhZHkgdmlzaWJsZSBjb2x1bW5zIGFuZCBhZGp1c3QgaW5zZXJ0aW9uIHBvaW50XG4gICAgICAgIGlmICghYWxsb3dEdXBsaWNhdGVDb2x1bW5zKSB7XG4gICAgICAgICAgICBuZXdDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBhY3RpdmVDb2x1bW5zLmluZGV4T2YoY29sdW1uKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUNvbHVtbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmZXJlbmNlSW5kZXggPiBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAtLXJlZmVyZW5jZUluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnNlcnQgdGhlIG5ldyBjb2x1bW5zIGF0IHRoZSBpbnNlcnRpb24gcG9pbnRcbiAgICAgICAgaWYgKHJlZmVyZW5jZUluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGFjdGl2ZUNvbHVtbnMuc3BsaWNlLmFwcGx5KGFjdGl2ZUNvbHVtbnMsIFtyZWZlcmVuY2VJbmRleCwgMF0uY29uY2F0KG5ld0NvbHVtbnMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLmNvbHVtbkluZGV4ZXMgPSBhY3RpdmVDb2x1bW5zLm1hcChmdW5jdGlvbihjb2x1bW4pIHsgcmV0dXJuIGNvbHVtbi5pbmRleDsgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEhpZGUgYWN0aXZlIGNvbHVtbihzKS5cbiAgICAgKiBAZGVzYyBSZW1vdmVzIG9uZSBvciBzZXZlcmFsIGNvbHVtbnMgZnJvbSB0aGUgXCJhY3RpdmVcIiBjb2x1bW4gbGlzdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0FjdGl2ZUNvbHVtbkluZGV4ZXM9ZmFsc2VdIC0gV2hpY2ggbGlzdCBgY29sdW1uSW5kZXhlc2AgcmVmZXJzIHRvOlxuICAgICAqICogYHRydWVgIC0gVGhlIGFjdGl2ZSBjb2x1bW4gbGlzdC5cbiAgICAgKiAqIGBmYWxzZWAgLSBUaGUgZnVsbCBjb2x1bW4gbGlzdCAoYXMgcGVyIGNvbHVtbiBzY2hlbWEgYXJyYXkpLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBjb2x1bW5JbmRleGVzIC0gQ29sdW1uIGluZGV4KGVzKSBpbnRvIGxpc3QgYXMgZGV0ZXJtaW5lZCBieSBgaXNBY3RpdmVDb2x1bW5JbmRleGVzYC4gT25lIG9mOlxuICAgICAqICogKipTY2FsYXIgY29sdW1uIGluZGV4KiogLSBBZGRzIHNpbmdsZSBjb2x1bW4gYXQgaW5zZXJ0aW9uIHBvaW50LlxuICAgICAqICogKipBcnJheSBvZiBjb2x1bW4gaW5kZXhlcyoqIC0gQWRkcyBtdWx0aXBsZSBjb25zZWN1dGl2ZSBjb2x1bW5zIGF0IGluc2VydGlvbiBwb2ludC5cbiAgICAgKlxuICAgICAqIF9UaGlzIHJlcXVpcmVkIHBhcmFtZXRlciBpcyBwcm9tb3RlZCBsZWZ0IG9uZSBhcmcgcG9zaXRpb24gd2hlbiBgaXNBY3RpdmVDb2x1bW5JbmRleGVzYCBvbWl0dGVkLl9cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICovXG4gICAgaGlkZUNvbHVtbnM6IGZ1bmN0aW9uKGlzQWN0aXZlQ29sdW1uSW5kZXhlcywgY29sdW1uSW5kZXhlcykge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7IC8vIENvbnZlcnQgdG8gYXJyYXkgc28gd2UgY2FuIGFkZCBhbiBhcmd1bWVudCAoZWxlbWVudClcbiAgICAgICAgYXJncy5wdXNoKC0xKTsgLy8gUmVtb3ZlIG9ubHk7IGRvIG5vdCByZWluc2VydC5cbiAgICAgICAgdGhpcy5zaG93Q29sdW1ucy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIGZldGNoIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBrZXlcbiAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gYSBwcm9wZXJ0eSBuYW1lXG4gICAgICovXG4gICAgcmVzb2x2ZVByb3BlcnR5OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgLy8gdG9kbzogcmVtb3ZlIHdoZW4gd2UgcmVtb3ZlIHRoZSBkZXByZWNhdGVkIGdyaWQucmVzb2x2ZVByb3BlcnR5XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQucmVzb2x2ZVByb3BlcnR5KGtleSk7XG4gICAgfSxcblxuICAgIGxvb2t1cEZlYXR1cmU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlTWFwW2tleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fG51bWJlcn0geE9yQ2VsbEV2ZW50IC0gR3JpZCBjb2x1bW4gY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ldIC0gR3JpZCByb3cgY29vcmRpbmF0ZS4gT21pdCBpZiBgeE9yQ2VsbEV2ZW50YCBpcyBhIENlbGxFdmVudC5cbiAgICAgKiBAcGFyYW0ge2RhdGFNb2RlbEFQSX0gW2RhdGFNb2RlbF0gLSBGb3IgdXNlIG9ubHkgd2hlbiBgeE9yQ2VsbEV2ZW50YCBpcyBfbm90XyBhIGBDZWxsRXZlbnRgOiBQcm92aWRlIGEgc3ViZ3JpZC4gSWYgZ2l2ZW4sIHggYW5kIHkgYXJlIGludGVycHJldGVkIGFzIGRhdGEgY2VsbCBjb29yZGluYXRlcyAodW5hZGp1c3RlZCBmb3Igc2Nyb2xsaW5nKS4gRG9lcyBub3QgZGVmYXVsdCB0byB0aGUgZGF0YSBzdWJncmlkLCBhbHRob3VnaCB5b3UgY2FuIHByb3ZpZGUgaXQgZXhwbGljaXRseSAoYHRoaXMuc3ViZ3JpZHMubG9va3VwLmRhdGFgKS5cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHhPckNlbGxFdmVudCwgeSwgZGF0YU1vZGVsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgeE9yQ2VsbEV2ZW50ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFyIHggPSB4T3JDZWxsRXZlbnQ7XG4gICAgICAgICAgICB4T3JDZWxsRXZlbnQgPSBuZXcgdGhpcy5DZWxsRXZlbnQ7XG4gICAgICAgICAgICBpZiAoZGF0YU1vZGVsKSB7XG4gICAgICAgICAgICAgICAgeE9yQ2VsbEV2ZW50LnJlc2V0RGF0YVhZKHgsIHksIGRhdGFNb2RlbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHhPckNlbGxFdmVudC5yZXNldEdyaWRDWSh4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geE9yQ2VsbEV2ZW50LnZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2MgdXBkYXRlIHRoZSBkYXRhIGF0IHBvaW50IHgsIHkgd2l0aCB2YWx1ZVxuICAgICAqIEByZXR1cm4gVGhlIGRhdGEuXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR8bnVtYmVyfSB4T3JDZWxsRXZlbnQgLSBHcmlkIGNvbHVtbiBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gLSBHcmlkIHJvdyBjb29yZGluYXRlLiBPbWl0IGlmIGB4T3JDZWxsRXZlbnRgIGlzIGEgQ2VsbEV2ZW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB1c2UuIF9XaGVuIGB5YCBvbWl0dGVkLCBwcm9tb3RlZCB0byAybmQgYXJnLl9cbiAgICAgKiBAcGFyYW0ge2RhdGFNb2RlbEFQSX0gW2RhdGFNb2RlbF0gLSBGb3IgdXNlIG9ubHkgd2hlbiBgeE9yQ2VsbEV2ZW50YCBpcyBfbm90XyBhIGBDZWxsRXZlbnRgOiBQcm92aWRlIGEgc3ViZ3JpZC4gSWYgZ2l2ZW4sIHggYW5kIHkgYXJlIGludGVycHJldGVkIGFzIGRhdGEgY2VsbCBjb29yZGluYXRlcyAodW5hZGp1c3RlZCBmb3Igc2Nyb2xsaW5nKS4gRG9lcyBub3QgZGVmYXVsdCB0byB0aGUgZGF0YSBzdWJncmlkLCBhbHRob3VnaCB5b3UgY2FuIHByb3ZpZGUgaXQgZXhwbGljaXRseSAoYHRoaXMuc3ViZ3JpZHMubG9va3VwLmRhdGFgKS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBDb25zdW1lZC5cbiAgICAgKi9cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeE9yQ2VsbEV2ZW50LCB5LCB2YWx1ZSwgZGF0YU1vZGVsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgeE9yQ2VsbEV2ZW50ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFsdWUgPSB5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHggPSB4T3JDZWxsRXZlbnQ7XG4gICAgICAgICAgICB4T3JDZWxsRXZlbnQgPSBuZXcgdGhpcy5DZWxsRXZlbnQ7XG4gICAgICAgICAgICBpZiAoZGF0YU1vZGVsKSB7XG4gICAgICAgICAgICAgICAgeE9yQ2VsbEV2ZW50LnJlc2V0RGF0YVhZKHgsIHksIGRhdGFNb2RlbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHhPckNlbGxFdmVudC5yZXNldEdyaWRDWSh4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB4T3JDZWxsRXZlbnQudmFsdWUgPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSBmaXhlZCBjb2x1bW4gYXJlYSBpbiB0aGUgaHlwZXJncmlkLlxuICAgICAqL1xuICAgIGdldEZpeGVkQ29sdW1uc1dpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5nZXRGaXhlZENvbHVtbkNvdW50KCksXG4gICAgICAgICAgICB0b3RhbCA9IDAsXG4gICAgICAgICAgICBpID0gdGhpcy5sZWZ0TW9zdENvbEluZGV4O1xuXG4gICAgICAgIGZvciAoOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgdG90YWwgKz0gdGhpcy5nZXRDb2x1bW5XaWR0aChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgZGF0YSBjb2x1bW4gYXJlYSBpbiB0aGUgaHlwZXJncmlkLlxuICAgICAqL1xuICAgIGdldENvbHVtbnNXaWR0aDogZnVuY3Rpb24odG9YKSB7XG4gICAgICAgIHZhciBjb3VudCA9IHRvWCA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXRBY3RpdmVDb2x1bW5Db3VudCgpIDogdG9YLFxuICAgICAgICAgICAgdG90YWwgPSAwLFxuICAgICAgICAgICAgaSA9IHRoaXMubGVmdE1vc3RDb2xJbmRleDtcblxuICAgICAgICBmb3IgKDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHRvdGFsICs9IHRoaXMuZ2V0Q29sdW1uV2lkdGgoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2MgVGhpcyBleGlzdHMgdG8gc3VwcG9ydCBcImZsb2F0aW5nXCIgY29sdW1ucy5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB0b3RhbCB3aWR0aCBvZiB0aGUgZml4ZWQgY29sdW1ucyBhcmVhLlxuICAgICAqL1xuICAgIGdldEZpeGVkQ29sdW1uc01heFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rml4ZWRDb2x1bW5zV2lkdGgoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIGRlbGVnYXRlIHNldHRpbmcgdGhlIGN1cnNvciB1cCB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgc2V0Q3Vyc29yOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGdyaWQudXBkYXRlQ3Vyc29yKCk7XG4gICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLnNldEN1cnNvcihncmlkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIG1vdXNlIG1vdmUgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlTW91c2VNb3ZlKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyB0YXAgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25DbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVDbGljayhncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgdGFwIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uQ29udGV4dE1lbnU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlQ29udGV4dE1lbnUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIHdoZWVsIG1vdmVkIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uV2hlZWxNb3ZlZDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVXaGVlbE1vdmVkKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyB0YXAgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25HcmlkUmVuZGVyZWQ6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlR3JpZFJlbmRlcmVkKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9uQ29sdW1uUmVzaXplZEV2ZW50OiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZUNvbHVtblJlc2l6ZWRFdmVudChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIG1vdXNlIHVwIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uTW91c2VVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVNb3VzZVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBtb3VzZSBkcmFnIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcga2V5IGRvd24gdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25LZXlEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZUtleURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyaWQub25DdHJsU2hpZnRBbmRaICYmIGV2ZW50LmRldGFpbC5jaGFyID09PSAnWicgJiYgZXZlbnQuZGV0YWlsLmN0cmwgJiYgZXZlbnQuZGV0YWlsLnNoaWZ0KSB7XG4gICAgICAgICAgICBncmlkLm9uQ3RybFNoaWZ0QW5kWigpO1xuICAgICAgICB9IGVsc2UgaWYgKGdyaWQub25DdHJsQW5kWiAmJiBldmVudC5kZXRhaWwuY2hhciA9PT0gJ3onICYmIGV2ZW50LmRldGFpbC5jdHJsKSB7XG4gICAgICAgICAgICBncmlkLm9uQ3RybEFuZFooKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkFwaURlc3Ryb3lDYWxsZWQ6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4ub25BcGlEZXN0cm95Q2FsbGVkKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcga2V5IHVwIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uS2V5VXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlS2V5VXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIG9mIGdyaWQgZGF0YSBhZGRlZCBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvbkRhdGFBZGRlZDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVEYXRhQWRkZWQoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBkb3VibGUgY2xpY2sgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25Eb3VibGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVEb3VibGVDbGljayhncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIG1vdXNlIGRvd24gdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgbW91c2UgZG93biBvdXRzaWRlIGN1cnJlbnQgY2FudmFzIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUNhbnZhc091dHNpZGVNb3VzZURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlQ2FudmFzT3V0c2lkZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgbW91c2UgZXhpdCB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZUV4aXQ6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlTW91c2VFeGl0KGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyBJJ3ZlIGJlZW4gbm90aWZpZWQgdGhhdCB0aGUgYmVoYXZpb3IgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgY2hhbmdlZDogZnVuY3Rpb24oKSB7IHRoaXMuZ3JpZC5iZWhhdmlvckNoYW5nZWQoKTsgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgZ3JpZCBkYXRhIGhhdmUgY2hhbmdlZC4gWW91J3ZlIGJlZW4gbm90aWZpZWQuXG4gICAgICovXG4gICAgc2hhcGVDaGFuZ2VkOiBmdW5jdGlvbigpIHsgdGhpcy5ncmlkLmJlaGF2aW9yU2hhcGVDaGFuZ2VkKCk7IH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2MgVGhlIGRpbWVuc2lvbnMgb2YgdGhlIGdyaWQgZGF0YSBoYXZlIGNoYW5nZWQuIFlvdSd2ZSBiZWVuIG5vdGlmaWVkLlxuICAgICAqL1xuICAgIHN0YXRlQ2hhbmdlZDogZnVuY3Rpb24oKSB7IHRoaXMuZ3JpZC5iZWhhdmlvclN0YXRlQ2hhbmdlZCgpOyB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IENhbiByZS1vcmRlciBjb2x1bW5zLlxuICAgICAqL1xuICAgIGlzQ29sdW1uUmVvcmRlcmFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdpc0NvbHVtblJlb3JkZXJhYmxlKCknLCAnZ3JpZC5wcm9wZXJ0aWVzLmNvbHVtbnNSZW9yZGVyYWJsZScsICcyLjEuMycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2luZGV4fSB4IC0gRGF0YSB4IGNvb3JkaW5hdGUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgcHJvcGVydGllcyBmb3IgYSBzcGVjaWZpYyBjb2x1bW4uXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqL1xuICAgIGdldENvbHVtblByb3BlcnRpZXM6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuZ2V0Q29sdW1uKHgpO1xuICAgICAgICByZXR1cm4gY29sdW1uICYmIGNvbHVtbi5wcm9wZXJ0aWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2luZGV4fSB4IC0gRGF0YSB4IGNvb3JkaW5hdGUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgcHJvcGVydGllcyBmb3IgYSBzcGVjaWZpYyBjb2x1bW4uXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqL1xuICAgIHNldENvbHVtblByb3BlcnRpZXM6IGZ1bmN0aW9uKHgsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuZ2V0Q29sdW1uKHgpO1xuICAgICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIGNvbHVtbi4nO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBPYmplY3QuYXNzaWduKGNvbHVtbi5wcm9wZXJ0aWVzLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgY2VsbCBwcm9wZXJ0aWVzIG9mIGdpdmVuIGNvbHVtbiBvciBvZiBhbGwgY29sdW1ucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3hdIC0gT21pdCBmb3IgYWxsIGNvbHVtbnMuXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqL1xuICAgIGNsZWFyQWxsQ2VsbFByb3BlcnRpZXM6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuZ2V0Q29sdW1uKHgpO1xuICAgICAgICAgICAgaWYgKGNvbHVtbikge1xuICAgICAgICAgICAgICAgIGNvbHVtbi5jbGVhckFsbENlbGxQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdWJncmlkcykge1xuICAgICAgICAgICAgdGhpcy5zdWJncmlkcy5mb3JFYWNoKGZ1bmN0aW9uKGRhdGFNb2RlbCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBkYXRhTW9kZWwuZ2V0Um93Q291bnQoKTsgaS0tOykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhTW9kZWwuc2V0Um93TWV0YWRhdGEoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEByZXR1cm4ge3N0cmluZ1tdfSBBbGwgdGhlIGN1cnJlbnRseSBoaWRkZW4gY29sdW1uIGhlYWRlciBsYWJlbHMuXG4gICAgICovXG4gICAgZ2V0SGlkZGVuQ29sdW1uRGVzY3JpcHRvcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGFibGVTdGF0ZSA9IHRoaXMuZ3JpZC5wcm9wZXJ0aWVzO1xuICAgICAgICB2YXIgaW5kZXhlcyA9IHRhYmxlU3RhdGUuY29sdW1uSW5kZXhlcztcbiAgICAgICAgdmFyIGxhYmVscyA9IFtdO1xuICAgICAgICB2YXIgY29sdW1uQ291bnQgPSB0aGlzLmdldEFjdGl2ZUNvbHVtbkNvdW50KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKGluZGV4ZXMuaW5kZXhPZihpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5nZXRBY3RpdmVDb2x1bW4oaSk7XG4gICAgICAgICAgICAgICAgbGFiZWxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogaSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiBjb2x1bW4uaGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogY29sdW1uLm5hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFiZWxzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGZpeGVkIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQucHJvcGVydGllcy5maXhlZENvbHVtbkNvdW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2Mgc2V0IHRoZSBudW1iZXIgb2YgZml4ZWQgY29sdW1uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIC0gdGhlIGludGVnZXIgY291bnQgb2YgaG93IG1hbnkgY29sdW1ucyB0byBiZSBmaXhlZFxuICAgICAqL1xuICAgIHNldEZpeGVkQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdGhpcy5ncmlkLnByb3BlcnRpZXMuZml4ZWRDb2x1bW5Db3VudCA9IG47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFRoZSBudW1iZXIgb2YgXCJmaXhlZCByb3dzLlwiXG4gICAgICogQGRlc2MgVGhlIG51bWJlciBvZiAobm9uLXNjcm9sbGFibGUpIHJvd3MgcHJlY2VkaW5nIHRoZSAoc2Nyb2xsYWJsZSkgZGF0YSBzdWJncmlkLlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzdW0gb2Y6XG4gICAgICogMS4gQWxsIHJvd3Mgb2YgYWxsIHN1YmdyaWRzIHByZWNlZGluZyB0aGUgZGF0YSBzdWJncmlkLlxuICAgICAqIDIuIFRoZSBmaXJzdCBgZml4ZWRSb3dDb3VudGAgcm93cyBvZiB0aGUgZGF0YSBzdWJncmlkLlxuICAgICAqL1xuICAgIGdldEZpeGVkUm93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5nZXRIZWFkZXJSb3dDb3VudCgpICtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLmZpeGVkUm93Q291bnRcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIFNldCB0aGUgbnVtYmVyIG9mIGZpeGVkIHJvd3MsIHdoaWNoIGluY2x1ZGVzICh0b3AgdG8gYm90dG9tIG9yZGVyKTpcbiAgICAgKiAxLiBUaGUgaGVhZGVyIHJvd3NcbiAgICAgKiAgICAxLiBUaGUgaGVhZGVyIGxhYmVscyByb3cgKG9wdGlvbmFsKVxuICAgICAqICAgIDIuIFRoZSBmaWx0ZXIgcm93IChvcHRpb25hbClcbiAgICAgKiAgICAzLiBUaGUgdG9wIHRvdGFsIHJvd3MgKDAgb3IgbW9yZSlcbiAgICAgKiAyLiBUaGUgbm9uLXNjcm9sbGluZyByb3dzIChleHRlcm5hbGx5IGNhbGxlZCBcInRoZSBmaXhlZCByb3dzXCIpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTdW0gb2YgdGhlIGFib3ZlIG9yIDAgaWYgbm9uZSBvZiB0aGUgYWJvdmUgYXJlIGluIHVzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHJvd3MuXG4gICAgICovXG4gICAgc2V0Rml4ZWRSb3dDb3VudDogZnVuY3Rpb24obikge1xuICAgICAgICB0aGlzLmdyaWQucHJvcGVydGllcy5maXhlZFJvd0NvdW50ID0gbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIGEgZG5kIGNvbHVtbiBoYXMganVzdCBiZWVuIGRyb3BwZWQsIHdlJ3ZlIGJlZW4gbm90aWZpZWRcbiAgICAgKi9cbiAgICBlbmREcmFnQ29sdW1uTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEByZXR1cm4ge251bGx9IHRoZSBjdXJzb3IgYXQgYSBzcGVjaWZpYyB4LHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGdldEN1cnNvckF0OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgX3Zpc2libGVfIGNvbHVtbnMuXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHRvdGFsIG51bWJlciBvZiBjb2x1bW5zLlxuICAgICAqL1xuICAgIGdldEFjdGl2ZUNvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1ucy5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IENvbHVtbiBhbGlnbm1lbnQgb2YgZ2l2ZW4gZ3JpZCBjb2x1bW4uXG4gICAgICogQGRlc2MgT25lIG9mOlxuICAgICAqICogYCdsZWZ0J2BcbiAgICAgKiAqIGAnY2VudGVyJ2BcbiAgICAgKiAqIGAncmlnaHQnYFxuICAgICAqXG4gICAgICogQ2FzY2FkZXMgdG8gZ3JpZC5cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2MgUXVpZXRseSBzZXQgdGhlIGhvcml6b250YWwgc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIG5ldyBwb3NpdGlvbiBpbiBwaXhlbHMuXG4gICAgICovXG4gICAgc2V0U2Nyb2xsUG9zaXRpb25YOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uWCA9IHg7XG4gICAgfSxcblxuICAgIGdldFNjcm9sbFBvc2l0aW9uWDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFBvc2l0aW9uWDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIFF1aWV0bHkgc2V0IHRoZSB2ZXJ0aWNhbCBzY3JvbGwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgbmV3IHBvc2l0aW9uIGluIHBpeGVscy5cbiAgICAgKi9cbiAgICBzZXRTY3JvbGxQb3NpdGlvblk6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb25ZID0geTtcbiAgICB9LFxuXG4gICAgZ2V0U2Nyb2xsUG9zaXRpb25ZOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsUG9zaXRpb25ZO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQHJldHVybiB7Y2VsbEVkaXRvcn0gVGhlIGNlbGwgZWRpdG9yIGZvciB0aGUgY2VsbCBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR9IGVkaXRQb2ludCAtIFRoZSBncmlkIGNlbGwgY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgZ2V0Q2VsbEVkaXRvckF0OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICByZXR1cm4gZXZlbnQuaXNEYXRhQ29sdW1uICYmIGV2ZW50LmNvbHVtbi5nZXRDZWxsRWRpdG9yQXQoZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHdlIHNob3VsZCBoaWdobGlnaHQgb24gaG92ZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzQ29sdW1uSG92ZXJlZCAtIHRoZSBjb2x1bW4gaXMgaG92ZXJlZCBvciBub3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUm93SG92ZXJlZCAtIHRoZSByb3cgaXMgaG92ZXJlZCBvciBub3RcbiAgICAgKi9cbiAgICBoaWdobGlnaHRDZWxsT25Ib3ZlcjogZnVuY3Rpb24oaXNDb2x1bW5Ib3ZlcmVkLCBpc1Jvd0hvdmVyZWQpIHtcbiAgICAgICAgcmV0dXJuIGlzQ29sdW1uSG92ZXJlZCAmJiBpc1Jvd0hvdmVyZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIGlzIGEgaG9vayBhbmQgaXMgY2FsbGVkIGp1c3QgYmVmb3JlIHRoZSBwYWludGluZyBvZiBhIGNlbGwgb2NjdXJzXG4gICAgICogQHBhcmFtIHtQb2ludH0gY2VsbFxuICAgICAqL1xuICAgIGNlbGxQcm9wZXJ0aWVzUHJlUGFpbnROb3RpZmljYXRpb246IGZ1bmN0aW9uKGNlbGwpIHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBpcyBhIGhvb2sgYW5kIGlzIGNhbGxlZCBqdXN0IGJlZm9yZSB0aGUgcGFpbnRpbmcgb2YgYSBmaXhlZCByb3cgY2VsbCBvY2N1cnNcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsXG4gICAgICovXG4gICAgY2VsbEZpeGVkUm93UHJlUGFpbnROb3RpZmljYXRpb246IGZ1bmN0aW9uKGNlbGwpIHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBpcyBhIGhvb2sgYW5kIGlzIGNhbGxlZCBqdXN0IGJlZm9yZSB0aGUgcGFpbnRpbmcgb2YgYSBmaXhlZCBjb2x1bW4gY2VsbCBvY2N1cnNcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsXG4gICAgICovXG4gICAgY2VsbEZpeGVkQ29sdW1uUHJlUGFpbnROb3RpZmljYXRpb246IGZ1bmN0aW9uKGNlbGwpIHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBpcyBhIGhvb2sgYW5kIGlzIGNhbGxlZCBqdXN0IGJlZm9yZSB0aGUgcGFpbnRpbmcgb2YgYSB0b3AgbGVmdCBjZWxsIG9jY3Vyc1xuICAgICAqIEBwYXJhbSB7UG9pbnR9IGNlbGxcbiAgICAgKi9cbiAgICBjZWxsVG9wTGVmdFByZVBhaW50Tm90aWZpY2F0aW9uOiBmdW5jdGlvbihjZWxsKSB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIHN3YXAgc3JjIGFuZCB0YXIgY29sdW1uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmMgLSBjb2x1bW4gaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGFyIC0gY29sdW1uIGluZGV4XG4gICAgICovXG4gICAgc3dhcENvbHVtbnM6IGZ1bmN0aW9uKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgICAgIHZhciBjb2x1bW5zID0gdGhpcy5jb2x1bW5zO1xuICAgICAgICB2YXIgdG1wID0gY29sdW1uc1tzb3VyY2VdO1xuICAgICAgICBjb2x1bW5zW3NvdXJjZV0gPSBjb2x1bW5zW3RhcmdldF07XG4gICAgICAgIGNvbHVtbnNbdGFyZ2V0XSA9IHRtcDtcbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIHN5bmNocm9uaXplU2NoZW1hVG9Db2x1bW5EZWZzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ncmlkLmFwaS5zZXRDb2x1bW5EZWZzKHRoaXMuZ3JpZC5jb2x1bW5EZWZzKTtcbiAgICB9LFxuXG4gICAgcmVjYWxjdWxhdGVDb2x1bW5TaXplczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ3JpZC5hcGkuc2l6ZUNvbHVtbnNUb0ZpdCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyB1dGlsaXR5IG1ldGhvZCB0byBwZXJmb3JtIGNvbHVtbnMgcmVvcmRlcmluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tIC0gdmlzaWJsZSBjb2x1bW5zIHN0YXJ0IGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbiAtIGxlbmd0aCBvZiBjb2x1bW5zIHNldCB0byByZW9yZGVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldCAtIG5ldyBzdGFydCBpbmRleCBvZiBhbiBjb2x1bW5zXG4gICAgICogQHBhcmFtIHtib29sZWFuP30gYnJvYWRjYXN0RXZlbnQgLSBvcHRpb25hbCBwYXJhbS4gSWYgc2V0IHRvICdmYWxzZScsIHN5bnRoZXRpYyBldmVudCB3aWxsIG5vdCBiZSBmaXJlZC5cbiAgICAgKiBVc2VmdWwsIHdoZW4gcmVvcmRlcmluZyBub3QgaW5pdGlhdGVkIGJ5IHVzZXIsIGFuZCBkb24ndCBuZWVkIHRvIGFmZmVjdCBzaWRlIGVmZmVjdHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW4/fSBnaXZlbkhpZGRlbkNvbHVtbnMgLSBpZiB0cnVlLCBtZXRob2QgcGVyZm9ybWVkIGxpa2UgYWxsIHRoZSBjb2x1bW5zIGlzIHNob3duIGFuZCBpbmRleGVzXG4gICAgICogb2YgdmlzaWJsZSBjb2x1bW5zIGFuZCBhbGwgY29sdW1ucyBhcmUgZXF1YWxcbiAgICAgKi9cbiAgICBtb3ZlQ29sdW1uczogZnVuY3Rpb24oZnJvbSwgbGVuLCB0YXJnZXQsIGJyb2FkY2FzdEV2ZW50ID0gdHJ1ZSwgZ2l2ZW5IaWRkZW5Db2x1bW5zID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5sb2coJ21vdmVDb2x1bW5zIGNhbGxlZCB3aXRoIHBhcmFtcycsIGZyb20sIGxlbiwgdGFyZ2V0LCBicm9hZGNhc3RFdmVudCwgZ2l2ZW5IaWRkZW5Db2x1bW5zKTtcbiAgICAgICAgY29uc3QgY29sdW1ucyA9IHRoaXMuY29sdW1ucztcblxuICAgICAgICBjb25zdCB2aXNpYmxlQ29sRGVmcyA9IHRoaXMuZ3JpZC52aXNpYmxlQ29sdW1uRGVmcztcbiAgICAgICAgY29uc3QgY29sRGVmcyA9IHRoaXMuZ3JpZC5jb2x1bW5EZWZzO1xuXG4gICAgICAgIGxldCBjb2xEZWZzVG9Nb3ZlID0gZ2l2ZW5IaWRkZW5Db2x1bW5zXG4gICAgICAgICAgICA/IGNvbERlZnMuc2xpY2UoMCkuc3BsaWNlKGZyb20sIGxlbilcbiAgICAgICAgICAgIDogdmlzaWJsZUNvbERlZnMuc2xpY2UoMCkuc3BsaWNlKGZyb20sIGxlbik7XG5cbiAgICAgICAgbGV0IGhlYWRlcnMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLm9ubHlEYXRhUmVvcmRlcikge1xuICAgICAgICAgICAgaGVhZGVycyA9IGNvbHVtbnMubWFwKGMgPT4gYy5oZWFkZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFnaXZlbkhpZGRlbkNvbHVtbnMpIHtcbiAgICAgICAgICAgIGxldCB2aXNpYmxlQ29sdW1uV2l0aFRhcmdldEluZGV4ID0gdmlzaWJsZUNvbERlZnNbdGFyZ2V0XTtcbiAgICAgICAgICAgIHRhcmdldCA9IGNvbERlZnMuaW5kZXhPZih2aXNpYmxlQ29sdW1uV2l0aFRhcmdldEluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtb3ZlZENvbHVtbnMgPSBbXTtcbiAgICAgICAgbGV0IGNvbERlZnNQcmVwYXJlZCA9IGNvbERlZnNUb01vdmU7XG4gICAgICAgIGlmIChjb2xEZWZzLmluZGV4T2YoY29sRGVmc1RvTW92ZVswXSkgPj0gdGFyZ2V0KSB7XG4gICAgICAgICAgICBjb2xEZWZzUHJlcGFyZWQgPSBjb2xEZWZzVG9Nb3ZlLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjb2xEZWZzUHJlcGFyZWQuZm9yRWFjaCgoY29sRGVmKSA9PiB7XG4gICAgICAgICAgICBsZXQgY29sdW1uV2l0aFNhbWVDb2xEZWYgPSBjb2x1bW5zLmZpbmQoKGMpID0+IGMuY29sRGVmID09PSBjb2xEZWYpO1xuICAgICAgICAgICAgaWYgKGNvbHVtbldpdGhTYW1lQ29sRGVmKSB7XG4gICAgICAgICAgICAgICAgbW92ZWRDb2x1bW5zLnVuc2hpZnQoY29sdW1uV2l0aFNhbWVDb2xEZWYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY3VycmVudENvbERlZkluZGV4ID0gY29sRGVmcy5pbmRleE9mKGNvbERlZik7XG4gICAgICAgICAgICBjb2xEZWZzLnNwbGljZSh0YXJnZXQsIDAsIGNvbERlZnMuc3BsaWNlKGN1cnJlbnRDb2xEZWZJbmRleCwgMSlbMF0pO1xuXG4gICAgICAgICAgICB0aGlzLmxvZyhgQ29sRGVmIHdpdGggaW5kZXggJHtjdXJyZW50Q29sRGVmSW5kZXh9IG1vdmVkIHRvICR7dGFyZ2V0fWApO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnN5bmNocm9uaXplU2NoZW1hVG9Db2x1bW5EZWZzKCk7XG5cbiAgICAgICAgaWYgKGJyb2FkY2FzdEV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQuZmlyZVN5bnRoZXRpY0NvbHVtbnNNb3ZlZEV2ZW50KG1vdmVkQ29sdW1ucywgdGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ3JpZC52aXNpYmxlQ29sdW1uRGVmcyA9IGNvbERlZnMuZmlsdGVyKChjZCkgPT4gIWNkLmlzSGlkZGVuKTtcblxuICAgICAgICBpZiAodGhpcy5ncmlkLnByb3BlcnRpZXMub25seURhdGFSZW9yZGVyKSB7XG4gICAgICAgICAgICBjb2x1bW5zLmZvckVhY2goKGMsIGkpID0+IGMuaGVhZGVyID0gaGVhZGVyc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgY29udmVydFZpZXdQb2ludFRvRGF0YVBvaW50OiBmdW5jdGlvbih1bnNjcm9sbGVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICB0aGlzLmdldEFjdGl2ZUNvbHVtbih1bnNjcm9sbGVkLngpLmluZGV4LFxuICAgICAgICAgICAgdW5zY3JvbGxlZC55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHNob3dzLCBpcyByb3cgd2l0aCB0aGlzIGluZGV4IHJlcHJlc2VudHMgYWdncmVnYXRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGlzQWdncmVnYXRpb25Sb3dCeUluZGV4OiBmdW5jdGlvbihyb3dJbmRleCkge1xuICAgICAgICBsZXQgcm93ID0gdGhpcy5ncmlkLmdldFJvdyhyb3dJbmRleCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBZ2dyZWdhdGlvblJvdyhyb3cpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBzaG93cywgaXMgcm93IHJlcHJlc2VudHMgYWdncmVnYXRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGlzQWdncmVnYXRpb25Sb3c6IGZ1bmN0aW9uKHJvdykge1xuICAgICAgICByZXR1cm4gISFyb3cgJiYgdHlwZW9mIHJvdy4kJGFnZ3JlZ2F0aW9uICE9PSAndW5kZWZpbmVkJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgcmV0dXJucyBhcnJheSBvZiBjaGlsZCByb3dzIG9mIGFuIHJvdyBieSBpbmRleFxuICAgICAqIEB0eXBlIHthcnJheX1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGdldENoaWxkUm93c0J5SW5kZXg6IGZ1bmN0aW9uKHJvd0luZGV4KSB7XG4gICAgICAgIGxldCByb3cgPSB0aGlzLmdyaWQuZ2V0Um93KHJvd0luZGV4KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDaGlsZFJvd3Mocm93KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBkZXNjIHJldHVybnMgYXJyYXkgb2YgY2hpbGQgcm93cyBvZiBhbiByb3cgaWYgZXhpc3RzXG4gICAgICogQHR5cGUge2FycmF5fVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgZ2V0Q2hpbGRSb3dzOiBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgcmV0dXJuICEhcm93ICYmIHJvdy4kJGNoaWxkcmVuID8gcm93LiQkY2hpbGRyZW4gOiBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2Mgc2hvd3MsIGlzIHJvdyB3aXRoIGluZGV4IGNvbnRhaW5zIGFnZ3JlZ2F0ZWQgc3Vicm93c1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgaGFzQ2hpbGRSb3dzQnlJbmRleDogZnVuY3Rpb24ocm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2hpbGRSb3dzQnlJbmRleChyb3dJbmRleCkubGVuZ3RoID4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2Mgc2hvd3MsIGlzIHJvdyBjb250YWlucyBhZ2dyZWdhdGVkIHN1YnJvd3NcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGhhc0NoaWxkUm93czogZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENoaWxkUm93cyhyb3cpLmxlbmd0aCA+IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHJldHVybnMgY291bnQgb2YgYWdncmVnYXRlZCBjaGlsZCByb3dzIGJ5IHBhcmVudCByb3cgaW5kZXhcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgZ2V0QWdncmVnYXRpb25DaGlsZENvdW50QnlJbmRleDogZnVuY3Rpb24ocm93SW5kZXgpIHtcbiAgICAgICAgbGV0IHJvdyA9IHRoaXMuZ3JpZC5nZXRSb3cocm93SW5kZXgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldEFnZ3JlZ2F0aW9uQ2hpbGRDb3VudChyb3cpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyByZXR1cm5zIGNvdW50IG9mIGFnZ3JlZ2F0ZWQgY2hpbGQgcm93c1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgKi9cbiAgICBnZXRBZ2dyZWdhdGlvbkNoaWxkQ291bnQ6IGZ1bmN0aW9uKHJvdykge1xuICAgICAgICByZXR1cm4gISFyb3cgJiYgISFyb3cuJCRjbHVzdGVyX3NpemUgPyByb3cuJCRjbHVzdGVyX3NpemUgOiAwO1xuICAgIH0sXG5cbiAgICBpc0V4cGFuZGFibGVSb3dCeUluZGV4OiBmdW5jdGlvbihyb3dJbmRleCkge1xuICAgICAgICBsZXQgcm93ID0gdGhpcy5ncmlkLmdldFJvdyhyb3dJbmRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRXhwYW5kYWJsZVJvdyhyb3cpO1xuICAgIH0sXG5cbiAgICBpc0V4cGFuZGFibGVSb3c6IGZ1bmN0aW9uKHJvdykge1xuICAgICAgICByZXR1cm4gISFyb3cgJiYgcm93LiQkZXhwYW5kYWJsZSA/IHJvdy4kJGV4cGFuZGFibGUgOiBmYWxzZTtcbiAgICB9LFxuXG4gICAgaXNSb3dFeHBhbmRlZEJ5SW5kZXg6IGZ1bmN0aW9uKHJvd0luZGV4KSB7XG4gICAgICAgIGxldCByb3cgPSB0aGlzLmdyaWQuZ2V0Um93KHJvd0luZGV4KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5pc1Jvd0V4cGFuZGVkKHJvdyk7XG4gICAgfSxcblxuICAgIGlzUm93RXhwYW5kZWQ6IGZ1bmN0aW9uKHJvdykge1xuICAgICAgICByZXR1cm4gISFyb3cgJiYgcm93LiQkb3BlbiA/IHJvdy4kJG9wZW4gOiBmYWxzZTtcbiAgICB9LFxuXG4gICAgZ2V0Um93VHJlZUxldmVsQnlJbmRleDogZnVuY3Rpb24ocm93SW5kZXgpIHtcbiAgICAgICAgbGV0IHJvdyA9IHRoaXMuZ3JpZC5nZXRSb3cocm93SW5kZXgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldFJvd1RyZWVMZXZlbChyb3cpO1xuICAgIH0sXG5cbiAgICBnZXRSb3dUcmVlTGV2ZWw6IGZ1bmN0aW9uKHJvdykge1xuICAgICAgICByZXR1cm4gISFyb3cgJiYgcm93Ll9fdHJlZUxldmVsICE9PSB1bmRlZmluZWQgPyByb3cuX190cmVlTGV2ZWwgOiBmYWxzZTtcbiAgICB9LFxuXG4gICAgaGFzVHJlZUNvbHVtbjogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGlvbk1hdHJpeEZ1bmN0aW9uOiBmdW5jdGlvbihzZWxlY3RlZFJvd3MpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGdldFJvd0hlYWRlckNvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFsbENvbHVtbnNbdGhpcy5yb3dDb2x1bW5JbmRleF07XG4gICAgfSxcblxuICAgIGdldEhlYWRlckNvbHVtbkJ5TmFtZTogZnVuY3Rpb24obmFtZVRvRmluZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zLmZpbmQoYyA9PiBjLm5hbWUgPT09IG5hbWVUb0ZpbmQpO1xuICAgIH0sXG5cbiAgICBhdXRvc2l6ZUFsbENvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNoZWNrQ29sdW1uQXV0b3NpemluZyh0cnVlKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIGNoZWNrQ29sdW1uQXV0b3NpemluZzogZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgICAgZm9yY2UgPSBmb3JjZSA9PT0gdHJ1ZTtcbiAgICAgICAgdmFyIGF1dG9TaXplZCA9IHRoaXMuYXV0b1NpemVSb3dOdW1iZXJDb2x1bW4oKSB8fFxuICAgICAgICAgICAgdGhpcy5oYXNUcmVlQ29sdW1uKCkgJiYgdGhpcy5nZXRSb3dIZWFkZXJDb2x1bW4oKS5jaGVja0NvbHVtbkF1dG9zaXppbmcoZm9yY2UpO1xuICAgICAgICB0aGlzLmFsbENvbHVtbnMuZm9yRWFjaChmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgICAgIGF1dG9TaXplZCA9IGNvbHVtbi5jaGVja0NvbHVtbkF1dG9zaXppbmcoZm9yY2UpIHx8IGF1dG9TaXplZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhdXRvU2l6ZWQ7XG4gICAgfSxcblxuICAgIGF1dG9TaXplUm93TnVtYmVyQ29sdW1uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLnNob3dSb3dOdW1iZXJzICYmIHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLnJvd051bWJlckF1dG9zaXppbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJvd0hlYWRlckNvbHVtbigpLmNoZWNrQ29sdW1uQXV0b3NpemluZyh0cnVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsQ29sdW1ucztcbiAgICB9LFxuXG4gICAgZ2V0QWN0aXZlQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnM7XG4gICAgfSxcblxuICAgIGdldEhpZGRlbkNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmlzaWJsZSA9IHRoaXMuY29sdW1ucztcbiAgICAgICAgdmFyIGFsbCA9IHRoaXMuYWxsQ29sdW1ucztcbiAgICAgICAgdmFyIGhpZGRlbiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHZpc2libGUuaW5kZXhPZihhbGxbaV0pID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGhpZGRlbi5wdXNoKGFsbFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGlkZGVuLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEuaGVhZGVyIDwgYi5oZWFkZXI7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGlkZGVuO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3RlZFJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGVkUm93cygpO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3RlZENvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGVkQ29sdW1ucygpO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKCk7XG4gICAgfSxcblxuICAgIGxvZzogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmdyaWQubG9nKC4uLmFyZ3VtZW50cyk7XG4gICAgfSxcbn0pO1xuXG5cbi8vIGRlZmluZSBjb25zdGFudHMgYXMgaW1tdXRhYmxlIChpLmUuLCAhd3JpdGFibGUpXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhCZWhhdmlvci5wcm90b3R5cGUsIHtcbiAgICB0cmVlQ29sdW1uSW5kZXg6IHsgdmFsdWU6IC0xIH0sXG4gICAgcm93Q29sdW1uSW5kZXg6IHsgdmFsdWU6IC0yIH1cbn0pO1xuXG5cbmZ1bmN0aW9uIHdhcm5CZWhhdmlvckZlYXR1cmVzRGVwcmVjYXRpb24oKSB7XG4gICAgdmFyIGZlYXR1cmVOYW1lcyA9IFtdLCB1bnJlZ2lzdGVyZWRGZWF0dXJlcyA9IFtdLCBuID0gMDtcblxuICAgIHRoaXMuZmVhdHVyZXMuZm9yRWFjaChmdW5jdGlvbihGZWF0dXJlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IEZlYXR1cmVDb25zdHJ1Y3Rvci5wcm90b3R5cGUuJCRDTEFTU19OQU1FIHx8IEZlYXR1cmVDb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICAgICAgZmVhdHVyZU5hbWUgPSBjbGFzc05hbWUgfHwgJ2ZlYXR1cmUnICsgbisrO1xuXG4gICAgICAgIC8vIGJ1aWxkIGxpc3Qgb2YgZmVhdHVyZSBuYW1lc1xuICAgICAgICBmZWF0dXJlTmFtZXMucHVzaChmZWF0dXJlTmFtZSk7XG5cbiAgICAgICAgLy8gYnVpbGQgbGlzdCBvZiB1bnJlZ2lzdGVyZWQgZmVhdHVyZXNcbiAgICAgICAgaWYgKCF0aGlzLmZlYXR1cmVSZWdpc3RyeS5nZXQoZmVhdHVyZU5hbWUsIHRydWUpKSB7XG4gICAgICAgICAgICB2YXIgY29uc3RydWN0b3JOYW1lID0gRmVhdHVyZUNvbnN0cnVjdG9yLm5hbWUgfHwgRmVhdHVyZUNvbnN0cnVjdG9yLnByb3RvdHlwZS4kJENMQVNTX05BTUUgfHwgJ0ZlYXR1cmVDb25zdHJ1Y3RvcicgKyBuLFxuICAgICAgICAgICAgICAgIHBhcmFtcyA9IFtdO1xuICAgICAgICAgICAgaWYgKCFjbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaCgnXFwnJyArIGZlYXR1cmVOYW1lICsgJ1xcJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyYW1zLnB1c2goY29uc3RydWN0b3JOYW1lKTtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJlZEZlYXR1cmVzLnB1c2gocGFyYW1zLmpvaW4oJywgJykpO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAoZmVhdHVyZU5hbWVzLmxlbmd0aCkge1xuICAgICAgICB2YXIgc2FtcGxlQ29kZSA9ICdIeXBlcmdyaWQuZGVmYXVsdHMuZmVhdHVyZXMgPSBbXFxuJyArIGpvaW4oJ1xcdFxcJycsIGZlYXR1cmVOYW1lcywgJ1xcJyxcXG4nKSArICddOyc7XG5cbiAgICAgICAgaWYgKHVucmVnaXN0ZXJlZEZlYXR1cmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc2FtcGxlQ29kZSArPSAnXFxuXFxuVGhlIGZvbGxvd2luZyBjdXN0b20gZmVhdHVyZXMgYXJlIHVucmVnaXN0ZXJlZCBhbmQgd2lsbCBuZWVkIHRvIGJlIHJlZ2lzdGVyZWQgcHJpb3IgdG8gYmVoYXZpb3IgaW5zdGFudGlhdGlvbjpcXG5cXG4nICtcbiAgICAgICAgICAgICAgICBqb2luKCdGZWF0dXJlcy5hZGQoJywgdW5yZWdpc3RlcmVkRmVhdHVyZXMsICcpO1xcbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgIHNhbXBsZUNvZGUgKz0gJ1xcblxcbihZb3Ugc2hvdWxkIHByb3ZpZGUgbWVhbmluZ2Z1bCBuYW1lcyBmb3IgeW91ciBjdXN0b20gZmVhdHVyZXMgcmF0aGVyIHRoYW4gdGhlIGdlbmVyYXRlZCBuYW1lcyBhYm92ZS4pJztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUud2FybignYGdyaWQuYmVoYXZpb3IuZmVhdHVyZXNgIChhcnJheSBvZiBmZWF0dXJlIGNvbnN0cnVjdG9ycykgaGFzIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2ZXJzaW9uIDIuMS4wIGluIGZhdm9yIG9mIGBncmlkLnByb3BlcnRpZXMuZmVhdHVyZXNgIChhcnJheSBvZiBmZWF0dXJlIG5hbWVzKS4gUmVtb3ZlIGBmZWF0dXJlc2AgYXJyYXkgZnJvbSB5b3VyIGJlaGF2aW9yIGFuZCBhZGQgYGZlYXR1cmVzYCBwcm9wZXJ0eSB0byB5b3VyIGdyaWQgc3RhdGUgb2JqZWN0IChvciBIeXBlcmdyaWQuZGVmYXVsdHMpLCBlLmcuOlxcblxcbicgKyBzYW1wbGVDb2RlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGpvaW4ocHJlZml4LCBhcnJheSwgc3VmZml4KSB7XG4gICAgcmV0dXJuIHByZWZpeCArIGFycmF5LmpvaW4oc3VmZml4ICsgcHJlZml4KSArIHN1ZmZpeDtcbn1cblxuXG4vLyBzeW5vbnltc1xuXG4vKipcbiAqIFN5bm9ueW0gb2Yge0BsaW5rIEJlaGF2aW9yI3JlaW5kZXh9LlxuICogQG5hbWUgYXBwbHlBbmFseXRpY3NcbiAqIEBkZXByZWNhdGVkXG4gKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gKi9cbkJlaGF2aW9yLnByb3RvdHlwZS5hcHBseUFuYWx5dGljcyA9IEJlaGF2aW9yLnByb3RvdHlwZS5yZWluZGV4O1xuXG5cbi8vIG1peC1pbnNcbkJlaGF2aW9yLnByb3RvdHlwZS5taXhJbihyZXF1aXJlKCcuL3Jvd1Byb3BlcnRpZXMnKS5taXhpbik7XG5CZWhhdmlvci5wcm90b3R5cGUubWl4SW4ocmVxdWlyZSgnLi9jZWxsUHJvcGVydGllcycpLmJlaGF2aW9yTWl4aW4pO1xuQmVoYXZpb3IucHJvdG90eXBlLm1peEluKHJlcXVpcmUoJy4vc3ViZ3JpZHMnKS5taXhpbik7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCZWhhdmlvcjtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBvdmVycmlkZXIgPSByZXF1aXJlKCdvdmVycmlkZXInKTtcblxudmFyIHRvRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9saWIvdG9GdW5jdGlvbicpO1xudmFyIEh5cGVyZ3JpZEVycm9yID0gcmVxdWlyZSgnLi4vbGliL2Vycm9yJyk7XG52YXIgaW1hZ2VzID0gcmVxdWlyZSgnLi4vLi4vaW1hZ2VzJyk7XG5cblxuLyoqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBgQ29sdW1uYCBvYmplY3QuXG4gKiBAc2VlIHtAbGluayBtb2R1bGU6Q2VsbH0gaXMgbWl4ZWQgaW50byBDb2x1bW4ucHJvdG90eXBlLlxuICogQG1peGVzIGNlbGxQcm9wZXJ0aWVzLmNvbHVtbk1peGluXG4gKiBAbWl4ZXMgY29sdW1uUHJvcGVydGllcy5taXhpblxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gYmVoYXZpb3JcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xvYmplY3R9IGluZGV4T3JPcHRpb25zIC0gT25lIG9mOlxuICogKiBJZiBhIHBvc2l0aXZlIG51bWJlciwgdmFsaWQgaW5kZXggaW50byBgZmllbGRzYCBhcnJheS5cbiAqICogSWYgYSBzdHJpbmcsIGEgbmFtZSBpbiB0aGUgYGZpZWxkc2AgYXJyYXkuXG4gKiAqIElmIGFuIG9iamVjdCwgbXVzdCBjb250YWluIGVpdGhlciBhbiBgaW5kZXhgIG9yIGEgYG5hbWVgIHByb3BlcnR5LlxuICpcbiAqIFBvc2l0aXZlIHZhbHVlcyBvZiBgaW5kZXhgIGFyZSBcInJlYWxcIiBmaWVsZHM7IHNlZSBhbHNvIHtAbGluayBDb2x1bW4jc2V0UHJvcGVydGllc3xzZXRQcm9wZXJ0aWVzfSB3aGljaCBpcyBjYWxsZWQgdG8gc2V0IHRoZSByZW1haW5pbmcgcHJvcGVydGllcyBzcGVjaWZpZWQgaW4gYG9wdGlvbnNgLlxuICpcbiAqIE5lZ2F0aXZlIHZhbHVlcyBvZiBgaW5kZXhgIGFyZSBzcGVjaWFsIGNhc2VzOlxuICogYGluZGV4YCB8IE1lYW5pbmdcbiAqIDotLS0tLTogfCAtLS0tLS0tLVxuICogICAgLTEgICB8IFJvdyBoZWFkZXIgY29sdW1uXG4gKiAgICAtMiAgIHwgVHJlZSAoZHJpbGwtZG93bikgY29sdW1uXG4gKi9cbmZ1bmN0aW9uIENvbHVtbihiZWhhdmlvciwgaW5kZXgpIHtcbiAgICB2YXIgb3B0aW9ucywgaWNvbjtcblxuICAgIHRoaXMuYmVoYXZpb3IgPSBiZWhhdmlvcjtcbiAgICB0aGlzLmRhdGFNb2RlbCA9IGJlaGF2aW9yLmRhdGFNb2RlbDtcblxuICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbmRleDtcbiAgICAgICAgaW5kZXggPSBvcHRpb25zLmluZGV4ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmluZGV4IDogb3B0aW9ucy5uYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLnNjaGVtYSA9IHRoaXMuYmVoYXZpb3Iuc2NoZW1hW2luZGV4XTtcblxuICAgIGlmICghdGhpcy5zY2hlbWEpIHtcbiAgICAgICAgdGhyb3cgJ0NvbHVtbiBub3QgZm91bmQgaW4gZGF0YS4nO1xuICAgIH1cblxuICAgIHRoaXMucHJvcGVydGllcyA9IG9wdGlvbnM7XG5cbiAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgICAgIGNhc2UgdGhpcy5iZWhhdmlvci50cmVlQ29sdW1uSW5kZXg6XG4gICAgICAgICAgICAvLyBXaWR0aCBvZiBpY29uICsgMy1waXhlbCBzcGFjZXIgKGNoZWNrZWQgYW5kIHVuY2hlY2tlZCBzaG91bGQgYmUgc2FtZSB3aWR0aClcbiAgICAgICAgICAgIGljb24gPSBpbWFnZXNbT2JqZWN0LmNyZWF0ZSh0aGlzLnByb3BlcnRpZXMudHJlZUhlYWRlciwgeyBpc0RhdGFSb3c6IHsgdmFsdWU6IHRydWUgfSB9KS5sZWZ0SWNvbl07XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWluaW11bUNvbHVtbldpZHRoID0gaWNvbiA/IGljb24ud2lkdGggKyAzIDogMDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgdGhpcy5iZWhhdmlvci5yb3dDb2x1bW5JbmRleDpcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2BpbmRleGAgb3V0IG9mIHJhbmdlJztcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG5cbkNvbHVtbi5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbHVtbi5wcm90b3R5cGUuY29uc3RydWN0b3IsXG4gICAgJCRDTEFTU19OQU1FOiAnQ29sdW1uJyxcblxuICAgIEh5cGVyZ3JpZEVycm9yOiBIeXBlcmdyaWRFcnJvcixcblxuICAgIG1peEluOiBvdmVycmlkZXIubWl4SW4sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBJbmRleCBvZiB0aGlzIGNvbHVtbiBpbiB0aGUgYGZpZWxkc2AgYXJyYXkuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgaW5kZXgoKSB7IC8vIHJlYWQtb25seSAobm8gc2V0dGVyKVxuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWEuaW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IE5hbWUgb2YgdGhpcyBjb2x1bW4gZnJvbSB0aGUgYGZpZWxkc2AgYXJyYXkuXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlIGNvbHVtbiBpcyBub3QgaW4gdGhlIHNjaGVtYSAoc3VjaCBhcyBmb3IgaGFuZGxlIGNvbHVtbikuXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7IC8vIHJlYWQtb25seSAobm8gc2V0dGVyKVxuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWEubmFtZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgYWxpYXMgdG8gbmFtZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZSBjb2x1bW4gaXMgbm90IGluIHRoZSBzY2hlbWEgKHN1Y2ggYXMgZm9yIGhhbmRsZSBjb2x1bW4pLlxuICAgICAqL1xuICAgIGdldCBjb2xJZCgpIHsgLy8gcmVhZC1vbmx5IChubyBzZXR0ZXIpXG4gICAgICAgIHJldHVybiAodGhpcy5jb2xEZWYgJiYgdGhpcy5jb2xEZWYuY29sSWQpIHx8IHRoaXMuc2NoZW1hLm5hbWU7XG4gICAgfSxcblxuICAgIGdldCBjb2xEZWYoKSB7IC8vIHJlYWQtb25seSAobm8gc2V0dGVyKVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmNvbERlZjtcbiAgICB9LFxuXG4gICAgZ2V0IHRyZWVMZXZlbCgpIHsgLy8gcmVhZC1vbmx5IChubyBzZXR0ZXIpXG4gICAgICAgIHJldHVybiB0aGlzLmNvbERlZiA/IHRoaXMuY29sRGVmLnRyZWVMZXZlbCA6IHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IG9yIHNldCB0aGUgdGV4dCBvZiB0aGUgY29sdW1uJ3MgaGVhZGVyLlxuICAgICAqIEBkZXNjIFRoZSBfaGVhZGVyXyBpcyB0aGUgbGFiZWwgYXQgdGhlIHRvcCBvZiB0aGUgY29sdW1uLlxuICAgICAqXG4gICAgICogU2V0dGluZyB0aGUgaGVhZGVyIHVwZGF0ZXMgYm90aDpcbiAgICAgKiAqIHRoZSBgc2NoZW1hYCAoYWthLCBoZWFkZXIpIGFycmF5IGluIHRoZSB1bmRlcmx5aW5nIGRhdGEgc291cmNlOyBhbmRcbiAgICAgKiAqIHRoZSBmaWx0ZXIuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBzZXQgaGVhZGVyKGhlYWRlclRleHQpIHtcbiAgICAgICAgaWYgKGhlYWRlclRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2NoZW1hLmhlYWRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hLmhlYWRlciA9IGhlYWRlclRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iZWhhdmlvci5ncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuICAgIGdldCBoZWFkZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtYS5oZWFkZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCBvciBzZXQgdGhlIGNvbXB1dGVkIGNvbHVtbidzIGNhbGN1bGF0b3IgZnVuY3Rpb24uXG4gICAgICogQGRlc2MgU2V0dGluZyB0aGUgdmFsdWUgaGVyZSB1cGRhdGVzIHRoZSBjYWxjdWxhdG9yIGluIHRoZSBkYXRhIG1vZGVsIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIFRoZSByZXN1bHRzIG9mIHRoZSBuZXcgY2FsY3VsYXRpb25zIHdpbGwgYXBwZWFyIGluIHRoZSBjb2x1bW4gY2VsbHMgb24gdGhlIG5leHQgcmVwYWludC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHNldCBjYWxjdWxhdG9yKGNhbGN1bGF0b3IpIHtcbiAgICAgICAgaWYgKGNhbGN1bGF0b3IpIHtcbiAgICAgICAgICAgIGNhbGN1bGF0b3IgPSByZXNvbHZlQ2FsY3VsYXRvci5jYWxsKHRoaXMsIGNhbGN1bGF0b3IpO1xuICAgICAgICAgICAgaWYgKGNhbGN1bGF0b3IgIT09IHRoaXMuc2NoZW1hLmNhbGN1bGF0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsY3VsYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjaGVtYS5jYWxjdWxhdG9yO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZW1hLmNhbGN1bGF0b3IgPSBjYWxjdWxhdG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmJlaGF2aW9yLnJlaW5kZXgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNjaGVtYS5jYWxjdWxhdG9yKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zY2hlbWEuY2FsY3VsYXRvcjtcbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3IucmVpbmRleCgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXQgY2FsY3VsYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1hLmNhbGN1bGF0b3I7XG4gICAgfSxcblxuICAgIGdldCBzZWFyY2hUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xEZWYgJiYgdGhpcy5jb2xEZWYuc2VhcmNoVHlwZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IG9yIHNldCB0aGUgdHlwZSBvZiB0aGUgY29sdW1uJ3MgaGVhZGVyLlxuICAgICAqIEBkZXNjIFNldHRpbmcgdGhlIHR5cGUgdXBkYXRlcyB0aGUgZmlsdGVyIHdoaWNoIHR5cGljYWxseSB1c2VzIHRoaXMgaW5mb3JtYXRpb24gZm9yIHByb3BlciBjb2xsYXRpb24uXG4gICAgICpcbiAgICAgKiBAdG9kbzogSW5zdGVhZCBvZiB1c2luZyBgdGhpcy5fdHlwZWAsIHB1dCBvbiBkYXRhIHNvdXJjZSBsaWtlIHRoZSBvdGhlciBlc3NlbnRpYWwgcHJvcGVydGllcy4gSW4gdGhpcyBjYXNlLCBzb3J0ZXIgY291bGQgdXNlIHRoZSBpbmZvIHRvIGNob29zZSBhIGNvbXBhcmF0b3IgbW9yZSBpbnRlbGxpZ2VudGx5IGFuZCBlZmZpY2llbnRseS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHNldCB0eXBlKHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2NoZW1hLnR5cGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYS50eXBlID0gdHlwZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJlaGF2aW9yLnJlaW5kZXgoKTtcbiAgICB9LFxuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWEudHlwZTtcbiAgICB9LFxuXG4gICAgZ2V0Q291bnQ6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldENvdW50KHRoaXMuaW5kZXgsIHkpO1xuICAgIH0sXG5cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0VmFsdWUodGhpcy5pbmRleCwgeSk7XG4gICAgfSxcblxuICAgIHNldFZhbHVlOiBmdW5jdGlvbih5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuc2V0VmFsdWUodGhpcy5pbmRleCwgeSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMud2lkdGggfHwgdGhpcy5wcm9wZXJ0aWVzLmRlZmF1bHRDb2x1bW5XaWR0aDtcbiAgICB9LFxuXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICAgIHdpZHRoID0gTWF0aC5tYXgodGhpcy5wcm9wZXJ0aWVzLm1pbmltdW1Db2x1bW5XaWR0aCwgd2lkdGgpO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMubWF4V2lkdGggJiYgd2lkdGggPiB0aGlzLnByb3BlcnRpZXMubWF4V2lkdGgpIHtcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5wcm9wZXJ0aWVzLm1heFdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdpZHRoICE9PSB0aGlzLnByb3BlcnRpZXMud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5zY2hlbWEud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5jb2x1bW5BdXRvc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2hlY2tDb2x1bW5BdXRvc2l6aW5nOiBmdW5jdGlvbihmb3JjZSkge1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMucHJvcGVydGllcywgd2lkdGgsIHByZWZlcnJlZFdpZHRoLCBhdXRvU2l6ZWQ7XG5cbiAgICAgICAgaWYgKHByb3BlcnRpZXMuY29sdW1uQXV0b3NpemluZykge1xuICAgICAgICAgICAgd2lkdGggPSBwcm9wZXJ0aWVzLndpZHRoO1xuICAgICAgICAgICAgcHJlZmVycmVkV2lkdGggPSBwcm9wZXJ0aWVzLnByZWZlcnJlZFdpZHRoIHx8IHdpZHRoO1xuICAgICAgICAgICAgZm9yY2UgPSBmb3JjZSB8fCAhcHJvcGVydGllcy5jb2x1bW5BdXRvc2l6ZWQ7XG4gICAgICAgICAgICBpZiAod2lkdGggIT09IHByZWZlcnJlZFdpZHRoIHx8IGZvcmNlICYmIHByZWZlcnJlZFdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLndpZHRoID0gZm9yY2UgPyBwcmVmZXJyZWRXaWR0aCA6IE1hdGgubWF4KHdpZHRoLCBwcmVmZXJyZWRXaWR0aCk7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5jb2x1bW5BdXRvc2l6ZWQgPSAhaXNOYU4ocHJvcGVydGllcy53aWR0aCk7XG4gICAgICAgICAgICAgICAgYXV0b1NpemVkID0gcHJvcGVydGllcy53aWR0aCAhPT0gd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXV0b1NpemVkO1xuICAgIH0sXG5cbiAgICBnZXRDZWxsVHlwZTogZnVuY3Rpb24oeSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKHkpO1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlT2YodmFsdWUpO1xuICAgIH0sXG5cbiAgICBnZXRUeXBlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgICB2YXIgdHlwZSA9IHByb3BzLnR5cGU7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgdHlwZSA9IHRoaXMuY29tcHV0ZUNvbHVtblR5cGUoKTtcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSAndW5rbm93bicpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9LFxuXG4gICAgY29tcHV0ZUNvbHVtblR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSB0aGlzLmJlaGF2aW9yLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmJlaGF2aW9yLmdldFJvd0NvdW50KCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoaGVhZGVyUm93Q291bnQpO1xuICAgICAgICB2YXIgZWFjaFR5cGUgPSB0aGlzLnR5cGVPZih2YWx1ZSk7XG4gICAgICAgIGlmICghZWFjaFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiAndW5rbm93bic7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGVPZih2YWx1ZSk7XG4gICAgICAgIC8vdmFyIGlzTnVtYmVyID0gKCh0eXBlb2YgdmFsdWUpID09PSAnbnVtYmVyJyk7XG4gICAgICAgIGZvciAodmFyIHkgPSBoZWFkZXJSb3dDb3VudDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoeSk7XG4gICAgICAgICAgICBlYWNoVHlwZSA9IHRoaXMudHlwZU9mKHZhbHVlKTtcbiAgICAgICAgICAgIC8vIGlmICh0eXBlICE9PSBlYWNoVHlwZSkge1xuICAgICAgICAgICAgLy8gICAgIGlmIChpc051bWJlciAmJiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgdHlwZSA9ICdmbG9hdCc7XG4gICAgICAgICAgICAvLyAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgcmV0dXJuICdtaXhlZCc7XG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH0sXG5cbiAgICB0eXBlT2Y6IGZ1bmN0aW9uKHNvbWV0aGluZykge1xuICAgICAgICBpZiAoc29tZXRoaW5nID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlT2YgPSB0eXBlb2Ygc29tZXRoaW5nO1xuICAgICAgICBzd2l0Y2ggKHR5cGVPZikge1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc29tZXRoaW5nLmNvbnN0cnVjdG9yLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHNvbWV0aGluZykgPT09IHNvbWV0aGluZyA/ICdpbnQnIDogJ2Zsb2F0JztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVPZjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXQgcHJvcGVydGllcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgfSxcbiAgICBzZXQgcHJvcGVydGllcyhvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSB0aGlzLmNyZWF0ZUNvbHVtblByb3BlcnRpZXMoKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0aWVzKG93blByb3BlcnRpZXMpO1xuICAgIH0sXG5cbiAgICAvKiogVGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYmVjYXVzZSBzb21lIGdyaWQgcmVuZGVyZXIgb3B0aW1pemF0aW9ucyByZXF1aXJlIHRoYXQgdGhlIGdyaWQgcmVuZGVyZXIgYmUgaW5mb3JtZWQgd2hlbiBjb2x1bW4gY29sb3JzIGNoYW5nZS4gRHVlIHRvIHBlcmZvcm1hbmNlIGNvbmNlcm5zLCB0aGV5IGNhbm5vdCB0YWtlIHRoZSB0aW1lIHRvIGZpZ3VyZSBpdCBvdXQgZm9yIHRoZW1zZWx2ZXMuIEFsb25nIHRoZSBzYW1lIGxpbmVzLCBtYWtpbmcgdGhlIHByb3BlcnR5IGEgZ2V0dGVyL3NldHRlciAoaW4gY29sdW1uUHJvcGVydGllcy5qcyksIHRob3VnaCBkb2FibGUsIG1pZ2h0IHByZXNlbnQgcGVyZm9ybWFuY2UgY29uY2VybnMgYXMgdGhpcyBwcm9wZXJ0eSBpcyBwb3NzaWJseSB0aGUgbW9zdCBhY2Nlc3NlZCBvZiBhbGwgY29sdW1uIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIGNvbG9yXG4gICAgICovXG4gICAgc2V0QmFja2dyb3VuZENvbG9yOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLmJhY2tncm91bmRDb2xvciAhPT0gY29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3IuZ3JpZC5yZW5kZXJlci5yZWJ1bmRsZUdyaWRSZW5kZXJlcnMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRQcm9wZXJ0aWVzOiBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHZhciBrZXksIGRlc2NyaXB0b3IsIG9iaiA9IHRoaXMucHJvcGVydGllcztcblxuICAgICAgICBmb3IgKGtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgICAgICAgICAgICAgIGlmICghZGVzY3JpcHRvciB8fCBkZXNjcmlwdG9yLndyaXRhYmxlIHx8IGRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gcHJvcGVydGllc1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXQgYSBuZXcgY2VsbCBlZGl0b3IuXG4gICAgICogQGRlc2MgVGhlIGNlbGwgZWRpdG9yIHRvIHVzZSBtdXN0IGJlIHJlZ2lzdGVyZWQgd2l0aCB0aGUga2V5IGluIHRoZSBjZWxsJ3MgYGVkaXRvcmAgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBUaGUgY2VsbCdzIGBmb3JtYXRgIHByb3BlcnR5IGlzIG1peGVkIGludG8gdGhlIHByb3ZpZGVkIGNlbGxFdmVudCBmb3IgcG9zc2libGUgb3ZlcnJpZGluZyBieSBkZXZlbG9wZXIncyBvdmVycmlkZSBvZiB7QGxpbmsgRGF0YU1vZGVsLnByb3RvdHlwZS5nZXRDZWxsRWRpdG9yQXR9IGJlZm9yZSBiZWluZyB1c2VkIGJ5IHtAbGluayBDZWxsRWRpdG9yfSB0byBwYXJzZSBhbmQgZm9ybWF0IHRoZSBjZWxsIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR9IGNlbGxFdmVudFxuICAgICAqXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZHxDZWxsRWRpdG9yfSBGYWxzeSB2YWx1ZSBtZWFucyBlaXRoZXIgbm8gZGVjbGFyZWQgY2VsbCBlZGl0b3IgX29yXyBpbnN0YW50aWF0aW9uIGFib3J0ZWQgYnkgZmFsc3kgcmV0dXJuIGZyb20gYGZpcmVSZXF1ZXN0Q2VsbEVkaXRgLlxuICAgICAqL1xuICAgIGdldENlbGxFZGl0b3JBdDogZnVuY3Rpb24oY2VsbEV2ZW50KSB7XG4gICAgICAgIHZhciBjb2x1bW5JbmRleCA9IHRoaXMuaW5kZXgsXG5cbiAgICAgICAgICAgIHJvd0luZGV4ID0gY2VsbEV2ZW50LmdyaWRDZWxsLnksXG5cbiAgICAgICAgICAgIGVkaXRvck5hbWUgPSBjZWxsRXZlbnQucHJvcGVydGllcy5lZGl0b3IsXG5cbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKGNlbGxFdmVudCwge1xuICAgICAgICAgICAgICAgIGZvcm1hdDoge1xuICAgICAgICAgICAgICAgICAgICAvLyBgb3B0aW9ucy5mb3JtYXRgIGlzIGEgY29weSBvZiB0aGUgY2VsbCdzIGBmb3JtYXRgIHByb3BlcnR5IHdoaWNoIGlzOlxuICAgICAgICAgICAgICAgICAgICAvLyAxLiBTdWJqZWN0IHRvIGFkanVzdG1lbnQgYnkgdGhlIGBnZXRDZWxsRWRpdG9yQXRgIG92ZXJyaWRlLlxuICAgICAgICAgICAgICAgICAgICAvLyAyLiBUaGVuIHVzZWQgYnkgdGhlIGNlbGwgZWRpdG9yIHRvIHJlZmVyZW5jZSB0aGUgcmVnaXN0ZXJlZCBsb2NhbGl6ZXIgKGRlZmF1bHRzIHRvICdzdHJpbmcnIGxvY2FsaXplcilcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIC8vIHNvIGNlbGwgZWRpdG9yIHdpbGwgY29weSBpdCB0byBzZWxmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjZWxsRXZlbnQucHJvcGVydGllcy5mb3JtYXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNlbGxFZGl0b3IgPSB0aGlzLmRhdGFNb2RlbC5nZXRDZWxsRWRpdG9yQXQoY29sdW1uSW5kZXgsIHJvd0luZGV4LCBlZGl0b3JOYW1lLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAoY2VsbEVkaXRvciAmJiAhY2VsbEVkaXRvci5ncmlkKSB7XG4gICAgICAgICAgICAvLyBjZWxsIGVkaXRvciByZXR1cm5lZCBidXQgbm90IGZ1bGx5IGluc3RhbnRpYXRlZCAoYWJvcnRlZCBieSBmYWxzeSByZXR1cm4gZnJvbSBmaXJlUmVxdWVzdENlbGxFZGl0KVxuICAgICAgICAgICAgY2VsbEVkaXRvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjZWxsRWRpdG9yO1xuICAgIH0sXG5cbiAgICBnZXRGb3JtYXR0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbG9jYWxpemVyTmFtZSA9IHRoaXMucHJvcGVydGllcy5mb3JtYXQ7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdyaWQubG9jYWxpemF0aW9uLmdldChsb2NhbGl6ZXJOYW1lKS5mb3JtYXQ7XG4gICAgfVxufTtcblxudmFyIFJFR0VYX0FSUk9XX0ZVTkMgPSAvXihcXCguKlxcKXxcXHcrKVxccyo9Pi87XG5cbi8qKlxuICogQ2FsY3VsYXRvcnMgYXJlIGZ1bmN0aW9ucy4gQ29sdW1uIGNhbGN1bGF0b3JzIGFyZSBzYXZlZCBpbiBgZ3JpZC5wcm9wZXJ0aWVzLmNhbGN1bGF0b3JzYCB1c2luZyB0aGUgZnVuY3Rpb24gbmFtZSBhcyBrZXkuIEFub255bW91cyBmdW5jdGlvbnMgdXNlIHRoZSBzdHJpbmdpZmllZCBmdW5jdGlvbiBpdHNlbGYgYXMgdGhlIGtleS4gVGhpcyBtYXkgc2VlbSBwb2ludGxlc3MsIGJ1dCB0aGlzIGFjaGlldmVzIHRoZSBvYmplY3RpdmUgaGVyZSB3aGljaCBpcyB0byBzaGFyZSBmdW5jdGlvbiBpbnN0YW5jZXMuXG4gKiBAdGhyb3dzIHtIeXBlcmdyaWRFcnJvcn0gVW5leHBlY3RlZCBpbnB1dC5cbiAqIEB0aHJvd3Mge0h5cGVyZ3JpZEVycm9yfSBBcnJvdyBmdW5jdGlvbiBub3QgcGVybWl0dGVkLlxuICogQHRocm93cyB7SHlwZXJncmlkRXJyb3J9IFVua25vd24gZnVuY3Rpb24uXG4gKiBAdGhpcyB7Q29sdW1ufVxuICogQHBhcmFtIHtmdW5jdGlvbnxzdHJpbmd9IGNhbGN1bGF0b3IgLSBPbmUgb2Y6XG4gKiAqIGNhbGN1bGF0b3IgZnVuY3Rpb25cbiAqICogc3RyaW5naWZpZWQgY2FsY3VsYXRvciBmdW5jdGlvbiB3aXRoIG9yIHdpdGhvdXQgZnVuY3Rpb24gbmFtZVxuICogKiBmdW5jdGlvbiBuYW1lIG9mIGEga25vd24gZnVuY3Rpb24gKGFscmVhZHkgaW4gYGNhbGN1bGF0b3JzYClcbiAqICogZmFsc3kgdmFsdWVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gU2hhcmVkIGNhbGN1bGF0b3IgaW5zdGFuY2Ugb3IgYHVuZGVmaW5lZGAgaWYgaW5wdXQgd2FzIGZhbHN5LlxuICovXG5mdW5jdGlvbiByZXNvbHZlQ2FsY3VsYXRvcihjYWxjdWxhdG9yKSB7XG4gICAgaWYgKCFjYWxjdWxhdG9yKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjYWxjdWxhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGN1bGF0b3IgPSBjYWxjdWxhdG9yLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY2FsY3VsYXRvciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEh5cGVyZ3JpZEVycm9yKCdFeHBlY3RlZCBmdW5jdGlvbiBPUiBzdHJpbmcgY29udGFpbmluZyBmdW5jdGlvbiBPUiBmdW5jdGlvbiBuYW1lIHRoZSBcIicgKyB0aGlzLm5hbWUgKyAnXCIgY29sdW1uIGNhbGN1bGF0b3IuJyk7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoZXMsIGtleSxcbiAgICAgICAgY2FsY3VsYXRvcnMgPSB0aGlzLmJlaGF2aW9yLmdyaWQucHJvcGVydGllcy5jYWxjdWxhdG9ycyB8fCAodGhpcy5iZWhhdmlvci5ncmlkLnByb3BlcnRpZXMuY2FsY3VsYXRvcnMgPSB7fSk7XG5cbiAgICBpZiAoL15cXHcrJC8udGVzdChjYWxjdWxhdG9yKSkge1xuICAgICAgICBrZXkgPSBjYWxjdWxhdG9yOyAvLyBqdXN0IGEgZnVuY3Rpb24gbmFtZVxuICAgICAgICBpZiAoIWNhbGN1bGF0b3JzW2tleV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBIeXBlcmdyaWRFcnJvcignVW5rbm93biBmdW5jdGlvbiBuYW1lIFwiJyArIGtleSArICdcIiBmb3IgXCInICsgdGhpcy5uYW1lICsgJ1wiIGNvbHVtbiBjYWxjdWxhdG9yLicpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2hlcyA9IGNhbGN1bGF0b3IubWF0Y2goL15mdW5jdGlvblxccyooXFx3KylcXCgvKTtcblxuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAga2V5ID0gbWF0Y2hlc1sxXTsgLy8gZnVuY3Rpb24gbmFtZSBleHRyYWN0ZWQgZnJvbSBzdHJpbmdpZmllZCBmdW5jdGlvblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gY2FsY3VsYXRvcjsgLy8gYW5vbnltb3VzIHN0cmluZ2lmaWVkIGZ1bmN0aW9uXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNhbGN1bGF0b3JzW2tleV0pIHsgLy8gbmVpdGhlciBhIHN0cmluZyBub3IgYSBmdW5jdGlvbiAocHJldmlvdWxzeSBmdW5jdGlvbmlmaWVkIHN0cmluZyk/XG4gICAgICAgICAgICBpZiAoUkVHRVhfQVJST1dfRlVOQy50ZXN0KGNhbGN1bGF0b3IpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEh5cGVyZ3JpZEVycm9yKCdBcnJvdyBmdW5jdGlvbiBub3QgcGVybWl0dGVkIGFzIGNvbHVtbiBjYWxjdWxhdG9yIChmb3IgY29sdW1uIFwiJyArIHRoaXMubmFtZSArICdcIikuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxjdWxhdG9yc1trZXldID0gY2FsY3VsYXRvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhbGN1bGF0b3JzW2tleV0gPSB0b0Z1bmN0aW9uKGNhbGN1bGF0b3JzW2tleV0pOyAvLyBmdW5jdGlvbmlmaWVzIGV4aXN0aW5nIGBjYWxjdWxhdG9yc2AgZW50cmllcyBhcyB3ZWxsIGFzIG5ldyBlbnRyaWVzXG5cbiAgICByZXR1cm4gY2FsY3VsYXRvcnNba2V5XTtcbn1cblxuQ29sdW1uLnByb3RvdHlwZS5taXhJbihyZXF1aXJlKCcuL2NlbGxQcm9wZXJ0aWVzJykuY29sdW1uTWl4aW4pO1xuQ29sdW1uLnByb3RvdHlwZS5taXhJbihyZXF1aXJlKCcuL2NvbHVtblByb3BlcnRpZXMnKS5taXhpbik7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmVoYXZpb3IgPSByZXF1aXJlKCcuL0JlaGF2aW9yJyk7XG5cbi8qKiBAbmFtZSBEYXRhU291cmNlXG4gKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gKiBAZGVmYXVsdCByZXF1aXJlKCdkYXRhc2F1ci1sb2NhbCcpXG4gKiBAc3VtbWFyeSBEZWZhdWx0IGRhdGEgc291cmNlLlxuICogQGRlc2MgSWYgZGVmaW5lZCwgd2lsbCBiZSB1c2VkIGFzIGEgZGVmYXVsdCBkYXRhIHNvdXJjZSBmb3IgbmV3bHkgaW5zdGFudGlhdGVkIGBIeXBlcmdyaWRgIG9iamVjdHMgd2l0aG91dCBgRGF0YVNvdXJjZWAgb3IgYGRhdGFTb3VyY2VgIG9wdGlvbnMgc3BlY2lmaWVkLiBTY2hlZHVsZWQgZm9yIHJlbW92YWwgaW4gbmV4dCB2ZXJzaW9uICh2NCkuXG4gKi9cbnZhciBEZWZhdWx0RGF0YU1vZGVsID0gcmVxdWlyZSgnLi4vRGF0YXNhdXJMb2NhbCcpO1xuXG52YXIgZGVjb3JhdG9ycyA9IHJlcXVpcmUoJy4vZGF0YU1vZGVsL2RlY29yYXRvcnMnKTtcblxuY29uc3QgR1JBTkRfVE9UQUwgPSAnJCRncmFuZF90b3RhbCc7XG5cblxuLyoqXG4gKiBUaGlzIGNsYXNzIG1pbWljcyB0aGUge0BsaW5rIGRhdGFNb2RlbEFQSX0uXG4gKiA+IFRoaXMgY29uc3RydWN0b3IgKGFjdHVhbGx5IHtAbGluayBMb2NhbCNpbml0aWFsaXplfSkgd2lsbCBiZSBjYWxsZWQgdXBvbiBpbnN0YW50aWF0aW9uIG9mIHRoaXMgY2xhc3Mgb3Igb2YgYW55IGNsYXNzIHRoYXQgZXh0ZW5kcyBmcm9tIHRoaXMgY2xhc3MuIFNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2pvbmVpdC9leHRlbmQtbWV8ZXh0ZW5kLW1lfSBmb3IgbW9yZSBpbmZvLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBCZWhhdmlvclxuICovXG52YXIgTG9jYWwgPSBCZWhhdmlvci5leHRlbmQoJ0xvY2FsJywge1xuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZ3JpZCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNldERhdGEob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBMb2NhbCNcbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGNvbHVtbnMgYmFzZWQgb24gb2xkIHZhbHVlIG9mIGdyaWQuY29sdW1uc1xuICAgICAqL1xuICAgIGNyZWF0ZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBvbGRDb2x1bW5zID0gdGhpcy5jb2x1bW5zO1xuICAgICAgICBjb25zdCBvbGRBbGxDb2x1bW5zID0gdGhpcy5hbGxDb2x1bW5zO1xuXG4gICAgICAgIEJlaGF2aW9yLnByb3RvdHlwZS5jcmVhdGVDb2x1bW5zLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5zY2hlbWEuZm9yRWFjaCgoY29sdW1uU2NoZW1hLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmluZEZ1bmN0aW9uID0gZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjLnByb3BlcnRpZXMuaW5kZXggPT09IGluZGV4ICYmXG4gICAgICAgICAgICAgICAgICAgIGMucHJvcGVydGllcy5uYW1lID09PSBjb2x1bW5TY2hlbWEubmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICBjLnByb3BlcnRpZXMuY2FsY3VsYXRvciA9PT0gY29sdW1uU2NoZW1hLmNhbGN1bGF0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgYy5jb2xEZWYgPT09IGNvbHVtblNjaGVtYS5jb2xEZWY7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb2xkQ29sdW1uID0gb2xkQWxsQ29sdW1ucy5maW5kKGZpbmRGdW5jdGlvbikgfHwgb2xkQ29sdW1ucy5maW5kKGZpbmRGdW5jdGlvbik7XG4gICAgICAgICAgICBjb25zdCBvbGRDb2x1bW5Db2xkRGVmID0gb2xkQWxsQ29sdW1ucy5maW5kKGMgPT4gYy5jb2xEZWYgJiYgYy5jb2xEZWYgPT09IGNvbHVtblNjaGVtYS5jb2xEZWYpIHx8IG9sZENvbHVtbnMuZmluZChjID0+IGMuY29sRGVmID09PSBjb2x1bW5TY2hlbWEuY29sRGVmKTtcblxuICAgICAgICAgICAgaWYgKG9sZENvbHVtbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NvbHVtbiA9IHRoaXMuYWRkQ29sdW1uKG9sZENvbHVtbi5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IG5ld0NvbHVtbi5wcm9wZXJ0aWVzO1xuXG4gICAgICAgICAgICAgICAgLy8gZGlzYWJsZSByZXNpemluZyBmb3Igb2xkIHJlc2l6ZWQgY29sdW1uc1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gZGF0YSB3YXMgYWRkZWQgdG8gZXhpc3RlZCBhcnJheSBvZiBkYXRhXG4gICAgICAgICAgICAgICAgaWYgKHByb3BzLndpZHRoID09PSBwcm9wcy5wcmVmZXJyZWRXaWR0aCAmJiBwcm9wcy5jb2x1bW5BdXRvc2l6aW5nICYmIHByb3BzLmNvbHVtbkF1dG9zaXplZCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5jb2x1bW5BdXRvc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDb2x1bW4gPSB0aGlzLmFkZENvbHVtbih7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiBjb2x1bW5TY2hlbWEuaGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdG9yOiBjb2x1bW5TY2hlbWEuY2FsY3VsYXRvcixcbiAgICAgICAgICAgICAgICAgICAgY29sRGVmOiBjb2x1bW5TY2hlbWEuY29sRGVmXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHdpZHRoIGZyb20gcHJldmlvdXMgc2NoZW1hIHdoZW4gZGF0YSBqdXN0IHJlZnJlc2hlZC5cbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG5lZWRlZCBiZWNhdXNlIG9mIGFsbW9zdCB0b3RhbCByZWZyZXNoIG9mIGdyaWRcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uU2NoZW1hLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obmV3Q29sdW1uLnByb3BlcnRpZXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb2x1bW5TY2hlbWEud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5BdXRvc2l6aW5nOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9sZENvbHVtbkNvbGREZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBvbGRDb2x1bW5Db2xkRGVmLnByb3BlcnRpZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZSByZXNpemluZyBmb3Igb2xkIHJlc2l6ZWQgY29sdW1uc1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGRhdGEgd2FzIGFkZGVkIHRvIGV4aXN0ZWQgYXJyYXkgb2YgZGF0YVxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG5ld0NvbHVtbi5wcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJyZWRXaWR0aDogcHJvcHMucHJlZmVycmVkV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5BdXRvc2l6aW5nOiBwcm9wcy5jb2x1bW5BdXRvc2l6aW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uQXV0b3NpemVkOiBwcm9wcy5jb2x1bW5BdXRvc2l6ZWQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5TY2hlbWEuZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbHVtbi5wcm9wZXJ0aWVzLmZvcm1hdCA9IG5ld0NvbHVtbi5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb2x1bW4uc2NoZW1hLmZvcm1hdCA9IG5ld0NvbHVtbi5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmV3Q29sdW1uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IGNvbHVtblNjaGVtYS5mb3JtYXR0ZXIsIC8vIGNhbGxlZCBmb3IgcmVuZGVyIHZpZXdcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlOiB2YWx1ZSA9PiB2YWx1ZSwgLy8gY2FsbGVkIGZvciByZW5kZXIgdmFsdWUgaW4gZWRpdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU6ICdlbidcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmlkLmxvY2FsaXphdGlvbi5hZGQobmV3Q29sdW1uLm5hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIFsnaGFsaWduJywgJ21heFdpZHRoJywgJ2NlbGxDb250ZXh0TWVudSddLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW5TY2hlbWFba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29sdW1uLnByb3BlcnRpZXNba2V5XSA9IGNvbHVtblNjaGVtYVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgTG9jYWwjXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGN1bGF0ZSBjb2x1bW4gcHJlZmVyZWQgc2l6ZSBiYXNlZCBvbiBjZWxscyBjb250ZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ8b2JqZWN0fSB4T3JDb2x1bW4gLSBjb2x1bW4gb2JqZWN0IG9yIGluZGV4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZSAtIGlmIHRydWUsIHdpZHRoIHdpbGwgYmUgY2hhbmdlZCBldmVuIGlmIGNvbHVtbiBhdXRvc2l6aW5nIGRpc2FibGVkXG4gICAgICovXG4gICAgZml0Q29sdW1uOiBmdW5jdGlvbih4T3JDb2x1bW4sIGZvcmNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgeE9yQ29sdW1uICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgeE9yQ29sdW1uID0gdGhpcy5nZXRDb2x1bW4oeE9yQ29sdW1uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IHhPckNvbHVtbjtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgICAgICBjb25zdCBnYyA9IHRoaXMuZ3JpZC5jYW52YXMuZ2M7XG5cbiAgICAgICAgY29uc3QgcHJvcHMgPSBjb2x1bW4ucHJvcGVydGllcztcblxuICAgICAgICBsZXQgd2lkdGggPSBjb2x1bW4ud2lkdGggfHwgcHJvcHMuZGVmYXVsdENvbHVtbldpZHRoO1xuXG4gICAgICAgIC8vIGdldCBtYXggd2lkdGggYmFzZWQgb2ZcbiAgICAgICAgZGF0YS5mb3JFYWNoKChkLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsID0gY29sdW1uLmdldFZhbHVlKGkpO1xuICAgICAgICAgICAgY29uc3QgeyBzY2hlbWEgfSA9IGNvbHVtbjtcbiAgICAgICAgICAgIGlmICh2YWwgJiYgKHR5cGVvZiB2YWwgIT09ICdvYmplY3QnIHx8IHZhbCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRocyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVByb3BzID0gdGhpcy5nZXRSb3dQcm9wZXJ0aWVzKGkpIHx8IHByb3BzO1xuICAgICAgICAgICAgICAgIHdpZHRocy5jZWxsUGFkZGluZ1JpZ2h0ID0gcHJvcHMuY2VsbFBhZGRpbmdSaWdodDtcblxuICAgICAgICAgICAgICAgIGlmIChkYXRhUHJvcHMuc2hvd0NlbGxDb250ZXh0TWVudUljb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZ2MuY2FjaGUuZm9udCA9IHByb3BzLmNvbnRleHRNZW51SWNvbkZvbnQ7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRocy5zaG93Q2VsbENvbnRleHRNZW51SWNvbiA9IHByb3BzLmNvbnRleHRNZW51QnV0dG9uSWNvblByZWZlcmVkV2lkdGggKyAyICogcHJvcHMuY29udGV4dE1lbnVCdXR0b25QYWRkaW5nICsgcHJvcHMuY29udGV4dE1lbnVMZWZ0U3BhY2VUb0N1dFRleHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFQcm9wcy5zaG93Q29sdW1uVHlwZSAmJiBzY2hlbWEuY29sVHlwZVNpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGhzLmNvbFR5cGVTaWduID0gKHdpZHRocy5zaG93Q2VsbENvbnRleHRNZW51SWNvbiB8fCAwKSArIHdpZHRocy5jZWxsUGFkZGluZ1JpZ2h0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzY2hlbWEgJiYgc2NoZW1hLmhlYWRlclByZWZpeCAmJiBkYXRhUHJvcHMuaGVhZGVyUm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGdjLmNhY2hlLmZvbnQgPSBwcm9wcy5jb2x1bW5UaXRsZVByZWZpeEZvbnQ7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRocy5oZWFkZXJQcmVmaXggPSBnYy5nZXRUZXh0V2lkdGgoc2NoZW1hLmhlYWRlclByZWZpeCkgKyBwcm9wcy5jb2x1bW5UaXRsZVByZWZpeFJpZ2h0U3BhY2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5oYXNFcnJvciAmJiBkYXRhUHJvcHMuaGVhZGVyUm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGdjLmNhY2hlLmZvbnQgPSBwcm9wcy5lcnJvckljb25Gb250O1xuICAgICAgICAgICAgICAgICAgICB3aWR0aHMuaGFzRXJyb3IgPSBnYy5nZXRUZXh0V2lkdGgocHJvcHMuZXJyb3JJY29uVW5pY29kZUNoYXIpICsgcHJvcHMuY29sdW1uVGl0bGVQcmVmaXhSaWdodFNwYWNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4ubmFtZS5zdGFydHNXaXRoKCckJGFnZ3JlZ2F0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJlZUxldmVsID0gdGhpcy5nZXRSb3dUcmVlTGV2ZWwoZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyZWVPZmZzZXQgPSB0cmVlTGV2ZWwgPyB0aGlzLmdldFJvd1RyZWVMZXZlbChkKSAqIHByb3BzLmFnZ3JlZ2F0aW9uR3JvdXBUcmVlTGV2ZWxPZmZzZXQgOiAwO1xuICAgICAgICAgICAgICAgICAgICB3aWR0aHMudHJlZU9mZnNldCA9IHRyZWVPZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWdncmVnYXRpb25Db3VudCA9IHRoaXMuZ2V0QWdncmVnYXRpb25DaGlsZENvdW50KGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWdncmVnYXRpb25Db3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdjLmNhY2hlLmZvbnQgPSBwcm9wcy5jZWxsVmFsdWVQb3N0Zml4Rm9udDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRocy5hZ2dyZWdhdGlvbkNvdW50ID0gcHJvcHMuY2VsbFBhZGRpbmdMZWZ0ICsgdHJlZU9mZnNldCArIGdjLmdldFRleHRXaWR0aChgKCR7YWdncmVnYXRpb25Db3VudH0pYCkgKyBwcm9wcy5jZWxsVmFsdWVQb3N0Zml4TGVmdE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRXhwYW5kYWJsZVJvdyhkKSB8fCB0aGlzLmRhdGFNb2RlbC5nZXRIYXNDaGlsZENvbHVtbnNGcm9tQ2VsbChjb2x1bW4uaW5kZXgsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlUHJlZml4ID0gcHJvcHNbYGFnZ3JlZ2F0aW9uR3JvdXBFeHBhbmRJY29uJHsgdGhpcy5pc1Jvd0V4cGFuZGVkKGQpID8gJ0NvbGxhcHNlZCcgOiAnRXhwYW5kZWQnfUNoYXJgXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlUHJlZml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnYy5jYWNoZS5mb250ID0gcHJvcHMuYWdncmVnYXRpb25Hcm91cEV4cGFuZEljb25Gb250O1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGhzLnZhbHVlUHJlZml4ID0gZ2MuZ2V0VGV4dFdpZHRoKHZhbHVlUHJlZml4KSArIHByb3BzLmNvbHVtblRpdGxlUHJlZml4UmlnaHRTcGFjZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gY29sdW1uLmdldENvdW50KGkpO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGdjLmNhY2hlLmZvbnQgPSBwcm9wcy5jZWxsVmFsdWVQb3N0Zml4Rm9udDtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGhzLnZhbHVlUG9zdGZpeCA9IGdjLmdldFRleHRXaWR0aChgKCR7Y291bnR9KWApICsgcHJvcHMuY2VsbFZhbHVlUG9zdGZpeExlZnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZ2MuY2FjaGUuZm9udCA9IGRhdGFQcm9wcy5mb250O1xuICAgICAgICAgICAgICAgIHdpZHRocy52YWwgPSBnYy5nZXRUZXh0V2lkdGgodGhpcy5ncmlkLmZvcm1hdFZhbHVlKGNvbHVtbi5uYW1lLCB2YWwsIGRhdGFQcm9wcy5oZWFkZXJSb3cpKSArIHByb3BzLmNlbGxQYWRkaW5nTGVmdDtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd3aWR0aHMnLCB2YWwsIHdpZHRocyk7XG4gICAgICAgICAgICAgICAgbGV0IHRleHRXaWR0aCA9IE9iamVjdC52YWx1ZXMod2lkdGhzKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndGV4dFdpZHRoJywgdGV4dFdpZHRoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbHNwYW4gPSB0aGlzLmRhdGFNb2RlbC5nZXRDb2xzcGFuKGNvbHVtbi5pbmRleCwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHNwYW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRXaWR0aCA9IHRleHRXaWR0aCAvIChjb2xzcGFuICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBjb2x1bW4uaW5kZXg7IGkgPD0gY29sdW1uLmluZGV4ICsgY29sc3BhbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldENvbHVtbihpKS53aWR0aCA9IHRleHRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0ZXh0V2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHRleHRXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh3aWR0aCA+IHByb3BzLm1heFdpZHRoKSB7XG4gICAgICAgICAgICB3aWR0aCA9IHByb3BzLm1heFdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcHMucHJlZmVycmVkV2lkdGggPSBNYXRoLmNlaWwod2lkdGgpO1xuXG4gICAgICAgIGlmIChmb3JjZSB8fCBwcm9wcy5jb2x1bW5BdXRvc2l6aW5nKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMucHJlZmVycmVkV2lkdGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uLnNldFdpZHRoKHByb3BzLnByZWZlcnJlZFdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgTG9jYWwjXG4gICAgICogQGRlc2NyaXB0aW9uIFJlY2FsY3VsYXRlIGFsbCBjb2x1bW5zIHByZWZlcmVkIHNpemVzXG4gICAgICogQHJldHVybiB7YXJyYXl9IC0gYWZmZWN0ZWQgY29sdW1uc1xuICAgICAqL1xuICAgIGZpdENvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBnYyA9IHRoaXMuZ3JpZC5jYW52YXMuZ2M7XG4gICAgICAgIGNvbnN0IG9sZEZvbnQgPSBnYy5jYWNoZS5mb250O1xuICAgICAgICB0aGlzLmFsbENvbHVtbnMuZm9yRWFjaChjID0+IHRoaXMuZml0Q29sdW1uKGMpKTtcbiAgICAgICAgZ2MuY2FjaGUuZm9udCA9IG9sZEZvbnQ7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsQ29sdW1ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIExvY2FsI1xuICAgICAqIEBkZXNjcmlwdGlvbiBGaW5kIGNvbHVtbnMgYnkgZ2l2ZW4gZ3JvdXAgSWQgYW5kIHJlY2FsY3VsYXRlIHByZWZlcmVkIHNpemUgZm9yIGVhY2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXBJZCAtIGNvbHVtbiBncm91cCBpZFxuICAgICAqIEByZXR1cm4ge2FycmF5fSAtIGFmZmVjdGVkIGNvbHVtbnNcbiAgICAgKi9cbiAgICBmaXRDb2x1bW5zR3JvdXA6IGZ1bmN0aW9uKGdyb3VwSWQpIHtcbiAgICAgICAgY29uc3QgY29sdW1uc1RvRml0ID0gdGhpcy5hbGxDb2x1bW5zLmZpbHRlcihhYyA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYWMuc2NoZW1hICYmIGFjLnNjaGVtYS50b3BHcm91cHNJZHMgJiYgYWMuc2NoZW1hLnRvcEdyb3Vwc0lkcy5pbmNsdWRlcyhncm91cElkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGNvbHVtbnNUb0ZpdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBnYyA9IHRoaXMuZ3JpZC5jYW52YXMuZ2M7XG4gICAgICAgICAgICBjb25zdCBvbGRGb250ID0gZ2MuY2FjaGUuZm9udDtcbiAgICAgICAgICAgIGNvbHVtbnNUb0ZpdC5mb3JFYWNoKGMgPT4gdGhpcy5maXRDb2x1bW4oYykpO1xuICAgICAgICAgICAgZ2MuY2FjaGUuZm9udCA9IG9sZEZvbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sdW1uc1RvRml0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgTG9jYWwjXG4gICAgICogQGRlc2NyaXB0aW9uIFNldCB0aGUgaGVhZGVyIGxhYmVscy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfG9iamVjdH0gaGVhZGVycyAtIFRoZSBoZWFkZXIgbGFiZWxzLiBPbmUgb2Y6XG4gICAgICogKiBfSWYgYW4gYXJyYXk6XyBNdXN0IGNvbnRhaW4gYWxsIGhlYWRlcnMgaW4gY29sdW1uIG9yZGVyLlxuICAgICAqICogX0lmIGEgaGFzaDpfIE1heSBjb250YWluIGFueSBoZWFkZXJzLCBrZXllZCBieSBmaWVsZCBuYW1lLCBpbiBhbnkgb3JkZXIuXG4gICAgICovXG4gICAgc2V0SGVhZGVyczogZnVuY3Rpb24oaGVhZGVycykge1xuICAgICAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAvLyBSZXNldCBhbGwgaGVhZGVyc1xuICAgICAgICAgICAgdmFyIGFsbENvbHVtbnMgPSB0aGlzLmFsbENvbHVtbnM7XG4gICAgICAgICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGFsbENvbHVtbnNbaW5kZXhdLmhlYWRlciA9IGhlYWRlcjsgLy8gc2V0dGVyIHVwZGF0ZXMgaGVhZGVyIGluIGJvdGggY29sdW1uIGFuZCBkYXRhIHNvdXJjZSBvYmplY3RzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaGVhZGVycyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIEFkanVzdCBqdXN0IHRoZSBoZWFkZXJzIGluIHRoZSBoYXNoXG4gICAgICAgICAgICB0aGlzLmFsbENvbHVtbnMuZm9yRWFjaChmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyc1tjb2x1bW4ubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLmhlYWRlciA9IGhlYWRlcnNbY29sdW1uLm5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBMb2NhbCNcbiAgICAgKiBAc3VtbWFyeSBTZXQgZ3JpZCBkYXRhLlxuICAgICAqIEBkZXNjIEV4aXRzIHdpdGhvdXQgZG9pbmcgYW55dGhpbmcgaWYgbm8gZGF0YSAoYGRhdGFSb3dzYCB1bmRlZmluZWQgb3Igb21pdHRlZCBhbmQgYG9wdGlvbnMuZGF0YWAgdW5kZWZpbmVkKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb258b2JqZWN0W119IFtkYXRhUm93cz1vcHRpb25zLmRhdGFdIC0gQXJyYXkgb2YgdW5pZm9ybSBkYXRhIHJvdyBvYmplY3RzIG9yIGZ1bmN0aW9uIHJldHVybmluZyBzYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIF8oUHJvbW90ZWQgdG8gZmlyc3QgYXJndW1lbnQgcG9zaXRpb24gd2hlbiBgZGF0YVJvd3NgIG9taXR0ZWQuKV9cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb258b2JqZWN0W119IFtvcHRpb25zLmRhdGFdIC0gUGFzc2VkIHRvIGJlaGF2aW9yIGNvbnN0cnVjdG9yLiBNYXkgYmU6XG4gICAgICogKiBBbiBhcnJheSBvZiBjb25ncnVlbnQgcmF3IGRhdGEgb2JqZWN0c1xuICAgICAqICogQSBmdW5jdGlvbiByZXR1cm5pbmcgc2FtZVxuICAgICAqICogT21pdCBmb3Igbm9uLWxvY2FsIGRhdGFzb3VyY2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufG1lbnVJdGVtW119IFtvcHRpb25zLnNjaGVtYV0gLSBQYXNzZWQgdG8gYmVoYXZpb3IgY29uc3RydWN0b3IuIE1heSBiZTpcbiAgICAgKiAqIEEgc2NoZW1hIGFycmF5XG4gICAgICogKiBBIGZ1bmN0aW9uIHJldHVybmluZyBzYW1lLiBDYWxsZWQgYXQgZmlsdGVyIHJlc2V0IHRpbWUgd2l0aCBiZWhhdmlvciBhcyBjb250ZXh0LlxuICAgICAqICogT21pdCB0byBhbGxvdyB0aGUgZGF0YSBtb2RlbCB0byBnZW5lcmF0ZSBhIGJhc2ljIHNjaGVtYSBmcm9tIGl0cyBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hcHBseT10cnVlXSBBcHBseSBkYXRhIHRyYW5zZm9ybWF0aW9ucyB0byB0aGUgbmV3IGRhdGEuXG4gICAgICovXG4gICAgc2V0RGF0YTogZnVuY3Rpb24oZGF0YVJvd3MsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEoQXJyYXkuaXNBcnJheShkYXRhUm93cykgfHwgdHlwZW9mIGRhdGFSb3dzID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGRhdGFSb3dzO1xuICAgICAgICAgICAgZGF0YVJvd3MgPSBvcHRpb25zICYmIG9wdGlvbnMuZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFSb3dzID0gdGhpcy51bndyYXAoZGF0YVJvd3MpO1xuXG4gICAgICAgIGlmIChkYXRhUm93cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YVJvd3MpKSB7XG4gICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgZGF0YSB0byBiZSBhbiBhcnJheSAob2YgZGF0YSByb3cgb2JqZWN0cykuJztcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHZhciBncmlkID0gdGhpcy5ncmlkLFxuICAgICAgICAgICAgc2NoZW1hID0gdGhpcy51bndyYXAob3B0aW9ucy5zY2hlbWEpLCAvLyAqYWx3YXlzKiBkZWZpbmUgYSBuZXcgc2NoZW1hIG9uIHJlc2V0XG4gICAgICAgICAgICBzY2hlbWFDaGFuZ2VkID0gc2NoZW1hIHx8ICF0aGlzLnN1YmdyaWRzLmxvb2t1cC5kYXRhLmdldENvbHVtbkNvdW50KCksIC8vIHNjaGVtYSB3aWxsIGNoYW5nZSBpZiBhIG5ldyBzY2hlbWEgd2FzIHByb3ZpZGVkIE9SIGRhdGEgbW9kZWwgaGFzIGFuIGVtcHR5IHNjaGVtYSBub3csIHdoaWNoIHRyaWdnZXJzIHNjaGVtYSBnZW5lcmF0aW9uIG9uIHNldERhdGEgYmVsb3dcbiAgICAgICAgICAgIHJlaW5kZXggPSBvcHRpb25zLmFwcGx5ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5hcHBseTsgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuXG4gICAgICAgIC8vIGNvcHkgd2lkdGhzIGZyb20gb2xkIHNjaGVtYVxuICAgICAgICBpZiAoc2NoZW1hQ2hhbmdlZCAmJiB0aGlzLnNjaGVtYU9sZCAmJiBzY2hlbWEpIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWFPbGQgPSB0aGlzLnNjaGVtYU9sZDtcbiAgICAgICAgICAgIHNjaGVtYS5mb3JFYWNoKGZ1bmN0aW9uKGNvbHVtblNjaGVtYSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hT2xkW2luZGV4XSAmJiBpbmRleCA9PT0gc2NoZW1hT2xkW2luZGV4XS5pbmRleCAmJiBjb2x1bW5TY2hlbWEubmFtZSA9PT0gc2NoZW1hT2xkW2luZGV4XS5uYW1lICYmIHNjaGVtYU9sZFtpbmRleF0ud2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uU2NoZW1hLndpZHRoID0gc2NoZW1hT2xkW2luZGV4XS53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluZm9ybSBpbnRlcmVzdGVkIGRhdGEgbW9kZWxzIG9mIGRhdGEuXG4gICAgICAgIHRoaXMuc3ViZ3JpZHMuZm9yRWFjaChmdW5jdGlvbihkYXRhTW9kZWwpIHtcbiAgICAgICAgICAgIGRhdGFNb2RlbC5zZXREYXRhKGRhdGFSb3dzLCBzY2hlbWEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZ3JpZC5jZWxsRWRpdG9yKSB7XG4gICAgICAgICAgICBncmlkLmNlbGxFZGl0b3IuY2FuY2VsRWRpdGluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMucmVpbmRleCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjaGVtYUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQ29sdW1ucygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaGVja0ZvckVycm9ycygpO1xuXG4gICAgICAgIGdyaWQuYWxsb3dFdmVudHModGhpcy5nZXRSb3dDb3VudCgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIExvY2FsI1xuICAgICAqIEBzdW1tYXJ5IEFkZCBncmlkIGRhdGEuXG4gICAgICogQGRlc2MgRXhpdHMgd2l0aG91dCBkb2luZyBhbnl0aGluZyBpZiBubyBkYXRhIChgZGF0YVJvd3NgIHVuZGVmaW5lZCBvciBvbWl0dGVkIGFuZCBgb3B0aW9ucy5kYXRhYCB1bmRlZmluZWQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbnxvYmplY3RbXX0gW2RhdGFSb3dzPW9wdGlvbnMuZGF0YV0gLSBBcnJheSBvZiB1bmlmb3JtIGRhdGEgcm93IG9iamVjdHMgb3IgZnVuY3Rpb24gcmV0dXJuaW5nIHNhbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gXyhQcm9tb3RlZCB0byBmaXJzdCBhcmd1bWVudCBwb3NpdGlvbiB3aGVuIGBkYXRhUm93c2Agb21pdHRlZC4pX1xuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbnxvYmplY3RbXX0gW29wdGlvbnMuZGF0YV0gLSBQYXNzZWQgdG8gYmVoYXZpb3IgY29uc3RydWN0b3IuIE1heSBiZTpcbiAgICAgKiAqIEFuIGFycmF5IG9mIGNvbmdydWVudCByYXcgZGF0YSBvYmplY3RzXG4gICAgICogKiBBIGZ1bmN0aW9uIHJldHVybmluZyBzYW1lXG4gICAgICogKiBPbWl0IGZvciBub24tbG9jYWwgZGF0YXNvdXJjZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb258bWVudUl0ZW1bXX0gW29wdGlvbnMuc2NoZW1hXSAtIFBhc3NlZCB0byBiZWhhdmlvciBjb25zdHJ1Y3Rvci4gTWF5IGJlOlxuICAgICAqICogQSBzY2hlbWEgYXJyYXlcbiAgICAgKiAqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHNhbWUuIENhbGxlZCBhdCBmaWx0ZXIgcmVzZXQgdGltZSB3aXRoIGJlaGF2aW9yIGFzIGNvbnRleHQuXG4gICAgICogKiBPbWl0IHRvIGFsbG93IHRoZSBkYXRhIG1vZGVsIHRvIGdlbmVyYXRlIGEgYmFzaWMgc2NoZW1hIGZyb20gaXRzIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFwcGx5PXRydWVdIEFwcGx5IGRhdGEgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSBuZXcgZGF0YS5cbiAgICAgKi9cbiAgICBhZGREYXRhOiBmdW5jdGlvbihkYXRhUm93cywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIShBcnJheS5pc0FycmF5KGRhdGFSb3dzKSB8fCB0eXBlb2YgZGF0YVJvd3MgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gZGF0YVJvd3M7XG4gICAgICAgICAgICBkYXRhUm93cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVJvd3MgPSB0aGlzLnVud3JhcChkYXRhUm93cyk7XG5cbiAgICAgICAgaWYgKGRhdGFSb3dzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhUm93cykpIHtcbiAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCBkYXRhIHRvIGJlIGFuIGFycmF5IChvZiBkYXRhIHJvdyBvYmplY3RzKS4nO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdmFyIGdyaWQgPSB0aGlzLmdyaWQsXG4gICAgICAgICAgICBzY2hlbWEgPSB0aGlzLnVud3JhcChvcHRpb25zLnNjaGVtYSksIC8vICphbHdheXMqIGRlZmluZSBhIG5ldyBzY2hlbWEgb24gcmVzZXRcbiAgICAgICAgICAgIHNjaGVtYUNoYW5nZWQgPSBzY2hlbWEgfHwgIXRoaXMuc3ViZ3JpZHMubG9va3VwLmRhdGEuZ2V0Q29sdW1uQ291bnQoKSwgLy8gc2NoZW1hIHdpbGwgY2hhbmdlIGlmIGEgbmV3IHNjaGVtYSB3YXMgcHJvdmlkZWQgT1IgZGF0YSBtb2RlbCBoYXMgYW4gZW1wdHkgc2NoZW1hIG5vdywgd2hpY2ggdHJpZ2dlcnMgc2NoZW1hIGdlbmVyYXRpb24gb24gc2V0RGF0YSBiZWxvd1xuICAgICAgICAgICAgcmVpbmRleCA9IG9wdGlvbnMuYXBwbHkgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmFwcGx5OyAvLyBkZWZhdWx0cyB0byB0cnVlXG5cbiAgICAgICAgLy8gSW5mb3JtIGludGVyZXN0ZWQgZGF0YSBtb2RlbHMgb2YgZGF0YS5cbiAgICAgICAgdGhpcy5zdWJncmlkcy5mb3JFYWNoKGZ1bmN0aW9uKGRhdGFNb2RlbCkge1xuICAgICAgICAgICAgaWYgKGRhdGFNb2RlbC5hZGREYXRhKSB7XG4gICAgICAgICAgICAgICAgZGF0YU1vZGVsLmFkZERhdGEoZGF0YVJvd3MsIHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChncmlkLmNlbGxFZGl0b3IpIHtcbiAgICAgICAgICAgIGdyaWQuY2VsbEVkaXRvci5jYW5jZWxFZGl0aW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5yZWluZGV4KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2NoZW1hQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVDb2x1bW5zKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNoZWNrRm9yRXJyb3JzKCk7XG5cbiAgICAgICAgZ3JpZC5hbGxvd0V2ZW50cyh0aGlzLmdldFJvd0NvdW50KCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgTG9jYWwjXG4gICAgICogQGRlc2NyaXB0aW9uIEdldCBlcnJvcnMgc3VtbWFyeSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gZXJyb3JzIHN1bW1hcnlcbiAgICAgKi9cbiAgICBnZXRDb2x1bW5zRXJyb3JzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgTG9jYWwjXG4gICAgICogQGRlc2NyaXB0aW9uIENoZWNrIGdyaWQgZGF0YSBlcnJvcnMsIGFuZCBmaWxsIFwiZXJyb3JzXCIgb2JqZWN0IHVzaW5nIGZvdW5kIGVycm9ycyBkYXRhXG4gICAgICovXG4gICAgY2hlY2tGb3JFcnJvcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmVycm9ycyA9IHt9O1xuXG4gICAgICAgIHRoaXMuZ2V0RGF0YSgpLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHJvdykuZm9yRWFjaChjb2x1bW5OYW1lID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJvd1tjb2x1bW5OYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS50eXBlID09PSAnRVJST1InKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5lcnJvcnNbY29sdW1uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzW2NvbHVtbk5hbWVdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcnNbY29sdW1uTmFtZV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZXJyb3JDb3VudCA9IE9iamVjdC5rZXlzKHRoaXMuZXJyb3JzKS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHRoaXMuZXJyb3JDb3VudCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5lcnJvcnMpLmZvckVhY2goY29sdW1uTmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5ncmlkLmdldENvbHVtbkJ5TmFtZShjb2x1bW5OYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi5lcnJvckNvdW50ID0gdGhpcy5lcnJvcnNbY29sdW1uTmFtZV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4uZmlyc3RFcnJvciA9IHRoaXMuZXJyb3JzW2NvbHVtbk5hbWVdWzBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbERlZiA9IGNvbHVtbi5jb2xEZWY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xEZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbERlZi5lcnJvckNvdW50ID0gdGhpcy5lcnJvcnNbY29sdW1uTmFtZV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGRhdGEgbW9kZWxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtkYXRhTW9kZWxBUEl9IFtvcHRpb25zLmRhdGFNb2RlbF0gLSBBIGZ1bGx5IGluc3RhbnRpYXRlZCBkYXRhIG1vZGVsIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5EYXRhTW9kZWw9cmVxdWlyZSgnZGF0YXNhdXItbG9jYWwnKV0gLSBEYXRhIG1vZGVsIHdpbGwgYmUgaW5zdGFudGlhdGVkIGZyb20gdGhpcyBjb25zdHJ1Y3RvciB1bmxlc3MgYG9wdGlvbnMuZGF0YU1vZGVsYCB3YXMgZ2l2ZW4uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZGF0YSBtb2RlbCBoYXMgY2hhbmdlZC5cbiAgICAgKiBAbWVtYmVyT2YgTG9jYWwjXG4gICAgICovXG4gICAgZ2V0TmV3RGF0YU1vZGVsOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBuZXdEYXRhTW9kZWw7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZGF0YU1vZGVsKSB7XG4gICAgICAgICAgICBuZXdEYXRhTW9kZWwgPSBvcHRpb25zLmRhdGFNb2RlbDtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLkRhdGFNb2RlbCkge1xuICAgICAgICAgICAgbmV3RGF0YU1vZGVsID0gbmV3IG9wdGlvbnMuRGF0YU1vZGVsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3RGF0YU1vZGVsID0gbmV3IERlZmF1bHREYXRhTW9kZWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3RGF0YU1vZGVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBBdHRhY2ggYSBkYXRhIG1vZGVsIG9iamVjdCB0byB0aGUgZ3JpZC5cbiAgICAgKiBAZGVzYyBJbnN0YWxscyBkYXRhIG1vZGVsIGV2ZW50cywgZmFsbGJhY2tzLCBhbmQgaG9va3MuXG4gICAgICpcbiAgICAgKiBDYWxsZWQgZnJvbSB7QGxpbmsgQmVoYXZpb3IjcmVzZXR9LlxuICAgICAqIEB0aGlzIHtCZWhhdmlvcn1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtkYXRhTW9kZWxBUEl9IFtvcHRpb25zLmRhdGFNb2RlbF0gLSBBIGZ1bGx5IGluc3RhbnRpYXRlZCBkYXRhIG1vZGVsIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5EYXRhTW9kZWw9cmVxdWlyZSgnZGF0YXNhdXItbG9jYWwnKV0gLSBEYXRhIG1vZGVsIHdpbGwgYmUgaW5zdGFudGlhdGVkIGZyb20gdGhpcyBjb25zdHJ1Y3RvciB1bmxlc3MgYG9wdGlvbnMuZGF0YU1vZGVsYCB3YXMgZ2l2ZW4uXG4gICAgICogQHBhcmFtIHtkYXRhTW9kZWxBUEl9IFtvcHRpb25zLm1ldGFkYXRhXSAtIFBhc3NlZCB0byB7QGxpbmsgZGF0YU1vZGVsQVBJI3NldE1ldGFkYXRhU3RvcmUgc2V0TWV0YWRhdGFTdG9yZX0uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZGF0YSBtb2RlbCBoYXMgY2hhbmdlZC5cbiAgICAgKiBAbWVtYmVyT2YgTG9jYWwjXG4gICAgICovXG4gICAgcmVzZXREYXRhTW9kZWw6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG5ld0RhdGFNb2RlbCA9IHRoaXMuZ2V0TmV3RGF0YU1vZGVsKG9wdGlvbnMpLFxuICAgICAgICAgICAgY2hhbmdlZCA9IG5ld0RhdGFNb2RlbCAmJiBuZXdEYXRhTW9kZWwgIT09IHRoaXMuZGF0YU1vZGVsO1xuXG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFNb2RlbCA9IHRoaXMuZGVjb3JhdGVEYXRhTW9kZWwobmV3RGF0YU1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGRlY29yYXRvcnMuYWRkRGVwcmVjYXRpb25XYXJuaW5ncy5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgZGVjb3JhdG9ycy5hZGRGcmllbmRsaWVyRHJpbGxEb3duTWFwS2V5cy5jYWxsKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZGF0YU1vZGVsQVBJfSBuZXdEYXRhTW9kZWxcbiAgICAgKiBAcGFyYW0ge2RhdGFNb2RlbEFQSX0gW29wdGlvbnMubWV0YWRhdGFdIC0gUGFzc2VkIHRvIHtAbGluayBkYXRhTW9kZWxBUEkjc2V0TWV0YWRhdGFTdG9yZSBzZXRNZXRhZGF0YVN0b3JlfS5cbiAgICAgKi9cbiAgICBkZWNvcmF0ZURhdGFNb2RlbDogZnVuY3Rpb24obmV3RGF0YU1vZGVsLCBvcHRpb25zKSB7XG4gICAgICAgIGRlY29yYXRvcnMuYWRkUG9seWZpbGxzKG5ld0RhdGFNb2RlbCk7XG4gICAgICAgIGRlY29yYXRvcnMuYWRkRmFsbGJhY2tzKG5ld0RhdGFNb2RlbCwgdGhpcy5ncmlkKTtcbiAgICAgICAgZGVjb3JhdG9ycy5hZGREZWZhdWx0SG9va3MobmV3RGF0YU1vZGVsKTtcblxuICAgICAgICBuZXdEYXRhTW9kZWwuc2V0TWV0YWRhdGFTdG9yZShvcHRpb25zICYmIG9wdGlvbnMubWV0YWRhdGEpO1xuXG4gICAgICAgIHJldHVybiBuZXdEYXRhTW9kZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IENvbnZlbmllbmNlIGdldHRlci9zZXR0ZXIuXG4gICAgICogQGRlc2MgQ2FsbHMgdGhlIGRhdGEgbW9kZWwncyBgZ2V0U2NoZW1hYC9gc2V0U2NoZW1hYCBtZXRob2RzLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZmluLWh5cGVyZ3JpZC5naXRodWIuaW8vZG9jL2RhdGFNb2RlbEFQSS5odG1sI2dldFNjaGVtYXxnZXRTY2hlbWF9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9maW4taHlwZXJncmlkLmdpdGh1Yi5pby9kb2MvZGF0YU1vZGVsQVBJLmh0bWwjc2V0U2NoZW1hfHNldFNjaGVtYX1cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICogQG1lbWJlck9mIExvY2FsI1xuICAgICAqL1xuICAgIGdldCBzY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbCAmJiB0aGlzLmRhdGFNb2RlbC5nZXRTY2hlbWEoKTtcbiAgICB9LFxuICAgIHNldCBzY2hlbWEobmV3U2NoZW1hKSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnNldFNjaGVtYShuZXdTY2hlbWEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBNYXAgb2YgZHJpbGwgZG93biBjaGFyYWN0ZXJzIHVzZWQgYnkgdGhlIGRhdGEgbW9kZWwuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9maW4taHlwZXJncmlkLmdpdGh1Yi5pby9kb2MvZGF0YU1vZGVsQVBJLmh0bWwjY2hhck1hcHxjaGFyTWFwfVxuICAgICAqIEB0eXBlIHt7T1BFTjpzdHJpbmcsIENMT1NFOnN0cmluZywgSU5ERU5UOnN0cmluZ319XG4gICAgICogQG1lbWJlck9mIExvY2FsI1xuICAgICAqL1xuICAgIGdldCBjaGFyTWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZHJpbGxEb3duQ2hhck1hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQ2FsbHMgYGFwcGx5KClgIG9uIHRoZSBkYXRhIG1vZGVsLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZmluLWh5cGVyZ3JpZC5naXRodWIuaW8vZG9jL2RhdGFNb2RlbEFQSS5odG1sI3JlaW5kZXh8cmVpbmRleH1cbiAgICAgKiBAbWVtYmVyT2YgTG9jYWwjXG4gICAgICovXG4gICAgcmVpbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLmFwcGx5KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldHMgdGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBkYXRhIHN1YmdyaWQuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9maW4taHlwZXJncmlkLmdpdGh1Yi5pby9kb2MvZGF0YU1vZGVsQVBJLmh0bWwjZ2V0Um93Q291bnR8Z2V0Um93Q291bnR9XG4gICAgICogQG1lbWJlck9mIExvY2FsI1xuICAgICAqL1xuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgZGF0YSByb3cgZnJvbSB0aGUgZGF0YSBtb2RlbC5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2Zpbi1oeXBlcmdyaWQuZ2l0aHViLmlvL2RvYy9kYXRhTW9kZWxBUEkuaHRtbCNnZXRSb3d8Z2V0Um93fVxuICAgICAqIEBtZW1iZXJPZiBMb2NhbCNcbiAgICAgKiBAcmV0dXJuIHtkYXRhUm93T2JqZWN0fSBUaGUgZGF0YSByb3cgb2JqZWN0IGF0IHkgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgcm93IGluZGV4IG9mIGludGVyZXN0XG4gICAgICovXG4gICAgZ2V0Um93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRSb3coeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGFsbCBkYXRhIHJvd3MgZnJvbSB0aGUgZGF0YSBtb2RlbC5cbiAgICAgKiA+IFVzZSB3aXRoIGNhdXRpb24hXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9maW4taHlwZXJncmlkLmdpdGh1Yi5pby9kb2MvZGF0YU1vZGVsQVBJLmh0bWwjZ2V0RGF0YXxnZXREYXRhfVxuICAgICAqIEByZXR1cm4ge2RhdGFSb3dPYmplY3RbXX1cbiAgICAgKiBAbWVtYmVyT2YgTG9jYWwjXG4gICAgICovXG4gICAgZ2V0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXREYXRhKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBMb2NhbCNcbiAgICAgKi9cbiAgICBnZXRJbmRleGVkRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2dldEluZGV4ZWREYXRhKCknLCAnZ2V0RGF0YSgpJywgJzMuMC4wJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IENhbGxzIGBjbGlja2Agb24gdGhlIGRhdGEgbW9kZWwgaWYgY29sdW1uIGlzIGEgdHJlZSBjb2x1bW4uXG4gICAgICogQGRlc2MgU2VuZHMgY2xpY2tlZCBjZWxsJ3MgY29vcmRpbmF0ZXMgdG8gdGhlIGRhdGEgbW9kZWwuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9maW4taHlwZXJncmlkLmdpdGh1Yi5pby9kb2MvZGF0YU1vZGVsQVBJLmh0bWwjaXNEcmlsbERvd258aXNEcmlsbERvd259XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9maW4taHlwZXJncmlkLmdpdGh1Yi5pby9kb2MvZGF0YU1vZGVsQVBJLmh0bWwjY2xpY2t8Y2xpY2t9XG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR9IGV2ZW50XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IElmIGNsaWNrIHdhcyBpbiBhIGRyaWxsIGRvd24gY29sdW1uIGFuZCBjbGljayBvbiB0aGlzIHJvdyB3YXMgXCJjb25zdW1lZFwiIGJ5IHRoZSBkYXRhIG1vZGVsIChfaS5lLiwgY2F1c2VkIGl0J3Mgc3RhdGUgdG8gY2hhbmdlKS5cbiAgICAgKiBAbWVtYmVyT2YgTG9jYWwjXG4gICAgICovXG4gICAgY2VsbENsaWNrZWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5pc0RyaWxsRG93bihldmVudC5kYXRhQ2VsbC54KSAmJlxuICAgICAgICAgICAgdGhpcy5kYXRhTW9kZWwuY2xpY2soZXZlbnQuZGF0YUNlbGwueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBMb2NhbCNcbiAgICAgKiBAZGVzY3JpcHRpb24gR2V0IGJvb2xlYW4gZGF0YSBhYm91dCB0cmVlIGNvbHVtbnMgc2hvdyBuZWVkZWRcbiAgICAgKi9cbiAgICBoYXNUcmVlQ29sdW1uOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnByb3BlcnRpZXMuc2hvd1RyZWVDb2x1bW4gJiYgdGhpcy5kYXRhTW9kZWwuaXNEcmlsbERvd24oY29sdW1uSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgTG9jYWwjXG4gICAgICogQGRlc2MgR2V0IGFsbCBzZWxlY3Rpb25zIG1hZGUgaW4gY3VycmVudCBncmlkIHNlc3Npb25cbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IGV4dGVuZCByb3cgZGF0YSB3aXRoIGFnZ3JlZ2F0aW9uIG5hbWUgZnJvbSBwYXJlbnQgcm93XG4gICAgICogQHBhcmFtIHJvdyAtIHJvdyBzdHJ1Y3R1cmUgd2hpY2ggd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBuZXcgYWdnIGRhdGFcbiAgICAgKiBAcGFyYW0gcGFyZW50UGFyZW50QWdncyAtIGFnZyBkYXRhIGZyb20gcHJldmlvdXMgcm93IGRhdGFcbiAgICAgKi9cbiAgICBwb3B1bGF0ZUFnZ3JlZ2F0aW9uTmFtZXNGb3JSb3cocm93LCBwYXJlbnRQYXJlbnRBZ2dzKSB7XG4gICAgICAgIGlmIChyb3cuX190cmVlTGV2ZWwgIT09IHVuZGVmaW5lZCAmJiByb3cuJCRhZ2dyZWdhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50QWdncyA9IE9iamVjdC5hc3NpZ24oe30sIHJvdy5wYXJlbnRBZ2dzIHx8IHBhcmVudFBhcmVudEFnZ3MgfHwge30pOyAvLyBjb3B5IHBhcmVudEFnZ3NcbiAgICAgICAgICAgIHBhcmVudEFnZ3NbdGhpcy5hZ2dOYW1lRnJvbVJvdyhyb3cpXSA9IHJvdy4kJGFnZ3JlZ2F0aW9uO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyb3csIHBhcmVudEFnZ3MsIHsgcGFyZW50QWdncyB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZ2dOYW1lRnJvbVJvdzogZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIHJldHVybiBgJCRhZ2dyZWdhdGlvbiR7cm93Ll9fdHJlZUxldmVsfWA7XG4gICAgfSxcblxuICAgIGNvcHlWYWx1ZXM6IGZ1bmN0aW9uKHJvdykge1xuICAgICAgICBjb25zdCByZXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMocm93KS5maWx0ZXIoayA9PiAhay5zdGFydHNXaXRoKCckJCcpICYmICFrLnN0YXJ0c1dpdGgoJ19fJykpLmZvckVhY2goayA9PiByZXNba10gPSByb3dba10pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBhcHBlbmQgY2hpbGQgcm93cyByaWdodCBhZnRlciBwYXJlbnRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGV4cGFuZENoaWxkUm93czogZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1Jvd0V4cGFuZGVkKHJvdykgJiYgcm93LiQkY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHRoaXMucG9wdWxhdGVBZ2dyZWdhdGlvbk5hbWVzRm9yUm93KHJvdyk7XG4gICAgICAgICAgICBpZiAocm93LiQkY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvd0luZGV4ID0gdGhpcy5kYXRhTW9kZWwuaW5kZXhPZihyb3cpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkcmVuVG9BZGQgPSByb3cuJCRjaGlsZHJlbjtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdyaWQucHJvcGVydGllcy5pc1Bpdm90KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3cuJCRjaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgIXJvdy4kJGNoaWxkcmVuW3Jvdy4kJGNoaWxkcmVuLmxlbmd0aCAtIDFdW0dSQU5EX1RPVEFMXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93LiQkY2hpbGRyZW4ucHVzaChPYmplY3QuYXNzaWduKHRoaXMuY29weVZhbHVlcyhyb3cpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW0dSQU5EX1RPVEFMXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5hZ2dOYW1lRnJvbVJvdyhyb3cpXTogYCR7cm93W3RoaXMuYWdnTmFtZUZyb21Sb3cocm93KV19IFRvdGFsYFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuVG9BZGQgPSByb3cuJCRjaGlsZHJlbi5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFNb2RlbC5hZGRSb3dzKGNoaWxkcmVuVG9BZGQsIHJvd0luZGV4ICsgMSk7XG5cbiAgICAgICAgICAgICAgICByb3cuJCRjaGlsZHJlbi5mb3JFYWNoKHIgPT4ge1xuICAgICAgICAgICAgICAgICAgICByLiQkb3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcHVsYXRlQWdncmVnYXRpb25OYW1lc0ZvclJvdyhyLCB0aGlzLmdyaWQucHJvcGVydGllcy5pc1Bpdm90ID8ge30gOiByb3cucGFyZW50QWdncyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgY29sdW1uIGJlY2F1c2Ugb2YgZmxhdCBtb2RlXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmdyaWQucHJvcGVydGllcy5pc1Bpdm90KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YU1vZGVsLmRhdGEuc3BsaWNlKHJvd0luZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5mbGF0UmVhZHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFNb2RlbC5jYWNoZSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJvdy4kJG9wZW4gPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyByZW1vdmUgYWxsIGNoaWxkIHJvd3MgZnJvbSBkYXRhIG1vZGVsXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgKi9cbiAgICBjb2xsYXBzZUNoaWxkUm93czogZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIGlmIChyb3cuJCRvcGVuICYmIHJvdy4kJGNoaWxkcmVuICYmIHJvdy4kJGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHJvd0luZGV4ID0gdGhpcy5kYXRhTW9kZWwuaW5kZXhPZihyb3cpICsgMTsgLy8gZGVsZXRpbmcgc3RhcnRzIGZyb20gbmV4dCByb3dcblxuICAgICAgICAgICAgLy8gY29sbGFwc2UgY2hpbGRyZW4gYmVmb3JlIGRlbGV0aW5nIHBhcmVudFxuICAgICAgICAgICAgdGhpcy5jb2xsYXBzZUNoaWxkUm93cyhyb3cuJCRjaGlsZHJlblswXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcm93SW5kZXg7IGkgPCByb3dJbmRleCArIHJvdy4kJGNoaWxkcmVuLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGFwc2VDaGlsZFJvd3ModGhpcy5kYXRhTW9kZWwuZGF0YVtpXSk7IC8vIHJlYWxseSBuZWVkZWQgYWNjZXNzIGJ5IGluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRhdGFNb2RlbC5kZWxSb3cocm93SW5kZXgsIHJvdy4kJGNoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJvdy4kJG9wZW4gPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2Mgc2V0IGNvbERlZnMgZ3JvdXAgc3RhdGUgdG8gb3BlbiBhbmQgc3luY2hyb25pemUgc2NoZW1hXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgKi9cbiAgICBleHBhbmRDaGlsZENvbHVtbnM6IGZ1bmN0aW9uKGdyb3VwSWQpIHtcbiAgICAgICAgdGhpcy5fc2V0Q29sRGVmR3JvdXBTaG93U3RhdGVSZWN1cnNpdmUodGhpcy5ncmlkLmNvbHVtbkRlZnMsIGdyb3VwSWQsICdvcGVuJyk7XG5cbiAgICAgICAgdGhpcy5zeW5jaHJvbml6ZVNjaGVtYVRvQ29sdW1uRGVmcygpO1xuICAgICAgICB0aGlzLmZpdENvbHVtbnNHcm91cChncm91cElkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2Mgc2V0IGNvbERlZnMgZ3JvdXAgc3RhdGUgdG8gY2xvc2VkIGFuZCBzeW5jaHJvbml6ZSBzY2hlbWFcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGNvbGxhcHNlQ2hpbGRDb2x1bW5zOiBmdW5jdGlvbihncm91cElkKSB7XG4gICAgICAgIHRoaXMuX3NldENvbERlZkdyb3VwU2hvd1N0YXRlUmVjdXJzaXZlKHRoaXMuZ3JpZC5jb2x1bW5EZWZzLCBncm91cElkLCAnY2xvc2VkJyk7XG5cbiAgICAgICAgdGhpcy5zeW5jaHJvbml6ZVNjaGVtYVRvQ29sdW1uRGVmcygpO1xuICAgICAgICB0aGlzLmZpdENvbHVtbnNHcm91cChncm91cElkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgdXRpbGl0eSBmdW5jdGlvbiB0byByZWN1cnNpdmVseSBmb3VuZCBjb2xEZWZzIGdyb3VwIGJ5IGlkIGFuZCBzZXQgaXQncyBvcGVuIHN0YXRlXG4gICAgICogQHBhcmFtIHthcnJheX0gY29sRGVmc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cElkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1N0YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgKi9cbiAgICBfc2V0Q29sRGVmR3JvdXBTaG93U3RhdGVSZWN1cnNpdmU6IGZ1bmN0aW9uKGNvbERlZnMsIGdyb3VwSWQsIG5ld1N0YXRlKSB7XG4gICAgICAgIGNvbERlZnMuZm9yRWFjaChjZCA9PiB7XG4gICAgICAgICAgICBpZiAoY2QuZ3JvdXBJZCA9PT0gZ3JvdXBJZCkge1xuICAgICAgICAgICAgICAgIGNkLmNvbHVtbkdyb3VwU2hvdyA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2QuY2hpbGRyZW4gJiYgY2QuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldENvbERlZkdyb3VwU2hvd1N0YXRlUmVjdXJzaXZlKGNkLmNoaWxkcmVuLCBncm91cElkLCBuZXdTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBzZXQgYWxsIHJvd3MgZXhwYW5kZWQgaW4gb25lIHRpbWVcbiAgICAgKi9cbiAgICBidWlsZEZsYXRNb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgZXhwYW5kUm93ID0gKHJvdykgPT4ge1xuICAgICAgICAgICAgdGhpcy5leHBhbmRDaGlsZFJvd3Mocm93KTtcbiAgICAgICAgICAgIGlmIChyb3cuJCRjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIHJvdy4kJGNoaWxkcmVuLmZvckVhY2goYyA9PiBleHBhbmRSb3coYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB0aGlzLmZsYXRSZWFkeSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRhdGFNb2RlbC5kYXRhLmZvckVhY2gocm93ID0+IGV4cGFuZFJvdyhyb3cpKTtcbiAgICAgICAgfSB3aGlsZSAoIXRoaXMuZmxhdFJlYWR5KTtcblxuICAgICAgICB0aGlzLmRhdGFNb2RlbC5jYWNoZSA9IFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBnZXQgYWRkaXRpb25hbCB3aWR0aCBiYXNlZCBvbiBjb2xzcGFuXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0QWRkaXRpb25hbFdpZHRoOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRBZGRpdGlvbmFsV2lkdGgoeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IGdldCBhZGRpdGlvbmFsIGhlaWdodCBiYXNlZCBvbiByb3dzcGFuXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0QWRkaXRpb25hbEhlaWdodDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0QWRkaXRpb25hbEhlaWdodCh4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBkZXNjIGdldCBjb2xzcGFuIG9mIGFuIGNlbGwsIGlmIGV4aXN0LiBPdGhlcndpc2UsIHJldHVybnMgMDtcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICBnZXRDb2xzcGFuOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRDb2xzcGFuKHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQGRlc2MgZ2V0IHJvd3NwYW4gb2YgYW4gY2VsbCwgaWYgZXhpc3QuIE90aGVyd2lzZSwgcmV0dXJucyAwO1xuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqL1xuICAgIGdldFJvd3NwYW46IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldFJvd3NwYW4oeCwgeSk7XG4gICAgfSxcblxuICAgIGVycm9yczoge31cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhMb2NhbC5wcm90b3R5cGUsIHJlcXVpcmUoJy4vY29sdW1uRW51bScpLmRlc2NyaXB0b3JzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2NhbDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBCZWhhdmlvci5qcyBtaXhlcyB0aGlzIG1vZHVsZSBpbnRvIGl0cyBwcm90b3R5cGUuXG4gKiBAbWl4aW5cbiAqL1xuZXhwb3J0cy5iZWhhdmlvck1peGluID0ge1xuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgY2VsbCdzIG93biBwcm9wZXJ0aWVzIG9iamVjdC5cbiAgICAgKiBAZGVzYyBNYXkgYmUgdW5kZWZpbmVkIGJlY2F1c2UgY2VsbHMgb25seSBoYXZlIHRoZWlyIG93biBwcm9wZXJ0aWVzIG9iamVjdCB3aGVuIGF0IGxlc3Qgb25lIG93biBwcm9wZXJ0eSBoYXMgYmVlbiBzZXQuXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR8bnVtYmVyfSB4T3JDZWxsRXZlbnQgLSBEYXRhIHggY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ldIC0gR3JpZCByb3cgY29vcmRpbmF0ZS4gX09taXQgd2hlbiBgeE9yQ2VsbEV2ZW50YCBpcyBhIGBDZWxsRXZlbnRgLl9cbiAgICAgKiBAcGFyYW0ge2RhdGFNb2RlbEFQSX0gW2RhdGFNb2RlbD10aGlzLnN1YmdyaWRzLmxvb2t1cC5kYXRhXSAtIEZvciB1c2Ugb25seSB3aGVuIGB4T3JDZWxsRXZlbnRgIGlzIF9ub3RfIGEgYENlbGxFdmVudGA6IFByb3ZpZGUgYSBzdWJncmlkLlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8b2JqZWN0fSBUaGUgXCJvd25cIiBwcm9wZXJ0aWVzIG9mIHRoZSBjZWxsIGF0IHgseSBpbiB0aGUgZ3JpZC4gSWYgdGhlIGNlbGwgZG9lcyBub3Qgb3duIGEgcHJvcGVydGllcyBvYmplY3QsIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqL1xuICAgIGdldENlbGxPd25Qcm9wZXJ0aWVzOiBmdW5jdGlvbih4T3JDZWxsRXZlbnQsIHksIGRhdGFNb2RlbCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8geE9yQ2VsbEV2ZW50IGlzIGNlbGxFdmVudFxuICAgICAgICAgICAgcmV0dXJuIHhPckNlbGxFdmVudC5jb2x1bW4uZ2V0Q2VsbE93blByb3BlcnRpZXMoeE9yQ2VsbEV2ZW50LmRhdGFDZWxsLnksIHhPckNlbGxFdmVudC5zdWJncmlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHhPckNlbGxFdmVudCBpcyB4XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2x1bW4oeE9yQ2VsbEV2ZW50KS5nZXRDZWxsT3duUHJvcGVydGllcyh5LCBkYXRhTW9kZWwpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgcHJvcGVydGllcyBvYmplY3QgZm9yIGNlbGwuXG4gICAgICogQGRlc2MgVGhpcyBpcyB0aGUgY2VsbCdzIG93biBwcm9wZXJ0aWVzIG9iamVjdCBpZiBmb3VuZCBlbHNlIHRoZSBjb2x1bW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogSWYgeW91IGFyZSBzZWVraW5nIGEgc2luZ2xlIHNwZWNpZmljIHByb3BlcnR5LCBjb25zaWRlciBjYWxsaW5nIHtAbGluayBCZWhhdmlvciNnZXRDZWxsUHJvcGVydHl9IGluc3RlYWQuXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR8bnVtYmVyfSB4T3JDZWxsRXZlbnQgLSBEYXRhIHggY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ldIC0gR3JpZCByb3cgY29vcmRpbmF0ZS4gX09taXQgd2hlbiBgeE9yQ2VsbEV2ZW50YCBpcyBhIGBDZWxsRXZlbnRgLl9cbiAgICAgKiBAcGFyYW0ge2RhdGFNb2RlbEFQSX0gW2RhdGFNb2RlbD10aGlzLnN1YmdyaWRzLmxvb2t1cC5kYXRhXSAtIEZvciB1c2Ugb25seSB3aGVuIGB4T3JDZWxsRXZlbnRgIGlzIF9ub3RfIGEgYENlbGxFdmVudGA6IFByb3ZpZGUgYSBzdWJncmlkLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHByb3BlcnRpZXMgb2YgdGhlIGNlbGwgYXQgeCx5IGluIHRoZSBncmlkLlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKi9cbiAgICBnZXRDZWxsUHJvcGVydGllczogZnVuY3Rpb24oeE9yQ2VsbEV2ZW50LCB5LCBkYXRhTW9kZWwpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIHhPckNlbGxFdmVudCBpcyBjZWxsRXZlbnRcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB4T3JDZWxsRXZlbnQucHJvcGVydGllcyB8fCB7fSwgeE9yQ2VsbEV2ZW50LnJvd093blByb3BlcnRpZXMgfHwge30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8geE9yQ2VsbEV2ZW50IGlzIHhcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbHVtbih4T3JDZWxsRXZlbnQpLmdldENlbGxQcm9wZXJ0aWVzKHksIGRhdGFNb2RlbCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmV0dXJuIGEgc3BlY2lmaWMgY2VsbCBwcm9wZXJ0eS5cbiAgICAgKiBAZGVzYyBJZiB0aGVyZSBpcyBubyBjZWxsIHByb3BlcnRpZXMgb2JqZWN0LCBkZWZlcnMgdG8gY29sdW1uIHByb3BlcnRpZXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fG51bWJlcn0geE9yQ2VsbEV2ZW50IC0gRGF0YSB4IGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5XSAtIEdyaWQgcm93IGNvb3JkaW5hdGUuXyBPbWl0IHdoZW4gYHhPckNlbGxFdmVudGAgaXMgYSBgQ2VsbEV2ZW50YC5fXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIE5hbWUgb2YgcHJvcGVydHkgdG8gZ2V0LiBfV2hlbiBgeWAgb21pdHRlZCwgdGhpcyBwYXJhbSBwcm9tb3RlZCB0byAybmQgYXJnLl9cbiAgICAgKiBAcGFyYW0ge2RhdGFNb2RlbEFQSX0gW2RhdGFNb2RlbD10aGlzLnN1YmdyaWRzLmxvb2t1cC5kYXRhXSAtIEZvciB1c2Ugb25seSB3aGVuIGB4T3JDZWxsRXZlbnRgIGlzIF9ub3RfIGEgYENlbGxFdmVudGA6IFByb3ZpZGUgYSBzdWJncmlkLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBmb3IgdGhlIGNlbGwgYXQgeCx5IGluIHRoZSBncmlkLlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKi9cbiAgICBnZXRDZWxsUHJvcGVydHk6IGZ1bmN0aW9uKHhPckNlbGxFdmVudCwgeSwga2V5LCBkYXRhTW9kZWwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4T3JDZWxsRXZlbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBrZXkgPSB5O1xuICAgICAgICAgICAgcmV0dXJuIHhPckNlbGxFdmVudC5wcm9wZXJ0aWVzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5nZXRDb2x1bW4oeE9yQ2VsbEV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBjb2x1bW4gJiYgY29sdW1uLmdldENlbGxQcm9wZXJ0eSh5LCBrZXksIGRhdGFNb2RlbCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIHVwZGF0ZSB0aGUgZGF0YSBhdCBwb2ludCB4LCB5IHdpdGggdmFsdWVcbiAgICAgKiBAcGFyYW0ge0NlbGxFdmVudHxudW1iZXJ9IHhPckNlbGxFdmVudCAtIERhdGEgeCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gLSBHcmlkIHJvdyBjb29yZGluYXRlLiBfT21pdCB3aGVuIGB4T3JDZWxsRXZlbnRgIGlzIGEgYENlbGxFdmVudGAuX1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gSGFzaCBvZiBjZWxsIHByb3BlcnRpZXMuIF9XaGVuIGB5YCBvbWl0dGVkLCB0aGlzIHBhcmFtIHByb21vdGVkIHRvIDJuZCBhcmcuX1xuICAgICAqIEBwYXJhbSB7ZGF0YU1vZGVsQVBJfSBbZGF0YU1vZGVsPXRoaXMuc3ViZ3JpZHMubG9va3VwLmRhdGFdIC0gRm9yIHVzZSBvbmx5IHdoZW4gYHhPckNlbGxFdmVudGAgaXMgX25vdF8gYSBgQ2VsbEV2ZW50YDogUHJvdmlkZSBhIHN1YmdyaWQuXG4gICAgICovXG4gICAgc2V0Q2VsbFByb3BlcnRpZXM6IGZ1bmN0aW9uKHhPckNlbGxFdmVudCwgeSwgcHJvcGVydGllcywgZGF0YU1vZGVsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgeE9yQ2VsbEV2ZW50ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcHJvcGVydGllcyA9IHk7XG4gICAgICAgICAgICByZXR1cm4geE9yQ2VsbEV2ZW50LmNvbHVtbi5zZXRDZWxsUHJvcGVydGllcyh4T3JDZWxsRXZlbnQuZGF0YUNlbGwueSwgcHJvcGVydGllcywgeE9yQ2VsbEV2ZW50LnN1YmdyaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sdW1uKHhPckNlbGxFdmVudCkuc2V0Q2VsbFByb3BlcnRpZXMoeSwgcHJvcGVydGllcywgZGF0YU1vZGVsKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2MgdXBkYXRlIHRoZSBkYXRhIGF0IHBvaW50IHgsIHkgd2l0aCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fG51bWJlcn0geE9yQ2VsbEV2ZW50IC0gRGF0YSB4IGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5XSAtIEdyaWQgcm93IGNvb3JkaW5hdGUuIF9PbWl0IHdoZW4gYHhPckNlbGxFdmVudGAgaXMgYSBgQ2VsbEV2ZW50YC5fXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSBIYXNoIG9mIGNlbGwgcHJvcGVydGllcy4gX1doZW4gYHlgIG9taXR0ZWQsIHRoaXMgcGFyYW0gcHJvbW90ZWQgdG8gMm5kIGFyZy5fXG4gICAgICogQHBhcmFtIHtkYXRhTW9kZWxBUEl9IFtkYXRhTW9kZWw9dGhpcy5zdWJncmlkcy5sb29rdXAuZGF0YV0gLSBGb3IgdXNlIG9ubHkgd2hlbiBgeE9yQ2VsbEV2ZW50YCBpcyBfbm90XyBhIGBDZWxsRXZlbnRgOiBQcm92aWRlIGEgc3ViZ3JpZC5cbiAgICAgKi9cbiAgICBhZGRDZWxsUHJvcGVydGllczogZnVuY3Rpb24oeE9yQ2VsbEV2ZW50LCB5LCBwcm9wZXJ0aWVzLCBkYXRhTW9kZWwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4T3JDZWxsRXZlbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0geTtcbiAgICAgICAgICAgIHJldHVybiB4T3JDZWxsRXZlbnQuY29sdW1uLmFkZENlbGxQcm9wZXJ0aWVzKHhPckNlbGxFdmVudC5kYXRhQ2VsbC55LCBwcm9wZXJ0aWVzLCB4T3JDZWxsRXZlbnQuc3ViZ3JpZCk7IC8vIHkgb21pdHRlZCBzbyB5IGhlcmUgaXMgYWN0dWFsbHkgcHJvcGVydGllc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sdW1uKHhPckNlbGxFdmVudCkuYWRkQ2VsbFByb3BlcnRpZXMoeSwgcHJvcGVydGllcywgZGF0YU1vZGVsKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTZXQgYSBzcGVjaWZpYyBjZWxsIHByb3BlcnR5LlxuICAgICAqIEBkZXNjIElmIHRoZXJlIGlzIG5vIGNlbGwgcHJvcGVydGllcyBvYmplY3QsIGRlZmVycyB0byBjb2x1bW4gcHJvcGVydGllcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBOT1RFOiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgcmVuZGVyZXIncyBjZWxsIGV2ZW50IG9iamVjdHMgY2FjaGUgdGhlaXIgcmVzcGVjdGl2ZSBjZWxsIHByb3BlcnRpZXMgb2JqZWN0cy4gVGhpcyBtZXRob2QgYWNjZXB0cyBhIGBDZWxsRXZlbnRgIG92ZXJsb2FkLiBXaGVuZXZlciBwb3NzaWJsZSwgdXNlIHRoZSBgQ2VsbEV2ZW50YCBmcm9tIHRoZSByZW5kZXJlcidzIGNlbGwgZXZlbnQgcG9vbC4gRG9pbmcgc28gd2lsbCByZXNldCB0aGUgY2VsbCBwcm9wZXJ0aWVzIG9iamVjdCBjYWNoZS5cbiAgICAgKlxuICAgICAqIElmIHlvdSB1c2Ugc29tZSBvdGhlciBgQ2VsbEV2ZW50YCwgdGhlIHJlbmRlcmVyJ3MgYENlbGxFdmVudGAgcHJvcGVydGllcyBjYWNoZSB3aWxsIG5vdCBiZSBhdXRvbWF0aWNhbGx5IHJlc2V0IHVudGlsIHRoZSB3aG9sZSBjZWxsIGV2ZW50IHBvb2wgaXMgcmVzZXQgb24gdGhlIG5leHQgY2FsbCB0byB7QGxpbmsgUmVuZGVyZXIjY29tcHV0ZUNlbGxCb3VuZGFyaWVzfS4gSWYgbmVjZXNzYXJ5LCB5b3UgY2FuIFwibWFudWFsbHlcIiByZXNldCBpdCBieSBjYWxsaW5nIHtAbGluayBSZW5kZXJlciNyZXNldENlbGxQcm9wZXJ0aWVzQ2FjaGV8cmVzZXRDZWxsUHJvcGVydGllc0NhY2hlKHlvdXJDZWxsRXZlbnQpfSB3aGljaCBzZWFyY2hlcyB0aGUgY2VsbCBldmVudCBwb29sIGZvciBvbmUgd2l0aCBtYXRjaGluZyBjb29yZGluYXRlcyBhbmQgcmVzZXRzIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIFRoZSByYXcgY29vcmRpbmF0ZXMgb3ZlcmxvYWQgY2FsbHMgdGhlIGByZXNldENlbGxQcm9wZXJ0aWVzQ2FjaGUoeCwgeSlgIG92ZXJsb2FkIGZvciB5b3UuXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR8bnVtYmVyfSB4T3JDZWxsRXZlbnQgLSBgQ2VsbEV2ZW50YCBvciBkYXRhIHggY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ldIC0gR3JpZCByb3cgY29vcmRpbmF0ZS4gX09taXQgd2hlbiBgeE9yQ2VsbEV2ZW50YCBpcyBhIGBDZWxsRXZlbnRgLl9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gTmFtZSBvZiBwcm9wZXJ0eSB0byBnZXQuIF9XaGVuIGB5YCBvbWl0dGVkLCB0aGlzIHBhcmFtIHByb21vdGVkIHRvIDJuZCBhcmcuX1xuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7ZGF0YU1vZGVsQVBJfSBbZGF0YU1vZGVsPXRoaXMuc3ViZ3JpZHMubG9va3VwLmRhdGFdIC0gRm9yIHVzZSBvbmx5IHdoZW4gYHhPckNlbGxFdmVudGAgaXMgX25vdF8gYSBgQ2VsbEV2ZW50YDogUHJvdmlkZSBhIHN1YmdyaWQuXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqL1xuICAgIHNldENlbGxQcm9wZXJ0eTogZnVuY3Rpb24oeE9yQ2VsbEV2ZW50LCB5LCBrZXksIHZhbHVlLCBkYXRhTW9kZWwpIHtcbiAgICAgICAgdmFyIGNlbGxPd25Qcm9wZXJ0aWVzO1xuICAgICAgICBpZiAodHlwZW9mIHhPckNlbGxFdmVudCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0ga2V5O1xuICAgICAgICAgICAga2V5ID0geTtcbiAgICAgICAgICAgIGNlbGxPd25Qcm9wZXJ0aWVzID0geE9yQ2VsbEV2ZW50LnNldENlbGxQcm9wZXJ0eShrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNlbGxPd25Qcm9wZXJ0aWVzID0gdGhpcy5nZXRDb2x1bW4oeE9yQ2VsbEV2ZW50KS5zZXRDZWxsUHJvcGVydHkoeSwga2V5LCB2YWx1ZSwgZGF0YU1vZGVsKTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5yZW5kZXJlci5yZXNldENlbGxQcm9wZXJ0aWVzQ2FjaGUoeE9yQ2VsbEV2ZW50LCB5LCBkYXRhTW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjZWxsT3duUHJvcGVydGllcztcbiAgICB9XG59O1xuXG4vKipcbiAqIENvbHVtbi5qcyBtaXhlcyB0aGlzIG1vZHVsZSBpbnRvIGl0cyBwcm90b3R5cGUuXG4gKiBAbWl4aW5cbiAqL1xuZXhwb3J0cy5jb2x1bW5NaXhpbiA9IHtcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgcHJvcGVydGllcyBvYmplY3QgZm9yIGNlbGwuXG4gICAgICogQGRlc2MgVGhpcyBpcyB0aGUgY2VsbCdzIG93biBwcm9wZXJ0aWVzIG9iamVjdCBpZiBmb3VuZDsgZWxzZSB0aGUgY29sdW1uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIElmIHlvdSBhcmUgc2Vla2luZyBhIHNpbmdsZSBzcGVjaWZpYyBwcm9wZXJ0eSwgY29uc2lkZXIgY2FsbGluZyB7QGxpbmsgQ29sdW1uI2dldENlbGxQcm9wZXJ0eX0gaW5zdGVhZCAod2hpY2ggY2FsbHMgdGhpcyBtZXRob2QpLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIERhdGEgcm93IGNvb3JkaW5hdGUuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcHJvcGVydGllcyBvZiB0aGUgY2VsbCBhdCB4LHkgaW4gdGhlIGdyaWQuXG4gICAgICogQG1lbWJlck9mIENvbHVtbiNcbiAgICAgKi9cbiAgICBnZXRDZWxsUHJvcGVydGllczogZnVuY3Rpb24ocm93SW5kZXgsIGRhdGFNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDZWxsT3duUHJvcGVydGllcyhyb3dJbmRleCwgZGF0YU1vZGVsKSB8fCB0aGlzLnByb3BlcnRpZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIERhdGEgcm93IGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMgLSBIYXNoIG9mIGNlbGwgcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uI1xuICAgICAqL1xuICAgIHNldENlbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbihyb3dJbmRleCwgcHJvcGVydGllcywgZGF0YU1vZGVsKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ld0NlbGxQcm9wZXJ0aWVzT2JqZWN0LmNhbGwodGhpcywgcm93SW5kZXgsIGRhdGFNb2RlbCksIHByb3BlcnRpZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBEYXRhIHJvdyBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzIC0gSGFzaCBvZiBjZWxsIHByb3BlcnRpZXMuXG4gICAgICogQHJldHVybnMge29iamVjdH0gQ2VsbCdzIG93biBwcm9wZXJ0aWVzIG9iamVjdCwgd2hpY2ggd2lsbCBiZSBjcmVhdGVkIGJ5IHRoaXMgY2FsbCBpZiBpdCBkaWQgbm90IGFscmVhZHkgZXhpc3QuXG4gICAgICogQG1lbWJlck9mIENvbHVtbiNcbiAgICAgKi9cbiAgICBhZGRDZWxsUHJvcGVydGllczogZnVuY3Rpb24ocm93SW5kZXgsIHByb3BlcnRpZXMsIGRhdGFNb2RlbCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihnZXRDZWxsUHJvcGVydGllc09iamVjdC5jYWxsKHRoaXMsIHJvd0luZGV4LCBkYXRhTW9kZWwpLCBwcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBjZWxsJ3Mgb3duIHByb3BlcnRpZXMgb2JqZWN0LlxuICAgICAqIEBkZXNjIER1ZSB0byBtZW1vcnkgY29uc3RyYWludHMsIHdlIGRvbid0IGNyZWF0ZSBhIGNlbGwgcHJvcGVydGllcyBvYmplY3QgZm9yIGV2ZXJ5IGNlbGwuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgY2VsbCBoYXMgaXRzIG93biBwcm9wZXJ0aWVzIG9iamVjdCwgaXQ6XG4gICAgICogKiB3YXMgY3JlYXRlZCBieSBhIHByZXZpb3VzIGNhbGwgdG8gYHNldENlbGxQcm9wZXJ0aWVzYCBvciBgc2V0Q2VsbFByb3BlcnR5YFxuICAgICAqICogaGFzIHRoZSBjb2x1bW4gcHJvcGVydGllcyBvYmplY3QgYXMgaXRzIHByb3RvdHlwZVxuICAgICAqICogaXMgcmV0dXJuZWRcbiAgICAgKlxuICAgICAqIElmIHRoZSBjZWxsIGRvZXMgbm90IGhhdmUgaXRzIG93biBwcm9wZXJ0aWVzIG9iamVjdCwgdGhpcyBtZXRob2QgcmV0dXJucyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBDYWxsIHRoaXMgbWV0aG9kIG9ubHkgd2hlbiB5b3UgbmVlZCB0byBrbm93IGlmIHRoZSB0aGUgY2VsbCBoYXMgaXRzIG93biBwcm9wZXJ0aWVzIG9iamVjdDsgb3RoZXJ3aXNlIGNhbGwge0BsaW5rIENvbHVtbiNnZXRDZWxsUHJvcGVydGllc3xnZXRDZWxsUHJvcGVydGllc30uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gRGF0YSByb3cgY29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVsbHxvYmplY3R9IFRoZSBcIm93blwiIHByb3BlcnRpZXMgb2YgdGhlIGNlbGwgYXQgeCx5IGluIHRoZSBncmlkLiBJZiB0aGUgY2VsbCBkb2VzIG5vdCBvd24gYSBwcm9wZXJ0aWVzIG9iamVjdCwgcmV0dXJucyBgbnVsbGAuXG4gICAgICogQG1lbWJlck9mIENvbHVtbiNcbiAgICAgKi9cbiAgICBnZXRDZWxsT3duUHJvcGVydGllczogZnVuY3Rpb24ocm93SW5kZXgsIGRhdGFNb2RlbCkge1xuICAgICAgICB2YXIgbWV0YWRhdGE7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAvLyB0aGlzLmluZGV4ID49IDAgJiYgLy8gbm8gY2VsbCBwcm9wcyBvbiByb3cgaGFuZGxlIGNlbGxzXG4gICAgICAgICAgICAobWV0YWRhdGEgPSAoZGF0YU1vZGVsIHx8IHRoaXMuZGF0YU1vZGVsKS5nZXRSb3dNZXRhZGF0YShyb3dJbmRleCkpICYmIC8vIG5vIGNlbGwgcHJvcHMgb24gbm9uLWV4aXN0ZW50IHJvd3NcbiAgICAgICAgICAgIG1ldGFkYXRhICYmIG1ldGFkYXRhW3RoaXMubmFtZV0gfHxcbiAgICAgICAgICAgIG51bGwgLy8gbnVsbCBtZWFucyBub3QgcHJldmlvdXNseSBjcmVhdGVkXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGRlbGV0ZUNlbGxPd25Qcm9wZXJ0aWVzOiBmdW5jdGlvbihyb3dJbmRleCwgZGF0YU1vZGVsKSB7XG4gICAgICAgIGRhdGFNb2RlbCA9IGRhdGFNb2RlbCB8fCB0aGlzLmRhdGFNb2RlbDtcbiAgICAgICAgdmFyIG1ldGFkYXRhID0gZGF0YU1vZGVsLmdldFJvd01ldGFkYXRhKHJvd0luZGV4KTtcbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICBkZWxldGUgbWV0YWRhdGFbdGhpcy5uYW1lXTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhtZXRhZGF0YSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGF0YU1vZGVsLnNldFJvd01ldGFkYXRhKHJvd0luZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZXR1cm4gYSBzcGVjaWZpYyBjZWxsIHByb3BlcnR5LlxuICAgICAqIEBkZXNjIElmIHRoZXJlIGlzIG5vIGNlbGwgcHJvcGVydGllcyBvYmplY3QsIGRlZmVycyB0byBjb2x1bW4gcHJvcGVydGllcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gRGF0YSByb3cgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgc3BlY2lmaWVkIHByb3BlcnR5IGZvciB0aGUgY2VsbCBhdCB4LHkgaW4gdGhlIGdyaWQuXG4gICAgICogQG1lbWJlck9mIENvbHVtbiNcbiAgICAgKi9cbiAgICBnZXRDZWxsUHJvcGVydHk6IGZ1bmN0aW9uKHJvd0luZGV4LCBrZXksIGRhdGFNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDZWxsUHJvcGVydGllcyhyb3dJbmRleCwgZGF0YU1vZGVsKVtrZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBEYXRhIHJvdyBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDZWxsJ3Mgb3duIHByb3BlcnRpZXMgb2JqZWN0LCB3aGljaCB3aWxsIGJlIGNyZWF0ZWQgYnkgdGhpcyBjYWxsIGlmIGl0IGRpZCBub3QgYWxyZWFkeSBleGlzdC5cbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uI1xuICAgICAqL1xuICAgIHNldENlbGxQcm9wZXJ0eTogZnVuY3Rpb24ocm93SW5kZXgsIGtleSwgdmFsdWUsIGRhdGFNb2RlbCkge1xuICAgICAgICB2YXIgY2VsbFByb3BzID0gZ2V0Q2VsbFByb3BlcnRpZXNPYmplY3QuY2FsbCh0aGlzLCByb3dJbmRleCwgZGF0YU1vZGVsKTtcbiAgICAgICAgY2VsbFByb3BzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNlbGxQcm9wcztcbiAgICB9LFxuXG4gICAgZGVsZXRlQ2VsbFByb3BlcnR5OiBmdW5jdGlvbihyb3dJbmRleCwga2V5LCBkYXRhTW9kZWwpIHtcbiAgICAgICAgdmFyIGNlbGxQcm9wcyA9IHRoaXMuZ2V0Q2VsbE93blByb3BlcnRpZXMocm93SW5kZXgsIGRhdGFNb2RlbCk7XG4gICAgICAgIGlmIChjZWxsUHJvcHMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjZWxsUHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgY2VsbCBwcm9wZXJ0aWVzIGZyb20gYWxsIGNlbGxzIGluIHRoaXMgY29sdW1uLlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW4jXG4gICAgICovXG4gICAgY2xlYXJBbGxDZWxsUHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc3ViZ3JpZHMuZm9yRWFjaChmdW5jdGlvbihkYXRhTW9kZWwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSBkYXRhTW9kZWwuZ2V0Um93Q291bnQoKTsgeS0tOykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlQ2VsbE93blByb3BlcnRpZXMoeSwgZGF0YU1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAdG9kbzogVGhlb3JldGljYWxseSBzZXREYXRhIHNob3VsZCBjYWxsIHRoaXMgbWV0aG9kIHRvIGVuc3VyZSBlYWNoIGNlbGwncyBwZXJzaXN0ZWQgcHJvcGVydGllcyBvYmplY3QgaXMgcHJvcGVybHkgcmVjcmVhdGVkIHdpdGggcHJvdG90eXBlIHNldCB0byBpdHMgY29sdW1uJ3MgcHJvcGVydGllcyBvYmplY3QuXG4gKiBAdGhpcyB7Q29sdW1ufVxuICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gRGF0YSByb3cgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRDZWxsUHJvcGVydGllc09iamVjdChyb3dJbmRleCwgZGF0YU1vZGVsKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2VsbE93blByb3BlcnRpZXMocm93SW5kZXgsIGRhdGFNb2RlbCkgfHwgbmV3Q2VsbFByb3BlcnRpZXNPYmplY3QuY2FsbCh0aGlzLCByb3dJbmRleCwgZGF0YU1vZGVsKTtcbn1cblxuLyoqXG4gKiBAdGhpcyB7Q29sdW1ufVxuICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gRGF0YSByb3cgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBuZXdDZWxsUHJvcGVydGllc09iamVjdChyb3dJbmRleCwgZGF0YU1vZGVsKSB7XG4gICAgdmFyIG1ldGFkYXRhID0gKGRhdGFNb2RlbCB8fCB0aGlzLmRhdGFNb2RlbCkuZ2V0Um93TWV0YWRhdGEocm93SW5kZXgsIG51bGwpLFxuICAgICAgICBwcm9wcyA9IHRoaXMucHJvcGVydGllcztcblxuICAgIHN3aXRjaCAodGhpcy5faW5kZXgpIHtcbiAgICAgICAgY2FzZSB0aGlzLmJlaGF2aW9yLnRyZWVDb2x1bW5JbmRleDpcbiAgICAgICAgICAgIHByb3BzID0gcHJvcHMudHJlZUhlYWRlcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHRoaXMuYmVoYXZpb3Iucm93Q29sdW1uSW5kZXg6XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzLnJvd0hlYWRlcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiAobWV0YWRhdGFbdGhpcy5uYW1lXSA9IE9iamVjdC5jcmVhdGUocHJvcHMpKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHdhcm5lZCA9IHt9O1xuXG52YXIgY29sdW1uRW51bSA9IHt9O1xuXG52YXIgY29sdW1uRW51bURlcHJlY2F0aW9uRGVzY3JpcHRvciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB3YXJuQ29sdW1uRW51bURlcHJlY2F0aW9uKCk7XG4gICAgICAgIHJldHVybiBjb2x1bW5FbnVtO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHdhcm5Db2x1bW5FbnVtRGVwcmVjYXRpb24oKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiB3YXJuQ29sdW1uRW51bURlcHJlY2F0aW9uKCkge1xuICAgIGlmICghd2FybmVkLmNvbHVtbkVudW1EZWNvcmF0b3JzKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignLmNvbHVtbkVudW1EZWNvcmF0b3JzIGFuZCAuY29sdW1uRW51bUtleSBoYXZlIGJvdGggYmVlbiBkZXByZWNhdGVkIGFzIG9mIHYzLjAuMCBhbmQgbm8gbG9uZ2VyIGhhdmUgYW55IG1lYW5pbmcuIChXaWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4pIE5vdGUgdGhhdCAuY29sdW1uRW51bSBpcyBhbHNvIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgLnNjaGVtYSwgd2hpY2ggbm93IHNlcnZlcyBhcyBhIGNvbHVtbiBlbnVtLiAoU2VlIGh0dHBzOi8vZmluLWh5cGVyZ3JpZC5naXRodWIuaW8vZG9jL2RhdGFNb2RlbC5hcGkjaW5pdFNjaGVtYS4pJyk7XG4gICAgICAgIHdhcm5lZC5jb2x1bW5FbnVtRGVjb3JhdG9ycyA9IHRydWU7XG4gICAgfVxufVxuXG5leHBvcnRzLmRlc2NyaXB0b3JzID0ge1xuICAgIGNvbHVtbkVudW06IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghd2FybmVkLmNvbHVtbkVudW0pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJy5jb2x1bW5FbnVtIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYXMgb2YgdjMuMC4wIGluIGZhdm9yIG9mIC5zY2hlbWEgKGxhcmdlbHkgY29tcGF0aWJsZSB3aXRoIHRoZSBkZXByZWNhdGVkIHByb3BlcnR5OyBzZWUgaHR0cHM6Ly9maW4taHlwZXJncmlkLmdpdGh1Yi5pby9kb2MvZGF0YU1vZGVsLmFwaSNpbml0U2NoZW1hKS4gKFdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiknKTtcbiAgICAgICAgICAgICAgICB3YXJuZWQuY29sdW1uRW51bSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWE7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbHVtbkVudW1LZXk6IGNvbHVtbkVudW1EZXByZWNhdGlvbkRlc2NyaXB0b3IsXG4gICAgY29sdW1uRW51bURlY29yYXRvcnM6IGNvbHVtbkVudW1EZXByZWNhdGlvbkRlc2NyaXB0b3Jcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHRoaXMge0NvbHVtbn1cbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKiBAbWVtYmVyT2YgQ29sdW1uI1xuICovXG5mdW5jdGlvbiBjcmVhdGVDb2x1bW5Qcm9wZXJ0aWVzKCkge1xuICAgIHZhciBjb2x1bW4gPSB0aGlzLFxuICAgICAgICBncmlkUHJvcHMgPSBjb2x1bW4uYmVoYXZpb3IuZ3JpZC5wcm9wZXJ0aWVzLFxuICAgICAgICBwcm9wZXJ0aWVzO1xuXG4gICAgcHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUoZ3JpZFByb3BzLCB7XG5cbiAgICAgICAgaW5kZXg6IHsgLy8gcmVhZC1vbmx5IChubyBzZXR0ZXIpXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW4uaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbmFtZTogeyAvLyByZWFkLW9ubHkgKG5vIHNldHRlcilcbiAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmllbGQ6IHsgLy8gcmVhZC1vbmx5IChubyBzZXR0ZXIpXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW4ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjb2x1bW5OYW1lOiB7IC8vIHJlYWQtb25seSAobm8gc2V0dGVyKVxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGVhZGVyOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW4uaGVhZGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMgIT09IGNvbHVtbi5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeWluZyB0byBzZXQgYSBjZWxsIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICBncmlkUHJvcHMuaGVhZGVyID0gaGVhZGVyOyAvLyB0aHJvdyBzYW1lIGVycm9yIGFzIHdoZW4gdHJ5aW5nIHRvIHNldCBhIGdyaWQgaGVhZGVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbHVtbi5oZWFkZXIgPSBoZWFkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uLnR5cGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMgIT09IGNvbHVtbi5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeWluZyB0byBzZXQgYSBjZWxsIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgZ3JpZFByb3BzLnR5cGUgPSB0eXBlOyAvLyB0aHJvdyBzYW1lIGVycm9yIGFzIHdoZW4gdHJ5aW5nIHRvIHNldCBhIGdyaWQgdHlwZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2x1bW4udHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2FsY3VsYXRvcjoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uLmNhbGN1bGF0b3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihjYWxjdWxhdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMgIT09IGNvbHVtbi5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeWluZyB0byBzZXQgYSBjZWxsIGNhbGN1bGF0b3JcbiAgICAgICAgICAgICAgICAgICAgZ3JpZFByb3BzLmNhbGN1bGF0b3IgPSBjYWxjdWxhdG9yOyAvLyB0aHJvdyBzYW1lIGVycm9yIGFzIHdoZW4gdHJ5aW5nIHRvIHNldCBhIGdyaWQgY2FsY3VsYXRvclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2x1bW4uY2FsY3VsYXRvciA9IGNhbGN1bGF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9ybWF0OiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnZm9ybWF0JyBpbiBjb2x1bW4uc2NoZW1hID8gY29sdW1uLnNjaGVtYS5mb3JtYXQgOiBncmlkUHJvcHMuZm9ybWF0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMgIT09IGNvbHVtbi5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCBvbiBpbnN0YW5jZSB0byBvdmVycmlkZSB0aGlzIGFjY2Vzc29yIChjb3VsZCBiZSBjZWxsIHByb3BzIG9iaiBvciBhbm9uIG9iaiBjcmVhdGVkIGJ5IHJlbmRlcmVyKVxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2Zvcm1hdCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29sdW1uLnNjaGVtYS5mb3JtYXQ7IC8vIHJlbW92ZSBjb2x1bW4gcHJvcCB0byBzbyBnZXR0ZXIgcmV0dXJucyBncmlkIHByb3BcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4uc2NoZW1hLmZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyZXI6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdyZW5kZXJlcicgaW4gY29sdW1uLnNjaGVtYSA/IGNvbHVtbi5zY2hlbWEucmVuZGVyZXIgOiBncmlkUHJvcHMucmVuZGVyZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihyZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzICE9PSBjb2x1bW4ucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgb24gaW5zdGFuY2UgdG8gb3ZlcnJpZGUgdGhpcyBhY2Nlc3NvciAoY291bGQgYmUgY2VsbCBwcm9wcyBvYmogb3IgYW5vbiBvYmogY3JlYXRlZCBieSByZW5kZXJlcilcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZW5kZXJlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZW5kZXJlclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlbmRlcmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNvbHVtbi5zY2hlbWEucmVuZGVyZXI7IC8vIHJlbW92ZSBjb2x1bW4gcHJvcCB0byBzbyBnZXR0ZXIgcmV0dXJucyBncmlkIHByb3BcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4uc2NoZW1hLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRvSlNPTjoge1xuICAgICAgICAgICAgLy8gYWx0aG91Z2ggd2UgZG9uJ3QgZ2VuZXJhbGx5IHdhbnQgdGhlc2UgdG8gYmUgZW51bWVyYWJsZSwgd2UgZG8gd2FudCB0aGVtIHRvIGJlIHNlcmlhbGl6YWJsZVxuICAgICAgICAgICAgLy8gdG9kbzogPz8/IG5vdCBzdXJlIG5vdyAoMy8xMy8yMDE4KSB3aHkgdGhlc2Ugc2hvdWxkbid0IGJlIGVudW1lcmFibGVcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcjogdGhpcy5oZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRvcjogdGhpcy5jYWxjdWxhdG9yLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IHRoaXMuZm9ybWF0LFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlcjogdGhpcy5yZW5kZXJlclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHByb3BlcnRpZXMsIHtcbiAgICAgICAgcm93SGVhZGVyOiB7IHZhbHVlOiBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXMsIGNyZWF0ZUNvbHVtblByb3BlcnRpZXMucm93SGVhZGVyRGVzY3JpcHRvcnMpIH0sXG4gICAgICAgIHRyZWVIZWFkZXI6IHsgdmFsdWU6IE9iamVjdC5jcmVhdGUocHJvcGVydGllcywgY3JlYXRlQ29sdW1uUHJvcGVydGllcy50cmVlSGVhZGVyRGVzY3JpcHRvcnMpIH0sXG4gICAgICAgIGNvbHVtbkhlYWRlcjogeyB2YWx1ZTogT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzLCBjcmVhdGVDb2x1bW5Qcm9wZXJ0aWVzLmNvbHVtbkhlYWRlckRlc2NyaXB0b3JzKSB9LFxuICAgICAgICBmaWx0ZXJQcm9wZXJ0aWVzOiB7IHZhbHVlOiBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXMsIGNyZWF0ZUNvbHVtblByb3BlcnRpZXMuZmlsdGVyRGVzY3JpcHRvcnMpIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9wZXJ0aWVzO1xufVxuXG5jcmVhdGVDb2x1bW5Qcm9wZXJ0aWVzLnRyZWVIZWFkZXJEZXNjcmlwdG9ycyA9IHtcbiAgICBmb250OiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyZWVIZWFkZXJGb250O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnRyZWVIZWFkZXJGb250ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbG9yOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyZWVIZWFkZXJDb2xvcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy50cmVlSGVhZGVyQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYmFja2dyb3VuZENvbG9yOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyZWVIZWFkZXJCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudHJlZUhlYWRlckJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlSGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkZvbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudHJlZUhlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Gb250ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlSGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnRyZWVIZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyZXI6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJlZVJlbmRlcmVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnRyZWVSZW5kZXJlciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJlZUhlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy50cmVlSGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy9sZWZ0SWNvbjogdW5kZWZpbmVkXG59O1xuXG5jcmVhdGVDb2x1bW5Qcm9wZXJ0aWVzLnJvd0hlYWRlckRlc2NyaXB0b3JzID0ge1xuICAgIGZvbnQ6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyRm9udDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5yb3dIZWFkZXJGb250ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbG9yOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0hlYWRlckNvbG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnJvd0hlYWRlckNvbG9yID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJhY2tncm91bmRDb2xvcjoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dIZWFkZXJCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucm93SGVhZGVyQmFja2dyb3VuZENvbG9yID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGZvcmVncm91bmRTZWxlY3Rpb25Gb250OiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0hlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Gb250O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnJvd0hlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Gb250ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dIZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucm93SGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dIZWFkZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucm93SGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGxlZnRJY29uOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWQucHJvcGVydGllcy5yb3dIZWFkZXJDaGVja2JveGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0RhdGFSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5pc1Jvd1NlbGVjdGVkID8gJ2NoZWNrZWQnIDogJ3VuY2hlY2tlZCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzSGVhZGVyUm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuYWxsUm93c1NlbGVjdGVkID8gJ2NoZWNrZWQnIDogJ3VuY2hlY2tlZCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzRmlsdGVyUm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICdmaWx0ZXItb2ZmJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgLy8gcmVwbGFjZSBzZWxmIHdpdGggYSBzaW1wbGUgaW5zdGFuY2UgdmFyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2xlZnRJY29uJywge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jcmVhdGVDb2x1bW5Qcm9wZXJ0aWVzLmZpbHRlckRlc2NyaXB0b3JzID0ge1xuICAgIGZvbnQ6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyRm9udDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJGb250ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbG9yOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlckNvbG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlckNvbG9yID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJhY2tncm91bmRDb2xvcjoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyQmFja2dyb3VuZENvbG9yID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGhhbGlnbjoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJIYWxpZ247XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVySGFsaWduID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcmVyOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlclJlbmRlcmVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlclJlbmRlcmVyID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGVkaXRvcjoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJFZGl0b3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyRWRpdG9yID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJpZ2h0SWNvbjoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyYWJsZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyID8gJ2ZpbHRlci1vbicgOiAnZmlsdGVyLW9mZic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyByZXBsYWNlIHNlbGYgd2l0aCBhIHNpbXBsZSBpbnN0YW5jZSB2YXJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmlnaHRJY29uJywge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jcmVhdGVDb2x1bW5Qcm9wZXJ0aWVzLmNvbHVtbkhlYWRlckRlc2NyaXB0b3JzID0ge1xuICAgIGZvbnQ6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyRm9udDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5IZWFkZXJGb250ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbG9yOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkhlYWRlckNvbG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckNvbG9yID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJhY2tncm91bmRDb2xvcjoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZENvbG9yID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGZvcmVncm91bmRTZWxlY3Rpb25Gb250OiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkhlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Gb250O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Gb250ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uSGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGhhbGlnbjoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJIYWxpZ247XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uSGVhZGVySGFsaWduID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcmVyOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkhlYWRlclJlbmRlcmVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlclJlbmRlcmVyID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGxlZnRJY29uOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkfSxcbiAgICBjZW50ZXJJY29uOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkfSxcbiAgICByaWdodEljb246IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWR9LFxufTtcblxuLyoqXG4gKiBDb2x1bW4uanMgbWl4ZXMgdGhpcyBtb2R1bGUgaW50byBpdHMgcHJvdG90eXBlLlxuICogQG1peGluXG4gKi9cbmV4cG9ydHMubWl4aW4gPSB7XG4gICAgY3JlYXRlQ29sdW1uUHJvcGVydGllczogY3JlYXRlQ29sdW1uUHJvcGVydGllc1xufTtcbiIsIi8qIGdsb2JhbHMgQ3VzdG9tRXZlbnQgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaG9va3MgPSByZXF1aXJlKCcuJyk7XG52YXIgZmFsbGJhY2tzID0gcmVxdWlyZSgnLi9mYWxsYmFja3MnKTtcbnZhciBIeXBlcmdyaWRFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2xpYi9lcnJvcicpO1xuXG5cbnZhciB3YXJuZWQgPSB7fTtcblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAdGhpcyB7TG9jYWx9XG4gKiBAcGFyYW0ge2RhdGFNb2RlbEFQSX0gZGF0YU1vZGVsXG4gKi9cbmZ1bmN0aW9uIGFkZFBvbHlmaWxscyhkYXRhTW9kZWwpIHtcbiAgICBpZiAoIWRhdGFNb2RlbC5pbnN0YWxsKSB7XG4gICAgICAgIGRhdGFNb2RlbC5pbnN0YWxsID0gZnVuY3Rpb24oYXBpLCBmYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKGZhbGxiYWNrICYmICFBcnJheS5pc0FycmF5KGFwaSkpIHtcbiAgICAgICAgICAgICAgICBhcGkgPSBhcGkgfHwgdGhpcztcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhhcGkpLmZpbHRlcihmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcGlba2V5XSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gYXBpW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogSW5qZWN0IGZhbGxiYWNrIG1ldGhvZHMgaW50byBkYXRhIG1vZGVsIHdoZW4gbm90IGltcGxlbWVudGVkIGJ5IGRhdGEgbW9kZWwuXG4gKiBBbHNvIGFkZHMgYGRpc3BhdGNoRXZlbnRgLCBjYWxsZWQgYnkgZGF0YSBtb2RlbCB0byBjb21tdW5pY2F0ZSBiYWNrIHRvIEh5cGVyZ3JpZC5cbiAqIChIeXBlcmdyaWQgaXRzZWxmIG5ldmVyIGNhbGxzIGBkaXNwYXRjaEV2ZW50YCBvbiB0aGUgZGF0YSBtb2RlbC4pXG4gKiBAdGhpcyB7TG9jYWx9XG4gKiBAcGFyYW0ge2RhdGFNb2RlbEFQSX0gZGF0YU1vZGVsXG4gKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkRmFsbGJhY2tzKGRhdGFNb2RlbCwgZ3JpZCkge1xuICAgIGRhdGFNb2RlbC5pbnN0YWxsKGZhbGxiYWNrcywgdHJ1ZSk7XG4gICAgZGF0YU1vZGVsLmluc3RhbGwoeyBkaXNwYXRjaEV2ZW50OiBkaXNwYXRjaEV2ZW50LmJpbmQoZ3JpZCkgfSwgdHJ1ZSk7XG59XG5cbnZhciBSRUdFWF9EQVRBX0VWRU5UX1NUUklORyA9IC9eZGF0YSgtW2Etel0rKSskLztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHRoaXMge0h5cGVyZ3JpZH1cbiAqIEBwYXJhbSBldmVudE5hbWVcbiAqIEBwYXJhbSBldmVudERldGFpbFxuICovXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50TmFtZSwgZXZlbnREZXRhaWwpIHtcbiAgICBpZiAoIVJFR0VYX0RBVEFfRVZFTlRfU1RSSU5HLnRlc3QoZXZlbnROYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgSHlwZXJncmlkRXJyb3IoJ0V4cGVjdGVkIGRhdGEgZXZlbnQgc3RyaW5nIHRvIG1hdGNoICcgKyBSRUdFWF9EQVRBX0VWRU5UX1NUUklORyArICcuJyk7XG4gICAgfVxuICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdmaW4tY2FudmFzLScgKyBldmVudE5hbWUsIGV2ZW50RGV0YWlsKSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEB0aGlzIHtMb2NhbH1cbiAqL1xuZnVuY3Rpb24gYWRkRGVwcmVjYXRpb25XYXJuaW5ncygpIHtcbiAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZDtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmRhdGFNb2RlbCwgJ2dyaWQnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXdhcm5lZC5ncmlkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdgdGhpcy5ncmlkYCAoZGF0YU1vZGVsLmdyaWQpIHByb3BlcnR5IGhhcyBiZWVuIGRlcHJlY2F0ZWQgYXMgb2YgdjMuMC4wIGFuZCB3aWxsIGRlZmluaXRlbHkgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiBEYXRhIG1vZGVscyBzaG91bGQgaGF2ZSBubyBkaXJlY3Qga25vd2xlZGdlIG9mIG9yIGFjY2VzcyB0byB0aGUgZ3JpZC4gKElmIHlvdXIgZGF0YSBtb2RlbCBuZWVkcyB0byBjYWxsIGdyaWQgbWV0aG9kcywgYWRkIGEgZGF0YSBldmVudCB0byB5b3VyIGdyaWQgd2l0aCBncmlkLmFkZERhdGFFdmVudExpc3RlbmVyKFxcJ2RhdGEtbXktZXZlbnRcXCcsIG15SGFuZGxlcikgYW5kIHRyaWdnZXIgaXQgZnJvbSB5b3VyIGRhdGEgbW9kZWwgd2l0aCB0aGlzLmRpc3BhdGNoRXZlbnQoXFwnZGF0YS1teS1ldmVudFxcJykuIElmIHlvdSBuZWVkIGFjY2VzcyB0byB0aGUgZ3JpZCBvYmplY3QgZnJvbSB3aXRoaW4gYSBgZ2V0Q2VsbGAgb3IgYGdldENlbGxFZGl0QXRgIG92ZXJyaWRlLCBkZWZpbmUgYGdyaWRgIGFuZCB0aGUgb3ZlcnJpZGUgaW4gYSBjbG9zdXJlLiknKTtcbiAgICAgICAgICAgICAgICB3YXJuZWQuZ3JpZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ3JpZDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuZGF0YU1vZGVsLmRhdGFTb3VyY2UpIHtcbiAgICAgICAgaWYgKCF3YXJuZWQuZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdBcyBvZiBIeXBlcmdyaWQgMy4wLjAsIHRoZSBleHRlcm5hbCBkYXRhIG1vZGVsIGlzIG5vdyBgZ3JpZC5iZWhhdmlvci5kYXRhTW9kZWxgLiBGb3JtZXJseSwgaXQgd2FzIGBncmlkLmJlaGF2aW9yLmRhdGFNb2RlbC5kYXRhU291cmNlYC4gRGF0YSBtb2RlbCBhdXRob3JzIGFyZSBzdHJvbmdseSBhZHZpc2VkIHRvIGF2b2lkIGltcGxlbWVudGluZyBhIGAuZGF0YVNvdXJjZWAgcHJvcGVydHkgaW5zaWRlIHRoZWlyIGRhdGEgbW9kZWwgdG8gcmVkdWNlIHRoZSBjb25mdXNpb24gdGhhdCB3b3VsZCByZXN1bHQgaWYgYSBsZWdhY3kgYXBwbGljYXRpb24gd2VyZSB0byB0cnkgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG1vZGVsIHZpYSBgLmRhdGFNb2RlbC5kYXRhU291cmNlYCBhbmQgZ2V0IHNvbWV0aGluZyB1bmV4cGVjdGVkIGluc3RlYWQgb2YgYW4gZXJyb3IuKScpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBmb3IgYXBwIGxheWVyIGFjY2VzcyB0byBkcmlsbCBkb3duIGNoYXJzLCBwcm92aWRlIGZyaWVuZGxpZXIga2V5cyB0aGFuIGRhdGEgbW9kZWwgbm9ybWFsbHkgc3VwcG9ydHMgaW4gYGRyaWxsRG93bkNoYXJNYXBgLlxudmFyIGZyaWVuZGxpZXJEcmlsbERvd25NYXBLZXlzID0ge1xuICAgIHRydWU6ICdPUEVOJyxcbiAgICBmYWxzZTogJ0NMT1NFJyxcbiAgICBudWxsOiAnSU5ERU5UJ1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHRoaXMge0xvY2FsfVxuICovXG5mdW5jdGlvbiBhZGRGcmllbmRsaWVyRHJpbGxEb3duTWFwS2V5cygpIHtcbiAgICB2YXIgY2hhck1hcCA9IHRoaXMuZGF0YU1vZGVsLmRyaWxsRG93bkNoYXJNYXA7XG4gICAgaWYgKGNoYXJNYXApIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZnJpZW5kbGllckRyaWxsRG93bk1hcEtleXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIGNoYXJNYXApIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJpZW5kbGllcktleSA9IGZyaWVuZGxpZXJEcmlsbERvd25NYXBLZXlzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKCEoZnJpZW5kbGllcktleSBpbiBjaGFyTWFwKSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2hhck1hcCwgZnJpZW5kbGllcktleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXNba2V5XTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24ocykgeyB0aGlzW2tleV0gPSBzOyB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2RhdGFNb2RlbEFQSX0gZGF0YU1vZGVsXG4gKiBAdGhpcyB7TG9jYWx9XG4gKi9cbmZ1bmN0aW9uIGFkZERlZmF1bHRIb29rcyhkYXRhTW9kZWwpIHtcbiAgICBpZiAoIWRhdGFNb2RlbC5nZXRDZWxsKSB7XG4gICAgICAgIGRhdGFNb2RlbC5nZXRDZWxsID0gaG9va3MuZ2V0Q2VsbDtcbiAgICB9XG5cbiAgICBpZiAoIWRhdGFNb2RlbC5nZXRDZWxsRWRpdG9yQXQpIHtcbiAgICAgICAgZGF0YU1vZGVsLmdldENlbGxFZGl0b3JBdCA9IGhvb2tzLmdldENlbGxFZGl0b3JBdDtcbiAgICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYWRkUG9seWZpbGxzOiBhZGRQb2x5ZmlsbHMsXG4gICAgYWRkRmFsbGJhY2tzOiBhZGRGYWxsYmFja3MsXG4gICAgYWRkRGVwcmVjYXRpb25XYXJuaW5nczogYWRkRGVwcmVjYXRpb25XYXJuaW5ncyxcbiAgICBhZGRGcmllbmRsaWVyRHJpbGxEb3duTWFwS2V5czogYWRkRnJpZW5kbGllckRyaWxsRG93bk1hcEtleXMsXG4gICAgYWRkRGVmYXVsdEhvb2tzOiBhZGREZWZhdWx0SG9va3Ncbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG1vZHVsZSBmYWxsYmFja3NcbiAqXG4gKiBAZGVzYyB7QGxpbmsgQmVoYXZpb3IjcmVzZXREYXRhTW9kZWwgcmVzZXREYXRhTW9kZWwoKX0gaW5zZXJ0cyBlYWNoIG9mIHRoZXNlIGNhdGNoZXIgbWV0aG9kcyBpbnRvIHRoZSBuZXcgZGF0YSBtb2RlbCB3aGVuIG5vdCBvdGhlcndpc2UgaW1wbGVtZW50ZWQsIHdoaWNoIGFsbG93cyBIeXBlcmdyaWQgdG8gaW5kaXNjcmltaW5hdGVseSBjYWxsIHRoZXNlIG90aGVyd2lzZSBtaXNzaW5nIG1ldGhvZHMgb24gdGhlIGRhdGEgbW9kZWwgd2l0aG91dCBmZWFyIG9mIHRoZSBjYWxsIGZhaWxpbmcuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qKiBAaW1wbGVtZW50cyBkYXRhTW9kZWxBUEkjYXBwbHkgKi9cbiAgICBhcHBseTogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKiBAaW1wbGVtZW50cyBkYXRhTW9kZWxBUEkjaXNEcmlsbERvd24gKi9cbiAgICBpc0RyaWxsRG93bjogZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfSxcblxuICAgIC8qKiBAaW1wbGVtZW50cyBkYXRhTW9kZWxBUEkjY2xpY2sgKi9cbiAgICBjbGljazogZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfSxcblxuICAgIC8qKiBAaW1wbGVtZW50cyBkYXRhTW9kZWxBUEkjZ2V0Q29sdW1uQ291bnQgKi9cbiAgICBnZXRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjaGVtYSgpLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqIEBpbXBsZW1lbnRzIGRhdGFNb2RlbEFQSSNnZXRSb3cgKi9cbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdGhpcy5kYXRhUm93UHJveHkuJHkkID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVJvd1Byb3h5O1xuICAgIH0sXG5cbiAgICAvKiogQGltcGxlbWVudHMgZGF0YU1vZGVsQVBJI2dldERhdGEgKi9cbiAgICBnZXREYXRhOiBmdW5jdGlvbihtZXRhZGF0YUZpZWxkTmFtZSkge1xuICAgICAgICB2YXIgeSwgWSA9IHRoaXMuZ2V0Um93Q291bnQoKSxcbiAgICAgICAgICAgIHJvdywgcm93cyA9IG5ldyBBcnJheShZKSxcbiAgICAgICAgICAgIG1ldGFkYXRhO1xuXG4gICAgICAgIGZvciAoeSA9IDA7IHkgPCBZOyB5KyspIHtcbiAgICAgICAgICAgIHJvdyA9IHRoaXMuZGF0YVt5XTsgLy8gZG8gbm90IHVzZSBnZXRSb3cgYmVjYXVzZSBvZiB0cmVlIGxldmVsc1xuICAgICAgICAgICAgaWYgKHJvdykge1xuICAgICAgICAgICAgICAgIHJvd3NbeV0gPSBPYmplY3QuYXNzaWduKHt9LCByb3cpO1xuICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YUZpZWxkTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IHRoaXMuZ2V0Um93TWV0YWRhdGEoeSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93c1t5XVttZXRhZGF0YUZpZWxkTmFtZV0gPSBtZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByb3dzO1xuICAgIH0sXG5cbiAgICBzZXREYXRhOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIC8vIGZhaWwgc2lsZW50bHkgYmVjYXVzZSBMb2NhbC5qczo6c2V0RGF0YSBjdXJyZW50bHkgY2FsbHMgdGhpcyBmb3IgZXZlcnkgc3ViZ3JpZFxuICAgIH0sXG5cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdkYXRhTW9kZWwuc2V0VmFsdWUoJyArIHggKyAnLCAnICsgeSArICcsIFwiJyArIHZhbHVlICsgJ1wiKSBjYWxsZWQgYnV0IG5vIGltcGxlbWVudGF0aW9uLiBEYXRhIG5vdCBzYXZlZC4nKTtcbiAgICB9LFxuXG4gICAgLyoqIEBpbXBsZW1lbnRzIGRhdGFNb2RlbEFQSSNnZXRSb3dJbmRleCAqL1xuICAgIGdldFJvd0luZGV4OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB5O1xuICAgIH0sXG5cbiAgICAvKiogQGltcGxlbWVudHMgZGF0YU1vZGVsQVBJI2dldFJvd01ldGFkYXRhICovXG4gICAgZ2V0Um93TWV0YWRhdGE6IGZ1bmN0aW9uKHksIHByb3RvdHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YVt5XSB8fCBwcm90b3R5cGUgIT09IHVuZGVmaW5lZCAmJiAodGhpcy5tZXRhZGF0YVt5XSA9IE9iamVjdC5jcmVhdGUocHJvdG90eXBlKSk7XG4gICAgfSxcblxuICAgIC8qKiBAaW1wbGVtZW50cyBkYXRhTW9kZWxBUEkjZ2V0TWV0YWRhdGFTdG9yZSAqL1xuICAgIGdldE1ldGFkYXRhU3RvcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YTtcbiAgICB9LFxuXG4gICAgLyoqIEBpbXBsZW1lbnRzIGRhdGFNb2RlbEFQSSNzZXRSb3dNZXRhZGF0YSAqL1xuICAgIHNldFJvd01ldGFkYXRhOiBmdW5jdGlvbih5LCBtZXRhZGF0YSkge1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGFbeV0gPSBtZXRhZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1ldGFkYXRhW3ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9LFxuXG4gICAgLyoqIEBpbXBsZW1lbnRzIGRhdGFNb2RlbEFQSSNzZXRNZXRhZGF0YVN0b3JlICovXG4gICAgc2V0TWV0YWRhdGFTdG9yZTogZnVuY3Rpb24obmV3TWV0YWRhdGFTdG9yZSkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbmV3TWV0YWRhdGFTdG9yZSB8fCBbXTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbi8qKlxuICogQ3VzdG9tIGltcGxlbWVudGF0aW9ucyBzaG91bGQgcmV0dXJuIHdpdGggYSBjYWxsIHRvIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uOlxuICogYGBganNcbiAqIHZhciBnZXRDZWxsID0gcmVxdWlyZSgnZmluLWh5cGVyZ3JpZC9zcmMvYmVoYXZpb3JzL2RhdGFNb2RlbCcpLmdldENlbGw7XG4gKiBmdW5jdGlvbiBteUN1c3RvbUdldENlbGwoY29uZmlnLCByZW5kZXJlck5hbWUpIHtcbiAqICAgICAvLyBjdXN0b20gbG9naWMgaGVyZSB0aGF0IG11dGF0ZXMgY29uZmlnIGFuZC9vciByZW5kZXJOYW1lXG4gKiAgICAgcmV0dXJuIGdldENlbGwoY29uZmlnLCByZW5kZXJlck5hbWUpO1xuICogfVxuICogYGBgXG4gKiBBbHRlcm5hdGl2ZWx5LCBjb3B5IGluIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGJvZHkgKGEgb25lLWxpbmVyKTpcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbiBteUN1c3RvbUdldENlbGwoY29uZmlnLCByZW5kZXJlck5hbWUpIHtcbiAqICAgICAvLyBjdXN0b20gbG9naWMgaGVyZSB0aGF0IG11dGF0ZXMgY29uZmlnIGFuZC9vciByZW5kZXJOYW1lXG4gKiAgICAgcmV0dXJuIGNvbmZpZy5ncmlkLmNlbGxSZW5kZXJlcnMuZ2V0KHJlbmRlcmVyTmFtZSk7XG4gKiB9XG4gKiBgYGBcbiAqIEBpbXBsZW1lbnRzIHtkYXRhTW9kZWxBUEkjZ2V0Q2VsbH1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6ZGF0YU1vZGVsXG4gKi9cbmV4cG9ydHMuZ2V0Q2VsbCA9IGZ1bmN0aW9uKGNvbmZpZywgcmVuZGVyZXJOYW1lKSB7XG4gICAgcmV0dXJuIGNvbmZpZy5ncmlkLmNlbGxSZW5kZXJlcnMuZ2V0KHJlbmRlcmVyTmFtZSk7XG59O1xuXG5cbi8qKlxuICogQ3VzdG9tIGltcGxlbWVudGF0aW9ucyBzaG91bGQgcmV0dXJuIHdpdGggYSBjYWxsIHRvIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uOlxuICogYGBganNcbiAqIHZhciBnZXRDZWxsRWRpdG9yQXQgPSByZXF1aXJlKCdmaW4taHlwZXJncmlkL3NyYy9iZWhhdmlvcnMvZGF0YU1vZGVsJykuZ2V0Q2VsbEVkaXRvckF0O1xuICogZnVuY3Rpb24gbXlDdXN0b21HZXRDZWxsRWRpdG9yQXQoY29sdW1uSW5kZXgsIHJvd0luZGV4LCBlZGl0b3JOYW1lLCBjZWxsRXZlbnQpIHtcbiAqICAgICAvLyBjdXN0b20gbG9naWMgaGVyZSwgbWF5IG11dGF0ZSBjb25maWcgYW5kL29yIHJlbmRlck5hbWVcbiAqICAgICByZXR1cm4gZ2V0Q2VsbEVkaXRvckF0KGNvbHVtbkluZGV4LCByb3dJbmRleCwgZWRpdG9yTmFtZSwgY2VsbEV2ZW50KTtcbiAqIH1cbiAqIGBgYFxuICogQWx0ZXJuYXRpdmVseSwgY29weSBpbiB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBib2R5IChhIG9uZS1saW5lcik6XG4gKiBgYGBqc1xuICogZnVuY3Rpb24gbXlDdXN0b21HZXRDZWxsRWRpdG9yQXQoY29sdW1uSW5kZXgsIHJvd0luZGV4LCBlZGl0b3JOYW1lLCBjZWxsRXZlbnQpIHtcbiAqICAgICAvLyBjdXN0b20gbG9naWMgaGVyZSwgbWF5IG11dGF0ZSBlZGl0b3JOYW1lXG4gKiAgICAgcmV0dXJuIGNlbGxFdmVudC5ncmlkLmNlbGxFZGl0b3JzLmNyZWF0ZShlZGl0b3JOYW1lLCBjZWxsRXZlbnQpO1xuICogfVxuICogYGBgXG4gKiBAaW1wbGVtZW50cyB7ZGF0YU1vZGVsQVBJI2dldENlbGxFZGl0b3JBdH1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6ZGF0YU1vZGVsXG4gKi9cbmV4cG9ydHMuZ2V0Q2VsbEVkaXRvckF0ID0gZnVuY3Rpb24oY29sdW1uSW5kZXgsIHJvd0luZGV4LCBlZGl0b3JOYW1lLCBjZWxsRXZlbnQpIHtcbiAgICByZXR1cm4gY2VsbEV2ZW50LmdyaWQuY2VsbEVkaXRvcnMuY3JlYXRlKGVkaXRvck5hbWUsIGNlbGxFdmVudCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIG1vZHVsZSBpcyBwcm92aWRlZCBzb2xlbHkgaW4gc3VwcG9ydCBvZiBidWlsZCBmaWxlIHVzYWdlLCBlLmcuLCBgZmluLkh5cGVyZ3JpZC5yZXF1aXJlKCdmaW4taHlwZXJncmlkL3NyYy9iZWhhdmlvcnMvd2hhdGV2ZXInKWAsXG4vLyBhbmQgaXMgbm90IG1lYW50IHRvIGJlIHVzZWQgZWxzZXdoZXJlLlxuXG52YXIgd2FybmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBCZWhhdmlvcjogcmVxdWlyZSgnLi9CZWhhdmlvcicpLFxuICAgIExvY2FsOiByZXF1aXJlKCcuL0xvY2FsJyksXG4gICAgQ29sdW1uOiByZXF1aXJlKCcuL0NvbHVtbicpLFxuICAgIGRhdGFNb2RlbDogcmVxdWlyZSgnLi9kYXRhTW9kZWwnKSxcblxuICAgIGdldCBKU09OKCkge1xuICAgICAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCcuL3NyYy9iZWhhdmlvcnMvSlNPTiBoYXMgYmVlbiByZW5hbWVkIHRvIExvY2FsIGFzIG9mIHYzLjAuMC4gKFdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiknKTtcbiAgICAgICAgfVxuICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVxdWlyZSgnLi9Mb2NhbCcpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMubWl4aW4gPSB7XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgVGhlIHRvdGFsIGhlaWdodCBvZiB0aGUgXCJmaXhlZCByb3dzLlwiXG4gICAgICogQGRlc2MgVGhlIHRvdGFsIGhlaWdodCBvZiBhbGwgKG5vbi1zY3JvbGxhYmxlKSByb3dzIHByZWNlZGluZyB0aGUgKHNjcm9sbGFibGUpIGRhdGEgc3ViZ3JpZC5cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaGVpZ2h0IGluIHBpeGVscyBvZiB0aGUgZml4ZWQgcm93cyBhcmVhIG9mIHRoZSBoeXBlcmdyaWQsIHRoZSB0b3RhbCBoZWlnaHQgb2Y6XG4gICAgICogMS4gQWxsIHJvd3Mgb2YgYWxsIHN1YmdyaWRzIHByZWNlZGluZyB0aGUgZGF0YSBzdWJncmlkLlxuICAgICAqIDIuIFRoZSBmaXJzdCBgZml4ZWRSb3dDb3VudGAgcm93cyBvZiB0aGUgZGF0YSBzdWJncmlkLlxuICAgICAqL1xuICAgIGdldEZpeGVkUm93c0hlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdWJncmlkLCBpc0RhdGEsIHIsIFIsXG4gICAgICAgICAgICBzdWJncmlkcyA9IHRoaXMuc3ViZ3JpZHMsXG4gICAgICAgICAgICBoZWlnaHQgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ViZ3JpZHMubGVuZ3RoICYmICFpc0RhdGE7ICsraSkge1xuICAgICAgICAgICAgc3ViZ3JpZCA9IHN1YmdyaWRzW2ldO1xuICAgICAgICAgICAgaXNEYXRhID0gc3ViZ3JpZC5pc0RhdGE7XG4gICAgICAgICAgICBSID0gaXNEYXRhID8gdGhpcy5ncmlkLnByb3BlcnRpZXMuZml4ZWRSb3dDb3VudCA6IHN1YmdyaWQuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgICAgIGZvciAociA9IDA7IHIgPCBSOyArK3IpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgKz0gdGhpcy5nZXRSb3dIZWlnaHQociwgc3ViZ3JpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBUaGUgdG90YWwgaGVpZ2h0IG9mIHRoZSBcImRhdGEgcm93cy5cIlxuICAgICAqIEBkZXNjIFRoZSB0b3RhbCBoZWlnaHQgb2YgYWxsIHJvd3MgcHJlY2VkaW5nIHRoZSAoc2Nyb2xsYWJsZSkgZGF0YSBzdWJncmlkLlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBoZWlnaHQgaW4gcGl4ZWxzIG9mIHRoZSBkYXRhIHJvd3MgYXJlYSBvZiB0aGUgaHlwZXJncmlkLCB0aGUgdG90YWwgaGVpZ2h0IG9mOlxuICAgICAqIDEuIEFsbCByb3dzIG9mIGFsbCBzdWJncmlkcyBwcmVjZWRpbmcgdGhlIGRhdGEgc3ViZ3JpZC5cbiAgICAgKiAyLiBUaGUgdmlzaWJsZSBkYXRhIHJvd3Mgb2YgdGhlIGRhdGEgc3ViZ3JpZC5cbiAgICAgKi9cbiAgICBnZXRSb3dzSGVpZ2h0OiBmdW5jdGlvbih0b1kpIHtcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7XG5cbiAgICAgICAgdGhpcy5zdWJncmlkcy5mb3JFYWNoKHN1YmdyaWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWF4Um93Q291bnQgPSBzdWJncmlkLmdldFJvd0NvdW50KCk7XG4gICAgICAgICAgICBjb25zdCBSID0gdG9ZID09PSB1bmRlZmluZWQgfHwgdG9ZID4gbWF4Um93Q291bnQgPyBtYXhSb3dDb3VudCA6IHRvWTtcbiAgICAgICAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgUjsgKytyKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ICs9IHRoaXMuZ2V0Um93SGVpZ2h0KHIsIHN1YmdyaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQHBhcmFtIHtudW1iZXJ8Q2VsbEV2ZW50fSB5T3JDZWxsRXZlbnQgLSBEYXRhIHJvdyBpbmRleCBsb2NhbCB0byBgZGF0YU1vZGVsYDsgb3IgYSBgQ2VsbEV2ZW50YCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcHJvdG90eXBlXSAtIFByb3RvdHlwZSBmb3IgYSBuZXcgcHJvcGVydGllcyBvYmplY3Qgd2hlbiBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdC4gSWYgeW91IGRvbid0IGRlZmluZSB0aGlzIGFuZCBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdCwgdGhpcyBjYWxsIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgLlxuICAgICAqIFR5cGljYWwgZGVmaW5lZCB2YWx1ZSBpcyBgbnVsbGAsIHdoaWNoIGNyZWF0ZXMgYSBwbGFpbiBvYmplY3Qgd2l0aCBubyBwcm90b3R5cGUsIG9yIGBPYmplY3QucHJvdG90eXBlYCBmb3IgYSBtb3JlIFwibmF0dXJhbFwiIG9iamVjdC5cbiAgICAgKiBfKFJlcXVpcmVkIHdoZW4gM3JkIHBhcmFtIHByb3ZpZGVkLilfXG4gICAgICogQHBhcmFtIHtkYXRhTW9kZWxBUEl9IFtkYXRhTW9kZWw9dGhpcy5kYXRhTW9kZWxdIC0gVGhpcyBpcyB0aGUgc3ViZ3JpZC4gWW91IG9ubHkgbmVlZCB0byBwcm92aWRlIHRoZSBzdWJncmlkIHdoZW4gaXQgaXMgbm90IHRoZSBkYXRhIHN1YmdyaWQgX2FuZF8geW91IGRpZCBub3QgZ2l2ZSBhIGBDZWxsRXZlbnRgIG9iamVjdCBpbiB0aGUgZmlyc3QgcGFyYW0gKHdoaWNoIGFscmVhZHkga25vd3Mgd2hhdCBzdWJncmlkIGl0J3MgaW4pLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R8dW5kZWZpbmVkfSBUaGUgcm93IHByb3BlcnRpZXMgb2JqZWN0IHdoaWNoIHdpbGwgYmUgb25lIG9mOlxuICAgICAqICogb2JqZWN0IC0gZXhpc3Rpbmcgcm93IHByb3BlcnRpZXMgb2JqZWN0IG9yIG5ldyByb3cgcHJvcGVydGllcyBvYmplY3QgY3JlYXRlZCBmcm9tIGBwcm90b3R5cGVgOyBlbHNlXG4gICAgICogKiBgZmFsc2VgIC0gcm93IGZvdW5kIGJ1dCBubyBleGlzdGluZyByb3cgcHJvcGVydGllcyBvYmplY3QgYW5kIGBwcm90b3R5cGVgIHdhcyBub3QgZGVmaW5lZDsgZWxzZVxuICAgICAqICogYHVuZGVmaW5lZGAgLSBubyBzdWNoIHJvd1xuICAgICAqL1xuICAgIGdldFJvd1Byb3BlcnRpZXM6IGZ1bmN0aW9uKHlPckNlbGxFdmVudCwgcHJvdG90eXBlLCBkYXRhTW9kZWwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB5T3JDZWxsRXZlbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBkYXRhTW9kZWwgPSB5T3JDZWxsRXZlbnQuc3ViZ3JpZDtcbiAgICAgICAgICAgIHlPckNlbGxFdmVudCA9IHlPckNlbGxFdmVudC5kYXRhQ2VsbC55O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1ldGFkYXRhID0gKGRhdGFNb2RlbCB8fCB0aGlzLmRhdGFNb2RlbCkuZ2V0Um93TWV0YWRhdGEoeU9yQ2VsbEV2ZW50LCBwcm90b3R5cGUgJiYgbnVsbCk7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YSAmJiAobWV0YWRhdGEuX19ST1cgfHwgcHJvdG90eXBlICE9PSB1bmRlZmluZWQgJiYgKG1ldGFkYXRhLl9fUk9XID0gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSByb3cgcHJvcGVydGllcyBpbiBpdHMgZW50aXJldHkgdG8gdGhlIGdpdmVuIHJvdyBwcm9wZXJ0aWVzIG9iamVjdC5cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQHBhcmFtIHtudW1iZXJ8Q2VsbEV2ZW50fSB5T3JDZWxsRXZlbnQgLSBEYXRhIHJvdyBpbmRleCBsb2NhbCB0byBgZGF0YU1vZGVsYDsgb3IgYSBgQ2VsbEV2ZW50YCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMgLSBUaGUgbmV3IHJvdyBwcm9wZXJ0aWVzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2RhdGFNb2RlbEFQSX0gW2RhdGFNb2RlbD10aGlzLmRhdGFNb2RlbF0gLSBUaGlzIGlzIHRoZSBzdWJncmlkLiBZb3Ugb25seSBuZWVkIHRvIHByb3ZpZGUgdGhlIHN1YmdyaWQgd2hlbiBpdCBpcyBub3QgdGhlIGRhdGEgc3ViZ3JpZCBfYW5kXyB5b3UgZGlkIG5vdCBnaXZlIGEgYENlbGxFdmVudGAgb2JqZWN0IGluIHRoZSBmaXJzdCBwYXJhbSAod2hpY2ggYWxyZWFkeSBrbm93cyB3aGF0IHN1YmdyaWQgaXQncyBpbikuXG4gICAgICovXG4gICAgc2V0Um93UHJvcGVydGllczogZnVuY3Rpb24oeU9yQ2VsbEV2ZW50LCBwcm9wZXJ0aWVzLCBkYXRhTW9kZWwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB5T3JDZWxsRXZlbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBkYXRhTW9kZWwgPSB5T3JDZWxsRXZlbnQuc3ViZ3JpZDtcbiAgICAgICAgICAgIHlPckNlbGxFdmVudCA9IHlPckNlbGxFdmVudC5kYXRhQ2VsbC55O1xuICAgICAgICB9XG5cbiAgICAgICAgKGRhdGFNb2RlbCB8fCB0aGlzLmRhdGFNb2RlbCkuZ2V0Um93TWV0YWRhdGEoeU9yQ2VsbEV2ZW50LCBudWxsKS5fX1JPVyA9IHByb3BlcnRpZXM7XG5cbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHNpbmdsZSByb3cgcHJvcGVydHkgb24gYSBzcGVjaWZpYyBpbmRpdmlkdWFsIHJvdy5cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQHBhcmFtIHtudW1iZXJ8Q2VsbEV2ZW50fSB5T3JDZWxsRXZlbnQgLSBEYXRhIHJvdyBpbmRleCBsb2NhbCB0byBgZGF0YU1vZGVsYDsgb3IgYSBgQ2VsbEV2ZW50YCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBwcm9wZXJ0eSBuYW1lLlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBuZXcgcHJvcGVydHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHtkYXRhTW9kZWxBUEl9IFtkYXRhTW9kZWw9dGhpcy5kYXRhTW9kZWxdIC0gVGhpcyBpcyB0aGUgc3ViZ3JpZC4gWW91IG9ubHkgbmVlZCB0byBwcm92aWRlIHRoZSBzdWJncmlkIHdoZW4gaXQgaXMgbm90IHRoZSBkYXRhIHN1YmdyaWQgX2FuZF8geW91IGRpZCBub3QgZ2l2ZSBhIGBDZWxsRXZlbnRgIG9iamVjdCBpbiB0aGUgZmlyc3QgcGFyYW0gKHdoaWNoIGFscmVhZHkga25vd3Mgd2hhdCBzdWJncmlkIGl0J3MgaW4pLlxuICAgICAqL1xuICAgIHNldFJvd1Byb3BlcnR5OiBmdW5jdGlvbih5T3JDZWxsRXZlbnQsIGtleSwgdmFsdWUsIGRhdGFNb2RlbCkge1xuICAgICAgICB0aGlzLmdldFJvd1Byb3BlcnRpZXMoeU9yQ2VsbEV2ZW50LCBudWxsLCBkYXRhTW9kZWwpW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGFsbCB0aGUgcHJvcGVydGllcyBpbiB0aGUgZ2l2ZW4gcm93IHByb3BlcnRpZXMgb2JqZWN0IHRvIHRoZSByb3cgcHJvcGVydGllcy5cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQHBhcmFtIHtudW1iZXJ8Q2VsbEV2ZW50fSB5T3JDZWxsRXZlbnQgLSBEYXRhIHJvdyBpbmRleCBsb2NhbCB0byBgZGF0YU1vZGVsYDsgb3IgYSBgQ2VsbEV2ZW50YCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMgLSBBbiBvYmplY3QgY29udGFpbmluZyBuZXcgcHJvcGVydHkgdmFsdWVzKHMpIHRvIGFzc2lnbiB0byB0aGUgcm93IHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIHtkYXRhTW9kZWxBUEl9IFtkYXRhTW9kZWw9dGhpcy5kYXRhTW9kZWxdIC0gVGhpcyBpcyB0aGUgc3ViZ3JpZC4gWW91IG9ubHkgbmVlZCB0byBwcm92aWRlIHRoZSBzdWJncmlkIHdoZW4gaXQgaXMgbm90IHRoZSBkYXRhIHN1YmdyaWQgX2FuZF8geW91IGRpZCBub3QgZ2l2ZSBhIGBDZWxsRXZlbnRgIG9iamVjdCBpbiB0aGUgZmlyc3QgcGFyYW0gKHdoaWNoIGFscmVhZHkga25vd3Mgd2hhdCBzdWJncmlkIGl0J3MgaW4pLlxuICAgICAqL1xuICAgIGFkZFJvd1Byb3BlcnRpZXM6IGZ1bmN0aW9uKHlPckNlbGxFdmVudCwgcHJvcGVydGllcywgZGF0YU1vZGVsKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5nZXRSb3dQcm9wZXJ0aWVzKHlPckNlbGxFdmVudCwgbnVsbCwgZGF0YU1vZGVsKSwgcHJvcGVydGllcyk7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geU9yQ2VsbEV2ZW50IC0gRGF0YSByb3cgaW5kZXggbG9jYWwgdG8gYGRhdGFNb2RlbGAuXG4gICAgICogQHBhcmFtIHtkYXRhTW9kZWxBUEl9IFtkYXRhTW9kZWw9dGhpcy5kYXRhTW9kZWxdXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHJvdyBoZWlnaHQgaW4gcGl4ZWxzLlxuICAgICAqL1xuICAgIGdldFJvd0hlaWdodDogZnVuY3Rpb24oeU9yQ2VsbEV2ZW50LCBkYXRhTW9kZWwpIHtcbiAgICAgICAgdmFyIHJvd1Byb3BzID0gdGhpcy5nZXRSb3dQcm9wZXJ0aWVzKHlPckNlbGxFdmVudCwgdW5kZWZpbmVkLCBkYXRhTW9kZWwpO1xuICAgICAgICByZXR1cm4gcm93UHJvcHMgJiYgcm93UHJvcHMuaGVpZ2h0IHx8XG4gICAgICAgICAgICB0aGlzLmdyaWQucHJvcGVydGllc1tkYXRhTW9kZWwgJiYgZGF0YU1vZGVsLmlzSGVhZGVyID8gJ2RlZmF1bHRIZWFkZXJSb3dIZWlnaHQnIDogJ2RlZmF1bHRSb3dIZWlnaHQnXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGNvdW50IG9mIHJvd3MsIHRoYXQgdXNlZCBhcyBmaWN0aXZlIGhlYWRlcnMuXG4gICAgICovXG4gICAgZ2V0RmljdGl2ZUhlYWRlclJvd3NDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQucHJvcGVydGllcy5maWN0aXZlSGVhZGVyUm93c0NvdW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2Mgc2V0IHRoZSBwaXhlbCBoZWlnaHQgb2YgYSBzcGVjaWZpYyByb3dcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geU9yQ2VsbEV2ZW50IC0gRGF0YSByb3cgaW5kZXggbG9jYWwgdG8gZGF0YU1vZGVsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBwaXhlbCBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2RhdGFNb2RlbEFQSX0gW2RhdGFNb2RlbD10aGlzLmRhdGFNb2RlbF1cbiAgICAgKi9cbiAgICBzZXRSb3dIZWlnaHQ6IGZ1bmN0aW9uKHlPckNlbGxFdmVudCwgaGVpZ2h0LCBkYXRhTW9kZWwpIHtcbiAgICAgICAgdmFyIHJvd1Byb3BzID0gdGhpcy5nZXRSb3dQcm9wZXJ0aWVzKHlPckNlbGxFdmVudCwgbnVsbCwgZGF0YU1vZGVsKSxcbiAgICAgICAgICAgIG9sZEhlaWdodCA9IHJvd1Byb3BzLmhlaWdodDtcblxuICAgICAgICByb3dQcm9wcy5oZWlnaHQgPSBNYXRoLm1heCg1LCBNYXRoLmNlaWwoaGVpZ2h0KSk7XG5cbiAgICAgICAgaWYgKHJvd1Byb3BzLmhlaWdodCAhPT0gb2xkSGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRhdGFNb2RlbHMgPSByZXF1aXJlKCcuLi9kYXRhTW9kZWxzL2luZGV4Jyk7XG5cbi8qKiBAdHlwZWRlZiBzdWJncmlkQ29uc3RydWN0b3JSZWZcbiAqIEBzdW1tYXJ5IFR5cGUgZGVmaW5pdGlvbi5cbiAqIEBkZXNjIE9uZSBvZjpcbiAqICogKipgZnVuY3Rpb25gIHR5cGUqKiAtIEFzc3VtZWQgdG8gYWxyZWFkeSBiZSBhIGRhdGEgbW9kZWwgY29uc3RydWN0b3IuXG4gKiAqICoqYHN0cmluZ2AgdHlwZSoqIC0gVGhlIG5hbWUgb2YgYSBkYXRhIG1vZGVsIFwiY2xhc3NcIiAoY29uc3RydWN0b3IpIHJlZ2lzdGVyZWQgaW4gdGhlIHtAbGluayBzcmMvZGF0YU1vZGVsc30gbmFtZXNwYWNlLiBVc2VkIHRvIGxvb2sgdXAgdGhlIGNvbnN0cnVjdG9yIGluIHRoZSBuYW1lc3BhY2UuXG4gKi9cblxuLyoqIEB0eXBlZGVmIHN1YmdyaWRTcGVjXG4gKiBAc3VtbWFyeSBUeXBlIGRlZmluaXRpb24uXG4gKiBAZGVzYyBPbmUgb2Y6XG4gKiAqICoqYG9iamVjdGAgdHlwZSoqIF8oZXhjZXB0IHdoZW4gYW4gYXJyYXkpXyAtIEFzc3VtZWQgdG8gYmUgYSByZWZlcmVuY2UgdG8gYW4gYWxyZWFkeS1pbnN0YW50aWF0ZWQgZGF0YSBtb2RlbC4gVXNlZCBhcyBpcy5cbiAqICogKipgJ2RhdGEnYCBzcGVjaWFsIHZhbHVlKiogLSBTZXQgdG8gdGhlIGRhdGEgc3ViZ3JpZCAoX2kuZS4sXyB0aGUgYmVoYXZpb3IncyBhbHJlYWR5LWluc3RhbnRpYXRlZCBkYXRhIG1vZGVsKS5cbiAqICogKip7QGxpbmsgc3ViZ3JpZENvbnN0cnVjdG9yUmVmfSoqIF8oc2VlKV8gLSBUaGUgY29uc3RydWN0b3IgcmVmIGlzIHJlc29sdmVkIGFuZCBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCArIGEgcmVmZXJlbmNlIHRvIHRoZSBncmlkIGFzIHRoZSBzb2xlIHBhcmFtZXRlci5cbiAqICogKipgQXJyYXlgIG9iamVjdCoqIOKAlCBBY2NvbW1vZGF0ZXMgZGF0YSBtb2RlbCBjb25zdHJ1Y3RvciBhcmd1bWVudHMuIFRoZSBjb25zdHJ1Y3RvciByZWYgaXMgcmVzb2x2ZWQgYW5kIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkICsgYSByZWZlcmVuY2UgdG8gdGhlIGdyaWQgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciArIHRoZSByZW1haW5pbmcgZWxlbWVudHMgYXMgYWRkaXRpb25hbCBwYXJhbWV0ZXJzLiAoSWYgeW91IGRvbid0IGhhdmUgcmVtYWluaW5nIGVsZW1lbnRzLCBkb24ndCBnaXZlIGFuIGFycmF5IGhlcmU7IGp1c3QgcHJvdmlkZSBhIHNpbXBsZSBgc3ViZ3JpZENvbnN0cnVjdG9yUmVmYCBpbnN0ZWFkLikgVGhlIGFycmF5IHNob3VsZCBoYXZlIHR3byBvciBtb3JlIGVsZW1lbnRzOlxuICogICAqIFRoZSBmaXJzdCBlbGVtZW50IGlzIGEge0BsaW5rIHN1YmdyaWRDb25zdHJ1Y3RvclJlZn0uXG4gKiAgICogUmVtYWluaW5nIGVsZW1lbnRzIGFyZSB1c2VkIGFzIGFkZGl0aW9uYWwgcGFyYW1ldGVycyB0byB0aGUgY29uc3RydWN0b3IuXG4gKi9cblxuLyoqXG4gKiBCZWhhdmlvci5qcyBtaXhlcyB0aGlzIG1vZHVsZSBpbnRvIGl0cyBwcm90b3R5cGUuXG4gKiBAbWl4aW5cbiAqL1xuZXhwb3J0cy5taXhpbiA9IHtcbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSB3aGVyZSBlYWNoIGVsZW1lbnQgcmVwcmVzZW50cyBhIHN1YmdyaWQgdG8gYmUgcmVuZGVyZWQgaW4gdGhlIGh5cGVyZ3JpZC5cbiAgICAgKlxuICAgICAqIFRoZSBsaXN0IHNob3VsZCBhbHdheXMgaW5jbHVkZSBhdCBsZWFzdCBvbmUgXCJkYXRhXCIgc3ViZ3JpZCwgdHlwaWNhbGx5IHtAbGluayBCZWhhdmlvciNkYXRhTW9kZWx8ZGF0YU1vZGVsfS5cbiAgICAgKiBJdCBtYXkgYWxzbyBpbmNsdWRlIHplcm8gb3IgbW9yZSBvdGhlciB0eXBlcyBvZiBzdWJncmlkcyBzdWNoIGFzIGhlYWRlciwgZmlsdGVyLCBhbmQgc3VtbWFyeSBzdWJncmlkcy5cbiAgICAgKlxuICAgICAqIFRoaXMgb2JqZWN0IGFsc28gc3BvcnRzIGEgZGljdGlvbmFyeSBvZiBzdWJncmlkcyBpbiBgbG9va3VwYCBwcm9wZXJ0eSB3aGVyZSBlYWNoIGRpY3Rpb25hcnkga2V5IGlzIG9uZSBvZjpcbiAgICAgKiAqICoqYHN1YmdyaWQubmFtZWAqKiAoZm9yIHRob3NlIHRoYXQgaGF2ZSBhIGRlZmluZWQgbmFtZSwgd2hpY2ggaXMgcHJlc3VtZWQgdG8gYmUgdW5pcXVlKVxuICAgICAqICogKipgc3ViZ3JpZC50eXBlYCoqIChub3QgdW5pcXVlLCBzbyBpZiB5b3UgcGxhbiBvbiBoYXZpbmcgbXVsdGlwbGUsIG5hbWUgdGhlbSEpXG4gICAgICogKiAqKmAnZGF0YSdgKiogZm9yIHRoZSAob25lIGFuZCBvbmx5KSBkYXRhIHN1YmdyaWQgd2hlbiB1bm5hbWVkIChub3RlIHRoYXQgZGF0YSBzdWJncmlkcyBoYXZlIG5vIGB0eXBlYClcbiAgICAgKlxuICAgICAqIFRoZSBzZXR0ZXI6XG4gICAgICogKiBcIkVubGl2ZW5zXCIgYW55IGNvbnN0cnVjdG9ycyAoc2VlIHtAbGluayBCZWhhdmlvcn5jcmVhdGVTdWJncmlkfGNyZWF0ZVN1YmdyaWR9IGZvciBkZXRhaWxzKS5cbiAgICAgKiAqIFJlY29uc3RydWN0cyB0aGUgZGljdGlvbmFyeS5cbiAgICAgKiAqIENhbGxzIHtAbGluayBCZWhhdmlvciNzaGFwZUNoYW5nZWR8c2hhcGVDaGFuZ2VkKCl9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdWJncmlkU3BlY1tdfSBzdWJncmlkU3BlY3NcbiAgICAgKlxuICAgICAqIEB0eXBlIHtkYXRhTW9kZWxBUElbXX1cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKi9cbiAgICBzZXQgc3ViZ3JpZHMoc3ViZ3JpZFNwZWNzKSB7XG4gICAgICAgIHZhciBzdWJncmlkcyA9IHRoaXMuX3N1YmdyaWRzID0gW107XG5cbiAgICAgICAgc3ViZ3JpZHMubG9va3VwID0ge307XG5cbiAgICAgICAgc3ViZ3JpZFNwZWNzLmZvckVhY2goZnVuY3Rpb24oc3BlYykge1xuICAgICAgICAgICAgaWYgKHNwZWMpIHtcbiAgICAgICAgICAgICAgICBzdWJncmlkcy5wdXNoKHRoaXMuY3JlYXRlU3ViZ3JpZChzcGVjKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc2hhcGVDaGFuZ2VkKCk7XG4gICAgfSxcbiAgICBnZXQgc3ViZ3JpZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJncmlkcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgTWFwcyBhIGBzdWJncmlkU3BlY2AgdG8gYSBkYXRhIG1vZGVsLlxuICAgICAqIEBkZXNjIFRoZSBzcGVjIG1heSBkZXNjcmliZSBlaXRoZXIgYW4gZXhpc3RpbmcgZGF0YSBtb2RlbCwgb3IgYSBjb25zdHJ1Y3RvciBmb3IgYSBuZXcgZGF0YSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge3N1YmdyaWRTcGVjfSBzcGVjXG4gICAgICogQHJldHVybnMge2RhdGFNb2RlbEFQSX0gQSBkYXRhIG1vZGVsLlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKi9cbiAgICBjcmVhdGVTdWJncmlkOiBmdW5jdGlvbihzcGVjLCBhcmdzKSB7XG4gICAgICAgIHZhciBzdWJncmlkLCBDb25zdHJ1Y3RvciwgdmFyaWFibGVBcmdBcnJheTtcblxuICAgICAgICBpZiAoc3BlYyA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICBzdWJncmlkID0gdGhpcy5kYXRhTW9kZWw7XG4gICAgICAgIH0gZWxzZSBpZiAoc3BlYyBpbnN0YW5jZW9mIEFycmF5ICYmIHNwZWMubGVuZ3RoKSB7XG4gICAgICAgICAgICBDb25zdHJ1Y3RvciA9IGRlcmVmU3ViZ3JpZFJlZi5jYWxsKHRoaXMsIHNwZWNbMF0pO1xuICAgICAgICAgICAgdmFyaWFibGVBcmdBcnJheSA9IHNwZWMuc2xpY2UoMSk7XG4gICAgICAgICAgICBzdWJncmlkID0gdGhpcy5jcmVhdGVBcHBseShDb25zdHJ1Y3RvciwgdmFyaWFibGVBcmdBcnJheSwgdW5kZWZpbmVkLCB7IGdyaWQ6IHRoaXMuZ3JpZCB9KTtcbiAgICAgICAgICAgIHN1YmdyaWQgPSB0aGlzLmRlY29yYXRlRGF0YU1vZGVsKHN1YmdyaWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcGVjID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgc3ViZ3JpZCA9IHNwZWM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBDb25zdHJ1Y3RvciA9IGRlcmVmU3ViZ3JpZFJlZi5jYWxsKHRoaXMsIHNwZWMpO1xuICAgICAgICAgICAgdmFyaWFibGVBcmdBcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICBzdWJncmlkID0gdGhpcy5jcmVhdGVBcHBseShDb25zdHJ1Y3RvciwgdmFyaWFibGVBcmdBcnJheSwgdW5kZWZpbmVkLCB7IGdyaWQ6IHRoaXMuZ3JpZCB9KTtcbiAgICAgICAgICAgIHN1YmdyaWQgPSB0aGlzLmRlY29yYXRlRGF0YU1vZGVsKHN1YmdyaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdW5kZWZpbmVkIHR5cGUgaXMgZGF0YVxuICAgICAgICBpZiAoIXN1YmdyaWQudHlwZSkge1xuICAgICAgICAgICAgc3ViZ3JpZC50eXBlID0gJ2RhdGEnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFrZSBkaWN0aW9uYXJ5IGxvb2t1cCBlbnRyeVxuICAgICAgICB2YXIga2V5ID0gc3ViZ3JpZC50eXBlID09PSAnZGF0YScgJiYgc3ViZ3JpZC50eXBlIHx8IHN1YmdyaWQubmFtZSB8fCBzdWJncmlkLnR5cGU7XG4gICAgICAgIHRoaXMuX3N1YmdyaWRzLmxvb2t1cFtrZXldID0gdGhpcy5fc3ViZ3JpZHMubG9va3VwW2tleV0gfHwgc3ViZ3JpZDsgLy8gb25seSBzYXZlIGZpcnN0IHdpdGggdGhpcyBrZXlcblxuICAgICAgICAvLyBtYWtlIGlzVHlwZSBib29sZWFuXG4gICAgICAgIHN1YmdyaWRbJ2lzJyArIHN1YmdyaWQudHlwZVswXS50b1VwcGVyQ2FzZSgpICsgc3ViZ3JpZC50eXBlLnN1YnN0cigxKV0gPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBzdWJncmlkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXRzIHRoZSBudW1iZXIgb2YgXCJoZWFkZXIgcm93c1wiLlxuICAgICAqIEBkZXNjIERlZmluZWQgYXMgdGhlIHN1bSBvZiBhbGwgcm93cyBpbiBhbGwgc3ViZ3JpZHMgYmVmb3JlIHRoZSAoZmlyc3QpIGRhdGEgc3ViZ3JpZC5cbiAgICAgKiBAbWVtYmVyT2YgTG9jYWwucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0SGVhZGVyUm93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gMDtcblxuICAgICAgICB0aGlzLnN1YmdyaWRzLmZpbmQoZnVuY3Rpb24oc3ViZ3JpZCkge1xuICAgICAgICAgICAgaWYgKHN1YmdyaWQuaXNEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIHN0b3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSBzdWJncmlkLmdldFJvd0NvdW50KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldHMgdGhlIG51bWJlciBvZiBcImZvb3RlciByb3dzXCIuXG4gICAgICogQGRlc2MgRGVmaW5lZCBhcyB0aGUgc3VtIG9mIGFsbCByb3dzIGluIGFsbCBzdWJncmlkcyBhZnRlciB0aGUgKGxhc3QpIGRhdGEgc3ViZ3JpZC5cbiAgICAgKiBAbWVtYmVyT2YgTG9jYWwucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0Rm9vdGVyUm93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZ290RGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViZ3JpZHMucmVkdWNlKGZ1bmN0aW9uKHJvd3MsIHN1YmdyaWQpIHtcbiAgICAgICAgICAgIGlmIChnb3REYXRhICYmICFzdWJncmlkLmlzRGF0YSkge1xuICAgICAgICAgICAgICAgIHJvd3MgKz0gc3ViZ3JpZC5nZXRSb3dDb3VudCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnb3REYXRhID0gc3ViZ3JpZC5pc0RhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm93cztcbiAgICAgICAgfSwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldHMgdGhlIHRvdGFsIG51bWJlciBvZiBsb2dpY2FsIHJvd3MuXG4gICAgICogQGRlc2MgRGVmaW5lZCBhcyB0aGUgc3VtIG9mIGFsbCByb3dzIGluIGFsbCBzdWJncmlkcy5cbiAgICAgKiBAbWVtYmVyT2YgTG9jYWwucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0TG9naWNhbFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViZ3JpZHMucmVkdWNlKGZ1bmN0aW9uKHJvd3MsIHN1YmdyaWQpIHtcbiAgICAgICAgICAgIHJldHVybiAocm93cyArPSBzdWJncmlkLmdldFJvd0NvdW50KCkpO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBzdW1tYXJ5IFJlc29sdmVzIGEgc3ViZ3JpZCBjb25zdHJ1Y3RvciByZWZlcmVuY2UuXG4gKiBAZGVzYyBUaGUgcmVmIGlzIHJlc29sdmVkIHRvIGEgZGF0YSBtb2RlbCBjb25zdHJ1Y3Rvci5cbiAqIEB0aGlzIHtCZWhhdmlvcn1cbiAqIEBwYXJhbSB7c3ViZ3JpZENvbnN0cnVjdG9yUmVmfSByZWZcbiAqIEByZXR1cm5zIHtEYXRhTW9kZWx9IEEgZGF0YSBtb2RlbCBjb25zdHJ1Y3Rvci5cbiAqIEBtZW1iZXJPZiBCZWhhdmlvcn5cbiAqL1xuZnVuY3Rpb24gZGVyZWZTdWJncmlkUmVmKHJlZikge1xuICAgIHZhciBDb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2ggKHR5cGVvZiByZWYpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIENvbnN0cnVjdG9yID0gZGF0YU1vZGVsc1tyZWZdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgIENvbnN0cnVjdG9yID0gcmVmO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgdGhpcy5IeXBlcmdyaWRFcnJvcignRXhwZWN0ZWQgc3ViZ3JpZCByZWYgdG8gYmUgcmVnaXN0ZXJlZCBuYW1lIG9yIGNvbnN0cnVjdG9yLCBidXQgZm91bmQgJyArIHR5cGVvZiByZWYgKyAnLicpO1xuICAgIH1cbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4uL0Jhc2UnKTtcbnZhciBlZmZlY3RzID0gcmVxdWlyZSgnLi4vbGliL0RPTS9lZmZlY3RzJyk7XG52YXIgTG9jYWxpemF0aW9uID0gcmVxdWlyZSgnLi4vbGliL0xvY2FsaXphdGlvbicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGRlc2MgRGlzcGxheXMgYSBjZWxsIGVkaXRvciBhbmQgaGFuZGxlcyBjZWxsIGVkaXRvciBpbnRlcmFjdGlvbnMuXG4gKlxuICogPiBUaGlzIGNvbnN0cnVjdG9yIChhY3R1YWxseSBgaW5pdGlhbGl6ZWApIHdpbGwgYmUgY2FsbGVkIHVwb24gaW5zdGFudGlhdGlvbiBvZiB0aGlzIGNsYXNzIG9yIG9mIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgZnJvbSB0aGlzIGNsYXNzLiBTZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9qb25laXQvZXh0ZW5kLW1lfGV4dGVuZC1tZX0gZm9yIG1vcmUgaW5mby5cbiAqXG4gKiBJbnN0YW5jZXMgb2YgYENlbGxFZGl0b3JgIGFyZSB1c2VkIHRvIHJlbmRlciBhbiBIVE1MIGVsZW1lbnQgb24gdG9wIG9mIHRoZSBncmlkIGV4YWN0bHkgd2l0aGluIHRoZSBib3VuZCBvZiBhIGNlbGwgZm9yIHB1cnBvc2VzIG9mIGVkaXRpbmcgdGhlIGNlbGwgdmFsdWUuXG4gKlxuICogRXh0ZW5kIHRoaXMgYmFzZSBjbGFzcyB0byBpbXBsZW1lbnQgeW91ciBvd24gY2VsbCBlZGl0b3IuXG4gKlxuICogQHBhcmFtIGdyaWRcbiAqIEBwYXJhbSB7Q2VsbEVkaXRvciNyZW5kZXJDb25maWd9IG9wdGlvbnMgLSBQcm9wZXJ0aWVzIGxpc3RlZCBiZWxvdyArIGFyYml0cmFyeSBtdXN0YWNoZSBcInZhcmlhYmxlc1wiIGZvciBtZXJnaW5nIGludG8gdGVtcGxhdGUuXG4gKiBAcGFyYW0ge1BvaW50fSBvcHRpb25zLmVkaXRQb2ludCAtIERlcHJlY2F0ZWQ7IHVzZSBgb3B0aW9ucy5ncmlkQ2VsbGAuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZm9ybWF0XSAtIE5hbWUgb2YgYSBsb2NhbGl6ZXIgd2l0aCB3aGljaCB0byBvdmVycmlkZSBwcm90b3R5cGUncyBgbG9jYWxpemVyYCBwcm9wZXJ0eS5cbiAqL1xudmFyIENlbGxFZGl0b3IgPSBCYXNlLmV4dGVuZCgnQ2VsbEVkaXRvcicsIHtcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGdyaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gTWl4IGluIGFsbCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgZm9yIG11c3RhY2hlIHVzZSwgdHlwaWNhbGx5IGBjb2x1bW5gIGFuZCBgZm9ybWF0YC5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZXZlbnQgPSBvcHRpb25zO1xuXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZXZlbnQudmFsdWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG15IGluc3RhbmNlIG9mIGh5cGVyZ3JpZFxuICAgICAgICAgKiBAdHlwZSB7SHlwZXJncmlkfVxuICAgICAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG5cbiAgICAgICAgdGhpcy5ncmlkLmNlbGxFZGl0b3IgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMubG9jYWxlID0gZ3JpZC5sb2NhbGl6YXRpb24ubG9jYWxlOyAvLyBmb3IgdGVtcGxhdGUncyBgbGFuZ2AgYXR0cmlidXRlXG5cbiAgICAgICAgLy8gT25seSBvdmVycmlkZSBjZWxsIGVkaXRvcidzIGRlZmF1bHQgJ251bGwnIGxvY2FsaXplciBpZiB0aGUgY3VzdG9tIGxvY2FsaXplciBsb29rdXAgc3VjY2VlZHMuXG4gICAgICAgIC8vIEZhaWx1cmUgaXMgd2hlbiBpdCByZXR1cm5zIHRoZSBkZWZhdWx0ICgnc3RyaW5nJykgbG9jYWxpemVyIHdoZW4gJ3N0cmluZycgaXMgbm90IHdoYXQgd2FzIHJlcXVlc3RlZC5cbiAgICAgICAgdmFyIGxvY2FsaXplciA9IHRoaXMuZ3JpZC5sb2NhbGl6YXRpb24uZ2V0KG9wdGlvbnMuZm9ybWF0KTsgLy8gdHJ5IHRvIGdldCBuYW1lZCBsb2NhbGl6ZXJcbiAgICAgICAgaWYgKCEobG9jYWxpemVyID09PSBMb2NhbGl6YXRpb24ucHJvdG90eXBlLnN0cmluZyB8fCBvcHRpb25zLmZvcm1hdCA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsaXplciA9IGxvY2FsaXplcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gdGhpcy5ncmlkLm1vZHVsZXMudGVtcGxhdGVyLnJlbmRlcih0aGlzLnRlbXBsYXRlLCB0aGlzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBvYmplY3QncyBpbnB1dCBjb250cm9sLCBvbmUgb2Y6XG4gICAgICAgICAqICogKmlucHV0IGVsZW1lbnQqIC0gYW4gYEhUTUxFbGVtZW50YCB0aGF0IGhhcyBhIGB2YWx1ZWAgYXR0cmlidXRlLCBzdWNoIGFzIGBIVE1MSW5wdXRFbGVtZW50YCwgYEhUTUxCdXR0b25FbGVtZW50YCwgZXRjLlxuICAgICAgICAgKiAqICpjb250YWluZXIgZWxlbWVudCogLSBhbiBgSFRNTEVsZW1lbnRgIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgaW5wdXQgZWxlbWVudHMsIG9ubHkgb25lIG9mIHdoaWNoIGNvbnRhaW5zIHRoZSBlZGl0b3IgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBhY2Nlc3MgdG8gdGhlIGlucHV0IGNvbnRyb2wgaXRzZWxmICh3aGljaCBtYXkgb3IgbWF5IG5vdCBiZSB0aGUgc2FtZSBhcyBgdGhpcy5lbGApLCBzZWUgYHRoaXMuaW5wdXRgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVsID0gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMuZWw7XG5cbiAgICAgICAgdGhpcy5lcnJvcnMgPSAwO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMua2V5dXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IDkpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IFRBQiBmcm9tIGxlYXZpbmcgaW5wdXQgY29udHJvbFxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyaWQuZmlyZVN5bnRoZXRpY0VkaXRvcktleURvd25FdmVudChzZWxmLCBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBncmlkLmZpcmVTeW50aGV0aWNFZGl0b3JLZXlQcmVzc0V2ZW50KHNlbGYsIGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBzZWxmLm9ubW91c2Vkb3duKGUpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gSWYgeW91IG92ZXJyaWRlIHRoaXMgbWV0aG9kLCBiZSBzdXJlIHRvIGNhbGwgaXQgYXMgYSBmaW5hbCBzdGVwIChvciBjYWxsIHN0b3BQcm9wYWdhdGlvbiB5b3Vyc2VsZikuXG4gICAgb25tb3VzZWRvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyBDYXRjaCBtb3VzZWRvd24gaGVyZSBiZWZvcmUgaXQgZ2V0cyB0byB0aGUgZG9jdW1lbnQgbGlzdGVuZXIgZGVmaW5lZCBpbiBIeXBlcmdyaWQoKS5cbiAgICB9LFxuXG4gICAgbG9jYWxpemVyOiBMb2NhbGl6YXRpb24ucHJvdG90eXBlLm51bGwsXG5cbiAgICBzcGVjaWFsS2V5dXBzOiB7XG4gICAgICAgIC8vMHgwODogJ2NsZWFyU3RvcEVkaXRpbmcnLCAvLyBiYWNrc3BhY2VcbiAgICAgICAgMHgwOTogJ3N0b3BFZGl0aW5nJywgLy8gdGFiXG4gICAgICAgIDB4MGQ6ICdzdG9wRWRpdGluZycsIC8vIHJldHVybi9lbnRlclxuICAgICAgICAweDFiOiAnY2FuY2VsRWRpdGluZycgLy8gZXNjYXBlXG4gICAgfSxcblxuICAgIGtleXVwOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBncmlkID0gdGhpcy5ncmlkLFxuICAgICAgICAgICAgY2VsbFByb3BzID0gdGhpcy5ldmVudC5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgZmVlZGJhY2tDb3VudCA9IGNlbGxQcm9wcy5mZWVkYmFja0NvdW50LFxuICAgICAgICAgICAga2V5Q2hhciA9IGdyaWQuY2FudmFzLmdldEtleUNoYXIoZSksXG4gICAgICAgICAgICBzcGVjaWFsS2V5dXAsXG4gICAgICAgICAgICBzdG9wcGVkO1xuXG4gICAgICAgIC8vIFNURVAgMTogQ2FsbCB0aGUgc3BlY2lhbCBrZXkgaGFuZGxlciBhcyBuZWVkZWRcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHNwZWNpYWxLZXl1cCA9IHRoaXMuc3BlY2lhbEtleXVwc1tlLmtleUNvZGVdKSAmJlxuICAgICAgICAgICAgKHN0b3BwZWQgPSB0aGlzW3NwZWNpYWxLZXl1cF0oZmVlZGJhY2tDb3VudCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTVEVQIDI6IElmIHRoaXMgaXMgYSBwb3NzaWJsZSBcIm5hdiBrZXlcIiBjb25zdW1hYmxlIGJ5IENlbGxTZWxlY3Rpb24jaGFuZGxlS2V5RG93biwgdHJ5IHRvIHN0b3AgZWRpdGluZyBhbmQgc2VuZCBpdCBhbG9uZ1xuICAgICAgICBpZiAoY2VsbFByb3BzLm1hcHBlZE5hdktleShrZXlDaGFyLCBlLmN0cmxLZXkpKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIXNwZWNpYWxLZXl1cCAmJlxuICAgICAgICAgICAgICAgIC8vIFdlIGRpZG4ndCB0cnkgdG8gc3RvcCBlZGl0aW5nIGFib3ZlIHNvIHRyeSB0byBzdG9wIGl0IG5vd1xuICAgICAgICAgICAgICAgIChzdG9wcGVkID0gdGhpcy5zdG9wRWRpdGluZyhmZWVkYmFja0NvdW50KSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgIC8vIEVkaXRpbmcgc3VjY2Vzc2Z1bGx5IHN0b3BwZWRcbiAgICAgICAgICAgICAgICAvLyAtPiBzZW5kIHRoZSBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluXG4gICAgICAgICAgICAgICAgdmFyIGZpbkV2ZW50ID0gZ3JpZC5jYW52YXMubmV3RXZlbnQoZSwgJ2Zpbi1lZGl0b3Ita2V5ZG93bicsIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZDogZ3JpZCxcbiAgICAgICAgICAgICAgICAgICAgYWx0OiBlLmFsdEtleSxcbiAgICAgICAgICAgICAgICAgICAgY3RybDogZS5jdHJsS2V5LFxuICAgICAgICAgICAgICAgICAgICBjaGFyOiBrZXlDaGFyLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBlLmNoYXJDb2RlLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGUua2V5Q29kZSxcbiAgICAgICAgICAgICAgICAgICAgbWV0YTogZS5tZXRhS2V5LFxuICAgICAgICAgICAgICAgICAgICBzaGlmdDogZS5zaGlmdEtleSxcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogZS5rZXksXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGdyaWQuZGVsZWdhdGVLZXlEb3duKGZpbkV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ3JpZC5maXJlU3ludGhldGljRWRpdG9yS2V5VXBFdmVudCh0aGlzLCBlKTtcblxuICAgICAgICByZXR1cm4gc3RvcHBlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaWYgdHJ1ZSwgY2hlY2sgdGhhdCB0aGUgZWRpdG9yIGlzIGluIHRoZSByaWdodCBsb2NhdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgY2hlY2tFZGl0b3JQb3NpdGlvbkZsYWc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhpcyBmdW5jdGlvbiBpcyBhIGNhbGxiYWNrIGZyb20gdGhlIGZpbi1oeXBlcmdyaWQuICAgSXQgaXMgY2FsbGVkIGFmdGVyIGVhY2ggcGFpbnQgb2YgdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICBncmlkUmVuZGVyZWROb3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNoZWNrRWRpdG9yKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNjcm9sbCB2YWx1ZXMgaGF2ZSBjaGFuZ2VkLCB3ZSd2ZSBiZWVuIG5vdGlmaWVkXG4gICAgICovXG4gICAgc2Nyb2xsVmFsdWVDaGFuZ2VkTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jaGVja0VkaXRvclBvc2l0aW9uRmxhZyA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIG1vdmUgdGhlIGVkaXRvciB0byB0aGUgY3VycmVudCBlZGl0b3IgcG9pbnRcbiAgICAgKi9cbiAgICBtb3ZlRWRpdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXRCb3VuZHModGhpcy5ldmVudC5ib3VuZHMpO1xuICAgIH0sXG5cbiAgICBiZWdpbkVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5ncmlkLmZpcmVSZXF1ZXN0Q2VsbEVkaXQodGhpcy5ldmVudCwgdGhpcy5pbml0aWFsVmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRWRpdG9yUG9zaXRpb25GbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tFZGl0b3IoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzaG93UmVhZG9ubHlFZGl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5maXJlUmVxdWVzdENlbGxFZGl0KHRoaXMuZXZlbnQsIHRoaXMuaW5pdGlhbFZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja0VkaXRvclBvc2l0aW9uRmxhZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRWRpdG9yKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuZWwucmVhZE9ubHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFB1dCB0aGUgdmFsdWUgaW50byBvdXIgZWRpdG9yLlxuICAgICAqIEBkZXNjIEZvcm1hdHMgdGhlIHZhbHVlIGFuZCBkaXNwbGF5cyBpdC5cbiAgICAgKiBUaGUgbG9jYWxpemVyJ3Mge0BsaW5rIGxvY2FsaXplckludGVyZmFjZSNmb3JtYXR8Zm9ybWF0fSBtZXRob2Qgd2lsbCBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB5b3VyIGVkaXRvciBoYXMgYWRkaXRpb25hbCBvciBhbHRlcm5hdGl2ZSBHVUkgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWUgLSBUaGUgcmF3IHVuZm9ybWF0dGVkIHZhbHVlIGZyb20gdGhlIGRhdGEgc291cmNlIHRoYXQgd2Ugd2FudCB0byBlZGl0LlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldEVkaXRvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMubG9jYWxpemVyLmZvcm1hdCh2YWx1ZSwgdGhpcy5ldmVudC5yb3dQcm9wZXJ0aWVzLmhlYWRlclJvdyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBgWyR7dmFsdWUuam9pbignLCAnKX1dYDtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyA/IHZhbHVlIDogJyc7XG4gICAgICAgIHRoaXMuaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGlzcGxheSB0aGUgZWRpdG9yXG4gICAgICovXG4gICAgc2hvd0VkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5lbC5zdHlsZSwgeyBkaXNwbGF5OiAnaW5saW5lJ30pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoaWRlIHRoZSBlZGl0b3JcbiAgICAgKi9cbiAgICBoaWRlRWRpdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH0sXG5cbiAgICAvKiogQHN1bW1hcnkgU3RvcHMgZWRpdGluZy5cbiAgICAgKiBAZGVzYyBCZWZvcmUgc2F2aW5nLCB2YWxpZGF0ZXMgdGhlIGVkaXRlZCB2YWx1ZSBpbiB0d28gcGhhc2VzIGFzIGZvbGxvd3M6XG4gICAgICogMS4gQ2FsbCBgdmFsaWRhdGVFZGl0b3JWYWx1ZWAuIChDYWxscyB0aGUgbG9jYWxpemVyJ3MgYGludmFsaWQoKWAgZnVuY3Rpb24sIGlmIGF2YWlsYWJsZS4pXG4gICAgICogMi4gQ2F0Y2ggYW55IGVycm9ycyB0aHJvd24gYnkgdGhlIHtAbGluayBDZWxsRWRpdG9yI2dldEVkaXRvclZhbHVlfGdldEVkaXRvclZhbHVlfSBtZXRob2QuXG4gICAgICpcbiAgICAgKiAqKklmIHRoZSBlZGl0ZWQgdmFsdWUgcGFzc2VzIGJvdGggcGhhc2VzIG9mIHRoZSB2YWxpZGF0aW9uOioqXG4gICAgICogU2F2ZXMgdGhlIGVkaXRlZCB2YWx1ZSBieSBjYWxsaW5nIHRoZSB7QGxpbmsgQ2VsbEVkaXRvciNzYXZlRWRpdG9yVmFsdWV8c2F2ZUVkaXRvclZhbHVlfSBtZXRob2QuXG4gICAgICpcbiAgICAgKiAqKk9uIHZhbGlkYXRpb24gZmFpbHVyZToqKlxuICAgICAqIDEuIElmIGBmZWVkYmFja2Agd2FzIG9taXR0ZWQsIGNhbmNlbHMgZWRpdGluZywgZGlzY2FyZGluZyB0aGUgZWRpdGVkIHZhbHVlLlxuICAgICAqIDIuIElmIGBmZWVkYmFja2Agd2FzIHByb3ZpZGVkLCBnaXZlcyB0aGUgdXNlciBzb21lIGZlZWRiYWNrIChzZWUgYGZlZWRiYWNrYCwgYmVsb3cpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmZWVkYmFja10gV2hhdCB0byBkbyBvbiB2YWxpZGF0aW9uIGZhaWx1cmUuIE9uZSBvZjpcbiAgICAgKiAqICoqYHVuZGVmaW5lZGAqKiAtIERvIG5vdCBzaG93IHRoZSBlcnJvciBlZmZlY3Qgb3IgdGhlIGVuZCBlZmZlY3QuIEp1c3QgZGlzY2FyZCB0aGUgdmFsdWUgYW5kIGNsb3NlIHRoZSBlZGl0b3IgKGFzIGlmIGBFU0NgIGhhZCBiZWVuIHR5cGVkKS5cbiAgICAgKiAqICoqYDBgKiogLSBKdXN0IHNob3dzIHRoZSBlcnJvciBlZmZlY3QgKHNlZSB0aGUge0BsaW5rIENlbGxFZGl0b3IjZXJyb3JFZmZlY3R8ZXJyb3JFZmZlY3R9IHByb3BlcnR5KS5cbiAgICAgKiAqICoqYDFgKiogLSBTaG93cyB0aGUgZXJyb3IgZmVlZGJhY2sgZWZmZWN0IGZvbGxvd2VkIGJ5IHRoZSBkZXRhaWxlZCBleHBsYW5hdGlvbi5cbiAgICAgKiAqIGAyYCBvciBtb3JlOlxuICAgICAqICAgMS4gU2hvd3MgdGhlIGVycm9yIGZlZWRiYWNrIGVmZmVjdFxuICAgICAqICAgMi4gT24gZXZlcnkgYGZlZWRiYWNrYCB0cmllcywgc2hvd3MgdGhlIGRldGFpbGVkIGV4cGxhbmF0aW9uLlxuICAgICAqICogSWYgYHVuZGVmaW5lZGAgKG9taXR0ZWQpLCBzaW1wbHkgY2FuY2VscyBlZGl0aW5nIHdpdGhvdXQgc2F2aW5nIGVkaXRlZCB2YWx1ZS5cbiAgICAgKiAqIElmIDAsIHNob3dzIHRoZSBlcnJvciBmZWVkYmFjayBlZmZlY3QgKHNlZSB0aGUge0BsaW5rIENlbGxFZGl0b3IjZXJyb3JFZmZlY3R8ZXJyb3JFZmZlY3R9IHByb3BlcnR5KS5cbiAgICAgKiAqIElmID4gMCwgc2hvd3MgdGhlIGVycm9yIGZlZWRiYWNrIGVmZmVjdCBfYW5kXyBjYWxscyB0aGUge0BsaW5rIENlbGxFZGl0b3IjZXJyb3JFZmZlY3RFbmR8ZXJyb3JFZmZlY3RFbmR9IG1ldGhvZCkgZXZlcnkgYGZlZWRiYWNrYCBjYWxsKHMpIHRvIGBzdG9wRWRpdGluZ2AuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydXRoeSBtZWFucyBzdWNjZXNzZnVsIHN0b3AuIEZhbHN5IG1lYW5zIHN5bnRheCBlcnJvciBwcmV2ZW50ZWQgc3RvcC4gTm90ZSB0aGF0IGVkaXRpbmcgaXMgY2FuY2VsZWQgd2hlbiBubyBmZWVkYmFjayByZXF1ZXN0ZWQgYW5kIHN1Y2Nlc3NmdWwgc3RvcCBpbmNsdWRlcyAoc3VjY2Vzc2Z1bCkgY2FuY2VsLlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHN0b3BFZGl0aW5nOiBmdW5jdGlvbihmZWVkYmFjaykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW58c3RyaW5nfEVycm9yfVxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLnZhbGlkYXRlRWRpdG9yVmFsdWUoKTtcblxuICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0RWRpdG9yVmFsdWUoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlcnJvciAmJiB0aGlzLmdyaWQuZmlyZVN5bnRoZXRpY0VkaXRvckRhdGFDaGFuZ2VFdmVudCh0aGlzLCB0aGlzLmluaXRpYWxWYWx1ZSwgdmFsdWUpICYmICF0aGlzLmVsLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2F2ZUVkaXRvclZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5oaWRlRWRpdG9yKCk7XG4gICAgICAgICAgICB0aGlzLmdyaWQuY2VsbEVkaXRvciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmVsLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGZlZWRiYWNrID49IDApIHsgLy8gZmFsc2Ugd2hlbiBgZmVlZGJhY2tgIHVuZGVmaW5lZFxuICAgICAgICAgICAgdGhpcy5lcnJvckVmZmVjdEJlZ2luKCsrdGhpcy5lcnJvcnMgJSBmZWVkYmFjayA9PT0gMCAmJiBlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7IC8vIGludmFsaWQgYnV0IG5vIGZlZWRiYWNrXG4gICAgICAgICAgICB0aGlzLmNhbmNlbEVkaXRpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhZXJyb3I7XG4gICAgfSxcblxuICAgIC8qKiBAc3VtbWFyeSBDYW5jZWxzIGVkaXRpbmcuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFN1Y2Nlc3NmdWwuIChDYW5jZWwgaXMgYWx3YXlzIHN1Y2Nlc3NmdWwuKVxuICAgICAqL1xuICAgIGNhbmNlbEVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldEVkaXRvclZhbHVlKHRoaXMuaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgdGhpcy5oaWRlRWRpdG9yKCk7XG4gICAgICAgIHRoaXMuZ3JpZC5jZWxsRWRpdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmUoKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIGVmZmVjdCBmdW5jdGlvbiBpbmRpY2F0ZWQgaW4gdGhlIHtAbGluayBtb2R1bGU6ZGVmYXVsdHMuZmVlZGJhY2tFZmZlY3R8ZmVlZGJhY2tFZmZlY3R9IHByb3BlcnR5LCB3aGljaCB0cmlnZ2VycyBhIHNlcmllcyBvZiBDU1MgdHJhbnNpdGlvbnMuXG4gICAgICogQHBhcmFtIHtib29sZWFufHN0cmluZ3xFcnJvcn0gW2Vycm9yXSAtIElmIGRlZmluZWQsIGNhbGwgdGhlIHtAbGluayBDZWxsRWRpdG9yI2Vycm9yRWZmZWN0RW5kfGVycm9yRWZmZWN0RW5kfSBtZXRob2QgYXQgdGhlIGVuZCBvZiB0aGUgbGFzdCBlZmZlY3QgdHJhbnNpdGlvbiB3aXRoIHRoaXMgZXJyb3IuXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgZXJyb3JFZmZlY3RCZWdpbjogZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgdmFyIHNwZWMgPSB0aGlzLmdyaWQucHJvcGVydGllcy5mZWVkYmFja0VmZmVjdCwgLy8gc3BlYyBtYXkgZSBhIHN0cmluZyBvciBhbiBvYmplY3Qgd2l0aCBuYW1lIGFuZCBvcHRpb25zIHByb3BzXG4gICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgc3BlYy5vcHRpb25zKSwgLy8gaWYgc3BlYyBpcyBhIHN0cmluZywgc3BlYy5vcHRpb25zIHdpbGwgYmUgdW5kZWZpbmVkXG4gICAgICAgICAgICBlZmZlY3QgPSBlZmZlY3RzW3NwZWMubmFtZSB8fCBzcGVjXTsgLy8gaWYgc3BlYyBpcyBhIHN0cmluZywgc3BlYy5uYW1lIHdpbGwgYmUgdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrID0gdGhpcy5lcnJvckVmZmVjdEVuZC5iaW5kKHRoaXMsIGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlZmZlY3QpIHtcbiAgICAgICAgICAgIGVmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZXhwZWN0cyB0byBiZSBwYXNzZWQgYW4gZXJyb3IuIFRoZXJlIGlzIG5vIHBvaW50IGluIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBpZiB0aGVyZSBpcyBubyBlcnJvci4gTmV2ZXJ0aGVsZXNzLCBpZiBjYWxsZWQgd2l0aCBhIGZhbHN5IGBlcnJvcmAsIHJldHVybnMgd2l0aG91dCBkb2luZyBhbnl0aGluZy5cbiAgICAgKiBAdGhpcyB7Q2VsbEVkaXRvcn1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58c3RyaW5nfEVycm9yfSBbZXJyb3JdXG4gICAgICovXG4gICAgZXJyb3JFZmZlY3RFbmQ6IGZ1bmN0aW9uKGVycm9yLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdmFyIG1zZyA9XG4gICAgICAgICAgICAgICAgJ0ludmFsaWQgdmFsdWUuIFRvIHJlc29sdmUsIGRvIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxcblxcbicgK1xuICAgICAgICAgICAgICAgICcgICAqIENvcnJlY3QgdGhlIGVycm9yIGFuZCB0cnkgYWdhaW4uXFxuJyArXG4gICAgICAgICAgICAgICAgJyAgICAgICAgIC0gb3IgLVxcbicgK1xuICAgICAgICAgICAgICAgICcgICAqIENhbmNlbCBlZGl0aW5nIGJ5IHByZXNzaW5nIHRoZSBcImVzY1wiIChlc2NhcGUpIGtleS4nO1xuXG4gICAgICAgICAgICBlcnJvciA9IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3I7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMubG9jYWxpemVyLmV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlcnJvciA/IGVycm9yICsgJ1xcbicgKyB0aGlzLmxvY2FsaXplci5leHBlY3RhdGlvbiA6IHRoaXMubG9jYWxpemVyLmV4cGVjdGF0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoL1tcXG5cXHJdLy50ZXN0KGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9ICdcXG4nICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gZXJyb3IucmVwbGFjZSgvW1xcblxccl0rL2csICdcXG5cXG4gICAqICcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtc2cgKz0gJ1xcblxcbkFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBlcnJvcjogJyArIGVycm9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyAvLyBhbGxvdyBhbmltYXRpb24gdG8gY29tcGxldGVcbiAgICAgICAgICAgICAgICBhbGVydChtc2cpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWFsZXJ0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBzYXZlIHRoZSBuZXcgdmFsdWUgaW50byB0aGUgYmVoYXZpb3IgKG1vZGVsKVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBEYXRhIGNoYW5nZWQgYW5kIHByZS1jZWxsLWVkaXQgZXZlbnQgd2FzIG5vdCBjYW5jZWxlZC5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYXZlRWRpdG9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBzYXZlID0gKFxuICAgICAgICAgICAgISh2YWx1ZSAmJiB2YWx1ZSA9PT0gdGhpcy5pbml0aWFsVmFsdWUpICYmIC8vIGRhdGEgY2hhbmdlZFxuICAgICAgICAgICAgdGhpcy5ncmlkLmZpcmVCZWZvcmVDZWxsRWRpdCh0aGlzLmV2ZW50LmdyaWRDZWxsLCB0aGlzLmluaXRpYWxWYWx1ZSwgdmFsdWUsIHRoaXMpIC8vIHByb2NlZWRcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoc2F2ZSkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmJlaGF2aW9yLnNldFZhbHVlKHRoaXMuZXZlbnQsIHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5maXJlQWZ0ZXJDZWxsRWRpdCh0aGlzLmV2ZW50LmdyaWRDZWxsLCB0aGlzLmluaXRpYWxWYWx1ZSwgdmFsdWUsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNhdmU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEV4dHJhY3QgdGhlIGVkaXRlZCB2YWx1ZSBmcm9tIHRoZSBlZGl0b3IuXG4gICAgICogQGRlc2MgRGUtZm9ybWF0IHRoZSBlZGl0ZWQgc3RyaW5nIGJhY2sgaW50byBhIHByaW1pdGl2ZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoZSBsb2NhbGl6ZXIncyB7QGxpbmsgbG9jYWxpemVySW50ZXJmYWNlI3BhcnNlfHBhcnNlfSBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgb24gdGhlIHRleHQgYm94IGNvbnRlbnRzLlxuICAgICAqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgeW91ciBlZGl0b3IgaGFzIGFkZGl0aW9uYWwgb3IgYWx0ZXJuYXRpdmUgR1VJIGVsZW1lbnRzLiBUaGUgR1VJIGVsZW1lbnRzIHdpbGwgaW5mbHVlbmNlIHRoZSBwcmltaXRpdmUgdmFsdWUsIGVpdGhlciBieSBhbHRlcmluZyB0aGUgZWRpdGVkIHN0cmluZyBiZWZvcmUgaXQgaXMgcGFyc2VkLCBvciBieSB0cmFuc2Zvcm1pbmcgdGhlIHBhcnNlZCB2YWx1ZSBiZWZvcmUgcmV0dXJuaW5nIGl0LlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSBjdXJyZW50IGVkaXRvcidzIHZhbHVlXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0RWRpdG9yVmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6ZXIucGFyc2UodGhpcy5pbnB1dC52YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRoZXJlIGlzIG5vIHZhbGlkYXRvciBvbiB0aGUgbG9jYWxpemVyLCByZXR1cm5zIGZhbHN5IChub3QgaW52YWxpZDsgcG9zc2libHkgdmFsaWQpLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufHN0cmluZ30gVHJ1dGh5IHZhbHVlIG1lYW5zIGludmFsaWQuIElmIGEgc3RyaW5nLCB0aGlzIHdpbGwgYmUgYW4gZXJyb3IgbWVzc2FnZS4gSWYgbm90IGEgc3RyaW5nLCBpdCBtZXJlbHkgaW5kaWNhdGVzIGEgZ2VuZXJpYyBpbnZhbGlkIHJlc3VsdC5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZUVkaXRvclZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemVyLmludmFsaWQgJiYgdGhpcy5sb2NhbGl6ZXIuaW52YWxpZCh0aGlzLmlucHV0LnZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVxdWVzdCBmb2N1cyBmb3IgbXkgaW5wdXQgY29udHJvbC5cbiAgICAgKiBAZGVzYyBTZWUgR1JJRC05NSBcIlNjcm9sbGJhciBtb3ZlcyBpbndhcmRcIiBmb3IgaXNzdWUgYW5kIHdvcmstYXJvdW5kIGV4cGxhbmF0aW9uLlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHRha2VGb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWwsXG4gICAgICAgICAgICBsZWZ0V2FzID0gZWwuc3R5bGUubGVmdCxcbiAgICAgICAgICAgIHRvcFdhcyA9IGVsLnN0eWxlLnRvcDtcblxuICAgICAgICBlbC5zdHlsZS5sZWZ0ID0gZWwuc3R5bGUudG9wID0gMDsgLy8gd29yay1hcm91bmQ6IG1vdmUgdG8gdXBwZXIgbGVmdFxuXG4gICAgICAgIHZhciB4ID0gd2luZG93LnNjcm9sbFgsIHkgPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgdGhpcy5pbnB1dC5mb2N1cygpO1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oeCwgeSk7XG4gICAgICAgIHRoaXMuc2VsZWN0QWxsKCk7XG5cbiAgICAgICAgZWwuc3R5bGUubGVmdCA9IGxlZnRXYXM7XG4gICAgICAgIGVsLnN0eWxlLnRvcCA9IHRvcFdhcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2VsZWN0IGV2ZXJ5dGhpbmdcbiAgICAgKi9cbiAgICBzZWxlY3RBbGw6IG51bGxQYXR0ZXJuLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IHRoZSBib3VuZHMgb2YgbXkgaW5wdXQgY29udHJvbFxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBjZWxsQm91bmRzIC0gdGhlIGJvdW5kcyB0byBtb3ZlIHRvXG4gICAgICovXG4gICAgc2V0Qm91bmRzOiBmdW5jdGlvbihjZWxsQm91bmRzKSB7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uUmVnaW9uQm9yZGVyV2lkdGggfSA9IHRoaXMuZ3JpZC5wcm9wZXJ0aWVzO1xuICAgICAgICBjb25zdCB7IGdjLCB3aWR0aDogY2FudmFzV2lkdGgsIGhlaWdodDogY2FudmFzSGVpZ2h0IH0gPSB0aGlzLmdyaWQuY2FudmFzO1xuICAgICAgICBjb25zdCB7IHN0eWxlIH0gPSB0aGlzLmVsO1xuICAgICAgICBjb25zdCByb3dGb250ID0gdGhpcy5ldmVudC5yb3dQcm9wZXJ0aWVzLmZvbnQgfHwgdGhpcy5ldmVudC5wcm9wZXJ0aWVzLmZvbnQ7XG5cbiAgICAgICAgbGV0IGxlZnQgPSBjZWxsQm91bmRzLng7XG5cbiAgICAgICAgY29uc3QgbWF4aW11bUNvbHVtbldpZHRoID0gY2FudmFzV2lkdGggLSBsZWZ0O1xuXG4gICAgICAgIGdjLmNhY2hlLmZvbnQgPSByb3dGb250O1xuICAgICAgICAvLyBhZGRpdGlvbmFsIHdpZHRoIGJlY2F1c2Ugb2YgaW5uZXIgcGFkZGluZyBhbmQgYm9yZGVyXG4gICAgICAgIGxldCB3aWR0aCA9IGdjLmdldFRleHRXaWR0aCh0aGlzLmluaXRpYWxWYWx1ZSkgKyAxMjtcblxuICAgICAgICAvLyBjb3JyZWN0IHdpZHRoIGlmIGl0IHRvbyBtdWNoXG4gICAgICAgIGlmICghd2lkdGggfHwgd2lkdGggPCBjZWxsQm91bmRzLndpZHRoKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGNlbGxCb3VuZHMud2lkdGggKyBzZWxlY3Rpb25SZWdpb25Cb3JkZXJXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkdGggPiBtYXhpbXVtQ29sdW1uV2lkdGgpIHtcbiAgICAgICAgICAgIHdpZHRoID0gbWF4aW11bUNvbHVtbldpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW92ZSB0byBsZWZ0IGlmIGl0IG5lZWRlZFxuICAgICAgICBpZiAobGVmdCArIHdpZHRoID4gY2FudmFzV2lkdGgpIHtcbiAgICAgICAgICAgIGxlZnQgPSBjYW52YXNXaWR0aCAtIHdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgd2lkdGggKz0gc2VsZWN0aW9uUmVnaW9uQm9yZGVyV2lkdGg7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZSwge2xlZnQ6IHB4KGxlZnQpLCB3aWR0aDogcHgod2lkdGgpLCBmb250OiByb3dGb250LCByZXNpemU6ICdub25lJ30pO1xuXG4gICAgICAgIC8vIGFkZGl0aW9uYWwgaGVpZ2h0IGJlY2F1c2Ugb2YgaW5uZXIgcGFkZGluZyBhbmQgYm9yZGVyXG4gICAgICAgIGxldCBoZWlnaHQgPSAod2lkdGggPT09IG1heGltdW1Db2x1bW5XaWR0aCArIHNlbGVjdGlvblJlZ2lvbkJvcmRlcldpZHRoID8gdGhpcy5lbC5zY3JvbGxIZWlnaHQgOiBjZWxsQm91bmRzLmhlaWdodCkgKyAyO1xuICAgICAgICBsZXQgdG9wID0gY2VsbEJvdW5kcy55IC0gc2VsZWN0aW9uUmVnaW9uQm9yZGVyV2lkdGg7XG4gICAgICAgIGNvbnN0IG1heGltdW1Db2x1bW5IZWlnaHQgPSBjYW52YXNIZWlnaHQgLSB0b3A7XG5cbiAgICAgICAgLy8gY29ycmVjdCBoZWlnaHQgaWYgaXQgdG9vIG11c2hcbiAgICAgICAgaWYgKGhlaWdodCA+IG1heGltdW1Db2x1bW5IZWlnaHQpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IG1heGltdW1Db2x1bW5IZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3ZlIHRvIHRvcCBpZiBpdCBuZWVkZWRcbiAgICAgICAgaWYgKHRvcCArIGhlaWdodCA+IGNhbnZhc0hlaWdodCkge1xuICAgICAgICAgICAgdG9wID0gY2FudmFzSGVpZ2h0IC0gaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZSwgeyB0b3A6IHB4KHRvcCksIGhlaWdodDogcHgoaGVpZ2h0KSB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgY2hlY2sgdGhhdCB0aGUgZWRpdG9yIGlzIGluIHRoZSBjb3JyZWN0IGxvY2F0aW9uLCBhbmQgaXMgc2hvd2luZy9oaWRkZW4gYXBwcm9wcmlhdGVseVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj99IHRha2VGb2N1c05lZWRlZFxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNoZWNrRWRpdG9yOiBmdW5jdGlvbih0YWtlRm9jdXNOZWVkZWQpIHtcbiAgICAgICAgdGFrZUZvY3VzTmVlZGVkID0gdGFrZUZvY3VzTmVlZGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogdGFrZUZvY3VzTmVlZGVkO1xuICAgICAgICBpZiAodGhpcy5jaGVja0VkaXRvclBvc2l0aW9uRmxhZykge1xuICAgICAgICAgICAgdGhpcy5jaGVja0VkaXRvclBvc2l0aW9uRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnQuaXNDZWxsVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RWRpdG9yVmFsdWUodGhpcy5pbml0aWFsVmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoRWRpdG9yKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlRWRpdG9yKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93RWRpdG9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRha2VGb2N1c05lZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRha2VGb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlRWRpdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYXR0YWNoRWRpdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ncmlkLmRpdi5hcHBlbmRDaGlsZCh0aGlzLmVsKTtcbiAgICB9LFxuXG4gICAgdGVtcGxhdGU6ICcnXG5cbn0pO1xuXG5mdW5jdGlvbiBudWxsUGF0dGVybigpIHt9XG5mdW5jdGlvbiBweChuKSB7IHJldHVybiBuICsgJ3B4JzsgfVxuXG5cbm1vZHVsZS5leHBvcnRzID0gQ2VsbEVkaXRvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENlbGxFZGl0b3IgPSByZXF1aXJlKCcuL0NlbGxFZGl0b3InKTtcblxuLyoqXG4gKiBBcyBvZiBzcHJpbmcgMjAxNjpcbiAqIEZ1bmN0aW9ucyB3ZWxsIGluIENocm9tZSBhbmQgRmlyZWZveDsgdW5pbXBsZW1lbnRlZCBpbiBTYWZhcmkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENlbGxFZGl0b3JcbiAqL1xudmFyIENvbG9yID0gQ2VsbEVkaXRvci5leHRlbmQoJ0NvbG9yJywge1xuXG4gICAgdGVtcGxhdGU6ICc8aW5wdXQgdHlwZT1cImNvbG9yXCIgbGFuZz1cInt7bG9jYWxlfX1cIiBzdHlsZT1cInt7c3R5bGV9fVwiPidcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sb3I7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbEVkaXRvciA9IHJlcXVpcmUoJy4vQ2VsbEVkaXRvcicpO1xuXG52YXIgaXNDaHJvbWl1bSA9IHdpbmRvdy5jaHJvbWUsXG4gICAgd2luTmF2ID0gd2luZG93Lm5hdmlnYXRvcixcbiAgICB2ZW5kb3JOYW1lID0gd2luTmF2LnZlbmRvcixcbiAgICBpc09wZXJhID0gd2luTmF2LnVzZXJBZ2VudC5pbmRleE9mKCdPUFInKSA+IC0xLFxuICAgIGlzSUVlZGdlID0gd2luTmF2LnVzZXJBZ2VudC5pbmRleE9mKCdFZGdlJykgPiAtMSxcbiAgICBpc0lPU0Nocm9tZSA9IHdpbk5hdi51c2VyQWdlbnQubWF0Y2goJ0NyaU9TJyksXG4gICAgaXNDaHJvbWUgPSAhaXNJT1NDaHJvbWUgJiZcbiAgICAgICAgaXNDaHJvbWl1bSAhPT0gbnVsbCAmJlxuICAgICAgICBpc0Nocm9taXVtICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdmVuZG9yTmFtZSA9PT0gJ0dvb2dsZSBJbmMuJyAmJlxuICAgICAgICBpc09wZXJhID09IGZhbHNlICYmIGlzSUVlZGdlID09IGZhbHNlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuXG4vKipcbiAqIEFzIG9mIHNwcmluZyAyMDE2OlxuICogRnVuY3Rpb25zIHdlbGwgaW4gQ2hyb21lIGV4Y2VwdCBubyBsb2NhbGl6YXRpb24gKGRheSwgbW9udGggbmFtZXM7IGRhdGUgZm9ybWF0KS5cbiAqIFVuaW1wbGVtZW50ZWQgaW4gU2FmYXJpLCBGaXJlZm94LCBJbnRlcm5ldCBFeHBsb3Jlci5cbiAqIFRoaXMgaXMgYSBcInNubWFydFwiIGNvbnRyb2wuIEl0IGRldGVjdHMgQ2hyb21lOlxuICogKiBJZiBDaHJvbWUsIHVzZXMgY2hyb21lRGF0ZSBvdmVycmlkZXMgZm9ybWF0IHRvIHRoYXQgcmVxdWlyZWQgYnkgdGhlIHZhbHVlIGF0dHJpYnV0ZSwgeXl5eS1tbS1kZC4gKE5vdGUgdGhhdCB0aGlzIGlzIG5vdCB0aGUgZm9ybWF0IGRpc3BsYXllZCBpbiB0aGUgY29udHJvbCwgd2hpY2ggaXMgYWx3YXlzIG1tL2RkL3l5eXkuKVxuICogKiBPdGhlcndpc2UgdXNlcyBsb2NhbGl6ZWQgZGF0ZSBmb3JtYXQgX2J1dF8gZmFsbHMgYmFjayB0byBhIHJlZ3VsYXIgdGV4dCBib3guXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENlbGxFZGl0b3JcbiAqL1xudmFyIERhdGUgPSBDZWxsRWRpdG9yLmV4dGVuZCgnRGF0ZScsIHtcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGdyaWQpIHtcblxuICAgICAgICB2YXIgbG9jYWxpemVyTmFtZSxcbiAgICAgICAgICAgIHVzZXNEYXRlSW5wdXRDb250cm9sID0gaXNDaHJvbWU7XG5cbiAgICAgICAgaWYgKHVzZXNEYXRlSW5wdXRDb250cm9sKSB7XG4gICAgICAgICAgICBsb2NhbGl6ZXJOYW1lID0gJ2Nocm9tZURhdGUnO1xuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZSA9ICc8aW5wdXQgdHlwZT1cImRhdGVcIj4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9jYWxpemVyTmFtZSA9ICdkYXRlJztcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUgPSAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbGFuZz1cInt7bG9jYWxlfX1cIj4nO1xuXG4gICAgICAgICAgICB0aGlzLnNlbGVjdEFsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0Q2hhclBsdXNPbmUgPSB0aGlzLmdldEVkaXRvclZhbHVlKCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UoMCwgbGFzdENoYXJQbHVzT25lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxvY2FsaXplciA9IGdyaWQubG9jYWxpemF0aW9uLmdldChsb2NhbGl6ZXJOYW1lKTtcbiAgICB9XG59KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUZXh0ZmllbGQgPSByZXF1aXJlKCcuL1RleHRmaWVsZCcpO1xuXG4vKipcbiAqIEZ1bmN0aW9ucyB3ZWxsIGluIENocm9tZSwgU2FmYXJpLCBGaXJlZm94LCBhbmQgSW50ZXJuZXQgRXhwbG9yZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFRleHRmaWVsZFxuICovXG52YXIgTnVtYmVyID0gVGV4dGZpZWxkLmV4dGVuZCgnTnVtYmVyJywge1xuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLmxvY2FsaXplciA9IGdyaWQubG9jYWxpemF0aW9uLmdldCgnbnVtYmVyJyk7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsRWRpdG9yID0gcmVxdWlyZSgnLi9DZWxsRWRpdG9yJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDZWxsRWRpdG9yXG4gKi9cbnZhciBTbGlkZXIgPSBDZWxsRWRpdG9yLmV4dGVuZCgnU2xpZGVyJywge1xuXG4gICAgdGVtcGxhdGU6ICc8aW5wdXQgdHlwZT1cInJhbmdlXCIgbGFuZz1cInt7bG9jYWxlfX1cIiBzdHlsZT1cInt7c3R5bGV9fVwiPidcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2xpZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbEVkaXRvciA9IHJlcXVpcmUoJy4vQ2VsbEVkaXRvcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ2VsbEVkaXRvclxuICovXG52YXIgU3Bpbm5lciA9IENlbGxFZGl0b3IuZXh0ZW5kKCdTcGlubmVyJywge1xuXG4gICAgdGVtcGxhdGU6ICc8aW5wdXQgdHlwZT1cIm51bWJlclwiIGxhbmc9XCJ7e2xvY2FsZX19XCIgc3R5bGU9XCJ7e3N0eWxlfX1cIj4nXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwaW5uZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsRWRpdG9yID0gcmVxdWlyZSgnLi9DZWxsRWRpdG9yJyk7XG52YXIgTG9jYWxpemF0aW9uID0gcmVxdWlyZSgnLi4vbGliL0xvY2FsaXphdGlvbicpO1xuXG5cbi8qKlxuICogQXMgb2Ygc3ByaW5nIDIwMTY6XG4gKiBGdW5jdGlvbnMgd2VsbCBpbiBDaHJvbWUsIFNhZmFyaSwgRmlyZWZveCwgYW5kIEludGVybmV0IEV4cGxvcmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDZWxsRWRpdG9yXG4gKi9cbnZhciBUZXh0ZmllbGQgPSBDZWxsRWRpdG9yLmV4dGVuZCgnVGV4dGZpZWxkJywge1xuXG4gICAgdGVtcGxhdGU6ICc8dGV4dGFyZWEgbGFuZz1cInt7bG9jYWxlfX1cIiBjbGFzcz1cImh5cGVyZ3JpZC10ZXh0ZmllbGRcIiBzdHlsZT1cInt7c3R5bGV9fVwiPicsXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5pbnB1dC5zdHlsZS50ZXh0QWxpZ24gPSB0aGlzLmV2ZW50LnByb3BlcnRpZXMuaGFsaWduO1xuICAgIH0sXG5cbiAgICBsb2NhbGl6ZXI6IExvY2FsaXphdGlvbi5wcm90b3R5cGUuc3RyaW5nLFxuXG4gICAgc2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5pbnB1dC5zZXRTZWxlY3Rpb25SYW5nZSgwLCB0aGlzLmlucHV0LnZhbHVlLmxlbmd0aCk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dGZpZWxkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVnaXN0cnkgPSByZXF1aXJlKCcuLi9saWIvUmVnaXN0cnknKTtcblxuXG52YXIgd2FybmVkQmFzZUNsYXNzO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2MgUmVnaXN0cnkgb2YgY2VsbCBlZGl0b3IgY29uc3RydWN0b3JzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBDZWxsRWRpdG9ycyA9IFJlZ2lzdHJ5LmV4dGVuZCgnQ2VsbEVkaXRvcnMnLCB7XG5cbiAgICBCYXNlQ2xhc3M6IHJlcXVpcmUoJy4vQ2VsbEVkaXRvcicpLCAvLyBhYnN0cmFjdCBiYXNlIGNsYXNzXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gcHJlcmVnaXN0ZXIgdGhlIHN0YW5kYXJkIGNlbGwgZWRpdG9yc1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL0NvbG9yJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL0RhdGUnKSk7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vTnVtYmVyJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL1NsaWRlcicpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9TcGlubmVyJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL1RleHRmaWVsZCcpKTtcbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lICYmIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2NlbGxlZGl0b3InKSB7XG4gICAgICAgICAgICBpZiAoIXdhcm5lZEJhc2VDbGFzcykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignZ3JpZC5jZWxsRWRpdG9ycy5nZXQoXCInICsgbmFtZSArICdcIikgbWV0aG9kIGNhbGwgaGFzIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2Mi4xLjAgaW4gZmF2b3Igb2YgZ3JpZC5jZWxsRWRpdG9ycy5CYXNlQ2xhc3MgcHJvcGVydHkuIChXaWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4pJyk7XG4gICAgICAgICAgICAgICAgd2FybmVkQmFzZUNsYXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLkJhc2VDbGFzcztcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIENlbGxFZGl0b3IgPSBSZWdpc3RyeS5wcm90b3R5cGUuZ2V0LmNhbGwodGhpcywgbmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gZmFpbCBzaWxlbnRseVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDZWxsRWRpdG9yO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IENlbGxFZGl0b3JzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbFJlbmRlcmVyID0gcmVxdWlyZSgnLi9DZWxsUmVuZGVyZXInKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENlbGxSZW5kZXJlclxuICovXG52YXIgQnV0dG9uID0gQ2VsbFJlbmRlcmVyLmV4dGVuZCgnQnV0dG9uJywge1xuXG4gICAgcGFpbnQ6IGZ1bmN0aW9uKGdjLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHZhbCA9IGNvbmZpZy52YWx1ZSxcbiAgICAgICAgICAgIGMgPSBjb25maWcuZGF0YUNlbGwueCxcbiAgICAgICAgICAgIHIgPSBjb25maWcuZ3JpZENlbGwueSxcbiAgICAgICAgICAgIGJvdW5kcyA9IGNvbmZpZy5ib3VuZHMsXG4gICAgICAgICAgICB4ID0gYm91bmRzLnggKyAxLFxuICAgICAgICAgICAgeSA9IGJvdW5kcy55ICsgMSxcbiAgICAgICAgICAgIHdpZHRoID0gYm91bmRzLndpZHRoIC0gMSAtIGNvbmZpZy5saW5lV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBib3VuZHMuaGVpZ2h0IC0gMSAtIGNvbmZpZy5saW5lV2lkdGgsXG4gICAgICAgICAgICByYWRpdXMgPSBoZWlnaHQgLyAyLFxuICAgICAgICAgICAgYXJjR3JhZGllbnQgPSBnYy5jcmVhdGVMaW5lYXJHcmFkaWVudCh4LCB5LCB4LCB5ICsgaGVpZ2h0KTtcblxuICAgICAgICBpZiAoY29uZmlnLm1vdXNlRG93bikge1xuICAgICAgICAgICAgYXJjR3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsICcjQjVDQkVEJyk7XG4gICAgICAgICAgICBhcmNHcmFkaWVudC5hZGRDb2xvclN0b3AoMSwgJyM0ZDc0ZWEnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFyY0dyYWRpZW50LmFkZENvbG9yU3RvcCgwLCAnI2ZmZmZmZicpO1xuICAgICAgICAgICAgYXJjR3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsICcjYWFhYWFhJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkcmF3IHRoZSBiYWNrZ3JvdW5kXG4gICAgICAgIGdjLmNhY2hlLmZpbGxTdHlsZSA9IGNvbmZpZy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGdjLmZpbGxSZWN0KGJvdW5kcy54LCBib3VuZHMueSwgYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0KTtcblxuICAgICAgICAvLyBkcmF3IHRoZSBjYXBzdWxlXG4gICAgICAgIGdjLmNhY2hlLmZpbGxTdHlsZSA9IGFyY0dyYWRpZW50O1xuICAgICAgICBnYy5jYWNoZS5zdHJva2VTdHlsZSA9ICcjMDAwMDAwJztcbiAgICAgICAgdGhpcy5yb3VuZFJlY3QoZ2MsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cywgYXJjR3JhZGllbnQsIHRydWUpO1xuXG4gICAgICAgIHZhciBveCA9ICh3aWR0aCAtIGdjLmdldFRleHRXaWR0aCh2YWwpKSAvIDI7XG4gICAgICAgIHZhciBveSA9IChoZWlnaHQgLSBnYy5nZXRUZXh0SGVpZ2h0KGdjLmNhY2hlLmZvbnQpLmRlc2NlbnQpIC8gMjtcblxuICAgICAgICAvLyBkcmF3IHRoZSB0ZXh0XG4gICAgICAgIGdjLmNhY2hlLnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSAnIzMzMzMzMyc7XG4gICAgICAgIGdjLmNhY2hlLmZvbnQgPSBoZWlnaHQgLSAyICsgJ3B4IHNhbnMtc2VyaWYnO1xuICAgICAgICBjb25maWcuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgICAgICBnYy5zaW1wbGVUZXh0KHZhbCwgeCArIG94LCB5ICsgb3kpO1xuXG4gICAgICAgIC8vIElkZW50aWZ5IHRoYXQgd2UgYXJlIGEgYnV0dG9uIGJ5IGluc2VydGluZyBhbiBhcnJheSBvZiBib3VuZHMgaW50byBidXR0b25DZWxscyBmb3IgdGhpcyBjZWxsJ3MgY29vcmRzLFxuICAgICAgICAvLyBvbmUgZWxlbWVudCBwZXIgc3Vicm93LiBUaGlzIHdpbGwgYmUgYSBzaW5nbGUtZWxlbWVudCBhcnJheSBmb3IgYSBjZWxsIHdpdGhvdXQgYHN1YnJvd3NgLlxuICAgICAgICB2YXIga2V5ID0gYyArICcsJyArIHIsXG4gICAgICAgICAgICBidXR0b25DZWxscyA9IGNvbmZpZy5idXR0b25DZWxscyxcbiAgICAgICAgICAgIGJ1dHRvblN1YnJvd3MgPSBidXR0b25DZWxsc1trZXldIHx8IChidXR0b25DZWxsc1trZXldID0gW10pO1xuXG4gICAgICAgIGJ1dHRvblN1YnJvd3NbY29uZmlnLnN1YnJvd10gPSBPYmplY3QuYXNzaWduKHt9LCBib3VuZHMpO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1dHRvbjtcblxuXG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlZGVmIHtvYmplY3R9IENlbGxSZW5kZXJlciNyZW5kZXJDb25maWdcbiAqXG4gKiBUaGlzIGlzIHRoZSByZW5kZXJlciBjb25maWcgb2JqZWN0LCB3aGljaCBpczpcbiAqIDEuIEZpcnN0IHBhc3NlZCB0byBhIHtAbGluayBkYXRhTW9kZWxBUEkjZ2V0Q2VsbCBnZXRDZWxsfSBtZXRob2QgaW1wbGVtZW50YXRpb24sIHdoaWNoIG1heSBvdmVycmlkZSAobW9zdCBvZikgaXRzIHZhbHVlcyBiZWZvcmUgcmV0dXJuaW5nLlxuICogMi4gVGhlbiBwYXNzZWQgdG8gdGhlIHNwZWNpZmllZCBjZWxsIHJlbmRlcmVycycge0BsaW5rIENlbGxSZW5kZXJlciNwYWludCBwYWludH0gZnVuY3Rpb24gZm9yIHJlbmRlcmluZy5cbiAqXG4gKiAjIyMjIFN0YW5kYXJkIFByb3BlcnRpZXNcbiAqXG4gKiBPbiBlYWNoIGFuZCBldmVyeSByZW5kZXIgb2YgZXZlcnkgY2VsbCBpbiB2aWV3LCB0aGlzIGEgZnJlc2ggaW5zdGFuY2Ugb2YgYW4gb2JqZWN0IGNyZWF0ZWQgZnJvbSBhIHtAbGluayBDZWxsRXZlbnR9IG9iamVjdCwgd2hpY2ggaW4gdHVybiBkZXNjZW5kcyBmcm9tIHtAbGluayBtb2R1bGU6ZGVmYXVsdHN9LiBJdCB0aGVyZWZvcmUgaGFzIGFsbCB0aGUgc3RhbmRhcmQgcHJvcGVydGllcyBkZWZpbmVkIGluIGJvdGggb2JqZWN0cyAoc2VlKS5cbiAqXG4gKiAjIyMjIEFkZGl0aW9uYWwgUHJvcGVydGllc1xuICpcbiAqIFByb3BlcnRpZXMgbWFya2VkIF9yZWFkLW9ubHlfIGJlbG93IG1heSBpbiBmYWN0IGJlIHdyaXRhYmxlLCBidXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgKipvZmYgbGltaXRzKiogdG8gb3ZlcnJpZGluZy4gRG8gbm90IGF0dGVtcHQgdG8gY2hhbmdlIHRoZXNlIHByb3BlcnRpZXMgaW5zaWRlIGEge0BsaW5rIGRhdGFNb2RlbEFQSSNnZXRDZWxsIGdldENlbGx9IG1ldGhvZCBvdmVycmlkZS5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNvbmZpZy5hbGxSb3dzU2VsZWN0ZWRcbiAqXG4gKiBAcHJvcGVydHkge0JvdW5kaW5nUmVjdH0gY29uZmlnLmJvdW5kcyAtIEJvdW5kaW5nIHJlY3Qgb2YgdGhlIGNlbGwgb3Igc3ViY2VsbCB0byBiZSByZW5kZXJlZC5cbiAqXG4gKiBAcHJvcGVydHkge29iamVjdH0gYnV0dG9uQ2VsbHMgLSBfRm9yIGNlbGwgcmVuZGVyZXIgdXNlIG9ubHkuIE5vdCBhdmFpbGFibGUgaW4gYGdldENlbGxgIG92ZXJyaWRlLl8gIChCdXR0b24gcmVuZGVyZXJzIHJlZ2lzdGVyIHRoZW1zZWx2ZXMgaW4gdGhpcyBvYmplY3Qgc28gdGhlIGNsaWNrIGhhbmRsZXIgY2FuIGtub3cgd2hldGhlciBvciBub3QgdG8gZmlyZSB0aGUgJ2Zpbi1idXR0b24tcHJlc3NlZCcgZXZlbnQuKVxuICpcbiAqIEBwcm9wZXJ0eSB7ZGF0YUNlbGxDb29yZHN9IGNvbmZpZy5kYXRhQ2VsbCAtIF9SZWFkLW9ubHkuXyBEYXRhIGNvb3JkaW5hdGVzIG9mIHRoZSBjZWxsLlxuICpcbiAqIEBwcm9wZXJ0eSB7ZGF0YVJvd09iamVjdH0gY29uZmlnLmRhdGFSb3cgLSBBY2Nlc3MgdG8gb3RoZXIgY29sdW1uIHZhbHVlcyBpbiB0aGUgc2FtZSByb3cuXG4gKlxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gY29uZmlnLmZvcm1hdFZhbHVlIC0gX0ZvciBjZWxsIHJlbmRlcmVyIHVzZSBvbmx5LiBOb3QgYXZhaWxhYmxlIGluIGBnZXRDZWxsYCBvdmVycmlkZS5fIFRoZSBjZWxsJ3MgdmFsdWUgZm9ybWF0dGVyIGZ1bmN0aW9uIChiYXNlZCBvbiB0aGUgZm9ybWF0dGVyIG5hbWUgaW4gYGNvbmZpZy5mb3JtYXRgLCBhcyBwb3NzaWJseSBtdXRhdGVkIGJ5IGBnZXRDZWxsYCkuXG4gKlxuICogQHByb3BlcnR5IHtncmlkQ2VsbENvb3Jkc30gY29uZmlnLmdyaWRDZWxsIC0gX1JlYWQtb25seS5fIEdyaWQgY29vcmRpbmF0ZXMgb2YgdGhlIGNlbGwuXG4gKlxuICogQHByb3BlcnR5IHt9IGNvbmZpZy5oYWxpZ24gLSBUaGUgY2VsbCdzIGhvcml6b250YWwgYWxpZ25tZW50IHByb3BlcnR5LCBhcyBpbnRlcnByZXRlZCBieSBpdCdzIGNlbGwgcmVuZGVyZXIuXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBjb25maWcuaXNDZWxsSG92ZXJlZCAtXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBjb25maWcuaXNDZWxsU2VsZWN0ZWQgLVxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29uZmlnLmlzQ29sdW1uSG92ZXJlZCAtXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBjb25maWcuaXNDb2x1bW5TZWxlY3RlZCAtXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBjb25maWcuaXNEYXRhQ29sdW1uIC1cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNvbmZpZy5pc0RhdGFSb3cgLVxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29uZmlnLmlzRmlsdGVyUm93IC1cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNvbmZpZy5pc0hhbmRsZUNvbHVtbiAtXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBjb25maWcuaXNIZWFkZXJSb3cgLVxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29uZmlnLmlzSW5DdXJyZW50U2VsZWN0aW9uUmVjdGFuZ2xlIC1cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNvbmZpZy5pc1Jvd0hvdmVyZWQgLVxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29uZmlnLmlzUm93U2VsZWN0ZWQgLVxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29uZmlnLmlzU2VsZWN0ZWQgLVxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29uZmlnLmlzVHJlZUNvbHVtbiAtXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBjb25maWcuaXNVc2VyRGF0YUFyZWEgLVxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb25maWcubWluV2lkdGggLSBfRm9yIGNlbGwgcmVuZGVyZXIgdXNlIG9ubHkuIE5vdCBhdmFpbGFibGUgaW4gYGdldENlbGxgIG92ZXJyaWRlLl8gVGhlIENlbGwgcmVuZGVyZXIgcmV0dXJucyB0aGUgcGl4ZWwgd2lkdGggb2YgdGhlIHJlbmRlcmVkIGNvbnRlbnRzIGluIHRoaXMgcHJvcGVydHkuXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBjb25maWcubW91c2VEb3duIC0gVGhlIGxhc3QgbW91c2Vkb3duIGV2ZW50IG9jY3VyZWQgb3ZlciB0aGlzIGNlbGwgYW5kIHRoZSBtb3VzZSBpcyBzdGlsbCBkb3duLiBOb3RlLCBob3dldmVyLCB0aGF0IHRoZSBtb3VzZSBtYXkgbm8gbG9uZ2VyIGJlIGhvdmVyaW5nIG92ZXIgdGhpcyBjZWxsIHdoZW4gaXQgaGFzIGJlZW4gZHJhZ2dlZCBhd2F5LlxuICpcbiAqIEBwcm9wZXJ0eSB7fSBbY29uZmlnLnByZWZpbGxDb2xvcl0gLSBfRm9yIGNlbGwgcmVuZGVyZXIgdXNlIG9ubHkuIERvIG5vdCBtdXRhdGUgaW4gYGdldENlbGxgIG92ZXJyaWRlLl8gKFRoaXMgaXMgdGhlIGNvbG9yIGFscmVhZHkgcGFpbnRlZCBiZWhpbmQgdGhlIGNlbGwgdG8gYmUgcmVuZGVyZWQuIElmIHRoZSBjZWxsJ3Mgc3BlY2lmaWVkIGJhY2tncm91bmQgY29sb3IgaXMgdGhlIHNhbWUsIHJlbmRlcmVyIG1heSAoYW5kIHNob3VsZCEpIHNraXAgcGFpbnRpbmcgaXQuIElmIGB1bmRlZmluZWRgLCB0aGlzIGlzIGEgXCJwYXJ0aWFsIHJlbmRlclwiIGFuZCBjZWxsIHJlbmRlcmVycyB0aGF0IHN1cHBvcnQgcGFydGlhbCByZW5kZXJpbmcgY2FuIHVzZSBgY29uZmlnLnNuYXBzaG90YCB0byBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgdG8gcmVyZW5kZXIgdGhlIGNlbGwuKVxuICpcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbY29uZmlnLnNuYXBzaG90XSAtIF9Gb3IgY2VsbCByZW5kZXJlciB1c2Ugb25seS4gTm90IGF2YWlsYWJsZSBpbiBgZ2V0Q2VsbGAgb3ZlcnJpZGUuXyBTdXBwb3J0cyBfcGFydGlhbCByZW5kZXIuXyBJbiBzdXBwb3J0IG9mIHRoZSB7QGxpbmsgUmVuZGVyZXIjcGFpbnRDZWxsc0FzTmVlZGVkIGJ5LWNlbGxzfSBcInBhcnRpYWxcIiBncmlkIHJlbmRlcmVyLCBjZWxsIHJlbmRlcmVycyBjYW4gc2F2ZSB0aGUgZXNzZW50aWFsIHJlbmRlciBwYXJhbWV0ZXJzIGluIHRoaXMgcHJvcGVydHkgc28gdGhhdCBvbiBzdWJzZXF1ZW50IGNhbGxzLCB3aGVuIHRoZSBwYXJhbWV0ZXJzIGFyZSB0aGUgc2FtZSwgY2VsbCByZW5kZXJlcnMgY2FuIHNraXAgdGhlIGFjdHVhbCByZW5kZXJpbmcuIE9ubHkgd2hlbiB0aGUgcGFyYW1ldGVycyBoYXZlIGNoYW5nZWQgaXMgdGhlIGNlbGwgcmVuZGVyZWQgYW5kIHRoaXMgcHJvcGVydHkgcmVzZXQgKHdpdGggdGhlIG5ldyBwYXJhbWV0ZXJzKS4gVGhpcyBvYmplY3Qgd291bGQgdHlwaWNhbGx5IGluY2x1ZGUgYXQgdGhlIHZlcnkgbGVhc3QgdGhlIChmb3JtYXR0ZWQpIGB2YWx1ZWAsIHBsdXMgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGFzIG5lZWRlZCB0byBmdWxseSBkZXNjcmliZSB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgcmVuZGVyLCBzdWNoIGFzIGNvbG9yLCBfZXRjLl8gVGhpcyBwcm9wZXJ0eSBpcyB1bmRlZmluZWQgdGhlIGZpcnN0IHRpbWUgYSBjZWxsIGlzIHJlbmRlcmVkIGJ5IHRoZSBgYnktY2VsbHNgIGdyaWQgcmVuZGVyZXIuIFNlZSBhbHNvIHRoZSB7QGxpbmsgZGF0YU1vZGVsQVBJI2NvbmZpZ09iamVjdH0ncyBgcHJlZmlsbENvbG9yYCBwcm9wZXJ0eS5cbiAqXG4gKiBAcHJvcGVydHkgY29uZmlnLnZhbHVlIC0gVmFsdWUgdG8gYmUgcmVuZGVyZWQuXG4gKlxuICogVGhlIHJlbmRlcmVyIGhhcyBhdmFpbGFibGUgdG8gaXQgdGhlIGAuZm9ybWF0VmFsdWUoKWAgZnVuY3Rpb24gZm9yIGZvcm1hdHRpbmcgdGhlIHZhbHVlLiBUaGUgZnVuY3Rpb24gY29tZXMgZnJvbSB0aGUgbG9jYWxpemVyIG5hbWVkIGluIHRoZSBgLmZvcm1hdGAgcHJvcGVydHkuIElmIHRoZXJlIGlzIG5vIGxvY2FsaXplciB3aXRoIHRoYXQgbmFtZSwgdGhlIGZ1bmN0aW9uIGRlZmF1bHRzIHRvIHRoZSBgc3RyaW5nYCBsb2NhbGl6ZXIncyBmb3JtYXR0ZXIgKHdoaWNoIHNpbXBseSBpbnZva2VzIHRoZSB2YWx1ZSdzIGB0b1N0cmluZygpYCBtZXRob2QpLlxuICpcbiAqIFR5cGljYWxseSBhIExvY2FsIHByaW1pdGl2ZSB2YWx1ZSwgdmFsdWVzIGNhbiBiZSBhbnkgdHlwZSwgaW5jbHVkaW5nIG9iamVjdHMgYW5kIGFycmF5cy4gVGhlIHNwZWNpZmllZCBjZWxsIHJlbmRlcmVyIGlzIGV4cGVjdGVkIHRvIGtub3cgaG93IHRvIGRldGVybWluZSB0aGUgdmFsdWUncyB0eXBlIGFuZCByZW5kZXIgaXQuXG4gKi9cblxudmFyIEJhc2UgPSByZXF1aXJlKCcuLi9CYXNlJyk7XG5cbi8qKiBAY29uc3RydWN0b3JcbiAqIEBkZXNjIEluc3RhbmNlcyBvZiBgQ2VsbFJlbmRlcmVyYCBhcmUgdXNlZCB0byByZW5kZXIgdGhlIDJEIGdyYXBoaWNzIGNvbnRleHQgd2l0aGluIHRoZSBib3VuZCBvZiBhIGNlbGwuXG4gKlxuICogRXh0ZW5kIHRoaXMgYmFzZSBjbGFzcyB0byBpbXBsZW1lbnQgeW91ciBvd24gY2VsbCByZW5kZXJlci5cbiAqXG4gKiBAdHV0b3JpYWwgY2VsbC1yZW5kZXJlclxuICovXG52YXIgQ2VsbFJlbmRlcmVyID0gQmFzZS5leHRlbmQoJ0NlbGxSZW5kZXJlcicsIHtcbiAgICAvKipcbiAgICAgKiBAZGVzYyBBbiBlbXB0eSBpbXBsZW1lbnRhdGlvbiBvZiBhIGNlbGwgcmVuZGVyZXIsIHNlZSBbdGhlIG51bGwgb2JqZWN0IHBhdHRlcm5dKGh0dHA6Ly9jMi5jb20vY2dpL3dpa2k/TnVsbE9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAdGhpcyB7Q2VsbEVkaXRvcn1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDZWxsUmVuZGVyZXIjcmVuZGVyQ29uZmlnfSBjb25maWdcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFByZWZlcnJlZCBwaXhlbCB3aWR0aCBvZiBjb250ZW50LiBUaGUgY29udGVudCBtYXkgb3IgbWF5IG5vdCBiZSByZW5kZXJlZCBhdCB0aGF0IHdpZHRoIGRlcGVuZGluZyBvbiB3aGV0aGVyIG9yIG5vdCBgY29uZmlnLmJvdW5kc2Agd2FzIHJlc3BlY3RlZCBhbmQgd2hldGhlciBvciBub3QgdGhlIGdyaWQgcmVuZGVyZXIgaXMgdXNpbmcgY2xpcHBpbmcuIChDbGlwcGluZyBpcyBnZW5lcmFsbHkgbm90IHVzZWQgZHVlIHRvIHBvb3IgcGVyZm9ybWFuY2UuKVxuICAgICAqXG4gICAgICogQG1lbWJlck9mIENlbGxSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwYWludDogZnVuY3Rpb24oZ2MsIGNvbmZpZykge30sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBBIHNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiByb3VuZGluZyBhIGNlbGwuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgeCBncmlkIGNvb3JkaW5hdGUgb2YgbXkgb3JpZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgeSBncmlkIGNvb3JkaW5hdGUgb2YgbXkgb3JpZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gdGhlIHdpZHRoIEknbSBhbGxvd2VkIHRvIGRyYXcgd2l0aGluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBoZWlnaHQgSSdtIGFsbG93ZWQgdG8gZHJhdyB3aXRoaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZpbGxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3Ryb2tlXG4gICAgICogQG1lbWJlck9mIENlbGxSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICByb3VuZFJlY3Q6IGZ1bmN0aW9uKGdjLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMsIGZpbGwsIHN0cm9rZSkge1xuXG4gICAgICAgIGlmICghc3Ryb2tlKSB7XG4gICAgICAgICAgICBzdHJva2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmFkaXVzKSB7XG4gICAgICAgICAgICByYWRpdXMgPSA1O1xuICAgICAgICB9XG4gICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICBnYy5tb3ZlVG8oeCArIHJhZGl1cywgeSk7XG4gICAgICAgIGdjLmxpbmVUbyh4ICsgd2lkdGggLSByYWRpdXMsIHkpO1xuICAgICAgICBnYy5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcbiAgICAgICAgZ2MubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgICAgIGdjLnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICAgICAgICBnYy5saW5lVG8oeCArIHJhZGl1cywgeSArIGhlaWdodCk7XG4gICAgICAgIGdjLnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgICAgIGdjLmxpbmVUbyh4LCB5ICsgcmFkaXVzKTtcbiAgICAgICAgZ2MucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcmFkaXVzLCB5KTtcbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgICAgIGdjLnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgICBnYy5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHV0aWxpdHkgZnVuY3Rpb24gdG8gcmVuZGVyIFNWRyBpbWFnZSB3aXRoIGFuIHRleHQgaW5zaWRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBsZWZ0IHBvaW50IG9mIGFyZWEgd2hlcmUgaW1hZ2Ugd2lsbCBiZSByZW5kZXJlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdG9wIHBvaW50IG9mIGFyZWEgd2hlcmUgaW1hZ2Ugd2lsbCBiZSByZW5kZXJlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHdpZHRoIG9mIGFyZWEgd2hlcmUgaW1hZ2Ugd2lsbCBiZSByZW5kZXJlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBoZWlnaHQgb2YgYXJlYSB3aGVyZSBpbWFnZSB3aWxsIGJlIHJlbmRlcmVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN2Z1NyYyAtIGxpbmsgdG8gYW4gaW1hZ2UsIHRoYXQgbmVlZGVkIHRvIGJlIHJlbmRlcmVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbCAtIHRleHQgdmFsdWUsIHRoYXQgd2lsbCBiZSByZW5kZXJlZCBpbnNpZGUgaW1hZ2UgYXJlYVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb250IC0gZm9udCBvZiBhbiBpbm5lciB0ZXh0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnRDb2xvciAtIGZvbnQgY29sb3Igb2YgYW4gaW5uZXIgdGV4dFxuICAgICAqIEBtZW1iZXJPZiBDZWxsUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcmVuZGVyU3ZnSW1hZ2VXaXRoVGV4dDogZnVuY3Rpb24oZ2MsIHgsIHksIGhlaWdodCwgd2lkdGgsIHN2Z1NyYywgdmFsLCBmb250LCBmb250Q29sb3IpIHtcbiAgICAgICAgbGV0IHByZXZGb250U3RhdGUgPSBnYy5jYWNoZS5mb250LFxuICAgICAgICAgICAgcHJldkZpbGxTdHlsZVN0YXRlID0gZ2MuY2FjaGUuZmlsbFN0eWxlLFxuICAgICAgICAgICAgcHJldlRleHRBbGlnbiA9IGdjLmNhY2hlLnRleHRBbGlnbjtcblxuICAgICAgICBsZXQgaW1nID0gbmV3IEltYWdlO1xuICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGdjLmRyYXdJbWFnZShpbWcsIHgsIHksIGhlaWdodCwgd2lkdGgpO1xuXG4gICAgICAgICAgICBsZXQgdGV4dFN0YXJ0WCA9IHggKyB3aWR0aCAvIDI7XG4gICAgICAgICAgICBsZXQgdGV4dFN0YXJ0WSA9IHkgKyBoZWlnaHQgLyAyICsgNTtcblxuICAgICAgICAgICAgZ2MuY2FjaGUuZm9udCA9IGZvbnQ7XG4gICAgICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSBmb250Q29sb3I7XG4gICAgICAgICAgICBnYy5jYWNoZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcblxuICAgICAgICAgICAgaWYgKHZhbC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gJy4uLic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdjLnNpbXBsZVRleHQodmFsLFxuICAgICAgICAgICAgICAgIHRleHRTdGFydFgsXG4gICAgICAgICAgICAgICAgdGV4dFN0YXJ0WSk7XG5cbiAgICAgICAgICAgIGdjLmNhY2hlLmZvbnQgPSBwcmV2Rm9udFN0YXRlO1xuICAgICAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gcHJldkZpbGxTdHlsZVN0YXRlO1xuICAgICAgICAgICAgZ2MuY2FjaGUudGV4dEFsaWduID0gcHJldlRleHRBbGlnbjtcbiAgICAgICAgfTtcbiAgICAgICAgaW1nLnNyYyA9IHN2Z1NyYztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgdXRpbGl0eSBmdW5jdGlvbiB0byByZW5kZXIgdHJpYW5nbGUgd2l0aCByb3VuZGVkIGNvcm5lcnMgd2l0aCBhbiBpbm5lciB0ZXh0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBsZWZ0IHBvaW50IG9mIGFyZWEgd2hlcmUgdHJpYW5nbGUgd2lsbCBiZSByZW5kZXJlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdG9wIHBvaW50IG9mIGFyZWEgd2hlcmUgdHJpYW5nbGUgd2lsbCBiZSByZW5kZXJlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHdpZHRoIG9mIGFyZWEgd2hlcmUgdHJpYW5nbGUgd2lsbCBiZSByZW5kZXJlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBoZWlnaHQgb2YgYXJlYSB3aGVyZSB0cmlhbmdsZSB3aWxsIGJlIHJlbmRlcmVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvcm5lclJhZGl1cyAtIGNvcm5lciByYWRpdXMgb2YgdHJpYW5nbGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsbFN0eWxlIC0gZmlsbCBzdHlsZSBvZiBhbiBlbnRpcmUgdHJpYW5nbGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsIC0gdGV4dCB2YWx1ZSwgdGhhdCB3aWxsIGJlIHJlbmRlcmVkIGluc2lkZSBpbWFnZSBhcmVhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnQgLSBmb250IG9mIGFuIGlubmVyIHRleHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9udENvbG9yIC0gZm9udCBjb2xvciBvZiBhbiBpbm5lciB0ZXh0XG4gICAgICogQG1lbWJlck9mIENlbGxSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICByZW5kZXJSb3VuZGVkVHJpYW5nbGVXaXRoVGV4dDogZnVuY3Rpb24oZ2MsIHgsIHksIGhlaWdodCwgd2lkdGgsIGNvcm5lclJhZGl1cywgZmlsbFN0eWxlLCB2YWwsIGZvbnQsIGZvbnRDb2xvcikge1xuICAgICAgICBsZXQgcHJldkZvbnRTdGF0ZSA9IGdjLmNhY2hlLmZvbnQsXG4gICAgICAgICAgICBwcmV2RmlsbFN0eWxlU3RhdGUgPSBnYy5jYWNoZS5maWxsU3R5bGUsXG4gICAgICAgICAgICBwcmV2VGV4dEFsaWduID0gZ2MuY2FjaGUudGV4dEFsaWduLFxuICAgICAgICAgICAgcHJldkxpbmVKb2luID0gZ2MuY2FjaGUubGluZUpvaW4sXG4gICAgICAgICAgICBwcmV2TGluZVdpZHRoID0gZ2MuY2FjaGUubGluZVdpZHRoO1xuXG4gICAgICAgIGxldCB0b3BQb2ludFggPSB4ICsgd2lkdGggLyAyO1xuICAgICAgICBsZXQgdG9wUG9pbnRZID0geSArIGNvcm5lclJhZGl1cyAqIDI7XG5cbiAgICAgICAgbGV0IHRyaWFuZ2xlV2lkdGggPSB3aWR0aCAtIGNvcm5lclJhZGl1cyAqIDI7XG4gICAgICAgIGxldCB0cmlhbmdsZUhlaWdodCA9IGhlaWdodCAtIGNvcm5lclJhZGl1cyAqIDI7XG5cbiAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIGdjLm1vdmVUbyh0b3BQb2ludFgsIHRvcFBvaW50WSk7XG4gICAgICAgIGdjLmxpbmVUbyh0b3BQb2ludFggKyB0cmlhbmdsZVdpZHRoIC8gMiwgdG9wUG9pbnRZICsgdHJpYW5nbGVIZWlnaHQpO1xuICAgICAgICBnYy5saW5lVG8odG9wUG9pbnRYIC0gdHJpYW5nbGVXaWR0aCAvIDIsIHRvcFBvaW50WSArIHRyaWFuZ2xlSGVpZ2h0KTtcbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgICAgIGdjLmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAgICAgZ2MuZmlsbCgpO1xuXG5cbiAgICAgICAgZ2MubGluZVdpZHRoID0gY29ybmVyUmFkaXVzO1xuICAgICAgICBnYy5saW5lSm9pbiA9ICdyb3VuZCc7XG4gICAgICAgIGdjLnN0cm9rZVN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgICBnYy5zdHJva2UoKTtcblxuICAgICAgICBsZXQgdGV4dFN0YXJ0WCA9IHggKyB3aWR0aCAvIDI7XG4gICAgICAgIGxldCB0ZXh0U3RhcnRZID0geSArIGhlaWdodCAvIDIgKyAzO1xuXG4gICAgICAgIGdjLmNhY2hlLmZvbnQgPSBmb250O1xuICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSBmb250Q29sb3I7XG4gICAgICAgIGdjLmNhY2hlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuXG4gICAgICAgIGlmICh2YWwubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFsID0gJy4uLic7XG4gICAgICAgIH1cblxuICAgICAgICBnYy5zaW1wbGVUZXh0KHZhbCxcbiAgICAgICAgICAgIHRleHRTdGFydFgsXG4gICAgICAgICAgICB0ZXh0U3RhcnRZKTtcblxuICAgICAgICBnYy5jYWNoZS5mb250ID0gcHJldkZvbnRTdGF0ZTtcbiAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gcHJldkZpbGxTdHlsZVN0YXRlO1xuICAgICAgICBnYy5jYWNoZS50ZXh0QWxpZ24gPSBwcmV2VGV4dEFsaWduO1xuICAgICAgICBnYy5jYWNoZS5saW5lSm9pbiA9IHByZXZMaW5lSm9pbjtcbiAgICAgICAgZ2MuY2FjaGUubGluZVdpZHRoID0gcHJldkxpbmVXaWR0aDtcbiAgICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2VsbFJlbmRlcmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbFJlbmRlcmVyID0gcmVxdWlyZSgnLi9DZWxsUmVuZGVyZXInKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENlbGxSZW5kZXJlclxuICovXG52YXIgRXJyb3JDZWxsID0gQ2VsbFJlbmRlcmVyLmV4dGVuZCgnRXJyb3JDZWxsJywge1xuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgV3JpdGVzIGVycm9yIG1lc3NhZ2UgaW50byBjZWxsLlxuICAgICAqXG4gICAgICogQGRlc2MgVGhpcyBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIGJlIGNhbGxlZCBhcyBmb2xsb3dzOlxuICAgICAqXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIGdjLnNhdmUoKTtcbiAgICAgKiBnYy5iZWdpblBhdGgoKTtcbiAgICAgKiBnYy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAqIGdjLmNsaXAoKTtcbiAgICAgKiBiZWhhdmlvci5nZXRDZWxsUHJvdmlkZXIoKS5yZW5kZXJDZWxsRXJyb3IoZ2MsIG1lc3NhZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAqIGdjLnJlc3RvcmUoKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEJlZm9yZSBkb2luZyBhbnl0aGluZyBlbHNlLCB0aGlzIGZ1bmN0aW9uIHNob3VsZCBjbGVhciB0aGUgY2VsbCBieSBzZXR0aW5nIGBnYy5maWxsU3R5bGVgIGFuZCBjYWxsaW5nIGBnYy5maWxsKClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IGNvbmZpZy5ib3VuZHMgLSBUaGUgY2xpcHBpbmcgcmVjdCBvZiB0aGUgY2VsbCB0byBiZSByZW5kZXJlZC5cbiAgICAgKiBAbWVtYmVyT2YgRXJyb3JDZWxsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHBhaW50OiBmdW5jdGlvbihnYywgY29uZmlnLCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciB4ID0gY29uZmlnLmJvdW5kcy54LFxuICAgICAgICAgICAgeSA9IGNvbmZpZy5ib3VuZHMueSxcbiAgICAgICAgICAgIC8vIHdpZHRoID0gY29uZmlnLmJvdW5kcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbmZpZy5ib3VuZHMuaGVpZ2h0O1xuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBjZWxsXG4gICAgICAgIC8vICh0aGlzIG1ha2VzIHVzZSBvZiB0aGUgcmVjdCBwYXRoIGRlZmluZWQgYnkgdGhlIGNhbGxlcilcbiAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gJyNGRkZGRkYnO1xuICAgICAgICBnYy5maWxsKCk7XG5cbiAgICAgICAgLy8gcmVuZGVyIG1lc3NhZ2UgdGV4dFxuICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSAnI2E5NGQ0ZGMyJztcbiAgICAgICAgZ2MuY2FjaGUudGV4dEFsaWduID0gJ3N0YXJ0JztcbiAgICAgICAgZ2MuY2FjaGUudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgIGdjLmNhY2hlLmZvbnQgPSAnMTNweCBcIkhlbHZldGljYSBOZXVlXCIsSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWYnO1xuICAgICAgICBnYy5zaW1wbGVUZXh0KG1lc3NhZ2UsIHggKyA0LCB5ICsgaGVpZ2h0IC8gMiArIDAuNSk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRXJyb3JDZWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbFJlbmRlcmVyID0gcmVxdWlyZSgnLi9DZWxsUmVuZGVyZXInKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBkZXNjIEEgcmVuZGVyaW5nIG9mIHRoZSBsYXN0IFNlbGVjdGlvbiBNb2RlbFxuICogQGV4dGVuZHMgQ2VsbFJlbmRlcmVyXG4gKi9cbnZhciBMYXN0U2VsZWN0aW9uID0gQ2VsbFJlbmRlcmVyLmV4dGVuZCgnTGFzdFNlbGVjdGlvbicsIHtcbiAgICBwYWludDogZnVuY3Rpb24oZ2MsIGNvbmZpZykge1xuICAgICAgICB2YXIgdmlzT3ZlcmxheSA9IGdjLmFscGhhKGNvbmZpZy5zZWxlY3Rpb25SZWdpb25PdmVybGF5Q29sb3IpID4gMCxcbiAgICAgICAgICAgIHZpc091dGxpbmUgPSBnYy5hbHBoYShjb25maWcuc2VsZWN0aW9uUmVnaW9uT3V0bGluZUNvbG9yKSA+IDA7XG5cbiAgICAgICAgaWYgKHZpc092ZXJsYXkgfHwgdmlzT3V0bGluZSkge1xuICAgICAgICAgICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICAgICAgeSA9IGNvbmZpZy5ib3VuZHMueSxcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGNvbmZpZy5ib3VuZHMud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmJvdW5kcy5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmICh2aXNPdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgICAgICBnYy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gY29uZmlnLnNlbGVjdGlvblJlZ2lvbk92ZXJsYXlDb2xvcjtcbiAgICAgICAgICAgICAgICBnYy5maWxsKCk7XG5cbiAgICAgICAgICAgICAgICBnYy5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZpc091dGxpbmUpIHtcbiAgICAgICAgICAgICAgICBkcmF3UmVjdEJvcmRlcihnYyxcbiAgICAgICAgICAgICAgICAgICAgeCAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHkgLSAxLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCArIDEsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCArIDEsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5zZWxlY3Rpb25SZWdpb25PdXRsaW5lQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5zZWxlY3Rpb25SZWdpb25Cb3JkZXJXaWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBMYXN0U2VsZWN0aW9uO1xuXG5mdW5jdGlvbiBkcmF3UmVjdEJvcmRlcihjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvbG9yLCBsaW5lV2lkdGgpIHtcbiAgICBjdHguY2FjaGUuZmlsbFN0eWxlID0gY29sb3I7XG4gICAgY3R4LmZpbGxSZWN0KHgsIHksIGxpbmVXaWR0aCwgaGVpZ2h0KTtcbiAgICBjdHguZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGxpbmVXaWR0aCk7XG4gICAgY3R4LmZpbGxSZWN0KHggKyB3aWR0aCwgeSwgbGluZVdpZHRoLCBoZWlnaHQpO1xuICAgIGN0eC5maWxsUmVjdCh4LCB5ICsgaGVpZ2h0LCB3aWR0aCArIDEsIGxpbmVXaWR0aCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsUmVuZGVyZXIgPSByZXF1aXJlKCcuL0NlbGxSZW5kZXJlcicpO1xudmFyIGltYWdlcyA9IHJlcXVpcmUoJy4uLy4uL2ltYWdlcycpO1xuXG52YXIgV0hJVEVTUEFDRSA9IC9cXHNcXHMrL2c7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAc3VtbWFyeSBUaGUgZGVmYXVsdCBjZWxsIHJlbmRlcmVyIGZvciBhIHZhbmlsbGEgY2VsbC5cbiAqIEBkZXNjIEdyZWF0IGNhcmUgaGFzIGJlZW4gdGFrZW4gaW4gY3JhZnRpbmcgdGhpcyBmdW5jdGlvbiBhcyBpdCBuZWVkcyB0byBwZXJmb3JtIGV4dHJlbWVseSBmYXN0LlxuICpcbiAqIFVzZSBgZ2MuY2FjaGVgIGluc3RlYWQgd2hpY2ggd2UgaGF2ZSBpbXBsZW1lbnRlZCB0byBjYWNoZSB0aGUgZ3JhcGhpY3MgY29udGV4dCBwcm9wZXJ0aWVzLiBSZWFkcyBvbiB0aGUgZ3JhcGhpY3MgY29udGV4dCAoYGdjYCkgcHJvcGVydGllcyBhcmUgZXhwZW5zaXZlIGJ1dCBub3QgcXVpdGUgYXMgZXhwZW5zaXZlIGFzIHdyaXRlcy4gT24gcmVhZCBvZiBhIGBnYy5jYWNoZWAgcHJvcCwgdGhlIGFjdHVhbCBgZ2NgIHByb3AgaXMgcmVhZCBpbnRvIHRoZSBjYWNoZSBvbmNlIGFuZCBmcm9tIHRoZW4gb24gb25seSB0aGUgY2FjaGUgaXMgcmVmZXJlbmNlZCBmb3IgdGhhdCBwcm9wZXJ0eS4gT24gd3JpdGUsIHRoZSBhY3R1YWwgcHJvcCBpcyBvbmx5IHdyaXR0ZW4gdG8gd2hlbiB0aGUgbmV3IHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgY2FjaGVkIHZhbHVlLlxuICpcbiAqIENsaXBwaW5nIGJvdW5kcyBhcmUgbm90IHNldCBoZXJlIGFzIHRoaXMgaXMgYWxzbyBhbiBleHBlbnNpdmUgb3BlcmF0aW9uLiBJbnN0ZWFkLCB3ZSBlbXBsb3kgYSBudW1iZXIgb2Ygc3RyYXRlZ2llcyB0byB0cnVuY2F0ZSBvdmVyZmxvd2luZyB0ZXh0IGFuZCBjb250ZW50LlxuICpcbiAqIEBleHRlbmRzIENlbGxSZW5kZXJlclxuICovXG52YXIgU2ltcGxlQ2VsbCA9IENlbGxSZW5kZXJlci5leHRlbmQoJ1NpbXBsZUNlbGwnLCB7XG4gICAgcGFpbnQ6IGZ1bmN0aW9uKGdjLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHZhbCA9IGNvbmZpZy52YWx1ZSxcbiAgICAgICAgICAgIGJvdW5kcyA9IGNvbmZpZy5ib3VuZHMsXG4gICAgICAgICAgICB4ID0gYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gYm91bmRzLnksXG4gICAgICAgICAgICB3aWR0aCA9IGJvdW5kcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQsXG4gICAgICAgICAgICBpY29uUGFkZGluZyA9IGNvbmZpZy5pY29uUGFkZGluZyxcbiAgICAgICAgICAgIHBhcnRpYWxSZW5kZXIgPSBjb25maWcucHJlZmlsbENvbG9yID09PSB1bmRlZmluZWQsIC8vIHNpZ25pZmllcyBhYm9ydCBiZWZvcmUgcmVuZGVyaW5nIGlmIHNhbWVcbiAgICAgICAgICAgIHNuYXBzaG90ID0gY29uZmlnLnNuYXBzaG90LFxuICAgICAgICAgICAgc2FtZSA9IHNuYXBzaG90ICYmIHBhcnRpYWxSZW5kZXIsXG4gICAgICAgICAgICB2YWxXaWR0aCA9IDAsXG4gICAgICAgICAgICB0ZXh0Q29sb3IsIHRleHRGb250LFxuICAgICAgICAgICAgaXhvZmZzZXQsIGl5b2Zmc2V0LFxuICAgICAgICAgICAgbGVmdEljb24sIHJpZ2h0SWNvbiwgY2VudGVySWNvbixcbiAgICAgICAgICAgIGxlZnRQYWRkaW5nLCByaWdodFBhZGRpbmcsXG4gICAgICAgICAgICBob3ZlciwgaG92ZXJDb2xvciwgc2VsZWN0Q29sb3IsIGZvdW5kYXRpb25Db2xvciwgaW5oZXJpdHNCYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBjLCBjb2xvcnM7XG5cbiAgICAgICAgLy8gc2V0dGluZyBnYyBwcm9wZXJ0aWVzIGFyZSBleHBlbnNpdmUsIGxldCdzIG5vdCBkbyBpdCBuZWVkbGVzc2x5XG5cbiAgICAgICAgbGVmdEljb24gPSBpbWFnZXNbY29uZmlnLmxlZnRJY29uXTtcbiAgICAgICAgY2VudGVySWNvbiA9IGltYWdlc1tjb25maWcuY2VudGVySWNvbl07XG4gICAgICAgIHJpZ2h0SWNvbiA9IGltYWdlc1tjb25maWcucmlnaHRJY29uXTtcblxuICAgICAgICAvLyBOb3RlOiB2ZiA9PSAwIGlzIGZhc3Rlc3QgZXF1aXZhbGVudCBvZiB2ZiA9PT0gMCB8fCB2ZiA9PT0gZmFsc2Ugd2hpY2ggZXhjbHVkZXMgTmFOLCBudWxsLCB1bmRlZmluZWRcbiAgICAgICAgdmFyIHJlbmRlclZhbHVlID0gdmFsIHx8IGNvbmZpZy5yZW5kZXJGYWxzeSAmJiB2YWwgPT0gMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcblxuICAgICAgICBpZiAocmVuZGVyVmFsdWUgJiYgY29uZmlnLmlzRGF0YVJvdykge1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSBjb25maWcuZ3JpZC5iZWhhdmlvci5kYXRhTW9kZWwuZ2V0Q291bnQoY29uZmlnLmRhdGFDZWxsLngsIGNvbmZpZy5kYXRhQ2VsbC55KTtcbiAgICAgICAgICAgIGlmIChjb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLnZhbHVlUG9zdGZpeCA9IGAoJHtjb3VudH0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJWYWx1ZSkge1xuICAgICAgICAgICAgdmFsID0gY29uZmlnLmZvcm1hdFZhbHVlKHZhbCwgY29uZmlnKTtcblxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgICAgIHZhbCA9IGBbJHt2YWwuam9pbignLCAnKX1dYDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGV4dEZvbnQgPSBjb25maWcuaXNTZWxlY3RlZCA/IGNvbmZpZy5mb3JlZ3JvdW5kU2VsZWN0aW9uRm9udCA6IGNvbmZpZy5mb250O1xuXG4gICAgICAgICAgICB0ZXh0Q29sb3IgPSBnYy5jYWNoZS5zdHJva2VTdHlsZSA9IGNvbmZpZy5pc1NlbGVjdGVkXG4gICAgICAgICAgICAgICAgPyBjb25maWcuZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yXG4gICAgICAgICAgICAgICAgOiBjb25maWcuY29sb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWwgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHNhbWUgPSBzYW1lICYmXG4gICAgICAgICAgICB2YWwgPT09IHNuYXBzaG90LnZhbHVlICYmXG4gICAgICAgICAgICB0ZXh0Rm9udCA9PT0gc25hcHNob3QudGV4dEZvbnQgJiZcbiAgICAgICAgICAgIHRleHRDb2xvciA9PT0gc25hcHNob3QudGV4dENvbG9yO1xuXG4gICAgICAgIC8vIGZpbGwgYmFja2dyb3VuZCBvbmx5IGlmIG91ciBiZ0NvbG9yIGlzIHBvcHVsYXRlZCBvciB3ZSBhcmUgYSBzZWxlY3RlZCBjZWxsXG4gICAgICAgIGNvbG9ycyA9IFtdO1xuICAgICAgICBjID0gMDtcblxuICAgICAgICBpZiAoIWNvbmZpZy5kaXNhYmxlSG92ZXJIaWdobGlnaHRpbmcpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcuaXNDZWxsSG92ZXJlZCAmJiBjb25maWcuaG92ZXJDZWxsSGlnaGxpZ2h0LmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBob3ZlckNvbG9yID0gY29uZmlnLmhvdmVyQ2VsbEhpZ2hsaWdodC5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5pc1Jvd0hvdmVyZWQgJiYgKGhvdmVyID0gY29uZmlnLmhvdmVyUm93SGlnaGxpZ2h0KS5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgaG92ZXJDb2xvciA9IGNvbmZpZy5pc0RhdGFDb2x1bW4gfHwgIWhvdmVyLmhlYWRlciB8fCBob3Zlci5oZWFkZXIuYmFja2dyb3VuZENvbG9yID09PSB1bmRlZmluZWQgPyBob3Zlci5iYWNrZ3JvdW5kQ29sb3IgOiBob3Zlci5oZWFkZXIuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcuaXNDb2x1bW5Ib3ZlcmVkICYmIChob3ZlciA9IGNvbmZpZy5ob3ZlckNvbHVtbkhpZ2hsaWdodCkuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGhvdmVyQ29sb3IgPSBjb25maWcuaXNEYXRhUm93IHx8ICFob3Zlci5oZWFkZXIgfHwgaG92ZXIuaGVhZGVyLmJhY2tncm91bmRDb2xvciA9PT0gdW5kZWZpbmVkID8gaG92ZXIuYmFja2dyb3VuZENvbG9yIDogaG92ZXIuaGVhZGVyLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnYy5hbHBoYShob3ZlckNvbG9yKSA8IDEpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcuaXNTZWxlY3RlZCAmJiAhY29uZmlnLmlzRmlyc3RTZWxlY3RlZENlbGwgJiYgKGNvbmZpZy5pc0hlYWRlclJvdyB8fCAhY29uZmlnLmlzRGF0YUNvbHVtbikpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RDb2xvciA9IGNvbmZpZy5iYWNrZ3JvdW5kSGVhZGVyU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChnYy5hbHBoYShzZWxlY3RDb2xvcikgPCAxKSB7XG4gICAgICAgICAgICAgICAgaW5oZXJpdHNCYWNrZ3JvdW5kQ29sb3IgPSAoY29uZmlnLmJhY2tncm91bmRDb2xvciA9PT0gY29uZmlnLnByZWZpbGxDb2xvcik7XG4gICAgICAgICAgICAgICAgaWYgKCFpbmhlcml0c0JhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZGF0aW9uQ29sb3IgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcuY29tYmluZUNvbG9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JzLnB1c2goY29uZmlnLmJhY2tncm91bmRDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcnMgPSBbY29uZmlnLmJhY2tncm91bmRDb2xvcl07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzYW1lID0gc2FtZSAmJiAgZm91bmRhdGlvbkNvbG9yID09PSBzbmFwc2hvdC5mb3VuZGF0aW9uQ29sb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5iYWNrZ3JvdW5kQ29sb3IgPT09IHNuYXBzaG90LmNvbG9yc1tjKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGVjdENvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmNvbWJpbmVDb2xvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JzLnB1c2goc2VsZWN0Q29sb3IpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9ycyA9IFtzZWxlY3RDb2xvcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvbG9ycy5wdXNoKHNlbGVjdENvbG9yKTtcbiAgICAgICAgICAgICAgICBzYW1lID0gc2FtZSAmJiBzZWxlY3RDb2xvciA9PT0gc25hcHNob3QuY29sb3JzW2MrK107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvdmVyQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5jb21iaW5lQ29sb3JzKSB7XG4gICAgICAgICAgICAgICAgY29sb3JzLnB1c2goaG92ZXJDb2xvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbG9ycyA9IFtob3ZlckNvbG9yXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2FtZSA9IHNhbWUgJiYgaG92ZXJDb2xvciA9PT0gc25hcHNob3QuY29sb3JzW2MrK107XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b2RvIGNoZWNrIGlmIGljb25zIGhhdmUgY2hhbmdlZFxuICAgICAgICBpZiAoc2FtZSAmJiBjID09PSBzbmFwc2hvdC5jb2xvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gYSBzbmFwc2hvdCB0byBzYXZlIGluIGNlbGxFdmVudCBmb3IgZnV0dXJlIGNvbXBhcmlzb25zIGJ5IHBhcnRpYWwgcmVuZGVyZXJcbiAgICAgICAgY29uZmlnLnNuYXBzaG90ID0ge1xuICAgICAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgICAgIHRleHRDb2xvcjogdGV4dENvbG9yLFxuICAgICAgICAgICAgdGV4dEZvbnQ6IHRleHRGb250LFxuICAgICAgICAgICAgZm91bmRhdGlvbkNvbG9yOiBmb3VuZGF0aW9uQ29sb3IsXG4gICAgICAgICAgICBjb2xvcnM6IGNvbG9yc1xuICAgICAgICB9O1xuXG4gICAgICAgIGxheWVyQ29sb3JzKGdjLCBjb2xvcnMsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGZvdW5kYXRpb25Db2xvcik7XG5cbiAgICAgICAgLy8gTWVhc3VyZSBsZWZ0IGFuZCByaWdodCBpY29ucywgbmVlZGVkIGZvciByZW5kZXJpbmcgYW5kIGZvciByZXR1cm4gdmFsdWUgKG1pbiB3aWR0aClcbiAgICAgICAgbGVmdFBhZGRpbmcgPSBsZWZ0SWNvbiA/IGljb25QYWRkaW5nICsgbGVmdEljb24ud2lkdGggKyBpY29uUGFkZGluZyA6IGNvbmZpZy5jZWxsUGFkZGluZ0xlZnQ7XG4gICAgICAgIHJpZ2h0UGFkZGluZyA9IHJpZ2h0SWNvbiA/IGljb25QYWRkaW5nICsgcmlnaHRJY29uLndpZHRoICsgaWNvblBhZGRpbmcgOiBjb25maWcuY2VsbFBhZGRpbmdSaWdodDtcblxuICAgICAgICBpZiAoY29uZmlnLmlzQWdncmVnYXRpb25UcmVlQ29sdW1uKSB7XG4gICAgICAgICAgICBsZWZ0UGFkZGluZyArPSBjb25maWcudHJlZUxldmVsICogY29uZmlnLmFnZ3JlZ2F0aW9uR3JvdXBUcmVlTGV2ZWxPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdGV4dFJpZ2h0UGFkZGluZyA9IHJpZ2h0UGFkZGluZztcblxuICAgICAgICBpZiAoY29uZmlnLnJlbmRlclRvdGFsRXJyb3JTaWduTmVlZGVkICYmIGNvbmZpZy5yZW5kZXJUb3RhbEVycm9yQ291bnQpIHtcbiAgICAgICAgICAgIGxldCB0b3RhbEVycm9yc0NvdW50SWNvblN0YXJ0WSA9IHkgKyAoaGVpZ2h0IC8gMiAtIGNvbmZpZy50b3RhbEVycm9yc0NvdW50SWNvbkhlaWdodCAvIDIpIC0gMjtcbiAgICAgICAgICAgIGxldCB0b3RhbEVycm9yc0NvdW50SWNvblN0YXJ0WCA9IHggKyAod2lkdGggLyAyIC0gY29uZmlnLnRvdGFsRXJyb3JzQ291bnRJY29uV2lkdGggLyAyKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUm91bmRlZFRyaWFuZ2xlV2l0aFRleHQoZ2MsXG4gICAgICAgICAgICAgICAgdG90YWxFcnJvcnNDb3VudEljb25TdGFydFgsXG4gICAgICAgICAgICAgICAgdG90YWxFcnJvcnNDb3VudEljb25TdGFydFksXG4gICAgICAgICAgICAgICAgY29uZmlnLnRvdGFsRXJyb3JzQ291bnRJY29uSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGNvbmZpZy50b3RhbEVycm9yc0NvdW50SWNvbldpZHRoLFxuICAgICAgICAgICAgICAgIDIsXG4gICAgICAgICAgICAgICAgY29uZmlnLmNvbHVtbldhcm5pbmdJY29uQ29sb3IsXG4gICAgICAgICAgICAgICAgY29uZmlnLnJlbmRlclRvdGFsRXJyb3JDb3VudCxcbiAgICAgICAgICAgICAgICBjb25maWcuY29sdW1uV2FybmluZ0ZvbnQsXG4gICAgICAgICAgICAgICAgY29uZmlnLmNvbHVtbldhcm5pbmdGb250Q29sb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5zaG93Q2VsbENvbnRleHRNZW51SWNvbiAmJiByZW5kZXJWYWx1ZSkge1xuICAgICAgICAgICAgZ2MuY2FjaGUuc3Ryb2tlU3R5bGUgPSBjb25maWcuY29udGV4dE1lbnVCdXR0b25TdHJva2VTdHlsZTtcbiAgICAgICAgICAgIGlmIChjb25maWcuY29udGV4dE1lbnVJY29uSXNIb3ZlcmVkKSB7XG4gICAgICAgICAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gY29uZmlnLmNvbnRleHRNZW51QnV0dG9uSG92ZXJlZEZpbGxTdHlsZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gY29uZmlnLmNvbnRleHRNZW51QnV0dG9uRmlsbFN0eWxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgYnV0dG9uU3RhcnRZID0geSArIChoZWlnaHQgLyAyIC0gY29uZmlnLmNvbnRleHRNZW51QnV0dG9uSGVpZ2h0IC8gMik7XG4gICAgICAgICAgICBsZXQgYnV0dG9uQ29udGVudFdpZHRoID0gY29uZmlnLmNvbnRleHRNZW51QnV0dG9uSWNvblByZWZlcmVkV2lkdGhcbiAgICAgICAgICAgICAgICArIDIgKiBjb25maWcuY29udGV4dE1lbnVCdXR0b25QYWRkaW5nO1xuXG4gICAgICAgICAgICBsZXQgYnV0dG9uU3RhcnRYID0geCArIHdpZHRoIC0gY29uZmlnLmNvbnRleHRNZW51QnV0dG9uUmlnaHRNYXJnaW4gLSBidXR0b25Db250ZW50V2lkdGg7XG5cbiAgICAgICAgICAgIHRoaXMucm91bmRSZWN0KGdjLFxuICAgICAgICAgICAgICAgIGJ1dHRvblN0YXJ0WCxcbiAgICAgICAgICAgICAgICBidXR0b25TdGFydFksXG4gICAgICAgICAgICAgICAgYnV0dG9uQ29udGVudFdpZHRoLFxuICAgICAgICAgICAgICAgIGNvbmZpZy5jb250ZXh0TWVudUJ1dHRvbkhlaWdodCxcbiAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgIHRydWUpO1xuXG4gICAgICAgICAgICBsZXQgcHJldkZvbnRTdGF0ZSA9IGdjLmNhY2hlLmZvbnQsXG4gICAgICAgICAgICAgICAgcHJldkZpbGxTdHlsZVN0YXRlID0gZ2MuY2FjaGUuZmlsbFN0eWxlO1xuXG4gICAgICAgICAgICBnYy5jYWNoZS5mb250ID0gY29uZmlnLmNvbnRleHRNZW51SWNvbkZvbnQ7XG5cbiAgICAgICAgICAgIGlmIChjb25maWcuY29udGV4dE1lbnVJY29uSXNIb3ZlcmVkKSB7XG4gICAgICAgICAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gY29uZmlnLmNvbnRleHRNZW51SWNvbkhvdmVyZWRDb2xvcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gY29uZmlnLmNvbnRleHRNZW51SWNvbkNvbG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY29uZmlnQ2xvbmUgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgY29uZmlnQ2xvbmUuaGFsaWduID0gJ3JpZ2h0JztcblxuICAgICAgICAgICAgbGV0IGljb25TdGFydFggPSB4ICsgd2lkdGggLSBjb25maWcuY29udGV4dE1lbnVCdXR0b25SaWdodE1hcmdpblxuICAgICAgICAgICAgICAgIC0gY29uZmlnLmNvbnRleHRNZW51QnV0dG9uUGFkZGluZ1xuICAgICAgICAgICAgICAgIC0gY29uZmlnLmNvbnRleHRNZW51QnV0dG9uSWNvblByZWZlcmVkV2lkdGg7XG4gICAgICAgICAgICBsZXQgaWNvblN0YXJ0WSA9IGJ1dHRvblN0YXJ0WSArIGNvbmZpZy5jb250ZXh0TWVudUJ1dHRvbkhlaWdodCAvIDI7XG5cbiAgICAgICAgICAgIGdjLnNpbXBsZVRleHQoY29uZmlnLmNvbnRleHRNZW51SWNvblVuaWNvZGVDaGFyLFxuICAgICAgICAgICAgICAgIGljb25TdGFydFgsXG4gICAgICAgICAgICAgICAgaWNvblN0YXJ0WSk7XG5cbiAgICAgICAgICAgIGdjLmNhY2hlLmZvbnQgPSBwcmV2Rm9udFN0YXRlO1xuICAgICAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gcHJldkZpbGxTdHlsZVN0YXRlO1xuXG4gICAgICAgICAgICB0ZXh0UmlnaHRQYWRkaW5nICs9IGJ1dHRvbkNvbnRlbnRXaWR0aCArIGNvbmZpZy5jb250ZXh0TWVudUxlZnRTcGFjZVRvQ3V0VGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuc2hvd0NvbHVtblR5cGUgJiYgY29uZmlnLmNvbFR5cGVTaWduKSB7XG4gICAgICAgICAgICBsZXQgcHJldkZvbnRTdGF0ZSA9IGdjLmNhY2hlLmZvbnQsXG4gICAgICAgICAgICAgICAgcHJldkZpbGxTdHlsZVN0YXRlID0gZ2MuY2FjaGUuZmlsbFN0eWxlO1xuXG4gICAgICAgICAgICBnYy5jYWNoZS5mb250ID0gY29uZmlnLmNvbHVtblR5cGVTaWduRm9udDtcbiAgICAgICAgICAgIGdjLmNhY2hlLmZpbGxTdHlsZSA9IGNvbmZpZy5jb2x1bW5UeXBlU2lnbkNvbG9yO1xuXG4gICAgICAgICAgICBsZXQgY29uZmlnQ2xvbmUgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgY29uZmlnQ2xvbmUuaGFsaWduID0gJ3JpZ2h0JztcblxuICAgICAgICAgICAgdGV4dFJpZ2h0UGFkZGluZyArPSByZW5kZXJTaW5nbGVMaW5lVGV4dChnYywgY29uZmlnQ2xvbmUsIGNvbmZpZy5jb2xUeXBlU2lnbiwgbGVmdFBhZGRpbmcsIHRleHRSaWdodFBhZGRpbmcpO1xuXG4gICAgICAgICAgICBnYy5jYWNoZS5mb250ID0gcHJldkZvbnRTdGF0ZTtcbiAgICAgICAgICAgIGdjLmNhY2hlLmZpbGxTdHlsZSA9IHByZXZGaWxsU3R5bGVTdGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcudmFsdWVQcmVmaXggJiYgIWNvbmZpZy5pZ25vcmVWYWx1ZVByZWZpeCkge1xuICAgICAgICAgICAgbGV0IHByZXZGb250U3RhdGUgPSBnYy5jYWNoZS5mb250LFxuICAgICAgICAgICAgICAgIHByZXZGaWxsU3R5bGVTdGF0ZSA9IGdjLmNhY2hlLmZpbGxTdHlsZTtcblxuICAgICAgICAgICAgZ2MuY2FjaGUuZm9udCA9IGNvbmZpZy52YWx1ZVByZWZpeEZvbnQ7XG4gICAgICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSBjb25maWcudmFsdWVQcmVmaXhDb2xvcjtcblxuICAgICAgICAgICAgY29uc3Qgb2xkSWdub3JlVW5kZXJsaW5pbmdTdGF0ZSA9IGNvbmZpZy5pZ25vcmVVbmRlcmxpbmluZztcbiAgICAgICAgICAgIGNvbmZpZy5pZ25vcmVVbmRlcmxpbmluZyA9IGNvbmZpZy5wcmVmaXhJZ25vcmVVbmRlcmxpbmluZ05lZWRlZDtcbiAgICAgICAgICAgIHJlbmRlclNpbmdsZUxpbmVUZXh0KGdjLCBjb25maWcsIGNvbmZpZy52YWx1ZVByZWZpeCwgbGVmdFBhZGRpbmcsIHRleHRSaWdodFBhZGRpbmcpO1xuICAgICAgICAgICAgbGVmdFBhZGRpbmcgKz0gZ2MuZ2V0VGV4dFdpZHRoKGNvbmZpZy52YWx1ZVByZWZpeCkgKyBjb25maWcuY29sdW1uVGl0bGVQcmVmaXhSaWdodFNwYWNlO1xuICAgICAgICAgICAgY29uZmlnLmlnbm9yZVVuZGVybGluaW5nID0gb2xkSWdub3JlVW5kZXJsaW5pbmdTdGF0ZTtcblxuICAgICAgICAgICAgZ2MuY2FjaGUuZm9udCA9IHByZXZGb250U3RhdGU7XG4gICAgICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSBwcmV2RmlsbFN0eWxlU3RhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLmJhY2tncm91bmRUZXh0KSB7XG4gICAgICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSBjb25maWcuYmFja2dyb3VuZFRleHRDb2xvcjtcbiAgICAgICAgICAgIGdjLmNhY2hlLmZvbnQgPSBjb25maWcuYmFja2dyb3VuZFRleHRGb250O1xuXG4gICAgICAgICAgICByZW5kZXJTaW5nbGVMaW5lVGV4dChnYywgY29uZmlnLCBjb25maWcuYmFja2dyb3VuZFRleHQsIGxlZnRQYWRkaW5nLCB0ZXh0UmlnaHRQYWRkaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJWYWx1ZSkge1xuICAgICAgICAgICAgLy8gZHJhdyB0ZXh0XG4gICAgICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG4gICAgICAgICAgICBnYy5jYWNoZS5mb250ID0gdGV4dEZvbnQ7XG5cbiAgICAgICAgICAgIHZhbFdpZHRoID0gY29uZmlnLmlzSGVhZGVyUm93ICYmIGNvbmZpZy5oZWFkZXJUZXh0V3JhcHBpbmdcbiAgICAgICAgICAgICAgICA/IHJlbmRlck11bHRpTGluZVRleHQoZ2MsIGNvbmZpZywgdmFsLCBsZWZ0UGFkZGluZywgdGV4dFJpZ2h0UGFkZGluZylcbiAgICAgICAgICAgICAgICA6IHJlbmRlclNpbmdsZUxpbmVUZXh0KGdjLCBjb25maWcsIHZhbCwgbGVmdFBhZGRpbmcsIHRleHRSaWdodFBhZGRpbmcpO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLnZhbHVlUG9zdGZpeCAmJiAhY29uZmlnLmlnbm9yZVZhbHVlUG9zdGZpeCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xlZnRQYWRkaW5nID0gbGVmdFBhZGRpbmcgKyBnYy5nZXRUZXh0V2lkdGgodmFsKSArIGNvbmZpZy5jZWxsVmFsdWVQb3N0Zml4TGVmdE9mZnNldDtcbiAgICAgICAgICAgICAgICBsZXQgb2xkSWdub3JlVW5kZXJsaW5pbmdTdGF0ZSA9IGNvbmZpZy5pZ25vcmVVbmRlcmxpbmluZztcbiAgICAgICAgICAgICAgICBjb25maWcuaWdub3JlVW5kZXJsaW5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGdjLmNhY2hlLmZpbGxTdHlsZSA9IGNvbmZpZy5jZWxsVmFsdWVQb3N0Zml4Q29sb3I7XG4gICAgICAgICAgICAgICAgZ2MuY2FjaGUuZm9udCA9IGNvbmZpZy5jZWxsVmFsdWVQb3N0Zml4Rm9udDtcbiAgICAgICAgICAgICAgICB2YWxXaWR0aCArPSByZW5kZXJNdWx0aUxpbmVUZXh0KGdjLCBjb25maWcsIGNvbmZpZy52YWx1ZVBvc3RmaXgsIG5ld0xlZnRQYWRkaW5nLCB0ZXh0UmlnaHRQYWRkaW5nKTtcbiAgICAgICAgICAgICAgICBjb25maWcuaWdub3JlVW5kZXJsaW5pbmcgPSBvbGRJZ25vcmVVbmRlcmxpbmluZ1N0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNlbnRlckljb24pIHsgICAgICAgICAgICAvLyBNZWFzdXJlICYgZHJhdyBjZW50ZXIgaWNvblxuICAgICAgICAgICAgaXlvZmZzZXQgPSBNYXRoLnJvdW5kKChoZWlnaHQgLSBjZW50ZXJJY29uLmhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgIGl4b2Zmc2V0ID0gTWF0aC5yb3VuZCgod2lkdGggLSBjZW50ZXJJY29uLndpZHRoKSAvIDIpO1xuICAgICAgICAgICAgZ2MuZHJhd0ltYWdlKGNlbnRlckljb24sIHggKyB3aWR0aCAtIGl4b2Zmc2V0IC0gY2VudGVySWNvbi53aWR0aCwgeSArIGl5b2Zmc2V0KTtcbiAgICAgICAgICAgIHZhbFdpZHRoID0gaWNvblBhZGRpbmcgKyBjZW50ZXJJY29uLndpZHRoICsgaWNvblBhZGRpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVmdEljb24pIHtcbiAgICAgICAgICAgIC8vIERyYXcgbGVmdCBpY29uXG4gICAgICAgICAgICBpeW9mZnNldCA9IE1hdGgucm91bmQoKGhlaWdodCAtIGxlZnRJY29uLmhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgIGdjLmRyYXdJbWFnZShsZWZ0SWNvbiwgeCArIGljb25QYWRkaW5nLCB5ICsgaXlvZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJpZ2h0SWNvbikge1xuICAgICAgICAgICAgLy8gUmVwYWludCBiYWNrZ3JvdW5kIGJlZm9yZSBwYWludGluZyByaWdodCBpY29uLCBiZWNhdXNlIHRleHQgbWF5IGhhdmUgZmxvd2VkIHVuZGVyIHdoZXJlIGl0IHdpbGwgYmUuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgd29yay1hcm91bmQgdG8gY2xpcHBpbmcgd2hpY2ggaXMgdG9vIGV4cGVuc2l2ZSB0byBwZXJmb3JtIGhlcmUuXG4gICAgICAgICAgICB2YXIgcmlnaHRYID0geCArIHdpZHRoIC0gKHJpZ2h0SWNvbi53aWR0aCArIGljb25QYWRkaW5nKTtcbiAgICAgICAgICAgIGlmIChpbmhlcml0c0JhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgICAgICAgIGZvdW5kYXRpb25Db2xvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29sb3JzLnVuc2hpZnQoY29uZmlnLmJhY2tncm91bmRDb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXllckNvbG9ycyhnYywgY29sb3JzLCByaWdodFgsIHksIHJpZ2h0UGFkZGluZywgaGVpZ2h0LCBmb3VuZGF0aW9uQ29sb3IpO1xuXG4gICAgICAgICAgICAvLyBEcmF3IHJpZ2h0IGljb25cbiAgICAgICAgICAgIGl5b2Zmc2V0ID0gTWF0aC5yb3VuZCgoaGVpZ2h0IC0gcmlnaHRJY29uLmhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgIGdjLmRyYXdJbWFnZShyaWdodEljb24sIHJpZ2h0WCwgeSArIGl5b2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuY2VsbEJvcmRlclRoaWNrbmVzcykge1xuICAgICAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBnYy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgZ2MuY2FjaGUubGluZVdpZHRoID0gY29uZmlnLmNlbGxCb3JkZXJUaGlja25lc3M7XG4gICAgICAgICAgICBnYy5jYWNoZS5zdHJva2VTdHlsZSA9IGNvbmZpZy5jZWxsQm9yZGVyU3R5bGU7XG4gICAgICAgICAgICBnYy5zdHJva2UoKTtcbiAgICAgICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbFdpZHRoKSB7XG4gICAgICAgICAgICBjb25maWcubWluV2lkdGggPSBsZWZ0UGFkZGluZyArIHZhbFdpZHRoICsgcmlnaHRQYWRkaW5nO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogQHN1bW1hcnkgUmVuZGVycyBzaW5nbGUgbGluZSB0ZXh0LlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXG4gKiBAcGFyYW0ge1JlY3RhbmdsZX0gY29uZmlnLmJvdW5kcyAtIFRoZSBjbGlwcGluZyByZWN0IG9mIHRoZSBjZWxsIHRvIGJlIHJlbmRlcmVkLlxuICogQHBhcmFtIHsqfSB2YWwgLSBUaGUgdGV4dCB0byByZW5kZXIgaW4gdGhlIGNlbGwuXG4gKiBAbWVtYmVyT2YgU2ltcGxlQ2VsbC5wcm90b3R5cGVcbiAqL1xuZnVuY3Rpb24gcmVuZGVyTXVsdGlMaW5lVGV4dChnYywgY29uZmlnLCB2YWwsIGxlZnRQYWRkaW5nLCByaWdodFBhZGRpbmcpIHtcbiAgICB2YXIgeCA9IGNvbmZpZy5ib3VuZHMueCxcbiAgICAgICAgeSA9IGNvbmZpZy5ib3VuZHMueSxcbiAgICAgICAgd2lkdGggPSBjb25maWcuYm91bmRzLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBjb25maWcuYm91bmRzLmhlaWdodCxcbiAgICAgICAgY2xlYW5WYWwgPSAodmFsICsgJycpLnRyaW0oKS5yZXBsYWNlKFdISVRFU1BBQ0UsICcgJyksIC8vIHRyaW0gYW5kIHNxdWVlemUgd2hpdGVzcGFjZVxuICAgICAgICBsaW5lcyA9IGZpbmRMaW5lcyhnYywgY29uZmlnLCBjbGVhblZhbC5zcGxpdCgnICcpLCB3aWR0aCk7XG5cbiAgICBpZiAobGluZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJTaW5nbGVMaW5lVGV4dChnYywgY29uZmlnLCBjbGVhblZhbCwgbGVmdFBhZGRpbmcsIHJpZ2h0UGFkZGluZyk7XG4gICAgfVxuXG4gICAgdmFyIGhhbGlnbk9mZnNldCA9IGxlZnRQYWRkaW5nLFxuICAgICAgICB2YWxpZ25PZmZzZXQgPSBjb25maWcudm9mZnNldCxcbiAgICAgICAgaGFsaWduID0gY29uZmlnLmhhbGlnbixcbiAgICAgICAgdGV4dEhlaWdodCA9IGdjLmdldFRleHRIZWlnaHQoY29uZmlnLmZvbnQpLmhlaWdodDtcblxuICAgIHN3aXRjaCAoaGFsaWduKSB7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IHdpZHRoIC0gcmlnaHRQYWRkaW5nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICBoYWxpZ25PZmZzZXQgPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgaE1pbiA9IDAsIHZNaW4gPSBNYXRoLmNlaWwodGV4dEhlaWdodCAvIDIpO1xuXG4gICAgdmFsaWduT2Zmc2V0ICs9IE1hdGguY2VpbCgoaGVpZ2h0IC0gKGxpbmVzLmxlbmd0aCAtIDEpICogdGV4dEhlaWdodCkgLyAyKTtcblxuICAgIGhhbGlnbk9mZnNldCA9IE1hdGgubWF4KGhNaW4sIGhhbGlnbk9mZnNldCk7XG4gICAgdmFsaWduT2Zmc2V0ID0gTWF0aC5tYXgodk1pbiwgdmFsaWduT2Zmc2V0KTtcblxuICAgIGdjLmNhY2hlLnNhdmUoKTsgLy8gZGVmaW5lIGEgY2xpcHBpbmcgcmVnaW9uIGZvciBjZWxsXG4gICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgZ2MucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBnYy5jbGlwKCk7XG5cbiAgICBnYy5jYWNoZS50ZXh0QWxpZ24gPSBoYWxpZ247XG4gICAgZ2MuY2FjaGUudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGdjLnNpbXBsZVRleHQobGluZXNbaV0sIHggKyBoYWxpZ25PZmZzZXQsIHkgKyB2YWxpZ25PZmZzZXQgKyAoaSAqIHRleHRIZWlnaHQpKTtcbiAgICB9XG5cbiAgICBnYy5jYWNoZS5yZXN0b3JlKCk7IC8vIGRpc2NhcmQgY2xpcHBpbmcgcmVnaW9uXG5cbiAgICByZXR1cm4gd2lkdGg7XG59XG5cbi8qKlxuICogQHN1bW1hcnkgUmVuZGVycyBzaW5nbGUgbGluZSB0ZXh0LlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXG4gKiBAcGFyYW0ge1JlY3RhbmdsZX0gY29uZmlnLmJvdW5kcyAtIFRoZSBjbGlwcGluZyByZWN0IG9mIHRoZSBjZWxsIHRvIGJlIHJlbmRlcmVkLlxuICogQHBhcmFtIHsqfSB2YWwgLSBUaGUgdGV4dCB0byByZW5kZXIgaW4gdGhlIGNlbGwuXG4gKiBAbWVtYmVyT2YgU2ltcGxlQ2VsbC5wcm90b3R5cGVcbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2luZ2xlTGluZVRleHQoZ2MsIGNvbmZpZywgdmFsLCBsZWZ0UGFkZGluZywgcmlnaHRQYWRkaW5nKSB7XG4gICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgIHkgPSBjb25maWcuYm91bmRzLnksXG4gICAgICAgIHdpZHRoID0gY29uZmlnLmJvdW5kcy53aWR0aCxcbiAgICAgICAgaGFsaWduT2Zmc2V0ID0gbGVmdFBhZGRpbmcsXG4gICAgICAgIGhhbGlnbiA9IGNvbmZpZy5oYWxpZ24sXG4gICAgICAgIG1pbldpZHRoLFxuICAgICAgICBtZXRyaWNzO1xuXG4gICAgaWYgKGNvbmZpZy5jb2x1bW5BdXRvc2l6aW5nKSB7XG4gICAgICAgIG1ldHJpY3MgPSBnYy5nZXRUZXh0V2lkdGhUcnVuY2F0ZWQodmFsLCB3aWR0aCAtIGxlZnRQYWRkaW5nIC0gcmlnaHRQYWRkaW5nLCBjb25maWcudHJ1bmNhdGVUZXh0V2l0aEVsbGlwc2lzLCBjb25maWcuaGlnaGxpZ2h0ZWRDaGFycyk7XG4gICAgICAgIG1pbldpZHRoID0gbWV0cmljcy53aWR0aCArIHJpZ2h0UGFkZGluZztcbiAgICAgICAgdmFsID0gbWV0cmljcy5zdHJpbmcgfHwgdmFsO1xuICAgICAgICBzd2l0Y2ggKGhhbGlnbikge1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IHdpZHRoIC0gcmlnaHRQYWRkaW5nIC0gbWV0cmljcy53aWR0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgaGFsaWduT2Zmc2V0ID0gKHdpZHRoIC0gbWV0cmljcy53aWR0aCkgLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbWV0cmljcyA9IGdjLmdldFRleHRXaWR0aFRydW5jYXRlZCh2YWwsIHdpZHRoIC0gbGVmdFBhZGRpbmcgLSByaWdodFBhZGRpbmcsIGNvbmZpZy50cnVuY2F0ZVRleHRXaXRoRWxsaXBzaXMsIGNvbmZpZy5oaWdobGlnaHRlZENoYXJzLCB0cnVlKTtcbiAgICAgICAgbWluV2lkdGggPSAwICsgcmlnaHRQYWRkaW5nO1xuICAgICAgICBpZiAobWV0cmljcy5zdHJpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsID0gbWV0cmljcy5zdHJpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGhhbGlnbikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgaGFsaWduT2Zmc2V0ID0gd2lkdGggLSByaWdodFBhZGRpbmcgLSBtZXRyaWNzLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgICAgICBoYWxpZ25PZmZzZXQgPSAod2lkdGggLSBtZXRyaWNzLndpZHRoKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZhbCAhPT0gbnVsbCkge1xuICAgICAgICB4ICs9IE1hdGgubWF4KGxlZnRQYWRkaW5nLCBoYWxpZ25PZmZzZXQpO1xuICAgICAgICB5ICs9IGNvbmZpZy5ib3VuZHMuaGVpZ2h0IC8gMjtcblxuICAgICAgICBpZiAobWV0cmljcy5oaWdobGlnaHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGxTdHlsZU9sZCA9IGdjLmNhY2hlLmZpbGxTdHlsZTtcbiAgICAgICAgICAgIGdjLmNhY2hlLmZpbGxTdHlsZSA9IGNvbmZpZy5oaWdobGlnaHRDb2xvcjtcbiAgICAgICAgICAgIG1ldHJpY3MuaGlnaGxpZ2h0cy5mb3JFYWNoKGggPT4gZ2MuZmlsbFJlY3QoeCArIGgueCwgY29uZmlnLmJvdW5kcy55LCBoLndpZHRoLCBjb25maWcuYm91bmRzLmhlaWdodCkpO1xuICAgICAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gZmlsbFN0eWxlT2xkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5pc1VzZXJEYXRhQXJlYSkge1xuICAgICAgICAgICAgY29uc3QgaXNBZ2dyZWdhdGlvbkhpZ2hsaWdodGluZ05lZWRlZCA9ICFjb25maWcuaXNHcmFuZFRvdGFsUm93ICYmIGNvbmZpZy5pc0FnZ3JlZ2F0aW9uVHJlZUNvbHVtbiAmJiBjb25maWcuaXNBZ2dyZWdhdGlvblJvdyAmJiBjb25maWcuYWdncmVnYXRpb25DaGlsZENvdW50ID4gMDtcbiAgICAgICAgICAgIGlmIChjb25maWcubGluayB8fCBpc0FnZ3JlZ2F0aW9uSGlnaGxpZ2h0aW5nTmVlZGVkICYmICFjb25maWcuaWdub3JlVW5kZXJsaW5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmlzQ2VsbEhvdmVyZWQgfHwgIWNvbmZpZy5saW5rT25Ib3Zlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmxpbmtDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2MuY2FjaGUuc3Ryb2tlU3R5bGUgPSBjb25maWcubGlua0NvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICB1bmRlcmxpbmUoY29uZmlnLCBnYywgdmFsLCB4LCB5LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZ2Muc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmxpbmtDb2xvciAmJiAoY29uZmlnLmlzQ2VsbEhvdmVyZWQgfHwgIWNvbmZpZy5saW5rQ29sb3JPbkhvdmVyKSkge1xuICAgICAgICAgICAgICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSBjb25maWcubGlua0NvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbmZpZy5zdHJpa2VUaHJvdWdoID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgc3RyaWtlVGhyb3VnaChjb25maWcsIGdjLCB2YWwsIHgsIHksIDEpO1xuICAgICAgICAgICAgICAgIGdjLnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2MuY2FjaGUudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICBnYy5jYWNoZS50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgZ2Muc2ltcGxlVGV4dCh2YWwsIHgsIHkpO1xuICAgIH1cblxuICAgIHJldHVybiBtaW5XaWR0aDtcbn1cblxuZnVuY3Rpb24gZmluZExpbmVzKGdjLCBjb25maWcsIHdvcmRzLCB3aWR0aCkge1xuXG4gICAgaWYgKHdvcmRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gd29yZHM7XG4gICAgfVxuXG4gICAgLy8gc3RhcnRpbmcgd2l0aCBqdXN0IHRoZSBmaXJzdCB3b3JkLi4uXG4gICAgdmFyIHN0aWxsRml0cywgbGluZSA9IFt3b3Jkcy5zaGlmdCgpXTtcbiAgICB3aGlsZSAoXG4gICAgICAgIC8vIHNvIGxvbmUgYXMgbGluZSBzdGlsbCBmaXRzIHdpdGhpbiBjdXJyZW50IGNvbHVtbi4uLlxuICAgIChzdGlsbEZpdHMgPSBnYy5nZXRUZXh0V2lkdGgobGluZS5qb2luKCcgJykpIDwgd2lkdGgpXG4gICAgLy8gLi4uQU5EIHRoZXJlIGFyZSBtb3JlIHdvcmRzIGF2YWlsYWJsZS4uLlxuICAgICYmIHdvcmRzLmxlbmd0aFxuICAgICAgICApIHtcbiAgICAgICAgLy8gLi4uYWRkIGFub3RoZXIgd29yZCB0byBlbmQgb2YgbGluZSBhbmQgcmV0ZXN0XG4gICAgICAgIGxpbmUucHVzaCh3b3Jkcy5zaGlmdCgpKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAgICFzdGlsbEZpdHMgLy8gaWYgbGluZSBpcyBub3cgdG9vIGxvbmcuLi5cbiAgICAgICAgJiYgbGluZS5sZW5ndGggPiAxIC8vIC4uLkFORCBpcyBtdWx0aXBsZSB3b3Jkcy4uLlxuICAgICkge1xuICAgICAgICB3b3Jkcy51bnNoaWZ0KGxpbmUucG9wKCkpOyAvLyAuLi5iYWNrIG9mZiBieSAoaS5lLiwgcmVtb3ZlKSBvbmUgd29yZFxuICAgIH1cblxuICAgIGxpbmUgPSBbbGluZS5qb2luKCcgJyldO1xuXG4gICAgaWYgKHdvcmRzLmxlbmd0aCkgeyAvLyBpZiB0aGVyZSdzIGFueXRoaW5nIGxlZnQuLi5cbiAgICAgICAgbGluZSA9IGxpbmUuY29uY2F0KGZpbmRMaW5lcyhnYywgY29uZmlnLCB3b3Jkcywgd2lkdGgpKTsgLy8gLi4uYnJlYWsgaXQgdXAgYXMgd2VsbFxuICAgIH1cblxuICAgIHJldHVybiBsaW5lO1xufVxuXG5mdW5jdGlvbiBzdHJpa2VUaHJvdWdoKGNvbmZpZywgZ2MsIHRleHQsIHgsIHksIHRoaWNrbmVzcykge1xuICAgIHZhciB0ZXh0V2lkdGggPSBnYy5nZXRUZXh0V2lkdGgodGV4dCk7XG5cbiAgICBzd2l0Y2ggKGdjLmNhY2hlLnRleHRBbGlnbikge1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgeCAtPSB0ZXh0V2lkdGggLyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIHggLT0gdGV4dFdpZHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgeSA9IE1hdGgucm91bmQoeSArIDAuNSkgLSAwLjU7XG5cbiAgICBnYy5jYWNoZS5saW5lV2lkdGggPSB0aGlja25lc3M7XG4gICAgZ2MubW92ZVRvKHggLSAxLCB5KTtcbiAgICBnYy5saW5lVG8oeCArIHRleHRXaWR0aCArIDEsIHkpO1xufVxuXG5mdW5jdGlvbiB1bmRlcmxpbmUoY29uZmlnLCBnYywgdGV4dCwgeCwgeSwgdGhpY2tuZXNzKSB7XG4gICAgdmFyIHRleHRIZWlnaHQgPSBnYy5nZXRUZXh0SGVpZ2h0KGNvbmZpZy5mb250KS5oZWlnaHQsXG4gICAgICAgIHRleHRXaWR0aCA9IGdjLmdldFRleHRXaWR0aCh0ZXh0KTtcblxuICAgIHN3aXRjaCAoZ2MuY2FjaGUudGV4dEFsaWduKSB7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICB4IC09IHRleHRXaWR0aCAvIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgeCAtPSB0ZXh0V2lkdGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB5ID0gTWF0aC5yb3VuZCh5ICsgdGV4dEhlaWdodCAvIDIpIC0gMC41O1xuXG4gICAgLy9nYy5iZWdpblBhdGgoKTtcbiAgICBnYy5jYWNoZS5saW5lV2lkdGggPSB0aGlja25lc3M7XG4gICAgZ2MubW92ZVRvKHgsIHkpO1xuICAgIGdjLmxpbmVUbyh4ICsgdGV4dFdpZHRoLCB5KTtcbn1cblxuZnVuY3Rpb24gbGF5ZXJDb2xvcnMoZ2MsIGNvbG9ycywgeCwgeSwgd2lkdGgsIGhlaWdodCwgZm91bmRhdGlvbkNvbG9yKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGZvdW5kYXRpb25Db2xvciAmJiAhaSkge1xuICAgICAgICAgICAgZ2MuY2xlYXJGaWxsKHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvbG9yc1tpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSBjb2xvcnNbaV07XG4gICAgICAgICAgICBnYy5maWxsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGVDZWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbFJlbmRlcmVyID0gcmVxdWlyZSgnLi9DZWxsUmVuZGVyZXInKTtcblxuLyoqXG4gKiBSZW5kZXJzIGEgc2xpZGVyIGJ1dHRvbi5cbiAqIEN1cnJlbnRseSBob3dldmVyIHRoZSB1c2VyIGNhbm5vdCBpbnRlcmFjdCB3aXRoIGl0LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDZWxsUmVuZGVyZXJcbiAqL1xudmFyIFNsaWRlciA9IENlbGxSZW5kZXJlci5leHRlbmQoJ1NsaWRlcicsIHtcbiAgICBwYWludDogZnVuY3Rpb24oZ2MsIGNvbmZpZykge1xuICAgICAgICB2YXIgeCA9IGNvbmZpZy5ib3VuZHMueCxcbiAgICAgICAgICAgIHkgPSBjb25maWcuYm91bmRzLnksXG4gICAgICAgICAgICB3aWR0aCA9IGNvbmZpZy5ib3VuZHMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBjb25maWcuYm91bmRzLmhlaWdodDtcbiAgICAgICAgZ2MuY2FjaGUuc3Ryb2tlU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICB2YXIgdmFsID0gY29uZmlnLnZhbHVlO1xuICAgICAgICB2YXIgcmFkaXVzID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIG9mZnNldCA9IHdpZHRoICogdmFsO1xuICAgICAgICB2YXIgYmdDb2xvciA9IGNvbmZpZy5pc1NlbGVjdGVkID8gY29uZmlnLmJhY2tncm91bmRDb2xvciA6ICcjMzMzMzMzJztcbiAgICAgICAgdmFyIGJ0bkdyYWRpZW50ID0gZ2MuY3JlYXRlTGluZWFyR3JhZGllbnQoeCwgeSwgeCwgeSArIGhlaWdodCk7XG4gICAgICAgIGJ0bkdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBiZ0NvbG9yKTtcbiAgICAgICAgYnRuR3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsICcjNjY2NjY2Jyk7XG4gICAgICAgIHZhciBhcmNHcmFkaWVudCA9IGdjLmNyZWF0ZUxpbmVhckdyYWRpZW50KHgsIHksIHgsIHkgKyBoZWlnaHQpO1xuICAgICAgICBhcmNHcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgJyNhYWFhYWEnKTtcbiAgICAgICAgYXJjR3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsICcjNzc3Nzc3Jyk7XG4gICAgICAgIGdjLmNhY2hlLmZpbGxTdHlsZSA9IGJ0bkdyYWRpZW50O1xuICAgICAgICB0aGlzLnJvdW5kUmVjdChnYywgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzLCBidG5HcmFkaWVudCk7XG4gICAgICAgIGlmICh2YWwgPCAxLjApIHtcbiAgICAgICAgICAgIGdjLmNhY2hlLmZpbGxTdHlsZSA9IGFyY0dyYWRpZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gJyNlZWVlZWUnO1xuICAgICAgICB9XG4gICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICBnYy5hcmMoeCArIE1hdGgubWF4KG9mZnNldCAtIHJhZGl1cywgcmFkaXVzKSwgeSArIHJhZGl1cywgcmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgIGdjLmZpbGwoKTtcbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgICAgIGNvbmZpZy5taW5XaWR0aCA9IDEwMDtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTbGlkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsUmVuZGVyZXIgPSByZXF1aXJlKCcuL0NlbGxSZW5kZXJlcicpO1xuXG4vKipcbiAqIFJlbmRlcnMgYSBiYXIgY2hhcnQgc3BhcmtsaW5lLCBoZW5jZSB0aGUgbmFtZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ2VsbFJlbmRlcmVyXG4gKi9cbnZhciBTcGFya0JhciA9IENlbGxSZW5kZXJlci5leHRlbmQoJ1NwYXJrQmFyJywge1xuICAgIHBhaW50OiBmdW5jdGlvbihnYywgY29uZmlnKSB7XG4gICAgICAgIHZhciB4ID0gY29uZmlnLmJvdW5kcy54LFxuICAgICAgICAgICAgeSA9IGNvbmZpZy5ib3VuZHMueSxcbiAgICAgICAgICAgIHdpZHRoID0gY29uZmlnLmJvdW5kcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbmZpZy5ib3VuZHMuaGVpZ2h0O1xuXG4gICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICB2YXIgdmFsID0gY29uZmlnLnZhbHVlO1xuICAgICAgICBpZiAoIXZhbCB8fCAhdmFsLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3VudCA9IHZhbC5sZW5ndGg7XG4gICAgICAgIHZhciBlV2lkdGggPSB3aWR0aCAvIGNvdW50O1xuICAgICAgICB2YXIgZmdDb2xvciA9IGNvbmZpZy5pc1NlbGVjdGVkID8gY29uZmlnLmZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA6IGNvbmZpZy5jb2xvcjtcbiAgICAgICAgaWYgKGNvbmZpZy5iYWNrZ3JvdW5kQ29sb3IgfHwgY29uZmlnLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGdjLmNhY2hlLmZpbGxTdHlsZSA9IGNvbmZpZy5pc1NlbGVjdGVkID8gJ2JsdWUnIDogY29uZmlnLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIGdjLmZpbGxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGdjLmNhY2hlLmZpbGxTdHlsZSA9IGZnQ29sb3I7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYmFyaGVpZ2h0ID0gdmFsW2ldIC8gMTEwICogaGVpZ2h0O1xuICAgICAgICAgICAgZ2MuZmlsbFJlY3QoeCArIDUsIHkgKyBoZWlnaHQgLSBiYXJoZWlnaHQsIGVXaWR0aCAqIDAuNjY2NiwgYmFyaGVpZ2h0KTtcbiAgICAgICAgICAgIHggKz0gZVdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgICAgICBjb25maWcubWluV2lkdGggPSBjb3VudCAqIDEwO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwYXJrQmFyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbFJlbmRlcmVyID0gcmVxdWlyZSgnLi9DZWxsUmVuZGVyZXInKTtcblxuLyoqXG4gKiBSZW5kZXJzIGEgc3BhcmtsaW5lLlxuICogQHNlZSBbRWR3YXJkIFR1ZnRlIHNwYXJrbGluZV0oaHR0cDovL3d3dy5lZHdhcmR0dWZ0ZS5jb20vYmJvYXJkL3EtYW5kLWEtZmV0Y2gtbXNnP21zZ19pZD0wMDAxT1IpXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENlbGxSZW5kZXJlclxuICovXG52YXIgU3BhcmtMaW5lID0gQ2VsbFJlbmRlcmVyLmV4dGVuZCgnU3BhcmtMaW5lJywge1xuICAgIHBhaW50OiBmdW5jdGlvbihnYywgY29uZmlnKSB7XG4gICAgICAgIHZhciB4ID0gY29uZmlnLmJvdW5kcy54LFxuICAgICAgICAgICAgeSA9IGNvbmZpZy5ib3VuZHMueSxcbiAgICAgICAgICAgIHdpZHRoID0gY29uZmlnLmJvdW5kcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbmZpZy5ib3VuZHMuaGVpZ2h0O1xuXG4gICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICB2YXIgdmFsID0gY29uZmlnLnZhbHVlO1xuICAgICAgICBpZiAoIXZhbCB8fCAhdmFsLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3VudCA9IHZhbC5sZW5ndGg7XG4gICAgICAgIHZhciBlV2lkdGggPSB3aWR0aCAvIGNvdW50O1xuXG4gICAgICAgIHZhciBmZ0NvbG9yID0gY29uZmlnLmlzU2VsZWN0ZWQgPyBjb25maWcuZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yIDogY29uZmlnLmNvbG9yO1xuICAgICAgICBpZiAoY29uZmlnLmJhY2tncm91bmRDb2xvciB8fCBjb25maWcuaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gY29uZmlnLmlzU2VsZWN0ZWQgPyBjb25maWcuYmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yIDogY29uZmlnLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIGdjLmZpbGxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGdjLmNhY2hlLnN0cm9rZVN0eWxlID0gZmdDb2xvcjtcbiAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gZmdDb2xvcjtcbiAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIHZhciBwcmV2O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJhcmhlaWdodCA9IHZhbFtpXSAvIDExMCAqIGhlaWdodDtcbiAgICAgICAgICAgIGlmICghcHJldikge1xuICAgICAgICAgICAgICAgIHByZXYgPSBiYXJoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnYy5saW5lVG8oeCArIDUsIHkgKyBoZWlnaHQgLSBiYXJoZWlnaHQpO1xuICAgICAgICAgICAgZ2MuYXJjKHggKyA1LCB5ICsgaGVpZ2h0IC0gYmFyaGVpZ2h0LCAxLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgICAgeCArPSBlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLm1pbldpZHRoID0gY291bnQgKiAxMDtcbiAgICAgICAgZ2Muc3Ryb2tlKCk7XG4gICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwYXJrTGluZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENlbGxSZW5kZXJlciA9IHJlcXVpcmUoJy4vQ2VsbFJlbmRlcmVyJyk7XG5cbi8qKlxuICogUmVuZGVycyBhIHRyZWUgY2VsbCAocHJlc3VtYWJseSBpbiB0aGUgdHJlZSBjb2x1bW4pLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDZWxsUmVuZGVyZXJcbiAqL1xudmFyIFRyZWVDZWxsID0gQ2VsbFJlbmRlcmVyLmV4dGVuZCgnVHJlZUNlbGwnLCB7XG4gICAgcGFpbnQ6IGZ1bmN0aW9uKGdjLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gY29uZmlnLmJvdW5kcy55LFxuICAgICAgICAgICAgdmFsID0gY29uZmlnLnZhbHVlLmRhdGEsXG4gICAgICAgICAgICBpbmRlbnQgPSBjb25maWcudmFsdWUuaW5kZW50LFxuICAgICAgICAgICAgaWNvbiA9IGNvbmZpZy52YWx1ZS5pY29uO1xuXG4gICAgICAgIC8vIEZpbGwgYmFja2dyb3VuZCBvbmx5IGlmIG91ciBiZ0NvbG9yIGlzIHBvcHVsYXRlZCBvciB3ZSBhcmUgYSBzZWxlY3RlZCBjZWxsLlxuICAgICAgICBpZiAoY29uZmlnLmJhY2tncm91bmRDb2xvciB8fCBjb25maWcuaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gY29uZmlnLmlzU2VsZWN0ZWQgPyBjb25maWcuYmFja2dyb3VuZENvbG9yIDogY29uZmlnLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIGdjLmZpbGxSZWN0KHgsIHksIGNvbmZpZy5ib3VuZHMud2lkdGgsIGNvbmZpZy5ib3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdmFsIHx8ICF2YWwubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSBjb25maWcuaXNTZWxlY3RlZCA/IGNvbmZpZy5iYWNrZ3JvdW5kQ29sb3IgOiBjb25maWcuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgICAgIHZhciB2YWxpZ25PZmZzZXQgPSBNYXRoLmNlaWwoY29uZmlnLmJvdW5kcy5oZWlnaHQgLyAyKTtcbiAgICAgICAgZ2Muc2ltcGxlVGV4dChpY29uICsgdmFsLCB4ICsgaW5kZW50LCB5ICsgdmFsaWduT2Zmc2V0KTtcblxuICAgICAgICBjb25maWcubWluV2lkdGggPSB4ICsgaW5kZW50ICsgZ2MuZ2V0VGV4dFdpZHRoKGljb24gKyB2YWwpICsgMTA7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJlZUNlbGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBSZWdpc3RyeSA9IHJlcXVpcmUoJy4uL2xpYi9SZWdpc3RyeScpO1xuXG5cbnZhciB3YXJuZWRCYXNlQ2xhc3M7XG5cbi8qKlxuICogQGNsYXNzZGVzYyBSZWdpc3RyeSBvZiBjZWxsIHJlbmRlcmVyIHNpbmdsZXRvbnMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENlbGxSZW5kZXJlcnMgPSBSZWdpc3RyeS5leHRlbmQoJ0NlbGxSZW5kZXJlcnMnLCB7XG5cbiAgICBCYXNlQ2xhc3M6IHJlcXVpcmUoJy4vQ2VsbFJlbmRlcmVyJyksIC8vIGFic3RyYWN0IGJhc2UgY2xhc3NcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBwcmVyZWdpc3RlciB0aGUgc3RhbmRhcmQgY2VsbCByZW5kZXJlcnNcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9CdXR0b24nKSk7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vU2ltcGxlQ2VsbCcpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9TbGlkZXJDZWxsJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL1NwYXJrQmFyJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL0xhc3RTZWxlY3Rpb24nKSk7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vU3BhcmtMaW5lJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL0Vycm9yQ2VsbCcpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9UcmVlQ2VsbCcpKTtcbiAgICB9LFxuXG4gICAgLy8gZm9yIGJldHRlciBwZXJmb3JtYW5jZSwgaW5zdGFudGlhdGUgYXQgYWRkIHRpbWUgcmF0aGVyIHRoYW4gcmVuZGVyIHRpbWUuXG4gICAgYWRkOiBmdW5jdGlvbihuYW1lLCBDb25zdHJ1Y3Rvcikge1xuICAgICAgICBDb25zdHJ1Y3RvciA9IFJlZ2lzdHJ5LnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCBuYW1lLCBDb25zdHJ1Y3Rvcik7XG5cbiAgICAgICAgaWYgKENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzW0NvbnN0cnVjdG9yLmdldENsYXNzTmFtZSgpXSA9IG5ldyBDb25zdHJ1Y3RvcjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgJiYgbmFtZS50b0xvd2VyQ2FzZSgpID09PSAnZW1wdHljZWxsJykge1xuICAgICAgICAgICAgaWYgKCF3YXJuZWRCYXNlQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2dyaWQuY2VsbFJlbmRlcmVycy5nZXQoXCInICsgbmFtZSArICdcIikuY29uc3RydWN0b3IgaGFzIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2Mi4xLjAgaW4gZmF2b3Igb2YgZ3JpZC5jZWxsUmVuZGVyZXJzLkJhc2VDbGFzcyBwcm9wZXJ0eS4gKFdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiknKTtcbiAgICAgICAgICAgICAgICB3YXJuZWRCYXNlQ2xhc3MgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5CYXNlQ2xhc3MuY29uc3RydWN0b3IgPSB0aGlzLkJhc2VDbGFzcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkJhc2VDbGFzcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVnaXN0cnkucHJvdG90eXBlLmdldC5jYWxsKHRoaXMsIG5hbWUpO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IENlbGxSZW5kZXJlcnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhU291cmNlQmFzZSA9IHJlcXVpcmUoJy4uL0RhdGFzYXVyQmFzZScpO1xuXG4vKipcbiAqIEBpbXBsZW1lbnRzIGRhdGFNb2RlbEFQSVxuICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5uYW1lXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBIZWFkZXJTdWJncmlkID0gRGF0YVNvdXJjZUJhc2UuZXh0ZW5kKCdIZWFkZXJTdWJncmlkJywge1xuICAgIHR5cGU6ICdoZWFkZXInLFxuXG4gICAgZm9ybWF0OiAnaGVhZGVyJywgLy8gb3ZlcnJpZGUgY29sdW1uIGZvcm1hdFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24obmV4dERhdGFTb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5ncmlkID0gb3B0aW9ucy5ncmlkO1xuICAgIH0sXG5cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQucHJvcGVydGllcy5zaG93SGVhZGVyUm93ID8gMSA6IDA7XG4gICAgfSxcblxuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmdyaWQuYmVoYXZpb3IuZ2V0Q29sdW1uKHgpO1xuICAgICAgICByZXR1cm4gY29sdW1uLmhlYWRlciB8fCBjb2x1bW4ubmFtZTsgLy8gdXNlIGZpZWxkIG5hbWUgd2hlbiBoZWFkZXIgdW5kZWZpbmVkXG4gICAgfSxcblxuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoeSA8IHRoaXMuZ2V0Um93Q291bnQoKSkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmJlaGF2aW9yLmdldENvbHVtbih4KS5oZWFkZXIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVJvdztcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBIZWFkZXJTdWJncmlkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVnaXN0cnkgPSByZXF1aXJlKCcuLi9saWIvUmVnaXN0cnknKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjIFJlZ2lzdHJ5IG9mIGNlbGwgZWRpdG9yIGNvbnN0cnVjdG9ycy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIERhdGFNb2RlbHMgPSBSZWdpc3RyeS5leHRlbmQoJ0RhdGFNb2RlbHMnLCB7XG5cbiAgICBCYXNlQ2xhc3M6IHJlcXVpcmUoJy4uL0RhdGFzYXVyQmFzZScpLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHByZXJlZ2lzdGVyIHRoZSBzdGFuZGFyZCBjZWxsIGVkaXRvcnNcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9IZWFkZXJTdWJncmlkJykpO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IERhdGFNb2RlbHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBIeXBlcmdyaWRFcnJvciA9IHJlcXVpcmUoJy4vbGliL2Vycm9yJyk7XG5cblxudmFyIHByb3BDbGFzc0VudW0gPSB7XG4gICAgQ09MVU1OUzogMSxcbiAgICBTVFJJUEVTOiAyLFxuICAgIFJPV1M6IDMsXG4gICAgQ0VMTFM6IDRcbn07XG5cbnZhciBwcm9wQ2xhc3NMYXllcnNNYXAgPSB7XG4gICAgREVGQVVMVDogW3Byb3BDbGFzc0VudW0uQ09MVU1OUywgcHJvcENsYXNzRW51bS5TVFJJUEVTLCBwcm9wQ2xhc3NFbnVtLlJPV1MsIHByb3BDbGFzc0VudW0uQ0VMTFNdLFxuICAgIE5PX1JPV1M6IFtwcm9wQ2xhc3NFbnVtLkNFTExTXVxufTtcblxuXG4vKipcbiAqIFRoaXMgbW9kdWxlIGxpc3RzIHRoZSBwcm9wZXJ0aWVzIHRoYXQgY2FuIGJlIHNldCBvbiBhIHtAbGluayBIeXBlcmdyaWR9IGFsb25nIHdpdGggdGhlaXIgZGVmYXVsdCB2YWx1ZXMuXG4gKiBFZGl0IHRoaXMgZmlsZSB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG4gKiBAbW9kdWxlIGRlZmF1bHRzXG4gKi9cblxudmFyIGRlZmF1bHRzID0ge1xuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgVGhlIGdsb2JhbCB0aGVtZSBuYW1lLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgdGhlbWVOYW1lOiAnZGVmYXVsdCcsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBtZXNzYWdlIHRvIGRpc3BsYXkgaW4gZnJvbnQgb2YgdGhlIGNhbnZhcyB3aGVuIHRoZXJlIGFyZSBubyBncmlkIHJvd3MuXG4gICAgICogRm9ybWF0IGlzIEhUTUwuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBub0RhdGFNZXNzYWdlOiAnJyxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIElmIHRydWUsIGZpcnN0IHJvdyB3aWxsIGJlIHVzZWQgdG8gcmVuZGVyIGhlYWRlcnNcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICB1c2VIZWFkZXJzOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgSWYgdHJ1ZSwgY2VsbHMsIHRoYXQgY29udGFpbnMgb25seSB1cmwgd2lsbCBiZSBkaXNwbGF5ZWQgYXMgYSBsaW5rXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgZGV0ZWN0TGlua3NQZXJtYW5lbnRseTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIENvbnRhaW5zIGNvdW50IG9mIHJvd3MsIHRoYXQgY3VycmVudGx5IHVzZWQgYXMgYSBoZWFkZXJzXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBmaWN0aXZlSGVhZGVyUm93c0NvdW50OiAwLFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgTGlzdCBvZiBzdWJncmlkcyBieVxuICAgICAqIEBkZXNjIFJlc3RyaWN0IHVzYWdlIGhlcmUgdG8gc3RyaW5ncyAobmFtaW5nIGRhdGEgbW9kZWxzKSBvciBhcnJheXMgY29uc2lzdGluZyBvZiBzdWNoIGEgc3RyaW5nICsgY29uc3RydWN0b3IgYXJndW1lbnRzLiBUaGF0IGlzLCBhdm9pZCB7QGxpbmsgc3ViZ3JpZFNwZWN9J3MgZnVuY3Rpb24gYW5kIG9iamVjdCBvdmVybG9hZHMgYW5kIHtAbGluayBzdWJncmlkQ29uc3RydWN0b3JSZWZ9IGZ1bmN0aW9uIG92ZXJsb2FkLlxuICAgICAqIEBkZWZhdWx0IFwiWyAnSGVhZGVyU3ViZ3JpZCcsICdkYXRhJyBdXCJcbiAgICAgKiBAdHlwZSB7c3ViZ3JpZFNwZWNbXX1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgc3ViZ3JpZHM6IFtcbiAgICAgICAgJ0hlYWRlclN1YmdyaWQnLFxuICAgICAgICAnZGF0YSdcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZvbnQgZm9yIGRhdGEgY2VsbHMuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzRm9udH1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgZm9udDogJzEzcHggXCJIZWx2ZXRpY2EgTmV1ZVwiLEhlbHZldGljYSxBcmlhbCxzYW5zLXNlcmlmJyxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgY29sb3IgZm9yIGRhdGEgY2VsbHMuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb2xvcjogJyMwNjA2MDYnLFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBmb3IgZGF0YSBjZWxscy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGJhY2tncm91bmRDb2xvcjogJyNGRkZGRkYnLFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBmb3IgZW1wdHkgc3BhY2VcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNhbnZhc0JhY2tncm91bmRDb2xvcjogJyNGM0YzRjMnLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBzdHlsZSBmb3Igc2VsZWN0ZWQgY2VsbChzKS5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGZvcmVncm91bmRTZWxlY3Rpb25Gb250OiAnMTNweCBcIkhlbHZldGljYSBOZXVlXCIsSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWYnLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBjb2xvciBmb3Igc2VsZWN0ZWQgY2VsbChzKS5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjogJyMwNjA2MDYnLFxuICAgIC8qKlxuICAgICAqIEJhY2tncm91bmQgY29sb3IgZm9yIHNlbGVjdGVkIGNlbGwocykuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICcjRUNGM0ZGJyxcblxuICAgIC8qKlxuICAgICAqIEJhY2tncm91bmQgY29sb3IgZm9yIGhlYWRlciBzZWxlY3RlZCBjZWxsKHMpLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgYmFja2dyb3VuZEhlYWRlclNlbGVjdGlvbkNvbG9yOiAnI0RERERERCcsXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBUZXh0IGNvbG9yIGZvciBlcnJvciBjZWxsXG4gICAgICogQGRlc2NyaXB0aW9uIENvbG9yIGZvciBzeW1ib2wgb2YgZXJyb3IsIHdoZW4gdmFsdWUgZGVzY3JpYmVkIGFzIG9iamVjdCB3aXRoIHR5cGU6XCJFUlJPUlwiIGZpZWxkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgZXJyb3JDZWxsRGF0YUNvbG9yOiAnI2E5NGQ0ZGMyJyxcblxuICAgIGRpc2FibGVIb3ZlckhpZ2hsaWdodGluZzogdHJ1ZSxcblxuXG4gICAgLyoqKioqKioqKiogU0VDVElPTjogQ09MVU1OIEhFQURFUiBDT0xPUlMgKioqKioqKioqKi9cblxuICAgIC8vIElNUE9SVEFOVCBDQVZFQVQ6IFRoZSBjb2RlIGlzIGluY29uc2lzdGVudCByZWdhcmRpbmcgdGhlIHRlcm1pbm9sb2d5LiBJcyB0aGUgXCJjb2x1bW4gaGVhZGVyXCIgc2VjdGlvbiBfdGhlIHJvd18gb2YgY2VsbHMgYXQgdGhlIHRvcCAodGhhdCBhY3QgYXMgaGVhZGVycyBmb3IgZWFjaCBjb2x1bW4pIG9yIGlzIGl0IF90aGUgY29sdW1uXyBvZiBjZWxscyAodGhhdCBhY3QgYXMgaGVhZGVycyBmb3IgZWFjaCByb3cpPyBPaCBteS5cblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0ZvbnR9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbHVtbkhlYWRlckZvbnQ6ICcxMXB4IGFyaWFsLHNhbnMtc2VyaWYnLFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgdGV4dCBzdHlsZSBmb3IgZGF0YSByb3cgd2l0aCBoZWFkZXJzL3RpdGxlc1xuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0ZvbnR9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbHVtbkhlYWRlckZvbnRCb2xkOiAnYm9sZCAxM3B4IFwiSGVsdmV0aWNhIE5ldWVcIixIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY29sdW1uSGVhZGVyQ29sb3I6ICcjMDYwNjA2JyxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEZvbnQgc3R5bGUgZm9yIHNlbGVjdGVkIGNvbHVtbnMnIGhlYWRlcnMuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDogJzExcHggYXJpYWwsc2Fucy1zZXJpZicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY29sdW1uSGVhZGVyQmFja2dyb3VuZENvbG9yOiAncmdiKDI0MywyNDMsMjQzKScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY29sdW1uSGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiAnIzA2MDYwNicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY29sdW1uSGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiYSgyNTUsIDIyMCwgOTcsIDAuNDUpJyxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IGFsaWduIG9mIGZpcnN0IG51bWJlciBjb2x1bW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbHVtbkhlYWRlckhhbGlnbjogJ2NlbnRlcicsXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBpbml0aWFsIHdpZHRoIG9mIG51bWJlciBjb2x1bW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbHVtbkhlYWRlckluaXRXaWR0aDogNTAsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbHVtbkhlYWRlclJlbmRlcmVyOiAnU2ltcGxlQ2VsbCcsXG5cblxuICAgIC8qKioqKioqKioqIFNFQ1RJT046IFJPVyBIRUFERVIgQ09MT1JTICoqKioqKioqKiovXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NGb250fVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICByb3dIZWFkZXJGb250OiAnMTFweCBhcmlhbCxzYW5zLXNlcmlmJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICByb3dIZWFkZXJDb2xvcjogJyMwNjA2MDYnLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHJvd0hlYWRlckJhY2tncm91bmRDb2xvcjogJ3JnYigyNDMsMjQzLDI0MyknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHJvd0hlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjogJyMwNjA2MDYnLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBzdHlsZSBmb3Igc2VsZWN0ZWQgcm93cycgaGVhZGVycy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHJvd0hlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Gb250OiAnMTFweCBhcmlhbCxzYW5zLXNlcmlmJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICByb3dIZWFkZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2JhKDI1NSwgMjIwLCA5NywgMC40NSknLFxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kQ29sb3IyOiAncmdiKDIwMSwgMjAxLCAyMDEpJyxcblxuXG4gICAgLyoqKioqKioqKiogU0VDVElPTjogVFJFRSBIRUFERVIgQ09MT1JTICoqKioqKioqKiovXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NGb250fVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICB0cmVlSGVhZGVyRm9udDogJzEycHggVGFob21hLCBHZW5ldmEsIHNhbnMtc2VyaWYnLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHRyZWVIZWFkZXJDb2xvcjogJ3JnYigyNSwgMjUsIDI1KScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgdHJlZUhlYWRlckJhY2tncm91bmRDb2xvcjogJ3JnYigyMjMsIDIyNywgMjMyKScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgdHJlZUhlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjogJ3JnYig4MCwgODAsIDgwKScsXG5cbiAgICAvKipcbiAgICAgKiBGb250IHN0eWxlIGZvciBzZWxlY3RlZCByb3dzJyBoZWFkZXJzLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgdHJlZUhlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Gb250OiAnYm9sZCAxMnB4IFRhaG9tYSwgR2VuZXZhLCBzYW5zLXNlcmlmJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICB0cmVlSGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiYSgyNTUsIDIyMCwgOTcsIDAuNDUpJyxcbiAgICAvKioqKioqKioqKiBTRUNUSU9OOiBGSUxURVIgUk9XIENPTE9SUyAqKioqKioqKioqL1xuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzRm9udH1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgZmlsdGVyRm9udDogJzEycHggVGFob21hLCBHZW5ldmEsIHNhbnMtc2VyaWYnLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGZpbHRlckNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBmaWx0ZXJCYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgZmlsdGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBmaWx0ZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjU1LCAyMjAsIDk3KScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGZpbHRlckhhbGlnbjogJ2NlbnRlcicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGZpbHRlclJlbmRlcmVyOiAnU2ltcGxlQ2VsbCcsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGZpbHRlckVkaXRvcjogJ1RleHRGaWVsZCcsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBmaWx0ZXJhYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgc2hvd0ZpbHRlclJvdzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHZvZmZzZXQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHNjcm9sbGJhckhvdmVyT3ZlcjogJ3Zpc2libGUnLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBzY3JvbGxiYXJIb3Zlck9mZjogJ2hpZGRlbicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBzY3JvbGxpbmdFbmFibGVkOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICB2U2Nyb2xsYmFyQ2xhc3NQcmVmaXg6ICcnLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBoU2Nyb2xsYmFyQ2xhc3NQcmVmaXg6ICcnLFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgbGltaXQgZm9yIGluaXRpYXRpbmcgc2Nyb2xsIGVuZCBldmVudFxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgb25TY3JvbGxFbmRMaW1pdFRyaWdnZXI6IC0xLFxuXG4gICAgLyoqXG4gICAgICogSG9yaXpvbnRhbCBhbGlnbm1lbnQgb2YgZWFjaCBjZWxsIGFzIGludGVycHJldGVkIGJ5IGl0J3MgY2VsbCByZW5kZXJlci5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGhhbGlnbjogJ2xlZnQnLFxuXG4gICAgLyoqXG4gICAgICogUGFkZGluZyB0byBsZWZ0IGFuZCByaWdodCBvZiBjZWxsIHZhbHVlLlxuICAgICAqXG4gICAgICogTk9URTogUmlnaHQgcGFkZGluZyBtYXkgbm90IGJlIHZpc2libGUgaWYgY29sdW1uIGlzIG5vdCBzaXplZCB3aWRlIGVub3VnaC5cbiAgICAgKlxuICAgICAqIFNlZSBhbHNvIHtAbGluayBtb2R1bGU6ZGVmYXVsdHMuaWNvblBhZGRpbmd8aWNvblBhZGRpbmd9LlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY2VsbFBhZGRpbmc6IDQsXG5cbiAgICBjZWxsUGFkZGluZ1JpZ2h0OiA1LFxuXG4gICAgY2VsbFBhZGRpbmdMZWZ0OiA2LFxuXG4gICAgLyoqXG4gICAgICogUGFkZGluZyB0byBsZWZ0IGFuZCByaWdodCBvZiBjZWxsIGljb25zLlxuICAgICAqXG4gICAgICogT3ZlcnJpZGVzIHtAbGluayBtb2R1bGU6ZGVmYXVsdHMuY2VsbFBhZGRpbmd8Y2VsbFBhZGRpbmd9OlxuICAgICAqICogTGVmdCBpY29uICsgYGljb25QYWRkaW5nYCBvdmVycmlkZXMgbGVmdCB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLmNlbGxQZGRpbmdnfGNlbGxQZGRpbmdnfS5cbiAgICAgKiAqIFJpZ2h0IGljb24gKyBgaWNvblBhZGRpbmdgIG92ZXJyaWRlcyByaWdodCB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLmNlbGxQZGRpbmdnfGNlbGxQZGRpbmdnfS5cbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6ZGVmYXVsdHMubGVmdEljb258bGVmdEljb259XG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLmNlbnRlckljb258Y2VudGVySWNvbn1cbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6ZGVmYXVsdHMucmlnaHRJY29ufHJpZ2h0SWNvbn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGljb25QYWRkaW5nOiAzLFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgTmFtZSBvZiBpbWFnZSB0byBhcHBlYXIgYXQgcmlnaHQgb2YgY2VsbC5cbiAgICAgKiBNdXN0IGJlIGEga2V5IGZyb20ge0BsaW5rIG1vZHVsZTppbWFnZXN8aW1hZ2VzfS5cbiAgICAgKiBAZGVzYyBVc2VkIGJ5IHtAbGluayBTaW1wbGVDZWxsfSBjZWxsIHJlbmRlcmVyLlxuICAgICAqIEBzZWUge0BsaW5rIG1vZHVsZTpkZWZhdWx0cy5jZW50ZXJJY29ufGNlbnRlckljb259XG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLnJpZ2h0SWNvbnxyaWdodEljb259XG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLmljb25QYWRkaW5nfGljb25QYWRkaW5nfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgbGVmdEljb246IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IE5hbWUgb2YgaW1hZ2UgdG8gYXBwZWFyIGF0IHJpZ2h0IG9mIGNlbGwuXG4gICAgICogTXVzdCBiZSBhIGtleSBmcm9tIHtAbGluayBtb2R1bGU6aW1hZ2VzfGltYWdlc30uXG4gICAgICogQGRlc2MgVXNlZCBieSB7QGxpbmsgU2ltcGxlQ2VsbH0gY2VsbCByZW5kZXJlci5cbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6ZGVmYXVsdHMubGVmdEljb258bGVmdEljb259XG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLnJpZ2h0SWNvbnxyaWdodEljb259XG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLmljb25QYWRkaW5nfGljb25QYWRkaW5nfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY2VudGVySWNvbjogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgTmFtZSBvZiBpbWFnZSB0byBhcHBlYXIgYXQgcmlnaHQgb2YgY2VsbC5cbiAgICAgKiBNdXN0IGJlIGEga2V5IGZyb20ge0BsaW5rIG1vZHVsZTppbWFnZXN8aW1hZ2VzfS5cbiAgICAgKiBAZGVzYyBVc2VkIGJ5IHtAbGluayBTaW1wbGVDZWxsfSBjZWxsIHJlbmRlcmVyLlxuICAgICAqIEBzZWUge0BsaW5rIG1vZHVsZTpkZWZhdWx0cy5sZWZ0SWNvbnxsZWZ0SWNvbn1cbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6ZGVmYXVsdHMuY2VudGVySWNvbnxjZW50ZXJJY29ufVxuICAgICAqIEBzZWUge0BsaW5rIG1vZHVsZTpkZWZhdWx0cy5pY29uUGFkZGluZ3xpY29uUGFkZGluZ31cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHJpZ2h0SWNvbjogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgc2hvd0NlbGxDb250ZXh0TWVudUljb24gYW5kIHNob3dDb2x1bW5UeXBlIHRyaWdnZXJcbiAgICAgKi9cbiAgICBzaG93QWRkaXRpb25hbEluZm86IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIGB0cnVlYCB0byByZW5kZXIgYDBgIGFuZCBgZmFsc2VgLiBPdGhlcndpc2UgdGhlc2UgdmFsdWUgYXBwZWFyIGFzIGJsYW5rIGNlbGxzLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHJlbmRlckZhbHN5OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgYSByZWdpc3RlcmVkIGhlYWRlcmlmeSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIElmIHRoZSBuYW1lZCBoZWFkZXJpZnkgZnVuY3Rpb24gaXMgZGVmaW5lZCwgaXQgaXMgYXBwbGllZCB0byB0aGUgc2NoZW1hOlxuICAgICAqIDEuIFdoZW5ldmVyIHRoZSBzY2hlbWEgY2hhbmdlc1xuICAgICAqIDIuIEZvciBlYWNoIGNvbHVtbiB0aGF0IGRvZXMgbm90IGFscmVhZHkgaGF2ZSBhbiBleHBsaWNpdGx5IGRlZmluZWQgaGVhZGVyXG4gICAgICpcbiAgICAgKiBXaGVuIHRoaXMgcHJvcGVydHkgZG9lcyBub3QgbmFtZSBhIGRlZmluZWQgaGVhZGVyaWZ5IGZ1bmN0aW9uLCB1bmRlZmluZWQgY29sdW1uIGhlYWRlcnMgZGVmYXVsdCB0byB0aGVpciBjb2x1bW4gbmFtZXMuICAgICAqXG4gICAgICpcbiAgICAgKiBAc2VlIGxpYi9oZWFkZXJpZmllcnMuanNcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGhlYWRlcmlmeTogJ3RpdGxlaXplJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGdyaWRMaW5lc0g6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBncmlkTGluZXNWOiB0cnVlLFxuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmR5bmFtaWNQcm9wZXJ0eURlc2NyaXB0b3JzLmxpbmVXaWR0aH1cbiAgICAgKi9cbiAgICBncmlkTGluZXNXaWR0aDogMSxcblxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGdyaWRMaW5lc0NvbG9yOiAnI2RhZGFkYScsXG5cbiAgICAvKiogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAZGVzYyBDb2xvciBvZiBib3JkZXJzLCB0aGF0IHBhaW50ZWQgb24gbGVmdCBzaWRlIG9mIGhlYWRlciBwYXJ0IG9mIGVhY2ggY29sdW1uXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgZ3JpZExpbmVzSGVhZGVyQ29sb3I6ICcjYzFjMWMxJyxcblxuICAgIC8qKlxuICAgICAqIFNldCBjYW52YXMncyBDU1MgYm9yZGVyIHRvIHRoaXMgc3RyaW5nIGFzIHdlbGwgYXMgYGdyaWRCb3JkZXJMZWZ0YCwgYGdyaWRCb3JkZXJSaWdodGAsIGBncmlkQm9yZGVyVG9wYCwgYW5kIGBncmlkQm9yZGVyQm90dG9tYC5cbiAgICAgKiBJZiBzZXQgdG8gYHRydWVgLCB1c2VzIGN1cnJlbnQgYGxpbmVXaWR0aGAgYW5kIGBsaW5lQ29sb3JgLlxuICAgICAqIElmIHNldCB0byBgZmFsc2VgLCB1c2VzIG51bGwuXG4gICAgICpcbiAgICAgKiBDYXZlYXQ6IFRoZSB1c2Ugb2YgYGdyaWQuY2FudmFzLmNhbnZhcy5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCdgIGlzIF9ub3RfIHJlY29tbWVuZGVkIGR1ZSB0b1xuICAgICAqIHRoZSBmYWN0IHRoYXQgdGhlIGNhbnZhcyBpcyBzcXVhc2hlZCBzbGlnaHRseSB0byBhY2NvbW1vZGF0ZSB0aGUgYm9yZGVyIHJlc3VsdGluZyBpbiBibHVycmVkIHRleHQuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufHN0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgZ3JpZEJvcmRlcjogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFNldCBjYW52YXMncyBsZWZ0IENTUyBib3JkZXIgdG8gdGhpcyBzdHJpbmcuXG4gICAgICogSWYgc2V0IHRvIGB0cnVlYCwgdXNlcyBjdXJyZW50IGBsaW5lV2lkdGhgIGFuZCBgbGluZUNvbG9yYC5cbiAgICAgKiBJZiBzZXQgdG8gYGZhbHNlYCwgdXNlcyBudWxsLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW58c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBncmlkQm9yZGVyTGVmdDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFNldCBjYW52YXMncyByaWdodCBDU1MgYm9yZGVyIHRvIHRoaXMgc3RyaW5nLlxuICAgICAqIElmIHNldCB0byBgdHJ1ZWAsIHVzZXMgY3VycmVudCBgbGluZVdpZHRoYCBhbmQgYGxpbmVDb2xvcmAuXG4gICAgICogSWYgc2V0IHRvIGBmYWxzZWAsIHVzZXMgbnVsbC5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBncmlkQm9yZGVyUmlnaHQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgY2FudmFzJ3MgdG9wIENTUyBib3JkZXIgdG8gdGhpcyBzdHJpbmcuXG4gICAgICogSWYgc2V0IHRvIGB0cnVlYCwgdXNlcyBjdXJyZW50IGBsaW5lV2lkdGhgIGFuZCBgbGluZUNvbG9yYC5cbiAgICAgKiBJZiBzZXQgdG8gYGZhbHNlYCwgdXNlcyBudWxsLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGdyaWRCb3JkZXJUb3A6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogU2V0IGNhbnZhcydzIGJvdHRvbSBDU1MgYm9yZGVyIHRvIHRoaXMgc3RyaW5nLlxuICAgICAqIElmIHNldCB0byBgdHJ1ZWAsIHVzZXMgY3VycmVudCBgbGluZVdpZHRoYCBhbmQgYGxpbmVDb2xvcmAuXG4gICAgICogSWYgc2V0IHRvIGBmYWxzZWAsIHVzZXMgbnVsbC5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBncmlkQm9yZGVyQm90dG9tOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lIHRoaXMgcHJvcGVydHkgdG8gc3R5bGUgcnVsZSBsaW5lcyBiZXR3ZWVuIGZpeGVkICYgc2NvbGxpbmcgcm93cyBkaWZmZXJlbnRseSBmcm9tIGBsaW5lV2lkdGhgLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgZml4ZWRMaW5lc0hXaWR0aDogNixcblxuICAgIC8qKlxuICAgICAqIERlZmluZSB0aGlzIHByb3BlcnR5IHRvIHJlbmRlciBqdXN0IHRoZSBlZGdlcyBvZiB0aGUgbGluZXMgYmV0d2VlbiBmaXhlZCAmIHNjb2xsaW5nIHJvd3MsIGNyZWF0aW5nIGEgZG91YmxlLWxpbmUgZWZmZWN0LiBUaGUgdmFsdWUgaXMgdGhlIHRoaWNrbmVzcyBvZiB0aGUgZWRnZXMuIFR5cGljYWwgZGVmaW5pdGlvbiB3b3VsZCBiZSBgMWAgaW4gdGFuZGVtIHdpdGggc2V0dGluZyBgZml4ZWRMaW5lc1dpZHRoYCB0byBgM2AuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBmaXhlZExpbmVzSEVkZ2U6IHVuZGVmaW5lZCwgLy8gdW5kZWZpbmVkIG1lYW5zIG5vIGVkZ2UgZWZmZWN0XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgdGhpcyBwcm9wZXJ0eSB0byBzdHlsZSBydWxlIGxpbmVzIGJldHdlZW4gZml4ZWQgJiBzY29sbGluZyByb3dzIGRpZmZlcmVudGx5IGZyb20gYGxpbmVDb2xvcmAuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGZpeGVkTGluZXNIQ29sb3I6ICdyZ2IoMjE4LDIyMywyMzIpJywgLy8gfjIxJSBkYXJrZXIgdGhhbiBgbGluZUNvbG9yYCBkZWZhdWx0XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgdGhpcyBwcm9wZXJ0eSB0byBzdHlsZSBydWxlIGxpbmVzIGJldHdlZW4gZml4ZWQgJiBzY29sbGluZyBjb2x1bW5zIGRpZmZlcmVudGx5IGZyb20gYGxpbmVXaWR0aGAuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBmaXhlZExpbmVzVldpZHRoOiA2LFxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lIHRoaXMgcHJvcGVydHkgdG8gcmVuZGVyIGp1c3QgdGhlIGVkZ2VzIG9mIHRoZSBsaW5lcyBiZXR3ZWVuIGZpeGVkICYgc2NvbGxpbmcgY29sdW1ucywgY3JlYXRpbmcgYSBkb3VibGUtbGluZSBlZmZlY3QuIFRoZSB2YWx1ZSBpcyB0aGUgdGhpY2tuZXNzIG9mIHRoZSBlZGdlcy4gVHlwaWNhbCBkZWZpbml0aW9uIHdvdWxkIGJlIGAxYCBpbiB0YW5kZW0gd2l0aCBzZXR0aW5nIGBmaXhlZExpbmVzV2lkdGhgIHRvIGAzYC5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGZpeGVkTGluZXNWRWRnZTogdW5kZWZpbmVkLCAvLyB1bmRlZmluZWQgbWVhbnMgbm8gZWRnZSBlZmZlY3RcblxuICAgIC8qKlxuICAgICAqIERlZmluZSB0aGlzIHByb3BlcnR5IHRvIHN0eWxlIHJ1bGUgbGluZXMgYmV0d2VlbiBmaXhlZCAmIHNjb2xsaW5nIGNvbHVtbnMgZGlmZmVyZW50bHkgZnJvbSBgbGluZUNvbG9yYC5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgZml4ZWRMaW5lc1ZDb2xvcjogJ3JnYigyMTgsMjIzLDIzMiknLCAvLyB+MjElIGRhcmtlciB0aGFuIGBsaW5lQ29sb3JgIGRlZmF1bHRcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgZGVmYXVsdFJvd0hlaWdodDogMjEsXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBoZWlnaHQgcGFyYW1ldGVyIGZvciBoZWFkZXIgcm93XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBkZWZhdWx0SGVhZGVyUm93SGVpZ2h0OiAyMyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgZGVmYXVsdENvbHVtbldpZHRoOiAxMDEsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIG1pbmltdW1Db2x1bW5XaWR0aDogMzAsXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBnbG9iYWwgbWF4IHdpZHRoIG9mIGNvbHVtblxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgbWF4aW11bUNvbHVtbldpZHRoOiA2NTAsXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBtaW5pbWFsIGNvdW50IG9mIHJvd3Mgc2hvdWxkIGJlIHNob3duXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBtaW5pbXVtUm93Q291bnQ6IDUwLFxuXG4gICAgLy9mb3IgaW1tZWRpYXRlIHBhaW50aW5nLCBzZXQgdGhlc2UgdmFsdWVzIHRvIDAsIHRydWUgcmVzcGVjdGl2ZWx5XG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCBGUFMgZm93IGRyYXdpbmcgdGFibGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICByZXBhaW50SW50ZXJ2YWxSYXRlOiA2MCxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHJlcGFpbnRJbW1lZGlhdGVseTogZmFsc2UsXG5cbiAgICAvL2VuYWJsZSBvciBkaXNhYmxlIGRvdWJsZSBidWZmZXJpbmdcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHVzZUJpdEJsaXQ6IGZhbHNlLFxuXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICB1c2VIaURQSTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IE1hcHBpbmdzIGZvciBjZWxsIG5hdmlnYXRpb24ga2V5cy5cbiAgICAgKiBAZGVzYyBDZWxsIG5hdmlnYXRpb24gaXMgaGFuZGxlZCBpbiB0aGUge0BsaW5rIENlbGxTZWxlY3Rpb259IFwiZmVhdHVyZVwiLiBUaGlzIHByb3BlcnR5IGdpdmVzIHlvdSBjb250cm9sIG92ZXIgd2hpY2gga2V5cHJlc3NlcyB0aGUgYnVpbHQtaW4gbWVjaGFuaXNtIHdpbGwgcmVzcG9uZCB0by5cbiAgICAgKlxuICAgICAqIChJZiB0aGlzIGJ1aWx0LWluIGNlbGwgc2VsZWN0aW9uIGxvZ2ljIGlzIGluc3VmZmljaWVudCBmb3IgeW91ciBuZWVkcywgeW91IGNhbiBhbHNvIGxpc3RlbiBmb3IgdGhlIHZhcmlvdXMgXCJmaW4ta2V5XCIgZXZlbnRzIGFuZCBjYXJyeSBvdXQgbW9yZSBjb21wbGV4IG9wZXJhdGlvbnMgaW4geW91ciBsaXN0ZW5lcnMuKVxuICAgICAqXG4gICAgICogVGhlIGtleXByZXNzIG5hbWVzIHVzZWQgaGVyZSBhcmUgZGVmaW5lZCBpbiBDYW52YXMuanMuIE5vdGUgdGhhdCBhbGwga2V5cHJlc3NlcyBhY3R1YWxseSBoYXZlIHR3byBuYW1lcywgYSBub3JtYWwgbmFtZSBhbmQgYSBzaGlmdGVkIG5hbWUuIFRoZSBsYXR0ZXIgbmFtZSBpcyB1c2VkIHdoZW4gZWl0aGVyICoqc2hpZnQqKiBpcyBkZXByZXNzZWQuXG4gICAgICpcbiAgICAgKiBUaGUgYnVpbHQtaW4gbmF2IGtleXByZXNzZXMgYXJlIGFzIGZvbGxvd3M6XG4gICAgICogKiAqKmBVUGAqKiBfKHVwLWFycm93IGtleSlfIC0gUmVwbGFjZSBhbGwgc2VsZWN0aW9ucyB3aXRoIGEgc2luZ2xlIGNlbGwsIG9uZSByb3cgdXAgZnJvbSB0aGUgbGFzdCBzZWxlY3Rpb24uXG4gICAgICogKiAqKmBET1dOYCoqIF8oZG93bi1hcnJvdyBrZXkpXyAtIFJlcGxhY2UgYWxsIHNlbGVjdGlvbnMgd2l0aCBhIHNpbmdsZSBjZWxsLCBvbmUgcm93IGRvd24gZnJvbSB0aGUgbGFzdCBzZWxlY3Rpb24uXG4gICAgICogKiAqKmBMRUZUYCoqIF8obGVmdC1hcnJvdyBrZXkpXyAtIFJlcGxhY2UgYWxsIHNlbGVjdGlvbnMgd2l0aCBhIHNpbmdsZSBjZWxsLCBvbmUgY29sdW1uIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IHNlbGVjdGlvbi5cbiAgICAgKiAqICoqYFJJR0hUYCoqIF8ocmlnaHQtYXJyb3cga2V5KV8gLSBSZXBsYWNlIGFsbCBzZWxlY3Rpb25zIHdpdGggYSBzaW5nbGUgY2VsbCwgb25lIGNvbHVtbiB0byB0aGUgcmlnaHQgb2YgdGhlIGxhc3Qgc2VsZWN0aW9uLlxuICAgICAqICogKipgVVBTSElGVGAqKiBfKHNoaWZ0ICsgdXAtYXJyb3cpXyAtIEV4dGVuZCB0aGUgbGFzdCBzZWxlY3Rpb24gdXAgb25lIHJvdy5cbiAgICAgKiAqICoqYERPV05TSElGVGAqKiBfKHNoaWZ0ICsgZG93bi1hcnJvdylfIC0gRXh0ZW5kIHRoZSBsYXN0IHNlbGVjdGlvbiBkb3duIG9uZSByb3cuXG4gICAgICogKiAqKmBMRUZUU0hJRlRgKiogXyhzaGlmdCArIGxlZnQtYXJyb3cpXyAtIEV4dGVuZCB0aGUgbGFzdCBzZWxlY3Rpb24gbGVmdCBvbmUgY29sdW1uLlxuICAgICAqICogKipgUklHSFRTSElGVGAqKiBfKHNoaWZ0ICsgcmlnaHQtYXJyb3cpXyAtIEV4dGVuZCB0aGUgbGFzdCBzZWxlY3Rpb24gcmlnaHQgb25lIGNvbHVtbi5cbiAgICAgKlxuICAgICAqIFRvIGFsdGVyIHRoZXNlIG9yIGFkZCBvdGhlciBtYXBwaW5ncyBzZWUgdGhlIGV4YW1wbGVzIGJlbG93LlxuICAgICAqXG4gICAgICogQSBub3RlIHJlZ2FyZGluZyB0aGUgb3RoZXIgbWV0YSBrZXlzICgqKnRybCoqLCAqKm9wdGlvbioqLCBhbmQgKipjb21tYW5kKiopOiBBbHRob3VnaCB0aGVzZSBtZXRhIGtleXMgY2FuIGJlIGRldGVjdGVkLCB0aGV5IGRvIG5vdCBtb2RpZnkgdGhlIGtleSBuYW1lcyBhcyAqKnNoaWZ0KiogZG9lcy4gVGhpcyBpcyBiZWNhdXNlIHRoZXkgYXJlIG1vcmUgZm9yIHN5c3RlbSB1c2UgYW5kIGdlbmVyYWxseSAod2l0aCB0aGUgcG9zc2libHkgZXhjZXB0aW9uIGZvICoqY3RybCoqKSBzaG91bGQgbm90IGJlIGRlcGVuZGVkIHVwb24sIGFzIHN5c3RlbSBmdW5jdGlvbnMgd2lsbCB0YWtlIHByaW9yaXR5IGFuZCB5b3VyIGFwcCB3aWxsIG5ldmVyIHNlZSB0aGVzZSBrZXkgcHJlc3Nlcy5cbiAgICAgKlxuICAgICAqIEEgc3BlY2lhbCBhY2NvbW1vZGF0aW9uIGhhcyBiZWVuIG1hZGUgdG8gdGhlIHtAbGluayBtb2R1bGU6ZGVmYXVsdHMuZWRpdE9uS2V5ZG93bnxlZGl0T25LZXlkb3dufSBwcm9wZXJ0eTpcbiAgICAgKiAqIElmIGBlZGl0T25LZXlkb3duYCB0cnV0aHkgQU5EIG1hcHBlZCBjaGFyYWN0ZXIgaXMgYW4gYWN0dWFsIChub24td2hpdGUtc3BhY2UpIGNoYXJhY3RlciAoYXMgb3Bwb3NlZCB0byBzYXkgKip0YWIqKiBvciAqKnJldHVybioqKSwgdGhlbiBuYXZpZ2F0aW9uIHJlcXVpcmVzICoqY3RybCoqIGtleSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIG5hdiBhbmQgZGF0YS5cbiAgICAgKiAqIElmIGBlZGl0T25LZXlkb3duYCBmYWxzeSwgdGhlICoqY3RybCoqIGtleSBpcyBpZ25vcmVkLlxuICAgICAqXG4gICAgICogU28gaW4gdGhlIGxhc3QgZXhhbXBsZSwgaWYgYGVkaXRPbktleWRvd25gIGlzIE9OLCB0aGVuIGBhYCAod2l0aG91dCAqKmN0cmwqKikgd291bGQgc3RhcnQgZWRpdGluZyB0aGUgY2VsbCBhbmQgKipjdHJsKiogKyBgYWAgd291bGQgbW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjb2x1bW4gdG8gdGhlIGxlZnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFRvIHZvaWQgdGhlIGFib3ZlIGJ1aWxkLWluczpcbiAgICAgKiBuYXZLZXlNYXA6IHtcbiAgICAgKiAgICAgVVA6IHVuZGVmaW5lZCxcbiAgICAgKiAgICAgVVBTSElGVDogdW5kZWZpbmVkLFxuICAgICAqICAgICBET1dOOiB1bmRlZmluZWQsXG4gICAgICogICAgIC4uLlxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gVG8gbWFwIGFsdGVybmF0aXZlIG5hdiBrZXlwcmVzc2VzIHRvIFJFVFVSTiBhbmQgVEFCIChkZWZhdWx0IG1hcHBpbmcpOlxuICAgICAqIG5hdktleU1hcDoge1xuICAgICAqICAgICBSRVRVUk46ICdET1dOJyxcbiAgICAgKiAgICAgUkVUVVJOU0hJRlQ6ICdVUCcsXG4gICAgICogICAgIFRBQjogJ1JJR0hUJyxcbiAgICAgKiAgICAgVEFCU0hJRlQ6ICdMRUZUJ1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gVG8gbWFwIGFsdGVybmF0aXZlIG5hdiBrZXlwcmVzc2VzIHRvIGEvdy9kL3MgYW5kIGV4dGVuZCBzZWxlY3QgdG8gQS9XL0QvUzpcbiAgICAgKiBuYXZLZXlNYXA6IHtcbiAgICAgKiAgICAgYTogJ0xFRlQnLCBBOiAnTEVGVFNISUZUJyxcbiAgICAgKiAgICAgdzogJ1VQJywgVzogJ1VQU0hJRlQnLFxuICAgICAqICAgICBzOiAnRE9XTicsIFM6ICdET1dOU0hJRlQnLFxuICAgICAqICAgICBkOiAnUklHSFQnLCBEOiAnUklHSFRTSElGVCdcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtvYmplY3R8dW5kZWZpbmVkfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBuYXZLZXlNYXA6IHtcbiAgICAgICAgUkVUVVJOOiAnRE9XTicsXG4gICAgICAgIFJFVFVSTlNISUZUOiAnVVAnLFxuICAgICAgICBUQUI6ICdSSUdIVCcsXG4gICAgICAgIFRBQlNISUZUOiAnTEVGVCdcbiAgICB9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IFZhbGlkYXRpb24gZmFpbHVyZSBmZWVkYmFjay5cbiAgICAgKiBAZGVzYyBWYWxpZGF0aW9uIG9jY3VycyBvbiB7QGxpbmsgQ2VsbEVkaXRvciNzdG9wRWRpdGluZ30sIG5vcm1hbGx5IGNhbGxlZCBvbiBjb21taXQgKGBUQUJgLCBgRU5URVJgLCBvciBhbnkgb3RoZXIga2V5cyBsaXN0ZWQgaW4gYG5hdktleU1hcGApLlxuICAgICAqXG4gICAgICogT24gc3VjY2Vzc2Z1bCB2YWxpZGF0aW9uLCB0aGUgdmFsdWUgaXMgc2F2ZWQgYmFjayB0byB0aGUgZGF0YSBzb3VyY2UgYW5kIHRoZSBlZGl0b3IgaXMgY2xvc2VkLlxuICAgICAqXG4gICAgICogT24gdmFsaWRhdGlvbiBmYWlsdXJlLCBmZWVkYmFjayBpcyBzaG93biB0byB0aGUgdXNlciBpbiB0aGUgZm9ybSBvZiBhbiBcImVycm9yIGVmZmVjdFwiIHBvc3NpYmx5IGZvbGxvd2VkIGJ5IGFuIFwiZW5kIGVmZmVjdFwiIGNvbnRhaW5pbmcgYSBkZXRhaWxlZCBleHBsYW5hdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBlcnJvciBlZmZlY3QgdG8gdXNlIGlzIG5hbWVkIGluIGBmZWVkYmFja0VmZmVjdFxuICAgICAqXG4gICAgICogVGhlIHZhbHVlIG9mIHRoaXMgcHJvcGVydHkgaXMgdGhlIG51bWJlciBvZiB0aW1lcyB0byBzaG93IHRoZSBcImVycm9yIGVmZmVjdFwiIG9uIHZhbGlkYXRpb24gZmFpbHVyZSBiZWZvcmUgc2hvd2luZyB0aGUgZGV0YWlsZWQgZXhwbGFuYXRpb24uXG4gICAgICpcbiAgICAgKiBgZmVlZGJhY2tgIG1heSBiZSBzZXQgdG8gb25lIG9mOlxuICAgICAqICogKipgdW5kZWZpbmVkYCoqIC0gRG8gbm90IHNob3cgdGhlIGVycm9yIGVmZmVjdCBvciB0aGUgYWxlcnQuIEp1c3QgZGlzY2FyZCB0aGUgdmFsdWUgYW5kIGNsb3NlIHRoZSBlZGl0b3IgKGFzIGlmIGBFU0NgIGhhZCBiZWVuIHR5cGVkKS5cbiAgICAgKiAqICoqYDBgKiogLSBKdXN0IHNob3dzIHRoZSBlcnJvciBmZWVkYmFjayBlZmZlY3QgKHNlZSB0aGUge0BsaW5rIENlbGxFZGl0b3IjZXJyb3JFZmZlY3R8ZXJyb3JFZmZlY3R9IHByb3BlcnR5KS5cbiAgICAgKiAqICoqYDFgKiogLSBTaG93cyB0aGUgZXJyb3IgZmVlZGJhY2sgZWZmZWN0IGZvbGxvd2VkIGJ5IHRoZSBkZXRhaWxlZCBleHBsYW5hdGlvbi5cbiAgICAgKiAqIGAyYCBvciBtb3JlOlxuICAgICAqICAgMS4gU2hvd3MgdGhlIGVycm9yIGZlZWRiYWNrIGVmZmVjdFxuICAgICAqICAgMi4gT24gZXZlcnkgYGZlZWRiYWNrYCB0cmllcywgc2hvd3MgdGhlIGRldGFpbGVkIGV4cGxhbmF0aW9uLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGZlZWRiYWNrQ291bnQ6IDMsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHt7bmFtZTpzdHJpbmcsb3B0aW9uczpvYmplY3R9fHN0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgZmVlZGJhY2tFZmZlY3Q6ICdzaGFrZXInLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgcmVhZE9ubHk6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBmaXhlZENvbHVtbkNvdW50OiAwLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBmaXhlZFJvd0NvdW50OiAwLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICByb3dIZWFkZXJIYWxpZ246ICdjZW50ZXInLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmR5bmFtaWNQcm9wZXJ0eURlc2NyaXB0b3JzLnNob3dSb3dOdW1iZXJzfVxuICAgICAqL1xuICAgIHJvd0hlYWRlck51bWJlcnM6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6ZHluYW1pY1Byb3BlcnR5RGVzY3JpcHRvcnMuc2hvd1Jvd051bWJlcnN9XG4gICAgICovXG4gICAgcm93SGVhZGVyQ2hlY2tib3hlczogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHJvd0hlYWRlclN0YXJ0RGlzcGxheWVkSW5kZXg6IDEsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBzaG93VHJlZUNvbHVtbjogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgdHJlZVJlbmRlcmVyOiAnU2ltcGxlQ2VsbCcsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBzaG93SGVhZGVyUm93OiB0cnVlLFxuXG4gICAgLyoqIENsaWNraW5nIGluIGEgY2VsbCBcInNlbGVjdHNcIiBpdDsgaXQgaXMgYWRkZWQgdG8gdGhlIHNlbGVjdCByZWdpb24gYW5kIHJlcGFpbnRlZCB3aXRoIFwiY2VsbCBzZWxlY3Rpb25cIiBjb2xvcnMuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY2VsbFNlbGVjdGlvbjogdHJ1ZSxcblxuICAgIC8qKiBDbGlja2luZyBpbiBhIGNvbHVtbiBoZWFkZXIgKHRvcCByb3cpIFwic2VsZWN0c1wiIHRoZSBjb2x1bW47IHRoZSBlbnRpcmUgY29sdW1uIGlzIGFkZGVkIHRvIHRoZSBzZWxlY3QgcmVnaW9uIGFuZCByZXBhaW50ZWQgd2l0aCBcImNvbHVtbiBzZWxlY3Rpb25cIiBjb2xvcnMuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY29sdW1uU2VsZWN0aW9uOiB0cnVlLFxuXG4gICAgLyoqIENsaWNraW5nIGluIGEgcm93IGhlYWRlciAobGVmdG1vc3QgY29sdW1uKSBcInNlbGVjdHNcIiB0aGUgcm93OyB0aGUgZW50aXJlIHJvdyBpcyBhZGRlZCB0byB0aGUgc2VsZWN0IHJlZ2lvbiBhbmQgcmVwYWludGVkIHdpdGggXCJyb3cgc2VsZWN0aW9uXCIgY29sb3JzLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHJvd1NlbGVjdGlvbjogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIElmIHRydWUsIGZpY3RpdmUgaGVhZGVyIHJvd3Mgd2lsbCB1c2UgcmVndWxhciBzZWxlY3Rpb24gcnVsZXNcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBzZWxlY3RGaWN0aXZlSGVhZGVyQ2VsbHNBc1JlZ3VsYXI6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBJZiB0cnVlLCBDdHJsK1tVUC9Eb3duXSB3aWxsIG9ubHkgZ29lcyB0byB2ZXJ5IGZpcnN0L2xhc3Qgcm93XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgaWdub3JlRGF0YUNlbGxzT25WZXJ0aWNhbEN0cmxTZWxlY3Rpb246IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBzaW5nbGVSb3dTZWxlY3Rpb25Nb2RlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEZpbGwgY29sb3IgZm9yIGxhc3Qgc2VsZWN0aW9uIG92ZXJsYXkuXG4gICAgICogQGRlc2MgVGhlIGNvbG9yIHNob3VsZCBiZSB0cmFuc2x1Y2VudCAob3IgdHJhbnNwYXJlbnQpLiBOb3RlIHRoYXQgXCJQYXJ0aWFsXCIgZ3JpZCByZW5kZXJlcnMgKHN1Y2ggYXMgdGhlIHtAbGluayBwYWludENlbGxzQXNOZWVkZWR9IHJlbmRlcmVyKSBkbyBub3QgZHJhdyBvdmVybGF5IGJlY2F1c2UgaXQganVzdCBnZXRzIGRhcmtlciBhbmQgZGFya2VyIGZvciBub24tdXBkYXRlZCBjZWxscy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgc2VsZWN0aW9uUmVnaW9uT3ZlcmxheUNvbG9yOiAncmdiYSgxNjAsMTk1LDI1NSwuMiknLCAvLyAndHJhbnNwYXJlbnQnLCAvLyAncmdiYSgwLCAwLCA0OCwgMC4yKScsXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTdHJva2UgY29sb3IgZm9yIGxhc3Qgc2VsZWN0aW9uIG92ZXJsYXkuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25SZWdpb25PdXRsaW5lQ29sb3I6ICcjNDI4NUY0JyxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFdpZHRoIG9mIHNlbGVjdGVkIHJlZ2lvbiBib3JkZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHNlbGVjdGlvblJlZ2lvbkJvcmRlcldpZHRoOiAxLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY29sdW1uQXV0b3NpemluZzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHJvd051bWJlckF1dG9zaXppbmc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBoZWFkZXJUZXh0V3JhcHBpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgcm93UmVzaXplOiBmYWxzZSxcblxuXG4gICAgLyogQ0VMTCBFRElUSU5HICovXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBlZGl0YWJsZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBFZGl0IGNlbGwgb24gZG91YmxlLWNsaWNrIHJhdGhlciB0aGFuIHNpbmdsZS1jbGljay5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGVkaXRPbkRvdWJsZUNsaWNrOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogR3JpZC1sZXZlbCBwcm9wZXJ0eS5cbiAgICAgKiBXaGVuIHVzZXIgcHJlc3NlcyBhIFwicHJpbnRhYmxlXCIga2V5Ym9hcmQgY2hhcmFjdGVyIF9vcl8gQkFDS1NQQUNFIF9vcl8gREVMRVRFOlxuICAgICAqIDEuIEFjdGl2YXRlIGNlbGwgZWRpdG9yIG9uIGN1cnJlbnQgY2VsbCAoaS5lLiwgb3JpZ2luIG9mIG1vc3QgcmVjZW50IHNlbGVjdGlvbikuXG4gICAgICogMi4gSWYgY2VsbCBlZGl0b3IgaXMgYSB0ZXh0IGVkaXRvcjpcbiAgICAgKiAgICAxLiBSZXBsYWNlIGN1cnJlbnQgdmFsdWUgd2l0aCB0aGUgY2hhcmFjdGVyIHRoZSB1c2VyIHR5cGVkOyBvclxuICAgICAqICAgIDIuIENsZWFyIGl0IG9uIEJBQ0tTUEFDRSwgREVMRVRFLCBvciBvdGhlciBpbnZhbGlkIGNoYXJhY3RlciAoX2UuZy5fIHdoZW4gdXNlciB0eXBlcyBhIGxldHRlciBidXQgdGhlIGNlbGwgZWRpdG9yIG9ubHkgYWNjZXB0cyBkaWdpdHMpLlxuICAgICAqXG4gICAgICogPiBJbiBpbnZva2VkLCB1c2VyIGhhcyB0aGUgb3B0aW9uIHRvIGJhY2sgb3V0IGJ5IHByZXNzaW5nIHRoZSBFU0NBUEUga2V5LlxuICAgICAqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgZWRpdE9uS2V5ZG93bjogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IE9wZW4gY2VsbCBlZGl0b3Igd2hlbiBjZWxsIHNlbGVjdGVkIHZpYSBrZXlib2FyZCBuYXZpZ2F0aW9uLlxuICAgICAqIEBkZXNjIEtleWJvYXJkIG5hdmlnYXRpb24gYWx3YXlzIGluY2x1ZGVzOlxuICAgICAqIDEuIFRoZSBmb3VyIGFycm93IGtleXMgLS0gYnV0IG9ubHkgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgdGV4dCBjZWxsIGVkaXRvciBvcGVuXG4gICAgICogMi4gQWRkaXRpb25hbCBrZXlzIG1hcHBlZCB0byB0aGUgZm91ciBkaXJlY3RzIGluIHtAbGluayBtb2R1bGU6ZGVmYXVsdHMubmF2S2V5TWFwfVxuICAgICAqXG4gICAgICogR2VuZXJhbGx5IHNldCBhdCB0aGUgZ3JpZCBsZXZlbC4gSWYgc2V0IGF0IHRoZSBjb2x1bW4gKG9yIGNlbGwpIGxldmVsLCBub3RlIHRoYXQgdGhlIHByb3BlcnR5IHBlcnRhaW5zIHRvIHRoZSBjZWxsIG5hdmlnYXRlZCBfdG8sXyBub3QgdGhlIGNlbGwgbmF2aWdhdGVkIF9hd2F5IGZyb20uX1xuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGVkaXRPbk5leHRDZWxsOiBmYWxzZSxcblxuXG4gICAgLyogQ09MVU1OIFNPUlRJTkcgKi9cblxuICAgIC8qKlxuICAgICAqIElnbm9yZSBzb3J0IGhhbmRsaW5nIGluIGZlYXR1cmUvQ29sdW1uU29ydGluZy5qcy5cbiAgICAgKiBVc2VmdWwgZm9yIGV4Y2x1ZGluZyBzb21lIGNvbHVtbnMgYnV0IG5vdCBvdGhlciBmcm9tIHBhcnRpY2lwYXRpbmcgaW4gc29ydGluZy5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHVuc29ydGFibGU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogU29ydCBjb2x1bW4gb24gZG91YmxlLWNsaWNrIHJhdGhlciB0aGFuIHNpbmdsZS1jbGljay5cbiAgICAgKlxuICAgICAqIFVzZWQgYnk6XG4gICAgICogKiBmZWF0dXJlL0NvbHVtblNvcnRpbmcuanMgdG8gZGVjaWRlIHdoaWNoIGV2ZW50IHRvIHJlc3BvbmQgdG8gKGlmIGFueSwgc2VlIGB1bnNvcnRhYmVgKS5cbiAgICAgKiAqIGZlYXR1cmUvQ29sdW1uU2VsZWN0aW9uLmpzIHRvIGRlY2lkZSB3aGV0aGVyIG9yIG5vdCB0byB3YWl0IGZvciBkb3VibGUtY2xpY2suXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgc29ydE9uRG91YmxlQ2xpY2s6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiAqKlRoaXMgaXMgYSBzdGFuZGFyZCBwcm9wZXJ0eSBkZWZpbml0aW9uIGZvciBzb3J0IHBsdWctaW4gdXNlLlxuICAgICAqIEl0IGlzIG5vdCByZWZlcmVuY2VkIGluIGNvcmUuKipcbiAgICAgKlxuICAgICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjb2x1bW5zIHRoYXQgbWF5IHBhcnRpY2lwYXRlIGluIGEgbXVsdGktY29sdW1uIHNvcnQgKHZpYSBjdHJsLWNsaWNrIGhlYWRlcnMpLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgbWF4U29ydENvbHVtbnM6IDMsXG5cbiAgICAvKipcbiAgICAgKiAqKlRoaXMgaXMgYSBzdGFuZGFyZCBwcm9wZXJ0eSBkZWZpbml0aW9uIGZvciBzb3J0IHBsdWctaW4gdXNlLlxuICAgICAqIEl0IGlzIG5vdCByZWZlcmVuY2VkIGluIGNvcmUuKipcbiAgICAgKlxuICAgICAqIENvbHVtbihzKSBwYXJ0aWNpcGF0aW5nIGFuZCBzdWJzZXF1ZW50bHkgaGlkZGVuIHN0aWxsIGFmZmVjdCBzb3J0LlxuICAgICAqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgc29ydE9uSGlkZGVuQ29sdW1uczogdHJ1ZSxcblxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmV0YWluIHJvdyBzZWxlY3Rpb25zLlxuICAgICAqIEBkZXNjIFdoZW4gZmFsc3ksIHJvdyBzZWxlY3Rpb25zIGFyZSBjbGVhcmVkIHdoZW4gc2VsZWN0aW5nIGNlbGxzOyB3aGVuIHRydXRoeSwgcm93IHNlbGVjdGlvbnMgYXJlIGtlcHQgYXMgaXMgd2hlbiBzZWxlY3RpbmcgY2VsbHMuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAga2VlcFJvd1NlbGVjdGlvbnM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU2VsZWN0IGNlbGwncyBlbnRpcmUgcm93LlxuICAgICAqIEBkZXNjIFdoZW4gdHJ1dGh5LCBzZWxlY3RpbmcgYSBjZWxsIHdpbGwgYWxzbyBzZWxlY3QgdGhlIGVudGlyZSByb3cgaXQgaXMgaW4sIHN1YmplY3QgdG8gbm90ZSAjMSBiZWxvdy5cbiAgICAgKlxuICAgICAqIE5vdGVzOlxuICAgICAqIDEuIEluZWZmZWN0dWFsIHVubGVzcyBgY2hlY2tib3hPbmx5Um93U2VsZWN0aW9uc2AgaXMgc2V0IHRvIGBmYWxzZWAuXG4gICAgICogMi4gVG8gYWxsb3cgYXV0by1zZWxlY3Rpb24gb2YgX211bHRpcGxlIHJvd3MsXyBzZXQgYHNpbmdsZVJvd1NlbGVjdGlvbk1vZGVgIHRvIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBhdXRvU2VsZWN0Um93czogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTZWxlY3QgY2VsbCdzIGVudGlyZSBjb2x1bW4uXG4gICAgICogQGRlc2MgV2hlbiB0cnV0aHksIHNlbGVjdGluZyBhIGNlbGwgd2lsbCBhbHNvIHNlbGVjdCB0aGUgZW50aXJlIGNvbHVtbiBpdCBpcyBpbi5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBhdXRvU2VsZWN0Q29sdW1uczogZmFsc2UsXG5cbiAgICAvKiogQHN1bW1hcnkgTmFtZSBvZiBhIGZvcm1hdHRlciBmb3IgY2VsbCB0ZXh0LlxuICAgICAqIEBkZXNjIFRoZSBkZWZhdWx0IChgdW5kZWZpbmVkYCkgZmFsbHMgYmFjayB0byBgY29sdW1uLnR5cGVgLlxuICAgICAqIFRoZSB2YWx1ZSBgbnVsbGAgZG9lcyBubyBmb3JtYXR0aW5nLlxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAqIEB0eXBlIHt1bmRlZmluZWR8bnVsbHxzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqIEB0dXRvcmlhbCBsb2NhbGl6YXRpb25cbiAgICAgKi9cbiAgICBmb3JtYXQ6IHVuZGVmaW5lZCxcblxuICAgIC8qKiBAc3VtbWFyeSBOYW1lIG9mIGEgY2VsbCBlZGl0b3IgZnJvbSB0aGUge0BsaW5rIG1vZHVsZTpjZWxsRWRpdG9yc3xjZWxsRWRpdG9ycyBBUEl9Li5cbiAgICAgKiBAZGVzYyBOb3QgZWRpdGFibGUgaWYgbmFtZWQgZWRpdG9yIGlzIGRvZXMgbm90IGV4aXN0LlxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAqIEB0eXBlIHt1bmRlZmluZWR8bnVsbHxzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqIEB0dXRvcmlhbCBjZWxsLWVkaXRvcnNcbiAgICAgKi9cbiAgICBlZGl0b3I6ICd0ZXh0ZmllbGQnLFxuXG4gICAgLyoqXG4gICAgICogTmFtZSBvZiBjZWxsIHJlbmRlcmVyIGZyb20gdGhlIHtAbGluayBtb2R1bGU6Y2VsbFJlbmRlcmVyc3xjZWxsUmVuZGVyZXJzIEFQSX0uXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICByZW5kZXJlcjogJ1NpbXBsZUNlbGwnLFxuXG4gICAgLyoqXG4gICAgICogTmFtZSBvZiBncmlkIHJlbmRlcmVyLlxuICAgICAqIFJlbmRlcmVyIG11c3QgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQuXG4gICAgICogQHNlZSB7QGxpbmsgUmVuZGVyZXIjcmVnaXN0ZXJHcmlkUmVuZGVyZXJ9LlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgZ3JpZFJlbmRlcmVyOiAnYnktY29sdW1ucy1hbmQtcm93cycsXG5cbiAgICAvKioqKioqKioqKiBIT1ZFUiBDT0xPUlMgKioqKioqKioqKi9cblxuICAgIC8qKiBAdHlwZWRlZiBob3ZlckNvbG9yc1xuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2VuYWJsZT1mYWxzZV0gLSBgZmFsc2VgIG1lYW5zIG5vdCBoaWxpdGUgb24gaG92ZXJcbiAgICAgKiBAcHJvcGVydHkge2Nzc0NvbG9yfSBiYWNrZ3JvdW5kQ29sb3IgLSBjZWxsLCByb3csIG9yIGNvbHVtbiBiYWNrZ3JvdW5kIGNvbG9yLiBBbHBoYSBjaGFubmVsIHdpbGwgYmUgcmVzcGVjdGVkIGFuZCBpZiBnaXZlbiB3aWxsIGJlIHBhaW50ZWQgb3ZlciB0aGUgY2VsbHMgcHJlZGV0ZXJtaW5lZCBjb2xvci5cbiAgICAgKiBAcHJvcGVydHkge2Nzc0NvbG9yfSBbaGVhZGVyLmJhY2tncm91bmRDb2xvcj1iYWNrZ3JvdW5kQ29sb3JdIC0gZm9yIGNvbHVtbnMgYW5kIHJvd3MsIHRoaXMgaXMgdGhlIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIGNvbHVtbiBvciByb3cgXCJoYW5kbGVcIiAoaGVhZGVyIHJvd3Mgb3IgY29sdW1ucywgcmVzcGVjdGl2ZWx5KS4gKE5vdCB1c2VkIGZvciBjZWxscy4pXG4gICAgICovXG5cbiAgICAvKiogT24gbW91c2UgaG92ZXIsIHdoZXRoZXIgdG8gcmVwYWludCB0aGUgY2VsbCBiYWNrZ3JvdW5kIGFuZCBob3cuXG4gICAgICogQHR5cGUge2hvdmVyQ29sb3JzfVxuICAgICAqIEBkZWZhdWx0ICd7IGVuYWJsZWQ6IHRydWUsIGJhY2tncm91bmQ6IHJnYmEoMTYwLCAxNjAsIDQwLCAwLjMwKSB9J1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBob3ZlckNlbGxIaWdobGlnaHQ6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgxNjAsIDE2MCwgNDAsIDAuNDUpJ1xuICAgIH0sXG5cbiAgICAvKiogT24gbW91c2UgaG92ZXIsIHdoZXRoZXIgdG8gcmVwYWludCB0aGUgcm93IGJhY2tncm91bmQgYW5kIGhvdy5cbiAgICAgKiBAdHlwZSB7aG92ZXJDb2xvcnN9XG4gICAgICogQGRlZmF1bHQgJ3sgZW5hYmxlZDogdHJ1ZSwgYmFja2dyb3VuZDogcmdiYSgxMDAsIDEwMCwgMjUsIDAuMTUpIH0nXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGhvdmVyUm93SGlnaGxpZ2h0OiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDEwMCwgMTAwLCAyNSwgMC4zMCknXG5cbiAgICB9LFxuXG4gICAgLyoqIE9uIG1vdXNlIGhvdmVyLCB3aGV0aGVyIHRvIHJlcGFpbnQgdGhlIGNvbHVtbiBiYWNrZ3JvdW5kIGFuZCBob3cuXG4gICAgICogQHR5cGUge2hvdmVyQ29sb3JzfVxuICAgICAqIEBkZWZhdWx0ICd7IGVuYWJsZWQ6IHRydWUsIGJhY2tncm91bmQ6IHJnYmEoNjAsIDYwLCAxNSwgMC4xNSkgfSdcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgaG92ZXJDb2x1bW5IaWdobGlnaHQ6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoNjAsIDYwLCAxNSwgMC4xNSknXG4gICAgfSxcblxuICAgIC8qKiBAc3VtbWFyeSBEaXNwbGF5IGNlbGwgdmFsdWUgYXMgYSBsaW5rICh3aXRoIHVuZGVybGluZSkuXG4gICAgICogQGRlc2MgT25lIG9mOlxuICAgICAqICogYGJvb2xlYW5gIC0gTm8gYWN0aW9uIG9jY3VycyBvbiBjbGljazsgeW91IHdvdWxkIG5lZWQgdG8gYXR0YWNoIGEgJ2Zpbi1jbGljaycgbGlzdGVuZXIgdG8gdGhlIGh5cGVyZ3JpZCBvYmplY3QuXG4gICAgICogICAqIGB0cnVlYCAtIERpc3BsYXlzIHRoZSBjZWxsIGFzIGEgbGluay5cbiAgICAgKiAgICogX2ZhbHN5XyAtIERpc3BsYXlzIHRoZSBjZWxsIG5vcm1hbGx5LlxuICAgICAqICogYHN0cmluZ2AgLSAgVGhlIFVSTCBpcyBkZWNvcmF0ZWQgKHNlZSB7fSkgYW5kIHRoZW4gb3BlbmVkIGluIGEgc2VwYXJhdGUgd2luZG93L3RhYi4gU2VlIGFsc28ge0BsaW5rIG1vZHVsZTpkZWZhdWx0cy5saW5rVGFyZ2V0fGxpbmtUYXJnZXR9LlxuICAgICAqICAgKiBgJyonYCAtIFVzZSB0aGUgY2VsbCB2YWx1ZSBhcyB0aGUgVVJMLCByZWFkeSBmb3IgZGVjb3JhdGluZyAoc2VlIHtDZWxsQ2xpY2sjb3Blbkxpbmt8b3BlbkxpbmspKS5cbiAgICAgKiAgICogX2ZpZWxkIG5hbWVfIC0gRmV0Y2hlcyB0aGUgc3RyaW5nIGZyb20gdGhlIG5hbWVkIGZpZWxkIGluIHRoZSBzYW1lIHJvdywgYXNzdW1lZCB0byBiZSBhIFVSTCByZWFkeSBmb3IgZGVjb3JhdGluZy4gKE1heSBjb250YWluIG9ubHkgYWxwaGFudW1lcmljcyBhbmQgdW5kZXJzY29yZTsgbm8gc3BhY2VzIG9yIG90aGVyIHB1bmN0dWF0aW9uLilcbiAgICAgKiAgICogX290aGVyd2lzZV8gQXNzdW1lZCB0byBjb250YWlucyBhIFVSTCByZWFkeSBmb3IgZGVjb3JhdGluZy5cbiAgICAgKiAqIGBmdW5jdGlvbmAgLSBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgdG8gZ2V0IHRoZSBVUkwgcmVhZHkgZm9yIGRlY29yYXRpbmcuIFRoZSBmdW5jdGlvbiBpcyBwYXNzZWQgYSBzaW5nbGUgcGFyYW1ldGVyLCBgY2VsbEV2ZW50YCwgZnJvbSB3aGljaCB5b3UgY2FuIGdldCB0aGUgZmllbGQgYG5hbWVgLCBgZGF0YVJvd2AsIF9ldGMuX1xuICAgICAqICogYEFycmF5YCAtIEFuIGFycmF5IHRvIFwiYXBwbHlcIiB0byB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1dpbmRvdy9vcGVuIHdpbmRvdy5vcGVufSBpbiBpdHMgZW50aXJldHkuIFRoZSBmaXJzdCBlbGVtZW50IGlzIGludGVycHJldGVkIGFzIGFib3ZlIGZvciBgc3RyaW5nYCBvciBgZnVuY3Rpb25gLlxuICAgICAqXG4gICAgICogSW4gdGhlIGNhc2Ugb2YgYHN0cmluZ2Agb3IgYEFycmF5YCwgdGhlIGxpbmsgaXMgZnVydGhlciB1bnBhY2tlZCBieSB7QGxpbmsgbW9kdWxlOkNlbGxDbGljay5vcGVuTGlua3xvcGVuTGlua30gYW5kIHRoZW4gc2VudCB0byBgZ3JpZC53aW5kb3dPcGVuYC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZm9sbG93aW5nIGFmZmVjdCB1cHBlci1sZWZ0IGRhdGEgY2VsbDpcbiAgICAgKiBncmlkLmJlaGF2aW9yLnNldENlbGxQcm9wZXJ0eSgwLCAwLCAnaHR0cHM6Ly9ueXRpbWVzLmNvbScpOyAvLyBhYnNvbHV0ZSBhZGRyZXNzIHVzaW5nIHNwZWNpZmljIHByb3RvY29sXG4gICAgICogZ3JpZC5iZWhhdmlvci5zZXRDZWxsUHJvcGVydHkoMCwgMCwgJy8vbnl0aW1lcy5jb20nKTsgLy8gYWJzb2x1dGUgYWRkcmVzcyB1c2luZyBjdXJyZW50IHByb3RvY29sXG4gICAgICogZ3JpZC5iZWhhdmlvci5zZXRDZWxsUHJvcGVydHkoMCwgMCwgJy9wYWdlMi5jb20nKTsgLy8gcmVsYXRpdmUgdG8gY3VycmVudCBzaXRlXG4gICAgICogZ3JpZC5iZWhhdmlvci5zZXRDZWxsUHJvcGVydHkoMCwgMCwgJ215cGFnZS5jb20nKTsgLy8gcmVsYXRpdmUgdG8gY3VycmVudCBwYWdlXG4gICAgICogZ3JpZC5iZWhhdmlvci5zZXRDZWxsUHJvcGVydHkoMCwgMCwgJ215cGFnZS5jb20/aWQ9JXZhbHVlJyk7IC8vIGNlbGwncyB2YWx1ZSB3aWxsIHJlcGxhY2UgJXZhbHVlXG4gICAgICogZ3JpZC5iZWhhdmlvci5zZXRDZWxsUHJvcGVydHkoMCwgMCwgWycvL3d3dy5uZXd5b3JrZXIuY29tJywgJ255JywgdW5kZWZpbmVkLCB0cnVlXSkgLy8gdGFyZ2V0PSdueScsIHJlcGxhY2U9dHJ1ZVxuICAgICAqIEB0eXBlIHtib29sZWFufHN0cmluZ3xBcnJheX1cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBsaW5rOiBmYWxzZSxcblxuICAgIC8qKiBAc3VtbWFyeSBUaGUgd2luZG93IChvciB0YWIpIGluIHdoaWNoIHRvIG9wZW4gdGhlIGxpbmsuXG4gICAgICogQGRlc2MgVGhlIGRlZmF1bHQgKCdfYmxhbmsnYCkgd2lsbCBvcGVuIGEgbmV3IHdpbmRvdyBmb3IgZXZlcnkgY2xpY2suXG4gICAgICpcbiAgICAgKiBUbyBoYXZlIHRoZSBmaXJzdCBjbGljayBvcGVuIGEgbmV3IHdpbmRvdyBhbmQgYWxsIHN1YnNlcXVlbnQgY2xpY2tzIHJldXNlIHRoYXQgc2FtZSB3aW5kb3csIHNldCB0aGlzIHRvIGFuIGFyYml0cmFyeSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBPdGhlcndpc2UsIHNwZWNpZmljIGNvbHVtbnMgb3IgY2VsbHMgY2FuIGJlIHNldCB0byBvcGVuIHRoZWlyIGxpbmtzIGluIHRoZWlyIG93biB3aW5kb3cgYnkgc2V0dGluZyB0aGUgYXBwcm9wcmlhdGUgY29sdW1uJ3Mgb3IgY2VsbCdzIGBsaW5rVGFyZ2V0YCBwcm9wZXJ0eS5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBsaW5rVGFyZ2V0OiAnX2JsYW5rJyxcblxuICAgIC8qKiBAc3VtbWFyeSBVbmRlcmxpbmUgbGluayBvbiBob3ZlciBvbmx5LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGxpbmtPbkhvdmVyOiBmYWxzZSxcblxuICAgIC8qKiBAc3VtbWFyeSBDb2xvciBmb3IgbGluay5cbiAgICAgKiBAZGVzYyBGYWxzeSBtZWFucyBkZWZlciB0byBmb3JlZ3JvdW5kIGNvbG9yLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgbGlua0NvbG9yOiAnIzMzN2FiNycsXG5cbiAgICAvKiogQHN1bW1hcnkgQ29sb3IgZm9yIHZpc2l0ZWQgbGluay5cbiAgICAgKiBAZGVzYyBGYWxzeSBtZWFucyBkZWZlciB0byBmb3JlZ3JvdW5kIGNvbG9yLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgbGlua1Zpc2l0ZWRDb2xvcjogJyMzMzdhYjcnLFxuXG4gICAgLyoqIEBzdW1tYXJ5IENvbG9yIGxpbmsgb24gaG92ZXIgb25seS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBsaW5rQ29sb3JPbkhvdmVyOiBmYWxzZSxcblxuICAgIC8qKiBEaXNwbGF5IGNlbGwgZm9udCB3aXRoIHN0cmlrZS10aHJvdWdoIGxpbmUgZHJhd24gb3ZlciBpdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBzdHJpa2VUaHJvdWdoOiBmYWxzZSxcblxuICAgIC8qKiBBbGxvdyBtdWx0aXBsZSBjZWxsIHJlZ2lvbiBzZWxlY3Rpb25zLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIG11bHRpcGxlU2VsZWN0aW9uczogdHJ1ZSxcblxuICAgIC8qKiBAc3VtbWFyeSBSZS1yZW5kZXIgZ3JpZCBhdCBtYXhpbXVtIHNwZWVkLlxuICAgICAqIEBkZXNjIEluIHRoaXMgbW9kZTpcbiAgICAgKiAqIFRoZSBcImRpcnR5XCIgZmxhZywgc2V0IGJ5IGNhbGxpbmcgYGdyaWQucmVwYWludCgpYCwgaXMgaWdub3JlZC5cbiAgICAgKiAqIGBncmlkLmdldENhbnZhcygpLmN1cnJlbnRGUFNgIGlzIGEgbWVhc3VyZSBvZiB0aGUgbnVtYmVyIHRpbWVzIHRoZSBncmlkIGlzIGJlaW5nIHJlLXJlbmRlcmVkIGVhY2ggc2Vjb25kLlxuICAgICAqICogVGhlIEh5cGVyZ3JpZCByZW5kZXJlciBnb2JibGVzIHVwIENQVSB0aW1lIGV2ZW4gd2hlbiB0aGUgZ3JpZCBhcHBlYXJzIGlkbGUgKHRoZSB2ZXJ5IHNjZW5hcmlvIGByZXBhaW50KClgIGlzIGRlc2lnbmVkIHRvIGF2b2lkKS4gRm9yIHRoaXMgcmVhc29uLCB3ZSBlbXBoYXRpY2FsbHkgYWR2aXNlIGFnYWluc3Qgc2hpcHBpbmcgYXBwbGljYXRpb25zIHVzaW5nIHRoaXMgbW9kZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBlbmFibGVDb250aW51b3VzUmVwYWludDogZmFsc2UsXG5cbiAgICAvKiogQHN1bW1hcnkgQWxsb3cgdXNlciB0byBtb3ZlIGNvbHVtbnMgLlxuICAgICAqIEBkZXNjIENvbHVtbnMgY2FuIGJlIHJlb3JkZXJlZCB0aHJvdWdoIGVpdGhlciBvZiB0d28gaW50ZXJmYWNlczpcbiAgICAgKiAqIENvbHVtbiBEcmFnZ2luZyBmZWF0dXJlXG4gICAgICogKiBiZWhhdmlvci5jb2x1bW5zIEFQSVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbHVtbnNSZW9yZGVyYWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IGtlZXAgaGVhZGVycyBhcyBpcywgb25seSBkYXRhIGNvbHVtbnMgbW92aW5nXG4gICAgICovXG4gICAgb25seURhdGFSZW9yZGVyOiB0cnVlLFxuXG4gICAgLyoqIEBzdW1tYXJ5IENvbHVtbiBncmFiIHdpdGhpbiB0aGlzIG51bWJlciBvZiBwaXhlbHMgZnJvbSB0b3Agb2YgY2VsbC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbHVtbkdyYWJNYXJnaW46IDUsXG5cbiAgICAvKiogQHN1bW1hcnkgU2V0IHVwIGEgY2xpcHBpbmcgcmVnaW9uIGFyb3VuZCBlYWNoIGNvbHVtbiBiZWZvcmUgcGFpbnRpbmcgY2VsbHMuXG4gICAgICogQGRlc2MgT25lIG9mOlxuICAgICAqICogYHRydWVgIC0gQ2xpcCBjb2x1bW4uXG4gICAgICogKiBgZmFsc2VgIC0gRG8gbm90IGNsaXAgY29sdW1uLlxuICAgICAqICogYG51bGxgIC0gQ2xpcCBpZmYgbGFzdCBhY3RpdmUgY29sdW1uLlxuICAgICAqXG4gICAgICogQ2xpcHBpbmcgcHJldmVudHMgdGV4dCB0aGF0IG92ZXJmbG93cyB0byB0aGUgcmlnaHQgb2YgdGhlIGNlbGwgZnJvbSBiZWluZyByZW5kZXJlZC5cbiAgICAgKiBJZiB5b3UgY2FuIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgeW91ciB0ZXh0IHdpbGwgb3ZlcmZsb3csIHR1cm4gY29sdW1uIGNsaXBwaW5nIG9mZlxuICAgICAqIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuIElmIG5vdCwgeW91IG1heSBzdGlsbCBiZSBhYmxlIHRvIGdldCBhd2F5IHdpdGhvdXQgY2xpcHBpbmcuXG4gICAgICogSWYgdGhlIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIG5leHQgY29sdW1uIGlzIG9wYXF1ZSwgeW91IGRvbid0IHJlYWxseSBuZWVkIHRvIGNsaXAsXG4gICAgICogYWx0aG91Z2ggdGV4dCBjYW4gbGVhayBvdXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBsYXN0IGNvbHVtbi4gQ2xpcHBpbmcgdGhlIGxhc3QgY29sdW1uXG4gICAgICogb25seSBjYW4gaGVscCB0aGlzIGJ1dCBub3Qgc29sdmUgaXQgc2luY2UgdGhlIGxlYWtlZCB0ZXh0IGZyb20gKHNheSkgdGhlIGNvbHVtbiBiZWZvcmVcbiAgICAgKiB0aGUgbGFzdCBjb2x1bW4gY291bGQgc3RyZXRjaCBhY3Jvc3MgdGhlIGVudGlyZSBsYXN0IGNvbHVtbiBhbmQgbGVhayBvdXQgYW55d2F5LlxuICAgICAqIFRoZSBzb2x1dGlvbiB0byB0aGlzIGlzIHRvIGNsaXAgdGhlIHJlbmRlcmVkIHN0cmluZyBzbyBhdCBtb3N0IG9ubHkgYSBwYXJ0aWFsIGNoYXJhY3RlclxuICAgICAqIHdpbGwgb3ZlcmZsb3cuXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbHVtbkNsaXA6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVwZWF0aW5nIHBhdHRlcm4gb2YgcHJvcGVydHkgb3ZlcnJpZGVzIGZvciBncmlkIHJvd3MuXG4gICAgICogQGRlc2MgTm90ZXM6XG4gICAgICogKiBcIkdyaWQgcm93XCIgcmVmZXJzIHRvIGRhdGEgcm93cy5cbiAgICAgKiAqIFJvdyBpbmRleCBtb2R1bG8gaXMgYXBwbGllZCB3aGVuIGRlcmVmZXJlbmNpbmcgdGhpcyBhcnJheS4gSW4gb3RoZXIgd29yZHMsIHRoaXMgYXJyYXkgcmVwcmVzZW50cyBhIF9yZXBlYXRpbmcgcGF0dGVybl8gb2YgcHJvcGVydGllcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBkYXRhIHJvd3MuXG4gICAgICogKiBGb3Igbm8gcm93IHByb3BlcnRpZXMsIHNwZWNpZnkgYSBmYWxzeSB2YWx1ZSBpbiBwbGFjZSBvZiB0aGUgYXJyYXkuXG4gICAgICogKiBEbyBub3Qgc3BlY2lmeSBhbiBlbXB0eSBhcnJheSAod2lsbCB0aHJvdyBhbiBlcnJvcikuXG4gICAgICogKiBFYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5IG1heSBiZSBlaXRoZXI6XG4gICAgICogICAqIEFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnR5IG92ZXJyaWRlcyB0byBiZSBhcHBsaWVkIHRvIGV2ZXJ5IGNlbGwgb2YgdGhlIHJvdzsgb3JcbiAgICAgKiAgICogQSBmYWxzeSB2YWx1ZSBzaWduaWZ5aW5nIHRoYXQgdGhlcmUgYXJlIG5vIHJvdyBwcm9wZXJ0aWVzIGZvciB0aGlzIHNwZWNpZmljIHJvdy5cbiAgICAgKiAqIENhdmVhdDogUm93IHByb3BlcnRpZXMgdXNlIGBPYmplY3QuYXNzaWduKClgIHRvIGNvcHkgcHJvcGVydGllcyBhbmQgdGhlcmVmb3JlIGFyZSBub3QgYXMgcGVyZm9ybWFudCBhcyBjb2x1bW4gcHJvcGVydGllcyB3aGljaCB1c2UgcHJvdG90eXBlIGNoYWluLlxuICAgICAqICogYE9iamVjdC5hc3NpZ24oKWAgaXMgYSBwb2x5ZmlsbCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgKDw0NSkgYW5kIGluIGFsbCBJbnRlcm5ldCBFeHBsb3JlciAodGhyb3VnaCAxMSkuXG4gICAgICogQHR5cGUge3VuZGVmaW5lZHxvYmplY3RbXX1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICByb3dTdHJpcGVzOiB1bmRlZmluZWQsXG5cbiAgICAvLyBmb3IgUmVuZGVyZXIucHJvdG90eXBlLmFzc2lnblByb3BzXG4gICAgcHJvcENsYXNzTGF5ZXJzOiBwcm9wQ2xhc3NMYXllcnNNYXAuREVGQVVMVCxcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gYWNjZXNzIHJlZ2lzdGVyZWQgZmVhdHVyZXMgLS0gdW5sZXNzIGJlaGF2aW9yIGhhcyBhIG5vbi1lbXB0eSBgZmVhdHVyZXNgIHByb3BlcnR5IChhcnJheSBvZiBmZWF0dXJlIGNvbnRydWN0b3JzKS5cbiAgICAgKi9cbiAgICBmZWF0dXJlczogW1xuICAgICAgICAnZmlsdGVycycsXG4gICAgICAgICdjb250ZXh0bWVudScsXG4gICAgICAgIC8vICdjb2x1bW5maXhhdGlvbicsXG4gICAgICAgIC8vICdyb3dmaXhhdGlvbicsXG4gICAgICAgICdjZWxsc2VsZWN0aW9uJyxcbiAgICAgICAgJ2tleXBhZ2luZycsXG4gICAgICAgICdjb2x1bW5yZXNpemluZycsXG4gICAgICAgIC8vICdyb3dyZXNpemluZycsXG4gICAgICAgICdyb3dzZWxlY3Rpb24nLFxuICAgICAgICAnY29sdW1uc2VsZWN0aW9uJyxcbiAgICAgICAgJ2NvbHVtbm1vdmluZycsXG4gICAgICAgICdjb2x1bW5zb3J0aW5nJyxcbiAgICAgICAgJ2NlbGxjbGljaycsXG4gICAgICAgICdjZWxsZWRpdGluZycsXG4gICAgICAgICdvbmhvdmVyJyxcbiAgICAgICAgJ2xpbmtkZXRhaWxzJyxcbiAgICAgICAgJ3dhcm5pbmd0b29sdGlwJ1xuICAgIF0sXG5cbiAgICAvKiogQHN1bW1hcnkgSG93IHRvIHRydW5jYXRlIHRleHQuXG4gICAgICogQGRlc2MgQSBcInF1YXRlcm5hcnlcIiB2YWx1ZSwgb25lIG9mOlxuICAgICAqICogYHVuZGVmaW5lZGAgLSBUZXh0IGlzIG5vdCB0cnVuY2F0ZWQuXG4gICAgICogKiBgdHJ1ZWAgKGRlZmF1bHQpIC0gVHJ1bmNhdGUgc3VmZmljaWVudCBjaGFyYWN0ZXJzIHRvIGZpdCBlbGxpcHNpcyBpZiBwb3NzaWJsZS4gTW9zdCBhY2NlcHRhYmxlIG9wdGlvbiB0aGF0IGF2b2lkcyBuZWVkIGZvciBjbGlwcGluZy5cbiAgICAgKiAqIGBmYWxzZWAgLSBUcnVuY2F0ZSAqYmVmb3JlKiBsYXN0IHBhcnRpYWxseSB2aXNpYmxlIGNoYXJhY3Rlci4gVmlzaWJseSBhbm5veWluZzsgc2VtYW50aWNhbGx5IGphcnJpbmcuXG4gICAgICogKiBgbnVsbGAgLSBUcnVuY2F0ZSAqYWZ0ZXIqIHBhcnRpYWxseSB2aXNpYmxlIGNoYXJhY3Rlci4gTGVzcyB2aXNpYmx5IGFubm95aW5nOyBzdGlsbCBzZW1hbnRpY2FsbHkgY29uZnVzaW5nLiBCZXN0IHNvbHV0aW9uIHdoZW4gY29tYmluZWQgd2l0aCBlaXRoZXIgY29sdW1uIGNsaXBwaW5nIG9yIHBhaW50aW5nIG92ZXIgd2l0aCBuZXh0IGNvbHVtbidzIGJhY2tncm91bmQuXG4gICAgICogQHR5cGUge2Jvb2xlYW58bnVsbHx1bmRlZmluZWR9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgdHJ1bmNhdGVUZXh0V2l0aEVsbGlwc2lzOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgSWYgdHJ1ZSwgY29sb3JzIHdpbGwgYmUgY29tYmluZWQgb24gcmVuZGVyLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbWJpbmVDb2xvcnM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgTGlzdCBvZiBjb250ZXh0IG1lbnUgaXRlbXMsIGp1c3QgdGl0bGUgYW5kIGNhbGxiYWNrXG4gICAgICogUGFyYW1zLCB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gZWFjaCBpdGVtIGRlY2xhcmF0aW9uOlxuICAgICAqIHRpdGxlIHwgbmFtZSAoSFRNTCBzdHJpbmcpIC0gdGl0bGUgb2YgYW4gbWVudSBpdGVtXG4gICAgICogYWN0aW9uIChmdW5jdGlvbikgLSBjYWxsYmFjayBmdW5jdGlvbiwgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbiBjbGlja1xuICAgICAqIGlzU2hvd24gKGJvb2xlYW4gfCBmdW5jdGlvbikgLSBpZiBwYXNzZWQsIGVhY2ggaXRlbSBjaGVjayB0aGlzIHBhcmFtLCBiZWZvcmUgaXQgd2lsbCBiZSByZW5kZXJlZFxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNlbGxDb250ZXh0TWVudTogW1xuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnPGI+RmlsdGVyPC9iPiB0byB2YWx1ZScsXG4gICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKGNsaWNrRXZlbnQsIGdyaWRFdmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCc8Yj5GaWx0ZXI8L2I+IHRvIHZhbHVlIHdpdGggZXZlbnQnLCBncmlkRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnPGI+RXhjbHVkZTwvYj4gdGhpcyB2YWx1ZScsXG4gICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKGNsaWNrRXZlbnQsIGdyaWRFdmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCc8Yj5FeGNsdWRlPC9iPiB0aGlzIHZhbHVlIHdpdGggZXZlbnQnLCBncmlkRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQ29weScsXG4gICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKGNsaWNrRXZlbnQsIGdyaWRFdmVudCkge1xuICAgICAgICAgICAgICAgIGdyaWRFdmVudC5ncmlkLmFwaS5jb3B5U2VsZWN0ZWRSYW5nZVRvQ2xpcGJvYXJkKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0NvcHkgV2l0aCBIZWFkZXJzJyxcbiAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oY2xpY2tFdmVudCwgZ3JpZEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZ3JpZEV2ZW50LmdyaWQuYXBpLmNvcHlTZWxlY3RlZFJhbmdlVG9DbGlwYm9hcmQodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgTGlzdCBvZiBoZWFkZXIgcm93IGNvbnRleHQgbWVudSBpdGVtcywganVzdCB0aXRsZSBhbmQgY2FsbGJhY2tcbiAgICAgKiBQYXJhbXMsIHRoYXQgY2FuIGJlIHBhc3NlZCB0byBlYWNoIGl0ZW0gZGVjbGFyYXRpb246XG4gICAgICogdGl0bGUgfCBuYW1lIChIVE1MIHN0cmluZykgLSB0aXRsZSBvZiBhbiBtZW51IGl0ZW1cbiAgICAgKiBhY3Rpb24gKGZ1bmN0aW9uKSAtIGNhbGxiYWNrIGZ1bmN0aW9uLCB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uIGNsaWNrXG4gICAgICogaXNTaG93biAoYm9vbGVhbiB8IGZ1bmN0aW9uKSAtIGlmIHBhc3NlZCwgZWFjaCBpdGVtIGNoZWNrIHRoaXMgcGFyYW0sIGJlZm9yZSBpdCB3aWxsIGJlIHJlbmRlcmVkXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgaGVhZGVyQ29udGV4dE1lbnU6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1JlbmFtZScsXG4gICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKGNsaWNrRXZlbnQsIGNlbGxFdmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZW5hbWUgc2VsZWN0ZWQnLCBjbGlja0V2ZW50LCBjZWxsRXZlbnQpO1xuICAgICAgICAgICAgICAgIGNlbGxFdmVudC5ncmlkLm9uRWRpdG9yQWN0aXZhdGUoY2VsbEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1JlbW92ZScsXG4gICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKGNsaWNrRXZlbnQsIGNlbGxFdmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZW1vdmUgc2VsZWN0ZWQnLCBjbGlja0V2ZW50LCBjZWxsRXZlbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyaWQgPSBjZWxsRXZlbnQuZ3JpZDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xEZWYgPSBncmlkLmNvbHVtbkRlZnM7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sdW1uID0gY2VsbEV2ZW50LmNvbHVtbjtcblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBpZiBpdCBpc24ndCByZW1vdmVkIGluICdvblJlbW92ZUNvbHVtbicgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBncmlkLmdldENvbERlZnMoY29sdW1uLm5hbWUpLmZvckVhY2goc2luZ2xlQ29sRGVmID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29sRGVmLnNwbGljZShjb2xEZWYuaW5kZXhPZihzaW5nbGVDb2xEZWYpLCAxKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGdyaWQuYXBpLnNldENvbHVtbkRlZnMoY29sRGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBpZiB0cnVlLCBkYXRhIGNlbGwgY29udGV4dCBtZW51IGNhbiBiZSB0cmlnZ2VyZWQuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgc2hvd0NlbGxDb250ZXh0TWVudTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIGlmIHRydWUsIGNvbnRleHQgbWVudSB3aWxsIGJlIHN0eWxlZCB1c2VkIG5leHQgcGFyYW1zIChjb250ZXh0TWVudUhvbGRlclN0eWxlLCBjb250ZXh0TWVudUxpc3RTdHlsZSxcbiAgICAgKiBjb250ZXh0TWVudUxpc3RPcHRpb25TdHlsZSwgY29udGV4dE1lbnVMaXN0T3B0aW9uSG92ZXJTdHlsZSwgY29udGV4dE1lbnVMaXN0T3B0aW9uSWNvblN0eWxlLFxuICAgICAqIGNvbnRleHRNZW51TGlzdE9wdGlvblRleHRTdHlsZSwgY29udGV4dE1lbnVMaXN0T3B0aW9uU2hvcnRjdXRTdHlsZSwgY29udGV4dE1lbnVMaXN0T3B0aW9uUG9wdXBQb2ludGVyU3R5bGUpXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgYXBwbHlDb250ZXh0TWVudVN0eWxpbmc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBzdHlsZSBvYmplY3QgZm9yIGRpdiwgdGhhdCByZW5kZXJzIHdoZW4gY29udGV4dE1lbnUgY2FsbGVkLiBUaGlzIGRpdiBjb250YWlucyBjb250ZXh0TWVudUxpc3QgYXMgYSBjaGlsZFxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY29udGV4dE1lbnVIb2xkZXJTdHlsZToge1xuICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICAgIGZvbnRTaXplOiAnMTRweCcsXG4gICAgICAgIHpJbmRleDogMixcbiAgICAgICAgbWFyZ2luOiAnMCAwIDAgMCcsXG4gICAgICAgIGZvbnRGYW1pbHk6ICdcIkhlbHZldGljYSBOZXVlXCIsSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWYnLFxuICAgICAgICB3aWR0aDogJ2F1dG8nLFxuICAgICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgICAgJ3doaXRlLXNwYWNlJzogJ25vd3JhcCcsXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHN0eWxlIG9iamVjdCBmb3IgZGl2LCB0aGF0IHJlcHJlc2VudHMgbGlzdCBvZiBhbiBjb250ZXh0IG1lbnUgaXRlbXNcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbnRleHRNZW51TGlzdFN0eWxlOiB7XG4gICAgICAgIHBhZGRpbmc6ICc1cHggMCcsXG4gICAgICAgIG1heEhlaWdodDogJzI5MHB4JyxcbiAgICAgICAgbWluV2lkdGg6ICcyMjBweCcsXG4gICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICNjY2MnLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZmZmJyxcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgbWFyZ2luVG9wOiAnLTFweCcsXG4gICAgICAgIGJvcmRlckNvbGxhcHNlOiAnY29sbGFwc2UnLFxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBzdHlsZSBvYmplY3QgZm9yIGRpdiwgdGhhdCByZXByZXNlbnRzIHNpbmdsZSBsaXN0IGl0ZW0gb2YgY29udGV4dCBtZW51XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb250ZXh0TWVudUxpc3RPcHRpb25TdHlsZToge1xuICAgICAgICBoZWlnaHQ6ICcyN3B4JyxcbiAgICAgICAgZm9udFNpemU6ICcxM3B4JyxcbiAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNmZmYnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHN0eWxlIG9iamVjdCBmb3IgbWVudSBsaXN0IGl0ZW0gZGl2LCB3aGVuIGluIGhvdmVyZWQgc3RhdGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbnRleHRNZW51TGlzdE9wdGlvbkhvdmVyU3R5bGU6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2VlZSdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2Mgc3R5bGUgb2JqZWN0IGZvciBwYXJ0IG9mIG1lbnUgbGlzdCBpdGVtLCB0aGF0IGNvbnRhaW5zIGFuIGljb25cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbnRleHRNZW51TGlzdE9wdGlvbkljb25TdHlsZToge1xuICAgICAgICB3aWR0aDogJzMwcHgnLFxuICAgICAgICBwYWRkaW5nOiAnMnB4IDRweCcsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHN0eWxlIG9iamVjdCBmb3IgcGFydCBvZiBtZW51IGxpc3QgaXRlbSwgdGhhdCBjb250YWlucyBtYWluIHRleHRcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbnRleHRNZW51TGlzdE9wdGlvblRleHRTdHlsZToge1xuICAgICAgICBwYWRkaW5nOiAnMnB4IDRweCcsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgICBmbGV4R3JvdzogJzEnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHN0eWxlIG9iamVjdCBmb3IgcGFydCBvZiBtZW51IGxpc3QgaXRlbSwgdGhhdCBjb250YWlucyBhbiBzaG9ydGN1dFxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY29udGV4dE1lbnVMaXN0T3B0aW9uU2hvcnRjdXRTdHlsZToge1xuICAgICAgICBwYWRkaW5nOiAnMnB4IDJweCAycHggMjBweCcsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgICBXaWR0aDogJzAnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHN0eWxlIG9iamVjdCBmb3IgcGFydCBvZiBtZW51IGxpc3QgaXRlbSwgdGhhdCBjb250YWlucyBhbiBwb3B1cCBwb2ludGVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb250ZXh0TWVudUxpc3RPcHRpb25Qb3B1cFBvaW50ZXJTdHlsZToge1xuICAgICAgICBwYWRkaW5nOiAnMnB4IDRweCcsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgICB3aWR0aDogJzMwcHgnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHN0eWxlIG9iamVjdCBob3Jpem9udGFsIGxpbmUgKHNlcGFyYXRvcikgdGhhdCB1c2VkIHRvIHNlcGFyYXRlIG9uZSBpdGVtcyBncm91cCBmcm9tIGFub3RoZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbnRleHRNZW51U2VwYXJhdG9yU3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgYm9yZGVyVG9wOiAnMXB4IHNvbGlkICNFNUU1RTUnLFxuICAgICAgICBtYXJnaW46ICc1cHggMCdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgaHRtbCBzdHJpbmcsIHRoYXQgd2lsbCBiZSBkaXNwbGF5ZWQsIGlmIG1lbnUgaXRlbSBoYXMgY2hpbGQgbWVudS5cbiAgICAgKiBQcm9wZXJ0eSBjb250YWluIHdob2xlIGh0bWwgdGFnIChub3QganVzdCBjbGFzcykgYmVjYXVzZSBjb21lIGljb25wYWNrcyBtYXkgdXNlIFwic3BhblwiKG9yIGFueSBhbm90aGVyKVxuICAgICAqIHRhZyBpbnN0ZWFkIG9mIFwiaVwiXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb250ZXh0TWVudUNoaWxkTWVudUFycm93SWNvblRhZzogJzxpIGNsYXNzPVwiZmEgZmEtY2FyZXQtcmlnaHRcIj48L2k+JyxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIGhlYWRlciBwYXJ0IGNvbG9yIG9mIGFuIGNvbHVtbiBmaXhhdGlvbiBkcmFnZ2VyLCB3aGVuIGRyYWdnZXIgc3RhdGUgaXMgaW5hY3RpdmVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY29sdW1uRml4YXRpb25EcmFnZ2VySGVhZGVySW5hY3RpdmVDb2xvcjogJyNCQ0JDQkMnLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgaGVhZGVyIHBhcnQgY29sb3Igb2YgYW4gY29sdW1uIGZpeGF0aW9uIGRyYWdnZXIsIHdoZW4gZHJhZ2dlciBzdGF0ZSBpcyBob3ZlcmVkXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbHVtbkZpeGF0aW9uRHJhZ2dlckhlYWRlckhvdmVyZWRDb2xvcjogJyNBNUM2RkUnLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgaGVhZGVyIHBhcnQgY29sb3Igb2YgYW4gY29sdW1uIGZpeGF0aW9uIGRyYWdnZXIsIHdoZW4gZHJhZ2dlciBzdGF0ZSBpcyBkcmFnZ2luZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb2x1bW5GaXhhdGlvbkRyYWdnZXJIZWFkZXJEcmFnZ2luZ0NvbG9yOiAnI0E1QzZGRScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBib2R5IHBhcnQgY29sb3Igb2YgYW4gY29sdW1uIGZpeGF0aW9uIGRyYWdnZXIsIHdoZW4gZHJhZ2dlciBzdGF0ZSBpcyBkcmFnZ2luZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb2x1bW5GaXhhdGlvbkRyYWdnZXJCb2R5RHJhZ2dpbmdDb2xvcjogJyNEQkU1RjcnLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgaGVhZGVyIHBhcnQgY29sb3Igb2YgYW4gY29sdW1uIGZpeGF0aW9uIHBsYWNlaG9sZGVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbHVtbkZpeGF0aW9uUGxhY2Vob2xkZXJIZWFkZXJDb2xvcjogJyM2NTlERkMnLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgYm9keSBwYXJ0IGNvbG9yIG9mIGFuIGNvbHVtbiBmaXhhdGlvbiBwbGFjZWhvbGRlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb2x1bW5GaXhhdGlvblBsYWNlaG9sZGVyQm9keUNvbG9yOiAnI0FGQkJEMScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBoZWFkZXIgcGFydCBjb2xvciBvZiBhbiByb3cgZml4YXRpb24gZHJhZ2dlciwgd2hlbiBkcmFnZ2VyIHN0YXRlIGlzIGluYWN0aXZlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHJvd0ZpeGF0aW9uRHJhZ2dlckhlYWRlckluYWN0aXZlQ29sb3I6ICcjQkNCQ0JDJyxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIGhlYWRlciBwYXJ0IGNvbG9yIG9mIGFuIHJvdyBmaXhhdGlvbiBkcmFnZ2VyLCB3aGVuIGRyYWdnZXIgc3RhdGUgaXMgaG92ZXJlZFxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICByb3dGaXhhdGlvbkRyYWdnZXJIZWFkZXJIb3ZlcmVkQ29sb3I6ICcjQTVDNkZFJyxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIGhlYWRlciBwYXJ0IGNvbG9yIG9mIGFuIHJvdyBmaXhhdGlvbiBkcmFnZ2VyLCB3aGVuIGRyYWdnZXIgc3RhdGUgaXMgZHJhZ2dpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgcm93Rml4YXRpb25EcmFnZ2VySGVhZGVyRHJhZ2dpbmdDb2xvcjogJyNBNUM2RkUnLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgYm9keSBwYXJ0IGNvbG9yIG9mIGFuIHJvdyBmaXhhdGlvbiBkcmFnZ2VyLCB3aGVuIGRyYWdnZXIgc3RhdGUgaXMgZHJhZ2dpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgcm93Rml4YXRpb25EcmFnZ2VyQm9keURyYWdnaW5nQ29sb3I6ICcjREJFNUY3JyxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIGhlYWRlciBwYXJ0IGNvbG9yIG9mIGFuIHJvdyBmaXhhdGlvbiBwbGFjZWhvbGRlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICByb3dGaXhhdGlvblBsYWNlaG9sZGVySGVhZGVyQ29sb3I6ICcjNjU5REZDJyxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIGJvZHkgcGFydCBjb2xvciBvZiBhbiByb3cgZml4YXRpb24gcGxhY2Vob2xkZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgcm93Rml4YXRpb25QbGFjZWhvbGRlckJvZHlDb2xvcjogJyNBRkJCRDEnLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2Mgc3R5bGUgb2JqZWN0IG9mIGFuIHZlcnRpY2FsIHNjcm9sbGJhciBiYXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHNjcm9sbGJhclZTdHlsZToge1xuICAgICAgICB3aWR0aDogMTMsXG4gICAgICAgIGJhY2tncm91bmQ6ICcjRjhGOEY4JyxcbiAgICAgICAgYm94U2hhZG93OiAnMCAwIDAgIzAwMCwgMCAwIDAgIzAwMCwgMCAwIDAgIzAwMCcsXG4gICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgbWFyZ2luQm90dG9tOiAwLFxuICAgICAgICBtYXJnaW5SaWdodDogLTEsXG4gICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgYm9yZGVyU3R5bGU6ICdzb2xpZCcsXG4gICAgICAgIGJvcmRlckNvbG9yOiAnI2Q5ZDlkOScsXG4gICAgICAgIGJvcmRlcldpZHRoOiAnMXB4J1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBzdHlsZSBvYmplY3Qgb2YgYW4gaG9yaXpvbnRhbCBzY3JvbGxiYXIgYmFyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBzY3JvbGxiYXJIU3R5bGU6IHtcbiAgICAgICAgaGVpZ2h0OiAxMyxcbiAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICNkOWQ5ZDknLFxuICAgICAgICBiYWNrZ3JvdW5kOiAnI0Y4RjhGOCcsXG4gICAgICAgIGJveFNoYWRvdzogJzAgMCAwICMwMDAsIDAgMCAwICMwMDAsIDAgMCAwICMwMDAnLFxuICAgICAgICBtYXJnaW5MZWZ0OiAwLFxuICAgICAgICBtYXJnaW5SaWdodDogMCxcbiAgICAgICAgbWFyZ2luQm90dG9tOiAtMSxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAwXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHN0eWxlIG9iamVjdCBvZiBhbiB2ZXJ0aWNhbCBzY3JvbGxiYXIgdGh1bWJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHNjcm9sbGJhclZUaHVtYlN0eWxlOiB7XG4gICAgICAgIG1hcmdpbjogMSxcbiAgICAgICAgd2lkdGg6IDksXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjQzdDN0M3JyxcbiAgICAgICAgYm94U2hhZG93OiAnMHB4IDBweCAwcHggaW5zZXQnLFxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAwXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHN0eWxlIG9iamVjdCBvZiBhbiBob3Jpem9udGFsIHNjcm9sbGJhciB0aHVtYlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgc2Nyb2xsYmFySFRodW1iU3R5bGU6IHtcbiAgICAgICAgbWFyZ2luOiAxLFxuICAgICAgICBoZWlnaHQ6IDksXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI0M3QzdDNycsXG4gICAgICAgIGJveFNoYWRvdzogJzBweCAwcHggMHB4IGluc2V0JyxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAwXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHN0eWxlIG9iamVjdCBvZiBhbiBob3Jpem9udGFsIHNjcm9sbGJhciB1bmRlcmx5aW5nIGRpdlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgc2Nyb2xsYmFySE1vdW50U3R5bGU6IHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIGJhY2tncm91bmQ6ICcjRjhGOEY4JyxcbiAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICNEOUQ5RDknXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHN0eWxlIG9iamVjdCBvZiBhbiB2ZXJ0aWNhbCBzY3JvbGxiYXIgdW5kZXJseWluZyBkaXZcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHNjcm9sbGJhclZNb3VudFN0eWxlOiB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBiYWNrZ3JvdW5kOiAnI0Y4RjhGOCcsXG4gICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjRDlEOUQ5JyxcbiAgICAgICAgYm9yZGVyVG9wV2lkdGg6ICcwJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBzdHlsZSBvYmplY3Qgb2YgYW4gZGl2LCB0aGF0IGNvbnRhaW5zIGxpbmsgaW5mb1xuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgbGlua0RldGFpbHNTdHlsZToge1xuICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICBmbGV4RmxvdzogJ2NvbHVtbicsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBiYWNrZ3JvdW5kOiAnI2ZjZmNmYycsXG4gICAgICAgIGJveFNoYWRvdzogJzAgMCAycHggMCByZ2JhKDAsMCwwLC4xNSksIDAgMXB4IDJweCAwIHJnYmEoMCwwLDAsLjQpJyxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAnMXB4JyxcbiAgICAgICAgcGFkZGluZzogJzVweCA3cHgnLFxuICAgICAgICB6SW5kZXg6IDEwMzAsXG4gICAgICAgIGZvbnRTaXplOiAnMTNweCcsXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiAnbm9uZScsXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHN0eWxlIG9iamVjdCBvZiBhbiBkaXYsIHRoYXQgY29udGFpbnMgbGluayBpbmZvLCB3aGVuIG1vdXNlIG1vdmVkIG92ZXIgaXRcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGxpbmtEZXRhaWxzSG92ZXJlZFN0eWxlOiB7XG4gICAgICAgIGJveFNoYWRvdzogJzAgMCAycHggMCByZ2JhKDAsMCwwLC4xNSksIDAgMnB4IDJweCAwIHJnYmEoMCwwLDAsLjQpJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBNYXhpbXVtIGxlbmd0aCBvZiBsaW5rLCB0aGF0IHdpbGwgYmUgZGlzcGxheWVkIG9uIGxpbmsgZGV0YWlscyBwb3BvdmVyLlxuICAgICAqIElmIGxlbmd0aCBvZiBzdHJpbmcgZ3JlYXRlciB0aGFuIHRoaXMgdmFsdWUsIHZhbHVlIHdpbGwgYmUgdHJ1bmNhdGVkXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBsaW5rRGV0YWlsc01heFN0cmluZ0xlbmd0aDogMzAsXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBMaW5rIGRldGFpbHMgaGlkZSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgbGlua0RldGFpbHNIaWRlVGltZW91dDogMTAwMCxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHN0eWxlIG9iamVjdCBvZiBhbiBsaW5rIGluZm8gYW5jaG9yIHRhZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgbGlua0RldGFpbHNBbmNob3JTdHlsZToge1xuICAgICAgICBjb2xvcjogJyMzMzdhYjcnLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogJ25vbmUnLFxuICAgICAgICBsaW5lSGVpZ2h0OiAnMTlweCcsXG4gICAgICAgIGZvbnRGYW1pbHk6ICdBcmlhbCxzYW5zLXNlcmlmJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBwaXhlbHMgY291bnQgdGhhdCB3aWxsIGJlIHVzZWQgYXMgY2FudmFzIHJpZ2h0IHBhZGRpbmcgb24gcmVuZGVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjYW52YXNXaWR0aE9mZnNldDogMTQsXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBwaXhlbHMgY291bnQgdGhhdCB3aWxsIGJlIHVzZWQgYXMgY2FudmFzIGJvdHRvbSBwYWRkaW5nIG9uIHJlbmRlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY2FudmFzSGVpZ2h0T2Zmc2V0OiAxMyxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIGlmIHRydWUsIGNvbnRleHQgbWVudSBpY29uIHdpbGwgYmUgc2hvd24gb24gZXZlcnkgdGFibGUgY2VsbFxuICAgICAqIEJlc3QgdXNlIG9mIHRoaXMgcGFyYW1ldGVyIGlzIHNldCBpdCBvbiBjb2x1bW4gb3Igcm93XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgc2hvd0NlbGxDb250ZXh0TWVudUljb246IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgZm9udCBvZiBjb250ZXh0IG1lbnUgaWNvblxuICAgICAqIEJlc3QgdXNlIG9mIHRoaXMgcGFyYW1ldGVyIGlzIHNldCBmb250IGZhbWlseSBvbiBvbmUgb2YgY29ubmVjdGVkIGljb24tcGFjaydzLCB0byByZW5kZXIgbmVlZGVkIGljb25cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbnRleHRNZW51SWNvbkZvbnQ6ICdub3JtYWwgbm9ybWFsIGxpZ2h0ZXIgMTRweCBmb250QXdlc29tZScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBpZiB0cnVlLCBjb250ZXh0IG1lbnUgaWNvbiBzdHlsZSB3aWxsIGJlIHNldCB0byBob3ZlcmVkXG4gICAgICogKFV0aWxpdHkgcHJvcC4gWW91IGRvbid0IG5lZWQgdG8gc2V0IHRoaXMgcGFyYW0gaW4gbW9zdCBjYXNlcylcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb250ZXh0TWVudUljb25Jc0hvdmVyZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgQ29sb3Igb2YgY29udGV4dCBtZW51IGljb24sIHdoZW4gbm90IGhvdmVyZWRcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbnRleHRNZW51SWNvbkNvbG9yOiAnIzYxNjE2MScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBDb2xvciBvZiBjb250ZXh0IG1lbnUgaWNvbiwgd2hlbiBob3ZlcmVkXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb250ZXh0TWVudUljb25Ib3ZlcmVkQ29sb3I6ICcjNjE2MTYxJyxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIENvbG9yIG9mIGNvbnRleHQgbWVudSBidXR0b24gYm9yZGVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb250ZXh0TWVudUJ1dHRvblN0cm9rZVN0eWxlOiAnI0M2QzZDNicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBDb2xvciBvZiBjb250ZXh0IG1lbnUgYnV0dG9uIGJhY2tncm91bmQgY29sb3JcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbnRleHRNZW51QnV0dG9uRmlsbFN0eWxlOiAnI0Y4RjhGOCcsXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBDb2xvciBvZiBjb250ZXh0IG1lbnUgYnV0dG9uIGJhY2tncm91bmQgY29sb3Igd2hlbiBob3ZlcmVkXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb250ZXh0TWVudUJ1dHRvbkhvdmVyZWRGaWxsU3R5bGU6ICcjZjBmMGYwJyxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIFN0cmluZywgdGhhdCB3aWxsIGJlIGRpc3BsYXllZCBhcyBjb250ZXh0IG1lbnUgaWNvblxuICAgICAqIEJlc3Qgd2F5IHRvIHVzZSB0aGlzIHBhcmFtZXRlciBpcyBzZXQgaXQncyB2YWx1ZSBvbiBzdWNoIHVuaWNvZGUgY2hhciwgcHJvdmlkZWQgYnkgeW91ciBpY29ucyBwYWNrXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb250ZXh0TWVudUljb25Vbmljb2RlQ2hhcjogZGVjb2RlVVJJKCdcXHVmMGQ3JyksXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBTdHJpbmcsIHRoYXQgd2lsbCBiZSBkaXNwbGF5ZWQgYXMgZXJyb3IgaWNvblxuICAgICAqIEJlc3Qgd2F5IHRvIHVzZSB0aGlzIHBhcmFtZXRlciBpcyBzZXQgaXQncyB2YWx1ZSBvbiBzdWNoIHVuaWNvZGUgY2hhciwgcHJvdmlkZWQgYnkgeW91ciBpY29ucyBwYWNrXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBlcnJvckljb25Vbmljb2RlQ2hhcjogZGVjb2RlVVJJKCdcXHVmMDcxJyksXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBoZWlnaHQgb2YgaWNvbiwgdGhhdCByZXByZXNlbnRzIHRvdGFsIG51bWJlciBvZiBlcnJvcnNcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHRvdGFsRXJyb3JzQ291bnRJY29uSGVpZ2h0OiAxNixcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHdpZHRoIG9mIGljb24sIHRoYXQgcmVwcmVzZW50cyB0b3RhbCBudW1iZXIgb2YgZXJyb3JzXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICB0b3RhbEVycm9yc0NvdW50SWNvbldpZHRoOiAxOCxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIGZvbnQgb2YgZXJyb3IgaWNvblxuICAgICAqIEJlc3QgdXNlIG9mIHRoaXMgcGFyYW1ldGVyIGlzIHNldCBmb250IGZhbWlseSBvbiBvbmUgb2YgY29ubmVjdGVkIGljb24tcGFjaydzLCB0byByZW5kZXIgbmVlZGVkIGljb25cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGVycm9ySWNvbkZvbnQ6ICcxM3B4IGZvbnRBd2Vzb21lJyxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIGNvbG9yIG9mIGVycm9yIGljb25cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGVycm9ySWNvbkNvbG9yOiAnI0ZGM0QzRCcsXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBQcmVmZXJlZCB3aWR0aCBvZiBidXR0b25cbiAgICAgKiAoVXRpbGl0eSBwcm9wLiBZb3UgZG9uJ3QgbmVlZCB0byBzZXQgdGhpcyBwYXJhbSBpbiBtb3N0IGNhc2VzLiBVc2VkIGluIGNvbnRleHQgbWVudSBmZWF0dXJlKVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY29udGV4dE1lbnVCdXR0b25JY29uUHJlZmVyZWRXaWR0aDogOCxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHNwYWNlIGJldHdlZW4gY2VsbCByaWdodCBib3JkZXIgYW5kIGJ1dHRvblxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY29udGV4dE1lbnVCdXR0b25SaWdodE1hcmdpbjogNSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIGNvbnRleHQgbWVudSBidXR0b24gaGVpZ2h0XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb250ZXh0TWVudUJ1dHRvbkhlaWdodDogMTIsXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBzcGFjZSBiZXR3ZWVuIGNvbnRleHQgbWVudSBidXR0b24gY29udGVudCBhbmQgYm9yZGVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb250ZXh0TWVudUJ1dHRvblBhZGRpbmc6IDMsXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBTcGFjZSBmcm9tIGNvbnRleHQgbWVudSBpY29uIHRvIG1haW4gdGV4dCBvZiBjZWxsXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb250ZXh0TWVudUxlZnRTcGFjZVRvQ3V0VGV4dDogNSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIEZvbnQgb2YgY29sdW1uIHR5cGUgc2lnblxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY29sdW1uVHlwZVNpZ25Gb250OiAnOTAwIDEwcHggXCJIZWx2ZXRpY2EgTmV1ZVwiLEhlbHZldGljYSxBcmlhbCxzYW5zLXNlcmlmJyxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIENvbG9yIG9mIGNvbHVtbiB0eXBlIHNpZ25cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbHVtblR5cGVTaWduQ29sb3I6ICcjMzQzNDM0JyxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIEZvbnQgb2YgY29sdW1uIHRpdGxlIHByZWZpeFxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY29sdW1uVGl0bGVQcmVmaXhGb250OiAnODAwIDEycHggXCJIZWx2ZXRpY2EgTmV1ZVwiLEhlbHZldGljYSxBcmlhbCxzYW5zLXNlcmlmJyxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIENvbG9yIG9mIGNvbHVtbiB0aXRsZSBwcmVmaXhcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbHVtblRpdGxlUHJlZml4Q29sb3I6ICcjODE4MTgxJyxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIFNwYWNlIGZyb20gY29udGV4dCBtZW51IGljb24gdG8gbWFpbiB0ZXh0IG9mIGNlbGxcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbHVtblRpdGxlUHJlZml4UmlnaHRTcGFjZTogNSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIEZvbnQgb2YgdGV4dCAodG90YWwgbnVtYmVyIG9mIGVycm9ycyksIHRoYXQgcmVuZGVyZWQgaW5zaWRlIHdhcm5pbmcgaWNvblxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY29sdW1uV2FybmluZ0ZvbnQ6ICcxMDAwIDlweCBcIkhlbHZldGljYSBOZXVlXCIsSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWYnLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgY29sb3Igb2YgZXJyb3IgaWNvblxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY29sdW1uV2FybmluZ0ZvbnRDb2xvcjogJ3doaXRlJyxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIGNvbG9yIG9mIHRvdGFsIGVycm9ycyBpY29uXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb2x1bW5XYXJuaW5nSWNvbkNvbG9yOiAnI0ZGM0QzRCcsXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBjbGFzc2VzIG9mIHRvb2x0aXAgY29udGFpbmVyIHdoZW4gcGxhY2VkIGF0IGJvdHRvbVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgd2FybmluZ1Rvb2x0aXBCb3R0b21DbGFzczogJ3Rvb2x0aXAgYm90dG9tIG5nLWFuaW1hdGUgaW4tYWRkIGZhZGUgaW4gbWFpbi1wYWdlLXRvb2x0aXAnLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgY2xhc3NlcyBvZiB0b29sdGlwIGNvbnRhaW5lciB3aGVuIHBsYWNlZCBhdCByaWdodFxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgd2FybmluZ1Rvb2x0aXBSaWdodENsYXNzOiAndG9vbHRpcCByaWdodCBuZy1hbmltYXRlIGluLWFkZCBmYWRlIGluIG1haW4tcGFnZS10b29sdGlwJyxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIGNsYXNzZXMgb2YgdG9vbHRpcC1hcnJvd1xuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgd2FybmluZ1Rvb2x0aXBBcnJvd0NsYXNzOiAndG9vbHRpcC1hcnJvdycsXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBjbGFzc2VzIG9mIHRvb2x0aXAtaW5uZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHdhcm5pbmdUb29sdGlwSW5uZXJDbGFzczogJ3Rvb2x0aXAtaW5uZXInLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgdG9vbHRpcCBvcGFjaXR5IHdoZW4gdmlzaWJsZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgd2FybmluZ1Rvb2x0aXBPcGFjaXR5OiAwLjgsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbHVtbk1vdmVJbnNlcnRMaW5lQ29sb3I6ICcjNzc3Nzc3JyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY29sdW1uTW92ZUluc2VydExpbmVXaWR0aDogMixcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIENvbG9yIG9mIG51bWJlciwgdGhhdCBkaXNwbGF5cyB0b3RhbCBjb3VudCBvZiBlYWNoIGdyb3VwIHdoaWxlIGFnZ3JlZ2F0ZWRcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNlbGxWYWx1ZVBvc3RmaXhDb2xvcjogJyM4RjhGOEYnLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgRm9udCBvZiBhZ2dyZWdhdGlvbiB0b3RhbCBudW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNlbGxWYWx1ZVBvc3RmaXhGb250OiAnMTNweCBcIkhlbHZldGljYSBOZXVlXCIsSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWYnLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgU3BhY2UgYmV0d2VlbiBtYWluIGNlbGwgY29udGVudCBhbmQgcG9zdGZpeFxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY2VsbFZhbHVlUG9zdGZpeExlZnRPZmZzZXQ6IDUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBmb250IG9mIGFnZ3JlZ2F0aW9uIGdyb3VwIGV4cGFuZCBpY29uXG4gICAgICogQmVzdCB1c2Ugb2YgdGhpcyBwYXJhbWV0ZXIgaXMgc2V0IGZvbnQgZmFtaWx5IG9uIG9uZSBvZiBjb25uZWN0ZWQgaWNvbi1wYWNrJ3MsIHRvIHJlbmRlciBuZWVkZWQgaWNvblxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgYWdncmVnYXRpb25Hcm91cEV4cGFuZEljb25Gb250OiAnbm9ybWFsIG5vcm1hbCBsaWdodGVyIDE0cHggZm9udEF3ZXNvbWUnLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgY29sb3Igb2YgYWdncmVnYXRlZCByb3cgZXhwYW5kIGljb25cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGFnZ3JlZ2F0aW9uR3JvdXBFeHBhbmRJY29uQ29sb3I6ICcjOUY5RjlGJyxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIGljb24gKG9yIHRleHQobm90IHJlY29tZW5kZWQpKSB0aGF0IHdpbGwgYmUgZGlzcGxheWVkIGFzIGV4cGFuZCBhY3Rpb24gdHJpZ2dlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgYWdncmVnYXRpb25Hcm91cEV4cGFuZEljb25FeHBhbmRlZENoYXI6IGRlY29kZVVSSSgnXFx1ZjE5NicpLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgaWNvbiAob3IgdGV4dChub3QgcmVjb21lbmRlZCkpIHRoYXQgd2lsbCBiZSBkaXNwbGF5ZWQgYXMgY29sbGFwc2UgYWN0aW9uIHRyaWdnZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGFnZ3JlZ2F0aW9uR3JvdXBFeHBhbmRJY29uQ29sbGFwc2VkQ2hhcjogZGVjb2RlVVJJKCdcXHVmMTQ3JyksXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBhZGRpdGlvbmFsIGxlZnQgb2Zmc2V0IG9mIGVhY2ggdHJlZSBsZXZlbC5cbiAgICAgKiBPdGhlciB3b3JkcywgZXZlcnkgY2hpbGQgcm93IHdpbGwgYmUgZGlzcGxheWVkIHdpdGggYWRkaXRpb25hbCBvZmZzZXRcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGFnZ3JlZ2F0aW9uR3JvdXBUcmVlTGV2ZWxPZmZzZXQ6IDE3LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2Mgd2lkdGggb2YgY2xpY2thYmxlIGFyZWEsIHRoYXQgc3RhcnRzIG9uIGdyb3VwIGV4cGFuZCBpY29uIHN0YXJ0XG4gICAgICogVXRpbGl0eSBwYXJhbS4gVXNlZCB0byBwZXJmb3JtIGNsaWNrcyBvbiBpY29uXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBhZ2dyZWdhdGlvbkdyb3VwRXhwYW5kSWNvbkNsaWNrYWJsZVdpZHRoOiAxNSxcblxuICAgIC8qKlxuICAgICAqIGZvbnQgb2YgYWdncmVnYXRpb24gZ3JhbmQgdG90YWxcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NGb250fVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBncmFuZEFnZ3JlZ2F0aW9uQ2VsbEZvbnQ6ICdib2xkIDEzcHggXCJIZWx2ZXRpY2EgTmV1ZVwiLEhlbHZldGljYSxBcmlhbCxzYW5zLXNlcmlmJyxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHZhbHVlcyBwcmVmaXhlcyB3aWxsIG5vdCBiZSByZW5kZXJlZCBldmVuIGlmIGV4aXN0XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgaWdub3JlVmFsdWVQcmVmaXg6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdmFsdWVzIHBvc3RmaXhlcyB3aWxsIG5vdCBiZSByZW5kZXJlZCBldmVuIGlmIGV4aXN0XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgaWdub3JlVmFsdWVQb3N0Zml4OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IHBsYWNlaG9sZGVyIGZvciBkcmF3aW5nIG51bGwgdmFsdWVzXG4gICAgICovXG4gICAgbnVsbENlbGxQbGFjZWhvbGRlcjogJ8OYJyxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IGNvbG9yIG9mIHBsYWNlaG9sZGVyIGZvciBudWxsIHZhbHVlc1xuICAgICAqL1xuICAgIG51bGxDZWxsQ29sb3I6ICcjZDRkNGQ0JyxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IHRhZyBpbiB3aGljaCB3cmFwcGVkIHRleHQgd2hpY2ggbmVlZGVkIHRvIGhpZ2hsaWdodCwgZm9yIGluc3RhbmNlLCBzZWFyY2ggcmVzdWx0XG4gICAgICovXG4gICAgaGlnaExpZ2h0VGV4dDogJycsXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBjb2xvciBmb3IgaGlnaGxpZ2h0IHRleHQsIGZvciBpbnN0YW5jZSwgc2VhcmNoIHJlc3VsdFxuICAgICAqL1xuICAgIGhpZ2hsaWdodENvbG9yOiAnI0Y3RkZCQScsXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSB2YWx1ZSBmb3IgbWFuYWdpbmcgYmVoYXZpb3VyIHdpdGggYWdncmVnYXRlZCBkYXRhXG4gICAgICovXG4gICAgaXNQaXZvdDogZmFsc2UsXG59O1xuXG5cbnZhciB3YXJuZWQgPSB7fTtcblxuZnVuY3Rpb24gcm93UHJvcGVydGllc0RlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgICBpZiAoIXdhcm5lZC5yb3dQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHdhcm5lZC5yb3dQcm9wZXJ0aWVzID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS53YXJuKCdUaGUgYHJvd1Byb3BlcnRpZXNgIHByb3BlcnR5IGhhcyBiZWVuIGRlcHJlY2F0ZWQgYXMgb2YgdjIuMS4wIGluIGZhdm9yIG9mIGByb3dTdHJpcGVzYC4gKFdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiknKTtcbiAgICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGRlZmF1bHRzLCB7XG4gICAgcm93UHJvcGVydGllczoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcm93UHJvcGVydGllc0RlcHJlY2F0aW9uV2FybmluZygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93U3RyaXBlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihyb3dQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByb3dQcm9wZXJ0aWVzRGVwcmVjYXRpb25XYXJuaW5nKCk7XG4gICAgICAgICAgICB0aGlzLnJvd1N0cmlwZXMgPSByb3dQcm9wZXJ0aWVzO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIGNvbHVtbk9ubHlFcnJvcigpIHtcbiAgICB0aHJvdyBuZXcgSHlwZXJncmlkRXJyb3IoJ0F0dGVtcHQgdG8gc2V0L2dldCBjb2x1bW4tb25seSBwcm9wZXJ0eSBvbiBhIG5vbi1jb2x1bW4gcHJvcGVydGllcyBvYmplY3QuJyk7XG59XG5cblsnbmFtZScsICd0eXBlJywgJ2hlYWRlcicsICdjYWxjdWxhdG9yJ10uZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVmYXVsdHMsIGtleSwge1xuICAgICAgICBzZXQ6IGNvbHVtbk9ubHlFcnJvclxuICAgIH0pO1xufSk7XG5cbi8qKiBAdHlwZWRlZiB7c3RyaW5nfSBjc3NDb2xvclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9DU1MvY29sb3JfdmFsdWVcbiAqL1xuXG4vKiogQHR5cGVkZWYge3N0cmluZ30gY3NzRm9udFxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9DU1MvZm9udFxuICovXG5cblxuLyoqXG4gKiBSZXR1cm5zIGFueSB2YWx1ZSBvZiBga2V5Q2hhcmAgdGhhdCBwYXNzZXMgdGhlIGZvbGxvd2luZyBsb2dpYyB0ZXN0OlxuICogMS4gSWYgYSBub24tcHJpbnRhYmxlLCB3aGl0ZS1zcGFjZSBjaGFyYWN0ZXIsIHRoZW4gbmF2IGtleS5cbiAqIDIuIElmIG5vdCAoaS5lLiwgYSBub3JtYWwgY2hhcmFjdGVyKSwgY2FuIHN0aWxsIGJlIGEgbmF2IGtleSBpZiBub3QgZWRpdGluZyBvbiBrZXkgZG93bi5cbiAqIDMuIElmIG5vdCwgY2FuIHN0aWxsIGJlIGEgbmF2IGtleSBpZiBDVFJMIGtleSBpcyBkb3duLlxuICpcbiAqIE5vdGU6IENhbGxlcnMgYXJlIHR5cGNpYWxseSBvbmx5IGludGVyZXN0ZWQgaW4gdGhlIGZvbGxvd2luZyB2YWx1ZXMgb2YgYGtleUNoYXJgIGFuZCB3aWxsIGlnbm9yZSBhbGwgb3RoZXJzOlxuICogKiBgJ0xFRlQnYCBhbmQgYCdMRUZUU0hJRlQnYFxuICogKiBgJ1JJR0hUJ2AgYW5kIGAnUklHSFRTSElGVCdgXG4gKiAqIGAnVVAnYCBhbmQgYCdVUFNISUZUJ2BcbiAqICogYCdET1dOJ2AgYW5kIGAnRE9XTlNISUZUJ2BcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5Q2hhciAtIEEgdmFsdWUgZnJvbSBDYW52YXMncyBgY2hhck1hcGAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtjdHJsS2V5PWZhbHNlXSAtIFRoZSBDVFJMIGtleSB3YXMgZG93bi5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8c3RyaW5nfSBgdW5kZWZpbmVkYCBtZWFucyBub3QgYSBuYXYga2V5OyBvdGhlcndpc2UgcmV0dXJucyBga2V5Q2hhcmAuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gKi9cbmZ1bmN0aW9uIG5hdktleShrZXlDaGFyLCBjdHJsS2V5KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAoa2V5Q2hhci5sZW5ndGggPiAxIHx8ICF0aGlzLmVkaXRPbktleWRvd24gfHwgY3RybEtleSkge1xuICAgICAgICByZXN1bHQgPSBrZXlDaGFyOyAvLyByZXR1cm4gdGhlIG1hcHBlZCB2YWx1ZVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFJldHVybnMgb25seSB2YWx1ZXMgb2YgYGtleUNoYXJgIHRoYXQsIHdoZW4gcnVuIHRocm91Z2gge0BsaW5rIG1vZHVsZTpkZWZhdWx0cy5uYXZLZXlNYXB8bmF2S2V5TWFwfSwgcGFzcyB0aGUge0BsaW5rIG1vZHVsZTpkZWZhdWx0cy5uYXZLZXl8bmF2S2V5fSBsb2dpYyB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlDaGFyIC0gQSB2YWx1ZSBmcm9tIENhbnZhcydzIGBjaGFyTWFwYCwgdG8gYmUgcmVtYXBwZWQgdGhyb3VnaCB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLm5hdktleU1hcHxuYXZLZXlNYXB9LlxuICogQHBhcmFtIHtib29sZWFufSBbY3RybEtleT1mYWxzZV0gLSBUaGUgQ1RSTCBrZXkgd2FzIGRvd24uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfHN0cmluZ30gYHVuZGVmaW5lZGAgbWVhbnMgbm90IGEgbmF2IGtleTsgb3RoZXJ3aXNlIHJldHVybnMgYGtleUNoYXJgLlxuICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICovXG5mdW5jdGlvbiBtYXBwZWROYXZLZXkoa2V5Q2hhciwgY3RybEtleSkge1xuICAgIGtleUNoYXIgPSB0aGlzLm5hdktleU1hcFtrZXlDaGFyXTtcbiAgICByZXR1cm4ga2V5Q2hhciAmJiB0aGlzLm5hdktleShrZXlDaGFyKTtcbn1cblxuLyoqIEBzdW1tYXJ5IFJlYXBwbHkgY2VsbCBwcm9wZXJ0aWVzIGFmdGVyIGBnZXRDZWxsYC5cbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAqL1xuZnVuY3Rpb24gcmVhcHBseUNlbGxQcm9wZXJ0aWVzKHZhbHVlKSB7XG4gICAgaWYgKCF3YXJuZWQucmVhcHBseUNlbGxQcm9wZXJ0aWVzKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVGhlIGAucmVhcHBseUNlbGxQcm9wZXJ0aWVzYCBwcm9wZXJ0eSBoYXMgYmVlbiBkZXByZWNhdGVkIGFzIG9mIHYyLjEuMyBpbiBmYXZvciBvZiB1c2luZyB0aGUgbmV3IGAucHJvcENsYXNzTGF5ZXJzYCBwcm9wZXJ0eS4gKE1heSBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuKSBUaGlzIHByb3BlcnR5IGlzIG5vdyBhIHNldHRlciB3aGljaCBzZXRzIGAucHJvcENsYXNzTGF5ZXJzYCB0byBgLnByb3BDbGFzc0xheWVyc01hcC5ERUZBVUxUYCAoZ3JpZCDihpAgY29sdW1ucyDihpAgc3RyaXBlcyDihpAgcm93cyDihpAgY2VsbHMpIG9uIHRydXRoeSBvciBgcHJvcENsYXNzTGF5ZXJzTWFwLk5PX1JPV1NgIChncmlkIOKGkCBjb2x1bW5zIOKGkCBjZWxscykgb24gZmFsc3ksIHdoaWNoIGlzIHdoYXQgeW91IHdpbGwgc2VlIG9uIHByb3BlcnRpZXMgc3RyaW5naWZpY2F0aW9uLiBUaGlzIHdpbGwgZ2l2ZSB0aGUgc2FtZSBlZmZlY3QgaW4gbW9zdCBjYXNlcyBhcyB0aGUgZm9ybWVyIHByb3BlcnR5IGltcGxlbWVudGF0aW9uLCBidXQgbm90IGluIGFsbCBjYXNlcyBkdWUgdG8gaXQgbm8gbG9uZ2VyIGJlaW5nIGFwcGxpZWQgZHluYW1pY2FsbHkuIERldmVsb3BlcnMgc2hvdWxkIGRpc2NvbnRpbnVlIHVzZSBvZiB0aGlzIHByb3BlcnR5IGFuZCBzdGFydCBzcGVjaWZ5aW5nIGAucHJvcENsYXNzTGF5ZXJzYCBpbnN0ZWFkLicpO1xuICAgICAgICB3YXJuZWQucmVhcHBseUNlbGxQcm9wZXJ0aWVzID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5wcm9wQ2xhc3NMYXllcnMgPSB2YWx1ZSA/IHByb3BDbGFzc0xheWVyc01hcC5OT19ST1dTIDogcHJvcENsYXNzTGF5ZXJzTWFwLkRFRkFVTFQ7XG59XG5cbmZ1bmN0aW9uIGRlbGV0ZVByb3AocHJvcE5hbWUpIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcywgcHJvcE5hbWUpO1xuICAgIGlmICghZGVzY3JpcHRvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG93biBwcm9wZXJ0eSBub3QgZm91bmRcbiAgICB9IGVsc2UgaWYgKCFkZXNjcmlwdG9yLmdldCkge1xuICAgICAgICByZXR1cm4gZGVsZXRlIHRoaXNbcHJvcE5hbWVdOyAvLyBub24tYWNjZXNzb3IgcHJvcGVydHkgZm91bmQgKHJldHVybnMgIWRlc2NyaXB0b3IuY29uZmlndXJhYmxlKVxuICAgIH0gZWxzZSBpZiAoZGVzY3JpcHRvci5nZXQudG9TdHJpbmcoKS5pbmRleE9mKCcudmFyLicpKSB7XG4gICAgICAgIHRoaXMudmFyW3Byb3BOYW1lXSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKVtwcm9wTmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIHByb3BlcnR5IG5vdCBkZWxldGFibGVcbiAgICB9XG4gICAgdGhpcy5ncmlkLnJlcGFpbnQoKTtcbiAgICByZXR1cm4gZmFsc2U7IC8vIGRlbGV0ZSB3YXMgc3VjY2Vzc2Z1bFxufVxuXG4vKipcbiAqIEBzdW1tYXJ5IEV4ZWN1dGUgdmFsdWUgaWYgXCJjYWxjdWxhdG9yXCIgKGZ1bmN0aW9uKSBvciBpZiBjb2x1bW4gaGFzIGNhbGN1bGF0b3IuXG4gKiBAZGVzYyBUaGlzIGZ1bmN0aW9uIGlzIHJlZmVyZW5jZWQgaGVyZSBzbzpcbiAqIDEuIEl0IHdpbGwgYmUgYXZhaWxhYmxlIHRvIHRoZSBjZWxsIHJlbmRlcmVyc1xuICogMi4gSXRzIGNvbnRleHQgd2lsbCBuYXR1cmFsbHkgYmUgdGhlIGBjb25maWdgIG9iamVjdFxuICogQGRlZmF1bHQge0BsaW5rIG1vZHVsZTpkZWZhdWx0cy5leGVjfGV4ZWN9XG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0gdmYgLSBWYWx1ZSBvciBmdW5jdGlvbi5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAqL1xuZnVuY3Rpb24gZXhlYyh2Zikge1xuICAgIGlmICh0aGlzLmRhdGFSb3cpIHtcbiAgICAgICAgdmFyIGNhbGN1bGF0b3IgPSAodHlwZW9mIHZmKVswXSA9PT0gJ2YnICYmIHZmIHx8IHRoaXMuY2FsY3VsYXRvcjtcbiAgICAgICAgaWYgKGNhbGN1bGF0b3IpIHtcbiAgICAgICAgICAgIHZmID0gY2FsY3VsYXRvcih0aGlzLmRhdGFSb3csIHRoaXMubmFtZSwgdGhpcy5zdWJyb3cpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2Zjtcbn1cblxuLy8gQWRkIG5vbi1lbnVtZXJhYmxlIFwidXRpbGl0eVwiIHByb3BzIHNvIHRoZXkgd2lsbCBiZSBhdmFpbGFibGUgd2hlcmV2ZXIgcHJvcHMgYXJlIGF2YWlsYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGRlZmF1bHRzLCB7XG4gICAgbWl4SW46IHsgdmFsdWU6IHJlcXVpcmUoJ292ZXJyaWRlcicpLm1peEluIH0sXG4gICAgZGVsZXRlOiB7IHZhbHVlOiBkZWxldGVQcm9wIH0sXG4gICAgcHJvcENsYXNzRW51bTogeyB2YWx1ZTogcHJvcENsYXNzRW51bSB9LFxuICAgIHByb3BDbGFzc0xheWVyc01hcDogeyB2YWx1ZTogcHJvcENsYXNzTGF5ZXJzTWFwIH0sXG4gICAgbmF2S2V5OiB7IHZhbHVlOiBuYXZLZXkgfSxcbiAgICBtYXBwZWROYXZLZXk6IHsgdmFsdWU6IG1hcHBlZE5hdktleSB9LFxuICAgIHJlYXBwbHlDZWxsUHJvcGVydGllczogeyBzZXQ6IHJlYXBwbHlDZWxsUHJvcGVydGllcyB9LFxuICAgIGV4ZWM6IHsgdmFsdWU6IGV4ZWMgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBGZWF0dXJlXG4gKi9cbnZhciBDZWxsQ2xpY2sgPSBGZWF0dXJlLmV4dGVuZCgnQ2VsbENsaWNrJywge1xuICAgIGhhbmRsZU1vdXNlTW92ZTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSB0aGlzLl9pc01vdXNlT3ZlckFjdGl2ZUV4cGFuZEljb24oZ3JpZCwgZXZlbnQpID8gJ3BvaW50ZXInIDogbnVsbDtcblxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VNb3ZlKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQG1lbWJlck9mIENlbGxDbGljayNcbiAgICAgKi9cbiAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgZ3JpZC5sb2coJ2V2ZW50JywgZXZlbnQpO1xuICAgICAgICBsZXQgY29uc3VtZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGV2ZW50LmlzQWdncmVnYXRpb25Db2x1bW4gJiYgdGhpcy5faXNNb3VzZU92ZXJFeHBhbmRJY29uKGdyaWQsIGV2ZW50KSAmJiBldmVudC5pc0V4cGFuZGFibGVSb3cpIHtcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZUV4cGFuZGFibGVSb3coZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgY29uc3VtZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNBZ2dyZWdhdGlvblRyZWVDZWxsKGV2ZW50KSAmJiBldmVudC5pc0V4cGFuZGFibGVSb3cgJiYgZ3JpZC5vbkFnZ3JlZ2F0ZWRDZWxsQ2xpY2spIHtcbiAgICAgICAgICAgIGdyaWQub25BZ2dyZWdhdGVkQ2VsbENsaWNrKGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc01vdXNlT3ZlckV4cGFuZEljb24oZ3JpZCwgZXZlbnQpICYmIGV2ZW50LmlzRXhwYW5kYWJsZUNvbHVtbikge1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRXhwYW5kYWJsZUNvbHVtbihncmlkLCBldmVudCk7XG4gICAgICAgICAgICBjb25zdW1lZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdW1lZCA9IChldmVudC5pc0RhdGFDZWxsIHx8IGV2ZW50LmlzVHJlZUNvbHVtbikgJiYgKFxuICAgICAgICAgICAgICAgIHRoaXMub3BlbkxpbmsoZ3JpZCwgZXZlbnQpICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICBncmlkLmJlaGF2aW9yLmNlbGxDbGlja2VkKGV2ZW50KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY29uc3VtZWQgJiYgdGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdGluZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIC8vIHVzZWQgdG8gZGlzYWJsZSBldmVudCBwcm9wYWdhdGlvblxuICAgICAgICBpZiAodGhpcy5faXNNb3VzZU92ZXJBY3RpdmVFeHBhbmRJY29uKGdyaWQsIGV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdG9nZ2xlRXhwYW5kYWJsZVJvdzogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKCFldmVudC5pc1Jvd0V4cGFuZGVkKSB7XG4gICAgICAgICAgICBncmlkLmJlaGF2aW9yLmV4cGFuZENoaWxkUm93cyhldmVudC5kYXRhUm93KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyaWQuYmVoYXZpb3IuY29sbGFwc2VDaGlsZFJvd3MoZXZlbnQuZGF0YVJvdyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RvZ2dsZUV4cGFuZGFibGVDb2x1bW46IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICghZXZlbnQuaXNDb2x1bW5FeHBhbmRlZCkge1xuICAgICAgICAgICAgZ3JpZC5iZWhhdmlvci5leHBhbmRDaGlsZENvbHVtbnMoZXZlbnQuY29sdW1uR3JvdXBJZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBncmlkLmJlaGF2aW9yLmNvbGxhcHNlQ2hpbGRDb2x1bW5zKGV2ZW50LmNvbHVtbkdyb3VwSWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHNob3dzIGlzIGNlbGwgcmVwcmVzZW50IGFnZ3JlZ2F0aW9uIGRhdGEgc3VtbWFyeVxuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQG1lbWJlck9mIENlbGxDbGljayNcbiAgICAgKi9cbiAgICBpc0FnZ3JlZ2F0aW9uVHJlZUNlbGw6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGlzQWdncmVnYXRpb25UcmVlQ29sdW1uID0gZXZlbnQuaXNBZ2dyZWdhdGlvblRyZWVDb2x1bW4sXG4gICAgICAgICAgICBpc0FnZ3JlZ2F0aW9uUm93ID0gZXZlbnQuaXNBZ2dyZWdhdGlvblJvdyxcbiAgICAgICAgICAgIGFnZ3JlZ2F0aW9uQ2hpbGRDb3VudCA9IGV2ZW50LmFnZ3JlZ2F0aW9uQ2hpbGRDb3VudCxcbiAgICAgICAgICAgIGFnZ3JlZ2F0aW9uR3JhbmRUb3RhbFJvdyA9IGV2ZW50LmlzR3JhbmRUb3RhbFJvdztcblxuICAgICAgICByZXR1cm4gaXNBZ2dyZWdhdGlvblRyZWVDb2x1bW4gJiYgaXNBZ2dyZWdhdGlvblJvdyAmJiBhZ2dyZWdhdGlvbkNoaWxkQ291bnQgPiAwICYmICFhZ2dyZWdhdGlvbkdyYW5kVG90YWxSb3c7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHV0aWxpdHkgZnVuY3Rpb24gdG8gZGV0ZWN0IGlmIGN1cnNvciBvdmVyIGV4cGFuZC9jb2xsYXBzZSBidXR0b25cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fSBldmVudFxuICAgICAqIEBtZW1iZXJPZiBDZWxsQ2xpY2sjXG4gICAgICovXG4gICAgX2lzTW91c2VPdmVyRXhwYW5kSWNvbjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKCghZXZlbnQuaXNFeHBhbmRhYmxlUm93ICYmICFldmVudC5pc0V4cGFuZGFibGVDb2x1bW4pIHx8IGV2ZW50LmlzUmVuZGVyU2tpcE5lZWRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGljb25MZWZ0WCA9IGV2ZW50LnByb3BlcnRpZXMuY2VsbFBhZGRpbmdMZWZ0ICtcbiAgICAgICAgICAgIGV2ZW50LnRyZWVMZXZlbCAqIGV2ZW50LnByb3BlcnRpZXMuYWdncmVnYXRpb25Hcm91cFRyZWVMZXZlbE9mZnNldDtcbiAgICAgICAgbGV0IGljb25SaWdodFggPSBpY29uTGVmdFggKyBldmVudC5wcm9wZXJ0aWVzLmFnZ3JlZ2F0aW9uR3JvdXBFeHBhbmRJY29uQ2xpY2thYmxlV2lkdGg7XG5cbiAgICAgICAgbGV0IGljb25Ub3BZID0gNTtcbiAgICAgICAgbGV0IGljb25Cb3R0b21ZID0gZXZlbnQuYm91bmRzLmhlaWdodCAtIDU7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50Lm1vdXNlUG9pbnQueCA8PSBpY29uUmlnaHRYXG4gICAgICAgICAgICAmJiBldmVudC5tb3VzZVBvaW50LnggPj0gMFxuICAgICAgICAgICAgJiYgZXZlbnQubW91c2VQb2ludC55IDw9IGljb25Cb3R0b21ZXG4gICAgICAgICAgICAmJiBldmVudC5tb3VzZVBvaW50LnkgPj0gaWNvblRvcFk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHV0aWxpdHkgZnVuY3Rpb24gdG8gZGV0ZWN0IGlmIGN1cnNvciBvdmVyIGV4cGFuZC9jb2xsYXBzZSBidXR0b24sIHRoYXQgY2FuIGJlIGNsaWNrZWQgYmVjYXVzZSBvZiB2YXJpb3VzIGZhY3RvcnNcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fSBldmVudFxuICAgICAqIEBtZW1iZXJPZiBDZWxsQ2xpY2sjXG4gICAgICovXG4gICAgX2lzTW91c2VPdmVyQWN0aXZlRXhwYW5kSWNvbjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuICgoZXZlbnQuaXNBZ2dyZWdhdGlvbkNvbHVtbiAmJiBldmVudC5pc0V4cGFuZGFibGVSb3cpIHx8IHRoaXMuaXNBZ2dyZWdhdGlvblRyZWVDZWxsKGV2ZW50KSB8fCBldmVudC5pc0V4cGFuZGFibGVDb2x1bW4pXG4gICAgICAgICAgICAmJiB0aGlzLl9pc01vdXNlT3ZlckV4cGFuZEljb24oZ3JpZCwgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBPcGVuIHRoZSBjZWxsJ3MgVVJMLlxuICAgICAqXG4gICAgICogQGRlc2MgVGhlIFVSTCBpcyBmb3VuZCBpbiB0aGUgY2VsbCdzIHtAbGluayBtb2R1bGU6ZGVmYXVsdHMubGlua3xsaW5rfSBwcm9wZXJ0eSwgd2hpY2ggc2VydmVzIHR3byBmdW5jdGlvbnM6XG4gICAgICogMS4gKipSZW5kZXJzIGFzIGEgbGluay4qKiBXaGVuIHRydXRoeSBjYXVzZXMge0BsaW5rIFNpbXBsZUNlbGx9IGNlbGwgcmVuZGVyZXIgdG8gcmVuZGVyIHRoZSBjZWxsIHVuZGVybGluZWQgd2l0aCB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLmxpbmtDb2xvcnxsaW5rQ29sb3J9LiAoU2VlIGFsc28ge0BsaW5rIG1vZHVsZTpkZWZhdWx0cy5saW5rT25Ib3ZlcnxsaW5rT25Ib3Zlcn0gYW5kIHtAbGluayBtb2R1bGU6ZGVmYXVsdHMubGlua0NvbG9yT25Ib3ZlcnxsaW5rQ29sb3JPbkhvdmVyfS4pIFRoZXJlZm9yZSwgc2V0dGluZyB0aGlzIHByb3BlcnR5IHRvIGB0cnVlYCB3aWxsIHJlbmRlciBhcyBhIGxpbmssIGFsdGhvdWdoIGNsaWNraW5nIG9uIGl0IHdpbGwgaGF2ZSBubyBlZmZlY3QuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3aXNoIHRvIGhhbmRsZSB0aGUgY2xpY2sgeW91cnNlbGYgYnkgYXR0YWNoaW5nIGEgYCdmaW4tY2xpY2snYCBsaXN0ZW5lciB0byB5b3VyIGh5cGVyZ3JpZC5cbiAgICAgKiAyLiAqKkZldGNoIHRoZSBVUkwuKiogVGhlIHZhbHVlIG9mIHRoZSBsaW5rIHByb3BlcnR5IGlzIGludGVycHJldGVkIGFzIHBlciB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLmxpbmt8bGlua30uXG4gICAgICogMy4gKipEZWNvcmF0ZSB0aGUgVVJMLioqIFRoZSBjZWxsIG5hbWUgKF9pLmUuLF8gdGhlIGRhdGEgY29sdW1uIG5hbWUpIGFuZCBjZWxsIHZhbHVlIGFyZSBtZXJnZWQgaW50byB0aGUgVVJMIHdoZXJldmVyIHRoZSByZXNwZWN0aXZlIHN1YnN0cmluZ3MgYCclbmFtZSdgIGFuZCBgJyV2YWx1ZSdgIGFyZSBmb3VuZC4gRm9yIGV4YW1wbGUsIGlmIHRoZSBjb2x1bW4gbmFtZSBpcyBcImFnZVwiIGFuZCB0aGUgY2VsbCB2YWx1ZSBpcyA2IChvciBhIGZ1bmN0aW9uIHJldHVybmluZyAyNSksIGFuZCB0aGUgbGluayBpcyBgJ2h0dHA6Ly93d3cuYWJjLmNvbT8lbmFtZT0ldmFsdWUnYCwgdGhlbiB0aGUgYWN0dWFsIGxpbmsgKGZpcnN0IGFyZ3VtZW50IGdpdmVuIHRvIGBncmlkLndpbmRvd09wZW5gKSB3b3VsZCBiZSBgJ2h0dHA6Ly93d3cuYWJjLmNvbT9hZ2U9MjUnYC5cbiAgICAgKiA0LiAqKk9wZW4gdGhlIFVSTC4qKiBUaGUgbGluayBpcyB0aGVuIG9wZW5lZCBieSB7QGxpbmsgSHlwZXJncmlkI3dpbmRvd09wZW58Z3JpZC53aW5kb3dPcGVufS4gSWYgYGxpbmtgIGlzIGFuIGFycmF5LCBpdCBpcyBcImFwcGxpZWRcIiB0byBgZ3JpZC53aW5kb3dPcGVuYCBpbiBpdHMgZW50aXJldHk7IG90aGVyd2lzZSwgYGdyaWQud2luZG93T3BlbmAgaXMgY2FsbGVkIHdpdGggdGhlIGxpbmsgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLmxpbmtUYXJnZXR8bGlua1RhcmdldH0gYXMgdGhlIHNlY29uZC5cbiAgICAgKiA1LiAqKkRlY29yYXRlIHRoZSBsaW5rLioqIE9uIHN1Y2Nlc3NmdWwgcmV0dXJuIGZyb20gYHdpbmRvd09wZW4oKWAsIHRoZSB0ZXh0IGlzIGNvbG9yZWQgYXMgXCJ2aXNpdGVkXCIgYXMgcGVyIHRoZSBjZWxsJ3Mge0BsaW5rIG1vZHVsZTpkZWZhdWx0cy5saW5rVmlzaXRlZENvbG9yfGxpbmtWaXNpdGVkQ29sb3J9IHByb3BlcnR5IChieSBzZXR0aW5nIHRoZSBjZWxsJ3MgYGxpbmtDb2xvcmAgcHJvcGVydHkgdG8gaXRzIGBsaW5rVmlzaXRlZENvbG9yYCBwcm9wZXJ0eSkuXG5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fSBjZWxsRXZlbnQgLSBFdmVudCBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW58d2luZG93fG51bGx8dW5kZWZpbmVkfSBPbmUgb2Y6XG4gICAgICpcbiAgICAgKiB8IFZhbHVlIHwgTWVhbmluZyB8XG4gICAgICogfCA6LS0tLSB8IDotLS0tLS0gfFxuICAgICAqIHwgYHVuZGVmaW5lZGAgfCBubyBsaW5rIHRvIG9wZW4gfFxuICAgICAqIHwgYG51bGxgIHwgYGdyaWQud2luZG93T3BlbmAgZmFpbGVkIHRvIG9wZW4gYSB3aW5kb3cgfFxuICAgICAqIHwgX290aGVyd2lzZV8gfCBBIGB3aW5kb3dgIHJlZmVyZW5jZSByZXR1cm5lZCBieSBhIHN1Y2Nlc3NmdWwgY2FsbCB0byBgZ3JpZC53aW5kb3dPcGVuYC4gfFxuICAgICAqXG4gICAgICogQG1lbWJlck9mIENlbGxDbGljayNcbiAgICAgKi9cbiAgICBvcGVuTGluazogZnVuY3Rpb24oZ3JpZCwgY2VsbEV2ZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQsIHVybCxcbiAgICAgICAgICAgIGRhdGFSb3cgPSBjZWxsRXZlbnQuZGF0YVJvdyxcbiAgICAgICAgICAgIGNvbmZpZyA9IE9iamVjdC5jcmVhdGUoY2VsbEV2ZW50LnByb3BlcnRpZXMsIHsgZGF0YVJvdzogeyB2YWx1ZTogZGF0YVJvdyB9IH0pLFxuICAgICAgICAgICAgdmFsdWUgPSBjb25maWcuZXhlYyhjZWxsRXZlbnQudmFsdWUpLFxuICAgICAgICAgICAgbGlua1Byb3AgPSBjZWxsRXZlbnQucHJvcGVydGllcy5saW5rLFxuICAgICAgICAgICAgaXNBcnJheSA9IGxpbmtQcm9wIGluc3RhbmNlb2YgQXJyYXksXG4gICAgICAgICAgICBsaW5rID0gaXNBcnJheSA/IGxpbmtQcm9wWzBdIDogbGlua1Byb3A7XG5cbiAgICAgICAgLy8gU1RFUCAyOiBGZXRjaCB0aGUgVVJMXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIGxpbmspIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgaWYgKGxpbmsgPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKC9eXFx3KyQvLnRlc3QobGluaykpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gZGF0YVJvd1tsaW5rXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICB1cmwgPSBsaW5rKGNlbGxFdmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICAvLyBTVEVQIDM6IERlY29yYXRlIHRoZSBVUkxcbiAgICAgICAgICAgIHVybCA9IHVybC50b1N0cmluZygpLnJlcGxhY2UoLyVuYW1lL2csIGNvbmZpZy5uYW1lKS5yZXBsYWNlKC8ldmFsdWUvZywgdmFsdWUpO1xuXG4gICAgICAgICAgICAvLyBTVEVQIDQ6IE9wZW4gdGhlIFVSTFxuICAgICAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBsaW5rUHJvcCA9IGxpbmtQcm9wLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgbGlua1Byb3BbMF0gPSB1cmw7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZ3JpZC53aW5kb3dPcGVuLmFwcGx5KGdyaWQsIGxpbmtQcm9wKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZ3JpZC53aW5kb3dPcGVuKHVybCwgY2VsbEV2ZW50LnByb3BlcnRpZXMubGlua1RhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTVEVQIDU6IERlY29yYXRlIHRoZSBsaW5rIGFzIFwidmlzaXRlZFwiXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGNlbGxFdmVudC5zZXRDZWxsUHJvcGVydHkoJ2xpbmtDb2xvcicsIGdyaWQucHJvcGVydGllcy5saW5rVmlzaXRlZENvbG9yKTtcbiAgICAgICAgICAgIGdyaWQucmVuZGVyZXIucmVzZXRDZWxsUHJvcGVydGllc0NhY2hlKGNlbGxFdmVudCk7XG4gICAgICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsQ2xpY2s7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlJyk7XG52YXIgQ2VsbEVkaXRvciA9IHJlcXVpcmUoJy4uL2NlbGxFZGl0b3JzL0NlbGxFZGl0b3InKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEZlYXR1cmVcbiAqL1xudmFyIENlbGxFZGl0aW5nID0gRmVhdHVyZS5leHRlbmQoJ0NlbGxFZGl0aW5nJywge1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0aW5nLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgZWRpdC5jYWxsKHRoaXMsIGdyaWQsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0aW5nLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVEb3VibGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgZWRpdC5jYWxsKHRoaXMsIGdyaWQsIGV2ZW50LCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBtZW1iZXJPZiBLZXlQYWdpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGNoYXIsIGlzVmlzaWJsZUNoYXIsIGlzRGVsZXRlQ2hhciwgZWRpdG9yLCBjZWxsRXZlbnQ7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKGNlbGxFdmVudCA9IGdyaWQuZ2V0R3JpZENlbGxGcm9tTGFzdFNlbGVjdGlvbigpKSAmJlxuICAgICAgICAgICAgY2VsbEV2ZW50LnByb3BlcnRpZXMuZWRpdE9uS2V5ZG93biAmJlxuICAgICAgICAgICAgIWdyaWQuY2VsbEVkaXRvciAmJlxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgIChjaGFyID0gZXZlbnQuZGV0YWlsLmNoYXIpID09PSAnRjInIHx8XG4gICAgICAgICAgICAgICAgKGlzVmlzaWJsZUNoYXIgPSBjaGFyLmxlbmd0aCA9PT0gMSAmJiAhKGV2ZW50LmRldGFpbC5tZXRhIHx8IGV2ZW50LmRldGFpbC5jdHJsKSkgfHxcbiAgICAgICAgICAgICAgICAoaXNEZWxldGVDaGFyID0gY2hhciA9PT0gJ0RFTEVURScgfHwgY2hhciA9PT0gJ0JBQ0tTUEFDRScpXG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgbmVlZGVkVmlzaWJpbGl0eVByb3AgPSBjZWxsRXZlbnQuaXNEYXRhUm93ID8gJ2VkaXRhYmxlJyA6ICdmaWx0ZXJhYmxlJztcbiAgICAgICAgICAgIGNvbnN0IGlzRWRpdGFibGUgPSBjZWxsRXZlbnQucm93UHJvcGVydGllc1tuZWVkZWRWaXNpYmlsaXR5UHJvcF0gfHwgY2VsbEV2ZW50LnByb3BlcnRpZXNbbmVlZGVkVmlzaWJpbGl0eVByb3BdO1xuICAgICAgICAgICAgaWYgKGlzRWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IgPSBncmlkLm9uRWRpdG9yQWN0aXZhdGUoY2VsbEV2ZW50KTtcblxuICAgICAgICAgICAgICAgIGlmIChlZGl0b3IgaW5zdGFuY2VvZiBDZWxsRWRpdG9yKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmlzaWJsZUNoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5pbnB1dC52YWx1ZSA9IGNoYXI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNEZWxldGVDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2V0RWRpdG9yVmFsdWUoJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV2ZW50LmRldGFpbC5wcmltaXRpdmVFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUtleURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxuZnVuY3Rpb24gZWRpdChncmlkLCBldmVudCwgb25Eb3VibGVDbGljaykge1xuICAgIGlmIChcbiAgICAgICAgZXZlbnQuaXNEYXRhQ2VsbCAmJlxuICAgICAgICAhKGV2ZW50LmdldENlbGxQcm9wZXJ0eSgnZWRpdE9uRG91YmxlQ2xpY2snKSBeIG9uRG91YmxlQ2xpY2spIC8vIGJvdGggc2FtZSAodHJ1ZSBvciBmYWxzeSk/XG4gICAgKSB7XG4gICAgICAgIGdyaWQub25FZGl0b3JBY3RpdmF0ZShldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICB0aGlzLm5leHRbb25Eb3VibGVDbGljayA/ICdoYW5kbGVEb3VibGVDbGljaycgOiAnaGFuZGxlQ2xpY2snXShncmlkLCBldmVudCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENlbGxFZGl0aW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRmVhdHVyZVxuICovXG52YXIgQ2VsbFNlbGVjdGlvbiA9IEZlYXR1cmUuZXh0ZW5kKCdDZWxsU2VsZWN0aW9uJywge1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBtb3VzZSBwb2ludGVyIGR1cmluZyBhIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjdXJyZW50RHJhZzogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIHRoZSBjZWxsIGNvb3JkaW5hdGVzIG9mIHRoZSB3aGVyZSB0aGUgbW91c2UgcG9pbnRlciBpcyBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvblxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgbGFzdERyYWdDZWxsOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogYSBtaWxsaXNlY29uZCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHByZXZpb3VzIHRpbWUgYW4gYXV0b3Njcm9sbCBzdGFydGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JMYXN0QXV0bzogMCxcblxuICAgIC8qKlxuICAgICAqIGEgbWlsbGlzZWNvbmQgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSB0aW1lIHRoZSBjdXJyZW50IGF1dG9zY3JvbGwgc3RhcnRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNiQXV0b1N0YXJ0OiAwLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlVXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlVXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGxldCBkeCwgZHk7XG4gICAgICAgIGdyaWQuYmVoYXZpb3IuZ2V0SGVhZGVyQ29sdW1uQnlOYW1lKCk7XG4gICAgICAgIGlmIChldmVudC5pc0NvbHNwYW5lZEJ5TGVmdENvbHVtbiAmJiBldmVudC5jb2xzcGFuTWFpbkNvbHVtbk5hbWUpIHtcbiAgICAgICAgICAgIGxldCBtYWluQ29sdW1uID0gZ3JpZC5iZWhhdmlvci5nZXRIZWFkZXJDb2x1bW5CeU5hbWUoZXZlbnQuY29sc3Bhbk1haW5Db2x1bW5OYW1lKTtcbiAgICAgICAgICAgIGxldCBtYWluQ29sdW1uSW5kZXggPSBncmlkLmJlaGF2aW9yLmNvbHVtbnMuaW5kZXhPZihtYWluQ29sdW1uKTtcblxuICAgICAgICAgICAgaWYgKG1haW5Db2x1bW4gJiYgbWFpbkNvbHVtbkluZGV4KSB7XG4gICAgICAgICAgICAgICAgZHggPSBtYWluQ29sdW1uSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQucm93c3Bhbk1haW5Sb3cgIT09IHVuZGVmaW5lZCAmJiBldmVudC5yb3dzcGFuTWFpblJvdyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZHkgPSBldmVudC5yb3dzcGFuTWFpblJvdztcbiAgICAgICAgfVxuXG4gICAgICAgIGR4ID0gZHggIT09IHVuZGVmaW5lZCA/IGR4IDogZXZlbnQuZGF0YUNlbGwueDtcbiAgICAgICAgZHkgPSBkeSAhPT0gdW5kZWZpbmVkID8gZHkgOiBldmVudC5kYXRhQ2VsbC55O1xuICAgICAgICBsZXQgaXNTZWxlY3RhYmxlID0gZ3JpZC5iZWhhdmlvci5nZXRDZWxsUHJvcGVydHkoZHgsIGR5LCAnY2VsbFNlbGVjdGlvbicpO1xuXG4gICAgICAgIGlmIChpc1NlbGVjdGFibGUgJiYgZXZlbnQuaXNEYXRhQ2VsbCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5pc1JpZ2h0Q2xpY2sgJiYgZXZlbnQuaXNDZWxsU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZENlbGwgPSBncmlkLm5ld1BvaW50KGR4LCBkeSksXG4gICAgICAgICAgICAgICAgcHJpbUV2ZW50ID0gZXZlbnQucHJpbWl0aXZlRXZlbnQsXG4gICAgICAgICAgICAgICAga2V5cyA9IHByaW1FdmVudC5kZXRhaWwua2V5cztcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5leHRlbmRTZWxlY3Rpb24oZ3JpZCwgZENlbGwsIGtleXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRHJhZzogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgJiYgZ3JpZC5wcm9wZXJ0aWVzLmNlbGxTZWxlY3Rpb24gJiYgIWV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5pc1JpZ2h0Q2xpY2spIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERyYWcgPSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB0aGlzLmxhc3REcmFnQ2VsbCA9IGdyaWQubmV3UG9pbnQoZXZlbnQuZ3JpZENlbGwueCwgZXZlbnQuZGF0YUNlbGwueSk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRHJhZ1Njcm9sbChncmlkLCB0aGlzLmN1cnJlbnREcmFnKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbihncmlkLCB0aGlzLmxhc3REcmFnQ2VsbCwgZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmtleXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUtleURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGxldCBjZWxsRXZlbnQgPSBncmlkLmdldEdyaWRDZWxsRnJvbUxhc3RTZWxlY3Rpb24odHJ1ZSk7XG4gICAgICAgIGNvbnN0IGRldGFpbCA9IGV2ZW50LmRldGFpbCxcbiAgICAgICAgICAgIGtleXMgPSBkZXRhaWwuY3VycmVudEtleXM7XG4gICAgICAgIGNvbnN0IGN0cmxQcmVzc2VkID0gZXZlbnQubWV0YUtleVxuICAgICAgICAgICAgfHwgZXZlbnQuY3RybEtleVxuICAgICAgICAgICAgfHwga2V5cy5pbmRleE9mKCdDVFJMJykgPj0gMFxuICAgICAgICAgICAgfHwga2V5cy5pbmRleE9mKCdDT01NQU5ETEVGVCcpID49IDBcbiAgICAgICAgICAgIHx8IGtleXMuaW5kZXhPZignQ09NTUFORFJJR0hUJykgPj0gMDtcbiAgICAgICAgY29uc3QgbmF2S2V5ID0gY2VsbEV2ZW50ICYmIChcbiAgICAgICAgICAgICAgICBjZWxsRXZlbnQucHJvcGVydGllcy5tYXBwZWROYXZLZXkoZGV0YWlsLmNoYXIsIGN0cmxQcmVzc2VkKSB8fFxuICAgICAgICAgICAgICAgIGNlbGxFdmVudC5wcm9wZXJ0aWVzLm5hdktleShkZXRhaWwuY2hhciwgY3RybFByZXNzZWQpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSAoY3RybFByZXNzZWQgJiYgdGhpc1snaGFuZGxlQ1RSTCcgKyBuYXZLZXldKSA/IHRoaXNbJ2hhbmRsZUNUUkwnICsgbmF2S2V5XSA6IHRoaXNbJ2hhbmRsZScgKyBuYXZLZXldO1xuXG4gICAgICAgIC8vIFNURVAgMTogTW92ZSB0aGUgc2VsZWN0aW9uXG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgZ3JpZCwgZGV0YWlsKTtcblxuICAgICAgICAgICAgLy8gU1RFUCAyOiBPcGVuIHRoZSBjZWxsIGVkaXRvciBhdCB0aGUgbmV3IHBvc2l0aW9uIGlmIGl0IGhhcyBgZWRpdE9uTmV4dENlbGxgIGFuZCBpcyBgZWRpdGFibGVgXG4gICAgICAgICAgICBjZWxsRXZlbnQgPSBncmlkLmdldEdyaWRDZWxsRnJvbUxhc3RTZWxlY3Rpb24odHJ1ZSk7IC8vIG5ldyBjZWxsXG4gICAgICAgICAgICBpZiAoY2VsbEV2ZW50LnByb3BlcnRpZXMuZWRpdE9uTmV4dENlbGwpIHtcbiAgICAgICAgICAgICAgICBncmlkLmVkaXRBdChjZWxsRXZlbnQpOyAvLyBzdWNjZWVkcyBvbmx5IGlmIGBlZGl0YWJsZWBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU1RFUCAzOiBJZiBlZGl0b3Igbm90IG9wZW5lZCBvbiBuZXcgY2VsbCwgdGFrZSBmb2N1c1xuICAgICAgICAgICAgaWYgKCFncmlkLmNlbGxFZGl0b3IpIHtcbiAgICAgICAgICAgICAgICBncmlkLnRha2VGb2N1cygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXZlbnQuZGV0YWlsLnNvdXJjZUV2ZW50ICYmIGV2ZW50LmRldGFpbC5zb3VyY2VFdmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LmRldGFpbC5zb3VyY2VFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUtleURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEhhbmRsZSBhIG1vdXNlZHJhZyBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JpZENlbGwgLSBncmlkIGNlbGxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gYXJyYXkgb2YgdGhlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IHByZXNzZWQgZG93blxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb246IGZ1bmN0aW9uKGdyaWQsIGdyaWRDZWxsLCBrZXlzKSB7XG4gICAgICAgIGNvbnN0IHggPSBNYXRoLm1heCgwLCBncmlkQ2VsbC54KSxcbiAgICAgICAgICAgIHkgPSBNYXRoLm1heCgwLCBncmlkQ2VsbC55KSxcbiAgICAgICAgICAgIHByZXZpb3VzRHJhZ0V4dGVudCA9IGdyaWQuZ2V0RHJhZ0V4dGVudCgpLFxuICAgICAgICAgICAgbW91c2VEb3duID0gZ3JpZC5nZXRNb3VzZURvd24oKSxcbiAgICAgICAgICAgIG5ld1ggPSB4IC0gbW91c2VEb3duLngsXG4gICAgICAgICAgICBuZXdZID0geSAtIG1vdXNlRG93bi55O1xuXG4gICAgICAgIGlmIChwcmV2aW91c0RyYWdFeHRlbnQueCA9PT0gbmV3WCAmJiBwcmV2aW91c0RyYWdFeHRlbnQueSA9PT0gbmV3WSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRTZWxlY3Rpb24oKTtcblxuICAgICAgICBncmlkLnNlbGVjdChtb3VzZURvd24ueCwgbW91c2VEb3duLnksIG5ld1gsIG5ld1kpO1xuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludChuZXdYLCBuZXdZKSk7XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgY2hlY2tzIHdoaWxlIHdlcmUgZHJhZ2dpbmcgaWYgd2UgZ28gb3V0c2lkZSB0aGUgdmlzaWJsZSBib3VuZHMsIGlmIHNvLCBraWNrIG9mZiB0aGUgZXh0ZXJuYWwgYXV0b3Njcm9sbCBjaGVjayBmdW5jdGlvbiAoYWJvdmUpXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW91c2UgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGNoZWNrRHJhZ1Njcm9sbDogZnVuY3Rpb24oZ3JpZCwgbW91c2UpIHtcbiAgICAgICAgaWYgKCFncmlkLnByb3BlcnRpZXMuc2Nyb2xsaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGIgPSBncmlkLmdldERhdGFCb3VuZHMoKTtcbiAgICAgICAgY29uc3QgaW5zaWRlID0gYi5jb250YWlucyhtb3VzZSk7XG4gICAgICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgICAgIGlmIChncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgICAgICBncmlkLnNldFNjcm9sbGluZ05vdyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgZ3JpZC5zZXRTY3JvbGxpbmdOb3codHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbERyYWcoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBtYWtlcyBzdXJlIHRoYXQgd2hpbGUgd2UgYXJlIGRyYWdnaW5nIG91dHNpZGUgb2YgdGhlIGdyaWQgdmlzaWJsZSBib3VuZHMsIHdlIHNjcm9sbCBhY2NvcmRpbmdseVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgc2Nyb2xsRHJhZzogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBpZiAoIWdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxhc3REcmFnQ2VsbCA9IHRoaXMubGFzdERyYWdDZWxsLFxuICAgICAgICAgICAgYiA9IGdyaWQuZ2V0RGF0YUJvdW5kcygpLFxuXG4gICAgICAgICAgICB4T2Zmc2V0ID0gMCxcbiAgICAgICAgICAgIHlPZmZzZXQgPSAwLFxuXG4gICAgICAgICAgICBudW1GaXhlZENvbHVtbnMgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKSxcbiAgICAgICAgICAgIG51bUZpeGVkUm93cyA9IGdyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpLFxuXG4gICAgICAgICAgICBkcmFnRW5kSW5GaXhlZEFyZWFYID0gbGFzdERyYWdDZWxsLnggPCBudW1GaXhlZENvbHVtbnMsXG4gICAgICAgICAgICBkcmFnRW5kSW5GaXhlZEFyZWFZID0gbGFzdERyYWdDZWxsLnkgPCBudW1GaXhlZFJvd3M7XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYWcueCA8IGIub3JpZ2luLngpIHtcbiAgICAgICAgICAgIHhPZmZzZXQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhZy55IDwgYi5vcmlnaW4ueSkge1xuICAgICAgICAgICAgeU9mZnNldCA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYWcueCA+IGIub3JpZ2luLnggKyBiLmV4dGVudC54KSB7XG4gICAgICAgICAgICB4T2Zmc2V0ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhZy55ID4gYi5vcmlnaW4ueSArIGIuZXh0ZW50LnkpIHtcbiAgICAgICAgICAgIHlPZmZzZXQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRyYWdDZWxsT2Zmc2V0WCA9IHhPZmZzZXQ7XG4gICAgICAgIGxldCBkcmFnQ2VsbE9mZnNldFkgPSB5T2Zmc2V0O1xuXG4gICAgICAgIGlmIChkcmFnRW5kSW5GaXhlZEFyZWFYKSB7XG4gICAgICAgICAgICBkcmFnQ2VsbE9mZnNldFggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkcmFnRW5kSW5GaXhlZEFyZWFZKSB7XG4gICAgICAgICAgICBkcmFnQ2VsbE9mZnNldFkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0RHJhZ0NlbGwgPSBsYXN0RHJhZ0NlbGwucGx1c1hZKGRyYWdDZWxsT2Zmc2V0WCwgZHJhZ0NlbGxPZmZzZXRZKTtcbiAgICAgICAgZ3JpZC5zY3JvbGxCeSh4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZURyYWdDZWxsU2VsZWN0aW9uKGdyaWQsIGxhc3REcmFnQ2VsbCwgW10pOyAvLyB1cGRhdGUgdGhlIHNlbGVjdGlvblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnNjcm9sbERyYWcuYmluZCh0aGlzLCBncmlkKSwgMjUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBleHRlbmQgYSBzZWxlY3Rpb24gb3IgY3JlYXRlIG9uZSBpZiB0aGVyZSBpc250IHlldFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFDZWxsIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gYXJyYXkgb2YgdGhlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IHByZXNzZWQgZG93blxuICAgICAqL1xuICAgIGV4dGVuZFNlbGVjdGlvbjogZnVuY3Rpb24oZ3JpZCwgZGF0YUNlbGwsIGtleXMpIHtcbiAgICAgICAgY29uc3QgaGFzQ1RSTCA9IGtleXMuaW5kZXhPZignQ1RSTCcpID49IDAgfHwga2V5cy5pbmRleE9mKCdDT01NQU5ETEVGVCcpID49IDAgfHwga2V5cy5pbmRleE9mKCdDT01NQU5EUklHSFQnKSA+PSAwLFxuICAgICAgICAgICAgaGFzU0hJRlQgPSBrZXlzLmluZGV4T2YoJ1NISUZUJykgPj0gMCxcbiAgICAgICAgICAgIG1vdXNlUG9pbnQgPSBncmlkLmdldE1vdXNlRG93bigpLFxuICAgICAgICAgICAgeCA9IGRhdGFDZWxsLngsIC8vIC0gbnVtRml4ZWRDb2x1bW5zICsgc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIHkgPSBkYXRhQ2VsbC55OyAvLyAtIG51bUZpeGVkUm93cyArIHNjcm9sbFRvcDtcblxuICAgICAgICAvL3dlcmUgb3V0c2lkZSBvZiB0aGUgZ3JpZCBkbyBub3RoaW5nXG4gICAgICAgIGlmICh4IDwgMCB8fCB5IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy93ZSBoYXZlIHJlcGVhdGVkIGEgY2xpY2sgaW4gdGhlIHNhbWUgc3BvdCBkZXNsZWN0IHRoZSB2YWx1ZSBmcm9tIGxhc3QgdGltZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBoYXNDVFJMICYmXG4gICAgICAgICAgICB4ID09PSBtb3VzZVBvaW50LnggJiZcbiAgICAgICAgICAgIHkgPT09IG1vdXNlUG9pbnQueVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBncmlkLnBvcE1vdXNlRG93bigpO1xuICAgICAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhhc0NUUkwgJiYgIWhhc1NISUZUKSB7XG4gICAgICAgICAgICBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1NISUZUKSB7XG4gICAgICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgZ3JpZC5zZWxlY3QobW91c2VQb2ludC54LCBtb3VzZVBvaW50LnksIHggLSBtb3VzZVBvaW50LngsIHkgLSBtb3VzZVBvaW50LnkpO1xuICAgICAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoeCAtIG1vdXNlUG9pbnQueCwgeSAtIG1vdXNlUG9pbnQueSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JpZC5zZWxlY3QoeCwgeSwgMCwgMCk7XG4gICAgICAgICAgICBncmlkLnNldE1vdXNlRG93bihncmlkLm5ld1BvaW50KHgsIHkpKTtcbiAgICAgICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIDApKTtcbiAgICAgICAgfVxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBoYW5kbGVET1dOU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2hpZnRTZWxlY3QoZ3JpZCwgMCwgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaGFuZGxlVVBTSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAwLCAtMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaGFuZGxlTEVGVFNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIC0xLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBoYW5kbGVSSUdIVFNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIDEsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBncmlkXG4gICAgICogQHBhcmFtIHNlbGVjdGlvblxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNTZWxlY3Rpb25JbnNpZGVEYXRhQXJlYTogZnVuY3Rpb24oZ3JpZCwgc2VsZWN0aW9uKXtcbiAgICAgICAgY29uc3QgbWF4Q29sdW1uV2l0aENvbnRlbnQgPSBncmlkLmJlaGF2aW9yLmRhdGFNb2RlbC5nZXRDb2x1bW5zV2l0aFZhbHVlc0NvdW50KCk7XG4gICAgICAgIGNvbnN0IG1heFJvd1dpdGhDb250ZW50ID0gZ3JpZC5iZWhhdmlvci5kYXRhTW9kZWwuZ2V0Um93c1dpdGhWYWx1ZXNDb3VudCgpO1xuXG4gICAgICAgIHJldHVybiBzZWxlY3Rpb24uY29ybmVyLnggPD0gKG1heENvbHVtbldpdGhDb250ZW50IC0gMSlcbiAgICAgICAgICAgICYmIHNlbGVjdGlvbi5jb3JuZXIueSA8PSBtYXhSb3dXaXRoQ29udGVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gZ3JpZFxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzU2VsZWN0aW9uQWxyZWFkeU9uRmljdGl2ZUhlYWRlclJvdzogZnVuY3Rpb24oZ3JpZCwgc2VsZWN0aW9uKXtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbi5vcmlnaW4ueSA8IGdyaWQuZ2V0RmljdGl2ZUhlYWRlclJvd3NDb3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBncmlkXG4gICAgICogQHBhcmFtIHNlbGVjdGlvblxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNTZWxlY3Rpb25BbHJlYWR5T25GaXJzdERhdGFSb3c6IGZ1bmN0aW9uKGdyaWQsIHNlbGVjdGlvbil7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb24ub3JpZ2luLnkgPT09IGdyaWQuZ2V0RmljdGl2ZUhlYWRlclJvd3NDb3VudCgpXG4gICAgICAgICAgICB8fCBzZWxlY3Rpb24uY29ybmVyLnkgPT09IGdyaWQuZ2V0RmljdGl2ZUhlYWRlclJvd3NDb3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBncmlkXG4gICAgICogQHBhcmFtIHNlbGVjdGlvblxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNTZWxlY3Rpb25BbHJlYWR5T25MYXN0RGF0YVJvdzogZnVuY3Rpb24oZ3JpZCwgc2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IG1heFJvd1dpdGhDb250ZW50ID0gZ3JpZC5iZWhhdmlvci5kYXRhTW9kZWwuZ2V0Um93c1dpdGhWYWx1ZXNDb3VudCgpO1xuICAgICAgICByZXR1cm4gc2VsZWN0aW9uLmNvcm5lci55ID09PSBtYXhSb3dXaXRoQ29udGVudCArIGdyaWQuZ2V0RmljdGl2ZUhlYWRlclJvd3NDb3VudCgpIC0gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gZ3JpZFxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzU2VsZWN0aW9uQWxyZWFkeU9uTGFzdERhdGFDb2x1bW46IGZ1bmN0aW9uKGdyaWQsIHNlbGVjdGlvbikge1xuICAgICAgICBjb25zdCBtYXhDb2x1bW5XaXRoQ29udGVudCA9IGdyaWQuYmVoYXZpb3IuZGF0YU1vZGVsLmdldENvbHVtbnNXaXRoVmFsdWVzQ291bnQoKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbi5jb3JuZXIueCA9PT0gbWF4Q29sdW1uV2l0aENvbnRlbnQgLSAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBncmlkXG4gICAgICogQHBhcmFtIHNlbGVjdGlvblxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNTZWxlY3Rpb25BbHJlYWR5T25MYXN0RGF0YUNvbHVtbkFuZFJvdzogZnVuY3Rpb24oZ3JpZCwgc2VsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NlbGVjdGlvbkFscmVhZHlPbkxhc3REYXRhUm93KGdyaWQsIHNlbGVjdGlvbilcbiAgICAgICAgICAgICYmIHRoaXMuX2lzU2VsZWN0aW9uQWxyZWFkeU9uTGFzdERhdGFDb2x1bW4oZ3JpZCwgc2VsZWN0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gZ3JpZFxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzU2VsZWN0aW9uQWxyZWFkeU9uRmlyc3RDZWxsOiBmdW5jdGlvbihncmlkLCBzZWxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbi5vcmlnaW4ueCA8PSAwICYmIHNlbGVjdGlvbi5vcmlnaW4ueSA8PSBncmlkLmdldEZpY3RpdmVIZWFkZXJSb3dzQ291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBoYW5kbGVDVFJMYTogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBjb25zdCBvbGRMYXN0U2VsZWN0aW9uID0gZ3JpZC5zZWxlY3Rpb25Nb2RlbC5nZXRMYXN0U2VsZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IG1heENvbHVtbldpdGhDb250ZW50ID0gZ3JpZC5iZWhhdmlvci5kYXRhTW9kZWwuZ2V0Q29sdW1uc1dpdGhWYWx1ZXNDb3VudCgpO1xuICAgICAgICBjb25zdCBtYXhSb3dXaXRoQ29udGVudCA9IGdyaWQuYmVoYXZpb3IuZGF0YU1vZGVsLmdldFJvd3NXaXRoVmFsdWVzQ291bnQoKTtcbiAgICAgICAgY29uc3QgZmljdGl2ZUhlYWRlclJvd3NDb3VudCA9IGdyaWQuZ2V0RmljdGl2ZUhlYWRlclJvd3NDb3VudCgpO1xuXG4gICAgICAgIGxldCBuZXdTZWxlY3Rpb25PcmlnaW5YID0gMCwgbmV3U2VsZWN0aW9uT3JpZ2luWSA9IDAsIG5ld1NlbGVjdGlvbkNvcm5lclggPSAwLCAgbmV3U2VsZWN0aW9uQ29ybmVyWSA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0aW9uSW5zaWRlRGF0YUFyZWEoZ3JpZCwgb2xkTGFzdFNlbGVjdGlvbilcbiAgICAgICAgICAgICYmICEodGhpcy5faXNTZWxlY3Rpb25BbHJlYWR5T25MYXN0RGF0YUNvbHVtbkFuZFJvdyhncmlkLCBvbGRMYXN0U2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICYmIHRoaXMuX2lzU2VsZWN0aW9uQWxyZWFkeU9uRmlyc3RDZWxsKGdyaWQsIG9sZExhc3RTZWxlY3Rpb24pKSkge1xuICAgICAgICAgICAgbmV3U2VsZWN0aW9uT3JpZ2luWCA9IDA7XG4gICAgICAgICAgICBuZXdTZWxlY3Rpb25PcmlnaW5ZID0gZmljdGl2ZUhlYWRlclJvd3NDb3VudDtcbiAgICAgICAgICAgIG5ld1NlbGVjdGlvbkNvcm5lclggPSBtYXhDb2x1bW5XaXRoQ29udGVudCAtIDE7XG4gICAgICAgICAgICBuZXdTZWxlY3Rpb25Db3JuZXJZID0gbWF4Um93V2l0aENvbnRlbnQgLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3U2VsZWN0aW9uT3JpZ2luWCA9IDA7XG4gICAgICAgICAgICBuZXdTZWxlY3Rpb25PcmlnaW5ZID0gMDtcbiAgICAgICAgICAgIG5ld1NlbGVjdGlvbkNvcm5lclggPSBncmlkLmdldENvbHVtbkNvdW50KCk7XG4gICAgICAgICAgICBuZXdTZWxlY3Rpb25Db3JuZXJZID0gZ3JpZC5nZXRSb3dDb3VudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0aW9uQWxyZWFkeU9uRmljdGl2ZUhlYWRlclJvdyhncmlkLCBvbGRMYXN0U2VsZWN0aW9uKVxuICAgICAgICAgICAgfHwgZ3JpZC5wcm9wZXJ0aWVzLnNlbGVjdEZpY3RpdmVIZWFkZXJDZWxsc0FzUmVndWxhcikge1xuICAgICAgICAgICAgbmV3U2VsZWN0aW9uT3JpZ2luWSA9IDA7XG4gICAgICAgICAgICBuZXdTZWxlY3Rpb25Db3JuZXJZICs9IGdyaWQuZ2V0RmljdGl2ZUhlYWRlclJvd3NDb3VudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMTEuMDUuMjAxOCAtIERvIG5vdCByZW1vdmUgY29tbWVudGVkIGNvZGUgeWV0XG4gICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uKCk7XG4gICAgICAgIGdyaWQuc2VsZWN0KG5ld1NlbGVjdGlvbk9yaWdpblgsIG5ld1NlbGVjdGlvbk9yaWdpblksIG5ld1NlbGVjdGlvbkNvcm5lclgsIG5ld1NlbGVjdGlvbkNvcm5lclkpO1xuICAgICAgICAvLyBncmlkLnNldE1vdXNlRG93bihncmlkLm5ld1BvaW50KG5ld1NlbGVjdGlvbk9yaWdpblgsIG5ld1NlbGVjdGlvbk9yaWdpblkpKTtcbiAgICAgICAgLy8gZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQobmV3U2VsZWN0aW9uQ29ybmVyWCwgbmV3U2VsZWN0aW9uQ29ybmVyWSkpO1xuICAgICAgICBncmlkLnNldE1vdXNlRG93bihncmlkLm5ld1BvaW50KG9sZExhc3RTZWxlY3Rpb24uZmlyc3RTZWxlY3RlZENlbGwueCwgb2xkTGFzdFNlbGVjdGlvbi5maXJzdFNlbGVjdGVkQ2VsbC55KSk7XG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KG5ld1NlbGVjdGlvbkNvcm5lclggLSBvbGRMYXN0U2VsZWN0aW9uLmZpcnN0U2VsZWN0ZWRDZWxsLngsXG4gICAgICAgICAgICBuZXdTZWxlY3Rpb25Db3JuZXJZIC0gb2xkTGFzdFNlbGVjdGlvbi5maXJzdFNlbGVjdGVkQ2VsbC55KSk7XG4gICAgICAgIGNvbnN0IG5ld0xhc3RTZWxlY3Rpb24gPSBncmlkLnNlbGVjdGlvbk1vZGVsLmdldExhc3RTZWxlY3Rpb24oKTtcbiAgICAgICAgbmV3TGFzdFNlbGVjdGlvbi5maXJzdFNlbGVjdGVkQ2VsbCA9IG9sZExhc3RTZWxlY3Rpb24uZmlyc3RTZWxlY3RlZENlbGw7XG4gICAgICAgIG5ld0xhc3RTZWxlY3Rpb24ubGFzdFNlbGVjdGVkQ2VsbCA9IG9sZExhc3RTZWxlY3Rpb24ubGFzdFNlbGVjdGVkQ2VsbDtcbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaGFuZGxlQ1RSTFVQOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGNvbnN0IGxhc3RTZWxlY3Rpb24gPSBncmlkLnNlbGVjdGlvbk1vZGVsLmdldExhc3RTZWxlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgbWF4Um93V2l0aENvbnRlbnQgPSBncmlkLmJlaGF2aW9yLmRhdGFNb2RlbC5nZXRSb3dzV2l0aFZhbHVlc0NvdW50KCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pc1NlbGVjdGlvbkluc2lkZURhdGFBcmVhKGdyaWQsIGxhc3RTZWxlY3Rpb24pXG4gICAgICAgICAgICB8fCBncmlkLnByb3BlcnRpZXMuaWdub3JlRGF0YUNlbGxzT25WZXJ0aWNhbEN0cmxTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChsYXN0U2VsZWN0aW9uLm9yaWdpbi54ID49IGdyaWQuYmVoYXZpb3IuZGF0YU1vZGVsLmdldENvbHVtbnNXaXRoVmFsdWVzQ291bnQoKVxuICAgICAgICAgICAgICAgIHx8IGdyaWQucHJvcGVydGllcy5pZ25vcmVEYXRhQ2VsbHNPblZlcnRpY2FsQ3RybFNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGdyaWQubW92ZVNpbmdsZVNlbGVjdCgwLCAtIE1hdGgubWF4KGxhc3RTZWxlY3Rpb24uY29ybmVyLnksIGxhc3RTZWxlY3Rpb24ub3JpZ2luLnkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5tb3ZlU2luZ2xlU2VsZWN0KDAsIC0gKE1hdGgubWF4KGxhc3RTZWxlY3Rpb24uY29ybmVyLnksIGxhc3RTZWxlY3Rpb24ub3JpZ2luLnkpIC0gbWF4Um93V2l0aENvbnRlbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGlvbkFscmVhZHlPbkZpY3RpdmVIZWFkZXJSb3coZ3JpZCwgbGFzdFNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICB8fCB0aGlzLl9pc1NlbGVjdGlvbkFscmVhZHlPbkZpcnN0RGF0YVJvdyhncmlkLCBsYXN0U2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgIHx8IGdyaWQucHJvcGVydGllcy5zZWxlY3RGaWN0aXZlSGVhZGVyQ2VsbHNBc1JlZ3VsYXIpIHtcbiAgICAgICAgICAgICAgICBncmlkLm1vdmVTaW5nbGVTZWxlY3QoMCwgLSBNYXRoLm1heChsYXN0U2VsZWN0aW9uLmNvcm5lci55LCBsYXN0U2VsZWN0aW9uLm9yaWdpbi55KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdyaWQubW92ZVNpbmdsZVNlbGVjdCgwLCAtIChNYXRoLm1heChsYXN0U2VsZWN0aW9uLmNvcm5lci55LCBsYXN0U2VsZWN0aW9uLm9yaWdpbi55KSAtIGdyaWQuZ2V0RmljdGl2ZUhlYWRlclJvd3NDb3VudCgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBoYW5kbGVDVFJMRE9XTjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBjb25zdCBsYXN0U2VsZWN0aW9uID0gZ3JpZC5zZWxlY3Rpb25Nb2RlbC5nZXRMYXN0U2VsZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IG1heFJvd1dpdGhDb250ZW50ID0gZ3JpZC5iZWhhdmlvci5kYXRhTW9kZWwuZ2V0Um93c1dpdGhWYWx1ZXNDb3VudCgpO1xuXG4gICAgICAgIGlmICghdGhpcy5faXNTZWxlY3Rpb25JbnNpZGVEYXRhQXJlYShncmlkLCBsYXN0U2VsZWN0aW9uKVxuICAgICAgICAgICAgfHwgdGhpcy5faXNTZWxlY3Rpb25BbHJlYWR5T25MYXN0RGF0YVJvdyhncmlkLCBsYXN0U2VsZWN0aW9uKVxuICAgICAgICAgICAgfHwgbGFzdFNlbGVjdGlvbi5vcmlnaW4ueCA+IGdyaWQuYmVoYXZpb3IuZGF0YU1vZGVsLmdldENvbHVtbnNXaXRoVmFsdWVzQ291bnQoKVxuICAgICAgICAgICAgfHwgZ3JpZC5wcm9wZXJ0aWVzLmlnbm9yZURhdGFDZWxsc09uVmVydGljYWxDdHJsU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBncmlkLm1vdmVTaW5nbGVTZWxlY3QoMCwgZ3JpZC5nZXRSb3dDb3VudCgpIC0gbGFzdFNlbGVjdGlvbi5sYXN0U2VsZWN0ZWRDZWxsLnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0aW9uQWxyZWFkeU9uRmljdGl2ZUhlYWRlclJvdyhncmlkLCBsYXN0U2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICYmICF0aGlzLl9pc1NlbGVjdGlvbkFscmVhZHlPbkZpcnN0RGF0YVJvdyhncmlkLCBsYXN0U2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICYmICFncmlkLnByb3BlcnRpZXMuc2VsZWN0RmljdGl2ZUhlYWRlckNlbGxzQXNSZWd1bGFyKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5tb3ZlU2luZ2xlU2VsZWN0KDAsIGdyaWQuZ2V0RmljdGl2ZUhlYWRlclJvd3NDb3VudCgpIC0gbGFzdFNlbGVjdGlvbi5sYXN0U2VsZWN0ZWRDZWxsLnkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncmlkLm1vdmVTaW5nbGVTZWxlY3QoMCwgbWF4Um93V2l0aENvbnRlbnQgLSBsYXN0U2VsZWN0aW9uLmxhc3RTZWxlY3RlZENlbGwueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBoYW5kbGVDVFJMUklHSFQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgY29uc3QgbGFzdFNlbGVjdGlvbiA9IGdyaWQuc2VsZWN0aW9uTW9kZWwuZ2V0TGFzdFNlbGVjdGlvbigpO1xuICAgICAgICBjb25zdCBtYXhDb2x1bW5XaXRoQ29udGVudCA9IGdyaWQuYmVoYXZpb3IuZGF0YU1vZGVsLmdldENvbHVtbnNXaXRoVmFsdWVzQ291bnQoKTtcblxuICAgICAgICBpZiAoIXRoaXMuX2lzU2VsZWN0aW9uSW5zaWRlRGF0YUFyZWEoZ3JpZCwgbGFzdFNlbGVjdGlvbilcbiAgICAgICAgICAgIHx8IHRoaXMuX2lzU2VsZWN0aW9uQWxyZWFkeU9uTGFzdERhdGFDb2x1bW4oZ3JpZCwgbGFzdFNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIGdyaWQubW92ZVNpbmdsZVNlbGVjdCgoZ3JpZC5nZXRDb2x1bW5Db3VudCgpIC0gbGFzdFNlbGVjdGlvbi5vcmlnaW4ueCksIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JpZC5tb3ZlU2luZ2xlU2VsZWN0KCgobWF4Q29sdW1uV2l0aENvbnRlbnQgLSAxKSAtIGxhc3RTZWxlY3Rpb24ub3JpZ2luLngpLCAwKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGhhbmRsZUNUUkxMRUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGNvbnN0IGxhc3RTZWxlY3Rpb24gPSBncmlkLnNlbGVjdGlvbk1vZGVsLmdldExhc3RTZWxlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgbWF4Q29sdW1uV2l0aENvbnRlbnQgPSBncmlkLmJlaGF2aW9yLmRhdGFNb2RlbC5nZXRDb2x1bW5zV2l0aFZhbHVlc0NvdW50KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0aW9uSW5zaWRlRGF0YUFyZWEoZ3JpZCwgbGFzdFNlbGVjdGlvbilcbiAgICAgICAgICAgIHx8IHRoaXMuX2lzU2VsZWN0aW9uQWxyZWFkeU9uTGFzdERhdGFDb2x1bW4oZ3JpZCwgbGFzdFNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIGdyaWQubW92ZVNpbmdsZVNlbGVjdCgtbGFzdFNlbGVjdGlvbi5jb3JuZXIueCwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBncmlkLm1vdmVTaW5nbGVTZWxlY3QoLShsYXN0U2VsZWN0aW9uLmNvcm5lci54IC0gKG1heENvbHVtbldpdGhDb250ZW50IC0gMSkpLCAwKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGhhbmRsZUNUUkxVUFNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGNvbnN0IGxhc3RTZWxlY3Rpb24gPSBncmlkLnNlbGVjdGlvbk1vZGVsLmdldExhc3RTZWxlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgbWF4Um93V2l0aENvbnRlbnQgPSBncmlkLmJlaGF2aW9yLmRhdGFNb2RlbC5nZXRSb3dzV2l0aFZhbHVlc0NvdW50KCk7XG5cblxuICAgICAgICBpZiAoIXRoaXMuX2lzU2VsZWN0aW9uSW5zaWRlRGF0YUFyZWEoZ3JpZCwgbGFzdFNlbGVjdGlvbilcbiAgICAgICAgICAgIHx8IGdyaWQucHJvcGVydGllcy5pZ25vcmVEYXRhQ2VsbHNPblZlcnRpY2FsQ3RybFNlbGVjdGlvbikge1xuICAgICAgICAgICAgaWYgKGxhc3RTZWxlY3Rpb24ub3JpZ2luLnggPj0gZ3JpZC5iZWhhdmlvci5kYXRhTW9kZWwuZ2V0Q29sdW1uc1dpdGhWYWx1ZXNDb3VudCgpXG4gICAgICAgICAgICAgICAgfHwgZ3JpZC5wcm9wZXJ0aWVzLmlnbm9yZURhdGFDZWxsc09uVmVydGljYWxDdHJsU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2hpZnRTZWxlY3QoZ3JpZCwgMCwgLSBNYXRoLm1heChsYXN0U2VsZWN0aW9uLmNvcm5lci55LCBsYXN0U2VsZWN0aW9uLm9yaWdpbi55KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIDAsIC0gKE1hdGgubWF4KGxhc3RTZWxlY3Rpb24uY29ybmVyLnksIGxhc3RTZWxlY3Rpb24ub3JpZ2luLnkpIC0gbWF4Um93V2l0aENvbnRlbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGlvbkFscmVhZHlPbkZpY3RpdmVIZWFkZXJSb3coZ3JpZCwgbGFzdFNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICB8fCB0aGlzLl9pc1NlbGVjdGlvbkFscmVhZHlPbkZpcnN0RGF0YVJvdyhncmlkLCBsYXN0U2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgIHx8IGdyaWQucHJvcGVydGllcy5zZWxlY3RGaWN0aXZlSGVhZGVyQ2VsbHNBc1JlZ3VsYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAwLCAtIE1hdGgubWF4KGxhc3RTZWxlY3Rpb24uY29ybmVyLnksIGxhc3RTZWxlY3Rpb24ub3JpZ2luLnkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2hpZnRTZWxlY3QoZ3JpZCwgMCwgLSAoTWF0aC5tYXgobGFzdFNlbGVjdGlvbi5jb3JuZXIueSwgbGFzdFNlbGVjdGlvbi5vcmlnaW4ueSkgLSBncmlkLmdldEZpY3RpdmVIZWFkZXJSb3dzQ291bnQoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaGFuZGxlQ1RSTERPV05TSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBjb25zdCBsYXN0U2VsZWN0aW9uID0gZ3JpZC5zZWxlY3Rpb25Nb2RlbC5nZXRMYXN0U2VsZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IG1heFJvd1dpdGhDb250ZW50ID0gZ3JpZC5iZWhhdmlvci5kYXRhTW9kZWwuZ2V0Um93c1dpdGhWYWx1ZXNDb3VudCgpO1xuXG4gICAgICAgIGlmICghdGhpcy5faXNTZWxlY3Rpb25JbnNpZGVEYXRhQXJlYShncmlkLCBsYXN0U2VsZWN0aW9uKVxuICAgICAgICAgICAgfHwgdGhpcy5faXNTZWxlY3Rpb25BbHJlYWR5T25MYXN0RGF0YVJvdyhncmlkLCBsYXN0U2VsZWN0aW9uKVxuICAgICAgICAgICAgfHwgbGFzdFNlbGVjdGlvbi5vcmlnaW4ueCA+IGdyaWQuYmVoYXZpb3IuZGF0YU1vZGVsLmdldENvbHVtbnNXaXRoVmFsdWVzQ291bnQoKVxuICAgICAgICAgICAgfHwgZ3JpZC5wcm9wZXJ0aWVzLmlnbm9yZURhdGFDZWxsc09uVmVydGljYWxDdHJsU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAwLCBncmlkLmdldFJvd0NvdW50KCkgLSBsYXN0U2VsZWN0aW9uLmxhc3RTZWxlY3RlZENlbGwueSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAwLCBtYXhSb3dXaXRoQ29udGVudCAtIGxhc3RTZWxlY3Rpb24ubGFzdFNlbGVjdGVkQ2VsbC55KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGhhbmRsZUNUUkxSSUdIVFNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGNvbnN0IGxhc3RTZWxlY3Rpb24gPSBncmlkLnNlbGVjdGlvbk1vZGVsLmdldExhc3RTZWxlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgbWF4Q29sdW1uV2l0aENvbnRlbnQgPSBncmlkLmJlaGF2aW9yLmRhdGFNb2RlbC5nZXRDb2x1bW5zV2l0aFZhbHVlc0NvdW50KCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pc1NlbGVjdGlvbkluc2lkZURhdGFBcmVhKGdyaWQsIGxhc3RTZWxlY3Rpb24pXG4gICAgICAgICAgICB8fCB0aGlzLl9pc1NlbGVjdGlvbkFscmVhZHlPbkxhc3REYXRhQ29sdW1uKGdyaWQsIGxhc3RTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAoZ3JpZC5nZXRDb2x1bW5Db3VudCgpIC0gbGFzdFNlbGVjdGlvbi5vcmlnaW4ueCksIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb3ZlU2hpZnRTZWxlY3QoZ3JpZCwgKChtYXhDb2x1bW5XaXRoQ29udGVudCAtIDEpIC0gbGFzdFNlbGVjdGlvbi5vcmlnaW4ueCksIDApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaGFuZGxlQ1RSTExFRlRTSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBjb25zdCBsYXN0U2VsZWN0aW9uID0gZ3JpZC5zZWxlY3Rpb25Nb2RlbC5nZXRMYXN0U2VsZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IG1heENvbHVtbldpdGhDb250ZW50ID0gZ3JpZC5iZWhhdmlvci5kYXRhTW9kZWwuZ2V0Q29sdW1uc1dpdGhWYWx1ZXNDb3VudCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGlvbkluc2lkZURhdGFBcmVhKGdyaWQsIGxhc3RTZWxlY3Rpb24pXG4gICAgICAgICAgICB8fCB0aGlzLl9pc1NlbGVjdGlvbkFscmVhZHlPbkxhc3REYXRhQ29sdW1uKGdyaWQsIGxhc3RTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAtbGFzdFNlbGVjdGlvbi5jb3JuZXIueCwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAtKGxhc3RTZWxlY3Rpb24uY29ybmVyLnggLSAobWF4Q29sdW1uV2l0aENvbnRlbnQgLSAxKSksIDApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVET1dOOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICAvL2tlZXAgdGhlIGJyb3dzZXIgdmlld3BvcnQgZnJvbSBhdXRvIHNjcm9sbGluZyBvbiBrZXkgZXZlbnRcbiAgICAgICAgZXZlbnQucHJpbWl0aXZlRXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuZ2V0QXV0b1Njcm9sbEFjY2VsZXJhdGlvbigpO1xuICAgICAgICBncmlkLm1vdmVTaW5nbGVTZWxlY3QoMCwgY291bnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlVVA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIC8va2VlcCB0aGUgYnJvd3NlciB2aWV3cG9ydCBmcm9tIGF1dG8gc2Nyb2xsaW5nIG9uIGtleSBldmVudFxuICAgICAgICBldmVudC5wcmltaXRpdmVFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5nZXRBdXRvU2Nyb2xsQWNjZWxlcmF0aW9uKCk7XG4gICAgICAgIGdyaWQubW92ZVNpbmdsZVNlbGVjdCgwLCAtY291bnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGhhbmRsZUxFRlQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgZ3JpZC5tb3ZlU2luZ2xlU2VsZWN0KC0xLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBoYW5kbGVSSUdIVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBncmlkLm1vdmVTaW5nbGVTZWxlY3QoMSwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIElmIHdlIGFyZSBob2xkaW5nIGRvd24gdGhlIHNhbWUgbmF2aWdhdGlvbiBrZXksIGFjY2VsZXJhdGUgdGhlIGluY3JlbWVudCB3ZSBzY3JvbGxcbiAgICAgKiAjIyMjIHJldHVybnM6IGludGVnZXJcbiAgICAgKi9cbiAgICBnZXRBdXRvU2Nyb2xsQWNjZWxlcmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgZWxhcHNlZCA9IHRoaXMuZ2V0QXV0b1Njcm9sbER1cmF0aW9uKCkgLyAyMDAwO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihlbGFwc2VkICogZWxhcHNlZCAqIGVsYXBzZWQgKiBlbGFwc2VkKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldCB0aGUgc3RhcnQgdGltZSB0byByaWdodCBub3cgd2hlbiB3ZSBpbml0aWF0ZSBhbiBhdXRvIHNjcm9sbFxuICAgICAqL1xuICAgIHNldEF1dG9TY3JvbGxTdGFydFRpbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNiQXV0b1N0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXBkYXRlIHRoZSBhdXRvc2Nyb2xsIHN0YXJ0IHRpbWUgaWYgd2UgaGF2ZW4ndCBhdXRvc2Nyb2xsZWQgd2l0aGluIHRoZSBsYXN0IDUwMG1zIG90aGVyd2lzZSB1cGRhdGUgdGhlIGN1cnJlbnQgYXV0b3Njcm9sbCB0aW1lXG4gICAgICovXG4gICAgcGluZ0F1dG9TY3JvbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAobm93IC0gdGhpcy5zYkxhc3RBdXRvID4gNTAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldEF1dG9TY3JvbGxTdGFydFRpbWUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNiTGFzdEF1dG8gPSBEYXRlLm5vdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhbnN3ZXIgaG93IGxvbmcgd2UgaGF2ZSBiZWVuIGF1dG8gc2Nyb2xsaW5nXG4gICAgICogIyMjIyByZXR1cm5zOiBpbnRlZ2VyXG4gICAgICovXG4gICAgZ2V0QXV0b1Njcm9sbER1cmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSB0aGlzLnNiTGFzdEF1dG8gPiA1MDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5zYkF1dG9TdGFydDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgQXVnbWVudCB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uIGV4dGVudCBieSAob2Zmc2V0WCxvZmZzZXRZKSBhbmQgc2Nyb2xsIGlmIG5lY2Vzc2FyeS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0geCBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSB5IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKi9cbiAgICBtb3ZlU2hpZnRTZWxlY3Q6IGZ1bmN0aW9uKGdyaWQsIG9mZnNldFgsIG9mZnNldFkpIHtcbiAgICAgICAgaWYgKGdyaWQuZXh0ZW5kU2VsZWN0KG9mZnNldFgsIG9mZnNldFkpKSB7XG4gICAgICAgICAgICB0aGlzLnBpbmdBdXRvU2Nyb2xsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENlbGxTZWxlY3Rpb247XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbi8qIGdsb2JhbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZScpO1xuXG52YXIgZHJhZ2dlcjtcbnZhciBkcmFnZ2VyQ1RYO1xudmFyIHBsYWNlaG9sZGVyO1xudmFyIHBsYWNlaG9sZGVyQ1RYO1xuXG52YXIgR1JBQiA9IFsnZ3JhYicsICctbW96LWdyYWInLCAnLXdlYmtpdC1ncmFiJ10sXG4gICAgR1JBQkJJTkcgPSBbJ2dyYWJiaW5nJywgJy1tb3otZ3JhYmJpbmcnLCAnLXdlYmtpdC1ncmFiYmluZyddO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRmVhdHVyZVxuICovXG52YXIgQ29sdW1uRml4YXRpb24gPSBGZWF0dXJlLmV4dGVuZCgnQ29sdW1uRml4YXRpb24nLCB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENvbHVtbkZpeGF0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRyYWdnaW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIGFuIG9mZnNldCB0byBwb3NpdGlvbiB0aGUgZHJhZ2dlciBmcm9tIHRoZSBjdXJzb3JcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5GaXhhdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkcmFnT2Zmc2V0OiAwLFxuXG4gICAgLyoqXG4gICAgICogY3VycmVudCBwb3NpdGlvbiAoaW5kZXgpIG9mIGFuIHBsYWNlaG9sZGVyXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uRml4YXRpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgY3VycmVudFBsYWNlaG9sZGVyQ29sdW1uUG9zOiAtMSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5GaXhhdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBmaXJlZCBldmVyeSB0aW1lIHdoZW4gZ3JpZCByZW5kZXJlZFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVHcmlkUmVuZGVyZWQ6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUFuaW1hdGlvblN1cHBvcnQoZ3JpZCk7XG5cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUdyaWRSZW5kZXJlZChncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtbkZpeGF0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGluaXRpYWxpemUgYW5pbWF0aW9uIHN1cHBvcnQgb24gdGhlIGdyaWRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGluaXRpYWxpemVBbmltYXRpb25TdXBwb3J0OiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlT3JVcGRhdGVEcmFnZ2VyKGdyaWQpO1xuICAgICAgICBpZiAoIXBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICBwbGFjZWhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgcGxhY2Vob2xkZXIuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcwcHgnKTtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzBweCcpO1xuICAgICAgICAgICAgcGxhY2Vob2xkZXIuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyQ1RYID0gcGxhY2Vob2xkZXIuZ2V0Q29udGV4dCgnMmQnLCB7IGFscGhhOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uRml4YXRpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRHJhZzogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtbkZpeGF0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5GaXhhdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlVXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5GaXhhdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VNb3ZlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VNb3ZlKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVDb2x1bW5SZXNpemVkRXZlbnQ6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGdyaWQucGFpbnROb3coKTtcbiAgICAgICAgdGhpcy5tb3ZlRHJhZ2dlcihncmlkLCB0aGlzLmdldFN0YXJ0QnlGaXhlZENvbHVtbnNDb3VudChncmlkKSwgZmFsc2UpO1xuXG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVDb2x1bW5SZXNpemVkRXZlbnQoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5GaXhhdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1dGlsaXR5IGZ1bmN0aW9uIHRvIG1vdmUgZHJhZ2dlciBiYXNlZCBvbiBjdXJyZW50IGN1cnNvciBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW4/fSBtb3ZlUGxhY2Vob2xkZXJOZWVkZWRcbiAgICAgKi9cbiAgICBtb3ZlRHJhZ2dlcjogZnVuY3Rpb24oZ3JpZCwgeCwgbW92ZVBsYWNlaG9sZGVyTmVlZGVkKSB7XG4gICAgICAgIG1vdmVQbGFjZWhvbGRlck5lZWRlZCA9IHR5cGVvZiBtb3ZlUGxhY2Vob2xkZXJOZWVkZWQgIT09ICd1bmRlZmluZWQnID8gbW92ZVBsYWNlaG9sZGVyTmVlZGVkIDogdHJ1ZTtcbiAgICAgICAgZHJhZ2dlci5zdHlsZS5sZWZ0ID0geCArIGdyaWQuY2FudmFzLnNpemUubGVmdCArICdweCc7XG5cbiAgICAgICAgaWYgKG1vdmVQbGFjZWhvbGRlck5lZWRlZCkge1xuICAgICAgICAgICAgdmFyIG5lYXJlc3RDb2x1bW5JbmRleCA9IHRoaXMuZ2V0TmVhcmVzdENvbHVtbkluZGV4KGdyaWQsIHgpO1xuICAgICAgICAgICAgaWYgKChuZWFyZXN0Q29sdW1uSW5kZXggIT09IHVuZGVmaW5lZCkgJiYgbmVhcmVzdENvbHVtbkluZGV4ICE9PSB0aGlzLmN1cnJlbnRQbGFjZWhvbGRlckNvbHVtblBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZVBsYWNlaG9sZGVyVG8oZ3JpZCwgbmVhcmVzdENvbHVtbkluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQbGFjZWhvbGRlckNvbHVtblBvcyA9IG5lYXJlc3RDb2x1bW5JbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uRml4YXRpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXRpbGl0eSBmdW5jdGlvbiB0byBtb3ZlIHBsYWNlaG9sZGVyIHRvIHRoZSBzdGFydCBjb29yZGluYXRlcyBvZiBjb2x1bW5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5cbiAgICAgKi9cbiAgICBtb3ZlUGxhY2Vob2xkZXJUbzogZnVuY3Rpb24oZ3JpZCwgY29sdW1uKSB7XG4gICAgICAgIHBsYWNlaG9sZGVyLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcblxuICAgICAgICB2YXIgbmV3U3RhcnRYID0gdGhpcy5nZXRTdGFydEJ5Q29sdW1uSW5kZXgoZ3JpZCwgY29sdW1uKTtcblxuICAgICAgICBwbGFjZWhvbGRlci5zdHlsZS5sZWZ0ID0gbmV3U3RhcnRYICsgJ3B4JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtbkZpeGF0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGNyZWF0ZSB0aGUgcGxhY2Vob2xkZXIgYmFzZWQgb24gY3VycmVudCBjb3VudCBvZiBmaXhlZCBjb2x1bW5zXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBjcmVhdGVQbGFjZWhvbGRlcjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB2YXIgd2lkdGggPSBncmlkLnByb3BlcnRpZXMuZml4ZWRMaW5lc0hXaWR0aDtcbiAgICAgICAgdmFyIGdyaWRIZWlnaHQgPSBncmlkLmRpdi5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHZhciBoZHBpUmF0aW8gPSBncmlkLmdldEhpRFBJKHBsYWNlaG9sZGVyQ1RYKTtcbiAgICAgICAgdmFyIGhlYWRlckhlaWdodCA9IGdyaWQuZ2V0Um93SGVpZ2h0KDApO1xuXG4gICAgICAgIHZhciBsb2NhdGlvbiA9IGdyaWQuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIHBsYWNlaG9sZGVyLnN0eWxlLnRvcCA9IGxvY2F0aW9uLnRvcCArICdweCc7XG4gICAgICAgIHBsYWNlaG9sZGVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBNYXRoLnJvdW5kKHdpZHRoICogaGRwaVJhdGlvKSArICdweCcpO1xuICAgICAgICBwbGFjZWhvbGRlci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIE1hdGgucm91bmQoZ3JpZEhlaWdodCAqIGhkcGlSYXRpbykgKyAncHgnKTtcbiAgICAgICAgcGxhY2Vob2xkZXIuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuXG4gICAgICAgIHBsYWNlaG9sZGVyQ1RYLmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgZ3JpZEhlaWdodCk7XG4gICAgICAgIHBsYWNlaG9sZGVyQ1RYLmZpbGxTdHlsZSA9IGdyaWQucHJvcGVydGllcy5jb2x1bW5GaXhhdGlvblBsYWNlaG9sZGVySGVhZGVyQ29sb3I7XG4gICAgICAgIHBsYWNlaG9sZGVyQ1RYLmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWFkZXJIZWlnaHQpO1xuICAgICAgICBwbGFjZWhvbGRlckNUWC5maWxsU3R5bGUgPSBncmlkLnByb3BlcnRpZXMuY29sdW1uRml4YXRpb25QbGFjZWhvbGRlckJvZHlDb2xvcjtcbiAgICAgICAgcGxhY2Vob2xkZXJDVFguZmlsbFJlY3QoMCwgaGVhZGVySGVpZ2h0LCB3aWR0aCwgZ3JpZEhlaWdodCk7XG5cbiAgICAgICAgcGxhY2Vob2xkZXJDVFguc2NhbGUoaGRwaVJhdGlvLCBoZHBpUmF0aW8pO1xuXG4gICAgICAgIHBsYWNlaG9sZGVyLnN0eWxlLnpJbmRleCA9ICc0JztcblxuICAgICAgICB0aGlzLm1vdmVQbGFjZWhvbGRlclRvKGdyaWQsIGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtbkZpeGF0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHV0aWxpdHkgZnVuY3Rpb24gZm9yIHNldHRpbmcgY3Jvc3MgYnJvd3NlciBjc3MgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBkZXNjcmlwdG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gdGhlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIGFzc2lnblxuICAgICAqL1xuICAgIHNldENyb3NzQnJvd3NlclByb3BlcnR5OiBmdW5jdGlvbihlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHVQcm9wZXJ0eSA9IHByb3BlcnR5WzBdLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zdWJzdHIoMSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcChlbGVtZW50LCAnd2Via2l0JyArIHVQcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnNldFByb3AoZWxlbWVudCwgJ01veicgKyB1UHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zZXRQcm9wKGVsZW1lbnQsICdtcycgKyB1UHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zZXRQcm9wKGVsZW1lbnQsICdPJyArIHVQcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnNldFByb3AoZWxlbWVudCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtbkZpeGF0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGNyZWF0ZSB0aGUgZHJhZ2dlZCBjb2x1bW4gYmFzZWQgb24gY3VycmVudCBjb3VudCBvZiBmaXhlZCBjb2x1bW5zXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBjcmVhdGVPclVwZGF0ZURyYWdnZXI6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZml4ZWRMaW5lc0hXaWR0aCA9IGdyaWQucHJvcGVydGllcy5maXhlZExpbmVzSFdpZHRoO1xuXG4gICAgICAgIGlmICghZHJhZ2dlcikge1xuICAgICAgICAgICAgZHJhZ2dlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgZHJhZ2dlckNUWCA9IGRyYWdnZXIuZ2V0Q29udGV4dCgnMmQnLCB7IGFscGhhOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZHJhZ2dlcik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmZpeGVkTGluZXNIV2lkdGg7XG4gICAgICAgIHZhciBzdGFydFggPSB0aGlzLmdldFN0YXJ0QnlGaXhlZENvbHVtbnNDb3VudChncmlkKTtcblxuICAgICAgICB2YXIgaGVhZGVySGVpZ2h0ID0gZ3JpZC5nZXRSb3dIZWlnaHQoMCk7XG4gICAgICAgIHZhciBncmlkSGVpZ2h0ID0gZ3JpZC5kaXYuY2xpZW50SGVpZ2h0O1xuXG4gICAgICAgIHZhciBoZHBpUmF0aW8gPSBncmlkLmdldEhpRFBJKGRyYWdnZXJDVFgpO1xuICAgICAgICB2YXIgbG9jYXRpb24gPSBncmlkLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBkcmFnZ2VyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAod2lkdGggKiBoZHBpUmF0aW8pICsgJ3B4Jyk7XG4gICAgICAgIGRyYWdnZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAoZ3JpZEhlaWdodCAqIGhkcGlSYXRpbykgKyAncHgnKTtcbiAgICAgICAgZHJhZ2dlci5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgIGRyYWdnZXIuc3R5bGUudG9wID0gbG9jYXRpb24udG9wICsgJ3B4JztcbiAgICAgICAgZHJhZ2dlci5zdHlsZS5sZWZ0ID0gc3RhcnRYICsgJ3B4JztcbiAgICAgICAgZHJhZ2dlci5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG5cbiAgICAgICAgZHJhZ2dlckNUWC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGdyaWRIZWlnaHQpO1xuICAgICAgICBkcmFnZ2VyQ1RYLmZpbGxTdHlsZSA9IGdyaWQucHJvcGVydGllcy5jb2x1bW5GaXhhdGlvbkRyYWdnZXJIZWFkZXJJbmFjdGl2ZUNvbG9yO1xuICAgICAgICBkcmFnZ2VyQ1RYLmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWFkZXJIZWlnaHQpO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgZHJhZ2dlci5vbm1vdXNlZW50ZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnNvciA9IEdSQUI7XG5cbiAgICAgICAgICAgICAgICBkcmFnZ2VyQ1RYLmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgZ3JpZEhlaWdodCk7XG4gICAgICAgICAgICAgICAgZHJhZ2dlckNUWC5maWxsU3R5bGUgPSBncmlkLnByb3BlcnRpZXMuY29sdW1uRml4YXRpb25EcmFnZ2VySGVhZGVySG92ZXJlZENvbG9yO1xuICAgICAgICAgICAgICAgIGRyYWdnZXJDVFguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlYWRlckhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZHJhZ2dlci5vbm1vdXNlbGVhdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5kcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICBzZWxmLmN1cnNvciA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBkcmFnZ2VyQ1RYLmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgZ3JpZEhlaWdodCk7XG4gICAgICAgICAgICAgICAgZHJhZ2dlckNUWC5maWxsU3R5bGUgPSBncmlkLnByb3BlcnRpZXMuY29sdW1uRml4YXRpb25EcmFnZ2VySGVhZGVySW5hY3RpdmVDb2xvcjtcbiAgICAgICAgICAgICAgICBkcmFnZ2VyQ1RYLmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWFkZXJIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGRyYWdnZXIub25tb3VzZWRvd24gPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBHUkFCQklORztcblxuICAgICAgICAgICAgc2VsZi5kcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgICAgIGdyaWQuc2Nyb2xsVG9NYWtlVmlzaWJsZShncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKSwgZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCkgLSAxKTtcblxuICAgICAgICAgICAgc2VsZi5jcmVhdGVQbGFjZWhvbGRlcihncmlkKTtcbiAgICAgICAgICAgIHNlbGYuZHJhZ09mZnNldCA9IGRyYWdnZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblxuICAgICAgICAgICAgZHJhZ2dlckNUWC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGdyaWRIZWlnaHQpO1xuICAgICAgICAgICAgZHJhZ2dlckNUWC5maWxsU3R5bGUgPSBncmlkLnByb3BlcnRpZXMuY29sdW1uRml4YXRpb25EcmFnZ2VySGVhZGVyRHJhZ2dpbmdDb2xvcjtcbiAgICAgICAgICAgIGRyYWdnZXJDVFguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlYWRlckhlaWdodCk7XG4gICAgICAgICAgICBkcmFnZ2VyQ1RYLmZpbGxTdHlsZSA9IGdyaWQucHJvcGVydGllcy5jb2x1bW5GaXhhdGlvbkRyYWdnZXJCb2R5RHJhZ2dpbmdDb2xvcjtcbiAgICAgICAgICAgIGRyYWdnZXJDVFguZmlsbFJlY3QoMCwgaGVhZGVySGVpZ2h0LCB3aWR0aCwgZ3JpZEhlaWdodCk7XG5cbiAgICAgICAgICAgIGRvY3VtZW50Lm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHZhciBwb3MxID0gZS5jbGllbnRYIC0gKGdyaWQucHJvcGVydGllcy5maXhlZExpbmVzSFdpZHRoIC8gMikgLSBncmlkLmNhbnZhcy5zaXplLmxlZnQ7XG5cbiAgICAgICAgICAgICAgICBzZWxmLm1vdmVEcmFnZ2VyKGdyaWQsIHBvczEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRvY3VtZW50Lm9ubW91c2V1cCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5vbm1vdXNlbW92ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQub25tb3VzZXVwID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wZXJmb3JtRml4YXRpb24oZ3JpZCk7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQucGFpbnROb3coKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tb3ZlRHJhZ2dlcihncmlkLCBzZWxmLmdldFN0YXJ0QnlGaXhlZENvbHVtbnNDb3VudChncmlkKSAtIGdyaWQuY2FudmFzLnNpemUubGVmdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJzb3IgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgZHJhZ2dlckNUWC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGdyaWRIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGRyYWdnZXJDVFguZmlsbFN0eWxlID0gZ3JpZC5wcm9wZXJ0aWVzLmNvbHVtbkZpeGF0aW9uRHJhZ2dlckhlYWRlckluYWN0aXZlQ29sb3I7XG4gICAgICAgICAgICAgICAgZHJhZ2dlckNUWC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVhZGVySGVpZ2h0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5GaXhhdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1dGlsaXR5IG1ldGhvZCB0byBnZXQgc3RhcnQgcG9zaXRpb24gb2YgdGhlIGRyYWdnZXIgYmFzZWQgb24gY3VycmVudCBmaXhlZCBjb2x1bW5zIGNvdW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBnZXRTdGFydEJ5Rml4ZWRDb2x1bW5zQ291bnQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhcnRCeUNvbHVtbkluZGV4KGdyaWQsIGdyaWQucHJvcGVydGllcy5maXhlZENvbHVtbkNvdW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtbkZpeGF0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHV0aWxpdHkgbWV0aG9kIHRvIGdldCBzdGFydCBwb3NpdGlvbiBvZiB0aGUgZHJhZ2dlciBiYXNlZCBvbiBjb2x1bW5JbmRleFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4XG4gICAgICovXG4gICAgZ2V0U3RhcnRCeUNvbHVtbkluZGV4OiBmdW5jdGlvbihncmlkLCBjb2x1bW5JbmRleCkge1xuICAgICAgICBpZiAoY29sdW1uSW5kZXggPCAwKSB7XG4gICAgICAgICAgICBjb2x1bW5JbmRleCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29sdW1uLCByZXM7XG4gICAgICAgIGlmIChjb2x1bW5JbmRleCA+IDApIHtcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBkZXRlY3QgY29sdW1uIGFuZCB1c2UgaXQncyByaWdodCBzaWRlXG4gICAgICAgICAgICBjb2x1bW4gPSBncmlkLnJlbmRlcmVyLnZpc2libGVDb2x1bW5zW2NvbHVtbkluZGV4IC0gMV07XG4gICAgICAgICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IGdyaWQucmVuZGVyZXIudmlzaWJsZUNvbHVtbnNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSBjb2x1bW4gPyBjb2x1bW4ucmlnaHQgOiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgbm8gc2VsZWN0aW9uIHVzZSBsZWZ0IHNpZGUgb2YgZmlyc3QgY29sdW1uXG4gICAgICAgICAgICByZXMgPSBncmlkLnJlbmRlcmVyLnZpc2libGVDb2x1bW5zWzBdLmxlZnQgLSB0aGlzLmZpeGVkTGluZXNIV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzICsgZ3JpZC5jYW52YXMuc2l6ZS5sZWZ0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uRml4YXRpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXRpbGl0eSBtZXRob2QgdG8gc2V0IGdyaWQgb3B0aW9ucyB3aGVuIGRyYWdnaW5nIGVuZHNcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIHBlcmZvcm1GaXhhdGlvbjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB2YXIgY3VycmVudEZpeGVkQ29sdW1uQ291bnQgPSBncmlkLnByb3BlcnRpZXMuZml4ZWRDb2x1bW5Db3VudDtcbiAgICAgICAgZ3JpZC5hZGRQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIGZpeGVkQ29sdW1uQ291bnQ6IHRoaXMuY3VycmVudFBsYWNlaG9sZGVyQ29sdW1uUG9zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBsYWNlaG9sZGVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgZ3JpZC5maXJlU3ludGhldGljT25GaXhlZENvbHVtbkNvdW50Q2hhbmdlZEV2ZW50KGN1cnJlbnRGaXhlZENvbHVtbkNvdW50LCB0aGlzLmN1cnJlbnRQbGFjZWhvbGRlckNvbHVtblBvcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5GaXhhdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1dGlsaXR5IGZ1bmN0aW9uIHRvIGdldCBuZWFyZXN0IHBvc3NpYmxlIGluZGV4IGZyb20gYW4gY3Vyc29yIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIGhvcml6b250YWwgY3Vyc29yIHBvc2l0aW9uXG4gICAgICovXG4gICAgZ2V0TmVhcmVzdENvbHVtbkluZGV4OiBmdW5jdGlvbihncmlkLCB4KSB7XG4gICAgICAgIHZhciBjb2x1bW5VbmRlckN1cnNvckluZGV4ID0gZ3JpZC5yZW5kZXJlci5nZXRDb2x1bW5Gcm9tUGl4ZWxYKHgpO1xuICAgICAgICB2YXIgdmlzaWJsZUNvbHVtbnMgPSBncmlkLnJlbmRlcmVyLnZpc2libGVDb2x1bW5zO1xuXG4gICAgICAgIHZhciBtYXggPSBncmlkLmdldFZpc2libGVDb2x1bW5zQ291bnQoKTtcbiAgICAgICAgdmFyIGNvbHVtblN0YXJ0WCA9IHZpc2libGVDb2x1bW5zW01hdGgubWluKG1heCwgY29sdW1uVW5kZXJDdXJzb3JJbmRleCldLmxlZnQ7XG4gICAgICAgIHZhciBjb2x1bW5FbmRYID0gdmlzaWJsZUNvbHVtbnNbTWF0aC5taW4obWF4LCBjb2x1bW5VbmRlckN1cnNvckluZGV4KV0ucmlnaHQ7XG5cbiAgICAgICAgdmFyIHJlcyA9IGNvbHVtblVuZGVyQ3Vyc29ySW5kZXg7XG5cbiAgICAgICAgaWYgKCEoTWF0aC5hYnMoY29sdW1uU3RhcnRYIC0geCkgPCBNYXRoLmFicyhjb2x1bW5FbmRYIC0geCkpKSB7XG4gICAgICAgICAgICByZXMgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXMgPj0gdmlzaWJsZUNvbHVtbnNbdmlzaWJsZUNvbHVtbnMubGVuZ3RoIC0gMV0uY29sdW1uSW5kZXgpIHtcbiAgICAgICAgICAgIHJlcyA9IHZpc2libGVDb2x1bW5zW3Zpc2libGVDb2x1bW5zLmxlbmd0aCAtIDJdLmNvbHVtbkluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuXG4gICAgc2V0UHJvcDogZnVuY3Rpb24oZWxlbWVudCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eSBpbiBlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uRml4YXRpb247XG5cbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuLyogZ2xvYmFsIHJlcXVlc3RBbmltYXRpb25GcmFtZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgZmVhdHVyZSBpcyByZXNwb25zaWJsZSBmb3IgY29sdW1uIGRyYWcgYW5kIGRyb3AgcmVvcmRlcmluZy5cbi8vIFRoaXMgb2JqZWN0IGlzIGEgbWVzcyBhbmQgZGVzcGVyYXRlbHkgbmVlZHMgYSBjb21wbGV0ZSByZXdyaXRlLi4uLi5cblxuY29uc3QgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZScpO1xuXG5jb25zdCBHUkFCID0gWydncmFiJywgJy1tb3otZ3JhYicsICctd2Via2l0LWdyYWInXSxcbiAgICBHUkFCQklORyA9IFsnZ3JhYmJpbmcnLCAnLW1vei1ncmFiYmluZycsICctd2Via2l0LWdyYWJiaW5nJ10sXG4gICAgc2V0TmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHsgdGhpcy5jdXJzb3IgPSBuYW1lOyB9O1xuXG5sZXQgZHJhZ2dlcixcbiAgICBkcmFnZ2VyQ1RYLFxuICAgIHBsYWNlaG9sZGVyLFxuICAgIHBsYWNlaG9sZGVyQ1RYO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRmVhdHVyZVxuICovXG5jb25zdCBDb2x1bW5Nb3ZpbmcgPSBGZWF0dXJlLmV4dGVuZCgnQ29sdW1uTW92aW5nJywge1xuXG4gICAgLyoqXG4gICAgICogcXVldWUgdXAgdGhlIGFuaW1hdGlvbnMgdGhhdCBuZWVkIHRvIHBsYXkgc28gdGhleSBhcmUgZG9uZSBzeW5jaHJvbm91c2x5XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5Nb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZmxvYXRlckFuaW1hdGlvblF1ZXVlOiBbXSxcblxuICAgIC8qKlxuICAgICAqIGFtIEkgY3VycmVudGx5IGF1dG8gc2Nyb2xsaW5nIHJpZ2h0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENvbHVtbk1vdmluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjb2x1bW5EcmFnQXV0b1Njcm9sbGluZ1JpZ2h0OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIGFtIEkgY3VycmVudGx5IGF1dG8gc2Nyb2xsaW5nIGxlZnRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uTW92aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nTGVmdDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBhbSBJIGRyYWdnaW5nIHJpZ2h0IG5vd1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5Nb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ2dpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogdGhlIGNvbHVtbiBpbmRleCBvZiB0aGUgY3VycmVudGx5IGRyYWdnZWQgY29sdW1uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uTW92aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRyYWdDb2w6IC0xLFxuXG4gICAgLyoqXG4gICAgICogYW4gb2Zmc2V0IHRvIHBvc2l0aW9uIHRoZSBkcmFnZ2VkIGl0ZW0gZnJvbSB0aGUgY3Vyc29yXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uTW92aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRyYWdPZmZzZXQ6IDAsXG5cbiAgICBtaW5TY3JvbGxEZWxheTogMzAsXG4gICAgbWF4U2Nyb2xsRGVsYXk6IDEwMCxcbiAgICBzY3JvbGxBdHRlbXB0OiAwLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtbk1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBnaXZlIG1lIGFuIG9wcG9ydHVuaXR5IHRvIGluaXRpYWxpemUgc3R1ZmYgb24gdGhlIGdyaWRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGluaXRpYWxpemVPbjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVBbmltYXRpb25TdXBwb3J0KGdyaWQpO1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaW5pdGlhbGl6ZU9uKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5Nb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgaW5pdGlhbGl6ZSBhbmltYXRpb24gc3VwcG9ydCBvbiB0aGUgZ3JpZFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZUFuaW1hdGlvblN1cHBvcnQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgaWYgKCFkcmFnZ2VyKSB7XG4gICAgICAgICAgICBkcmFnZ2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBkcmFnZ2VyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMHB4Jyk7XG4gICAgICAgICAgICBkcmFnZ2VyLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzBweCcpO1xuICAgICAgICAgICAgZHJhZ2dlci5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZHJhZ2dlcik7XG4gICAgICAgICAgICBkcmFnZ2VyQ1RYID0gZHJhZ2dlci5nZXRDb250ZXh0KCcyZCcsIHsgYWxwaGE6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgcGxhY2Vob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMHB4Jyk7XG4gICAgICAgICAgICBwbGFjZWhvbGRlci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcwcHgnKTtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcblxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICBwbGFjZWhvbGRlckNUWCA9IHBsYWNlaG9sZGVyLmdldENvbnRleHQoJzJkJywgeyBhbHBoYTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5Nb3ZpbmcucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRHJhZzogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcblxuICAgICAgICBpZiAoZXZlbnQuaXNDb2x1bW5GaXhlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURyYWcoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdDb2x1bW4oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5Nb3ZpbmcucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZ3JpZC5iZWhhdmlvci5pc0NvbHVtblJlb3JkZXJhYmxlKCkgJiZcbiAgICAgICAgICAgICFldmVudC5pc0NvbHVtbkZpeGVkICYmXG4gICAgICAgICAgICBldmVudC5pc0hlYWRlckNlbGwgJiZcbiAgICAgICAgICAgICFldmVudC5pc0NvbHVtbkZpeGVkICYmXG4gICAgICAgICAgICAhZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmlzUmlnaHRDbGlja1xuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0IGRyYWdnaW5nXG4gICAgICAgICAgICBjb25zdCBncmlkQ2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBHUkFCQklORztcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kcmFnQ29sID0gZ3JpZENlbGwueDtcblxuICAgICAgICAgICAgY29uc3QgZmlyc3RTZWxlY3RlZENvbHVtbiA9IGdyaWQuZ2V0U2VsZWN0ZWRDb2x1bW5zKClbMF0gfHxcbiAgICAgICAgICAgICAgICBncmlkLnJlbmRlcmVyLnZpc2libGVDb2x1bW5zLmZpbmRJbmRleChmdW5jdGlvbihjKSB7cmV0dXJuIGMuY29sdW1uID09PSBldmVudC5jb2x1bW47fSk7XG4gICAgICAgICAgICBjb25zdCBoU2Nyb2xsT2Zmc2V0ID0gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0U2VsZWN0ZWRDb2x1bW5YID0gZ3JpZC5yZW5kZXJlci52aXNpYmxlQ29sdW1uc1tNYXRoLm1heCgwLCBmaXJzdFNlbGVjdGVkQ29sdW1uIC0gaFNjcm9sbE9mZnNldCldLmxlZnQ7XG5cbiAgICAgICAgICAgIHRoaXMuZHJhZ09mZnNldCA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZS54IC0gZmlyc3RTZWxlY3RlZENvbHVtblg7XG5cbiAgICAgICAgICAgIHRoaXMuZGV0YWNoQ2hhaW4oKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRHJhZ0NvbHVtbihncmlkLCB0aGlzLmRyYWdDb2wpO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVQbGFjZWhvbGRlcihncmlkLCB0aGlzLmRyYWdDb2wpO1xuICAgICAgICAgICAgdGhpcy5kcmFnQ29sdW1uKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICAvL3ZhciBjb2wgPSBldmVudC5ncmlkQ2VsbC54O1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICAgICAgLy9kZWxheSBoZXJlIHRvIGdpdmUgb3RoZXIgZXZlbnRzIGEgY2hhbmNlIHRvIGJlIGRyb3BwZWRcbiAgICAgICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5lbmREcmFnQ29sdW1uKGdyaWQpO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmF0dGFjaENoYWluKCk7XG4gICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhZ0NvbCA9IC0xO1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG5cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlVXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtbk1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VNb3ZlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBldmVudC5pc0NvbHVtblNlbGVjdGVkICYmXG4gICAgICAgICAgICBncmlkLmJlaGF2aW9yLmlzQ29sdW1uUmVvcmRlcmFibGUoKSAmJlxuICAgICAgICAgICAgIWV2ZW50LmlzQ29sdW1uRml4ZWQgJiZcbiAgICAgICAgICAgICF0aGlzLmRyYWdnaW5nICYmXG4gICAgICAgICAgICBldmVudC5pc0hlYWRlckNlbGxcbiAgICAgICAgICAgIC8vICYmIGV2ZW50Lm1vdXNlUG9pbnQueSA8IGdyaWQucHJvcGVydGllcy5jb2x1bW5HcmFiTWFyZ2luXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBHUkFCO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlTW92ZShncmlkLCBldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuaXNIZWFkZXJDZWxsICYmIHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gR1JBQkJJTkc7IC8vbW92ZSc7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtbk1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGlzIHRoZSBtYWluIGV2ZW50IGhhbmRsZXIgdGhhdCBtYW5hZ2VzIHRoZSBkcmFnZ2luZyBvZiB0aGUgY29sdW1uIGFuZCBtb3Zpbmcgb2YgcGxhY2Vob2xkZXJcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIG1vdmVQbGFjZWhvbGRlclRvOiBmdW5jdGlvbihncmlkLCBvdmVyQ29sKSB7XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyTGluZVdpZHRoID0gZ3JpZC5wcm9wZXJ0aWVzLmNvbHVtbk1vdmVJbnNlcnRMaW5lV2lkdGg7XG4gICAgICAgIGNvbnN0IHZpc2libGVDb2x1bW5zID0gZ3JpZC5yZW5kZXJlci52aXNpYmxlQ29sdW1ucztcblxuICAgICAgICBjb25zdCBkID0gcGxhY2Vob2xkZXI7XG4gICAgICAgIGQuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuXG4gICAgICAgIGxldCBzY3JvbGxMZWZ0ID0gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgY29uc3QgZml4ZWRDb2x1bW5Db3VudCA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICBpZiAob3ZlckNvbCA8IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHg7XG4gICAgICAgIGlmIChvdmVyQ29sID49IHNjcm9sbExlZnQgKyB2aXNpYmxlQ29sdW1ucy5sZW5ndGgpe1xuICAgICAgICAgICAgY29uc3QgbGFzdENvbHVtbiA9IHZpc2libGVDb2x1bW5zW3Zpc2libGVDb2x1bW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgeCA9IGxhc3RDb2x1bW4ubGVmdCArIGxhc3RDb2x1bW4ud2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgc3VwcG9ydGluZ0NvbHVtbiA9IHZpc2libGVDb2x1bW5zW292ZXJDb2wgLSBzY3JvbGxMZWZ0XTtcbiAgICAgICAgICAgIGlmICghc3VwcG9ydGluZ0NvbHVtbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHggPSBzdXBwb3J0aW5nQ29sdW1uLmxlZnQgKyBwbGFjZWhvbGRlckxpbmVXaWR0aCAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldENyb3NzQnJvd3NlclByb3BlcnR5KGQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB4ICsgJ3B4LCAnICsgMCArICdweCknKTtcbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5Nb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgY3JlYXRlIHRoZSBwbGFjZWhvbGRlciBhdCBjb2x1bW5JbmRleCB3aGVyZSBjb2x1bW4ocykgc2hvdWxkIGJlIG1vdmVkIHRvXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXggLSB0aGUgaW5kZXggb2YgdGhlIGNvbHVtbiBhZnRlciB3aGljaFxuICAgICAqL1xuICAgIGNyZWF0ZVBsYWNlaG9sZGVyOiBmdW5jdGlvbihncmlkLCBjb2x1bW5JbmRleCkge1xuICAgICAgICBjb25zdCBmaXhlZENvbHVtbkNvdW50ID0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIGxldCBzY3JvbGxMZWZ0ID0gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcblxuICAgICAgICBpZiAoY29sdW1uSW5kZXggPCBmaXhlZENvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICBzY3JvbGxMZWZ0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdpZHRoID0gZ3JpZC5wcm9wZXJ0aWVzLmNvbHVtbk1vdmVJbnNlcnRMaW5lV2lkdGg7XG4gICAgICAgIGxldCBjb2xIZWlnaHQgPSBncmlkLmRpdi5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IGQgPSBwbGFjZWhvbGRlcjtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBkLnN0eWxlO1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGdyaWQuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIGxldCBoZWlnaHRUb1NraXAgPSAwO1xuICAgICAgICBjb25zdCByb3dzVG9Ta2lwID0gZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3NUb1NraXA7IGkrKykge1xuICAgICAgICAgICAgaGVpZ2h0VG9Ta2lwICs9IGdyaWQuZ2V0Um93SGVpZ2h0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncmlkLnByb3BlcnRpZXMuZ3JpZExpbmVzSCAmJiBncmlkLnByb3BlcnRpZXMuZ3JpZExpbmVzV2lkdGgpIHtcbiAgICAgICAgICAgIGhlaWdodFRvU2tpcCArPSBncmlkLnByb3BlcnRpZXMuZ3JpZExpbmVzV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgY29sSGVpZ2h0IC09IGhlaWdodFRvU2tpcDtcblxuICAgICAgICBzdHlsZS50b3AgPSAobG9jYXRpb24udG9wICsgaGVpZ2h0VG9Ta2lwKSArICdweCc7XG4gICAgICAgIHN0eWxlLmxlZnQgPSBsb2NhdGlvbi5sZWZ0IC0gMiArICdweCc7XG5cbiAgICAgICAgY29uc3QgaGRwaVJhdGlvID0gZ3JpZC5nZXRIaURQSShwbGFjZWhvbGRlckNUWCk7XG5cbiAgICAgICAgZC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgTWF0aC5yb3VuZCh3aWR0aCAqIGhkcGlSYXRpbykgKyAncHgnKTtcbiAgICAgICAgZC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIE1hdGgucm91bmQoY29sSGVpZ2h0ICogaGRwaVJhdGlvKSArICdweCcpO1xuICAgICAgICAvLyBzdHlsZS5ib3hTaGFkb3cgPSAnMCAxMHB4IDIwcHggcmdiYSgwLDAsMCwwLjE5KSwgMCA2cHggNnB4IHJnYmEoMCwwLDAsMC4yMyknO1xuICAgICAgICBzdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JzsgLy9NYXRoLnJvdW5kKGNvbHVtbldpZHRoIC8gaGRwaVJhdGlvKSArICdweCc7XG4gICAgICAgIHN0eWxlLmhlaWdodCA9IGNvbEhlaWdodCArICdweCc7IC8vTWF0aC5yb3VuZChjb2xIZWlnaHQgLyBoZHBpUmF0aW8pICsgJ3B4JztcbiAgICAgICAgc3R5bGUuYmFja2dyb3VuZENvbG9yID0gZ3JpZC5wcm9wZXJ0aWVzLmNvbHVtbk1vdmVJbnNlcnRMaW5lQ29sb3I7XG5cbiAgICAgICAgbGV0IHN0YXJ0WCA9IGdyaWQucmVuZGVyZXIudmlzaWJsZUNvbHVtbnNbY29sdW1uSW5kZXggLSBzY3JvbGxMZWZ0XS5sZWZ0ICogaGRwaVJhdGlvO1xuXG4gICAgICAgIHBsYWNlaG9sZGVyQ1RYLnNjYWxlKGhkcGlSYXRpbywgaGRwaVJhdGlvKTtcblxuICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmZsb2F0ZXIgPSB7XG4gICAgICAgICAgICBjb2x1bW5JbmRleDogY29sdW1uSW5kZXgsXG4gICAgICAgICAgICBzdGFydFg6IHN0YXJ0WFxuICAgICAgICB9O1xuXG4gICAgICAgIHN0eWxlLnpJbmRleCA9ICc0JztcbiAgICAgICAgR1JBQkJJTkcuZm9yRWFjaChzZXROYW1lLCBzdHlsZSk7XG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHV0aWxpdHkgZnVuY3Rpb24gZm9yIHNldHRpbmcgY3Jvc3MgYnJvd3NlciBjc3MgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBkZXNjcmlwdG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gdGhlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIGFzc2lnblxuICAgICAqL1xuICAgIHNldENyb3NzQnJvd3NlclByb3BlcnR5OiBmdW5jdGlvbihlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdVByb3BlcnR5ID0gcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnN1YnN0cigxKTtcbiAgICAgICAgdGhpcy5zZXRQcm9wKGVsZW1lbnQsICd3ZWJraXQnICsgdVByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcChlbGVtZW50LCAnTW96JyArIHVQcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnNldFByb3AoZWxlbWVudCwgJ21zJyArIHVQcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnNldFByb3AoZWxlbWVudCwgJ08nICsgdVByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcChlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHV0aWxpdHkgZnVuY3Rpb24gZm9yIHNldHRpbmcgcHJvcGVydGllcyBvbiBIVE1MRWxlbWVudHNcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZGVzY3JpcHRvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBhc3NpZ25cbiAgICAgKi9cbiAgICBzZXRQcm9wOiBmdW5jdGlvbihlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5IGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtbk1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBjcmVhdGUgdGhlIGRyYWdnZWQgY29sdW1uIGF0IGNvbHVtbkluZGV4IGFib3ZlIHRoZSBmbG9hdGVkIGNvbHVtblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSBjb2x1bW4gdGhhdCB3aWxsIGJlIGZsb2F0aW5nXG4gICAgICovXG4gICAgY3JlYXRlRHJhZ0NvbHVtbjogZnVuY3Rpb24oZ3JpZCwgY29sdW1uSW5kZXgpIHtcbiAgICAgICAgY29uc3QgaGRwaVJhdGlvID0gZ3JpZC5nZXRIaURQSShkcmFnZ2VyQ1RYKTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRDb2x1bW5zID0gZ3JpZC5nZXRTZWxlY3RlZENvbHVtbnMoKTtcbiAgICAgICAgY29uc3QgY29uc2VxdWVudCA9IHRoaXMuX2lzQ29uc2VxdWVudChzZWxlY3RlZENvbHVtbnMpO1xuICAgICAgICBjb25zdCBjb2x1bW5zID0gY29uc2VxdWVudCA/IHNlbGVjdGVkQ29sdW1ucyA6IFtjb2x1bW5JbmRleF07XG5cbiAgICAgICAgbGV0IGNvbHVtbldpZHRoID0gMDtcbiAgICAgICAgY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uKGNvbCl7XG4gICAgICAgICAgICBjb2x1bW5XaWR0aCArPSBncmlkLmdldENvbHVtbldpZHRoKGNvbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGNvbEhlaWdodCA9IGdyaWQuZGl2LmNsaWVudEhlaWdodDtcbiAgICAgICAgY29uc3QgZCA9IGRyYWdnZXI7XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gZ3JpZC5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZC5zdHlsZTtcbiAgICAgICAgLy8gb2Zmc2V0IGZyb20gdG9wICsgaGVhZGVyIGhlaWdodFxuICAgICAgICBjb25zdCBvZmZzZXRZID0gZ3JpZC5nZXRGaXhlZFJvd3NIZWlnaHQoKTtcbiAgICAgICAgc3R5bGUudG9wID0gbG9jYXRpb24udG9wICsgb2Zmc2V0WSArICdweCc7XG4gICAgICAgIHN0eWxlLmxlZnQgPSBsb2NhdGlvbi5sZWZ0ICsgJ3B4JztcbiAgICAgICAgc3R5bGUub3BhY2l0eSA9IDAuMTU7XG4gICAgICAgIHN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgIzQyODVGNCc7XG4gICAgICAgIHN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2IoMCwgMCwgMCknO1xuXG4gICAgICAgIGQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIE1hdGgucm91bmQoY29sdW1uV2lkdGggKiBoZHBpUmF0aW8pICsgJ3B4Jyk7XG4gICAgICAgIGQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBNYXRoLnJvdW5kKGNvbEhlaWdodCAqIGhkcGlSYXRpbykgKyAncHgnKTtcblxuICAgICAgICBzdHlsZS53aWR0aCA9IGNvbHVtbldpZHRoICsgJ3B4JzsgLy9NYXRoLnJvdW5kKGNvbHVtbldpZHRoIC8gaGRwaVJhdGlvKSArICdweCc7XG4gICAgICAgIHN0eWxlLmhlaWdodCA9IGNvbEhlaWdodCAtIG9mZnNldFkgKyAncHgnOyAvL01hdGgucm91bmQoY29sSGVpZ2h0IC8gaGRwaVJhdGlvKSArICdweCc7XG5cbiAgICAgICAgZHJhZ2dlckNUWC5zY2FsZShoZHBpUmF0aW8sIGhkcGlSYXRpbyk7XG5cbiAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyID0ge1xuICAgICAgICAgICAgY29sdW1uSW5kZXg6IGNvbHVtbkluZGV4LFxuICAgICAgICAgICAgc3RhcnRJbmRleDogY29sdW1uSW5kZXhcbiAgICAgICAgfTtcblxuICAgICAgICAvLyB0aGlzLnNldENyb3NzQnJvd3NlclByb3BlcnR5KGQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB4ICsgJ3B4LCAtNXB4KScpO1xuICAgICAgICBzdHlsZS56SW5kZXggPSAnNSc7XG4gICAgICAgIEdSQUJCSU5HLmZvckVhY2goc2V0TmFtZSwgc3R5bGUpO1xuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtbk1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBtYWluIGRyYWdnaW5nIGxvZ2ljXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBkcmFnZ2luZyBldmVudFxuICAgICAqL1xuICAgIGRyYWdDb2x1bW46IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHggPSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueDtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB4IC0gdGhpcy5kcmFnT2Zmc2V0O1xuXG4gICAgICAgIGNvbnN0IGF1dG9TY3JvbGxpbmdOb3cgPSB0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nUmlnaHQgfHwgdGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ0xlZnQ7XG4gICAgICAgIGNvbnN0IGRyYWdDb2x1bW5JbmRleCA9IGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5zdGFydEluZGV4O1xuXG4gICAgICAgIGNvbnN0IG1pblggPSAwO1xuICAgICAgICBjb25zdCBtYXhYID0gZ3JpZC5yZW5kZXJlci5nZXRGaW5hbFZpc2libGVDb2x1bW5Cb3VuZGFyeSgpO1xuXG4gICAgICAgIGNvbnN0IGQgPSBkcmFnZ2VyO1xuXG4gICAgICAgIHRoaXMuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIGRpc3RhbmNlICsgJ3B4LCAnICsgMCArICdweCknKTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZC5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHRocmVzaG9sZCA9IDIwO1xuICAgICAgICBpZiAoeCA8IG1pblggKyB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tBdXRvU2Nyb2xsVG9MZWZ0KGdyaWQsIHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4ID4gbWluWCArIHRocmVzaG9sZCkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ0xlZnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRTY3JvbGxEZWxheSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4ID4gbWF4WCAtIHRocmVzaG9sZCkge1xuICAgICAgICAgICAgdGhpcy5jaGVja0F1dG9TY3JvbGxUb1JpZ2h0KGdyaWQsIHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4IDwgbWF4WCAtIHRocmVzaG9sZCkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ1JpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJlc2V0U2Nyb2xsRGVsYXkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvdmVyQ29sID0gZ3JpZC5yZW5kZXJlci5nZXRDb2x1bW5Gcm9tUGl4ZWxYKHgpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZENvbHVtbnMgPSBncmlkLmdldFNlbGVjdGVkQ29sdW1ucygpO1xuICAgICAgICBjb25zdCB2aXNpYmxlQ29sdW1ucyA9IGdyaWQucmVuZGVyZXIudmlzaWJsZUNvbHVtbnM7XG4gICAgICAgIGxldCBwbGFjZWhvbGRlckNvbCA9IC0xO1xuICAgICAgICBpZiAoIWF1dG9TY3JvbGxpbmdOb3cpIHtcbiAgICAgICAgICAgIGlmICghc2VsZWN0ZWRDb2x1bW5zLnNsaWNlKDEpLmluY2x1ZGVzKG92ZXJDb2wpKXtcbiAgICAgICAgICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuY29sdW1uSW5kZXggPSBvdmVyQ29sO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRyYWdnZWRUb1RoZVJpZ2h0ID0gZHJhZ0NvbHVtbkluZGV4IDwgb3ZlckNvbDtcbiAgICAgICAgICAgICAgICBpZiAoZHJhZ2dlZFRvVGhlUmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlckNvbCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckNvbCA9IG92ZXJDb2w7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0U2VsZWN0ZWRDb2x1bW5JbmRleCA9IHNlbGVjdGVkQ29sdW1uc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFZpc2libGVDb2x1bW5JbmRleCA9IHZpc2libGVDb2x1bW5zWzBdLmNvbHVtbkluZGV4O1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RTZWxlY3RlZENvbHVtbkluZGV4ID0gc2VsZWN0ZWRDb2x1bW5zW3NlbGVjdGVkQ29sdW1ucy5sZW5ndGggLSAxXSArIDI7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFZpc2libGVDb2x1bW5JbmRleCA9IHZpc2libGVDb2x1bW5zW3Zpc2libGVDb2x1bW5zLmxlbmd0aCAtIDFdLmNvbHVtbkluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFZpc2libGVDb2x1bW5JbmRleCA8IGZpcnN0U2VsZWN0ZWRDb2x1bW5JbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckNvbCA9IGZpcnN0U2VsZWN0ZWRDb2x1bW5JbmRleDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RWaXNpYmxlQ29sdW1uSW5kZXggPiBsYXN0U2VsZWN0ZWRDb2x1bW5JbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckNvbCA9IGxhc3RTZWxlY3RlZENvbHVtbkluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlckNvbCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlUGxhY2Vob2xkZXJUbyhncmlkLCBwbGFjZWhvbGRlckNvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtbk1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXNldHMgc2Nyb2xsIGRlbGF5IHRvIGluaXRpYWwgdmFsdWVcbiAgICAgKi9cbiAgICByZXNldFNjcm9sbERlbGF5OiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLnNjcm9sbEF0dGVtcHQgPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybnMgZGVsYXkgYmV0d2VlbiBhdXRvLXNjcm9sbGluZyBieSBvbmUgc3RlcC4gRGVsYXkgaXMgZGVjcmVtZW50ZWQgd2l0aCBlYWNoIGZ1cnRoZXIgc3RlcC5cbiAgICAgKi9cbiAgICBnZXRTY3JvbGxEZWxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLm1pblNjcm9sbERlbGF5LCB0aGlzLm1heFNjcm9sbERlbGF5IC0gdGhpcy5zY3JvbGxBdHRlbXB0KysgKiA1KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtbk1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhdXRvc2Nyb2xsIHRvIHRoZSByaWdodCBpZiBuZWNlc3NhcnlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHN0YXJ0IHBvc2l0aW9uXG4gICAgICovXG4gICAgY2hlY2tBdXRvU2Nyb2xsVG9SaWdodDogZnVuY3Rpb24oZ3JpZCwgeCkge1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ1JpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ1JpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY2hlY2tBdXRvU2Nyb2xsVG9SaWdodChncmlkLCB4KTtcbiAgICB9LFxuXG4gICAgX2NoZWNrQXV0b1Njcm9sbFRvUmlnaHQ6IGZ1bmN0aW9uKGdyaWQsIHgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nUmlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3JvbGxMZWZ0ID0gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgaWYgKCFncmlkLmRyYWdnaW5nIHx8IHNjcm9sbExlZnQgPiAoZ3JpZC5zYkhTY3JvbGxlci5yYW5nZS5tYXggLSAyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGdyaWQuc2Nyb2xsQnkoMSwgMCk7XG5cbiAgICAgICAgY29uc3QgdmlzaWJsZUNvbHVtbnMgPSBncmlkLnJlbmRlcmVyLnZpc2libGVDb2x1bW5zO1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlckNvbCA9IHZpc2libGVDb2x1bW5zW3Zpc2libGVDb2x1bW5zLmxlbmd0aCAtIDFdLmNvbHVtbkluZGV4ICsgMTtcbiAgICAgICAgdGhpcy5tb3ZlUGxhY2Vob2xkZXJUbyhncmlkLCBwbGFjZWhvbGRlckNvbCk7XG5cbiAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4ICs9IDE7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5fY2hlY2tBdXRvU2Nyb2xsVG9SaWdodC5iaW5kKHRoaXMsIGdyaWQsIHgpLCB0aGlzLmdldFNjcm9sbERlbGF5KCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGF1dG9zY3JvbGwgdG8gdGhlIGxlZnQgaWYgbmVjZXNzYXJ5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSBzdGFydCBwb3NpdGlvblxuICAgICAqL1xuICAgIGNoZWNrQXV0b1Njcm9sbFRvTGVmdDogZnVuY3Rpb24oZ3JpZCwgeCkge1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ0xlZnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nTGVmdCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NoZWNrQXV0b1Njcm9sbFRvTGVmdChncmlkLCB4KTtcbiAgICB9LFxuXG4gICAgX2NoZWNrQXV0b1Njcm9sbFRvTGVmdDogZnVuY3Rpb24oZ3JpZCwgeCkge1xuICAgICAgICBpZiAoIXRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdMZWZ0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2Nyb2xsTGVmdCA9IGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgICAgIGlmICghZ3JpZC5kcmFnZ2luZyB8fCBzY3JvbGxMZWZ0IDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGdyaWQuc2Nyb2xsQnkoLTEsIDApO1xuXG4gICAgICAgIGNvbnN0IHZpc2libGVDb2x1bW5zID0gZ3JpZC5yZW5kZXJlci52aXNpYmxlQ29sdW1ucztcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJDb2wgPSB2aXNpYmxlQ29sdW1uc1swXS5jb2x1bW5JbmRleCAtIDE7XG4gICAgICAgIHRoaXMubW92ZVBsYWNlaG9sZGVyVG8oZ3JpZCwgcGxhY2Vob2xkZXJDb2wpO1xuXG4gICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5jb2x1bW5JbmRleCAtPSAxO1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuX2NoZWNrQXV0b1Njcm9sbFRvTGVmdC5iaW5kKHRoaXMsIGdyaWQsIHgpLCB0aGlzLmdldFNjcm9sbERlbGF5KCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGEgY29sdW1uIGRyYWcgaGFzIGNvbXBsZXRlZCwgdXBkYXRlIGRhdGEgYW5kIGNsZWFudXBcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGVuZERyYWdDb2x1bW46IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgY29uc3QgZCA9IGRyYWdnZXI7XG4gICAgICAgIGNvbnN0IGNoYW5nZWQgPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuc3RhcnRJbmRleCAhPT0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4O1xuXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkQ29sdW1ucyA9IGdyaWQuZ2V0U2VsZWN0ZWRDb2x1bW5zKCk7XG4gICAgICAgIGNvbnN0IGNvbnNlcXVlbnQgPSB0aGlzLl9pc0NvbnNlcXVlbnQoc2VsZWN0ZWRDb2x1bW5zKTtcblxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlckluZGV4ID0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4O1xuICAgICAgICBjb25zdCBkcmFnZ2VySW5kZXggPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuc3RhcnRJbmRleDtcbiAgICAgICAgY29uc3QgZnJvbSA9IGNvbnNlcXVlbnQgPyBzZWxlY3RlZENvbHVtbnNbMF0gOiBbZHJhZ2dlckluZGV4XTtcbiAgICAgICAgY29uc3QgbGVuID0gY29uc2VxdWVudCA/IHNlbGVjdGVkQ29sdW1ucy5sZW5ndGggOiAxO1xuICAgICAgICBncmlkLm1vdmVDb2x1bW5zKGZyb20sIGxlbiwgcGxhY2Vob2xkZXJJbmRleCk7XG5cbiAgICAgICAgY29uc3QgZiA9IHBsYWNlaG9sZGVyO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlciA9IG51bGw7XG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuXG4gICAgICAgIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIGxldCBzdGFydE5ld1NlbGVjdGlvbkZyb207XG4gICAgICAgIGlmIChmcm9tIDwgcGxhY2Vob2xkZXJJbmRleCl7XG4gICAgICAgICAgICBzdGFydE5ld1NlbGVjdGlvbkZyb20gPSBwbGFjZWhvbGRlckluZGV4IC0gKGxlbiAtIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnROZXdTZWxlY3Rpb25Gcm9tID0gcGxhY2Vob2xkZXJJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBncmlkLnNlbGVjdENvbHVtbihzdGFydE5ld1NlbGVjdGlvbkZyb20sIHN0YXJ0TmV3U2VsZWN0aW9uRnJvbSArIChsZW4gLSAxKSk7XG5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgZ3JpZC5lbmREcmFnQ29sdW1uTm90aWZpY2F0aW9uKCk7IC8vaW50ZXJuYWwgbm90aWZpY2F0aW9uXG4gICAgICAgICAgICBpZiAoY2hhbmdlZCl7XG4gICAgICAgICAgICAgICAgZ3JpZC5maXJlU3ludGhldGljT25Db2x1bW5zQ2hhbmdlZEV2ZW50KCk7IC8vcHVibGljIG5vdGlmaWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH0sXG5cbiAgICBfaXNDb25zZXF1ZW50OiBmdW5jdGlvbihhcnIpe1xuICAgICAgICBsZXQgY29uc2VxdWVudCA9IHRydWU7XG4gICAgICAgIGlmIChhcnIubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgYXJyLnNvcnQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhcnJbaSArIDFdIC0gYXJyW2ldICE9PSAxKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc2VxdWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uc2VxdWVudDtcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtbk1vdmluZztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEZlYXR1cmVcbiAqL1xudmFyIENvbHVtblJlc2l6aW5nID0gRmVhdHVyZS5leHRlbmQoJ0NvbHVtblJlc2l6aW5nJywge1xuXG4gICAgLyoqXG4gICAgICogdGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSB3aGVyZSB0aGUgZHJhZyB3YXMgaW5pdGlhdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkcmFnU3RhcnQ6IC0xLFxuXG4gICAgLyoqXG4gICAgICogdGhlIHN0YXJ0aW5nIHdpZHRoL2hlaWdodCBvZiB0aGUgcm93L2NvbHVtbiB3ZSBhcmUgZHJhZ2dpbmdcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRyYWdTdGFydFdpZHRoOiAtMSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBnZXQgdGhlIG1vdXNlIHgseSBjb29yZGluYXRlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gdGhlIG1vdXNlIGV2ZW50IHRvIHF1ZXJ5XG4gICAgICovXG4gICAgZ2V0TW91c2VWYWx1ZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZS54O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJucyB0aGUgaW5kZXggb2Ygd2hpY2ggZGl2aWRlciBJJ20gb3ZlclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvdmVyQXJlYURpdmlkZXI6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBsZWZ0TW9zdENvbHVtbkluZGV4ID0gZ3JpZC5iZWhhdmlvci5sZWZ0TW9zdENvbEluZGV4O1xuXG4gICAgICAgIC8vIG5lYXIgbGVmdCBib3JkZXIgb2YgY29sdW1uXG4gICAgICAgIGlmIChldmVudC5ncmlkQ2VsbC54ICE9PSBsZWZ0TW9zdENvbHVtbkluZGV4ICYmIGV2ZW50Lm1vdXNlUG9pbnQueCA8PSAzKSB7XG4gICAgICAgICAgICB2YXIgbGVmdENvbHVtbiA9IGdyaWQuYmVoYXZpb3IuZ2V0Q29sdW1uU2hpZnRlZChldmVudC5ncmlkQ2VsbC54LCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAobGVmdENvbHVtbiAmJiAhbGVmdENvbHVtbi5wcm9wZXJ0aWVzLmZpeGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBuZWFyIHJpZ2h0IGJvcmRlciBvZiBjb2x1bW5cbiAgICAgICAgaWYgKGV2ZW50Lm1vdXNlUG9pbnQueCA+PSBldmVudC5ib3VuZHMud2lkdGggLSAzKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gZ3JpZC5iZWhhdmlvci5nZXRDb2x1bW4oZXZlbnQuZ3JpZENlbGwueCk7XG4gICAgICAgICAgICBpZiAoY29sdW1uICYmICFjb2x1bW4ucHJvcGVydGllcy5maXhlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSBjdXJzb3IgbmFtZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q3Vyc29yTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnY29sLXJlc2l6ZSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnQ29sdW1uKSB7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSB0aGlzLmdldE1vdXNlVmFsdWUoZXZlbnQpIC0gdGhpcy5kcmFnU3RhcnQ7XG4gICAgICAgICAgICBncmlkLmJlaGF2aW9yLnNldENvbHVtbldpZHRoKHRoaXMuZHJhZ0NvbHVtbiwgdGhpcy5kcmFnU3RhcnRXaWR0aCArIGRlbHRhKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURyYWcoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuaXNIZWFkZXJSb3cgJiYgdGhpcy5vdmVyQXJlYURpdmlkZXIoZ3JpZCwgZXZlbnQpKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQubW91c2VQb2ludC54IDw9IDMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uSW5kZXggPSBldmVudC5ncmlkQ2VsbC54IC0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdDb2x1bW4gPSBncmlkLmJlaGF2aW9yLmdldEFjdGl2ZUNvbHVtbihjb2x1bW5JbmRleCk7XG4gICAgICAgICAgICAgICAgLy90aGlzLmRyYWdTdGFydFdpZHRoID0gZ3JpZC5yZW5kZXJlci52aXNpYmxlQ29sdW1uc1tjb2x1bW5JbmRleF0ud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIHZpc2libGVDb2xJbmRleCA9IGdyaWQuYmVoYXZpb3Iucm93Q29sdW1uSW5kZXg7XG4gICAgICAgICAgICAgICAgdmFyIGRyYWdDb2x1bW4gPSB0aGlzLmRyYWdDb2x1bW47XG4gICAgICAgICAgICAgICAgZ3JpZC5yZW5kZXJlci52aXNpYmxlQ29sdW1ucy5mb3JFYWNoV2l0aE5lZyhmdW5jdGlvbih2Q29sLCB2SW5kZXgpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sID0gdkNvbC5jb2x1bW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2wuaW5kZXggPT09IGRyYWdDb2x1bW4uaW5kZXgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZUNvbEluZGV4ID0gdkluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnU3RhcnRXaWR0aCA9IGdyaWQucmVuZGVyZXIudmlzaWJsZUNvbHVtbnNbdmlzaWJsZUNvbEluZGV4XS53aWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnQ29sdW1uID0gZXZlbnQuY29sdW1uO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1N0YXJ0V2lkdGggPSBldmVudC5ib3VuZHMud2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZHJhZ1N0YXJ0ID0gdGhpcy5nZXRNb3VzZVZhbHVlKGV2ZW50KTtcbiAgICAgICAgICAgIC8vdGhpcy5kZXRhY2hDaGFpbigpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnQ29sdW1uKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxDYWxsYmFja0lmTmVlZGVkKGdyaWQsIHRoaXMuZHJhZ0NvbHVtbik7XG5cbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0NvbHVtbiA9IGZhbHNlO1xuXG4gICAgICAgICAgICBldmVudC5wcmltaXRpdmVFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIC8vZGVsYXkgaGVyZSB0byBnaXZlIG90aGVyIGV2ZW50cyBhIGNoYW5jZSB0byBiZSBkcm9wcGVkXG4gICAgICAgICAgICBncmlkLmJlaGF2aW9yU2hhcGVDaGFuZ2VkKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5kcmFnQ29sdW1uKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VNb3ZlKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBldmVudC5pc0hlYWRlclJvdyAmJiB0aGlzLm92ZXJBcmVhRGl2aWRlcihncmlkLCBldmVudCkgPyB0aGlzLmdldEN1cnNvck5hbWUoKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge0NlbGxFdmVudH0gY2VsbEV2ZW50XG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGhhbmRsZURvdWJsZUNsaWNrOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuaXNIZWFkZXJSb3cgJiYgdGhpcy5vdmVyQXJlYURpdmlkZXIoZ3JpZCwgZXZlbnQpKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gZXZlbnQubW91c2VQb2ludC54IDw9IDNcbiAgICAgICAgICAgICAgICA/IGdyaWQuYmVoYXZpb3IuZ2V0QWN0aXZlQ29sdW1uKGV2ZW50LmdyaWRDZWxsLnggLSAxKVxuICAgICAgICAgICAgICAgIDogZXZlbnQuY29sdW1uO1xuICAgICAgICAgICAgZ3JpZC5hdXRvc2l6ZUNvbHVtbihjb2x1bW4pO1xuICAgICAgICAgICAgY29sdW1uLmFkZFByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIGNvbHVtbkF1dG9zaXppbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgY29sdW1uQXV0b3NpemVkOiBmYWxzZSAvLyB0b2RvOiBjb2x1bW5BdXRvc2l6aW5nIHNob3VsZCBiZSBhIHNldHRlciB0aGF0IGF1dG9tYXRpY2FsbHkgcmVzZXRzIGNvbHVtbkF1dG9zaXplZCBvbiBzdGF0ZSBjaGFuZ2UgdG8gdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY29sdW1uLmNvbERlZikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb2x1bW4uY29sRGVmLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYWxsQ2FsbGJhY2tJZk5lZWRlZChncmlkLCBjb2x1bW4pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cblxuICAgIGNhbGxDYWxsYmFja0lmTmVlZGVkOiBmdW5jdGlvbihncmlkLCBjb2x1bW4pIHtcbiAgICAgICAgaWYgKGdyaWQub25Db2x1bW5SZXNpemVkICYmIHRoaXMuZHJhZ1N0YXJ0V2lkdGggIT09IE1hdGgucm91bmQoY29sdW1uLmdldFdpZHRoKCkpKSB7XG4gICAgICAgICAgICBncmlkLm9uQ29sdW1uUmVzaXplZChjb2x1bW4pO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2x1bW5SZXNpemluZztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEZlYXR1cmVcbiAqL1xudmFyIENvbHVtblNlbGVjdGlvbiA9IEZlYXR1cmUuZXh0ZW5kKCdDb2x1bW5TZWxlY3Rpb24nLCB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIG1vdXNlIHBvaW50ZXIgZHVyaW5nIGEgZHJhZyBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGN1cnJlbnREcmFnOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGhvcml6b250YWwgY2VsbCBjb29yZGluYXRlIG9mIHRoZSB3aGVyZSB0aGUgbW91c2UgcG9pbnRlciBpcyBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGxhc3REcmFnQ29sdW1uOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogYSBtaWxsaXNlY29uZCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHByZXZpb3VzIHRpbWUgYW4gYXV0b3Njcm9sbCBzdGFydGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYkxhc3RBdXRvOiAwLFxuXG4gICAgLyoqXG4gICAgICogYSBtaWxsaXNlY29uZCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHRpbWUgdGhlIGN1cnJlbnQgYXV0b3Njcm9sbCBzdGFydGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYkF1dG9TdGFydDogMCxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFuZGxlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRvdWJsZUNsaWNrVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRvdWJsZUNsaWNrVGltZXIpOyAvLyBwcmV2ZW50IG1vdXNlRG93biBmcm9tIGNvbnRpbnVpbmdcbiAgICAgICAgICAgIHRoaXMuZG91YmxlQ2xpY2tUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlRG91YmxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZG91YmxlQ2xpY2tUaW1lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdG9kbzogPj0gNSBkZXBlbmRzIG9uIGhlYWRlciBiZWluZyB0b3AtbW9zdCByb3cgd2hpY2ggaXMgY3VycmVudGx5IGFsd2F5cyB0cnVlIGJ1dCB3ZSBtYXkgYWxsb3cgaGVhZGVyIFwic2VjdGlvblwiIHRvIGJlIGFyYml0cmFyeSBwb3NpdGlvbiB3aXRoaW4gcXVhZHJhbnQgKHNlZSBhbHNvIGhhbmRsZU1vdXNlRG93biBpbiBDb2x1bW5Nb3ZpbmcuanMpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICFldmVudC5pc0NvbHVtblNlbGVjdGVkICYmXG4gICAgICAgICAgICBncmlkLnByb3BlcnRpZXMuY29sdW1uU2VsZWN0aW9uICYmXG4gICAgICAgICAgICAhZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmlzUmlnaHRDbGljayAmJlxuICAgICAgICAgICAgZXZlbnQuaXNIZWFkZXJDZWxsXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmV4dGVuZFNlbGVjdGlvbihncmlkLCBldmVudC5ncmlkQ2VsbC54LCBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwua2V5cyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWc6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGdyaWQucHJvcGVydGllcy5jb2x1bW5TZWxlY3Rpb24gJiZcbiAgICAgICAgICAgICF0aGlzLmlzQ29sdW1uRHJhZ2dpbmcoZ3JpZCkgJiZcbiAgICAgICAgICAgICFldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwuaXNSaWdodENsaWNrICYmXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy9pZiB3ZSBhcmUgaW4gdGhlIGZpeGVkIGFyZWEgZG8gbm90IGFwcGx5IHRoZSBzY3JvbGwgdmFsdWVzXG4gICAgICAgICAgICB0aGlzLmxhc3REcmFnQ29sdW1uID0gZXZlbnQuZ3JpZENlbGwueDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERyYWcgPSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRHJhZ1Njcm9sbChncmlkLCB0aGlzLmN1cnJlbnREcmFnKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbihncmlkLCB0aGlzLmxhc3REcmFnQ29sdW1uLCBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwua2V5cyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVLZXlEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgZGV0YWlsID0gZXZlbnQuZGV0YWlsLFxuICAgICAgICAgICAgaGFuZGxlciA9IGdyaWQuZ2V0TGFzdFNlbGVjdGlvblR5cGUoKSA9PT0gJ2NvbHVtbicgJiZcbiAgICAgICAgICAgICAgICB0aGlzWydoYW5kbGUnICsgZGV0YWlsLmNoYXJdO1xuXG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgZ3JpZCwgZGV0YWlsKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVLZXlEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEhhbmRsZSBhIG1vdXNlZHJhZyBzZWxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5cyAtIGFycmF5IG9mIHRoZSBrZXlzIHRoYXQgYXJlIGN1cnJlbnRseSBwcmVzc2VkIGRvd25cbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWdDZWxsU2VsZWN0aW9uOiBmdW5jdGlvbihncmlkLCB4LCBrZXlzKSB7XG4gICAgICAgIHZhciBtb3VzZVggPSBncmlkLmdldE1vdXNlRG93bigpLng7XG5cbiAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRDb2x1bW5TZWxlY3Rpb24oKTtcblxuICAgICAgICBncmlkLnNlbGVjdENvbHVtbihtb3VzZVgsIHgpO1xuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCh4IC0gbW91c2VYLCAwKSk7XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBjaGVja3Mgd2hpbGUgd2VyZSBkcmFnZ2luZyBpZiB3ZSBnbyBvdXRzaWRlIHRoZSB2aXNpYmxlIGJvdW5kcywgaWYgc28sIGtpY2sgb2ZmIHRoZSBleHRlcm5hbCBhdXRvc2Nyb2xsIGNoZWNrIGZ1bmN0aW9uIChhYm92ZSlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgY2hlY2tEcmFnU2Nyb2xsOiBmdW5jdGlvbihncmlkLCBtb3VzZSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBncmlkLnByb3BlcnRpZXMuc2Nyb2xsaW5nRW5hYmxlZCAmJlxuICAgICAgICAgICAgZ3JpZC5nZXREYXRhQm91bmRzKCkuY29udGFpbnMobW91c2UpXG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgICAgIGdyaWQuc2V0U2Nyb2xsaW5nTm93KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghZ3JpZC5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5zZXRTY3JvbGxpbmdOb3codHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxEcmFnKGdyaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBtYWtlcyBzdXJlIHRoYXQgd2hpbGUgd2UgYXJlIGRyYWdnaW5nIG91dHNpZGUgb2YgdGhlIGdyaWQgdmlzaWJsZSBib3VuZHMsIHdlIHNyY3JvbGwgYWNjb3JkaW5nbHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIHNjcm9sbERyYWc6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgaWYgKCFncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiID0gZ3JpZC5nZXREYXRhQm91bmRzKCksXG4gICAgICAgICAgICB4T2Zmc2V0O1xuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmFnLnggPCBiLm9yaWdpbi54KSB7XG4gICAgICAgICAgICB4T2Zmc2V0ID0gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50RHJhZy54ID4gYi5vcmlnaW4ueCArIGIuZXh0ZW50LngpIHtcbiAgICAgICAgICAgIHhPZmZzZXQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHhPZmZzZXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhc3REcmFnQ29sdW1uID49IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0RHJhZ0NvbHVtbiArPSB4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JpZC5zY3JvbGxCeSh4T2Zmc2V0LCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbihncmlkLCB0aGlzLmxhc3REcmFnQ29sdW1uLCBbXSk7IC8vIHVwZGF0ZSB0aGUgc2VsZWN0aW9uXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuc2Nyb2xsRHJhZy5iaW5kKHRoaXMsIGdyaWQpLCAyNSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgZXh0ZW5kIGEgc2VsZWN0aW9uIG9yIGNyZWF0ZSBvbmUgaWYgdGhlcmUgaXNudCB5ZXRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBncmlkQ2VsbCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5cyAtIGFycmF5IG9mIHRoZSBrZXlzIHRoYXQgYXJlIGN1cnJlbnRseSBwcmVzc2VkIGRvd25cbiAgICAgKi9cbiAgICBleHRlbmRTZWxlY3Rpb246IGZ1bmN0aW9uKGdyaWQsIHgsIGtleXMpIHtcbiAgICAgICAgaWYgKCFncmlkLmFib3J0RWRpdGluZygpKSB7IHJldHVybjsgfVxuXG4gICAgICAgIHZhciBtb3VzZVggPSBncmlkLmdldE1vdXNlRG93bigpLngsXG4gICAgICAgICAgICBoYXNTSElGVCA9IGtleXMuaW5kZXhPZignU0hJRlQnKSA+IDA7XG5cbiAgICAgICAgaWYgKHggPCAwKSB7IC8vIG91dHNpZGUgb2YgdGhlIGdyaWQ/XG4gICAgICAgICAgICByZXR1cm47IC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNTSElGVCkge1xuICAgICAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRDb2x1bW5TZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGdyaWQuc2VsZWN0Q29sdW1uKHgsIG1vdXNlWCk7XG4gICAgICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCh4IC0gbW91c2VYLCAwKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBncmlkLnRvZ2dsZVNlbGVjdENvbHVtbih4LCBrZXlzKTtcbiAgICAgICAgICAgIGdyaWQuc2V0TW91c2VEb3duKGdyaWQubmV3UG9pbnQoeCwgMCkpO1xuICAgICAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGhhbmRsZURPV05TSElGVDogZnVuY3Rpb24oZ3JpZCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVVUFNISUZUOiBmdW5jdGlvbihncmlkKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUxFRlRTSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAtMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVJJR0hUU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2hpZnRTZWxlY3QoZ3JpZCwgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZURPV046IGZ1bmN0aW9uKGdyaWQpIHtcblxuICAgICAgICAvLyB2YXIgbW91c2VDb3JuZXIgPSBncmlkLmdldE1vdXNlRG93bigpLnBsdXMoZ3JpZC5nZXREcmFnRXh0ZW50KCkpO1xuICAgICAgICAvLyB2YXIgbWF4Um93cyA9IGdyaWQuZ2V0Um93Q291bnQoKSAtIDE7XG5cbiAgICAgICAgLy8gdmFyIG5ld1ggPSBtb3VzZUNvcm5lci54O1xuICAgICAgICAvLyB2YXIgbmV3WSA9IGdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKSArIGdyaWQuZ2V0VlNjcm9sbFZhbHVlKCk7XG5cbiAgICAgICAgLy8gbmV3WSA9IE1hdGgubWluKG1heFJvd3MsIG5ld1kpO1xuXG4gICAgICAgIC8vIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIC8vIGdyaWQuc2VsZWN0KG5ld1gsIG5ld1ksIDAsIDApO1xuICAgICAgICAvLyBncmlkLnNldE1vdXNlRG93bihuZXcgZ3JpZC5yZWN0YW5ndWxhci5Qb2ludChuZXdYLCBuZXdZKSk7XG4gICAgICAgIC8vIGdyaWQuc2V0RHJhZ0V4dGVudChuZXcgZ3JpZC5yZWN0YW5ndWxhci5Qb2ludCgwLCAwKSk7XG5cbiAgICAgICAgLy8gZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVVQOiBmdW5jdGlvbihncmlkKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUxFRlQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2luZ2xlU2VsZWN0KGdyaWQsIC0xKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlUklHSFQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2luZ2xlU2VsZWN0KGdyaWQsIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIElmIHdlIGFyZSBob2xkaW5nIGRvd24gdGhlIHNhbWUgbmF2aWdhdGlvbiBrZXksIGFjY2VsZXJhdGUgdGhlIGluY3JlbWVudCB3ZSBzY3JvbGxcbiAgICAgKiAjIyMjIHJldHVybnM6IGludGVnZXJcbiAgICAgKi9cbiAgICBnZXRBdXRvU2Nyb2xsQWNjZWxlcmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVsYXBzZWQgPSB0aGlzLmdldEF1dG9TY3JvbGxEdXJhdGlvbigpIC8gMjAwMDtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDEsIE1hdGguZmxvb3IoZWxhcHNlZCAqIGVsYXBzZWQgKiBlbGFwc2VkICogZWxhcHNlZCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldCB0aGUgc3RhcnQgdGltZSB0byByaWdodCBub3cgd2hlbiB3ZSBpbml0aWF0ZSBhbiBhdXRvIHNjcm9sbFxuICAgICAqL1xuICAgIHNldEF1dG9TY3JvbGxTdGFydFRpbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNiQXV0b1N0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1cGRhdGUgdGhlIGF1dG9zY3JvbGwgc3RhcnQgdGltZSBpZiB3ZSBoYXZlbid0IGF1dG9zY3JvbGxlZCB3aXRoaW4gdGhlIGxhc3QgNTAwbXMgb3RoZXJ3aXNlIHVwZGF0ZSB0aGUgY3VycmVudCBhdXRvc2Nyb2xsIHRpbWVcbiAgICAgKi9cbiAgICBwaW5nQXV0b1Njcm9sbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAobm93IC0gdGhpcy5zYkxhc3RBdXRvID4gNTAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldEF1dG9TY3JvbGxTdGFydFRpbWUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNiTGFzdEF1dG8gPSBEYXRlLm5vdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGFuc3dlciBob3cgbG9uZyB3ZSBoYXZlIGJlZW4gYXV0byBzY3JvbGxpbmdcbiAgICAgKiAjIyMjIHJldHVybnM6IGludGVnZXJcbiAgICAgKi9cbiAgICBnZXRBdXRvU2Nyb2xsRHVyYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHRoaXMuc2JMYXN0QXV0byA+IDUwMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSB0aGlzLnNiQXV0b1N0YXJ0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEF1Z21lbnQgdGhlIG1vc3QgcmVjZW50IHNlbGVjdGlvbiBleHRlbnQgYnkgKG9mZnNldFgsb2Zmc2V0WSkgYW5kIHNjcm9sbCBpZiBuZWNlc3NhcnkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIHggY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0geSBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICovXG4gICAgbW92ZVNoaWZ0U2VsZWN0OiBmdW5jdGlvbihncmlkLCBvZmZzZXRYKSB7XG4gICAgICAgIHZhciBvcmlnaW4gPSBncmlkLmdldE1vdXNlRG93bigpLFxuICAgICAgICAgICAgZXh0ZW50ID0gZ3JpZC5nZXREcmFnRXh0ZW50KCksXG4gICAgICAgICAgICBuZXdYID0gZXh0ZW50LnggKyBvZmZzZXRYLFxuICAgICAgICAgICAgbWF4Vmlld2FibGVDb2x1bW5zID0gZ3JpZC5yZW5kZXJlci52aXNpYmxlQ29sdW1ucy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgbWF4Q29sdW1ucyA9IGdyaWQuZ2V0Q29sdW1uQ291bnQoKSAtIDE7XG5cbiAgICAgICAgaWYgKCFncmlkLnByb3BlcnRpZXMuc2Nyb2xsaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgbWF4Q29sdW1ucyA9IE1hdGgubWluKG1heENvbHVtbnMsIG1heFZpZXdhYmxlQ29sdW1ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdYID0gTWF0aC5taW4obWF4Q29sdW1ucyAtIG9yaWdpbi54LCBNYXRoLm1heCgtb3JpZ2luLngsIG5ld1gpKTtcblxuICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudENvbHVtblNlbGVjdGlvbigpO1xuICAgICAgICBncmlkLnNlbGVjdENvbHVtbihvcmlnaW4ueCwgb3JpZ2luLnggKyBuZXdYKTtcbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQobmV3WCwgMCkpO1xuXG4gICAgICAgIGlmIChncmlkLmluc3VyZU1vZGVsQ29sSXNWaXNpYmxlKG5ld1ggKyBvcmlnaW4ueCwgb2Zmc2V0WCkpIHtcbiAgICAgICAgICAgIHRoaXMucGluZ0F1dG9TY3JvbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlcGxhY2UgdGhlIG1vc3QgcmVjZW50IHNlbGVjdGlvbiB3aXRoIGEgc2luZ2xlIGNlbGwgc2VsZWN0aW9uIHRoYXQgaXMgbW92ZWQgKG9mZnNldFgsb2Zmc2V0WSkgZnJvbSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uIGV4dGVudC5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0geCBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSB5IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKi9cbiAgICBtb3ZlU2luZ2xlU2VsZWN0OiBmdW5jdGlvbihncmlkLCBvZmZzZXRYKSB7XG4gICAgICAgIHZhciBleHRlbnQgPSBncmlkLmdldERyYWdFeHRlbnQoKSxcbiAgICAgICAgICAgIG1vdXNlQ29ybmVyID0gZ3JpZC5nZXRNb3VzZURvd24oKS5wbHVzKGV4dGVudCksXG4gICAgICAgICAgICBuZXdYID0gbW91c2VDb3JuZXIueCArIG9mZnNldFgsXG4gICAgICAgICAgICBtYXhDb2x1bW5zID0gZ3JpZC5nZXRDb2x1bW5Db3VudCgpIC0gMSxcbiAgICAgICAgICAgIG1heFZpZXdhYmxlQ29sdW1ucyA9IGdyaWQuZ2V0VmlzaWJsZUNvbHVtbnNDb3VudCgpIC0gMTtcblxuICAgICAgICBpZiAoIWdyaWQucHJvcGVydGllcy5zY3JvbGxpbmdFbmFibGVkKSB7XG4gICAgICAgICAgICBtYXhDb2x1bW5zID0gTWF0aC5taW4obWF4Q29sdW1ucywgbWF4Vmlld2FibGVDb2x1bW5zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld1ggPSBNYXRoLm1pbihtYXhDb2x1bW5zLCBNYXRoLm1heCgwLCBuZXdYKSk7XG5cbiAgICAgICAgZ3JpZC5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgZ3JpZC5zZWxlY3RDb2x1bW4obmV3WCk7XG4gICAgICAgIGdyaWQuc2V0TW91c2VEb3duKGdyaWQubmV3UG9pbnQobmV3WCwgMCkpO1xuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCAwKSk7XG5cbiAgICAgICAgaWYgKGdyaWQuaW5zdXJlTW9kZWxDb2xJc1Zpc2libGUobmV3WCwgb2Zmc2V0WCkpIHtcbiAgICAgICAgICAgIHRoaXMucGluZ0F1dG9TY3JvbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICBpc0NvbHVtbkRyYWdnaW5nOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHZhciBkcmFnZ2VyID0gZ3JpZC5sb29rdXBGZWF0dXJlKCdDb2x1bW5Nb3ZpbmcnKTtcbiAgICAgICAgcmV0dXJuIGRyYWdnZXIgJiYgZHJhZ2dlci5kcmFnZ2luZyAmJiAhdGhpcy5kcmFnZ2luZztcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtblNlbGVjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEZlYXR1cmVcbiAqL1xudmFyIENvbHVtblNvcnRpbmcgPSBGZWF0dXJlLmV4dGVuZCgnQ29sdW1uU29ydGluZycsIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5Tb3J0aW5nLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgc29ydC5jYWxsKHRoaXMsIGdyaWQsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNvcnRpbmcucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZURvdWJsZUNsaWNrOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBzb3J0LmNhbGwodGhpcywgZ3JpZCwgZXZlbnQsIHRydWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU29ydGluZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VNb3ZlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgY29sdW1uUHJvcGVydGllcztcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZXZlbnQuaXNSb3dGaXhlZCAmJlxuICAgICAgICAgICAgZXZlbnQuaXNIZWFkZXJDZWxsICYmXG4gICAgICAgICAgICAoY29sdW1uUHJvcGVydGllcyA9IGdyaWQuYmVoYXZpb3IuZ2V0Q29sdW1uUHJvcGVydGllcyhldmVudC5ncmlkQ2VsbC54KSkgJiZcbiAgICAgICAgICAgICFjb2x1bW5Qcm9wZXJ0aWVzLnVuc29ydGFibGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VNb3ZlKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cbmZ1bmN0aW9uIHNvcnQoZ3JpZCwgZXZlbnQsIG9uRG91YmxlQ2xpY2spIHtcbiAgICB2YXIgY29sdW1uUHJvcGVydGllcztcbiAgICBpZiAoXG4gICAgICAgIGV2ZW50LmlzSGVhZGVyQ2VsbCAmJlxuICAgICAgICAhKGNvbHVtblByb3BlcnRpZXMgPSBldmVudC5jb2x1bW5Qcm9wZXJ0aWVzKS51bnNvcnRhYmxlICYmXG4gICAgICAgICEoY29sdW1uUHJvcGVydGllcy5zb3J0T25Eb3VibGVDbGljayBeIG9uRG91YmxlQ2xpY2spIC8vIGJvdGggc2FtZSAodHJ1ZSBvciBmYWxzeSk/XG4gICAgKSB7XG4gICAgICAgIGdyaWQuZmlyZVN5bnRoZXRpY0NvbHVtblNvcnRFdmVudChldmVudC5ncmlkQ2VsbC54LCBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwua2V5cyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICB0aGlzLm5leHRbb25Eb3VibGVDbGljayA/ICdoYW5kbGVEb3VibGVDbGljaycgOiAnaGFuZGxlQ2xpY2snXShncmlkLCBldmVudCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtblNvcnRpbmc7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUnKTtcblxudmFyIG1lbnVEaXY7XG5cbnZhciBwcmV2aW91c0hvdmVyZWRDZWxsRXZlbnQ7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBGZWF0dXJlXG4gKi9cbnZhciBDb250ZXh0TWVudSA9IEZlYXR1cmUuZXh0ZW5kKCdDb250ZXh0TWVudScsIHtcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29udGV4dE1lbnUucHJvdG90eXBlXG4gICAgICogQGRlc2MgZ2l2ZSBtZSBhbiBvcHBvcnR1bml0eSB0byBpbml0aWFsaXplIHN0dWZmIG9uIHRoZSBncmlkXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBpbml0aWFsaXplT246IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgaWYgKCFtZW51RGl2KSB7XG4gICAgICAgICAgICBtZW51RGl2ID0gdGhpcy5pbml0aWFsaXplQ29udGV4dE1lbnVEaXYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5pbml0aWFsaXplT24oZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb250ZXh0TWVudS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBpbml0aWFsaXplIGNvbnRleHQgbWVudSBkaXZcbiAgICAgKi9cbiAgICBpbml0aWFsaXplQ29udGV4dE1lbnVEaXY6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWVudUhvbGRlckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgIG1lbnVIb2xkZXJEaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgbWVudUhvbGRlckRpdi5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgIG1lbnVIb2xkZXJEaXYuc2V0QXR0cmlidXRlKCdjbGFzcycsICdhZy1jdXN0b20nKTtcblxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG1lbnVIb2xkZXJEaXYpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbGVtZW50OiBtZW51SG9sZGVyRGl2LFxuICAgICAgICAgICAgcmVsYXRlZDogW11cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbnRleHRNZW51LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB0aGlzLmhpZGVDb250ZXh0TWVudShtZW51RGl2KTtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25BcGlEZXN0cm95Q2FsbGVkOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB0aGlzLmhpZGVDb250ZXh0TWVudShtZW51RGl2KTtcblxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQub25BcGlEZXN0cm95Q2FsbGVkKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVDYW52YXNPdXRzaWRlTW91c2VEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB0aGlzLmhpZGVDb250ZXh0TWVudShtZW51RGl2KTtcblxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlQ2FudmFzT3V0c2lkZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29udGV4dE1lbnUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge0NlbGxFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdGhpcy5oaWRlQ29udGV4dE1lbnUobWVudURpdik7XG5cbiAgICAgICAgbGV0IGlzQ3Vyc29yT3ZlckNvbnRleHRNZW51SWNvbiA9IHRoaXMub3ZlckNvbnRleHRNZW51Q2VsbChncmlkLCBldmVudCk7XG5cbiAgICAgICAgbGV0IGNvbnRleHRNZW51SWNvblJpZ2h0WCA9IGV2ZW50LmJvdW5kcy54XG4gICAgICAgICAgICArIGV2ZW50LmJvdW5kcy53aWR0aFxuICAgICAgICAgICAgLSBncmlkLnByb3BlcnRpZXMuY29udGV4dE1lbnVCdXR0b25SaWdodE1hcmdpbjtcbiAgICAgICAgbGV0IGNvbnRleHRNZW51SWNvbkxlZnRYID0gY29udGV4dE1lbnVJY29uUmlnaHRYXG4gICAgICAgICAgICAtIGdyaWQucHJvcGVydGllcy5jb250ZXh0TWVudUJ1dHRvbkljb25QcmVmZXJlZFdpZHRoXG4gICAgICAgICAgICAtIChncmlkLnByb3BlcnRpZXMuY29udGV4dE1lbnVCdXR0b25QYWRkaW5nICogMik7XG5cblxuICAgICAgICBpZiAoaXNDdXJzb3JPdmVyQ29udGV4dE1lbnVJY29uKSB7XG4gICAgICAgICAgICBsZXQgY29udGV4dE1lbnUgPSBncmlkLmJlaGF2aW9yLmdldENlbGxQcm9wZXJ0aWVzKGV2ZW50KS5jZWxsQ29udGV4dE1lbnUgfHwgZ3JpZC5wcm9wZXJ0aWVzLmNlbGxDb250ZXh0TWVudTtcbiAgICAgICAgICAgIGlmIChldmVudC5pc0hlYWRlclJvdyAmJiBncmlkLnByb3BlcnRpZXMuaGVhZGVyQ29udGV4dE1lbnUpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0TWVudSA9IGdyaWQucHJvcGVydGllcy5oZWFkZXJDb250ZXh0TWVudTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHJpZ2h0VG9MZWZ0ID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlLnggKyAyMDAgPj0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgICAgICBsZXQgc3RhcnRYID0gcmlnaHRUb0xlZnQgPyBjb250ZXh0TWVudUljb25SaWdodFggOiBjb250ZXh0TWVudUljb25MZWZ0WDtcbiAgICAgICAgICAgIHN0YXJ0WCArPSBncmlkLmNhbnZhcy5zaXplLmxlZnQ7XG5cbiAgICAgICAgICAgIHRoaXMucGFpbnRDb250ZXh0TWVudShtZW51RGl2LFxuICAgICAgICAgICAgICAgIGdyaWQsXG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgY29udGV4dE1lbnUsXG4gICAgICAgICAgICAgICAgc3RhcnRYLFxuICAgICAgICAgICAgICAgIGV2ZW50LmJvdW5kcy55ICsgZXZlbnQuYm91bmRzLmhlaWdodCArIGdyaWQuY2FudmFzLnNpemUudG9wLFxuICAgICAgICAgICAgICAgIHJpZ2h0VG9MZWZ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVDbGljayhncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgdXBkYXRlIHNlbGVjdGlvbnMgaWYgbmVlZGVkIGJhc2VkIG9uIHJpZ2h0IGNsaWNrIGNlbGwgb3IgaGVhZGVyLiBpZiBtZW51IGNhbGxlZCBvbiB1bnNlbGVjdGVkIGl0ZW0gZXNwZWNpYWxseVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICB1cGRhdGVTZWxlY3Rpb25zOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuaXNIZWFkZXJSb3cgJiYgZXZlbnQuaXNIYW5kbGVDb2x1bW4gJiYgIWV2ZW50LmlzRGF0YVJvdykge1xuICAgICAgICAgICAgZ3JpZC5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgICAgIGdyaWQuc2VsZWN0aW9uTW9kZWwuc2VsZWN0QWxsUm93cygpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmlzSGVhZGVyUm93ICYmICFldmVudC5pc0NvbHVtblNlbGVjdGVkKSB7XG4gICAgICAgICAgICAvLyB0b3Agcm93IG93IGhlYWRlcnNcbiAgICAgICAgICAgIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgICAgICBncmlkLnNlbGVjdENvbHVtbihldmVudC5kYXRhQ2VsbC54LCBldmVudC5kYXRhQ2VsbC54KTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5pc0hhbmRsZUNvbHVtbiAmJiBldmVudC5pc0RhdGFSb3cgJiYgIWV2ZW50LmlzUm93U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vIGxlZnQgcm93IG51bWJlciBoZWFkZXJzXG4gICAgICAgICAgICBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICAgICAgZ3JpZC5zZWxlY3RSb3coZXZlbnQuZGF0YUNlbGwueSwgZXZlbnQuZGF0YUNlbGwueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWV2ZW50LmlzQ2VsbFNlbGVjdGVkKSB7XG4gICAgICAgICAgICAvLyBzaW1wbGUgY2VsbFxuICAgICAgICAgICAgZ3JpZC5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgICAgIGdyaWQuc2VsZWN0KGV2ZW50LmRhdGFDZWxsLngsIGV2ZW50LmRhdGFDZWxsLnksIDAsIDApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb250ZXh0TWVudS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlQ29udGV4dE1lbnU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGxldCBjb250ZXh0TWVudTtcbiAgICAgICAgaWYgKGV2ZW50LmlzSGVhZGVyUm93ICYmIGdyaWQucHJvcGVydGllcy5oZWFkZXJDb250ZXh0TWVudSkge1xuICAgICAgICAgICAgY29udGV4dE1lbnUgPSBncmlkLnByb3BlcnRpZXMuaGVhZGVyQ29udGV4dE1lbnU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0TWVudSA9IGdyaWQuYmVoYXZpb3IuZ2V0Q2VsbFByb3BlcnRpZXMoZXZlbnQpLmNlbGxDb250ZXh0TWVudSB8fCBncmlkLnByb3BlcnRpZXMuY2VsbENvbnRleHRNZW51O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3Rpb25zKGdyaWQsIGV2ZW50KTtcblxuICAgICAgICAvLyB1cGRhdGUgY2VsbCBtZW51IGZvciBsZWZ0IGNvbHVtbiBvZiByb3cgbnVtYmVyc1xuICAgICAgICBpZiAoZXZlbnQuaXNIYW5kbGVDb2x1bW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gZ3JpZC5zZWxlY3Rpb25Nb2RlbC5nZXRGaXJzdFNlbGVjdGVkQ2VsbE9mTGFzdFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgY29udGV4dE1lbnUgPSBncmlkLmJlaGF2aW9yLmdldENlbGxQcm9wZXJ0aWVzKHBvaW50LngsIHBvaW50LnkpLmNlbGxDb250ZXh0TWVudSB8fCBncmlkLnByb3BlcnRpZXMuY2VsbENvbnRleHRNZW51O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJpZ2h0VG9MZWZ0ID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlLnggKyAyMDAgPj0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIHRoaXMucGFpbnRDb250ZXh0TWVudShtZW51RGl2LFxuICAgICAgICAgICAgZ3JpZCxcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgY29udGV4dE1lbnUsXG4gICAgICAgICAgICBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueCArIGdyaWQuY2FudmFzLnNpemUubGVmdCxcbiAgICAgICAgICAgIGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZS55ICsgZ3JpZC5jYW52YXMuc2l6ZS50b3AgKyAyNSxcbiAgICAgICAgICAgIHJpZ2h0VG9MZWZ0KTtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUNvbnRleHRNZW51KGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIC8vIHRoaXMuY2xvc2VBbGxDaGlsZHMobWVudURpdik7XG5cbiAgICAgICAgbGV0IHN0YXRlQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgaXNDdXJzb3JPdmVyQ29udGV4dE1lbnVJY29uID0gdGhpcy5vdmVyQ29udGV4dE1lbnVDZWxsKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgbGV0IGlzUHJldmlvdXNDZWxsRXZlbnRFeGlzdCA9ICEhcHJldmlvdXNIb3ZlcmVkQ2VsbEV2ZW50O1xuXG4gICAgICAgIGlmIChpc0N1cnNvck92ZXJDb250ZXh0TWVudUljb24pIHtcbiAgICAgICAgICAgIGlmICghcHJldmlvdXNIb3ZlcmVkQ2VsbEV2ZW50IHx8IGV2ZW50LmJvdW5kcy54ICE9PSBwcmV2aW91c0hvdmVyZWRDZWxsRXZlbnQuYm91bmRzLnhcbiAgICAgICAgICAgICAgICB8fCBldmVudC5ib3VuZHMueSAhPT0gcHJldmlvdXNIb3ZlcmVkQ2VsbEV2ZW50LmJvdW5kcy55KSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDQVVUSU9OISBJZiBjYWxsIHNldENlbGxQcm9wZXJ0eSBtZXRob2Qgb2YgY2VsbEV2ZW50LCByZW5kZXJlciBwcm9wZXJ0aWVzIGNhY2hlIHdpbGwgbm90IGJlXG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlZCAoc28gaG92ZXIgc3RhdGUgb2YgaWNvbiBub3QgYmUgZGlzcGxheWVkIGJlZm9yZSBjZWxsIHByb3BlcnRpZXMgY2FjaGUgY2hhbmdlKVxuICAgICAgICAgICAgICAgIGdyaWQuYmVoYXZpb3Iuc2V0Q2VsbFByb3BlcnR5KGV2ZW50LmRhdGFDZWxsLngsIGV2ZW50LmRhdGFDZWxsLnksICdjb250ZXh0TWVudUljb25Jc0hvdmVyZWQnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBldmVudC5jb250ZXh0TWVudUljb25Jc0hvdmVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNIb3ZlcmVkQ2VsbEV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNQcmV2aW91c0NlbGxFdmVudEV4aXN0KSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDQVVUSU9OISBJZiBjYWxsIHNldENlbGxQcm9wZXJ0eSBtZXRob2Qgb2YgY2VsbEV2ZW50LCByZW5kZXJlciBwcm9wZXJ0aWVzIGNhY2hlIHdpbGwgbm90IGJlXG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlZCAoc28gaG92ZXIgc3RhdGUgb2YgaWNvbiBub3QgYmUgZGlzcGxheWVkIGJlZm9yZSBjZWxsIHByb3BlcnRpZXMgY2FjaGUgY2hhbmdlKVxuICAgICAgICAgICAgICAgIGdyaWQuYmVoYXZpb3Iuc2V0Q2VsbFByb3BlcnR5KHByZXZpb3VzSG92ZXJlZENlbGxFdmVudC5kYXRhQ2VsbC54LCBwcmV2aW91c0hvdmVyZWRDZWxsRXZlbnQuZGF0YUNlbGwueSwgJ2NvbnRleHRNZW51SWNvbklzSG92ZXJlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBldmVudC5jb250ZXh0TWVudUljb25Jc0hvdmVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c0hvdmVyZWRDZWxsRXZlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHN0YXRlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZU1vdmUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSBncmlkIGRhdGEgYWRkZWQgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbW1lbnQgTm90IHJlYWxseSBwcml2YXRlIGJ1dCB3YXMgY2x1dHRlcmluZyB1cCBhbGwgdGhlIGZlYXR1cmUgZG9jIHBhZ2VzLlxuICAgICAqL1xuICAgIGhhbmRsZURhdGFBZGRlZDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdGhpcy5oaWRlQ29udGV4dE1lbnUobWVudURpdik7XG5cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURhdGFBZGRlZChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb3ZlckNvbnRleHRNZW51Q2VsbDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgbGV0IGNlbGxIYXNDb250ZXh0TWVudUl0ZW0gPSBldmVudC5wcm9wZXJ0aWVzLnNob3dDZWxsQ29udGV4dE1lbnVJY29uXG4gICAgICAgICAgICB8fCAoZXZlbnQucm93UHJvcGVydGllcyAmJiBldmVudC5yb3dQcm9wZXJ0aWVzLnNob3dDZWxsQ29udGV4dE1lbnVJY29uKVxuICAgICAgICAgICAgfHwgKGV2ZW50LmNlbGxPd25Qcm9wZXJ0aWVzICYmIGV2ZW50LmNlbGxPd25Qcm9wZXJ0aWVzLnNob3dDZWxsQ29udGV4dE1lbnVJY29uKTtcblxuICAgICAgICBpZiAoIWNlbGxIYXNDb250ZXh0TWVudUl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBldmVudENlbGxSaWdodFggPSBldmVudC5ib3VuZHMud2lkdGg7XG4gICAgICAgIGxldCBjb250ZXh0TWVudUljb25SaWdodFggPSBldmVudENlbGxSaWdodFhcbiAgICAgICAgICAgIC0gZ3JpZC5wcm9wZXJ0aWVzLmNvbnRleHRNZW51QnV0dG9uUmlnaHRNYXJnaW47XG5cblxuICAgICAgICBsZXQgdHlwZVNpZ25XaWR0aCA9IDA7XG4gICAgICAgIGlmIChldmVudC5jb2x1bW4uc2NoZW1hICYmIGV2ZW50LmNvbHVtbi5zY2hlbWEuY29sVHlwZVNpZ24pIHtcbiAgICAgICAgICAgIGxldCBnYyA9IGdyaWQuY2FudmFzLmdjLFxuICAgICAgICAgICAgICAgIHByZXZGb250U3RhdGUgPSBnYy5jYWNoZS5mb250LFxuICAgICAgICAgICAgICAgIHByZXZGaWxsU3R5bGVTdGF0ZSA9IGdjLmNhY2hlLmZpbGxTdHlsZSxcbiAgICAgICAgICAgICAgICBjb25maWcgPSBldmVudC5wcm9wZXJ0aWVzO1xuXG4gICAgICAgICAgICBnYy5jYWNoZS5mb250ID0gY29uZmlnLmNvbHVtblR5cGVTaWduRm9udDtcbiAgICAgICAgICAgIGdjLmNhY2hlLmZpbGxTdHlsZSA9IGNvbmZpZy5jb2x1bW5UeXBlU2lnbkNvbG9yO1xuICAgICAgICAgICAgdHlwZVNpZ25XaWR0aCA9IGdjLm1lYXN1cmVUZXh0KGV2ZW50LmNvbHVtbi5zY2hlbWEuY29sVHlwZVNpZ24pLndpZHRoO1xuICAgICAgICAgICAgdHlwZVNpZ25XaWR0aCArPSBjb25maWcuY29udGV4dE1lbnVMZWZ0U3BhY2VUb0N1dFRleHQ7XG5cbiAgICAgICAgICAgIGdjLmNhY2hlLmZvbnQgPSBwcmV2Rm9udFN0YXRlO1xuICAgICAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gcHJldkZpbGxTdHlsZVN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZXh0TWVudUljb25MZWZ0WCA9IGNvbnRleHRNZW51SWNvblJpZ2h0WFxuICAgICAgICAgICAgLSBncmlkLnByb3BlcnRpZXMuY29udGV4dE1lbnVCdXR0b25JY29uUHJlZmVyZWRXaWR0aFxuICAgICAgICAgICAgLSAoZ3JpZC5wcm9wZXJ0aWVzLmNvbnRleHRNZW51QnV0dG9uUGFkZGluZyAqIDIpXG4gICAgICAgICAgICAtIHR5cGVTaWduV2lkdGg7XG5cbiAgICAgICAgbGV0IGNvbnRleHRNZW51SWNvblRvcFkgPSBldmVudC5ib3VuZHMuaGVpZ2h0IC8gMiAtIGdyaWQucHJvcGVydGllcy5jb250ZXh0TWVudUJ1dHRvbkhlaWdodCAvIDI7XG4gICAgICAgIGxldCBjb250ZXh0TWVudUljb25Cb3R0b21ZID0gY29udGV4dE1lbnVJY29uVG9wWSArIGdyaWQucHJvcGVydGllcy5jb250ZXh0TWVudUJ1dHRvbkhlaWdodDtcblxuICAgICAgICByZXR1cm4gZXZlbnQubW91c2VQb2ludC54IDw9IGNvbnRleHRNZW51SWNvblJpZ2h0WFxuICAgICAgICAgICAgJiYgZXZlbnQubW91c2VQb2ludC54ID49IGNvbnRleHRNZW51SWNvbkxlZnRYXG4gICAgICAgICAgICAmJiBldmVudC5tb3VzZVBvaW50LnkgPD0gY29udGV4dE1lbnVJY29uQm90dG9tWVxuICAgICAgICAgICAgJiYgZXZlbnQubW91c2VQb2ludC55ID49IGNvbnRleHRNZW51SWNvblRvcFk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb250ZXh0TWVudS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1dGlsaXR5IG1ldGhvZCB0byBwYWludCBjb250ZXh0IG1lbnUgYmFzZWQgb24gY2xpY2sgZXZlbnQsIGFuZCBwb3NpdGlvbiBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbWVudUhvbGRlckRpdiAtIG9iamVjdCB3aXRoIEh0bWwgZWxlbWVudCBhbmQgcmVsYXRlZCBlbGVtZW50c1xuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR9IGV2ZW50XG4gICAgICogQHBhcmFtIHtbXXxmdW5jdGlvbn0gaXRlbXMgLSBtZW51IGl0ZW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBkZWZpbmVzIGhvcml6b250YWwgcG9pbnQgb2YgbWVudSBzdGFydFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gZGVmaW5lcyB2ZXJ0aWNhbCBwb2ludCBvZiBtZW51IHN0YXJ0XG4gICAgICogQHBhcmFtIHtib29sZWFufSByaWdodFRvTGVmdCAtIGlmIHRydWUsIG1lbnUgd2lsbCBiZSBkaXNwbGF5ZWQgdGhhdCB3YXkgd2hlbiBpdCBob3Jpem9udGFsbHkgZW5kcyBvbiBYIHBvaW50XG4gICAgICovXG4gICAgcGFpbnRDb250ZXh0TWVudTogZnVuY3Rpb24obWVudUhvbGRlckRpdiwgZ3JpZCwgZXZlbnQsIGl0ZW1zLCB4LCB5LCByaWdodFRvTGVmdCkge1xuICAgICAgICB0aGlzLmhpZGVDb250ZXh0TWVudShtZW51SG9sZGVyRGl2KTtcblxuICAgICAgICB2YXIgbWVudUxpc3RIb2xkZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICBtZW51TGlzdEhvbGRlckRpdi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2FnLW1lbnUnKTtcblxuICAgICAgICBtZW51SG9sZGVyRGl2LmVsZW1lbnQuYXBwZW5kQ2hpbGQobWVudUxpc3RIb2xkZXJEaXYpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaXRlbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGl0ZW1zID0gaXRlbXMoeyBjb2x1bW46IGV2ZW50LmNvbHVtbiwgbm9kZTogeyBkYXRhOiBldmVudC5kYXRhUm93LCBsZXZlbDogZXZlbnQuY29sdW1uLnRyZWVMZXZlbCB9LCB2YWx1ZTogZXZlbnQudmFsdWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1ha2VDb250ZXh0TWVudUl0ZW0oZ3JpZCwgZXZlbnQsIG1lbnVIb2xkZXJEaXYsIG1lbnVMaXN0SG9sZGVyRGl2LCBpdGVtKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGdyaWQucHJvcGVydGllcy5hcHBseUNvbnRleHRNZW51U3R5bGluZyl7XG4gICAgICAgICAgICBpZiAoZ3JpZC5wcm9wZXJ0aWVzLmNvbnRleHRNZW51SG9sZGVyU3R5bGUpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG1lbnVIb2xkZXJEaXYuZWxlbWVudC5zdHlsZSwgZ3JpZC5wcm9wZXJ0aWVzLmNvbnRleHRNZW51SG9sZGVyU3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyaWQucHJvcGVydGllcy5hcHBseUNvbnRleHRNZW51U3R5bGluZykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWVudUxpc3RIb2xkZXJEaXYuc3R5bGUsIGdyaWQucHJvcGVydGllcy5jb250ZXh0TWVudUxpc3RTdHlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNob3dDb250ZXh0TWVudShtZW51SG9sZGVyRGl2LCB4LCB5LCByaWdodFRvTGVmdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb250ZXh0TWVudS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1dGlsaXR5IG1ldGhvZCB0byBwYWludCBzaW5nbGUgbWVudSBpdGVtIGFuZCBhcHBlbmQgaXQgdG8gbGlzdCB0aGF0IHBhc3NlZCBhcyBwYXJhbVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR9IGV2ZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG1lbnVIb2xkZXJEaXYgLSBvYmplY3Qgd2l0aCBIdG1sIGVsZW1lbnQgYW5kIHJlbGF0ZWQgZWxlbWVudHNcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtZW51TGlzdEhvbGRlckRpdiAtIEhUTUwgZWxlbWVudCB0aGF0IHJlcHJlc2VudHMgYSBsaXN0IG9mIG1lbnUgaXRlbXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaXRlbSAtIG1lbnUgaXRlbSBvYmplY3RcbiAgICAgKi9cbiAgICBtYWtlQ29udGV4dE1lbnVJdGVtOiBmdW5jdGlvbihncmlkLCBldmVudCwgbWVudUhvbGRlckRpdiwgbWVudUxpc3RIb2xkZXJEaXYsIGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0uaGFzT3duUHJvcGVydHkoJ2lzU2hvd24nKSkge1xuICAgICAgICAgICAgaWYgKCh0eXBlb2YgaXRlbS5pc1Nob3duID09PSAnZnVuY3Rpb24nKSAmJiAhaXRlbS5pc1Nob3duKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWl0ZW0uaXNTaG93bikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGNvbnN0IG1lbnVPcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbWVudU9wdGlvbi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgICAgICBtZW51T3B0aW9uLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnYWctbWVudS1vcHRpb24nKTtcblxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBtZW51T3B0aW9uSWNvblNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBtZW51T3B0aW9uSWNvblNwYW4uc2V0QXR0cmlidXRlKCdjbGFzcycsICdhZy1tZW51LW9wdGlvbi1pY29uJyk7XG4gICAgICAgICAgICBtZW51T3B0aW9uSWNvblNwYW4uc2V0QXR0cmlidXRlKCdpZCcsICdlSWNvbicpO1xuICAgICAgICAgICAgbWVudU9wdGlvbi5hcHBlbmRDaGlsZChtZW51T3B0aW9uSWNvblNwYW4pO1xuICAgICAgICAgICAgaWYgKGl0ZW0uaWNvbikge1xuICAgICAgICAgICAgICAgIG1lbnVPcHRpb25JY29uU3Bhbi5pbm5lckhUTUwgPSBpdGVtLmljb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG1lbnVPcHRpb25OYW1lU3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIG1lbnVPcHRpb25OYW1lU3Bhbi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2FnLW1lbnUtb3B0aW9uLXRleHQnKTtcbiAgICAgICAgICAgIG1lbnVPcHRpb25OYW1lU3Bhbi5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2VOYW1lJyk7XG4gICAgICAgICAgICBtZW51T3B0aW9uTmFtZVNwYW4uaW5uZXJIVE1MID0gaXRlbS50aXRsZSB8fCBpdGVtLm5hbWU7XG4gICAgICAgICAgICBtZW51T3B0aW9uLmFwcGVuZENoaWxkKG1lbnVPcHRpb25OYW1lU3Bhbik7XG5cbiAgICAgICAgICAgIGNvbnN0IG1lbnVPcHRpb25TaG9ydGN1dFNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBtZW51T3B0aW9uU2hvcnRjdXRTcGFuLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnY29udGV4dC1tZW51LW9wdGlvbi1zaG9ydGN1dCcpO1xuICAgICAgICAgICAgbWVudU9wdGlvblNob3J0Y3V0U3Bhbi5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2VTaG9ydGN1dCcpO1xuICAgICAgICAgICAgbWVudU9wdGlvbi5hcHBlbmRDaGlsZChtZW51T3B0aW9uU2hvcnRjdXRTcGFuKTtcblxuICAgICAgICAgICAgY29uc3QgbWVudU9wdGlvblBvcHVwUG9pbnRlclNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBtZW51T3B0aW9uUG9wdXBQb2ludGVyU3Bhbi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2NvbnRleHQtbWVudS1vcHRpb24tcG9wdXAtcG9pbnRlcicpO1xuICAgICAgICAgICAgbWVudU9wdGlvblBvcHVwUG9pbnRlclNwYW4uc2V0QXR0cmlidXRlKCdpZCcsICdlUG9wdXBQb2ludGVyJyk7XG5cbiAgICAgICAgICAgIGlmIChpdGVtLmNoaWxkTWVudSAmJiBpdGVtLmNoaWxkTWVudS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBtZW51T3B0aW9uUG9wdXBQb2ludGVyU3Bhbi5pbm5lckhUTUwgPSBncmlkLnByb3BlcnRpZXMuY29udGV4dE1lbnVDaGlsZE1lbnVBcnJvd0ljb25UYWc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lbnVPcHRpb24uYXBwZW5kQ2hpbGQobWVudU9wdGlvblBvcHVwUG9pbnRlclNwYW4pO1xuXG4gICAgICAgICAgICBtZW51T3B0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oY2xpY2tFdmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBncmlkLm1lbnVDbGljayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uYWN0aW9uKGNsaWNrRXZlbnQsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGdyaWQubWVudUNsaWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLmhpZGVDb250ZXh0TWVudShtZW51RGl2KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoZ3JpZC5wcm9wZXJ0aWVzLmFwcGx5Q29udGV4dE1lbnVTdHlsaW5nKXtcbiAgICAgICAgICAgICAgICBpZiAoZ3JpZC5wcm9wZXJ0aWVzLmNvbnRleHRNZW51TGlzdE9wdGlvblN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWVudU9wdGlvbi5zdHlsZSwgZ3JpZC5wcm9wZXJ0aWVzLmNvbnRleHRNZW51TGlzdE9wdGlvblN0eWxlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZ3JpZC5wcm9wZXJ0aWVzLmNvbnRleHRNZW51TGlzdE9wdGlvbkljb25TdHlsZSl7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWVudU9wdGlvbkljb25TcGFuLnN0eWxlLCBncmlkLnByb3BlcnRpZXMuY29udGV4dE1lbnVMaXN0T3B0aW9uSWNvblN0eWxlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZ3JpZC5wcm9wZXJ0aWVzLmNvbnRleHRNZW51TGlzdE9wdGlvblRleHRTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG1lbnVPcHRpb25OYW1lU3Bhbi5zdHlsZSwgZ3JpZC5wcm9wZXJ0aWVzLmNvbnRleHRNZW51TGlzdE9wdGlvblRleHRTdHlsZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGdyaWQucHJvcGVydGllcy5jb250ZXh0TWVudUxpc3RPcHRpb25TaG9ydGN1dFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWVudU9wdGlvblNob3J0Y3V0U3Bhbi5zdHlsZSwgZ3JpZC5wcm9wZXJ0aWVzLmNvbnRleHRNZW51TGlzdE9wdGlvblNob3J0Y3V0U3R5bGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChncmlkLnByb3BlcnRpZXMuY29udGV4dE1lbnVMaXN0T3B0aW9uUG9wdXBQb2ludGVyU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihtZW51T3B0aW9uUG9wdXBQb2ludGVyU3Bhbi5zdHlsZSwgZ3JpZC5wcm9wZXJ0aWVzLmNvbnRleHRNZW51TGlzdE9wdGlvblBvcHVwUG9pbnRlclN0eWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lbnVPcHRpb24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgICAgICAgICBzZWxmLmNsb3NlQWxsQ2hpbGRzKG1lbnVIb2xkZXJEaXYpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNoaWxkTWVudSAmJlxuICAgICAgICAgICAgICAgICAgICBpdGVtLmNoaWxkTWVudS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgIWl0ZW0uY2hpbGRNZW51RGl2KSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uY2hpbGRNZW51RGl2ID0gc2VsZi5pbml0aWFsaXplQ29udGV4dE1lbnVEaXYoKTtcblxuICAgICAgICAgICAgICAgICAgICBtZW51SG9sZGVyRGl2LnJlbGF0ZWQucHVzaChpdGVtLmNoaWxkTWVudURpdik7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjdGFuZ2xlID0gbWVudU9wdGlvbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmlnaHRCb3JkZXJYID0gcmVjdGFuZ2xlLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHJpZ2h0Qm9yZGVyWCArIDIwMCkgPiB3aW5kb3cuaW5uZXJXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wYWludENvbnRleHRNZW51KGl0ZW0uY2hpbGRNZW51RGl2LCBncmlkLCBldmVudCwgaXRlbS5jaGlsZE1lbnUsIHJlY3RhbmdsZS5sZWZ0LCByZWN0YW5nbGUudG9wLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucGFpbnRDb250ZXh0TWVudShpdGVtLmNoaWxkTWVudURpdiwgZ3JpZCwgZXZlbnQsIGl0ZW0uY2hpbGRNZW51LCByaWdodEJvcmRlclgsIHJlY3RhbmdsZS50b3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lbnVPcHRpb24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICAgICAgICAgIGlmIChncmlkLnByb3BlcnRpZXMuYXBwbHlDb250ZXh0TWVudVN0eWxpbmcgJiYgZ3JpZC5wcm9wZXJ0aWVzLmNvbnRleHRNZW51TGlzdE9wdGlvbkhvdmVyU3R5bGUpe1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG1lbnVPcHRpb24uc3R5bGUsIGdyaWQucHJvcGVydGllcy5jb250ZXh0TWVudUxpc3RPcHRpb25Ib3ZlclN0eWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWVudU9wdGlvbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICAgICAgICAgIGlmIChncmlkLnByb3BlcnRpZXMuYXBwbHlDb250ZXh0TWVudVN0eWxpbmcgJiYgZ3JpZC5wcm9wZXJ0aWVzLmNvbnRleHRNZW51TGlzdE9wdGlvblN0eWxlKXtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihtZW51T3B0aW9uLnN0eWxlLCBncmlkLnByb3BlcnRpZXMuY29udGV4dE1lbnVMaXN0T3B0aW9uU3R5bGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNoaWxkTWVudURpdiAmJiAhc2VsZi5pc0VsZW1lbnRDb250YWluc0NoaWxkKGl0ZW0uY2hpbGRNZW51RGl2LmVsZW1lbnQsIGV2ZW50LnJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaGlkZUNvbnRleHRNZW51KGl0ZW0uY2hpbGRNZW51RGl2KTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVET01FbGVtZW50KGl0ZW0uY2hpbGRNZW51RGl2LmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmNoaWxkTWVudURpdiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbSA9PT0gJ3NlcGFyYXRvcicpIHtcbiAgICAgICAgICAgIG1lbnVPcHRpb24uY2xhc3NOYW1lID0gJ2FnLW1lbnUtc2VwYXJhdG9yJztcblxuICAgICAgICAgICAgbGV0IGhyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2hyJyk7XG4gICAgICAgICAgICBtZW51T3B0aW9uLmFwcGVuZENoaWxkKGhyRWxlbWVudCk7XG5cbiAgICAgICAgICAgIGlmIChncmlkLnByb3BlcnRpZXMuYXBwbHlDb250ZXh0TWVudVN0eWxpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JpZC5wcm9wZXJ0aWVzLmNvbnRleHRNZW51U2VwYXJhdG9yU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihockVsZW1lbnQuc3R5bGUsIGdyaWQucHJvcGVydGllcy5jb250ZXh0TWVudVNlcGFyYXRvclN0eWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZW51TGlzdEhvbGRlckRpdi5hcHBlbmRDaGlsZChtZW51T3B0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbnRleHRNZW51LnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHV0aWxpdHkgbWV0aG9kIHRvIGNsZWFyIGNvbnRleHQgbWVudSBIVE1MIG9iamVjdCBhbmQgYWxsIHJlbGF0ZWQgb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtZW51SG9sZGVyRGl2XG4gICAgICovXG4gICAgY2xlYXJDb250ZXh0TWVudTogZnVuY3Rpb24obWVudUhvbGRlckRpdikge1xuICAgICAgICB3aGlsZSAobWVudUhvbGRlckRpdi5lbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIG1lbnVIb2xkZXJEaXYuZWxlbWVudC5yZW1vdmVDaGlsZChtZW51SG9sZGVyRGl2LmVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZUFsbENoaWxkcyhtZW51SG9sZGVyRGl2KTtcbiAgICB9LFxuXG4gICAgY2xvc2VBbGxDaGlsZHM6IGZ1bmN0aW9uKG1lbnVIb2xkZXJEaXYpIHtcbiAgICAgICAgd2hpbGUgKG1lbnVIb2xkZXJEaXYucmVsYXRlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZUNvbnRleHRNZW51KG1lbnVIb2xkZXJEaXYucmVsYXRlZFswXSk7XG4gICAgICAgICAgICBtZW51SG9sZGVyRGl2LnJlbGF0ZWQuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29udGV4dE1lbnUucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXRpbGl0eSBtZXRob2QgdG8gc3RhcnQgc2hvdyBjb250ZXh0IG1lbnUgb24gZGVmaW5lZCBwb2ludC5cbiAgICAgKiBAZGVzYyBNZW51IG11c3QgYmUgZm9ybWVkIGJlZm9yZSBpdCB3aWxsIGJlIHBhc3NlZCB0byB0aGlzIG1ldGhvZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtZW51SG9sZGVyRGl2IC0gb2JqZWN0IHdpdGggSHRtbCBlbGVtZW50IGFuZCByZWxhdGVkIGVsZW1lbnRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBkZWZpbmVzIGhvcml6b250YWwgcG9pbnQgb2YgbWVudSBzdGFydFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gZGVmaW5lcyB2ZXJ0aWNhbCBwb2ludCBvZiBtZW51IHN0YXJ0XG4gICAgICogQHBhcmFtIHtib29sZWFufSByaWdodFRvTGVmdCAtIGlmIHRydWUsIG1lbnUgd2lsbCBiZSBkaXNwbGF5ZWQgdGhhdCB3YXkgd2hlbiBpdCBob3Jpem9udGFsbHkgZW5kcyBvbiBYIHBvaW50XG4gICAgICovXG4gICAgc2hvd0NvbnRleHRNZW51OiBmdW5jdGlvbihtZW51SG9sZGVyRGl2LCB4LCB5LCByaWdodFRvTGVmdCkge1xuICAgICAgICBtZW51SG9sZGVyRGl2LmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIG1lbnVIb2xkZXJEaXYuZWxlbWVudC5zdHlsZS50b3AgPSB5ICsgJ3B4JztcblxuICAgICAgICB2YXIgc3RhcnRYID0geDtcbiAgICAgICAgaWYgKHJpZ2h0VG9MZWZ0KSB7XG4gICAgICAgICAgICBzdGFydFggPSB4IC0gbWVudUhvbGRlckRpdi5lbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIG1lbnVIb2xkZXJEaXYuZWxlbWVudC5zdHlsZS5sZWZ0ID0gc3RhcnRYICsgJ3B4JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbnRleHRNZW51LnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHV0aWxpdHkgbWV0aG9kIHRvIHN0b3AgZGlzcGxheWluZyBjb250ZXh0IG1lbnVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbWVudUhvbGRlckRpdiAtIG9iamVjdCB3aXRoIEh0bWwgZWxlbWVudCBhbmQgcmVsYXRlZCBlbGVtZW50c1xuICAgICAqL1xuICAgIGhpZGVDb250ZXh0TWVudTogZnVuY3Rpb24obWVudUhvbGRlckRpdikge1xuICAgICAgICB0aGlzLmNsZWFyQ29udGV4dE1lbnUobWVudUhvbGRlckRpdik7XG4gICAgICAgIG1lbnVIb2xkZXJEaXYuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29udGV4dE1lbnUucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXRpbGl0eSBtZXRob2QgdG8gcmVtb3ZlIEhUTUwgZWxlbWVudCBmcm9tIGN1cnJlbnQgRE9NXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIEhUTUwgZWxlbWVudCB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCBmcm9tIERPTVxuICAgICAqL1xuICAgIHJlbW92ZURPTUVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbnRleHRNZW51LnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHV0aWxpdHkgbWV0aG9kIHRvIGNoZWNrIGlzIG9uZSBIVE1MIGVsZW1lbnQgY29udGFpbnMgYW5vdGhlciBpbiBhbnkgbGV2ZWxcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gSFRNTCBlbGVtZW50IHRoYXQgbmVlZCB0byBiZSBjaGVja2VkXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29uY3JldGVDaGlsZCAtIEhUTUwgZWxlbWVudCB0aGF0IG5lZWQgdG8gYmUgZm91bmQgaW5zaWRlXG4gICAgICovXG4gICAgaXNFbGVtZW50Q29udGFpbnNDaGlsZDogZnVuY3Rpb24oZWxlbWVudCwgY29uY3JldGVDaGlsZCkge1xuICAgICAgICBpZiAoZWxlbWVudCA9PT0gY29uY3JldGVDaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBjaGlsZCA9IGVsZW1lbnQuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCA9PT0gY29uY3JldGVDaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaXNDaGlsZENvbnRhaW5zRWxlbWVudCA9IHRoaXMuaXNFbGVtZW50Q29udGFpbnNDaGlsZChjaGlsZCwgY29uY3JldGVDaGlsZCk7XG4gICAgICAgICAgICBpZiAoaXNDaGlsZENvbnRhaW5zRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRleHRNZW51O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4uL0Jhc2UnKTtcblxuLyoqXG4gKiBJbnN0YW5jZXMgb2YgZmVhdHVyZXMgYXJlIGNvbm5lY3RlZCB0byBvbmUgYW5vdGhlciB0byBtYWtlIGEgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkgZm9yIGhhbmRsaW5nIGFsbCB0aGUgaW5wdXQgdG8gdGhlIGh5cGVyZ3JpZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRmVhdHVyZSA9IEJhc2UuZXh0ZW5kKCdGZWF0dXJlJywge1xuXG4gICAgLyoqXG4gICAgICogdGhlIG5leHQgZmVhdHVyZSB0byBiZSBnaXZlbiBhIGNoYW5jZSB0byBoYW5kbGUgaW5jb21pbmcgZXZlbnRzXG4gICAgICogQHR5cGUge0ZlYXR1cmV9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIG5leHQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBhIHRlbXBvcmFyeSBob2xkaW5nIGZpZWxkIGZvciBteSBuZXh0IGZlYXR1cmUgd2hlbiBJJ20gaW4gYSBkaXNjb25uZWN0ZWQgc3RhdGVcbiAgICAgKiBAdHlwZSB7RmVhdHVyZX1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICovXG4gICAgZGV0YWNoZWQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiB0aGUgY3Vyc29yIEkgd2FudCB0byBiZSBkaXNwbGF5ZWRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjdXJzb3I6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiB0aGUgY2VsbCBsb2NhdGlvbiB3aGVyZSB0aGUgY3Vyc29yIGlzIGN1cnJlbnRseVxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICovXG4gICAgY3VycmVudEhvdmVyQ2VsbDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldCBteSBuZXh0IGZpZWxkLCBvciBpZiBpdCdzIHBvcHVsYXRlZCBkZWxlZ2F0ZSB0byB0aGUgZmVhdHVyZSBpbiBteSBuZXh0IGZpZWxkXG4gICAgICogQHBhcmFtIHtGZWF0dXJlfSBuZXh0RmVhdHVyZSAtIHRoaXMgaXMgaG93IHdlIGJ1aWxkIHRoZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbW1lbnQgTm90IHJlYWxseSBwcml2YXRlIGJ1dCB3YXMgY2x1dHRlcmluZyB1cCBhbGwgdGhlIGZlYXR1cmUgZG9jIHBhZ2VzLlxuICAgICAqL1xuICAgIHNldE5leHQ6IGZ1bmN0aW9uKG5leHRGZWF0dXJlKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5zZXROZXh0KG5leHRGZWF0dXJlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG5leHRGZWF0dXJlO1xuICAgICAgICAgICAgdGhpcy5kZXRhY2hlZCA9IG5leHRGZWF0dXJlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRpc2Nvbm5lY3QgbXkgY2hpbGRcbiAgICAgKi9cbiAgICBkZXRhY2hDaGFpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJlYXR0YWNoIG15IGNoaWxkIGZyb20gdGhlIGRldGFjaGVkIHJlZmVyZW5jZVxuICAgICAqL1xuICAgIGF0dGFjaENoYWluOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gdGhpcy5kZXRhY2hlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIG1vdXNlIG1vdmUgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb21tZW50IE5vdCByZWFsbHkgcHJpdmF0ZSBidXQgd2FzIGNsdXR0ZXJpbmcgdXAgYWxsIHRoZSBmZWF0dXJlIGRvYyBwYWdlcy5cbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZU1vdmUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSBncmlkIGRhdGEgYWRkZWQgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbW1lbnQgTm90IHJlYWxseSBwcml2YXRlIGJ1dCB3YXMgY2x1dHRlcmluZyB1cCBhbGwgdGhlIGZlYXR1cmUgZG9jIHBhZ2VzLlxuICAgICAqL1xuICAgIGhhbmRsZURhdGFBZGRlZDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURhdGFBZGRlZChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbW1lbnQgTm90IHJlYWxseSBwcml2YXRlIGJ1dCB3YXMgY2x1dHRlcmluZyB1cCBhbGwgdGhlIGZlYXR1cmUgZG9jIHBhZ2VzLlxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRXhpdDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRXhpdChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbW1lbnQgTm90IHJlYWxseSBwcml2YXRlIGJ1dCB3YXMgY2x1dHRlcmluZyB1cCBhbGwgdGhlIGZlYXR1cmUgZG9jIHBhZ2VzLlxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRW50ZXI6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZUVudGVyKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29tbWVudCBOb3QgcmVhbGx5IHByaXZhdGUgYnV0IHdhcyBjbHV0dGVyaW5nIHVwIGFsbCB0aGUgZmVhdHVyZSBkb2MgcGFnZXMuXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29tbWVudCBOb3QgcmVhbGx5IHByaXZhdGUgYnV0IHdhcyBjbHV0dGVyaW5nIHVwIGFsbCB0aGUgZmVhdHVyZSBkb2MgcGFnZXMuXG4gICAgICovXG4gICAgb25BcGlEZXN0cm95Q2FsbGVkOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQub25BcGlEZXN0cm95Q2FsbGVkKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVDYW52YXNPdXRzaWRlTW91c2VEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlQ2FudmFzT3V0c2lkZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbW1lbnQgTm90IHJlYWxseSBwcml2YXRlIGJ1dCB3YXMgY2x1dHRlcmluZyB1cCBhbGwgdGhlIGZlYXR1cmUgZG9jIHBhZ2VzLlxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlVXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29tbWVudCBOb3QgcmVhbGx5IHByaXZhdGUgYnV0IHdhcyBjbHV0dGVyaW5nIHVwIGFsbCB0aGUgZmVhdHVyZSBkb2MgcGFnZXMuXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUtleURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbW1lbnQgTm90IHJlYWxseSBwcml2YXRlIGJ1dCB3YXMgY2x1dHRlcmluZyB1cCBhbGwgdGhlIGZlYXR1cmUgZG9jIHBhZ2VzLlxuICAgICAqL1xuICAgIGhhbmRsZUtleVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlS2V5VXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb21tZW50IE5vdCByZWFsbHkgcHJpdmF0ZSBidXQgd2FzIGNsdXR0ZXJpbmcgdXAgYWxsIHRoZSBmZWF0dXJlIGRvYyBwYWdlcy5cbiAgICAgKi9cbiAgICBoYW5kbGVXaGVlbE1vdmVkOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlV2hlZWxNb3ZlZChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbW1lbnQgTm90IHJlYWxseSBwcml2YXRlIGJ1dCB3YXMgY2x1dHRlcmluZyB1cCBhbGwgdGhlIGZlYXR1cmUgZG9jIHBhZ2VzLlxuICAgICAqL1xuICAgIGhhbmRsZURvdWJsZUNsaWNrOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlRG91YmxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb21tZW50IE5vdCByZWFsbHkgcHJpdmF0ZSBidXQgd2FzIGNsdXR0ZXJpbmcgdXAgYWxsIHRoZSBmZWF0dXJlIGRvYyBwYWdlcy5cbiAgICAgKi9cbiAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29tbWVudCBOb3QgcmVhbGx5IHByaXZhdGUgYnV0IHdhcyBjbHV0dGVyaW5nIHVwIGFsbCB0aGUgZmVhdHVyZSBkb2MgcGFnZXMuXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29tbWVudCBOb3QgcmVhbGx5IHByaXZhdGUgYnV0IHdhcyBjbHV0dGVyaW5nIHVwIGFsbCB0aGUgZmVhdHVyZSBkb2MgcGFnZXMuXG4gICAgICovXG4gICAgaGFuZGxlQ29udGV4dE1lbnU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVDb250ZXh0TWVudShncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgdG9nZ2xlIHRoZSBjb2x1bW4gcGlja2VyXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29tbWVudCBOb3QgcmVhbGx5IHByaXZhdGUgYnV0IHdhcyBjbHV0dGVyaW5nIHVwIGFsbCB0aGUgZmVhdHVyZSBkb2MgcGFnZXMuXG4gICAgICovXG4gICAgbW92ZVNpbmdsZVNlbGVjdDogZnVuY3Rpb24oZ3JpZCwgeCwgeSkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQubW92ZVNpbmdsZVNlbGVjdChncmlkLCB4LCB5KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaXNGaXJzdEZpeGVkUm93OiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICByZXR1cm4gZXZlbnQuZ3JpZENlbGwueSA8IDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc0ZpcnN0Rml4ZWRDb2x1bW46IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC5ncmlkQ2VsbC54ID09PSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29tbWVudCBOb3QgcmVhbGx5IHByaXZhdGUgYnV0IHdhcyBjbHV0dGVyaW5nIHVwIGFsbCB0aGUgZmVhdHVyZSBkb2MgcGFnZXMuXG4gICAgICovXG4gICAgc2V0Q3Vyc29yOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yKSB7XG4gICAgICAgICAgICBncmlkLmJlQ3Vyc29yKHRoaXMuY3Vyc29yKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29tbWVudCBOb3QgcmVhbGx5IHByaXZhdGUgYnV0IHdhcyBjbHV0dGVyaW5nIHVwIGFsbCB0aGUgZmVhdHVyZSBkb2MgcGFnZXMuXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZU9uOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5pbml0aWFsaXplT24oZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbW1lbnQgTm90IHJlYWxseSBwcml2YXRlIGJ1dCB3YXMgY2x1dHRlcmluZyB1cCBhbGwgdGhlIGZlYXR1cmUgZG9jIHBhZ2VzLlxuICAgICAqL1xuICAgIGhhbmRsZUdyaWRSZW5kZXJlZDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUdyaWRSZW5kZXJlZChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFuZGxlRGF0YVNoYXBlQ2hhbmdlZDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUdyaWRSZW5kZXJlZChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaGFuZGxlQ29sdW1uUmVzaXplZEV2ZW50OiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlQ29sdW1uUmVzaXplZEV2ZW50KGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRmVhdHVyZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEZpbHRlcnMgPSBGZWF0dXJlLmV4dGVuZCgnRmlsdGVycycsIHtcblxuICAgIC8qKlxuICAgICAqIE5hdmlnYXRlIGF3YXkgZnJvbSB0aGUgZmlsdGVyIGNlbGwgd2hlbjpcbiAgICAgKiAxLiBDb21pbmcgZnJvbSBhIGNlbGwgZWRpdG9yIChgZXZlbnQuZGV0YWlsLmVkaXRvcmAgZGVmaW5lZCkuXG4gICAgICogMi4gVGhlIGNlbGwgZWRpdG9yIHdhcyBmb3IgYSBmaWx0ZXIgY2VsbC5cbiAgICAgKiAzLiBUaGUga2V5IChgZXZlbnQuZGV0YWlsLmNoYXIpIG1hcHMgKHRocm91Z2gge0BsaW5rIG1vZHVsZTpkZWZhdWx0cy5uYXZLZXlNYXB8bmF2S2V5TWFwfSkgdG8gb25lIG9mOlxuICAgICAqICAgICogYCdVUCdgIG9yIGAnRE9XTidgIC0gU2VsZWN0cyBmaXJzdCB2aXNpYmxlIGRhdGEgY2VsbCB1bmRlciBmaWx0ZXIgY2VsbC5cbiAgICAgKiAgICAqIGAnTEVGVCdgIC0gT3BlbnMgZmlsdGVyIGNlbGwgZWRpdG9yIGluIHByZXZpb3VzIGZpbHRlcmFibGUgY29sdW1uOyBpZiBub25lc3VjaCwgc2VsZWN0cyBmaXJzdCB2aXNpYmxlIGRhdGEgY2VsbCB1bmRlciBmaWx0ZXIgY2VsbC5cbiAgICAgKiAgICAqIGAnUklHSFQnYCAtIE9wZW5zIGZpbHRlciBjZWxsIGVkaXRvciBpbiBuZXh0IGZpbHRlcmFibGUgY29sdW1uOyBpZiBub25lc3VjaCwgc2VsZWN0cyBmaXJzdCB2aXNpYmxlIGRhdGEgY2VsbCB1bmRlciBmaWx0ZXIgY2VsbC5cbiAgICAgKi9cbiAgICBoYW5kbGVLZXlEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgY2VsbEV2ZW50LCBtYXBwZWROYXZLZXksIGhhbmRsZXIsXG4gICAgICAgICAgICBkZXRhaWwgPSBldmVudC5kZXRhaWw7XG5cbiAgICAgICAgaWYgKGRldGFpbC5lZGl0b3IpIHtcbiAgICAgICAgICAgIGNlbGxFdmVudCA9IGRldGFpbC5lZGl0b3IuZXZlbnQ7XG4gICAgICAgICAgICBpZiAoY2VsbEV2ZW50LmlzRmlsdGVyQ2VsbCkge1xuICAgICAgICAgICAgICAgIG1hcHBlZE5hdktleSA9IGNlbGxFdmVudC5wcm9wZXJ0aWVzLm1hcHBlZE5hdktleShkZXRhaWwuY2hhcik7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IHRoaXNbJ2hhbmRsZScgKyBtYXBwZWROYXZLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBncmlkLCBkZXRhaWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUtleURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGhhbmRsZUxFRlQ6IGZ1bmN0aW9uKGdyaWQsIGRldGFpbCkgeyBtb3ZlTGF0ZXJhbGx5KGdyaWQsIGRldGFpbCwgLTEpOyB9LFxuICAgIGhhbmRsZVJJR0hUOiBmdW5jdGlvbihncmlkLCBkZXRhaWwpIHsgbW92ZUxhdGVyYWxseShncmlkLCBkZXRhaWwsICsxKTsgfSxcbiAgICBoYW5kbGVVUDogbW92ZURvd24sXG4gICAgaGFuZGxlRE9XTjogbW92ZURvd24sXG5cbiAgICBoYW5kbGVEb3VibGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmlzRmlsdGVyQ2VsbCkge1xuICAgICAgICAgICAgZ3JpZC5vbkVkaXRvckFjdGl2YXRlKGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVEb3VibGVDbGljayhncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5pc0ZpbHRlckNlbGwpIHtcbiAgICAgICAgICAgIGdyaWQub25FZGl0b3JBY3RpdmF0ZShldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxuZnVuY3Rpb24gbW92ZUxhdGVyYWxseShncmlkLCBkZXRhaWwsIGRlbHRhWCkge1xuICAgIHZhciBjZWxsRXZlbnQgPSBkZXRhaWwuZWRpdG9yLmV2ZW50LFxuICAgICAgICBncmlkWCA9IGNlbGxFdmVudC52aXNpYmxlQ29sdW1uLmluZGV4LFxuICAgICAgICBncmlkWSA9IGNlbGxFdmVudC52aXNpYmxlUm93LmluZGV4LFxuICAgICAgICBvcmlnaW5YID0gZ3JpZFgsXG4gICAgICAgIEMgPSBncmlkLnJlbmRlcmVyLnZpc2libGVDb2x1bW5zLmxlbmd0aDtcblxuICAgIGNlbGxFdmVudCA9IG5ldyBncmlkLmJlaGF2aW9yLkNlbGxFdmVudDsgLy8gcmVkZWZpbmUgc28gd2UgZG9uJ3QgcmVzZXQgdGhlIG9yaWdpbmFsIGJlbG93XG5cbiAgICB3aGlsZSAoXG4gICAgICAgIChncmlkWCA9IChncmlkWCArIGRlbHRhWCArIEMpICUgQykgIT09IG9yaWdpblggJiZcbiAgICAgICAgY2VsbEV2ZW50LnJlc2V0R3JpZFhZKGdyaWRYLCBncmlkWSlcbiAgICApIHtcbiAgICAgICAgaWYgKGNlbGxFdmVudC5wcm9wZXJ0aWVzLmZpbHRlcmFibGUpIHtcbiAgICAgICAgICAgIC8vIFNlbGVjdCBwcmV2aW91cyBvciBuZXh0IGZpbHRlcmFibGUgY29sdW1uJ3MgZmlsdGVyIGNlbGxcbiAgICAgICAgICAgIGdyaWQuZWRpdEF0KGNlbGxFdmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb3ZlRG93bihncmlkLCBjZWxsRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBtb3ZlRG93bihncmlkLCBkZXRhaWwpIHtcbiAgICB2YXIgY2VsbEV2ZW50ID0gZGV0YWlsLmVkaXRvci5ldmVudCxcbiAgICAgICAgZ3JpZFggPSBjZWxsRXZlbnQudmlzaWJsZUNvbHVtbi5pbmRleDtcblxuICAgIC8vIFNlbGVjdCBmaXJzdCB2aXNpYmxlIGdyaWQgY2VsbCBvZiB0aGlzIGNvbHVtblxuICAgIGdyaWQuc2VsZWN0Vmlld3BvcnRDZWxsKGdyaWRYLCAwKTtcbiAgICBncmlkLnRha2VGb2N1cygpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbHRlcnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlJyk7XG5cbnZhciBjb21tYW5kcyA9IHtcbiAgICBQQUdFRE9XTjogZnVuY3Rpb24oZ3JpZCkgeyBncmlkLnBhZ2VEb3duKCk7IH0sXG4gICAgUEFHRVVQOiBmdW5jdGlvbihncmlkKSB7IGdyaWQucGFnZVVwKCk7IH0sXG4gICAgUEFHRUxFRlQ6IGZ1bmN0aW9uKGdyaWQpIHsgZ3JpZC5wYWdlTGVmdCgpOyB9LFxuICAgIFBBR0VSSUdIVDogZnVuY3Rpb24oZ3JpZCkgeyBncmlkLnBhZ2VSaWdodCgpOyB9XG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgS2V5UGFnaW5nID0gRmVhdHVyZS5leHRlbmQoJ0tleVBhZ2luZycsIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAbWVtYmVyT2YgS2V5UGFnaW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGhhbmRsZUtleURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBmdW5jID0gY29tbWFuZHNbZXZlbnQuZGV0YWlsLmNoYXJdO1xuICAgICAgICBpZiAoZnVuYykge1xuICAgICAgICAgICAgZnVuYyhncmlkKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVLZXlEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5UGFnaW5nO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlJyk7XG5cbnZhciBkZXRhaWxzSG9sZGVyRWxlbWVudDtcbnZhciBkZXRhaWxzU2hvd25PbkRhdGFDZWxsID0gbnVsbDtcblxudmFyIGRldGFpbHNIaWRlVGltZW91dCA9IG51bGw7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBGZWF0dXJlXG4gKi9cbnZhciBMaW5rRGV0YWlscyA9IEZlYXR1cmUuZXh0ZW5kKCdMaW5rRGV0YWlscycsIHtcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgTGlua0RldGFpbHMucHJvdG90eXBlXG4gICAgICogQGRlc2MgaW5pdGlhbCBtZXRob2Qgb2YgYW4gZmVhdHVyZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZU9uOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGlmICghZGV0YWlsc0hvbGRlckVsZW1lbnQpIHtcbiAgICAgICAgICAgIGRldGFpbHNIb2xkZXJFbGVtZW50ID0gdGhpcy5pbml0aWFsaXplTGlua0RldGFpbHNEaXYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5pbml0aWFsaXplT24oZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBMaW5rRGV0YWlscy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1dGlsaXR5IG1ldGhvZCB0byBpbml0aWFsaXplIGRpdiwgdGhhdCBjb250YWlucyBsaW5rIGluZm9cbiAgICAgKi9cbiAgICBpbml0aWFsaXplTGlua0RldGFpbHNEaXY6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaG9sZGVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblxuICAgICAgICBob2xkZXJFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGhvbGRlckVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsICdmaW4tbGluay1kZXRhaWxzLWRpdicpO1xuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaG9sZGVyRWxlbWVudCk7XG5cbiAgICAgICAgcmV0dXJuIGhvbGRlckVsZW1lbnQ7XG4gICAgfSxcblxuICAgIG9uQXBpRGVzdHJveUNhbGxlZDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdGhpcy5oaWRlTGlua0RldGFpbHMoZ3JpZCwgZGV0YWlsc0hvbGRlckVsZW1lbnQpO1xuXG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5vbkFwaURlc3Ryb3lDYWxsZWQoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGhhbmRsZUNhbnZhc091dHNpZGVNb3VzZURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuaGlkZUxpbmtEZXRhaWxzKGdyaWQsIGRldGFpbHNIb2xkZXJFbGVtZW50KTtcblxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlQ2FudmFzT3V0c2lkZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIExpbmtEZXRhaWxzLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmIChkZXRhaWxzU2hvd25PbkRhdGFDZWxsXG4gICAgICAgICAgICAmJiAoZGV0YWlsc1Nob3duT25EYXRhQ2VsbC54ICE9PSBldmVudC5ncmlkQ2VsbC54XG4gICAgICAgICAgICAgICAgfHwgZGV0YWlsc1Nob3duT25EYXRhQ2VsbC55ICE9PSBldmVudC5ncmlkQ2VsbC55KSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlTGlua0RldGFpbHMoZ3JpZCwgZGV0YWlsc0hvbGRlckVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29tbWVudCBOb3QgcmVhbGx5IHByaXZhdGUgYnV0IHdhcyBjbHV0dGVyaW5nIHVwIGFsbCB0aGUgZmVhdHVyZSBkb2MgcGFnZXMuXG4gICAgICovXG4gICAgaGFuZGxlV2hlZWxNb3ZlZDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdGhpcy5oaWRlTGlua0RldGFpbHMoZ3JpZCwgZGV0YWlsc0hvbGRlckVsZW1lbnQpO1xuXG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVXaGVlbE1vdmVkKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICghZGV0YWlsc1Nob3duT25EYXRhQ2VsbFxuICAgICAgICAgICAgfHwgZGV0YWlsc1Nob3duT25EYXRhQ2VsbC54ICE9PSBldmVudC5ncmlkQ2VsbC54XG4gICAgICAgICAgICB8fCBkZXRhaWxzU2hvd25PbkRhdGFDZWxsLnkgIT09IGV2ZW50LmdyaWRDZWxsLnkpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5wcm9wZXJ0aWVzLmxpbmsgfHwgKGV2ZW50LnByb3BlcnRpZXMuZGV0ZWN0TGlua3NQZXJtYW5lbnRseSAmJiBldmVudC5pc1ZhbHVlVXJsKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZUxpbmtEZXRhaWxzKGdyaWQsIGRldGFpbHNIb2xkZXJFbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmtUb0Rpc3BsYXkgPSBldmVudC5wcm9wZXJ0aWVzLmxpbmsgPyBldmVudC5wcm9wZXJ0aWVzLmxpbmsgOiBldmVudC52YWx1ZTtcblxuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRMaW5rRGV0YWlscyhkZXRhaWxzSG9sZGVyRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgZ3JpZCxcbiAgICAgICAgICAgICAgICAgICAgbGlua1RvRGlzcGxheSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuYm91bmRzKTtcblxuICAgICAgICAgICAgICAgIGRldGFpbHNTaG93bk9uRGF0YUNlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGV0YWlsc1Nob3duT25EYXRhQ2VsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZUxpbmtEZXRhaWxzVGltZW91dGVkKGdyaWQsIGRldGFpbHNIb2xkZXJFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZU1vdmUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBMaW5rRGV0YWlscy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1dGlsaXR5IG1ldGhvZCB0byBwYWludCBjb250ZXh0IG1lbnUgYmFzZWQgb24gY2xpY2sgZXZlbnQsIGFuZCBwb3NpdGlvbiBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBsaW5rRGV0YWlsc0hvbGRlckVsZW1lbnQgLSBIdG1sIGVsZW1lbnQgdGhhdCBjb250YWlucyBkZXRhaWxzXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge2FycmF5fHN0cmluZ30gbGlua1ZhbHVlIC0gbGluayB0aGF0IG5lZWQgdG8gYmUgZGV0YWlsZWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2VsbEJvdW5kcyAtIGRlZmluZXMgYm91bmRzIG9mIGNlbGwgY2VsbFxuICAgICAqL1xuICAgIHBhaW50TGlua0RldGFpbHM6IGZ1bmN0aW9uKGxpbmtEZXRhaWxzSG9sZGVyRWxlbWVudCwgZ3JpZCwgbGlua1ZhbHVlLCBjZWxsQm91bmRzKSB7XG4gICAgICAgIHRoaXMuaGlkZUxpbmtEZXRhaWxzKGdyaWQsIGxpbmtEZXRhaWxzSG9sZGVyRWxlbWVudCk7XG5cbiAgICAgICAgbGV0IGxpbmtzID0gbGlua1ZhbHVlO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGlua1ZhbHVlKSkge1xuICAgICAgICAgICAgbGlua3MgPSBbbGlua1ZhbHVlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmtzLmZvckVhY2gobCA9PiB7XG4gICAgICAgICAgICBsZXQgb3V0ZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGxldCBkZXRhaWxzTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblxuICAgICAgICAgICAgaWYgKGdyaWQucHJvcGVydGllcy5saW5rRGV0YWlsc0FuY2hvclN0eWxlKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihkZXRhaWxzTGluay5zdHlsZSwgZ3JpZC5wcm9wZXJ0aWVzLmxpbmtEZXRhaWxzQW5jaG9yU3R5bGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaW5rRGV0YWlsc0hvbGRlckVsZW1lbnQuaHJlZiA9IGw7XG4gICAgICAgICAgICBsaW5rRGV0YWlsc0hvbGRlckVsZW1lbnQudGFyZ2V0ID0gJ19ibGFuayc7XG5cbiAgICAgICAgICAgIGRldGFpbHNMaW5rLmhyZWYgPSBsO1xuICAgICAgICAgICAgbGV0IHRydW5jYXRlZExpbmsgPSB0aGlzLnRydW5jYXRlU3RyaW5nKGwsIGdyaWQucHJvcGVydGllcy5saW5rRGV0YWlsc01heFN0cmluZ0xlbmd0aCwgJy4uLicpO1xuICAgICAgICAgICAgZGV0YWlsc0xpbmsudGV4dCA9IGAke3RydW5jYXRlZExpbmt9ICBgO1xuICAgICAgICAgICAgZGV0YWlsc0xpbmsudGFyZ2V0ID0gJ19ibGFuayc7XG5cbiAgICAgICAgICAgIGxldCBkZXRhaWxzTGlua0ljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpJyk7XG4gICAgICAgICAgICBkZXRhaWxzTGlua0ljb24uc2V0QXR0cmlidXRlKCdjbGFzcycsICdmYSBmYS1leHRlcm5hbC1saW5rJyk7XG5cbiAgICAgICAgICAgIGRldGFpbHNMaW5rLmFwcGVuZENoaWxkKGRldGFpbHNMaW5rSWNvbik7XG5cbiAgICAgICAgICAgIG91dGVyRGl2LmFwcGVuZENoaWxkKGRldGFpbHNMaW5rKTtcbiAgICAgICAgICAgIGxpbmtEZXRhaWxzSG9sZGVyRWxlbWVudC5hcHBlbmRDaGlsZChvdXRlckRpdik7XG4gICAgICAgICAgICBsaW5rRGV0YWlsc0hvbGRlckVsZW1lbnQub25tb3VzZW92ZXIgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obGlua0RldGFpbHNIb2xkZXJFbGVtZW50LnN0eWxlLCBncmlkLnByb3BlcnRpZXMubGlua0RldGFpbHNIb3ZlcmVkU3R5bGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxpbmtEZXRhaWxzSG9sZGVyRWxlbWVudC5vbm1vdXNlb3V0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGxpbmtEZXRhaWxzSG9sZGVyRWxlbWVudC5zdHlsZSwgZ3JpZC5wcm9wZXJ0aWVzLmxpbmtEZXRhaWxzU3R5bGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGdyaWQucHJvcGVydGllcy5saW5rRGV0YWlsc1N0eWxlKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGxpbmtEZXRhaWxzSG9sZGVyRWxlbWVudC5zdHlsZSwgZ3JpZC5wcm9wZXJ0aWVzLmxpbmtEZXRhaWxzU3R5bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zaG93TGlua0RldGFpbHMoZ3JpZCwgbGlua0RldGFpbHNIb2xkZXJFbGVtZW50LCBjZWxsQm91bmRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIExpbmtEZXRhaWxzLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHV0aWxpdHkgbWV0aG9kIHRvIHN0YXJ0IHNob3cgY29udGV4dCBtZW51IG9uIGRlZmluZWQgcG9pbnQuXG4gICAgICogQGRlc2MgTWVudSBtdXN0IGJlIGZvcm1lZCBiZWZvcmUgaXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhpcyBtZXRob2RcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGxpbmtEZXRhaWxzSG9sZGVyRWxlbWVudCAtIEh0bWwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIGRldGFpbHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2VsbEJvdW5kcyAtIGRlZmluZXMgYm91bmRzIG9mIGNlbGwgY2VsbFxuICAgICAqL1xuICAgIHNob3dMaW5rRGV0YWlsczogZnVuY3Rpb24oZ3JpZCwgbGlua0RldGFpbHNIb2xkZXJFbGVtZW50LCBjZWxsQm91bmRzKSB7XG4gICAgICAgIGxpbmtEZXRhaWxzSG9sZGVyRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgICAgICBjb25zdCBob2xkZXJDb21wdXRlZFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGxpbmtEZXRhaWxzSG9sZGVyRWxlbWVudCk7XG5cbiAgICAgICAgbGV0IHN0YXJ0WSwgc3RhcnRYLCBib3R0b21Ub1RvcCA9IHRydWU7XG5cbiAgICAgICAgY29uc3QgaG9sZGVySGVpZ2h0ID0gaG9sZGVyQ29tcHV0ZWRTdHlsZXMuaGVpZ2h0LnJlcGxhY2UoJ3B4JywgJycpO1xuICAgICAgICBpZiAoKGNlbGxCb3VuZHMueSA8IGhvbGRlckhlaWdodCkgJiYgKChOdW1iZXIoY2VsbEJvdW5kcy55KSArIE51bWJlcihob2xkZXJIZWlnaHQpKSA8IHdpbmRvdy5pbm5lckhlaWdodCkpIHtcbiAgICAgICAgICAgIGJvdHRvbVRvVG9wID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYm90dG9tVG9Ub3ApIHtcbiAgICAgICAgICAgIHN0YXJ0WSA9IGNlbGxCb3VuZHMueSArIGdyaWQuY2FudmFzLnNpemUudG9wIC0gaG9sZGVyQ29tcHV0ZWRTdHlsZXMuaGVpZ2h0LnJlcGxhY2UoJ3B4JywgJycpO1xuICAgICAgICAgICAgc3RhcnRYID0gY2VsbEJvdW5kcy54ICsgZ3JpZC5jYW52YXMuc2l6ZS5sZWZ0ICsgZ3JpZC5wcm9wZXJ0aWVzLmdyaWRMaW5lc1dpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRZID0gY2VsbEJvdW5kcy55ICsgY2VsbEJvdW5kcy5oZWlnaHQgKyBncmlkLmNhbnZhcy5zaXplLnRvcDtcbiAgICAgICAgICAgIHN0YXJ0WCA9IGNlbGxCb3VuZHMueCArIGdyaWQuY2FudmFzLnNpemUubGVmdCArIGdyaWQucHJvcGVydGllcy5ncmlkTGluZXNXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmtEZXRhaWxzSG9sZGVyRWxlbWVudC5zdHlsZS50b3AgPSBzdGFydFkgKyAncHgnO1xuICAgICAgICBsaW5rRGV0YWlsc0hvbGRlckVsZW1lbnQuc3R5bGUubGVmdCA9IHN0YXJ0WCArICdweCc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBMaW5rRGV0YWlscy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1dGlsaXR5IG1ldGhvZCB0byBzdG9wIGRpc3BsYXlpbmcgY29udGV4dCBtZW51XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGV0YWlsc0hvbGRlckVsZW1lbnQgLSBIdG1sIGVsZW1lbnQgdGhhdCBjb250YWlucyBsaW5rIGluZm9cbiAgICAgKi9cbiAgICBoaWRlTGlua0RldGFpbHM6IGZ1bmN0aW9uKGdyaWQsIGRldGFpbHNIb2xkZXJFbGVtZW50KSB7XG4gICAgICAgIGRldGFpbHNIb2xkZXJFbGVtZW50LmlubmVySFRNTCA9ICcnO1xuICAgICAgICBkZXRhaWxzSG9sZGVyRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBkZXRhaWxzU2hvd25PbkRhdGFDZWxsID0gbnVsbDtcbiAgICAgICAgaWYgKGRldGFpbHNIaWRlVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRldGFpbHNIaWRlVGltZW91dCk7XG4gICAgICAgICAgICBkZXRhaWxzSGlkZVRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBMaW5rRGV0YWlscy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1dGlsaXR5IG1ldGhvZCB0byBzdG9wIGRpc3BsYXlpbmcgY29udGV4dCBtZW51XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGV0YWlsc0hvbGRlckVsZW1lbnQgLSBIdG1sIGVsZW1lbnQgdGhhdCBjb250YWlucyBsaW5rIGluZm9cbiAgICAgKi9cbiAgICBoaWRlTGlua0RldGFpbHNUaW1lb3V0ZWQ6IGZ1bmN0aW9uKGdyaWQsIGRldGFpbHNIb2xkZXJFbGVtZW50KSB7XG4gICAgICAgIGlmICghZGV0YWlsc0hpZGVUaW1lb3V0KSB7XG4gICAgICAgICAgICBkZXRhaWxzSGlkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVMaW5rRGV0YWlscyhncmlkLCBkZXRhaWxzSG9sZGVyRWxlbWVudCk7XG4gICAgICAgICAgICB9LCBncmlkLnByb3BlcnRpZXMubGlua0RldGFpbHNIaWRlVGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIExpbmtEZXRhaWxzLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHV0aWxpdHkgbWV0aG9kIHRvIHJlbW92ZSBIVE1MIGVsZW1lbnQgZnJvbSBjdXJyZW50IERPTVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBIVE1MIGVsZW1lbnQgdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWQgZnJvbSBET01cbiAgICAgKi9cbiAgICByZW1vdmVET01FbGVtZW50OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBMaW5rRGV0YWlscy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1dGlsaXR5IG1ldGhvZCB0byB0cnVuY2F0ZSBzdHJpbmcuIElmIHN0cmluZyBncmVhdGVyLCB0aGFuIHZhbHVlLFxuICAgICAqIGNlbnRyYWwgcGFydCBvZiBzdHJpbmcgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHNlcGFyYXRvclxuICAgICAqIEBwYXJhbSBmdWxsU3RyXG4gICAgICogQHBhcmFtIHN0ckxlblxuICAgICAqIEBwYXJhbSBzZXBhcmF0b3JcbiAgICAgKi9cbiAgICB0cnVuY2F0ZVN0cmluZzogZnVuY3Rpb24oZnVsbFN0ciwgc3RyTGVuLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgaWYgKGZ1bGxTdHIubGVuZ3RoIDw9IHN0ckxlbikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bGxTdHI7XG4gICAgICAgIH1cblxuICAgICAgICBzZXBhcmF0b3IgPSBzZXBhcmF0b3IgfHwgJy4uLic7XG5cbiAgICAgICAgbGV0IHNlcExlbiA9IHNlcGFyYXRvci5sZW5ndGgsXG4gICAgICAgICAgICBjaGFyc1RvU2hvdyA9IHN0ckxlbiAtIHNlcExlbixcbiAgICAgICAgICAgIGZyb250Q2hhcnMgPSBNYXRoLmNlaWwoY2hhcnNUb1Nob3cgLyAyKSxcbiAgICAgICAgICAgIGJhY2tDaGFycyA9IE1hdGguZmxvb3IoY2hhcnNUb1Nob3cgLyAyKTtcblxuICAgICAgICByZXR1cm4gZnVsbFN0ci5zdWJzdHIoMCwgZnJvbnRDaGFycykgK1xuICAgICAgICAgICAgc2VwYXJhdG9yICtcbiAgICAgICAgICAgIGZ1bGxTdHIuc3Vic3RyKGZ1bGxTdHIubGVuZ3RoIC0gYmFja0NoYXJzKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5rRGV0YWlscztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE9uSG92ZXIgPSBGZWF0dXJlLmV4dGVuZCgnT25Ib3ZlcicsIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAbWVtYmVyT2YgT25Ib3Zlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBob3ZlckNlbGwgPSBncmlkLmhvdmVyQ2VsbDtcbiAgICAgICAgaWYgKCFldmVudC5ncmlkQ2VsbC5lcXVhbHMoaG92ZXJDZWxsKSkge1xuICAgICAgICAgICAgaWYgKGhvdmVyQ2VsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VFeGl0KGdyaWQsIGhvdmVyQ2VsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRW50ZXIoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgZ3JpZC5zZXRIb3ZlckNlbGwoZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlTW92ZShncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9uSG92ZXI7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbi8qIGdsb2JhbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZScpO1xuXG52YXIgcm93Rml4YXRpb25EcmFnZ2VyO1xudmFyIHJvd0ZpeGF0aW9uRHJhZ2dlckNUWDtcbnZhciByb3dGaXhhdGlvblBsYWNlaG9sZGVyO1xudmFyIHJvd0ZpeGF0aW9uUGxhY2Vob2xkZXJDVFg7XG5cbnZhciBHUkFCID0gWydncmFiJywgJy1tb3otZ3JhYicsICctd2Via2l0LWdyYWInXSxcbiAgICBHUkFCQklORyA9IFsnZ3JhYmJpbmcnLCAnLW1vei1ncmFiYmluZycsICctd2Via2l0LWdyYWJiaW5nJ107XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBGZWF0dXJlXG4gKi9cbnZhciBSb3dGaXhhdGlvbiA9IEZlYXR1cmUuZXh0ZW5kKCdSb3dGaXhhdGlvbicsIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgUm93Rml4YXRpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ2dpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogYW4gb2Zmc2V0IHRvIHBvc2l0aW9uIHRoZSBkcmFnZ2VyIGZyb20gdGhlIGN1cnNvclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIFJvd0ZpeGF0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRyYWdPZmZzZXQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBjdXJyZW50IHBvc2l0aW9uIChpbmRleCkgb2YgYW4gcGxhY2Vob2xkZXJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBSb3dGaXhhdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjdXJyZW50UGxhY2Vob2xkZXJSb3dJbmRleDogLTEsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93Rml4YXRpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgZmlyZWQgZXZlcnkgdGltZSB3aGVuIGdyaWQgcmVuZGVyZWRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlR3JpZFJlbmRlcmVkOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVBbmltYXRpb25TdXBwb3J0KGdyaWQpO1xuXG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVHcmlkUmVuZGVyZWQoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dGaXhhdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBpbml0aWFsaXplIGFuaW1hdGlvbiBzdXBwb3J0IG9uIHRoZSBncmlkXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBpbml0aWFsaXplQW5pbWF0aW9uU3VwcG9ydDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLmNyZWF0ZU9yVXBkYXRlRHJhZ2dlcihncmlkKTtcbiAgICAgICAgaWYgKCFyb3dGaXhhdGlvblBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICByb3dGaXhhdGlvblBsYWNlaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICByb3dGaXhhdGlvblBsYWNlaG9sZGVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMHB4Jyk7XG4gICAgICAgICAgICByb3dGaXhhdGlvblBsYWNlaG9sZGVyLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzBweCcpO1xuICAgICAgICAgICAgcm93Rml4YXRpb25QbGFjZWhvbGRlci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocm93Rml4YXRpb25QbGFjZWhvbGRlcik7XG4gICAgICAgICAgICByb3dGaXhhdGlvblBsYWNlaG9sZGVyQ1RYID0gcm93Rml4YXRpb25QbGFjZWhvbGRlci5nZXRDb250ZXh0KCcyZCcsIHsgYWxwaGE6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dGaXhhdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93Rml4YXRpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd0ZpeGF0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd0ZpeGF0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZU1vdmUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dGaXhhdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1dGlsaXR5IGZ1bmN0aW9uIHRvIG1vdmUgZHJhZ2dlciBiYXNlZCBvbiBjdXJyZW50IGN1cnNvciBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj99IG1vdmVQbGFjZWhvbGRlck5lZWRlZFxuICAgICAqL1xuICAgIG1vdmVEcmFnZ2VyOiBmdW5jdGlvbihncmlkLCB4LCB5LCBtb3ZlUGxhY2Vob2xkZXJOZWVkZWQpIHtcbiAgICAgICAgbW92ZVBsYWNlaG9sZGVyTmVlZGVkID0gdHlwZW9mIG1vdmVQbGFjZWhvbGRlck5lZWRlZCAhPT0gJ3VuZGVmaW5lZCcgPyBtb3ZlUGxhY2Vob2xkZXJOZWVkZWQgOiB0cnVlO1xuICAgICAgICBncmlkLmxvZyh5ICsgZ3JpZC5jYW52YXMuc2l6ZS50b3ApO1xuICAgICAgICByb3dGaXhhdGlvbkRyYWdnZXIuc3R5bGUudG9wID0geSArIGdyaWQuY2FudmFzLnNpemUudG9wICsgJ3B4JztcblxuICAgICAgICBpZiAobW92ZVBsYWNlaG9sZGVyTmVlZGVkKSB7XG4gICAgICAgICAgICB2YXIgbmVhcmVzdFJvd0luZGV4ID0gdGhpcy5nZXROZWFyZXN0Um93SW5kZXgoZ3JpZCwgeCwgeSk7XG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBuZWFyZXN0Um93SW5kZXggIT09ICd1bmRlZmluZWQnKSAmJiBuZWFyZXN0Um93SW5kZXggIT09IHRoaXMuY3VycmVudFBsYWNlaG9sZGVyUm93SW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVQbGFjZWhvbGRlclRvKGdyaWQsIG5lYXJlc3RSb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGxhY2Vob2xkZXJSb3dJbmRleCA9IG5lYXJlc3RSb3dJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93Rml4YXRpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXRpbGl0eSBmdW5jdGlvbiB0byBtb3ZlIHBsYWNlaG9sZGVyIHRvIHRoZSBzdGFydCBjb29yZGluYXRlcyBvZiBjb2x1bW5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5cbiAgICAgKi9cbiAgICBtb3ZlUGxhY2Vob2xkZXJUbzogZnVuY3Rpb24oZ3JpZCwgY29sdW1uKSB7XG4gICAgICAgIHZhciBuZXdTdGFydFkgPSB0aGlzLmdldFN0YXJ0QnlSb3dJbmRleChncmlkLCBjb2x1bW4pO1xuXG4gICAgICAgIHJvd0ZpeGF0aW9uUGxhY2Vob2xkZXIuc3R5bGUudG9wID0gbmV3U3RhcnRZICsgJ3B4JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd0ZpeGF0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGNyZWF0ZSB0aGUgcGxhY2Vob2xkZXIgYmFzZWQgb24gY3VycmVudCBjb3VudCBvZiBmaXhlZCBjb2x1bW5zXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBjcmVhdGVQbGFjZWhvbGRlcjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB2YXIgZml4YXRpb25MaW5lV2lkdGggPSBncmlkLnByb3BlcnRpZXMuZml4ZWRMaW5lc1ZXaWR0aDtcbiAgICAgICAgdmFyIHN0YXJ0WSA9IHRoaXMuZ2V0U3RhcnRCeUZpeGVkUm93c0NvdW50KGdyaWQpO1xuICAgICAgICB2YXIgcm93SGVhZGVyV2lkdGggPSBncmlkLnJlbmRlcmVyLnZpc2libGVDb2x1bW5zWzBdLmxlZnQ7XG4gICAgICAgIHZhciBncmlkV2lkdGggPSBncmlkLmRpdi5jbGllbnRXaWR0aDtcblxuICAgICAgICB2YXIgaGRwaVJhdGlvID0gZ3JpZC5nZXRIaURQSShyb3dGaXhhdGlvblBsYWNlaG9sZGVyQ1RYKTtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gZ3JpZC5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgcm93Rml4YXRpb25QbGFjZWhvbGRlci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgKGdyaWRXaWR0aCAqIGhkcGlSYXRpbykgKyAncHgnKTtcbiAgICAgICAgcm93Rml4YXRpb25QbGFjZWhvbGRlci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIChmaXhhdGlvbkxpbmVXaWR0aCAqIGhkcGlSYXRpbykgKyAncHgnKTtcbiAgICAgICAgcm93Rml4YXRpb25QbGFjZWhvbGRlci5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgIHJvd0ZpeGF0aW9uUGxhY2Vob2xkZXIuc3R5bGUudG9wID0gc3RhcnRZICsgJ3B4JztcbiAgICAgICAgcm93Rml4YXRpb25QbGFjZWhvbGRlci5zdHlsZS5sZWZ0ID0gbG9jYXRpb24ubGVmdCArICdweCc7XG4gICAgICAgIHJvd0ZpeGF0aW9uUGxhY2Vob2xkZXIuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuXG4gICAgICAgIHJvd0ZpeGF0aW9uUGxhY2Vob2xkZXJDVFguY2xlYXJSZWN0KDAsIDAsIGdyaWRXaWR0aCwgZml4YXRpb25MaW5lV2lkdGgpO1xuICAgICAgICByb3dGaXhhdGlvblBsYWNlaG9sZGVyQ1RYLmZpbGxTdHlsZSA9IGdyaWQucHJvcGVydGllcy5yb3dGaXhhdGlvblBsYWNlaG9sZGVySGVhZGVyQ29sb3I7XG4gICAgICAgIHJvd0ZpeGF0aW9uUGxhY2Vob2xkZXJDVFguZmlsbFJlY3QoMCwgMCwgcm93SGVhZGVyV2lkdGgsIGZpeGF0aW9uTGluZVdpZHRoKTtcbiAgICAgICAgcm93Rml4YXRpb25QbGFjZWhvbGRlckNUWC5maWxsU3R5bGUgPSBncmlkLnByb3BlcnRpZXMucm93Rml4YXRpb25QbGFjZWhvbGRlckJvZHlDb2xvcjtcbiAgICAgICAgcm93Rml4YXRpb25QbGFjZWhvbGRlckNUWC5maWxsUmVjdChyb3dIZWFkZXJXaWR0aCwgMCwgZ3JpZFdpZHRoLCBmaXhhdGlvbkxpbmVXaWR0aCk7XG5cbiAgICAgICAgdGhpcy5tb3ZlUGxhY2Vob2xkZXJUbyhncmlkLCBncmlkLmdldEZpeGVkUm93Q291bnQoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dGaXhhdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1dGlsaXR5IGZ1bmN0aW9uIGZvciBzZXR0aW5nIGNyb3NzIGJyb3dzZXIgY3NzIHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZGVzY3JpcHRvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBhc3NpZ25cbiAgICAgKi9cbiAgICBzZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eTogZnVuY3Rpb24oZWxlbWVudCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIHZhciB1UHJvcGVydHkgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc3Vic3RyKDEpO1xuICAgICAgICB0aGlzLnNldFByb3AoZWxlbWVudCwgJ3dlYmtpdCcgKyB1UHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zZXRQcm9wKGVsZW1lbnQsICdNb3onICsgdVByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcChlbGVtZW50LCAnbXMnICsgdVByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcChlbGVtZW50LCAnTycgKyB1UHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zZXRQcm9wKGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dGaXhhdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBjcmVhdGUgdGhlIGRyYWdnZWQgY29sdW1uIGJhc2VkIG9uIGN1cnJlbnQgY291bnQgb2YgZml4ZWQgY29sdW1uc1xuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgY3JlYXRlT3JVcGRhdGVEcmFnZ2VyOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJvd0ZpeGF0aW9uRHJhZ2dlcikge1xuICAgICAgICAgICAgcm93Rml4YXRpb25EcmFnZ2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICByb3dGaXhhdGlvbkRyYWdnZXJDVFggPSByb3dGaXhhdGlvbkRyYWdnZXIuZ2V0Q29udGV4dCgnMmQnLCB7IGFscGhhOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocm93Rml4YXRpb25EcmFnZ2VyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaXhhdGlvbkxpbmVXaWR0aCA9IHRoaXMuZml4YXRpb25MaW5lV2lkdGggPSBncmlkLnByb3BlcnRpZXMuZml4ZWRMaW5lc1ZXaWR0aDtcbiAgICAgICAgdmFyIHN0YXJ0WSA9IHRoaXMuZ2V0U3RhcnRCeUZpeGVkUm93c0NvdW50KGdyaWQpO1xuXG4gICAgICAgIHZhciByb3dIZWFkZXJXaWR0aCA9IGdyaWQucmVuZGVyZXIudmlzaWJsZUNvbHVtbnNbMF0ubGVmdDtcbiAgICAgICAgdmFyIGdyaWRXaWR0aCA9IGdyaWQuZGl2LmNsaWVudFdpZHRoO1xuXG4gICAgICAgIHZhciBoZHBpUmF0aW8gPSBncmlkLmdldEhpRFBJKHJvd0ZpeGF0aW9uRHJhZ2dlckNUWCk7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IGdyaWQuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIHJvd0ZpeGF0aW9uRHJhZ2dlci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgKGdyaWRXaWR0aCAqIGhkcGlSYXRpbykgKyAncHgnKTtcbiAgICAgICAgcm93Rml4YXRpb25EcmFnZ2VyLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgKGZpeGF0aW9uTGluZVdpZHRoICogaGRwaVJhdGlvKSArICdweCcpO1xuICAgICAgICByb3dGaXhhdGlvbkRyYWdnZXIuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICByb3dGaXhhdGlvbkRyYWdnZXIuc3R5bGUudG9wID0gc3RhcnRZICsgJ3B4JztcbiAgICAgICAgcm93Rml4YXRpb25EcmFnZ2VyLnN0eWxlLmxlZnQgPSBsb2NhdGlvbi5sZWZ0ICsgJ3B4JztcbiAgICAgICAgcm93Rml4YXRpb25EcmFnZ2VyLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcblxuICAgICAgICByb3dGaXhhdGlvbkRyYWdnZXJDVFguY2xlYXJSZWN0KDAsIDAsIGdyaWRXaWR0aCwgZml4YXRpb25MaW5lV2lkdGgpO1xuICAgICAgICByb3dGaXhhdGlvbkRyYWdnZXJDVFguZmlsbFN0eWxlID0gZ3JpZC5wcm9wZXJ0aWVzLnJvd0ZpeGF0aW9uRHJhZ2dlckhlYWRlckluYWN0aXZlQ29sb3I7XG4gICAgICAgIHJvd0ZpeGF0aW9uRHJhZ2dlckNUWC5maWxsUmVjdCgwLCAwLCByb3dIZWFkZXJXaWR0aCwgZml4YXRpb25MaW5lV2lkdGgpO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcm93Rml4YXRpb25EcmFnZ2VyLm9ubW91c2VlbnRlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuY3Vyc29yID0gR1JBQjtcblxuICAgICAgICAgICAgICAgIHJvd0ZpeGF0aW9uRHJhZ2dlckNUWC5jbGVhclJlY3QoMCwgMCwgZ3JpZFdpZHRoLCBmaXhhdGlvbkxpbmVXaWR0aCk7XG4gICAgICAgICAgICAgICAgcm93Rml4YXRpb25EcmFnZ2VyQ1RYLmZpbGxTdHlsZSA9IGdyaWQucHJvcGVydGllcy5yb3dGaXhhdGlvbkRyYWdnZXJIZWFkZXJIb3ZlcmVkQ29sb3I7XG4gICAgICAgICAgICAgICAgcm93Rml4YXRpb25EcmFnZ2VyQ1RYLmZpbGxSZWN0KDAsIDAsIHJvd0hlYWRlcldpZHRoLCBmaXhhdGlvbkxpbmVXaWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcm93Rml4YXRpb25EcmFnZ2VyLm9ubW91c2VsZWF2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgIHNlbGYuY3Vyc29yID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHJvd0ZpeGF0aW9uRHJhZ2dlckNUWC5jbGVhclJlY3QoMCwgMCwgZ3JpZFdpZHRoLCBmaXhhdGlvbkxpbmVXaWR0aCk7XG4gICAgICAgICAgICAgICAgcm93Rml4YXRpb25EcmFnZ2VyQ1RYLmZpbGxTdHlsZSA9IGdyaWQucHJvcGVydGllcy5yb3dGaXhhdGlvbkRyYWdnZXJIZWFkZXJJbmFjdGl2ZUNvbG9yO1xuICAgICAgICAgICAgICAgIHJvd0ZpeGF0aW9uRHJhZ2dlckNUWC5maWxsUmVjdCgwLCAwLCByb3dIZWFkZXJXaWR0aCwgZml4YXRpb25MaW5lV2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJvd0ZpeGF0aW9uRHJhZ2dlci5vbm1vdXNlZG93biA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IEdSQUJCSU5HO1xuXG4gICAgICAgICAgICBzZWxmLmRyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgZ3JpZC5zY3JvbGxUb01ha2VWaXNpYmxlKGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpLCBncmlkLmdldEZpeGVkUm93Q291bnQoKSAtIDEpO1xuXG4gICAgICAgICAgICBzZWxmLmNyZWF0ZVBsYWNlaG9sZGVyKGdyaWQpO1xuICAgICAgICAgICAgc2VsZi5kcmFnT2Zmc2V0ID0gcm93Rml4YXRpb25EcmFnZ2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcblxuICAgICAgICAgICAgcm93Rml4YXRpb25EcmFnZ2VyQ1RYLmNsZWFyUmVjdCgwLCAwLCBncmlkV2lkdGgsIGZpeGF0aW9uTGluZVdpZHRoKTtcbiAgICAgICAgICAgIHJvd0ZpeGF0aW9uRHJhZ2dlckNUWC5maWxsU3R5bGUgPSBncmlkLnByb3BlcnRpZXMucm93Rml4YXRpb25EcmFnZ2VySGVhZGVyRHJhZ2dpbmdDb2xvcjtcbiAgICAgICAgICAgIHJvd0ZpeGF0aW9uRHJhZ2dlckNUWC5maWxsUmVjdCgwLCAwLCByb3dIZWFkZXJXaWR0aCwgZml4YXRpb25MaW5lV2lkdGgpO1xuICAgICAgICAgICAgcm93Rml4YXRpb25EcmFnZ2VyQ1RYLmZpbGxTdHlsZSA9IGdyaWQucHJvcGVydGllcy5yb3dGaXhhdGlvbkRyYWdnZXJCb2R5RHJhZ2dpbmdDb2xvcjtcbiAgICAgICAgICAgIHJvd0ZpeGF0aW9uRHJhZ2dlckNUWC5maWxsUmVjdChyb3dIZWFkZXJXaWR0aCwgMCwgZ3JpZFdpZHRoLCBmaXhhdGlvbkxpbmVXaWR0aCk7XG5cbiAgICAgICAgICAgIGRvY3VtZW50Lm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdZID0gZS5jbGllbnRZIC0gKGdyaWQucHJvcGVydGllcy5maXhlZExpbmVzVldpZHRoIC8gMikgLSBncmlkLmNhbnZhcy5zaXplLnRvcDtcblxuICAgICAgICAgICAgICAgIHNlbGYubW92ZURyYWdnZXIoZ3JpZCwgZS5jbGllbnRYLCBuZXdZKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkb2N1bWVudC5vbm1vdXNldXAgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQub25tb3VzZW1vdmUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50Lm9ubW91c2V1cCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5kcmFnZ2luZykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmN1cnNvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGVyZm9ybUZpeGF0aW9uKGdyaWQpO1xuICAgICAgICAgICAgICAgICAgICBncmlkLnBhaW50Tm93KCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubW92ZURyYWdnZXIoZ3JpZCwgMCwgc2VsZi5nZXRTdGFydEJ5Rml4ZWRSb3dzQ291bnQoZ3JpZCkgLSBncmlkLmNhbnZhcy5zaXplLnRvcCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJzb3IgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgcm93Rml4YXRpb25EcmFnZ2VyQ1RYLmNsZWFyUmVjdCgwLCAwLCBncmlkV2lkdGgsIGZpeGF0aW9uTGluZVdpZHRoKTtcbiAgICAgICAgICAgICAgICByb3dGaXhhdGlvbkRyYWdnZXJDVFguZmlsbFN0eWxlID0gZ3JpZC5wcm9wZXJ0aWVzLnJvd0ZpeGF0aW9uRHJhZ2dlckhlYWRlckluYWN0aXZlQ29sb3I7XG4gICAgICAgICAgICAgICAgcm93Rml4YXRpb25EcmFnZ2VyQ1RYLmZpbGxSZWN0KDAsIDAsIHJvd0hlYWRlcldpZHRoLCBmaXhhdGlvbkxpbmVXaWR0aCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93Rml4YXRpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXRpbGl0eSBtZXRob2QgdG8gZ2V0IHN0YXJ0IHBvc2l0aW9uIGJhc2VkIG9uIGN1cnJlbnQgZml4ZWQgcm93cyBjb3VudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgZ2V0U3RhcnRCeUZpeGVkUm93c0NvdW50OiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXJ0QnlSb3dJbmRleChncmlkLCBncmlkLnByb3BlcnRpZXMuZml4ZWRSb3dDb3VudCArIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93Rml4YXRpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXRpbGl0eSBtZXRob2QgdG8gZ2V0IHN0YXJ0IHBvc2l0aW9uIGJhc2VkIG9uIHJvd0luZGV4XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXhcbiAgICAgKi9cbiAgICBnZXRTdGFydEJ5Um93SW5kZXg6IGZ1bmN0aW9uKGdyaWQsIHJvd0luZGV4KSB7XG4gICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IGdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgaWYgKHJvd0luZGV4IDwgaGVhZGVyUm93Q291bnQpIHtcbiAgICAgICAgICAgIHJvd0luZGV4ID0gaGVhZGVyUm93Q291bnQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBpZiAocm93SW5kZXggPiAxKSB7IC8vIDEgYmVjYXVzZSBvZiBoZWFkZXJzXG4gICAgICAgICAgICB2YXIgcm93ID0gZ3JpZC5yZW5kZXJlci52aXNpYmxlUm93c1tyb3dJbmRleCAtIDFdO1xuICAgICAgICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgICAgICAgICByb3cgPSBncmlkLnJlbmRlcmVyLnZpc2libGVSb3dzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzID0gcm93ID8gcm93LmJvdHRvbSA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBncmlkLnJlbmRlcmVyLnZpc2libGVSb3dzWzBdLmJvdHRvbSAtIHRoaXMuZml4YXRpb25MaW5lV2lkdGggKyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcyArIGdyaWQuY2FudmFzLnNpemUudG9wO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd0ZpeGF0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHV0aWxpdHkgbWV0aG9kIHRvIHNldCBncmlkIG9wdGlvbnMgd2hlbiBkcmFnZ2luZyBlbmRzXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBwZXJmb3JtRml4YXRpb246IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRGaXhlZFJvd0NvdW50ID0gZ3JpZC5wcm9wZXJ0aWVzLmZpeGVkUm93Q291bnQ7XG4gICAgICAgIHJvd0ZpeGF0aW9uUGxhY2Vob2xkZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGxhY2Vob2xkZXJSb3dJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdGaXhlZFJvd1ZhbHVlID0gdGhpcy5jdXJyZW50UGxhY2Vob2xkZXJSb3dJbmRleCAtIGdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcblxuICAgICAgICBncmlkLmFkZFByb3BlcnRpZXMoe1xuICAgICAgICAgICAgZml4ZWRSb3dDb3VudDogbmV3Rml4ZWRSb3dWYWx1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBncmlkLmZpcmVTeW50aGV0aWNPbkZpeGVkUm93Q291bnRDaGFuZ2VkRXZlbnQoY3VycmVudEZpeGVkUm93Q291bnQsIG5ld0ZpeGVkUm93VmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93Rml4YXRpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXRpbGl0eSBmdW5jdGlvbiB0byBnZXQgbmVhcmVzdCBwb3NzaWJsZSBpbmRleCBmcm9tIGFuIGN1cnNvciBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBob3Jpem9udGFsIGN1cnNvciBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gaG9yaXpvbnRhbCBjdXJzb3IgcG9zaXRpb25cbiAgICAgKi9cbiAgICBnZXROZWFyZXN0Um93SW5kZXg6IGZ1bmN0aW9uKGdyaWQsIHgsIHkpIHtcbiAgICAgICAgdmFyIGNlbGxVbmRlckN1cnNvciA9IGdyaWQucmVuZGVyZXIuZ2V0R3JpZENlbGxGcm9tTW91c2VQb2ludCh7IHg6IHgsIHk6IHkgfSk7XG4gICAgICAgIHZhciByb3dVbmRlckN1cnNvckluZGV4ID0gY2VsbFVuZGVyQ3Vyc29yLmNlbGxFdmVudC52aXNpYmxlUm93LnJvd0luZGV4O1xuICAgICAgICB2YXIgdmlzaWJsZVJvd3MgPSBncmlkLnJlbmRlcmVyLnZpc2libGVSb3dzO1xuXG4gICAgICAgIHZhciBtYXggPSBncmlkLmdldFZpc2libGVSb3dzQ291bnQoKTtcbiAgICAgICAgdmFyIGNvbHVtblN0YXJ0WSA9IHZpc2libGVSb3dzW01hdGgubWluKG1heCwgcm93VW5kZXJDdXJzb3JJbmRleCldLnRvcDtcbiAgICAgICAgdmFyIGNvbHVtbkVuZFkgPSB2aXNpYmxlUm93c1tNYXRoLm1pbihtYXgsIHJvd1VuZGVyQ3Vyc29ySW5kZXgpXS5ib3R0b207XG5cbiAgICAgICAgdmFyIHJlcyA9IHJvd1VuZGVyQ3Vyc29ySW5kZXg7XG5cbiAgICAgICAgaWYgKCEoTWF0aC5hYnMoY29sdW1uU3RhcnRZIC0geSkgPCBNYXRoLmFicyhjb2x1bW5FbmRZIC0geSkpKSB7XG4gICAgICAgICAgICByZXMgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXMgPj0gdmlzaWJsZVJvd3NbdmlzaWJsZVJvd3MubGVuZ3RoIC0gMl0uY29sdW1uSW5kZXgpIHtcbiAgICAgICAgICAgIHJlcyA9IHZpc2libGVSb3dzW3Zpc2libGVSb3dzLmxlbmd0aCAtIDNdLmNvbHVtbkluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuXG4gICAgICAgIGlmIChyZXMgPD0gaGVhZGVyUm93Q291bnQpIHtcbiAgICAgICAgICAgIHJlcyA9IGhlYWRlclJvd0NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcblxuICAgIHNldFByb3A6IGZ1bmN0aW9uKGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICBpZiAocHJvcGVydHkgaW4gZWxlbWVudC5zdHlsZSkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvd0ZpeGF0aW9uO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBSb3dTZWxlY3Rpb24gPSBGZWF0dXJlLmV4dGVuZCgnUm93U2VsZWN0aW9uJywge1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBtb3VzZSBwb2ludGVyIGR1cmluZyBhIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjdXJyZW50RHJhZzogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjZWxsIGNvb3JkaW5hdGVzIG9mIHRoZSB3aGVyZSB0aGUgbW91c2UgcG9pbnRlciBpcyBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGxhc3REcmFnQ2VsbDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGEgbWlsbGlzZWNvbmQgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBwcmV2aW91cyB0aW1lIGFuIGF1dG9zY3JvbGwgc3RhcnRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JMYXN0QXV0bzogMCxcblxuICAgIC8qKlxuICAgICAqIGEgbWlsbGlzZWNvbmQgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSB0aW1lIHRoZSBjdXJyZW50IGF1dG9zY3JvbGwgc3RhcnRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JBdXRvU3RhcnQ6IDAsXG5cbiAgICBkcmFnQXJtZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ0FybWVkKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdBcm1lZCA9IGZhbHNlO1xuICAgICAgICAgICAgZ3JpZC5maXJlU3ludGhldGljUm93U2VsZWN0aW9uQ2hhbmdlZEV2ZW50KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgZ3JpZC5maXJlU3ludGhldGljUm93U2VsZWN0aW9uQ2hhbmdlZEV2ZW50KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgcm93U2VsZWN0YWJsZSA9IGdyaWQucHJvcGVydGllcy5yb3dTZWxlY3Rpb24gJiZcbiAgICAgICAgICAgICFldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwuaXNSaWdodENsaWNrICYmXG4gICAgICAgICAgICBncmlkLnByb3BlcnRpZXMuc2hvd1Jvd051bWJlcnMgJiZcbiAgICAgICAgICAgIGV2ZW50LmlzSGFuZGxlQ29sdW1uO1xuXG4gICAgICAgIGlmIChyb3dTZWxlY3RhYmxlICYmIGV2ZW50LmlzSGVhZGVySGFuZGxlKSB7XG4gICAgICAgICAgICAvL2dsb2JhbCByb3cgc2VsZWN0aW9uXG4gICAgICAgICAgICBncmlkLnRvZ2dsZVNlbGVjdEFsbFJvd3MoKTtcbiAgICAgICAgfSBlbHNlIGlmIChyb3dTZWxlY3RhYmxlICYmIGV2ZW50LmlzRGF0YVJvdykgIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBpbiB0aGUgZml4ZWQgYXJlYSwgZG8gbm90IGFwcGx5IHRoZSBzY3JvbGwgdmFsdWVzXG4gICAgICAgICAgICB0aGlzLmRyYWdBcm1lZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmV4dGVuZFNlbGVjdGlvbihncmlkLCBldmVudC5kYXRhQ2VsbC55LCBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwua2V5cyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWc6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuZHJhZ0FybWVkICYmXG4gICAgICAgICAgICBncmlkLnByb3BlcnRpZXMucm93U2VsZWN0aW9uICYmXG4gICAgICAgICAgICAhZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmlzUmlnaHRDbGlja1xuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vaWYgd2UgYXJlIGluIHRoZSBmaXhlZCBhcmVhIGRvIG5vdCBhcHBseSB0aGUgc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgICAgdGhpcy5sYXN0RHJhZ1JvdyA9IGV2ZW50LmRhdGFDZWxsLnk7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERyYWcgPSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRHJhZ1Njcm9sbChncmlkLCB0aGlzLmN1cnJlbnREcmFnKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbihncmlkLCB0aGlzLmxhc3REcmFnUm93LCBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwua2V5cyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVLZXlEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgaGFuZGxlcjtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZ3JpZC5nZXRMYXN0U2VsZWN0aW9uVHlwZSgpID09PSAncm93JyAmJlxuICAgICAgICAgICAgKGhhbmRsZXIgPSB0aGlzWydoYW5kbGUnICsgZXZlbnQuZGV0YWlsLmNoYXJdKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBncmlkLCBldmVudC5kZXRhaWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUtleURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIGEgbW91c2VkcmFnIHNlbGVjdGlvblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gYXJyYXkgb2YgdGhlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IHByZXNzZWQgZG93blxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb246IGZ1bmN0aW9uKGdyaWQsIHksIGtleXMpIHtcbiAgICAgICAgdmFyIG1vdXNlWSA9IGdyaWQuZ2V0TW91c2VEb3duKCkueTtcblxuICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudFJvd1NlbGVjdGlvbigpO1xuXG4gICAgICAgIGdyaWQuc2VsZWN0Um93KG1vdXNlWSwgeSk7XG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIHkgLSBtb3VzZVkpKTtcblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGNoZWNrcyB3aGlsZSB3ZXJlIGRyYWdnaW5nIGlmIHdlIGdvIG91dHNpZGUgdGhlIHZpc2libGUgYm91bmRzLCBpZiBzbywga2ljayBvZmYgdGhlIGV4dGVybmFsIGF1dG9zY3JvbGwgY2hlY2sgZnVuY3Rpb24gKGFib3ZlKVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBjaGVja0RyYWdTY3JvbGw6IGZ1bmN0aW9uKGdyaWQsIG1vdXNlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGdyaWQucHJvcGVydGllcy5zY3JvbGxpbmdFbmFibGVkICYmXG4gICAgICAgICAgICBncmlkLmdldERhdGFCb3VuZHMoKS5jb250YWlucyhtb3VzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5zZXRTY3JvbGxpbmdOb3coZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgICAgICBncmlkLnNldFNjcm9sbGluZ05vdyh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbERyYWcoZ3JpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIG1ha2VzIHN1cmUgdGhhdCB3aGlsZSB3ZSBhcmUgZHJhZ2dpbmcgb3V0c2lkZSBvZiB0aGUgZ3JpZCB2aXNpYmxlIGJvdW5kcywgd2Ugc3Jjcm9sbCBhY2NvcmRpbmdseVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgc2Nyb2xsRHJhZzogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBpZiAoIWdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGIgPSBncmlkLmdldERhdGFCb3VuZHMoKSxcbiAgICAgICAgICAgIHlPZmZzZXQ7XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYWcueSA8IGIub3JpZ2luLnkpIHtcbiAgICAgICAgICAgIHlPZmZzZXQgPSAtMTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnREcmFnLnkgPiBiLm9yaWdpbi55ICsgYi5leHRlbnQueSkge1xuICAgICAgICAgICAgeU9mZnNldCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeU9mZnNldCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGFzdERyYWdSb3cgPj0gZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3REcmFnUm93ICs9IHlPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmlkLnNjcm9sbEJ5KDAsIHlPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZURyYWdDZWxsU2VsZWN0aW9uKGdyaWQsIHRoaXMubGFzdERyYWdSb3csIFtdKTsgLy8gdXBkYXRlIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5zY3JvbGxEcmFnLmJpbmQodGhpcywgZ3JpZCksIDI1KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBleHRlbmQgYSBzZWxlY3Rpb24gb3IgY3JlYXRlIG9uZSBpZiB0aGVyZSBpc250IHlldFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdyaWRDZWxsIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gYXJyYXkgb2YgdGhlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IHByZXNzZWQgZG93blxuICAgICAqL1xuICAgIGV4dGVuZFNlbGVjdGlvbjogZnVuY3Rpb24oZ3JpZCwgeSwga2V5cykge1xuICAgICAgICBpZiAoIWdyaWQuYWJvcnRFZGl0aW5nKCkpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgdmFyIG1vdXNlWSA9IGdyaWQuZ2V0TW91c2VEb3duKCkueSxcbiAgICAgICAgICAgIGhhc1NISUZUID0ga2V5cy5pbmRleE9mKCdTSElGVCcpICE9PSAtMTtcblxuICAgICAgICBpZiAoeSA8IDApIHsgLy8gb3V0c2lkZSBvZiB0aGUgZ3JpZD9cbiAgICAgICAgICAgIHJldHVybjsgLy8gZG8gbm90aGluZ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1NISUZUKSB7XG4gICAgICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudFJvd1NlbGVjdGlvbigpO1xuICAgICAgICAgICAgZ3JpZC5zZWxlY3RSb3coeSwgbW91c2VZKTtcbiAgICAgICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIHkgLSBtb3VzZVkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyaWQudG9nZ2xlU2VsZWN0Um93KHksIGtleXMpO1xuICAgICAgICAgICAgZ3JpZC5zZXRNb3VzZURvd24oZ3JpZC5uZXdQb2ludCgwLCB5KSk7XG4gICAgICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCAwKSk7XG4gICAgICAgIH1cblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaGFuZGxlRE9XTlNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVVUFNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIC0xKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTEVGVFNISUZUOiBmdW5jdGlvbihncmlkKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVJJR0hUU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlRE9XTjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaW5nbGVTZWxlY3QoZ3JpZCwgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVVQOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNpbmdsZVNlbGVjdChncmlkLCAtMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUxFRlQ6IGZ1bmN0aW9uKGdyaWQpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlUklHSFQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdmFyIG1vdXNlQ29ybmVyID0gZ3JpZC5nZXRNb3VzZURvd24oKS5wbHVzKGdyaWQuZ2V0RHJhZ0V4dGVudCgpKSxcbiAgICAgICAgICAgIG1heENvbHVtbnMgPSBncmlkLmdldENvbHVtbkNvdW50KCkgLSAxLFxuICAgICAgICAgICAgbmV3WCA9IGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCksXG4gICAgICAgICAgICBuZXdZID0gbW91c2VDb3JuZXIueTtcblxuICAgICAgICBuZXdYID0gTWF0aC5taW4obWF4Q29sdW1ucywgbmV3WCk7XG5cbiAgICAgICAgZ3JpZC5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgZ3JpZC5zZWxlY3QobmV3WCwgbmV3WSwgMCwgMCk7XG4gICAgICAgIGdyaWQuc2V0TW91c2VEb3duKGdyaWQubmV3UG9pbnQobmV3WCwgbmV3WSkpO1xuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCAwKSk7XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSWYgd2UgYXJlIGhvbGRpbmcgZG93biB0aGUgc2FtZSBuYXZpZ2F0aW9uIGtleSwgYWNjZWxlcmF0ZSB0aGUgaW5jcmVtZW50IHdlIHNjcm9sbFxuICAgICAqICMjIyMgcmV0dXJuczogaW50ZWdlclxuICAgICAqL1xuICAgIGdldEF1dG9TY3JvbGxBY2NlbGVyYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY291bnQgPSAxO1xuICAgICAgICB2YXIgZWxhcHNlZCA9IHRoaXMuZ2V0QXV0b1Njcm9sbER1cmF0aW9uKCkgLyAyMDAwO1xuICAgICAgICBjb3VudCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoZWxhcHNlZCAqIGVsYXBzZWQgKiBlbGFwc2VkICogZWxhcHNlZCkpO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IHRoZSBzdGFydCB0aW1lIHRvIHJpZ2h0IG5vdyB3aGVuIHdlIGluaXRpYXRlIGFuIGF1dG8gc2Nyb2xsXG4gICAgICovXG4gICAgc2V0QXV0b1Njcm9sbFN0YXJ0VGltZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2JBdXRvU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHVwZGF0ZSB0aGUgYXV0b3Njcm9sbCBzdGFydCB0aW1lIGlmIHdlIGhhdmVuJ3QgYXV0b3Njcm9sbGVkIHdpdGhpbiB0aGUgbGFzdCA1MDBtcyBvdGhlcndpc2UgdXBkYXRlIHRoZSBjdXJyZW50IGF1dG9zY3JvbGwgdGltZVxuICAgICAqL1xuICAgIHBpbmdBdXRvU2Nyb2xsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChub3cgLSB0aGlzLnNiTGFzdEF1dG8gPiA1MDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXV0b1Njcm9sbFN0YXJ0VGltZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2JMYXN0QXV0byA9IERhdGUubm93KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgYW5zd2VyIGhvdyBsb25nIHdlIGhhdmUgYmVlbiBhdXRvIHNjcm9sbGluZ1xuICAgICAqICMjIyMgcmV0dXJuczogaW50ZWdlclxuICAgICAqL1xuICAgIGdldEF1dG9TY3JvbGxEdXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy5zYkxhc3RBdXRvID4gNTAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHRoaXMuc2JBdXRvU3RhcnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgQXVnbWVudCB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uIGV4dGVudCBieSAob2Zmc2V0WCxvZmZzZXRZKSBhbmQgc2Nyb2xsIGlmIG5lY2Vzc2FyeS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0geCBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSB5IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKi9cbiAgICBtb3ZlU2hpZnRTZWxlY3Q6IGZ1bmN0aW9uKGdyaWQsIG9mZnNldFkpIHtcbiAgICAgICAgdmFyIG9yaWdpbiA9IGdyaWQuZ2V0TW91c2VEb3duKCksXG4gICAgICAgICAgICBleHRlbnQgPSBncmlkLmdldERyYWdFeHRlbnQoKSxcbiAgICAgICAgICAgIG1heFZpZXdhYmxlUm93cyA9IGdyaWQucmVuZGVyZXIudmlzaWJsZVJvd3MubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIG1heFJvd3MgPSBncmlkLmdldFJvd0NvdW50KCkgLSAxO1xuXG4gICAgICAgIGlmICghZ3JpZC5wcm9wZXJ0aWVzLnNjcm9sbGluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgIG1heFJvd3MgPSBNYXRoLm1pbihtYXhSb3dzLCBtYXhWaWV3YWJsZVJvd3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld1kgPSBleHRlbnQueSArIG9mZnNldFk7XG5cbiAgICAgICAgbmV3WSA9IE1hdGgubWluKG1heFJvd3MgLSBvcmlnaW4ueSwgTWF0aC5tYXgoLW9yaWdpbi55LCBuZXdZKSk7XG5cbiAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRSb3dTZWxlY3Rpb24oKTtcbiAgICAgICAgZ3JpZC5zZWxlY3RSb3cob3JpZ2luLnksIG9yaWdpbi55ICsgbmV3WSk7XG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIG5ld1kpKTtcblxuICAgICAgICBpZiAoZ3JpZC5pbnN1cmVNb2RlbFJvd0lzVmlzaWJsZShuZXdZICsgb3JpZ2luLnksIG9mZnNldFkpKSB7XG4gICAgICAgICAgICB0aGlzLnBpbmdBdXRvU2Nyb2xsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBncmlkLmZpcmVTeW50aGV0aWNSb3dTZWxlY3Rpb25DaGFuZ2VkRXZlbnQoKTtcblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZXBsYWNlIHRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb24gd2l0aCBhIHNpbmdsZSBjZWxsIHNlbGVjdGlvbiB0aGF0IGlzIG1vdmVkIChvZmZzZXRYLG9mZnNldFkpIGZyb20gdGhlIHByZXZpb3VzIHNlbGVjdGlvbiBleHRlbnQuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIHggY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0geSBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICovXG4gICAgbW92ZVNpbmdsZVNlbGVjdDogZnVuY3Rpb24oZ3JpZCwgb2Zmc2V0WSkge1xuICAgICAgICB2YXIgbWF4Um93cyA9IGdyaWQuZ2V0Um93Q291bnQoKSAtIDEsXG4gICAgICAgICAgICBtYXhWaWV3YWJsZVJvd3MgPSBncmlkLmdldFZpc2libGVSb3dzQ291bnQoKSAtIDEsXG4gICAgICAgICAgICBtb3VzZUNvcm5lciA9IGdyaWQuZ2V0TW91c2VEb3duKCkucGx1cyhncmlkLmdldERyYWdFeHRlbnQoKSksXG4gICAgICAgICAgICBuZXdZID0gbW91c2VDb3JuZXIueSArIG9mZnNldFk7XG5cbiAgICAgICAgaWYgKCFncmlkLnByb3BlcnRpZXMuc2Nyb2xsaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgbWF4Um93cyA9IE1hdGgubWluKG1heFJvd3MsIG1heFZpZXdhYmxlUm93cyk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdZID0gTWF0aC5taW4obWF4Um93cywgTWF0aC5tYXgoMCwgbmV3WSkpO1xuXG4gICAgICAgIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIGdyaWQuc2VsZWN0Um93KG5ld1kpO1xuICAgICAgICBncmlkLnNldE1vdXNlRG93bihncmlkLm5ld1BvaW50KDAsIG5ld1kpKTtcbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgMCkpO1xuXG4gICAgICAgIGlmIChncmlkLmluc3VyZU1vZGVsUm93SXNWaXNpYmxlKG5ld1ksIG9mZnNldFkpKSB7XG4gICAgICAgICAgICB0aGlzLnBpbmdBdXRvU2Nyb2xsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBncmlkLmZpcmVTeW50aGV0aWNSb3dTZWxlY3Rpb25DaGFuZ2VkRXZlbnQoKTtcbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIGlzU2luZ2xlUm93U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3dTZWxlY3Rpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBUaHVtYndoZWVsU2Nyb2xsaW5nID0gRmVhdHVyZS5leHRlbmQoJ1RodW1id2hlZWxTY3JvbGxpbmcnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgVGh1bWJ3aGVlbFNjcm9sbGluZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlV2hlZWxNb3ZlZDogZnVuY3Rpb24oZ3JpZCwgZSkge1xuICAgICAgICBpZiAoIWdyaWQucHJvcGVydGllcy5zY3JvbGxpbmdFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJpbUV2ZW50ID0gZS5wcmltaXRpdmVFdmVudCxcbiAgICAgICAgICAgIGRlbHRhWCA9IE1hdGguc2lnbihwcmltRXZlbnQud2hlZWxEZWx0YVggfHwgLXByaW1FdmVudC5kZWx0YVgpLFxuICAgICAgICAgICAgZGVsdGFZID0gTWF0aC5zaWduKHByaW1FdmVudC53aGVlbERlbHRhWSB8fCAtcHJpbUV2ZW50LmRlbHRhWSk7XG5cbiAgICAgICAgaWYgKGRlbHRhWCB8fCBkZWx0YVkpIHtcbiAgICAgICAgICAgIGdyaWQuc2Nyb2xsQnkoXG4gICAgICAgICAgICAgICAgLWRlbHRhWCB8fCAwLCAvLyAwIGlmIE5hTlxuICAgICAgICAgICAgICAgIC1kZWx0YVkgfHwgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUaHVtYndoZWVsU2Nyb2xsaW5nO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUnKTtcblxudmFyIHRvb2x0aXBEaXYsXG4gICAgZmFkZUluSW50ZXJ2YWwsXG4gICAgZmFkZU91dEludGVydmFsO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRmVhdHVyZVxuICovXG5jb25zdCBXYXJuaW5nVG9vbHRpcCA9IEZlYXR1cmUuZXh0ZW5kKCdXYXJuaW5nVG9vbHRpcCcsIHtcbiAgICBpc01lbnVTaG93bjogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgV2FybmluZ1Rvb2x0aXAucHJvdG90eXBlXG4gICAgICogQGRlc2MgaW5pdGlhbGl6ZSBjb250ZXh0IG1lbnUgZGl2XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZVdhcm5pbmdUb29sdGlwRGl2OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdG9vbHRpcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgIHRvb2x0aXBEaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRvb2x0aXBEaXYpO1xuXG4gICAgICAgIHJldHVybiB0b29sdGlwRGl2O1xuICAgIH0sXG5cbiAgICBoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGxldCBzdGF0ZUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGlzQ3Vyc29yT3ZlckNvbGx1bW5XYXJuaW5nSWNvbiA9IHRoaXMub3ZlckNvbHVtbldhcm5pbmdJY29uKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgbGV0IGlzQ3Vyc29yT3ZlclRvdGFsV2FybmluZ0ljb24gPSB0aGlzLm92ZXJUb3RhbFdhcm5pbmdJY29uKGdyaWQsIGV2ZW50KTtcblxuICAgICAgICBpZiAoaXNDdXJzb3JPdmVyQ29sbHVtbldhcm5pbmdJY29uKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNNZW51U2hvd24pIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9vbHRpcFJpZ2h0WCA9IGV2ZW50LmJvdW5kcy54XG4gICAgICAgICAgICAgICAgICAgICsgZXZlbnQucHJvcGVydGllcy5jZWxsUGFkZGluZ0xlZnRcbiAgICAgICAgICAgICAgICAgICAgKyBncmlkLmNhbnZhcy5zaXplLmxlZnRcbiAgICAgICAgICAgICAgICAgICAgKyA4O1xuICAgICAgICAgICAgICAgIGxldCB0b29sdGlwVG9wWSA9IGV2ZW50LmJvdW5kcy55ICsgZXZlbnQuYm91bmRzLmhlaWdodCArIGdyaWQuY2FudmFzLnNpemUudG9wO1xuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRXYXJuaW5nVG9vbHRpcChncmlkLFxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwUmlnaHRYLFxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwVG9wWSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuY29sdW1uLmZpcnN0RXJyb3IuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICdib3R0b20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc0N1cnNvck92ZXJUb3RhbFdhcm5pbmdJY29uKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNNZW51U2hvd24pIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9vbHRpcFJpZ2h0WCA9IGV2ZW50LmJvdW5kcy54XG4gICAgICAgICAgICAgICAgICAgICsgZXZlbnQuYm91bmRzLndpZHRoIC8gMiArIGV2ZW50LnByb3BlcnRpZXMudG90YWxFcnJvcnNDb3VudEljb25XaWR0aCAvIDJcbiAgICAgICAgICAgICAgICAgICAgKyBncmlkLmNhbnZhcy5zaXplLmxlZnQ7XG4gICAgICAgICAgICAgICAgbGV0IHRvb2x0aXBUb3BZID0gZXZlbnQuYm91bmRzLnkgKyBldmVudC5ib3VuZHMuaGVpZ2h0IC8gMiArIGdyaWQuY2FudmFzLnNpemUudG9wO1xuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRXYXJuaW5nVG9vbHRpcChncmlkLFxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwUmlnaHRYLFxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwVG9wWSxcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5nZXRGaWVsZHNFcnJvcnNNZXNzYWdlKCksXG4gICAgICAgICAgICAgICAgICAgICdyaWdodCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNNZW51U2hvd24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVXYXJuaW5nVG9vbHRpcChncmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlTW92ZShncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIGdyaWQgZGF0YSBhZGRlZCBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29tbWVudCBOb3QgcmVhbGx5IHByaXZhdGUgYnV0IHdhcyBjbHV0dGVyaW5nIHVwIGFsbCB0aGUgZmVhdHVyZSBkb2MgcGFnZXMuXG4gICAgICovXG4gICAgaGFuZGxlRGF0YUFkZGVkOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB0aGlzLmhpZGVXYXJuaW5nVG9vbHRpcChncmlkKTtcblxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlRGF0YUFkZGVkKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvdmVyQ29sdW1uV2FybmluZ0ljb246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGxldCBjb2x1bW5IYXNFcnJvciA9IGV2ZW50LmNvbHVtbi5oYXNFcnJvcjtcbiAgICAgICAgbGV0IGlzSGVhZGVyUm93ID0gZXZlbnQucHJvcGVydGllcy5oZWFkZXJSb3cgfHwgZXZlbnQucm93UHJvcGVydGllcy5oZWFkZXJSb3c7XG5cbiAgICAgICAgaWYgKCFjb2x1bW5IYXNFcnJvciB8fCAhaXNIZWFkZXJSb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB3YXJuaW5nSWNvbkxlZnRYID0gZXZlbnQucHJvcGVydGllcy5jZWxsUGFkZGluZ0xlZnQ7XG4gICAgICAgIGxldCB3YXJuaW5nSWNvblJpZ2h0WCA9IHdhcm5pbmdJY29uTGVmdFggKyAxNCArIGV2ZW50LnByb3BlcnRpZXMuY29sdW1uVGl0bGVQcmVmaXhSaWdodFNwYWNlO1xuXG4gICAgICAgIGxldCB3YXJuaW5nSWNvblRvcFkgPSA1O1xuICAgICAgICBsZXQgd2FybmluZ0ljb25Cb3R0b21ZID0gZXZlbnQuYm91bmRzLmhlaWdodCAtIDU7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50Lm1vdXNlUG9pbnQueCA8PSB3YXJuaW5nSWNvblJpZ2h0WFxuICAgICAgICAgICAgJiYgZXZlbnQubW91c2VQb2ludC54ID49IHdhcm5pbmdJY29uTGVmdFhcbiAgICAgICAgICAgICYmIGV2ZW50Lm1vdXNlUG9pbnQueSA8PSB3YXJuaW5nSWNvbkJvdHRvbVlcbiAgICAgICAgICAgICYmIGV2ZW50Lm1vdXNlUG9pbnQueSA+PSB3YXJuaW5nSWNvblRvcFk7XG4gICAgfSxcblxuICAgIG92ZXJUb3RhbFdhcm5pbmdJY29uOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBsZXQgeCA9IGV2ZW50LmdyaWRDZWxsLng7XG4gICAgICAgIGxldCByID0gZXZlbnQuZGF0YUNlbGwueTtcblxuICAgICAgICBsZXQgcmVuZGVyVG90YWxFcnJvclNpZ25OZWVkZWQgPSB4ID09PSBncmlkLmJlaGF2aW9yLnJvd0NvbHVtbkluZGV4XG4gICAgICAgICAgICAmJiByID09PSAwXG4gICAgICAgICAgICAmJiBldmVudC5pc0hlYWRlclJvd1xuICAgICAgICAgICAgJiYgZ3JpZC5iZWhhdmlvci5lcnJvckNvdW50O1xuXG4gICAgICAgIGlmICghcmVuZGVyVG90YWxFcnJvclNpZ25OZWVkZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0b3RhbEVycm9yc0NvdW50SWNvblN0YXJ0WSA9IGV2ZW50LmJvdW5kcy5oZWlnaHQgLyAyIC0gZXZlbnQucHJvcGVydGllcy50b3RhbEVycm9yc0NvdW50SWNvbkhlaWdodCAvIDI7XG4gICAgICAgIGxldCB0b3RhbEVycm9yc0NvdW50SWNvbkVuZFkgPSB0b3RhbEVycm9yc0NvdW50SWNvblN0YXJ0WSArIGV2ZW50LnByb3BlcnRpZXMudG90YWxFcnJvcnNDb3VudEljb25IZWlnaHQ7XG4gICAgICAgIGxldCB0b3RhbEVycm9yc0NvdW50SWNvblN0YXJ0WCA9IGV2ZW50LmJvdW5kcy53aWR0aCAvIDIgLSBldmVudC5wcm9wZXJ0aWVzLnRvdGFsRXJyb3JzQ291bnRJY29uV2lkdGggLyAyO1xuICAgICAgICBsZXQgdG90YWxFcnJvcnNDb3VudEljb25FbmRYID0gdG90YWxFcnJvcnNDb3VudEljb25TdGFydFggKyBldmVudC5wcm9wZXJ0aWVzLnRvdGFsRXJyb3JzQ291bnRJY29uV2lkdGg7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50Lm1vdXNlUG9pbnQueCA8PSB0b3RhbEVycm9yc0NvdW50SWNvbkVuZFhcbiAgICAgICAgICAgICYmIGV2ZW50Lm1vdXNlUG9pbnQueCA+PSB0b3RhbEVycm9yc0NvdW50SWNvblN0YXJ0WFxuICAgICAgICAgICAgJiYgZXZlbnQubW91c2VQb2ludC55IDw9IHRvdGFsRXJyb3JzQ291bnRJY29uRW5kWVxuICAgICAgICAgICAgJiYgZXZlbnQubW91c2VQb2ludC55ID49IHRvdGFsRXJyb3JzQ291bnRJY29uU3RhcnRZO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgV2FybmluZ1Rvb2x0aXAucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXRpbGl0eSBtZXRob2QgdG8gcGFpbnQgY29udGV4dCBtZW51IGJhc2VkIG9uIGNsaWNrIGV2ZW50LCBhbmQgcG9zaXRpb24gcGFyYW1zXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIGRlZmluZXMgaG9yaXpvbnRhbCBwb2ludCBvZiBtZW51IHN0YXJ0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBkZWZpbmVzIHZlcnRpY2FsIHBvaW50IG9mIG1lbnUgc3RhcnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRvb2x0aXAgY29udGVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwbGFjZW1lbnQgLSBwbGFjZW1lbnQgb2YgYW4gdG9vbHRpcFxuICAgICAqL1xuICAgIHBhaW50V2FybmluZ1Rvb2x0aXA6IGZ1bmN0aW9uKGdyaWQsIHgsIHksIHRleHQsIHBsYWNlbWVudCkge1xuICAgICAgICB0aGlzLmhpZGVXYXJuaW5nVG9vbHRpcChncmlkKTtcblxuICAgICAgICBpZiAoIXRvb2x0aXBEaXYpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZVdhcm5pbmdUb29sdGlwRGl2KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b29sdGlwSG9sZGVyRGl2LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAndG9vbHRpcCBib3R0b20gZmFkZSBpbiBtYWluLXBhZ2UtdG9vbHRpcCcpO1xuXG4gICAgICAgIHN3aXRjaCAocGxhY2VtZW50KXtcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgdG9vbHRpcERpdi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgZ3JpZC5wcm9wZXJ0aWVzLndhcm5pbmdUb29sdGlwQm90dG9tQ2xhc3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHRvb2x0aXBEaXYuc2V0QXR0cmlidXRlKCdjbGFzcycsIGdyaWQucHJvcGVydGllcy53YXJuaW5nVG9vbHRpcFJpZ2h0Q2xhc3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRvb2x0aXBBcnJvd0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0b29sdGlwQXJyb3dEaXYuc2V0QXR0cmlidXRlKCdjbGFzcycsIGdyaWQucHJvcGVydGllcy53YXJuaW5nVG9vbHRpcEFycm93Q2xhc3MpO1xuICAgICAgICB0b29sdGlwRGl2LmFwcGVuZENoaWxkKHRvb2x0aXBBcnJvd0Rpdik7XG5cbiAgICAgICAgbGV0IHRvb2x0aXBJbm5lckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0b29sdGlwSW5uZXJEaXYuc2V0QXR0cmlidXRlKCdjbGFzcycsIGdyaWQucHJvcGVydGllcy53YXJuaW5nVG9vbHRpcElubmVyQ2xhc3MpO1xuICAgICAgICB0b29sdGlwSW5uZXJEaXYuaW5uZXJIVE1MID0gdGV4dDtcbiAgICAgICAgdG9vbHRpcERpdi5hcHBlbmRDaGlsZCh0b29sdGlwSW5uZXJEaXYpO1xuXG4gICAgICAgIHRoaXMuc2hvd1dhcm5pbmdUb29sdGlwKGdyaWQpO1xuXG4gICAgICAgIGxldCBsZWZ0WCwgdG9wWTtcbiAgICAgICAgbGV0IHRvb2x0aXBXaWR0aCA9IHRvb2x0aXBEaXYub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICB0b29sdGlwSGVpZ2h0ID0gdG9vbHRpcERpdi5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgc3dpdGNoIChwbGFjZW1lbnQpe1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICBsZWZ0WCA9IHggLSB0b29sdGlwV2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHRvcFkgPSB5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIGxlZnRYID0geDtcbiAgICAgICAgICAgICAgICB0b3BZID0geSAtIHRvb2x0aXBIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb3ZlV2FybmluZ1Rvb2x0aXAobGVmdFgsIHRvcFkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgV2FybmluZ1Rvb2x0aXAucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXRpbGl0eSBtZXRob2QgdG8gc3RhcnQgc2hvdyBjb250ZXh0IG1lbnUgb24gZGVmaW5lZCBwb2ludC5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIHNob3dXYXJuaW5nVG9vbHRpcDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBsZXQgb3AgPSAwLjE7ICAvLyBpbml0aWFsIG9wYWNpdHlcbiAgICAgICAgdG9vbHRpcERpdi5zdHlsZS5vcGFjaXR5ID0gb3A7XG4gICAgICAgIHRvb2x0aXBEaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMuaXNNZW51U2hvd24gPSB0cnVlO1xuICAgICAgICB0aGlzLmNsZWFySW50ZXJ2YWxzKCk7XG4gICAgICAgIGZhZGVJbkludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG9wID49IGdyaWQucHJvcGVydGllcy53YXJuaW5nVG9vbHRpcE9wYWNpdHkpe1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoZmFkZUluSW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0b29sdGlwRGl2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9vbHRpcERpdi5zdHlsZS5vcGFjaXR5ID0gb3A7XG4gICAgICAgICAgICB0b29sdGlwRGl2LnN0eWxlLmZpbHRlciA9ICdhbHBoYShvcGFjaXR5PScgKyBvcCAqIDEwMCArICcpJztcbiAgICAgICAgICAgIG9wICs9IG9wICogMC4yO1xuICAgICAgICB9LCA1KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFdhcm5pbmdUb29sdGlwLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHV0aWxpdHkgbWV0aG9kIHRvIG1vdmUgdG9vbHRpcCB0byBwb3NpdGlvblxuICAgICAqIEBkZXNjIE1lbnUgbXVzdCBiZSBmb3JtZWQgYmVmb3JlIGl0IHdpbGwgYmUgcGFzc2VkIHRvIHRoaXMgbWV0aG9kXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBkZWZpbmVzIGhvcml6b250YWwgcG9pbnQgb2YgdG9vbHRpcCBzdGFydFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gZGVmaW5lcyB2ZXJ0aWNhbCBwb2ludCBvZiB0b29sdGlwIHN0YXJ0XG4gICAgICovXG4gICAgbW92ZVdhcm5pbmdUb29sdGlwOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHRvb2x0aXBEaXYuc3R5bGUudG9wID0geSArICdweCc7XG4gICAgICAgIHRvb2x0aXBEaXYuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgV2FybmluZ1Rvb2x0aXAucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXRpbGl0eSBtZXRob2QgdG8gc3RvcCBkaXNwbGF5aW5nIGNvbnRleHQgbWVudVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaGlkZVdhcm5pbmdUb29sdGlwOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMuaXNNZW51U2hvd24gPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXRvb2x0aXBEaXYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvcCA9IGdyaWQucHJvcGVydGllcy53YXJuaW5nVG9vbHRpcE9wYWNpdHk7ICAvLyBpbml0aWFsIG9wYWNpdHlcbiAgICAgICAgdGhpcy5jbGVhckludGVydmFscygpO1xuICAgICAgICBmYWRlT3V0SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAob3AgPD0gMC4xKXtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGZhZGVPdXRJbnRlcnZhbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRvb2x0aXBEaXYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b29sdGlwRGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgICAgICAgICB0b29sdGlwRGl2LmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgICAgIHRvb2x0aXBEaXYucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdG9vbHRpcERpdiA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdG9vbHRpcERpdikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9vbHRpcERpdi5zdHlsZS5vcGFjaXR5ID0gb3A7XG4gICAgICAgICAgICB0b29sdGlwRGl2LnN0eWxlLmZpbHRlciA9ICdhbHBoYShvcGFjaXR5PScgKyBvcCAqIDEwMCArICcpJztcbiAgICAgICAgICAgIG9wIC09IG9wICogMC4yO1xuICAgICAgICB9LCA1KTtcbiAgICB9LFxuXG4gICAgY2xlYXJJbnRlcnZhbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAgKGZhZGVPdXRJbnRlcnZhbCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChmYWRlT3V0SW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICAoZmFkZUluSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoZmFkZUluSW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2FybmluZ1Rvb2x0aXA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBSZWdpc3RyeSA9IHJlcXVpcmUoJy4uL2xpYi9SZWdpc3RyeScpO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzYyBSZWdpc3RyeSBvZiBmZWF0dXJlIGNvbnN0cnVjdG9ycy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByaXZhdGVSZWdpc3RyeT1mYWxzZV0gLSBUaGlzIGluc3RhbmNlIHdpbGwgdXNlIGEgcHJpdmF0ZSByZWdpc3RyeS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRmVhdHVyZXMgPSBSZWdpc3RyeS5leHRlbmQoJ0ZlYXR1cmVzJywge1xuXG4gICAgQmFzZUNsYXNzOiByZXF1aXJlKCcuL0ZlYXR1cmUnKSwgLy8gYWJzdHJhY3QgYmFzZSBjbGFzc1xuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHByZXJlZ2lzdGVyIHRoZSBzdGFuZGFyZCBjZWxsIHJlbmRlcmVyc1xuICAgICAgICB0aGlzLmFkZChGZWF0dXJlcy5DZWxsQ2xpY2spO1xuICAgICAgICB0aGlzLmFkZChGZWF0dXJlcy5DZWxsRWRpdGluZyk7XG4gICAgICAgIHRoaXMuYWRkKEZlYXR1cmVzLkNlbGxTZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLmFkZChGZWF0dXJlcy5Db2x1bW5Nb3ZpbmcpO1xuICAgICAgICB0aGlzLmFkZChGZWF0dXJlcy5Db2x1bW5SZXNpemluZyk7XG4gICAgICAgIHRoaXMuYWRkKEZlYXR1cmVzLkNvbHVtblNlbGVjdGlvbik7XG4gICAgICAgIHRoaXMuYWRkKEZlYXR1cmVzLkNvbHVtblNvcnRpbmcpO1xuICAgICAgICB0aGlzLmFkZChGZWF0dXJlcy5GaWx0ZXJzKTtcbiAgICAgICAgdGhpcy5hZGQoRmVhdHVyZXMuS2V5UGFnaW5nKTtcbiAgICAgICAgdGhpcy5hZGQoRmVhdHVyZXMuT25Ib3Zlcik7XG4gICAgICAgIC8vIHRoaXMuYWRkKHJlcXVpcmUoJy4vUm93UmVzaXppbmcnKSk7XG4gICAgICAgIHRoaXMuYWRkKEZlYXR1cmVzLlJvd1NlbGVjdGlvbik7XG4gICAgICAgIHRoaXMuYWRkKEZlYXR1cmVzLlRodW1id2hlZWxTY3JvbGxpbmcpO1xuICAgICAgICB0aGlzLmFkZChGZWF0dXJlcy5Db250ZXh0TWVudSk7XG4gICAgICAgIHRoaXMuYWRkKEZlYXR1cmVzLkNvbHVtbkZpeGF0aW9uKTtcbiAgICAgICAgdGhpcy5hZGQoRmVhdHVyZXMuUm93Rml4YXRpb24pO1xuICAgICAgICB0aGlzLmFkZChGZWF0dXJlcy5MaW5rRGV0YWlscyk7XG4gICAgICAgIHRoaXMuYWRkKEZlYXR1cmVzLldhcm5pbmdUb29sdGlwKTtcbiAgICB9XG5cbn0pO1xuXG5cbi8vIEZvbGxvd2luZyBzaGFyZWQgcHJvcHMgcHJvdmlkZWQgc29sZWx5IGluIHN1cHBvcnQgb2YgYnVpbGQgZmlsZSB1c2FnZSwgZS5nLiwgYGZpbi5IeXBlcmdyaWQuZmVhdHVyZXMueWFkYWAsXG4vLyBwcmVzdW1hYmx5IGZvciBvdmVycmlkaW5nIGJ1aWx0LWluIGZlYXR1cmVzLCBhbmQgYXJlIG5vdCBtZWFudCB0byBiZSB1c2VkIGVsc2V3aGVyZS5cblxuRmVhdHVyZXMuQmFzZUNsYXNzID0gcmVxdWlyZSgnLi9GZWF0dXJlJyk7IC8vIGFic3RyYWN0IGJhc2UgY2xhc3NcbkZlYXR1cmVzLkNlbGxDbGljayA9IHJlcXVpcmUoJy4vQ2VsbENsaWNrJyk7XG5GZWF0dXJlcy5DZWxsRWRpdGluZyA9IHJlcXVpcmUoJy4vQ2VsbEVkaXRpbmcnKTtcbkZlYXR1cmVzLkNlbGxTZWxlY3Rpb24gPSByZXF1aXJlKCcuL0NlbGxTZWxlY3Rpb24nKTtcbkZlYXR1cmVzLkNvbHVtbk1vdmluZyA9IHJlcXVpcmUoJy4vQ29sdW1uTW92aW5nJyk7XG5GZWF0dXJlcy5Db2x1bW5SZXNpemluZyA9IHJlcXVpcmUoJy4vQ29sdW1uUmVzaXppbmcnKTtcbkZlYXR1cmVzLkNvbHVtblNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vQ29sdW1uU2VsZWN0aW9uJyk7XG5GZWF0dXJlcy5Db2x1bW5Tb3J0aW5nID0gcmVxdWlyZSgnLi9Db2x1bW5Tb3J0aW5nJyk7XG5GZWF0dXJlcy5GaWx0ZXJzID0gcmVxdWlyZSgnLi9GaWx0ZXJzJyk7XG5GZWF0dXJlcy5LZXlQYWdpbmcgPSByZXF1aXJlKCcuL0tleVBhZ2luZycpO1xuRmVhdHVyZXMuT25Ib3ZlciA9IHJlcXVpcmUoJy4vT25Ib3ZlcicpO1xuLy8gRmVhdHVyZXMuUm93UmVzaXppbmcgPSByZXF1aXJlKCcuL1Jvd1Jlc2l6aW5nJyk7XG5GZWF0dXJlcy5Sb3dTZWxlY3Rpb24gPSByZXF1aXJlKCcuL1Jvd1NlbGVjdGlvbicpO1xuRmVhdHVyZXMuVGh1bWJ3aGVlbFNjcm9sbGluZyA9IHJlcXVpcmUoJy4vVGh1bWJ3aGVlbFNjcm9sbGluZycpO1xuRmVhdHVyZXMuQ29udGV4dE1lbnUgPSByZXF1aXJlKCcuL0NvbnRleHRNZW51Jyk7XG5GZWF0dXJlcy5Db2x1bW5GaXhhdGlvbiA9IHJlcXVpcmUoJy4vQ29sdW1uRml4YXRpb24nKTtcbkZlYXR1cmVzLlJvd0ZpeGF0aW9uID0gcmVxdWlyZSgnLi9Sb3dGaXhhdGlvbicpO1xuRmVhdHVyZXMuTGlua0RldGFpbHMgPSByZXF1aXJlKCcuL0xpbmtEZXRhaWxzJyk7XG5GZWF0dXJlcy5XYXJuaW5nVG9vbHRpcCA9IHJlcXVpcmUoJy4vV2FybmluZ1Rvb2x0aXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRmVhdHVyZXM7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiBOT1RFXG4gKlxuICogV2hhdCB0aGlzIGZpbGUgaXM6XG4gKiAqIFRoaXMgZmlsZSBpcyBicm93c2VyaWZ5J3MgZW50cnkgcG9pbnQuXG4gKiAqIFRoaXMgZmlsZSBjcmVhdGVzIHRoZSBgd2luZG93LmZpbi5IeXBlcmdyaWRgIG9iamVjdC5cbiAqICogQnVuZGxlZCBmaWxlIGNhbiBiZSB1c2VkIGFzIHJlcXVpcmUgbW9kdWxlIGZvciBjcmVhdGluZyBuZXcgSHlwZXJncmlkIG9iamVjdHNcbiAqL1xuXG4vLyBDcmVhdGUgdGhlIGBmaW5gIG5hbWVzcGFjZSBpZiBub3QgYWxyZWFkeSBleHRhbnRcbnZhciBmaW4gPSB3aW5kb3cuZmluID0gd2luZG93LmZpbiB8fCB7fTtcblxuLy8gQ3JlYXRlIHRoZSBgZmluLkh5cGVyZ3JpZGAgb2JqZWN0LCB3aGljaCBzZXJ2ZXMgYm90aCBhcyBhIFwiY2xhc3NcIiAoY29uc3RydWN0b3IpIGFuZCBhIG5hbWVzcGFjZTpcbnZhciBIeXBlcmdyaWQgPSBmaW4uSHlwZXJncmlkID0gcmVxdWlyZSgnLi4vSHlwZXJncmlkJyk7XG5cbi8vIEluc3RhbGwgdGhlIG1vZHVsZSBsb2FkZXJcbkh5cGVyZ3JpZC5yZXF1aXJlID0gcmVxdWlyZSgnLi9tb2R1bGUtbG9hZGVyJyk7XG5cbi8vIEluc3RhbGwgYHNyY2AgdGhlIGludGVybmFsIG1vZHVsZSBuYW1lc3BhY2Ugd2hpY2ggaXMgZm9yIHRoZSBidWlsZCBmaWxlIG9ubHlcbkh5cGVyZ3JpZC5zcmMgPSB7fTtcblxuLy8gTm90ZTogQXQgdGhpcyBwb2ludCwgYEh5cGVyZ3JpZC5tb2R1bGVzYCwgdGhlIGV4dGVybmFsIG1vZHVsZSBuYW1lc3BhY2UsIGhhcyBhbHJlYWR5XG4vLyBiZWVuIGluc3RhbGxlZCBieSAuL0h5cGVyZ3JpZC9pbmRleC5qcyAoZm9yIGJvdGggbnBtIGFuZCBidWlsZCBtb2R1bGVzKS5cblxuLy8gSW5zdGFsbCBpbXBsaWNpdCBtb2R1bGVzIHdoaWNoIGFyZSBleHRlcm5hbCBtb2R1bGVzIGJ1dCBhcmUgbm90IG92ZXJyaWRhYmxlIHNvIG5vbi1jb25maWd1cmFibGUsIG5vbi13cml0YWJsZVxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoSHlwZXJncmlkLm1vZHVsZXMsIHtcbiAgICAnZGF0YXNhdXItYmFzZSc6IHsgdmFsdWU6IHJlcXVpcmUoJy4uL0RhdGFzYXVyQmFzZScpIH0sIC8vIG1heSBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2VcbiAgICAnZGF0YXNhdXItbG9jYWwnOiB7IHZhbHVlOiByZXF1aXJlKCcuLi9EYXRhc2F1ckxvY2FsJykgfSwgLy8gbWF5IGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZVxuICAgICdleHRlbmQtbWUnOiB7IHZhbHVlOiByZXF1aXJlKCdleHRlbmQtbWUnKSB9LFxuICAgICdvYmplY3QtaXRlcmF0b3JzJzogeyB2YWx1ZTogcmVxdWlyZSgnb2JqZWN0LWl0ZXJhdG9ycycpIH0sXG4gICAgb3ZlcnJpZGVyOiB7IHZhbHVlOiByZXF1aXJlKCdvdmVycmlkZXInKSB9LFxuICAgIHJlY3Rhbmd1bGFyOiB7IHZhbHVlOiByZXF1aXJlKCdyZWN0YW5ndWxhcicpIH0sXG4gICAgJ3NwYXJzZS1ib29sZWFuLWFycmF5JzogeyB2YWx1ZTogcmVxdWlyZSgnc3BhcnNlLWJvb2xlYW4tYXJyYXknKSB9XG59KTtcblxuLy8gSW5zdGFsbCBpbnRlcm5hbCBtb2R1bGVzIG1heSBub3QgYmUgb3ZlcnJpZGRlbiBzbyBub24tY29uZmlndXJhYmxlLCBub24td3JpdGFibGVcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEh5cGVyZ3JpZC5zcmMsIHtcbiAgICBsaWI6IHsgdmFsdWU6IHJlcXVpcmUoJy4uLy9saWInKSB9LFxuICAgIGJlaGF2aW9yczogeyB2YWx1ZTogcmVxdWlyZSgnLi4vYmVoYXZpb3JzJykgfSxcbiAgICBkYXRhTW9kZWxzOiB7IHZhbHVlOiByZXF1aXJlKCcuLi9kYXRhTW9kZWxzJykgfSxcbiAgICBmZWF0dXJlczogeyB2YWx1ZTogcmVxdWlyZSgnLi4vZmVhdHVyZXMnKSB9LFxuICAgIEJhc2U6IHsgdmFsdWU6IHJlcXVpcmUoJy4uL0Jhc2UnKSB9LFxuICAgIGRlZmF1bHRzOiB7IHZhbHVlOiByZXF1aXJlKCcuLi9kZWZhdWx0cycpIH1cbn0pO1xuXG4vLyBEZXByZWNhdGUgY2VydGFpbiBwcm9wZXJ0aWVzXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhIeXBlcmdyaWQsIHtcbiAgICBsaWI6IHsgZ2V0OiBkZXByZWNhdGVkLmJpbmQobnVsbCwgJ2xpYicpIH0sXG4gICAgYmVoYXZpb3JzOiB7IGdldDogZGVwcmVjYXRlZC5iaW5kKG51bGwsICdiZWhhdmlvcnMnKSB9LFxuICAgIGRhdGFNb2RlbHM6IHsgZ2V0OiBkZXByZWNhdGVkLmJpbmQobnVsbCwgJ2RhdGFNb2RlbHMnKSB9LFxuICAgIGZlYXR1cmVzOiB7IGdldDogZGVwcmVjYXRlZC5iaW5kKG51bGwsICdmZWF0dXJlcycpIH0sXG4gICAgcmVjdGFuZ3VsYXI6IHsgZ2V0OiBkZXByZWNhdGVkLmJpbmQobnVsbCwgJ3JlY3Rhbmd1bGFyJywgJ21vZHVsZXMnKSB9XG59KTtcblxuZnVuY3Rpb24gZGVwcmVjYXRlZChrZXksIHJlZ2lzdHJ5KSB7XG4gICAgcmVnaXN0cnkgPSByZWdpc3RyeSB8fCAnc3JjJztcblxuICAgIHZhciByZXF1aXJlU3RyaW5nLCB3YXJuaW5nO1xuXG4gICAgc3dpdGNoIChyZWdpc3RyeSkge1xuICAgICAgICBjYXNlICdzcmMnOlxuICAgICAgICAgICAgcmVxdWlyZVN0cmluZyA9ICcuLi8nICsga2V5O1xuICAgICAgICAgICAgd2FybmluZyA9ICdSZWZlcmVuY2UgdG8gJyArIGtleSArICcgaW50ZXJuYWwgbW9kdWxlcyB1c2luZycgK1xuICAgICAgICAgICAgICAgICcgYEh5cGVyZ3JpZC4nICsga2V5ICsgJy5tb2R1bGVuYW1lYCBoYXMgYmVlbiBkZXByZWNhdGVkIGFzIG9mIHYzLjAuMCBpbiBmYXZvciBvZicgK1xuICAgICAgICAgICAgICAgICcgYEh5cGVyZ3JpZC5yZXF1aXJlKFxcJycgKyByZXF1aXJlU3RyaW5nICsgJy9tb2R1bGVuYW1lXFwnKWAgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLicgK1xuICAgICAgICAgICAgICAgICcgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9maW4taHlwZXJncmlkL2NvcmUvd2lraS9DbGllbnQtTW9kdWxlcyNwcmVkZWZpbmVkLW1vZHVsZXMuJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ21vZHVsZXMnOlxuICAgICAgICAgICAgcmVxdWlyZVN0cmluZyA9IGtleTtcbiAgICAgICAgICAgIHdhcm5pbmcgPSAnUmVmZXJlbmNlIHRvICcgKyBrZXkgKyAnIGV4dGVybmFsIG1vZHVsZSB1c2luZycgK1xuICAgICAgICAgICAgICAgICcgYEh5cGVyZ3JpZC4nICsga2V5ICsgJy5gIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYXMgb2YgdjMuMC4wIGluIGZhdm9yIG9mJyArXG4gICAgICAgICAgICAgICAgJyBgSHlwZXJncmlkLnJlcXVpcmUoXFwnJyArIHJlcXVpcmVTdHJpbmcgKyAnXFwnKWAgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLicgK1xuICAgICAgICAgICAgICAgICcgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9maW4taHlwZXJncmlkL2NvcmUvd2lraS9DbGllbnQtTW9kdWxlcyNleHRlcm5hbC1tb2R1bGVzLic7XG4gICAgfVxuXG4gICAgaWYgKCFkZXByZWNhdGVkLndhcm5lZFtrZXldKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbiAgICAgICAgZGVwcmVjYXRlZC53YXJuZWRba2V5XSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIEh5cGVyZ3JpZC5yZXF1aXJlKHJlcXVpcmVTdHJpbmcpO1xufVxuXG5kZXByZWNhdGVkLndhcm5lZCA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh5cGVyZ3JpZDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBhY2thZ2VOYW1lID0gJ2J1aWxkJztcbnZhciBIeXBlcmdyaWQgPSByZXF1aXJlKCcuLi9IeXBlcmdyaWQnKTtcblxudmFyIFJFR0VYX1NSQ19NT0RVTEVTID0gbmV3IFJlZ0V4cCgnXicgKyBwYWNrYWdlTmFtZSArICcvc3JjLyhCYXNlfGRlZmF1bHRzKSQnKSxcbiAgICBSRUdFWF9JTlRFUk5BTF9NT0RVTEVTID0gbmV3IFJlZ0V4cCgnXicgKyBwYWNrYWdlTmFtZSArICcvc3JjLyhsaWJ8YmVoYXZpb3JzfGRhdGFNb2RlbHN8ZmVhdHVyZXMpKC8oXFxcXHcrKSk/JCcpO1xuXG5mdW5jdGlvbiBtb2R1bGVMb2FkZXIocGF0aCkgeyAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Zpbi1oeXBlcmdyaWQvY29yZS93aWtpL0NsaWVudC1Nb2R1bGVzXG4gICAgdmFyIG1vZHVsZSwgY3J1bWJzO1xuXG4gICAgc3dpdGNoIChwYXRoKSB7XG4gICAgICAgIGNhc2UgcGFja2FnZU5hbWU6XG4gICAgICAgICAgICBtb2R1bGUgPSBIeXBlcmdyaWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBwYWNrYWdlTmFtZSArICcvaW1hZ2VzJzpcbiAgICAgICAgICAgIG1vZHVsZSA9IHJlcXVpcmUoJy4uLy4uL2ltYWdlcycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoKGNydW1icyA9IHBhdGgubWF0Y2goUkVHRVhfU1JDX01PRFVMRVMpKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZSA9IEh5cGVyZ3JpZC5zcmNbY3J1bWJzWzFdXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGNydW1icyA9IHBhdGgubWF0Y2goUkVHRVhfSU5URVJOQUxfTU9EVUxFUykpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlID0gSHlwZXJncmlkLnNyY1tjcnVtYnNbMV1dO1xuICAgICAgICAgICAgICAgIGlmIChjcnVtYnNbM10pIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlID0gbW9kdWxlW2NydW1ic1szXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgPSBIeXBlcmdyaWQubW9kdWxlc1twYXRoXTtcbiAgICAgICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW1vZHVsZSkge1xuICAgICAgICB2YXIgbXNnID0gJ1Vua25vd24gbW9kdWxlICcgKyAgcGF0aCxcbiAgICAgICAgICAgIG1hdGNoID0gcGF0aC5tYXRjaCgvKFxcLyhpbmRleChcXC5qcyk/KT98XFwuanMpJC8pO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbXNnICs9ICcgKHRyeSBvbWl0dGluZyB0cmFpbGluZyBcIicgKyBtYXRjaFsxXSArICdcIiknO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbXNnO1xuICAgIH1cblxuICAgIHJldHVybiBtb2R1bGU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbW9kdWxlTG9hZGVyO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBmdW5jdGlvbihldmVudCwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7IGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgZGV0YWlsOiB1bmRlZmluZWQgfTtcbiAgICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICAgICAgICByZXR1cm4gZXZ0O1xuICAgIH07XG5cbiAgICB3aW5kb3cuQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZTtcbn1cblxudmFyIHJlY3Rhbmd1bGFyID0gcmVxdWlyZSgncmVjdGFuZ3VsYXInKTtcblxudmFyIFJFU0laRV9QT0xMSU5HX0lOVEVSVkFMID0gMjAwLFxuICAgIHBhaW50YWJsZXMgPSBbXSxcbiAgICByZXNpemFibGVzID0gW10sXG4gICAgcGFpbnRSZXF1ZXN0LFxuICAgIHJlc2l6ZUludGVydmFsLFxuICAgIGNoYXJNYXAgPSBtYWtlQ2hhck1hcCgpO1xuXG5mdW5jdGlvbiBDYW52YXMoZGl2LCBjb21wb25lbnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBjcmVhdGUgdGhlIGNvbnRhaW5pbmcgPGRpdj4uLi48L2Rpdj5cbiAgICB0aGlzLmRpdiA9IGRpdjtcbiAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcblxuICAgIHRoaXMuZHJhZ0VuZHRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgLy8gY3JlYXRlIGFuZCBhcHBlbmQgdGhlIGluZm8gPGRpdj4uLi48L2Rpdj4gKHRvIGJlIGRpc3BsYXllZCB3aGVuIHRoZXJlIGFyZSBubyBkYXRhIHJvd3MpXG4gICAgdGhpcy5pbmZvRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5pbmZvRGl2LmNsYXNzTmFtZSA9ICdpbmZvJztcbiAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZCh0aGlzLmluZm9EaXYpO1xuXG4gICAgLy8gY3JlYXRlIGFuZCBhcHBlbmQgdGhlIGNhbnZhc1xuICAgIHRoaXMuZ2MgPSBnZXRDYWNoZWRDb250ZXh0KHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpO1xuICAgIHRoaXMuYmMgPSBnZXRDYWNoZWRDb250ZXh0KHRoaXMuYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpO1xuXG4gICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuXG4gICAgdGhpcy5jYW52YXMuc3R5bGUub3V0bGluZSA9ICdub25lJztcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kID0gdGhpcy5jb21wb25lbnQucHJvcGVydGllcy5jYW52YXNCYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQoLTEsIC0xKTtcbiAgICB0aGlzLmRyYWdzdGFydCA9IG5ldyByZWN0YW5ndWxhci5Qb2ludCgtMSwgLTEpO1xuICAgIC8vdGhpcy5vcmlnaW4gPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQoMCwgMCk7XG4gICAgdGhpcy5ib3VuZHMgPSBuZXcgcmVjdGFuZ3VsYXIuUmVjdGFuZ2xlKDAsIDAsIDAsIDApO1xuICAgIHRoaXMuaGFzTW91c2UgPSBmYWxzZTtcblxuICAgIHRoaXMuY2FudmFzLm9ubW91c2VvdmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuaGFzTW91c2UgPSB0cnVlO1xuICAgIH07XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5mb2N1c2dhaW5lZChlKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmluZm9jdXNsb3N0KGUpO1xuICAgIH0pO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbm1vdXNlZG93bihlKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmhhc01vdXNlID0gZmFsc2U7XG4gICAgICAgIHNlbGYuZmlubW91c2VvdXQoZSk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5jbGljayhlKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbmRibGNsaWNrKGUpO1xuICAgIH0pO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmluY29udGV4dG1lbnUoZSk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jYW52YXMuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIDApO1xuXG4gICAgdGhpcy5yZXNpemUoKTtcblxuICAgIHRoaXMuc3RhcnQoKTtcbiAgICAvLyB0aGlzLmJlZ2luUmVzaXppbmcoKTtcbiAgICAvLyB0aGlzLmJlZ2luUGFpbnRpbmcoKTtcbn1cblxuQ2FudmFzLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ2FudmFzLnByb3RvdHlwZS5jb25zdHJ1Y3RvcixcbiAgICBkaXY6IG51bGwsXG4gICAgY29tcG9uZW50OiBudWxsLFxuICAgIGNhbnZhczogbnVsbCxcbiAgICBmb2N1c2VyOiBudWxsLFxuICAgIGJ1ZmZlcjogbnVsbCxcbiAgICBjdHg6IG51bGwsXG4gICAgbW91c2VMb2NhdGlvbjogbnVsbCxcbiAgICBkcmFnc3RhcnQ6IG51bGwsXG4gICAgb3JpZ2luOiBudWxsLFxuICAgIGJvdW5kczogbnVsbCxcbiAgICBkaXJ0eTogZmFsc2UsXG4gICAgc2l6ZTogbnVsbCxcbiAgICBtb3VzZWRvd246IGZhbHNlLFxuICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICByZXBlYXRLZXlDb3VudDogMCxcbiAgICByZXBlYXRLZXk6IG51bGwsXG4gICAgcmVwZWF0S2V5U3RhcnRUaW1lOiAwLFxuICAgIGN1cnJlbnRLZXlzOiBbXSxcbiAgICBoYXNNb3VzZTogZmFsc2UsXG4gICAgZHJhZ0VuZFRpbWU6IDAsXG4gICAgbGFzdFJlcGFpbnRUaW1lOiAwLFxuICAgIGN1cnJlbnRQYWludENvdW50OiAwLFxuICAgIGN1cnJlbnRGUFM6IDAsXG4gICAgbGFzdEZQU0NvbXB1dGVUaW1lOiAwLFxuICAgIGxpc3RlbmVyczoge30sXG5cbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlRG9jdW1lbnRFdmVudExpc3RlbmVyczogZnVuY3Rpb24oaXNFbmFibGUpIHtcbiAgICAgICAgaWYgKGlzRW5hYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZURvY3VtZW50RXZlbnRMaXN0ZW5lcnMoZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgbW91c2Vtb3ZlOiBlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNNb3VzZSB8fCB0aGlzLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbm1vdXNlbW92ZShlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW91c2V1cDogZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5tb3VzZXVwKGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdoZWVsOiBlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbndoZWVsbW92ZWQoZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2V5ZG93bjogZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5rZXlkb3duKGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtleXVwOiBlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmtleXVwKGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vdXNlZG93bjogZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbnZhc1JlY3QgPSB0aGlzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FudmFzUmVjdC54ICE9PSBjYW52YXNSZWN0LnkgJiYgY2FudmFzUmVjdC53aWR0aCAhPT0gY2FudmFzUmVjdC5oZWlnaHQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICEoZXZlbnQuY2xpZW50WCA+IGNhbnZhc1JlY3QueFxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgZXZlbnQuY2xpZW50WSA+IGNhbnZhc1JlY3QueVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgZXZlbnQuY2xpZW50WCA8IChjYW52YXNSZWN0LnggKyBjYW52YXNSZWN0LndpZHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgZXZlbnQuY2xpZW50WSA8IChjYW52YXNSZWN0LnkgKyBjYW52YXNSZWN0LmhlaWdodCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbk1vdXNlRG93bk91dHNpZGUoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgT2JqZWN0LmtleXMobGlzdGVuZXJzKS5mb3JFYWNoKGV2ZW50VHlwZSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubGlzdGVuZXJzW2V2ZW50VHlwZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1tldmVudFR5cGVdID0gbGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb2N1bWVudFtgJHtpc0VuYWJsZSA/ICdhZGQnIDogJ3JlbW92ZSd9RXZlbnRMaXN0ZW5lcmBdKGV2ZW50VHlwZSwgdGhpcy5saXN0ZW5lcnNbZXZlbnRUeXBlXSk7XG4gICAgICAgICAgICBpZiAoIWlzRW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMubGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgc3RvcFBhaW50TG9vcDogc3RvcFBhaW50TG9vcCxcbiAgICByZXN0YXJ0UGFpbnRMb29wOiByZXN0YXJ0UGFpbnRMb29wLFxuXG4gICAgc3RvcFJlc2l6ZUxvb3A6IHN0b3BSZXNpemVMb29wLFxuICAgIHJlc3RhcnRSZXNpemVMb29wOiByZXN0YXJ0UmVzaXplTG9vcCxcblxuICAgIGRldGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zdG9wUGFpbnRpbmcoKTtcbiAgICAgICAgdGhpcy5zdG9wUmVzaXppbmcoKTtcbiAgICB9LFxuXG4gICAgZ2V0Q3VycmVudEZQUzpmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEZQUztcbiAgICB9LFxuXG5cbiAgICB0aWNrUGFpbnQ6IGZ1bmN0aW9uKG5vdykge1xuICAgICAgICB2YXIgaXNDb250aW51b3VzUmVwYWludCA9IHRoaXMuY29tcG9uZW50LnByb3BlcnRpZXMuZW5hYmxlQ29udGludW91c1JlcGFpbnQsXG4gICAgICAgICAgICBmcHMgPSB0aGlzLmNvbXBvbmVudC5wcm9wZXJ0aWVzLnJlcGFpbnRJbnRlcnZhbFJhdGU7XG4gICAgICAgIGlmIChmcHMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSAxMDAwIC8gZnBzO1xuXG4gICAgICAgIHZhciBlbGFwc2VkID0gbm93IC0gdGhpcy5sYXN0UmVwYWludFRpbWU7XG4gICAgICAgIGlmIChlbGFwc2VkID4gaW50ZXJ2YWwgJiYgKGlzQ29udGludW91c1JlcGFpbnQgfHwgdGhpcy5kaXJ0eSkpIHtcbiAgICAgICAgICAgIHRoaXMucGFpbnROb3coKTtcbiAgICAgICAgICAgIHRoaXMubGFzdFJlcGFpbnRUaW1lID0gbm93O1xuICAgICAgICAgICAgLyogLSAoZWxhcHNlZCAlIGludGVydmFsKTsqL1xuICAgICAgICAgICAgaWYgKGlzQ29udGludW91c1JlcGFpbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYWludENvdW50Kys7XG4gICAgICAgICAgICAgICAgaWYgKG5vdyAtIHRoaXMubGFzdEZQU0NvbXB1dGVUaW1lID49IDEwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RlBTID0gKHRoaXMuY3VycmVudFBhaW50Q291bnQgKiAxMDAwKSAvIChub3cgLSB0aGlzLmxhc3RGUFNDb21wdXRlVGltZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhaW50Q291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RGUFNDb21wdXRlVGltZSA9IG5vdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYmVnaW5QYWludGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMudGlja1BhaW50ZXIgPSBmdW5jdGlvbihub3cpIHtcbiAgICAgICAgICAgIHNlbGYudGlja1BhaW50KG5vdyk7XG4gICAgICAgIH07XG4gICAgICAgIHBhaW50YWJsZXMucHVzaCh0aGlzKTtcbiAgICB9LFxuXG4gICAgc3RvcFBhaW50aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcGFpbnRhYmxlcy5zcGxpY2UocGFpbnRhYmxlcy5pbmRleE9mKHRoaXMpLCAxKTtcbiAgICB9LFxuXG4gICAgYmVnaW5SZXNpemluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy50aWNrUmVzaXplciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5jaGVja3NpemUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVzaXphYmxlcy5wdXNoKHRoaXMpO1xuICAgIH0sXG5cbiAgICBzdG9wUmVzaXppbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNpemFibGVzLnNwbGljZShyZXNpemFibGVzLmluZGV4T2YodGhpcyksIDEpO1xuICAgIH0sXG5cbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYmVnaW5QYWludGluZygpO1xuICAgICAgICB0aGlzLmJlZ2luUmVzaXppbmcoKTtcbiAgICAgICAgdGhpcy50b2dnbGVEb2N1bWVudEV2ZW50TGlzdGVuZXJzKHRydWUpO1xuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zdG9wUGFpbnRpbmcoKTtcbiAgICAgICAgdGhpcy5zdG9wUmVzaXppbmcoKTtcbiAgICB9LFxuXG4gICAgZ2V0RGl2Qm91bmRpbmdDbGllbnRSZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIG91ciBjYW52YXMgaGFzIGludGVncmFsIGRpbWVuc2lvbnNcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHRvcCA9IE1hdGguZmxvb3IocmVjdC50b3ApLFxuICAgICAgICAgICAgbGVmdCA9IE1hdGguZmxvb3IocmVjdC5sZWZ0KSxcbiAgICAgICAgICAgIHdpZHRoID0gTWF0aC5jZWlsKHJlY3Qud2lkdGgpLFxuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKHJlY3QuaGVpZ2h0KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICByaWdodDogbGVmdCArIHdpZHRoLFxuICAgICAgICAgICAgYm90dG9tOiB0b3AgKyBoZWlnaHQsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICB4OiByZWN0LngsXG4gICAgICAgICAgICB5OiByZWN0LnlcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgY2hlY2tzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy90aGlzIGlzIGV4cGVuc2l2ZSBsZXRzIGRvIGl0IGF0IHNvbWUgbW9kdWxvXG4gICAgICAgIHZhciBzaXplTm93ID0gdGhpcy5nZXREaXZCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKHNpemVOb3cud2lkdGggIT09IHRoaXMuc2l6ZS53aWR0aCB8fCBzaXplTm93LmhlaWdodCAhPT0gdGhpcy5zaXplLmhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWZyZXNoQm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgYm94ID0gdGhpcy5zaXplID0gdGhpcy5nZXREaXZCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IGJveC53aWR0aCAtIHRoaXMuY29tcG9uZW50LnByb3BlcnRpZXMuY2FudmFzV2lkdGhPZmZzZXQ7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gYm94LmhlaWdodCAtIHRoaXMuY29tcG9uZW50LnByb3BlcnRpZXMuY2FudmFzSGVpZ2h0T2Zmc2V0O1xuICAgICAgICB0aGlzLmJvdW5kcyA9IG5ldyByZWN0YW5ndWxhci5SZWN0YW5nbGUoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudC5zZXRCb3VuZHModGhpcy5ib3VuZHMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudC52aWV3SGVpZ2h0ID0gdGhpcy5ib3VuZHMuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICByZXNpemU6IGZ1bmN0aW9uKHdpdGhOb3RpZmljYXRpb24pIHtcbiAgICAgICAgd2l0aE5vdGlmaWNhdGlvbiA9IHR5cGVvZiB3aXRoTm90aWZpY2F0aW9uICE9PSAndW5kZWZpbmVkJyA/IHdpdGhOb3RpZmljYXRpb24gOiB0cnVlO1xuICAgICAgICB2YXIgYm94ID0gdGhpcy5zaXplID0gdGhpcy5nZXREaXZCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICB0aGlzLndpZHRoID0gYm94LndpZHRoIC0gdGhpcy5jb21wb25lbnQucHJvcGVydGllcy5jYW52YXNXaWR0aE9mZnNldDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBib3guaGVpZ2h0IC0gdGhpcy5jb21wb25lbnQucHJvcGVydGllcy5jYW52YXNIZWlnaHRPZmZzZXQ7XG5cbiAgICAgICAgLy9maXggYWxhIHNpciBzcGlua2EsIHNlZVxuICAgICAgICAvL2h0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2NhbnZhcy9oaWRwaS9cbiAgICAgICAgLy9qdXN0IGFkZCAnaGRwaScgYXMgYW4gYXR0cmlidXRlIHRvIHRoZSBmaW4tY2FudmFzIHRhZ1xuICAgICAgICB2YXIgcmF0aW8gPSAxO1xuICAgICAgICB2YXIgaXNISURQSSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICYmIHRoaXMuY29tcG9uZW50LnByb3BlcnRpZXMudXNlSGlEUEk7XG4gICAgICAgIGlmIChpc0hJRFBJKSB7XG4gICAgICAgICAgICB2YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICAgICAgICB2YXIgYmFja2luZ1N0b3JlUmF0aW8gPSB0aGlzLmdjLndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmdjLm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmdjLm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuZ2Mub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmdjLmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcblxuICAgICAgICAgICAgcmF0aW8gPSBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG4gICAgICAgICAgICAvL3RoaXMuY2FudmFzQ1RYLnNjYWxlKHJhdGlvLCByYXRpbyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJ1ZmZlci53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy53aWR0aCAqIHJhdGlvO1xuICAgICAgICB0aGlzLmJ1ZmZlci5oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodCAqIHJhdGlvO1xuXG4gICAgICAgIC8vICsyIGFuZCArMSBiZWNhdXNlIG9mIHNvbWUgdGV4dCByZW5kZXIgYXJ0aWZhY3RzIChzb21ldGltZXMgbm90IG9ubHkgdGV4dCkgKHNvbWUgdmVydGljYWwvaG9yaXpvbnRhbCBicm9rZW4gbGluZXMpXG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLndpZHRoID0gdGhpcy5idWZmZXIuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgMiArICdweCc7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9IHRoaXMuYnVmZmVyLnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgMSArICdweCc7XG5cbiAgICAgICAgdGhpcy5iYy5zY2FsZShyYXRpbywgcmF0aW8pO1xuICAgICAgICBpZiAoaXNISURQSSAmJiAhdGhpcy5jb21wb25lbnQucHJvcGVydGllcy51c2VCaXRCbGl0KSB7XG4gICAgICAgICAgICB0aGlzLmdjLnNjYWxlKHJhdGlvLCByYXRpbyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvdW5kcyA9IG5ldyByZWN0YW5ndWxhci5SZWN0YW5nbGUoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudC5zZXRCb3VuZHModGhpcy5ib3VuZHMpO1xuICAgICAgICBpZiAod2l0aE5vdGlmaWNhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVOb3RpZmljYXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGFpbnROb3coKTtcbiAgICB9LFxuXG4gICAgcmVzaXplTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld0V2ZW50KHVuZGVmaW5lZCwgJ2Zpbi1jYW52YXMtcmVzaXplZCcsIHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRzO1xuICAgIH0sXG5cbiAgICBwYWludE5vdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1c2VCaXRCbGl0ID0gdGhpcy5jb21wb25lbnQucHJvcGVydGllcy51c2VCaXRCbGl0LFxuICAgICAgICAgICAgZ2MgPSB1c2VCaXRCbGl0ID8gdGhpcy5iYyA6IHRoaXMuZ2M7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGdjLmNhY2hlLnNhdmUoKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnBhaW50KGdjKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGdjLmNhY2hlLnJlc3RvcmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1c2VCaXRCbGl0KSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmx1c2hCdWZmZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXIud2lkdGggPiAwICYmIHRoaXMuYnVmZmVyLmhlaWdodCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZ2MuZHJhd0ltYWdlKHRoaXMuYnVmZmVyLCAwLCAwKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBuZXdFdmVudDogZnVuY3Rpb24ocHJpbWl0aXZlRXZlbnQsIG5hbWUsIGRldGFpbCkge1xuICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICBkZXRhaWw6IGRldGFpbCB8fCB7fVxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJpbWl0aXZlRXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LmRldGFpbC5wcmltaXRpdmVFdmVudCA9IHByaW1pdGl2ZUV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRXZlbnQobmFtZSwgZXZlbnQpO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaE5ld0V2ZW50OiBmdW5jdGlvbihwcmltaXRpdmVFdmVudCwgbmFtZSwgZGV0YWlsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KHRoaXMubmV3RXZlbnQocHJpbWl0aXZlRXZlbnQsIG5hbWUsIGRldGFpbCkpO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50OiBmdW5jdGlvbihldmVudCwgbmFtZSwgZGV0YWlsKSB7XG4gICAgICAgIGRldGFpbCA9IGRldGFpbCB8fCB7fTtcbiAgICAgICAgZGV0YWlsLm1vdXNlID0gdGhpcy5tb3VzZUxvY2F0aW9uO1xuICAgICAgICBkZXRhaWwua2V5cyA9IHRoaXMuY3VycmVudEtleXM7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZXZlbnQsIG5hbWUsIGRldGFpbCk7XG4gICAgfSxcblxuICAgIGZpbm1vdXNlbW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpICYmIHRoaXMubW91c2Vkb3duKSB7XG4gICAgICAgICAgICB0aGlzLmJlRHJhZ2dpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1kcmFnc3RhcnQnLCB7XG4gICAgICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKSxcbiAgICAgICAgICAgICAgICBkcmFnc3RhcnQ6IHRoaXMuZHJhZ3N0YXJ0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ3N0YXJ0ID0gbmV3IHJlY3Rhbmd1bGFyLlBvaW50KHRoaXMubW91c2VMb2NhdGlvbi54LCB0aGlzLm1vdXNlTG9jYXRpb24ueSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLm1vdXNlTG9jYXRpb24pO1xuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1kcmFnJywge1xuICAgICAgICAgICAgICAgIGRyYWdzdGFydDogdGhpcy5kcmFnc3RhcnQsXG4gICAgICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYm91bmRzLmNvbnRhaW5zKHRoaXMubW91c2VMb2NhdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1tb3VzZW1vdmUnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5tb3VzZWRvd246IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5tb3VzZURvd25Mb2NhdGlvbiA9IHRoaXMuZ2V0TG9jYWwoZSk7XG4gICAgICAgIHRoaXMubW91c2Vkb3duID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtbW91c2Vkb3duJywge1xuICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50YWtlRm9jdXMoKTtcblxuICAgICAgICAvLyBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG5cbiAgICBmaW5Nb3VzZURvd25PdXRzaWRlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1vdXRzaWRlLW1vdXNlZG93bicsIHtcbiAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZpbm1vdXNldXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vdXNlZG93bikge1xuICAgICAgICAgICAgLy8gaWdub3JlIGRvY3VtZW50Om1vdXNldXAgdW5sZXNzIHByZWNlZGVkIGJ5IGEgY2FudmFzOm1vdXNlZG93blxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLWRyYWdlbmQnLCB7XG4gICAgICAgICAgICAgICAgZHJhZ3N0YXJ0OiB0aGlzLmRyYWdzdGFydCxcbiAgICAgICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYmVOb3REcmFnZ2luZygpO1xuICAgICAgICAgICAgdGhpcy5kcmFnRW5kdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VzZWRvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLW1vdXNldXAnLCB7XG4gICAgICAgICAgICBkcmFnc3RhcnQ6IHRoaXMuZHJhZ3N0YXJ0LFxuICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKVxuICAgICAgICB9KTtcbiAgICAgICAgLy90aGlzLm1vdXNlTG9jYXRpb24gPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQoLTEsIC0xKTtcbiAgICB9LFxuXG4gICAgZmlubW91c2VvdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vdXNlZG93bikge1xuICAgICAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gbmV3IHJlY3Rhbmd1bGFyLlBvaW50KC0xLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1tb3VzZW91dCcsIHtcbiAgICAgICAgICAgIGRyYWdzdGFydDogdGhpcy5kcmFnc3RhcnRcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZpbndoZWVsbW92ZWQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZygpIHx8ICF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy13aGVlbG1vdmVkJywge1xuICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZmluY2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLWNsaWNrJywge1xuICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZmluZGJsY2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLWRibGNsaWNrJywge1xuICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZ2V0Q2hhck1hcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjaGFyTWFwO1xuICAgIH0sXG5cbiAgICBnZXRLZXlDaGFyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBrZXkgPSBlLmtleUNvZGUgfHwgZS5kZXRhaWwua2V5LFxuICAgICAgICAgICAgc2hpZnQgPSBlLnNoaWZ0S2V5IHx8IGUuZGV0YWlsLnNoaWZ0O1xuICAgICAgICByZXR1cm4gY2hhck1hcFtrZXldW3NoaWZ0ID8gMSA6IDBdO1xuICAgIH0sXG5cbiAgICBmaW5rZXlkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNGb2N1cygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcmV2ZW50IFRBQiBmcm9tIG1vdmluZyBmb2N1cyBvZmYgdGhlIGNhbnZhcyBlbGVtZW50XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IDkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7XG4gICAgICAgIC8vICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICB2YXIga2V5Q2hhciA9IHRoaXMuZ2V0S2V5Q2hhcihlKTtcbiAgICAgICAgaWYgKGUucmVwZWF0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXBlYXRLZXkgPT09IGtleUNoYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGVhdEtleUNvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwZWF0S2V5ID0ga2V5Q2hhcjtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGVhdEtleVN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlcGVhdEtleSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJlcGVhdEtleUNvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMucmVwZWF0S2V5U3RhcnRUaW1lID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50S2V5cy5pbmRleE9mKGtleUNoYXIpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50S2V5cy5wdXNoKGtleUNoYXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld0V2ZW50KGUsICdmaW4tY2FudmFzLWtleWRvd24nLCB7XG4gICAgICAgICAgICBhbHQ6IGUuYWx0S2V5LFxuICAgICAgICAgICAgY3RybDogZS5jdHJsS2V5LFxuICAgICAgICAgICAgY2hhcjoga2V5Q2hhcixcbiAgICAgICAgICAgIGNvZGU6IGUuY2hhckNvZGUsXG4gICAgICAgICAgICBrZXk6IGUua2V5Q29kZSxcbiAgICAgICAgICAgIG1ldGE6IGUubWV0YUtleSxcbiAgICAgICAgICAgIHJlcGVhdENvdW50OiB0aGlzLnJlcGVhdEtleUNvdW50LFxuICAgICAgICAgICAgcmVwZWF0U3RhcnRUaW1lOiB0aGlzLnJlcGVhdEtleVN0YXJ0VGltZSxcbiAgICAgICAgICAgIHNoaWZ0OiBlLnNoaWZ0S2V5LFxuICAgICAgICAgICAgaWRlbnRpZmllcjogZS5rZXksXG4gICAgICAgICAgICBjdXJyZW50S2V5czogdGhpcy5jdXJyZW50S2V5cy5zbGljZSgwKSxcbiAgICAgICAgICAgIHNvdXJjZUV2ZW50OiBlXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW5rZXl1cDogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzRm9jdXMoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJldmVudCBUQUIgZnJvbSBtb3ZpbmcgZm9jdXMgb2ZmIHRoZSBjYW52YXMgZWxlbWVudFxuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSA5KSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5Q2hhciA9IHRoaXMuZ2V0S2V5Q2hhcihlKTtcbiAgICAgICAgdGhpcy5jdXJyZW50S2V5cy5zcGxpY2UodGhpcy5jdXJyZW50S2V5cy5pbmRleE9mKGtleUNoYXIpLCAxKTtcbiAgICAgICAgdGhpcy5yZXBlYXRLZXlDb3VudCA9IDA7XG4gICAgICAgIHRoaXMucmVwZWF0S2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXBlYXRLZXlTdGFydFRpbWUgPSAwO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZSwgJ2Zpbi1jYW52YXMta2V5dXAnLCB7XG4gICAgICAgICAgICBhbHQ6IGUuYWx0S2V5LFxuICAgICAgICAgICAgY3RybDogZS5jdHJsS2V5LFxuICAgICAgICAgICAgY2hhcjoga2V5Q2hhcixcbiAgICAgICAgICAgIGNvZGU6IGUuY2hhckNvZGUsXG4gICAgICAgICAgICBrZXk6IGUua2V5Q29kZSxcbiAgICAgICAgICAgIG1ldGE6IGUubWV0YUtleSxcbiAgICAgICAgICAgIHJlcGVhdDogZS5yZXBlYXQsXG4gICAgICAgICAgICBzaGlmdDogZS5zaGlmdEtleSxcbiAgICAgICAgICAgIGlkZW50aWZpZXI6IGUua2V5LFxuICAgICAgICAgICAgY3VycmVudEtleXM6IHRoaXMuY3VycmVudEtleXMuc2xpY2UoMClcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9jbGVhckN1cnJlbnRLZXlzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50S2V5cyA9IFtdO1xuICAgIH0sXG5cbiAgICBmaW5mb2N1c2dhaW5lZDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZSwgJ2Zpbi1jYW52YXMtZm9jdXMtZ2FpbmVkJyk7XG4gICAgfSxcblxuICAgIGZpbmZvY3VzbG9zdDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLl9jbGVhckN1cnJlbnRLZXlzKCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdFdmVudChlLCAnZmluLWNhbnZhcy1mb2N1cy1sb3N0Jyk7XG4gICAgfSxcblxuICAgIGZpbmNvbnRleHRtZW51OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLmN0cmxLZXkgJiYgdGhpcy5jdXJyZW50S2V5cy5pbmRleE9mKCdDVFJMJykgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRLZXlzLnB1c2goJ0NUUkwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1jb250ZXh0LW1lbnUnLCB7XG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZXBhaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIGlmICghcGFpbnRSZXF1ZXN0IHx8IHRoaXMuY29tcG9uZW50LnByb3BlcnRpZXMucmVwYWludEludGVydmFsUmF0ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wYWludE5vdygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldE1vdXNlTG9jYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZUxvY2F0aW9uO1xuICAgIH0sXG5cbiAgICBnZXRPcmlnaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgcCA9IG5ldyByZWN0YW5ndWxhci5Qb2ludChyZWN0LmxlZnQsIHJlY3QudG9wKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfSxcblxuICAgIGdldExvY2FsOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBwID0gbmV3IHJlY3Rhbmd1bGFyLlBvaW50KGUuY2xpZW50WCAtIHJlY3QubGVmdCwgZS5jbGllbnRZIC0gcmVjdC50b3ApO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgaGFzRm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5jYW52YXM7XG4gICAgfSxcblxuICAgIHRha2VGb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYW52YXMuZm9jdXMoKTtcbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBiZURyYWdnaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlzYWJsZURvY3VtZW50RWxlbWVudFNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICBiZU5vdERyYWdnaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVuYWJsZURvY3VtZW50RWxlbWVudFNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICBpc0RyYWdnaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ2dpbmc7XG4gICAgfSxcblxuICAgIGRpc2FibGVEb2N1bWVudEVsZW1lbnRTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuICAgICAgICBzdHlsZS5jc3NUZXh0ID0gc3R5bGUuY3NzVGV4dCArICctd2Via2l0LXVzZXItc2VsZWN0OiBub25lJztcbiAgICB9LFxuXG4gICAgZW5hYmxlRG9jdW1lbnRFbGVtZW50U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICAgICAgc3R5bGUuY3NzVGV4dCA9IHN0eWxlLmNzc1RleHQucmVwbGFjZSgnLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZScsICcnKTtcbiAgICB9LFxuXG4gICAgc2V0Rm9jdXNhYmxlOiBmdW5jdGlvbih0cnV0aHkpIHtcbiAgICAgICAgdGhpcy5mb2N1c2VyLnN0eWxlLmRpc3BsYXkgPSB0cnV0aHkgPyAnJyA6ICdub25lJztcbiAgICB9LFxuXG4gICAgaXNSaWdodENsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBpc1JpZ2h0TUI7XG4gICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblxuICAgICAgICBpZiAoJ3doaWNoJyBpbiBlKSB7IC8vIEdlY2tvIChGaXJlZm94KSwgV2ViS2l0IChTYWZhcmkvQ2hyb21lKSAmIE9wZXJhXG4gICAgICAgICAgICBpc1JpZ2h0TUIgPSBlLndoaWNoID09PSAzO1xuICAgICAgICB9IGVsc2UgaWYgKCdidXR0b24nIGluIGUpIHsgLy8gSUUsIE9wZXJhXG4gICAgICAgICAgICBpc1JpZ2h0TUIgPSBlLmJ1dHRvbiA9PT0gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNSaWdodE1CO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGUpO1xuICAgIH0sXG5cbiAgICBzZXRJbmZvOiBmdW5jdGlvbihtZXNzYWdlLCB3aWR0aCkge1xuICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggJiYgIWlzTmFOKE51bWJlcih3aWR0aCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoICs9ICdweCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaW5mb0Rpdi5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbmRleE9mKCc8JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm9EaXYuaW5uZXJIVE1MID0gbWVzc2FnZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvRGl2LmlubmVyVGV4dCA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluZm9EaXYuc3R5bGUuZGlzcGxheSA9IG1lc3NhZ2UgPyAnYmxvY2snIDogJ25vbmUnO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHBhaW50TG9vcEZ1bmN0aW9uKG5vdykge1xuICAgIGlmIChwYWludFJlcXVlc3QpIHtcbiAgICAgICAgcGFpbnRhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uKHBhaW50YWJsZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYWludGFibGUudGlja1BhaW50ZXIobm93KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFpbnRhYmxlLmNvbXBvbmVudC50aWNrTm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgcGFpbnRhYmxlLmNvbXBvbmVudC50aWNrTm90aWZpY2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwYWludFJlcXVlc3QgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocGFpbnRMb29wRnVuY3Rpb24pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc3RhcnRQYWludExvb3AoKSB7XG4gICAgcGFpbnRSZXF1ZXN0ID0gcGFpbnRSZXF1ZXN0IHx8IHJlcXVlc3RBbmltYXRpb25GcmFtZShwYWludExvb3BGdW5jdGlvbik7XG59XG5mdW5jdGlvbiBzdG9wUGFpbnRMb29wKCkge1xuICAgIGlmIChwYWludFJlcXVlc3QpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocGFpbnRSZXF1ZXN0KTtcbiAgICAgICAgcGFpbnRSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbnJlc3RhcnRQYWludExvb3AoKTtcblxuZnVuY3Rpb24gcmVzaXphYmxlc0xvb3BGdW5jdGlvbihub3cpIHtcbiAgICBpZiAocmVzaXplSW50ZXJ2YWwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNpemFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc2l6YWJsZXNbaV0udGlja1Jlc2l6ZXIobm93KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzdGFydFJlc2l6ZUxvb3AoKSB7XG4gICAgcmVzaXplSW50ZXJ2YWwgPSByZXNpemVJbnRlcnZhbCB8fCBzZXRJbnRlcnZhbChyZXNpemFibGVzTG9vcEZ1bmN0aW9uLCBSRVNJWkVfUE9MTElOR19JTlRFUlZBTCk7XG59XG5mdW5jdGlvbiBzdG9wUmVzaXplTG9vcCgpIHtcbiAgICBpZiAocmVzaXplSW50ZXJ2YWwpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChyZXNpemVJbnRlcnZhbCk7XG4gICAgICAgIHJlc2l6ZUludGVydmFsID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbnJlc3RhcnRSZXNpemVMb29wKCk7XG5cbmZ1bmN0aW9uIG1ha2VDaGFyTWFwKCkge1xuICAgIHZhciBtYXAgPSBbXTtcblxuICAgIHZhciBlbXB0eSA9IFsnJywgJyddO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBtYXBbaV0gPSBlbXB0eTtcbiAgICB9XG5cbiAgICBtYXBbMjddID0gWydFU0MnLCAnRVNDU0hJRlQnXTtcbiAgICBtYXBbMTkyXSA9IFsnYCcsICd+J107XG4gICAgbWFwWzQ5XSA9IFsnMScsICchJ107XG4gICAgbWFwWzUwXSA9IFsnMicsICdAJ107XG4gICAgbWFwWzUxXSA9IFsnMycsICcjJ107XG4gICAgbWFwWzUyXSA9IFsnNCcsICckJ107XG4gICAgbWFwWzUzXSA9IFsnNScsICclJ107XG4gICAgbWFwWzU0XSA9IFsnNicsICdeJ107XG4gICAgbWFwWzU1XSA9IFsnNycsICcmJ107XG4gICAgbWFwWzU2XSA9IFsnOCcsICcqJ107XG4gICAgbWFwWzU3XSA9IFsnOScsICcoJ107XG4gICAgbWFwWzQ4XSA9IFsnMCcsICcpJ107XG4gICAgbWFwWzE4OV0gPSBbJy0nLCAnXyddO1xuICAgIG1hcFsxODddID0gWyc9JywgJysnXTtcbiAgICBtYXBbOF0gPSBbJ0JBQ0tTUEFDRScsICdCQUNLU1BBQ0VTSElGVCddO1xuICAgIG1hcFs0Nl0gPSBbJ0RFTEVURScsICdERUxFVEVTSElGVCddO1xuICAgIG1hcFs5XSA9IFsnVEFCJywgJ1RBQlNISUZUJ107XG4gICAgbWFwWzgxXSA9IFsncScsICdRJ107XG4gICAgbWFwWzg3XSA9IFsndycsICdXJ107XG4gICAgbWFwWzY5XSA9IFsnZScsICdFJ107XG4gICAgbWFwWzgyXSA9IFsncicsICdSJ107XG4gICAgbWFwWzg0XSA9IFsndCcsICdUJ107XG4gICAgbWFwWzg5XSA9IFsneScsICdZJ107XG4gICAgbWFwWzg1XSA9IFsndScsICdVJ107XG4gICAgbWFwWzczXSA9IFsnaScsICdJJ107XG4gICAgbWFwWzc5XSA9IFsnbycsICdPJ107XG4gICAgbWFwWzgwXSA9IFsncCcsICdQJ107XG4gICAgbWFwWzIxOV0gPSBbJ1snLCAneyddO1xuICAgIG1hcFsyMjFdID0gWyddJywgJ30nXTtcbiAgICBtYXBbMjIwXSA9IFsnXFxcXCcsICd8J107XG4gICAgbWFwWzIyMF0gPSBbJ0NBUFNMT0NLJywgJ0NBUFNMT0NLU0hJRlQnXTtcbiAgICBtYXBbNjVdID0gWydhJywgJ0EnXTtcbiAgICBtYXBbODNdID0gWydzJywgJ1MnXTtcbiAgICBtYXBbNjhdID0gWydkJywgJ0QnXTtcbiAgICBtYXBbNzBdID0gWydmJywgJ0YnXTtcbiAgICBtYXBbNzFdID0gWydnJywgJ0cnXTtcbiAgICBtYXBbNzJdID0gWydoJywgJ0gnXTtcbiAgICBtYXBbNzRdID0gWydqJywgJ0onXTtcbiAgICBtYXBbNzVdID0gWydrJywgJ0snXTtcbiAgICBtYXBbNzZdID0gWydsJywgJ0wnXTtcbiAgICBtYXBbMTg2XSA9IFsnOycsICc6J107XG4gICAgbWFwWzIyMl0gPSBbJ1xcJycsICd8J107XG4gICAgbWFwWzEzXSA9IFsnUkVUVVJOJywgJ1JFVFVSTlNISUZUJ107XG4gICAgbWFwWzE2XSA9IFsnU0hJRlQnLCAnU0hJRlQnXTtcbiAgICBtYXBbOTBdID0gWyd6JywgJ1onXTtcbiAgICBtYXBbODhdID0gWyd4JywgJ1gnXTtcbiAgICBtYXBbNjddID0gWydjJywgJ0MnXTtcbiAgICBtYXBbODZdID0gWyd2JywgJ1YnXTtcbiAgICBtYXBbNjZdID0gWydiJywgJ0InXTtcbiAgICBtYXBbNzhdID0gWyduJywgJ04nXTtcbiAgICBtYXBbNzddID0gWydtJywgJ00nXTtcbiAgICBtYXBbMTg4XSA9IFsnLCcsICc8J107XG4gICAgbWFwWzE5MF0gPSBbJy4nLCAnPiddO1xuICAgIG1hcFsxOTFdID0gWycvJywgJz8nXTtcbiAgICBtYXBbMTZdID0gWydTSElGVCcsICdTSElGVCddO1xuICAgIG1hcFsxN10gPSBbJ0NUUkwnLCAnQ1RSTFNISUZUJ107XG4gICAgbWFwWzE4XSA9IFsnQUxUJywgJ0FMVFNISUZUJ107XG4gICAgbWFwWzkxXSA9IFsnQ09NTUFORExFRlQnLCAnQ09NTUFORExFRlRTSElGVCddO1xuICAgIG1hcFszMl0gPSBbJ1NQQUNFJywgJ1NQQUNFU0hJRlQnXTtcbiAgICBtYXBbOTNdID0gWydDT01NQU5EUklHSFQnLCAnQ09NTUFORFJJR0hUU0hJRlQnXTtcbiAgICBtYXBbMThdID0gWydBTFQnLCAnQUxUU0hJRlQnXTtcbiAgICBtYXBbMzhdID0gWydVUCcsICdVUFNISUZUJ107XG4gICAgbWFwWzM3XSA9IFsnTEVGVCcsICdMRUZUU0hJRlQnXTtcbiAgICBtYXBbNDBdID0gWydET1dOJywgJ0RPV05TSElGVCddO1xuICAgIG1hcFszOV0gPSBbJ1JJR0hUJywgJ1JJR0hUU0hJRlQnXTtcblxuICAgIG1hcFszM10gPSBbJ1BBR0VVUCcsICdQQUdFVVBTSElGVCddO1xuICAgIG1hcFszNF0gPSBbJ1BBR0VET1dOJywgJ1BBR0VET1dOU0hJRlQnXTtcbiAgICBtYXBbMzVdID0gWydQQUdFUklHSFQnLCAnUEFHRVJJR0hUU0hJRlQnXTsgLy8gRU5EXG4gICAgbWFwWzM2XSA9IFsnUEFHRUxFRlQnLCAnUEFHRUxFRlRTSElGVCddOyAvLyBIT01FXG5cbiAgICBtYXBbMTEyXSA9IFsnRjEnLCAnRjFTSElGVCddO1xuICAgIG1hcFsxMTNdID0gWydGMicsICdGMlNISUZUJ107XG4gICAgbWFwWzExNF0gPSBbJ0YzJywgJ0YzU0hJRlQnXTtcbiAgICBtYXBbMTE1XSA9IFsnRjQnLCAnRjRTSElGVCddO1xuICAgIG1hcFsxMTZdID0gWydGNScsICdGNVNISUZUJ107XG4gICAgbWFwWzExN10gPSBbJ0Y2JywgJ0Y2U0hJRlQnXTtcbiAgICBtYXBbMTE4XSA9IFsnRjcnLCAnRjdTSElGVCddO1xuICAgIG1hcFsxMTldID0gWydGOCcsICdGOFNISUZUJ107XG4gICAgbWFwWzEyMF0gPSBbJ0Y5JywgJ0Y5U0hJRlQnXTtcbiAgICBtYXBbMTIxXSA9IFsnRjEwJywgJ0YxMFNISUZUJ107XG4gICAgbWFwWzEyMl0gPSBbJ0YxMScsICdGMTFTSElGVCddO1xuICAgIG1hcFsxMjNdID0gWydGMTInLCAnRjEyU0hJRlQnXTtcblxuICAgIHJldHVybiBtYXA7XG59XG5cbmZ1bmN0aW9uIGdldENhY2hlZENvbnRleHQoY2FudmFzRWxlbWVudCwgdHlwZSkge1xuICAgIHZhciBnYyA9IGNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dCh0eXBlIHx8ICcyZCcsIHsgYWxwaGE6IGZhbHNlIH0pLFxuICAgICAgICBwcm9wcyA9IHt9LFxuICAgICAgICB2YWx1ZXMgPSB7fTtcblxuICAgIC8vIFN0dWIgb3V0IGFsbCB0aGUgcHJvdG90eXBlIG1lbWJlcnMgb2YgdGhlIGNhbnZhcyAyRCBncmFwaGljcyBjb250ZXh0OlxuICAgIE9iamVjdC5rZXlzKE9iamVjdC5nZXRQcm90b3R5cGVPZihnYykpLmZvckVhY2gobWFrZVN0dWIpO1xuXG4gICAgLy8gU29tZSBvbGRlciBicm93c2VycyAoZS5nLiwgQ2hyb21lIDQwKSBkaWQgbm90IGhhdmUgYWxsIG1lbWJlcnMgb2YgY2FudmFzXG4gICAgLy8gMkQgZ3JhcGhpY3MgY29udGV4dCBpbiB0aGUgcHJvdG90eXBlIHNvIHdlIG1ha2UgdGhpcyBhZGRpdGlvbmFsIGNhbGw6XG4gICAgT2JqZWN0LmtleXMoZ2MpLmZvckVhY2gobWFrZVN0dWIpO1xuXG4gICAgZnVuY3Rpb24gbWFrZVN0dWIoa2V5KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICEoa2V5IGluIHByb3BzKSAmJlxuICAgICAgICAgICAgIS9eKHdlYmtpdHxtb3p8bXN8bylbQS1aXS8udGVzdChrZXkpICYmXG4gICAgICAgICAgICB0eXBlb2YgZ2Nba2V5XSAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywga2V5LCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZXNba2V5XSA9IHZhbHVlc1trZXldIHx8IGdjW2tleV0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHZhbHVlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnY1trZXldID0gdmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2MuY2FjaGUgPSBwcm9wcztcblxuICAgIGdjLmNhY2hlLnNhdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZ2Muc2F2ZSgpO1xuICAgICAgICB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHZhbHVlcyk7XG4gICAgfTtcblxuICAgIGdjLmNhY2hlLnJlc3RvcmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZ2MucmVzdG9yZSgpO1xuICAgICAgICB2YWx1ZXMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWVzKTtcbiAgICB9O1xuXG4gICAgZ2MuY29uZGl0aW9uYWxzU3RhY2sgPSBbXTtcblxuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKENhbnZhcy5ncmFwaGljc0NvbnRleHRBbGlhc2VzKS5mb3JFYWNoKGZ1bmN0aW9uKGFsaWFzKSB7XG4gICAgICAgIGdjW2FsaWFzXSA9IGdjW0NhbnZhcy5ncmFwaGljc0NvbnRleHRBbGlhc2VzW2FsaWFzXV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihnYywgcmVxdWlyZSgnLi9ncmFwaGljcycpKTtcbn1cblxuQ2FudmFzLmdyYXBoaWNzQ29udGV4dEFsaWFzZXMgPSB7XG4gICAgc2ltcGxlVGV4dDogJ2ZpbGxUZXh0J1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhcztcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKiogQG1vZHVsZSBlZmZlY3RzICovXG5cbi8qKiBAdHlwZWRlZiB7ZnVuY3Rpb259IGVmZmVjdEZ1bmN0aW9uXG4gKiBAZGVzYyBFbGVtZW50IHRvIHBlcmZvcm0gdHJhbnNpdGlvbnMgdXBvbiBpcyBgb3B0aW9ucy5lbGAgaWYgZGVmaW5lZCBvciBgdGhpcy5lbGAuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbb3B0aW9ucy5lbD10aGlzLmVsXVxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdIEZ1bmN0aW9uIHRvIGNhbGwgYXQgY29uY2x1c2lvbiBvZiB0cmFuc2l0aW9ucy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kdXJhdGlvbj0nMC4wNjVzJ10gLSBEdXJhdGlvbiBvZiBlYWNoIHRyYW5zaXRpb24uXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuc3R5bGVzPWRlZmF1bHRHbG93ZXJTdHlsZXNdIC0gSGFzaCBvZiBDU1Mgc3R5bGVzIGFuZCB2YWx1ZXMgdG8gdHJhbnNpdGlvbi4gKEZvciB7QGxpbmsgZWZmZWN0c35nbG93ZXJ8Z2xvd2VyfSBvbmx5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaGFrZSBlbGVtZW50IGJhY2sgYW5kIGZvdXJ0aCBhIGZldyB0aW1lcyBhcyBpZiB0byBzYXksIFwiTm9wZSFcIlxuICogQHR5cGUge2VmZmVjdEZ1bmN0aW9ufVxuICogQG1lbWJlck9mIG1vZHVsZTplZmZlY3RzXG4gKi9cbmV4cG9ydHMuc2hha2VyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBjb250ZXh0ID0gdGhpcyxcbiAgICAgICAgZWwgPSBvcHRpb25zLmVsIHx8IGNvbnRleHQuZWwsXG4gICAgICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiB8fCAnMC4wNjVzJyxcbiAgICAgICAgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKSxcbiAgICAgICAgdHJhbnNpdGlvbnMgPSBjb21wdXRlZFN0eWxlLnRyYW5zaXRpb24uc3BsaXQoJywnKSxcbiAgICAgICAgcG9zaXRpb24gPSBjb21wdXRlZFN0eWxlLnBvc2l0aW9uLFxuICAgICAgICB4ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5sZWZ0KSxcbiAgICAgICAgZHggPSAtMyxcbiAgICAgICAgc2hha2VzID0gNjtcblxuICAgIHRyYW5zaXRpb25zLnB1c2goJ2xlZnQgJyArIGR1cmF0aW9uKTtcbiAgICBlbC5zdHlsZS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbnMuam9pbignLCcpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBzaGFrZXIpO1xuICAgIHNoYWtlcigpO1xuICAgIGZ1bmN0aW9uIHNoYWtlcihldmVudCkge1xuICAgICAgICBpZiAoIWV2ZW50IHx8IGV2ZW50LnByb3BlcnR5TmFtZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS5sZWZ0ID0geCArIGR4ICsgJ3B4JztcbiAgICAgICAgICAgIGlmICghc2hha2VzLS0pIHtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc2hha2VyKTtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9ucy5wb3AoKTtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbnMuam9pbignLCcpO1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjay5jYWxsKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGR4ID0gc2hha2VzID8gLWR4IDogMDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBkZWZhdWx0R2xvd2VyU3R5bGVzID0ge1xuICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJ3llbGxvdycsXG4gICAgJ2JveC1zaGFkb3cnOiAnMCAwIDEwcHggcmVkJ1xufTtcblxuLyoqXG4gKiBUcmFuc2l0aW9uIHN0eWxlcyBvbiBlbGVtZW50IGZvciBhIG1vbWVudCBhbmQgcmV2ZXJ0IGFzIGlmIHRvIHNheSwgXCJXaG9hIS5cIlxuICogQHR5cGUge2VmZmVjdEZ1bmN0aW9ufVxuICogQG1lbWJlck9mIG1vZHVsZTplZmZlY3RzXG4gKi9cbmV4cG9ydHMuZ2xvd2VyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBjb250ZXh0ID0gdGhpcyxcbiAgICAgICAgZWwgPSBvcHRpb25zLmVsIHx8IGNvbnRleHQuZWwsXG4gICAgICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiB8fCAnMC4yNXMnLFxuICAgICAgICBzdHlsZXMgPSBvcHRpb25zLnN0eWxlcyB8fCBkZWZhdWx0R2xvd2VyU3R5bGVzLFxuICAgICAgICB2YWx1ZXMgPSBzdHlsZXMubGVuZ3RoLFxuICAgICAgICBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLFxuICAgICAgICBzdHlsZVdhcyA9IHt9LFxuICAgICAgICB0cmFuc2l0aW9uID0gY29tcHV0ZWRTdHlsZS50cmFuc2l0aW9uLFxuICAgICAgICB0cmFuc2l0aW9ucyA9IHRyYW5zaXRpb24uc3BsaXQoJywnKTtcblxuICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICBzdHlsZVdhc1tzdHlsZV0gPSB7XG4gICAgICAgICAgICBzdHlsZTogY29tcHV0ZWRTdHlsZVtzdHlsZV0sXG4gICAgICAgICAgICB1bmRvOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zaXRpb25zLnB1c2goc3R5bGUgKyAnICcgKyBkdXJhdGlvbik7XG4gICAgfSk7XG5cbiAgICBlbC5zdHlsZS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbnMuam9pbignLCcpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBnbG93ZXIpO1xuICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICBlbC5zdHlsZVtzdHlsZV0gPSBzdHlsZXNbc3R5bGVdO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZ2xvd2VyKGV2ZW50KSB7XG4gICAgICAgIHZhciB3YXMgPSBzdHlsZVdhc1tldmVudC5wcm9wZXJ0eU5hbWVdO1xuICAgICAgICBpZiAod2FzLnVuZG8pIHtcbiAgICAgICAgICAgIGVsLnN0eWxlW2V2ZW50LnByb3BlcnR5TmFtZV0gPSB3YXMuc3R5bGU7XG4gICAgICAgICAgICB3YXMudW5kbyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKCEtLXZhbHVlcykge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGdsb3dlcik7XG4gICAgICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjay5jYWxsKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIEBtb2R1bGUgbG9jYWxpemF0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4uL0Jhc2UnKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWZhdWx0TG9jYWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xvY2FsZT1kZWZhdWx0bG9jYWxlXVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBGb3JtYXR0ZXIgPSBCYXNlLmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZGVmYXVsdExvY2FsZSwgbG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGxvY2FsZTtcbiAgICAgICAgICAgIGxvY2FsZSA9IGRlZmF1bHRMb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcblxuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmludmFsaWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludmFsaWQgPSBvcHRpb25zLmludmFsaWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBlY3RhdGlvbiA9IG9wdGlvbnMuZXhwZWN0YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG4vLyBTYWZhcmkgaGFzIG5vIEludGwgaW1wbGVtZW50YXRpb25cbmlmICghd2luZG93LkludGwpIHtcbiAgICB3aW5kb3cuSW50bCA9IHtcbiAgICAgICAgTnVtYmVyRm9ybWF0OiBmdW5jdGlvbihsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBkaWdpdHMgPSAnMDEyMzQ1Njc4OSc7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdCA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IG4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy51c2VHcm91cGluZyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMudXNlR3JvdXBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRwID0gcy5pbmRleE9mKCcuJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRwID0gcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChkcCAtPSAzKSA+IDAgJiYgZGlnaXRzLmluZGV4T2Yoc1tkcCAtIDFdKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gcy5zdWJzdHIoMCwgZHApICsgJywnICsgcy5zdWJzdHIoZHApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgRGF0ZVRpbWVGb3JtYXQ6IGZ1bmN0aW9uKGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5mb3JtYXQgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IGRhdGUuZ2V0TW9udGgoKSArIDEgKyAnLScgKyBkYXRlLmdldERhdGUoKSArICctJyArIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG4vKipcbiAqIEBzdW1tYXJ5IENyZWF0ZSBhIG51bWJlciBsb2NhbGl6ZXIuXG4gKiBAaW1wbGVtZW50cyBsb2NhbGl6ZXJJbnRlcmZhY2VcbiAqIEBkZXNjIENyZWF0ZSBhbiBvYmplY3QgY29uZm9ybWluZyB0byB7QGxpbmsgbG9jYWxpemVySW50ZXJmYWNlfSBmb3IgbnVtYmVycywgdXNpbmcge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlckZvcm1hdHxJbnRsLk51bWJlckZvcm1hdH0uXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVmYXVsdExvY2FsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtsb2NhbGU9ZGVmYXVsdExvY2FsZV0gLSBQYXNzZWQgdG8gdGhlIHtAbGluayBJbnRsLk51bWJlckZvcm1hdHxodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXJGb3JtYXR9IGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIFBhc3NlZCB0byB0aGUgYEludGwuTnVtYmVyRm9ybWF0YCBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYWNjZXB0U3RhbmRhcmREaWdpdHM9ZmFsc2VdIC0gQWNjZXB0IHN0YW5kYXJkIGRpZ2l0cyBhbmQgZGVjaW1hbCBwb2ludCBpbnRlcmNoYW5nZWFibHkgd2l0aCBsb2NhbGl6ZWQgZGlnaXRzIGFuZCBkZWNpbWFsIHBvaW50LiAoVGhpcyBvcHRpb24gaXMgaW50ZXJwcmV0ZWQgaGVyZTsgaXQgaXMgbm90IHVzZWQgYnkgYEludGwuTnVtYmVyRm9ybWF0YC4pXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEZvcm1hdHRlclxuICogQHR1dG9yaWFsIGxvY2FsaXphdGlvblxuICovXG52YXIgTnVtYmVyRm9ybWF0dGVyID0gRm9ybWF0dGVyLmV4dGVuZCgnTnVtYmVyRm9ybWF0dGVyJywge1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGRlZmF1bHRMb2NhbGUsIGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBsb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB0aGlzLmZvcm1hdCA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCh0aGlzLmxvY2FsZSwgb3B0aW9ucykuZm9ybWF0O1xuXG4gICAgICAgIHZhciBtYXBwZXJPcHRpb25zID0geyB1c2VHcm91cGluZzogZmFsc2UgfSxcbiAgICAgICAgICAgIG1hcHBlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCh0aGlzLmxvY2FsZSwgbWFwcGVyT3B0aW9ucykuZm9ybWF0O1xuXG4gICAgICAgIHRoaXMuZGVtYXBwZXIgPSBkZW1hcC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBBIHN0cmluZyBjb250YWluaW5nIHRoZSB2YWxpZCBjaGFyYWN0ZXJzLlxuICAgICAgICAgKiBAZGVzYyBDb250YWlucyBhbGwgbG9jYWxpemVkIGRpZ2l0cyArIGxvY2FsaXplZCBkZWNpbWFsIHBvaW50LlxuICAgICAgICAgKiBJZiB3ZSdyZSBhY2NlcHRpbmcgc3RhbmRhcmQgZGlnaXRzLCB3aWxsIGFsc28gY29udGFpbiBhbGwgdGhlIHN0YW5kYXJkIGRpZ2l0cyArIHN0YW5kYXJkIGRlY2ltYWwgcG9pbnQgKGlmIGRpZmZlcmVudCB0aGFuIGxvY2FsaXplZCB2ZXJzaW9ucykuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBkZXNjIExvY2FsaXplZCBkaWdpdHMgYW5kIGRlY2ltYWwgcG9pbnQuIFdpbGwgYWxzbyBpbmNsdWRlIHN0YW5kYXJkaXplZCBkaWdpdHMgYW5kIGRlY2ltYWwgcG9pbnQgaWYgYG9wdGlvbnMuYWNjZXB0U3RhbmRhcmREaWdpdHNgIGlzIHRydXRoeS5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIGludGVybmFsIHVzZSBieSB0aGUge0BsaW5rIE51bWJlckZvcm1hdHRlciNwYXJzZXxwYXJzZX0gbWV0aG9kLlxuICAgICAgICAgKiBAbWVtYmVyT2YgTnVtYmVyRm9ybWF0dGVyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXAgPSBtYXBwZXIoMTAxMjM0NTY3ODkuNSkuc3Vic3RyKDEsIDExKTsgLy8gbG9jYWxpemVkICcwMTIzNDU2Nzg5LidcblxuICAgICAgICBpZiAob3B0aW9ucy5hY2NlcHRTdGFuZGFyZERpZ2l0cyAmJiB0aGlzLm1hcCAhPT0gJzAxMjM0NTY3ODkuJykge1xuICAgICAgICAgICAgdGhpcy5tYXAgKz0gJzAxMjM0NTY3ODkuJzsgIC8vIHN0YW5kYXJkICcwMTIzNDU2Nzg5LidcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAc3VtbWFyeSBBIHJlZ2V4IHRoYXQgdGVzdHMgYHRydWVgIG9uIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyLlxuICAgICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAZGVzYyBWYWxpZCBjaGFyYWN0ZXJzIGluY2x1ZGU6XG4gICAgICAgICAqXG4gICAgICAgICAqICogTG9jYWxpemVkIGRpZ2l0c1xuICAgICAgICAgKiAqIExvY2FsaXplZCBkZWNpbWFsIHBvaW50XG4gICAgICAgICAqICogU3RhbmRhcmQgZGlnaXRzICh3aGVuIGBvcHRpb25zLmFjY2VwdFN0YW5kYXJkRGlnaXRzYCBpcyB0cnV0aHkpXG4gICAgICAgICAqICogU3RhbmRhcmQgZGVjaW1hbCBwb2ludCAod2hlbiBgb3B0aW9ucy5hY2NlcHRTdGFuZGFyZERpZ2l0c2AgaXMgdHJ1dGh5KVxuICAgICAgICAgKiAqIENvc21ldGljIGNoYXJhY3RlcnMgYWRkZWQgYnkgZm9ybWF0dGVyIGFzIHBlciBgb3B0aW9uc2AgKGZvciBodW1hbi1mcmllbmRseSByZWFkYWJpbGl0eSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEFueSBjaGFyYWN0ZXJzIG91dHNpZGUgdGhpcyBzZXQgYXJlIGNvbnNpZGVyZWQgaW52YWxpZC5cbiAgICAgICAgICpcbiAgICAgICAgICogU2V0IGJ5IHRoZSBjb25zdHJ1Y3RvcjsgY29uc3VtZWQgYnkgdGhlIHtAbGluayBtb2R1bGU6bG9jYWxpemF0aW9ufk51bWJlckZvcm1hdHRlciNpbnZhbGlkfGludmFsaWR9IG1ldGhvZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGVzdGluZyBhIHN0cmluZyBhZ2FpbnN0IHRoaXMgcGF0dGVybiB5aWVsZHMgYHRydWVgIGlmIGF0IGxlYXN0IG9uZSBpbnZhbGlkIGNoYXJhY3RlciBvciBgZmFsc2VgIGlmIGFsbCBjaGFyYWN0ZXJzIGFyZSB2YWxpZC5cbiAgICAgICAgICogQG1lbWJlck9mIE51bWJlckZvcm1hdHRlci5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW52YWxpZHMgPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ1teJyArXG4gICAgICAgICAgICB0aGlzLmZvcm1hdCgxMTExMSkucmVwbGFjZSh0aGlzLm1hcFsxXSwgJycpICsgLy8gdGhvdXNhbmRzIHNlcGFyYXRvciBpZiBpbiB1c2VcbiAgICAgICAgICAgIHRoaXMubWFwICsgLy8gZGlnaXRzICsgZGVjaW1hbCBwb2ludFxuICAgICAgICAgICAgJ10nXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKiBAc3VtbWFyeSBUZXN0cyBmb3IgaW52YWxpZCBjaGFyYWN0ZXJzLlxuICAgICAqIEBkZXNjIFRlc3RzIGEgbG9jYWxpemVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG51bWJlciB0aGF0IGl0IGNvbnRhaW5zIGFueSBpbnZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBUaGUgbnVtYmVyIG1heSBiZSB1bmZvcm1hdHRlZCBvciBpdCBtYXkgYmUgZm9ybWF0dGVkIHdpdGggYW55IG9mIHRoZSBwZXJtaXR0ZWQgZm9ybWF0dGluZyBjaGFyYWN0ZXJzLCBhcyBpbXBsaWVkIGJ5IHRoZSBjb25zdHJ1Y3RvcidzIGBvcHRpb25zYCAocGFzc2VkIHRvIGBJbnRsLk51bWJlckZvcm1hdGApLiBBbnkgb3RoZXIgY2hhcmFjdGVycyBhcmUgY29uc2lkZXJlZCBpbnZhbGlkLlxuICAgICAqXG4gICAgICogSG93ZXZlciwgc3RhbmRhcmQgZGlnaXRzIGFuZCB0aGUgc3RhbmRhcmQgZGVjaW1hbCBwb2ludCBhcmUgY29uc2lkZXJlZCB2YWxpZCBpZiB0aGUgdmFsdWUgb2YgYG9wdGlvbnMuYWNjZXB0U3RhbmRhcmREaWdpdHNgIGFzIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3RvciB3YXMgdHJ1dGh5LiAoT2YgY291cnNlLCB0aGVzZSBhcmUgYWx3YXlzIHZhbGlkIGZvciBsb2NhbGVzIHRoYXQgdXNlIHRoZW0uKVxuICAgICAqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvOlxuICAgICAqIDEuIEZpbHRlciBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIG9uIGEgYG9ua2V5ZG93bmAgZXZlbnQ7IG9yXG4gICAgICogMi4gVGVzdCBhbiBlZGl0ZWQgc3RyaW5nIHByaW9yIHRvIGNhbGxpbmcgdGhlIHtAbGluayBtb2R1bGU6bG9jYWxpemF0aW9ufk51bWJlckZvcm1hdHRlciNwYXJzZXxwYXJzZX0uXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBjaGVjayBncmFtbWF0aWNhbCBzeW50YXg7IGl0IG9ubHkgY2hlY2tzIGZvciBpbnZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbnVtYmVyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW58c3RyaW5nfSBGYWxzeSBtZWFucyB2YWxpZCB3aGljaCBpbiB0aGlzIGNhc2UgbWVhbnMgY29udGFpbnMgb25seSB2YWxpZCBjaGFyYWN0ZXJzLlxuICAgICAqIEBtZW1iZXJPZiBOdW1iZXJGb3JtYXR0ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgaW52YWxpZDogZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludmFsaWRzLnRlc3QobnVtYmVyKTtcbiAgICB9LFxuXG4gICAgZXhwZWN0YXRpb246XG4gICAgICAgICdFeHBlY3RlZCBhIG51bWJlciB3aXRoIG9wdGlvbmFsIGNvbW1hcyAodGhvdXNhbmRzIGdyb3VwaW5nIHNlcGFyYXRvciksIG9wdGlvbmFsIGRlY2ltYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25hbCBmcmFjdGlvbmFsIHBhcnQuXFxuJyArXG4gICAgICAgICdDb21tYSBzZXBhcmF0b3JzIGFyZSBwYXJ0IG9mIHRoZSBmb3JtYXQgYW5kIHdpbGwgYWx3YXlzIGJlIGRpc3BsYXllZCBmb3IgdmFsdWVzID49IDEwMDAuXFxuJyArXG4gICAgICAgICdFZGl0ZWQgdmFsdWVzIGFyZSBhbHdheXMgc2F2ZWQgaW4gdGhlaXIgZW50aXJldHkgZXZlbiB0aG91Z2ggdGhlIGZvcm1hdHRlZCB2YWx1ZSBpcyByb3VuZGVkIHRvIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzLicsXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsOlxuICAgICAqICogQ29udmVydCBsb2NhbGl6ZWQgZGlnaXRzIGFuZCBkZWNpbWFsIHBvaW50IGNoYXJhY3RlcnMgdG8gc3RhbmRhcmQgZGlnaXRzIGFuZCBkZWNpbWFsIHBvaW50IGNoYXJhY3RlcnMuXG4gICAgICogKiBcIkNsZWFuXCIgdGhlIHN0cmluZyBieSBpZ25vcmluZyBhbGwgb3RoZXIgY2hhcmFjdGVycy5cbiAgICAgKiAqIENvZXJjZSB0aGUgc3RyaW5nIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0dGVkTG9jYWxpemVkTnVtYmVyIC0gTWF5IG9yIG1heSBub3QgYmUgZm9ybWF0dGVkLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBwcmltaXRpdmUuXG4gICAgICogQHRocm93cyB7c3RyaW5nfSBJbnZhbGlkIG51bWJlci5cbiAgICAgKiBAbWVtYmVyT2YgTnVtYmVyRm9ybWF0dGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHBhcnNlOiBmdW5jdGlvbihmb3JtYXR0ZWRMb2NhbGl6ZWROdW1iZXIpIHtcbiAgICAgICAgdmFyIG51bWJlciA9IE51bWJlcihcbiAgICAgICAgICAgIGZvcm1hdHRlZExvY2FsaXplZE51bWJlci5zcGxpdCgnJykubWFwKHRoaXMuZGVtYXBwZXIpLmpvaW4oJycpXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGlzTmFOKG51bWJlcikpIHtcbiAgICAgICAgICAgIHRocm93ICdJbnZhbGlkIE51bWJlcic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBkZW1hcChjKSB7XG4gICAgdmFyIGQgPSB0aGlzLm1hcC5pbmRleE9mKGMpICUgMTE7XG4gICAgcmV0dXJuIGQgPCAwID8gJycgOiBkIDwgMTAgPyBkIDogJy4nO1xufVxuXG4vKipcbiAqIEBpbXBsZW1lbnRzIGxvY2FsaXplckludGVyZmFjZVxuICogQHBhcmFtIHtzdHJpbmd9IGRlZmF1bHRMb2NhbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbG9jYWxlPWRlZmF1bHRsb2NhbGVdIC0gUGFzc2VkIHRvIHRoZSB7QGxpbmsgSW50bC5EYXRlRm9ybWF0fGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVGb3JtYXR9IGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIFBhc3NlZCB0byB0aGUgYEludGwuRGF0ZUZvcm1hdGAgY29uc3RydWN0b3IuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEZvcm1hdHRlclxuICovXG52YXIgRGF0ZUZvcm1hdHRlciA9IEZvcm1hdHRlci5leHRlbmQoJ0RhdGVGb3JtYXR0ZXInLCB7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZGVmYXVsdExvY2FsZSwgbG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGxvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8qKiBAc3VtbWFyeSBUcmFuc2Zvcm0gYSBkYXRlIG9iamVjdCBpbnRvIGh1bWFuLWZyaWVuZGx5IHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtYXQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmxvY2FsZSwgb3B0aW9ucykuZm9ybWF0O1xuXG4gICAgICAgIC8vIEdldCBkaWdpdHMgYmVjYXVzZSBtYXkgYmUgY2hpbmVzZSBvciBcInJlYWwgQXJhYmljXCIgbnVtZXJhbHMuXG4gICAgICAgIHZhciB0ZXN0T3B0aW9ucyA9IHsgdXNlR3JvdXBpbmc6IGZhbHNlLCBzdHlsZTogJ2RlY2ltYWwnIH0sXG4gICAgICAgICAgICBsb2NhbGl6ZU51bWJlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCh0aGlzLmxvY2FsZSwgdGVzdE9wdGlvbnMpLmZvcm1hdCxcbiAgICAgICAgICAgIGxvY2FsaXplZERpZ2l0cyA9IHRoaXMubG9jYWxpemVkRGlnaXRzID0gbG9jYWxpemVOdW1iZXIoMTAxMjM0NTY3ODkpLnN1YnN0cigxLCAxMCk7IC8vIGFsbCBsb2NhbGl6ZWQgZGlnaXRzIGluIG51bWVyaWNhbCBvcmRlclxuXG4gICAgICAgIHRoaXMuZGlnaXRGb3JtYXR0ZXIgPSBmb3JtYXREaWdpdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRpZ2l0UGFyc2VyID0gcGFyc2VEaWdpdC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIExvY2FsaXplIGEgdGVzdCBkYXRlIHdpdGggdGhlIGRlZmF1bHQgbnVtZXJpYyBwYXJ0cyB0byBmaW5kIG91dCB0aGUgcmVzdWx0aW5nIG9yZGVyIG9mIHRoZXNlIHBhcnRzLlxuICAgICAgICB2YXIgeXkgPSAxOTg3LFxuICAgICAgICAgICAgbW0gPSAxMixcbiAgICAgICAgICAgIGRkID0gMzAsXG4gICAgICAgICAgICBZWSA9IHRoaXMudHJhbnNmb3JtTnVtYmVyKHRoaXMuZGlnaXRGb3JtYXR0ZXIsIHl5KSxcbiAgICAgICAgICAgIE1NID0gdGhpcy50cmFuc2Zvcm1OdW1iZXIodGhpcy5kaWdpdEZvcm1hdHRlciwgbW0pLFxuICAgICAgICAgICAgREQgPSB0aGlzLnRyYW5zZm9ybU51bWJlcih0aGlzLmRpZ2l0Rm9ybWF0dGVyLCBkZCksXG4gICAgICAgICAgICB0ZXN0RGF0ZSA9IG5ldyBEYXRlKHl5LCBtbSAtIDEsIGRkKSxcbiAgICAgICAgICAgIGxvY2FsaXplRGF0ZSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxlKS5mb3JtYXQsXG4gICAgICAgICAgICBsb2NhbGl6ZWREYXRlID0gbG9jYWxpemVEYXRlKHRlc3REYXRlKSwgLy8gYWxsIGxvY2FsaXplZCBkaWdpdHMgKyBsb2NhbGl6ZWQgcHVuY3R1YXRpb25cbiAgICAgICAgICAgIG1pc3NpbmdEaWdpdHMgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQodGhpcy5sb2NhbGUpLmZvcm1hdCg0NTYpLFxuICAgICAgICAgICAgbG9jYWxpemVkTnVtYmVyUGF0dGVybiA9IHRoaXMubG9jYWxpemVkTnVtYmVyUGF0dGVybiA9IG5ldyBSZWdFeHAoJ1snICsgbG9jYWxpemVkRGlnaXRzICsgJ10rJywgJ2cnKSxcbiAgICAgICAgICAgIHBhcnRzID0gbG9jYWxpemVkRGF0ZS5tYXRjaChsb2NhbGl6ZWROdW1iZXJQYXR0ZXJuKTtcblxuICAgICAgICB0aGlzLnBhcnRzTWFwID0ge1xuICAgICAgICAgICAgeXk6IHBhcnRzLmluZGV4T2YoWVkpLFxuICAgICAgICAgICAgbW06IHBhcnRzLmluZGV4T2YoTU0pLFxuICAgICAgICAgICAgZGQ6IHBhcnRzLmluZGV4T2YoREQpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYWNjZXB0U3RhbmRhcmREaWdpdHMpIHtcbiAgICAgICAgICAgIG1pc3NpbmdEaWdpdHMgKz0gJzEyMzQ1Njc4OTAnO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBzdW1tYXJ5IEEgcmVnZXggdGhhdCB0ZXN0cyBgdHJ1ZWAgb24gZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIuXG4gICAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBkZXNjIFZhbGlkIGNoYXJhY3RlcnMgaW5jbHVkZTpcbiAgICAgICAgICpcbiAgICAgICAgICogKiBMb2NhbGl6ZWQgZGlnaXRzXG4gICAgICAgICAqICogU3RhbmRhcmQgZGlnaXRzICh3aGVuIGBvcHRpb25zLmFjY2VwdFN0YW5kYXJkRGlnaXRzYCBpcyB0cnV0aHkpXG4gICAgICAgICAqICogTG9jYWxpemVkIHB1bmN0dWF0aW9uIHRvIGRlbGltaXQgZGF0ZSBwYXJ0c1xuICAgICAgICAgKlxuICAgICAgICAgKiBBbnkgY2hhcmFjdGVycyBvdXRzaWRlIHRoaXMgc2V0IGFyZSBjb25zaWRlcmVkIGludmFsaWQuIE5vdGUgdGhhdCB0aGlzIG9ubHkgY3VycmVudGx5IGltcGxlbWVudGVkIHdoZW4gYWxsIHRocmVlIGRhdGUgcGFydHMgYXJlIG51bWVyaWNcbiAgICAgICAgICpcbiAgICAgICAgICogU2V0IGJ5IHRoZSBjb25zdHJ1Y3RvcjsgY29uc3VtZWQgYnkgdGhlIHtAbGluayBOdW1iZXJGb3JtYXR0ZXIjdmFsaWR8dmFsaWR9IG1ldGhvZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGVzdGluZyBhIHN0cmluZyBhZ2FpbnN0IHRoaXMgcGF0dGVybiB5aWVsZHMgYHRydWVgIGlmIGF0IGxlYXN0IG9uZSBpbnZhbGlkIGNoYXJhY3RlciBvciBgZmFsc2VgIGlmIGFsbCBjaGFyYWN0ZXJzIGFyZSB2YWxpZC5cbiAgICAgICAgICogQG1lbWJlck9mIERhdGVGb3JtYXR0ZXIucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmludmFsaWRzID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdbXicgK1xuICAgICAgICAgICAgbG9jYWxpemVkRGF0ZS5yZXBsYWNlKC8tL2csICdcXFxcLScpICtcbiAgICAgICAgICAgIG1pc3NpbmdEaWdpdHMgK1xuICAgICAgICAgICAgJ10nXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKiBAc3VtbWFyeSBUZXN0cyBmb3IgaW52YWxpZCBjaGFyYWN0ZXJzLlxuICAgICAqIEBkZXNjIFRlc3RzIGEgbG9jYWxpemVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG51bWJlciB0aGF0IGl0IGNvbnRhaW5zIGFueSBpbnZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBUaGUgZGF0ZSBpcyBhc3N1bWVkIHRvIGNvbnRhaW4gbG9jYWxpemVkIGRpZ2l0cyBhbmQgcHVuY3R1YXRpb24gYXMgd291bGQgYmUgcmV0dXJuZWQgYnkgYEludGwuRGF0ZUZvcm1hdGAgd2l0aCB0aGUgZ2l2ZW4gYGxvY2FsZWAgYW5kIGBvcHRpb25zYC4gQW55IG90aGVyIGNoYXJhY3RlcnMgYXJlIGNvbnNpZGVyZWQgaW52YWxpZC5cbiAgICAgKlxuICAgICAqIEhvd2V2ZXIsIHN0YW5kYXJkIGRpZ2l0cyBhbmQgdGhlIHN0YW5kYXJkIGRlY2ltYWwgcG9pbnQgYXJlIGFsc28gY29uc2lkZXJlZCB2YWxpZCBpZiB0aGUgdmFsdWUgb2YgYG9wdGlvbnMuYWNjZXB0U3RhbmRhcmREaWdpdHNgIGFzIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3RvciB3YXMgdHJ1dGh5LiAoT2YgY291cnNlLCB0aGVzZSBhcmUgYWx3YXlzIHZhbGlkIGZvciBsb2NhbGVzIHRoYXQgdXNlIHRoZW0uKVxuICAgICAqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvOlxuICAgICAqIDEuIEZpbHRlciBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIG9uIGEgYG9ua2V5ZG93bmAgZXZlbnQ7IG9yXG4gICAgICogMi4gVGVzdCBhbiBlZGl0ZWQgc3RyaW5nIHByaW9yIHRvIGNhbGxpbmcgdGhlIHtAbGluayBtb2R1bGU6bG9jYWxpemF0aW9ufkRhdGVGb3JtYXR0ZXIjcGFyc2V8cGFyc2V9LlxuICAgICAqXG4gICAgICogTk9URTogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBkYXRlIGZvcm1hdHMgdXNpbmcgYWxsIG51bWVyaWNzICh3aGljaCBpcyB0aGUgZGVmYXVsdCBmb3IgYEludGwuRGF0ZUZvcm1hdGApLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBtZXRob2QgZG9lcyBub3QgY2hlY2sgZ3JhbW1hdGljYWwgc3ludGF4OyBpdCBvbmx5IGNoZWNrcyBmb3IgaW52YWxpZCBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG51bWJlclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBDb250YWlucyBvbmx5IHZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICogQG1lbWJlck9mIERhdGVGb3JtYXR0ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgaW52YWxpZDogZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludmFsaWRzLnRlc3QobnVtYmVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbDpcbiAgICAgKiAqIENvbnZlcnQgbG9jYWxpemVkIGRhdGUgdG8gRGF0ZSBvYmplY3QuXG4gICAgICogKiBcIkNsZWFuXCIgdGhlIHN0cmluZyBieSBpZ25vcmluZyBhbGwgb3RoZXIgY2hhcmFjdGVycy5cbiAgICAgKiAqIENvZXJjZSB0aGUgc3RyaW5nIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxpemVkRGF0ZVxuICAgICAqIEByZXR1cm5zIHtEYXRlfVxuICAgICAqIEB0aHJvd3Mge3N0cmluZ30gSW52YWxpZCBkYXRlLlxuICAgICAqIEBtZW1iZXJPZiBEYXRlRm9ybWF0dGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHBhcnNlOiBmdW5jdGlvbihsb2NhbGl6ZWREYXRlKSB7XG4gICAgICAgIHZhciBkYXRlLFxuICAgICAgICAgICAgcGFydHMgPSBsb2NhbGl6ZWREYXRlLm1hdGNoKHRoaXMubG9jYWxpemVkTnVtYmVyUGF0dGVybik7XG5cbiAgICAgICAgaWYgKHBhcnRzICYmIHBhcnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLnRyYW5zZm9ybU51bWJlcih0aGlzLmRpZ2l0UGFyc2VyLCBwYXJ0c1t0aGlzLnBhcnRzTWFwLnl5XSksXG4gICAgICAgICAgICAgICAgbSA9IHRoaXMudHJhbnNmb3JtTnVtYmVyKHRoaXMuZGlnaXRQYXJzZXIsIHBhcnRzW3RoaXMucGFydHNNYXAubW1dKSAtIDEsXG4gICAgICAgICAgICAgICAgZCA9IHRoaXMudHJhbnNmb3JtTnVtYmVyKHRoaXMuZGlnaXRQYXJzZXIsIHBhcnRzW3RoaXMucGFydHNNYXAuZGRdKTtcblxuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ0ludmFsaWQgRGF0ZSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIGEgbnVtYmVyIHRvIG9yIGZyb20gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gd2l0aCBsb2NhbGl6ZWQgZGlnaXRzLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGRpZ2l0VHJhbnNmb3JtZXIgLSBBIGZ1bmN0aW9uIGJvdW5kIHRvIGB0aGlzYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXJPZiBEYXRlRm9ybWF0dGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHRyYW5zZm9ybU51bWJlcjogZnVuY3Rpb24oZGlnaXRUcmFuc2Zvcm1lciwgbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBudW1iZXIudG9TdHJpbmcoKS5zcGxpdCgnJykubWFwKGRpZ2l0VHJhbnNmb3JtZXIpLmpvaW4oJycpO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBmb3JtYXREaWdpdChkKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxpemVkRGlnaXRzW2RdO1xufVxuXG5mdW5jdGlvbiBwYXJzZURpZ2l0KGMpIHtcbiAgICB2YXIgZCA9IHRoaXMubG9jYWxpemVkRGlnaXRzLmluZGV4T2YoYyk7XG4gICAgaWYgKGQgPCAwKSB7IGQgPSAnJzsgfVxuICAgIHJldHVybiBkO1xufVxuXG4vKipcbiAqIEFsbCBtZW1iZXJzIGFyZSBsb2NhbGl6ZXJzIChjb25mb3JtIHRvIHtAbGluayBsb2NhbGl6ZXJJbnRlcmZhY2V9KSB3aXRoIGV4Y2VwdGlvbiBvZiBgZ2V0YCwgYHNldGAsIGFuZCBsb2NhbGl6ZXIgY29uc3RydWN0b3JzIHdoaWNoIGFyZSBuYW1lZCAoYnkgY29udmVudGlvbikgZW5kaW5nIGluIFwiRm9ybW1hdHRlclwiLlxuICpcbiAqIFRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgaXMgZnJlZSB0byBhZGQgbG9jYWxpemVycyBhbmQgbG9jYWxpemVyIGZhY3RvcnkgbWV0aG9kcy4gU2VlIHRoZSB7QGxpbmsgTG9jYWxpemF0aW9uI2NvbnN0cnVjdHxjb25zdHJ1Y3R9IGNvbnZlbmllbmNlIG1ldGhvZCB3aGljaCBtYXkgYmUgaGVscGZ1bCBpbiB0aGlzIHJlZ2FyZC5cbiAqIEBwYXJhbSBsb2NhbGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBbbnVtYmVyT3B0aW9uc11cbiAqIEBwYXJhbSB7b2JqZWN0fSBbZGF0ZU9wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTG9jYWxpemF0aW9uKGxvY2FsZSwgbnVtYmVyT3B0aW9ucywgZGF0ZU9wdGlvbnMpIHtcbiAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIG51bWJlclxuICAgICAqIEBzZWUgVGhlIHtAbGluayBOdW1iZXJGb3JtYXR0ZXJ8TnVtYmVyRm9ybWF0dGVyfSBjbGFzc1xuICAgICAqIEBtZW1iZXJPZiBMb2NhbGl6YXRpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgdGhpcy5pbnQgPSB0aGlzLmZsb2F0ID0gdGhpcy5jb25zdHJ1Y3QoJ251bWJlcicsIE51bWJlckZvcm1hdHRlciwgbnVtYmVyT3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIFRoZSB7QGxpbmsgRGF0ZUZvcm1hdHRlcnxEYXRlRm9ybWF0dGVyfSBjbGFzc1xuICAgICAqIEBtZW1iZXJPZiBMb2NhbGl6YXRpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgdGhpcy5jb25zdHJ1Y3QoJ2RhdGUnLCBEYXRlRm9ybWF0dGVyLCBkYXRlT3B0aW9ucyk7XG59XG5cbkxvY2FsaXphdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IExvY2FsaXphdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IsXG4gICAgJCRDTEFTU19OQU1FOiAnTG9jYWxpemF0aW9uJyxcblxuICAgIC8qKiBAc3VtbWFyeSBDcmVhdGVzIGEgbG9jYWxpemVyIGZyb20gYSBsb2NhbGl6ZXIgZmFjdG9yeSBvYmplY3QgdXNpbmcgdGhlIGRlZmF1bHQgbG9jYWxlLlxuICAgICAqIEBkZXNjIFBlcmZvcm1zIHRoZSBmb2xsb3dpbmcgYWN0aW9uczpcbiAgICAgKiAxLiBCaW5kcyBgQ29uc3RydWN0b3JgIHRvIGBsb2NhbGVgLlxuICAgICAqIDIuIEFkZHMgdGhlIG5ld2x5IGJvdW5kIGNvbnN0cnVjdG9yIHRvIHRoaXMgb2JqZWN0IChmb3IgZnV0dXJlIHJlZmVyZW5jZSkgd2l0aCB0aGUga2V5IFwiTmFtZUZvcm1hdHRlclwiICh3aGVyZSBcIk5hbWVcIiBpcyB0aGUgbG9jYWxpemVyIG5hbWUsIGFsbCBsb3dlciBjYXNlIGJ1dCB3aXRoIGFuIGluaXRpYWwgY2FwaXRhbCkuXG4gICAgICogMy4gVXNlcyB0aGUgbmV3bHkgYm91bmQgY29uc3RydWN0b3IgdG8gY3JlYXRlIGEgbmV3IGxvY2FsaXplZCBsb2NhbGl6ZXIgd2l0aCB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAgICAgKiA0LiBBZGRzIG5ldyBsb2NhbGl6ZXIgdG8gdGhpcyBvYmplY3QgdmlhIHtAbGluayBMb2NhbGl6YXRpb24jYWRkfGFkZH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxpemVyTmFtZVxuICAgICAqIEBwYXJhbSB7Q29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge29iamVjdH0ge2ZhY3RvcnlPcHRpb25zfVxuICAgICAqIEByZXR1cm5zIHtsb2NhbGl6ZXJJbnRlcmZhY2V9IFRoZSBuZXcgbG9jYWxpemVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdDogZnVuY3Rpb24obG9jYWxpemVyTmFtZSwgQ29uc3RydWN0b3IsIGZhY3RvcnlPcHRpb25zKSB7XG4gICAgICAgIHZhciBjb25zdHJ1Y3Rvck5hbWUgPSBsb2NhbGl6ZXJOYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBsb2NhbGl6ZXJOYW1lLnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpICsgJ0Zvcm1hdHRlcicsXG4gICAgICAgICAgICBCb3VuZENvbnN0cnVjdG9yID0gQ29uc3RydWN0b3IuYmluZChudWxsLCB0aGlzLmxvY2FsZSksXG4gICAgICAgICAgICBsb2NhbGl6ZXIgPSBuZXcgQm91bmRDb25zdHJ1Y3RvcihmYWN0b3J5T3B0aW9ucyk7XG5cbiAgICAgICAgdGhpc1tjb25zdHJ1Y3Rvck5hbWVdID0gQm91bmRDb25zdHJ1Y3RvcjtcblxuICAgICAgICByZXR1cm4gdGhpcy5hZGQobG9jYWxpemVyTmFtZSwgbG9jYWxpemVyKTtcbiAgICB9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IFJlZ2lzdGVyIGEgbG9jYWxpemVyLlxuICAgICAqIEBkZXNjIENoZWNrcyB0aGUgcHJvdmlkZWQgbG9jYWxpemVyIHRoYXQgaXQgY29uZm9ybXMgdG8ge0BsaW5rIGxvY2FsaXplckludGVyZmFjZX1cbiAgICAgKiBhbmQgYWRkcyBpdCB0byB0aGUgb2JqZWN0IHVzaW5nIGxvY2FsaXplck5hbWUgYWxsIGxvd2VyIGNhc2UgYXMgdGhlIGtleS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7bG9jYWxpemVySW50ZXJmYWNlfSBsb2NhbGl6ZXJcbiAgICAgKiBAbWVtYmVyT2YgTG9jYWxpemF0aW9uLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtsb2NhbGl6ZXJJbnRlcmZhY2V9IFRoZSBwcm92aWRlZCBsb2NhbGl6ZXIuXG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbihuYW1lLCBsb2NhbGl6ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgbG9jYWxpemVyID0gbmFtZTtcbiAgICAgICAgICAgIG5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgbG9jYWxpemVyICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGxvY2FsaXplci5mb3JtYXQgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIHR5cGVvZiBsb2NhbGl6ZXIucGFyc2UgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIGxvY2FsaXplci5pbnZhbGlkICYmIHR5cGVvZiBsb2NhbGl6ZXIuaW52YWxpZCAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgbG9jYWxpemVyLmV4cGVjdGF0aW9uICYmIHR5cGVvZiBsb2NhbGl6ZXIuZXhwZWN0YXRpb24gIT09ICdzdHJpbmcnXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIGxvY2FsaXplciBvYmplY3QgdG8gY29uZm9ybSB0byBpbnRlcmZhY2UuJztcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWUgPSBuYW1lIHx8IGxvY2FsaXplci5uYW1lO1xuICAgICAgICBuYW1lID0gbmFtZSAmJiBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRoaXNbbmFtZV0gPSBsb2NhbGl6ZXI7XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsaXplcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxpemVyTmFtZVxuICAgICAqIEByZXR1cm5zIHtsb2NhbGl6ZXJJbnRlcmZhY2V9XG4gICAgICogQG1lbWJlck9mIExvY2FsaXphdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbbmFtZSAmJiBuYW1lLnRvTG93ZXJDYXNlKCldIHx8IHRoaXMuc3RyaW5nO1xuICAgIH0sXG5cbiAgICAvLy8gIC8vLyAgLy8vICAvLy8gIC8vLyAgICBMT0NBTElaRVJTICAgIC8vLyAgLy8vICAvLy8gIC8vLyAgLy8vXG5cbiAgICAvLyBTcGVjaWFsIGxvY2FsaXplciBmb3IgdXNlIGJ5IENocm9tZSdzIGRhdGUgaW5wdXQgY29udHJvbC5cbiAgICBjaHJvbWVEYXRlOiB7XG4gICAgICAgIGZvcm1hdDogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgICAgaWYgKGRhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB5eSA9IGRhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgbSA9IGRhdGUuZ2V0TW9udGgoKSArIDEsIG1tID0gbSA8IDEwID8gJzAnICsgbSA6IG0sXG4gICAgICAgICAgICAgICAgICAgIGQgPSBkYXRlLmdldERhdGUoKSwgZGQgPSBkIDwgMTAgPyAnMCcgKyBkIDogZDtcblxuICAgICAgICAgICAgICAgIGRhdGUgPSB5eSArICctJyArIG1tICsgJy0nICsgZGQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHZhciBkYXRlLFxuICAgICAgICAgICAgICAgIHBhcnRzID0gc3RyLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBpZiAocGFydHMgJiYgcGFydHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHBhcnRzWzBdLCBwYXJ0c1sxXSAtIDEsIHBhcnRzWzJdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBudWxsOiB7XG4gICAgICAgIGZvcm1hdDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzdHJpbmc6IHtcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICsgJyc7XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIgKyAnJztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTG9jYWxpemF0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4uL0Jhc2UnKTtcblxuLyoqXG4gKiBAY2xhc3NcbiAqL1xudmFyIFJlZ2lzdHJ5ID0gQmFzZS5leHRlbmQoJ1JlZ2lzdHJ5Jywge1xuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJlZ2lzdGVyIGFuIGl0ZW0gYW5kIHJldHVybiBpdC5cbiAgICAgKiBAZGVzYyBBZGRzIGFuIGl0ZW0gdG8gdGhlIHJlZ2lzdHJ5IHVzaW5nIHRoZSBwcm92aWRlZCBuYW1lIChvciB0aGUgY2xhc3MgbmFtZSksIGNvbnZlcnRlZCB0byBhbGwgbG93ZXIgY2FzZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIC0gQ2FzZS1pbnNlbnNpdGl2ZSBpdGVtIGtleS4gSWYgbm90IGdpdmVuLCBmYWxsc2JhY2sgdG8gYGl0ZW0ucHJvdG90eXBlLiQkQ0xBU1NfTkFNRWAgb3IgYGl0ZW0ucHJvdG90eXBlLm5hbWVgIG9yIGBpdGVtLm5hbWVgLlxuICAgICAqIEBwYXJhbSBbaXRlbV0gLSBJZiB1bnJlZ2lzdGVyZWQgb3Igb21pdHRlZCwgbm90aGluZyBpcyBhZGRlZCBhbmQgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiA+IE5vdGU6IGAkJENMQVNTX05BTUVgIGlzIG5vcm1hbGx5IHNldCBieSBwcm92aWRpbmcgYSBzdHJpbmcgYXMgdGhlIChvcHRpb25hbCkgZmlyc3QgcGFyYW1ldGVyIChgYWxpYXNgKSBpbiB5b3VyIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9leHRlbmQtbWV8ZXh0ZW5kfSBjYWxsLlxuICAgICAqXG4gICAgICogQHJldHVybnMgTmV3bHkgcmVnaXN0ZXJlZCBpdGVtIG9yIGB1bmRlZmluZWRgIGlmIHVucmVnaXN0ZXJlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBSZWdpc3RyeSNcbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKG5hbWUsIGl0ZW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpdGVtID0gbmFtZTtcbiAgICAgICAgICAgIG5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWUgPSBuYW1lIHx8IGl0ZW0uZ2V0Q2xhc3NOYW1lICYmIGl0ZW0uZ2V0Q2xhc3NOYW1lKCk7XG5cbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgdGhpcy5IeXBlcmdyaWRFcnJvcignQ2Fubm90IHJlZ2lzdGVyIGEgXCInICsgdGhpcy5mcmllbmRseU5hbWUoKSArICdcIiB3aXRob3V0IGEgbmFtZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAodGhpc1tuYW1lXSA9IGl0ZW0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZWdpc3RlciBhIHN5bm9ueW0gZm9yIGFuIGV4aXN0aW5nIGl0ZW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN5bm9ueW1OYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4aXN0aW5nTmFtZVxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbnxDb25zdHJ1Y3Rvcn0gVGhlIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBpdGVtIHRoaXMgbmV3IHN5bm9ueW0gcG9pbnRzIHRvLlxuICAgICAqIEBtZW1iZXJPZiBSZWdpc3RyeSNcbiAgICAgKi9cbiAgICBhZGRTeW5vbnltOiBmdW5jdGlvbihzeW5vbnltTmFtZSwgZXhpc3RpbmdOYW1lKSB7XG4gICAgICAgIHJldHVybiAodGhpc1tzeW5vbnltTmFtZV0gPSB0aGlzLmdldChleGlzdGluZ05hbWUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSByZWdpc3RlcmVkIGl0ZW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXVxuICAgICAqIEByZXR1cm5zIHsqfHVuZGVmaW5lZH0gQSByZWdpc3RlcmVkIGl0ZW0gb3IgYHVuZGVmaW5lZGAgaWYgdW5yZWdpc3RlcmVkLlxuICAgICAqIEBtZW1iZXJPZiBSZWdpc3RyeSNcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpc1tuYW1lXTsgLy8gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGRvIG5vdCBjb252ZXJ0IHRvIGxvd2VyIGNhc2VcblxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgdmFyIGxvd2VyTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTsgLy8gbmFtZSBtYXkgZGlmZmVyIGluIGNhc2Ugb25seVxuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IFtdLCByID0gdGhpczsgT2JqZWN0LmdldFByb3RvdHlwZU9mKHIpIGluc3RhbmNlb2YgUmVnaXN0cnk7IHIgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocikpIHtcbiAgICAgICAgICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoT2JqZWN0LmtleXMocikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nTmFtZSA9IGtleXMuZmluZChmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGxvd2VyTmFtZSA9PT0ga2V5LnRvTG93ZXJDYXNlKCk7IH0pO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nTmFtZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXNbZXhpc3RpbmdOYW1lXTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFN5bm9ueW0obmFtZSwgZXhpc3RpbmdOYW1lKTsgLy8gcmVnaXN0ZXIgZm91bmQgbmFtZSBhcyBhIHN5bm9ueW0gZm9yIGZhc3RlciBhY2Nlc3MgbmV4dCB0aW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHRoaXMuSHlwZXJncmlkRXJyb3IoJ0V4cGVjdGVkIFwiJyArIG5hbWUgKyAnXCIgdG8gYmUgYSByZWdpc3RlcmVkICcgKyB0aGlzLmZyaWVuZGx5TmFtZSgpICsgJy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGZyaWVuZGx5TmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLkJhc2VDbGFzcykge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLkJhc2VDbGFzcy5nZXRDbGFzc05hbWUoKTtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lICYmIG5hbWVcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvKFtBLVpdKS9nLCAnICQxJylcbiAgICAgICAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWUgfHwgJ1t1bm5hbWVkIGNsYXNzXSc7XG4gICAgfVxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWdpc3RyeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgUmFuZ2VTZWxlY3Rpb25Nb2RlbCA9IHJlcXVpcmUoJ3NwYXJzZS1ib29sZWFuLWFycmF5Jyk7XG5cbi8qKlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGRlc2MgV2UgcmVwcmVzZW50IHNlbGVjdGlvbnMgYXMgYSBsaXN0IG9mIHJlY3RhbmdsZXMgYmVjYXVzZSBsYXJnZSBhcmVhcyBjYW4gYmUgcmVwcmVzZW50ZWQgYW5kIHRlc3RlZCBhZ2FpbnN0IHF1aWNrbHkgd2l0aCBhIG1pbmltYWwgYW1vdW50IG9mIG1lbW9yeSB1c2FnZS4gQWxzbyB3ZSBuZWVkIHRvIG1haW50YWluIHRoZSBzZWxlY3Rpb24gcmVjdGFuZ2xlcyBmbGF0dGVuZWQgY291bnRlciBwYXJ0cyBzbyB3ZSBjYW4gdGVzdCBmb3Igc2luZ2xlIGRpbWVuc2lvbiBjb250YWlucy4gVGhpcyBpcyBob3cgd2Uga25vdyB0byBoaWdobGlnaHQgdGhlIGZpeGVkIHJlZ2lvbnMgb24gdGhlIGVkZ2VzIG9mIHRoZSBncmlkLlxuICovXG5cbmZ1bmN0aW9uIFNlbGVjdGlvbk1vZGVsKGdyaWQpIHtcbiAgICB0aGlzLmdyaWQgPSBncmlkO1xuICAgIHRoaXMucmVzZXQoKTtcbn1cblxuU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5jb25zdHJ1Y3RvcixcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBhbGxSb3dzU2VsZWN0ZWQ6IGZhbHNlLFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgc2VsZWN0aW9uc1xuICAgICAgICAgKiBAdHlwZSB7UmVjdGFuZ2xlW119XG4gICAgICAgICAqIEBzdW1tYXJ5IFRoZSBzZWxlY3Rpb24gcmVjdGFuZ2xlcy5cbiAgICAgICAgICogQGRlc2MgQ3JlYXRlZCBhcyBhbiBlbXB0eSBhcnJheSB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGluayBTZWxlY3Rpb25Nb2RlbHxjb25zdHJ1Y3Rvcn0uXG4gICAgICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0aW9ucyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBmbGF0dGVuZWRYXG4gICAgICAgICAqIEB0eXBlIHtSZWN0YW5nbGVbXX1cbiAgICAgICAgICogQHN1bW1hcnkgVGhlIHNlbGVjdGlvbiByZWN0YW5nbGVzIGZsYXR0ZW5lZCBpbiB0aGUgaG9yaXpvbnRhbCBkaXJlY3Rpb24gKG5vIHdpZHRoKS5cbiAgICAgICAgICogQGRlc2MgQ3JlYXRlZCBhcyBhbiBlbXB0eSBhcnJheSB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGluayBTZWxlY3Rpb25Nb2RlbHxjb25zdHJ1Y3Rvcn0uXG4gICAgICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmxhdHRlbmVkWCA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBmbGF0dGVuZWRZXG4gICAgICAgICAqIEB0eXBlIHtSZWN0YW5nbGVbXX1cbiAgICAgICAgICogQHN1bW1hcnkgVGhlIHNlbGVjdGlvbiByZWN0YW5nbGVzIGZsYXR0ZW5lZCBpbiB0aGUgdmVydGljYWwgZGlyZWN0aW9uIChubyBoZWlnaHQpLlxuICAgICAgICAgKiBAZGVzYyBDcmVhdGVkIGFzIGFuIGVtcHR5IGFycmF5IHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rIFNlbGVjdGlvbk1vZGVsfGNvbnN0cnVjdG9yfS5cbiAgICAgICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbGF0dGVuZWRZID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIHJvd1NlbGVjdGlvbk1vZGVsXG4gICAgICAgICAqIEB0eXBlIHtSYW5nZVNlbGVjdGlvbk1vZGVsfVxuICAgICAgICAgKiBAc3VtbWFyeSBUaGUgc2VsZWN0aW9uIHJlY3RhbmdsZXMuXG4gICAgICAgICAqIEBkZXNjIENyZWF0ZWQgYXMgYSBuZXcgUmFuZ2VTZWxlY3Rpb25Nb2RlbCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGluayBTZWxlY3Rpb25Nb2RlbHxjb25zdHJ1Y3Rvcn0uXG4gICAgICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucm93U2VsZWN0aW9uTW9kZWwgPSBuZXcgUmFuZ2VTZWxlY3Rpb25Nb2RlbCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBjb2x1bW5TZWxlY3Rpb25Nb2RlbFxuICAgICAgICAgKiBAdHlwZSB7UmFuZ2VTZWxlY3Rpb25Nb2RlbH1cbiAgICAgICAgICogQHN1bW1hcnkgVGhlIHNlbGVjdGlvbiByZWN0YW5nbGVzLlxuICAgICAgICAgKiBAZGVzYyBDcmVhdGVkIGFzIGEgbmV3IFJhbmdlU2VsZWN0aW9uTW9kZWwgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmsgU2VsZWN0aW9uTW9kZWx8Y29uc3RydWN0b3J9LlxuICAgICAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsID0gbmV3IFJhbmdlU2VsZWN0aW9uTW9kZWwoKTtcblxuICAgICAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldExhc3RTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VscyA9IHRoaXMuc2VsZWN0aW9ucztcbiAgICAgICAgdmFyIHNlbCA9IHNlbHNbc2Vscy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHNlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldExhc3RTZWxlY3Rpb25UeXBlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdFNlbGVjdGlvblR5cGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB0eXBlXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldExhc3RTZWxlY3Rpb25UeXBlOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvblR5cGUgPSB0eXBlO1xuICAgIH0sXG5cbiAgICBjaGVja0NlbGxUb3A6IGZ1bmN0aW9uKHgsIHkxKSB7XG4gICAgICAgIGNvbnN0IGRtID0gdGhpcy5ncmlkLmJlaGF2aW9yLmRhdGFNb2RlbDtcbiAgICAgICAgaWYgKGRtLmlzUmVuZGVyU2tpcE5lZWRlZCh4LCB5MSkgJiYgZG0uZ2V0Um93c3Bhbih4LCB5MSAtIDEpID4gMCkgeyAvLyBjaGVjayBpZiBleHBhbmQgYXZhaWxhYmxlXG4gICAgICAgICAgICBsZXQgeU9mZnNldCA9IHkxO1xuICAgICAgICAgICAgd2hpbGUgKGRtLmlzUmVuZGVyU2tpcE5lZWRlZCh4LCB5T2Zmc2V0KSAmJiB5T2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgICAgIC0teU9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHkxID0geU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geTE7XG4gICAgfSxcblxuICAgIGNoZWNrQ2VsbEJvdHRvbTogZnVuY3Rpb24oeCwgeTIpIHtcbiAgICAgICAgbGV0IHNwYW4gPSB0aGlzLmdyaWQuYmVoYXZpb3IuZGF0YU1vZGVsLmdldFJvd3NwYW4oeCwgeTIpO1xuICAgICAgICBpZiAoc3BhbiA+IDApIHtcbiAgICAgICAgICAgIHkyICs9IHNwYW47IC8vIGp1c3QgYWRkIHJvd3NwYW4gaWYgaXQgYXZhaWxhYmxlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHkyO1xuICAgIH0sXG5cbiAgICBjaGVja0NlbGxMZWZ0OiBmdW5jdGlvbih4MSwgeSkge1xuICAgICAgICBjb25zdCBkbSA9IHRoaXMuZ3JpZC5iZWhhdmlvci5kYXRhTW9kZWw7XG4gICAgICAgIGlmIChkbS5pc1JlbmRlclNraXBOZWVkZWQoeDEsIHkpICYmIGRtLmdldENvbHNwYW4oeDEgLSAxLCB5KSA+IDApIHsgLy8gY2hlY2sgaWYgZXhwYW5kIGF2YWlsYWJsZVxuICAgICAgICAgICAgbGV0IHhPZmZzZXQgPSB4MTtcbiAgICAgICAgICAgIHdoaWxlIChkbS5pc1JlbmRlclNraXBOZWVkZWQoeE9mZnNldCwgeSkgJiYgeE9mZnNldCA+IDApIHtcbiAgICAgICAgICAgICAgICAtLXhPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4MSA9IHhPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHgxO1xuICAgIH0sXG5cbiAgICBjaGVja0NlbGxSaWdodDogZnVuY3Rpb24oeDIsIHkpIHtcbiAgICAgICAgbGV0IHNwYW4gPSB0aGlzLmdyaWQuYmVoYXZpb3IuZGF0YU1vZGVsLmdldENvbHNwYW4oeDIsIHkpO1xuICAgICAgICBpZiAoc3BhbiA+IDApIHtcbiAgICAgICAgICAgIHgyICs9IHNwYW47IC8vIGp1c3QgYWRkIGNvbHNwYW4gaWYgaXQgYXZhaWxhYmxlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHgyO1xuICAgIH0sXG5cbiAgICBjaGVja1NlbGVjdGlvbkNvcm5lcnM6IGZ1bmN0aW9uKG94LCBveSwgZXgsIGV5KSB7XG4gICAgICAgIGxldCB4MSA9IG94LCB4MiA9IG94ICsgZXgsIHN3YXBYID0geDEgPiB4MjtcbiAgICAgICAgbGV0IHkxID0gb3ksIHkyID0gb3kgKyBleSwgc3dhcFkgPSB5MSA+IHkyO1xuXG4gICAgICAgIGlmIChzd2FwWCkge1xuICAgICAgICAgICAgeDIgPSBbeDEsIHgxID0geDJdWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzd2FwWSkge1xuICAgICAgICAgICAgeTIgPSBbeTEsIHkxID0geTJdWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgdG9wIGNlbGxzXG4gICAgICAgIGZvciAobGV0IHggPSB4MTsgeCA8PSB4MjsgKyt4KSB7XG4gICAgICAgICAgICB5MSA9IHRoaXMuY2hlY2tDZWxsVG9wKHgsIHkxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGJvdHRvbSBjZWxsc1xuICAgICAgICBmb3IgKGxldCB4ID0geDE7IHggPD0geDI7ICsreCkge1xuICAgICAgICAgICAgeTIgPSB0aGlzLmNoZWNrQ2VsbEJvdHRvbSh4LCB5Mik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBsZWZ0IGNlbGxzXG4gICAgICAgIGZvciAobGV0IHkgPSB5MTsgeSA8PSB5MjsgKyt5KSB7XG4gICAgICAgICAgICB4MSA9IHRoaXMuY2hlY2tDZWxsTGVmdCh4MSwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayByaWdodCBjZWxsc1xuICAgICAgICBmb3IgKGxldCB5ID0geTE7IHkgPD0geTI7ICsreSkge1xuICAgICAgICAgICAgeDIgPSB0aGlzLmNoZWNrQ2VsbFJpZ2h0KHgyLCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzd2FwWCkge1xuICAgICAgICAgICAgeDIgPSBbeDEsIHgxID0geDJdWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzd2FwWSkge1xuICAgICAgICAgICAgeTIgPSBbeTEsIHkxID0geTJdWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG94ICE9PSB4MSB8fCBveSAhPT0geTEgfHwgZXggIT09IHgyIC0geDEgfHwgZXkgIT09IHkyIC0geTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrU2VsZWN0aW9uQ29ybmVycyh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpOyAvLyBjaGVjayBvbmUgbW9yZSB0aW1lIGJlY2F1c2Ugb2YgbmV3IGluY2x1ZGVkIGNlbGxzXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBveDogeDEsIG95OiB5MSwgZXg6IHgyIC0geDEsIGV5OiB5MiAtIHkxIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAZGVzY3JpcHRpb24gU2VsZWN0IHRoZSByZWdpb24gZGVzY3JpYmVkIGJ5IHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBfb3ggLSBvcmlnaW4geCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IF9veSAtIG9yaWdpbiB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gX2V4IC0gZXh0ZW50IHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBfZXkgLSBleHRlbnQgeSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzaWxlbnQgLSB3aGV0aGVyIHRvIGZpcmUgc2VsZWN0aW9uIGNoYW5nZWQgZXZlbnRcbiAgICAgKi9cbiAgICBzZWxlY3Q6IGZ1bmN0aW9uKF9veCwgX295LCBfZXgsIF9leSwgc2lsZW50KSB7XG4gICAgICAgIGlmIChpc05hTihfZXgpKSB7XG4gICAgICAgICAgICBfZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05hTihfZXkpKSB7XG4gICAgICAgICAgICBfZXkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHsgb3gsIG95LCBleCwgZXkgfSA9IHRoaXMuY2hlY2tTZWxlY3Rpb25Db3JuZXJzKF9veCwgX295LCBfZXgsIF9leSk7XG4gICAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IHRoaXMuZ3JpZC5uZXdSZWN0YW5nbGUob3gsIG95LCBleCwgZXkpO1xuXG4gICAgICAgIC8vQ2FjaGUgdGhlIGZpcnN0IHNlbGVjdGVkIGNlbGwgYmVmb3JlIGl0IGdldHMgbm9ybWFsaXplZCB0byB0b3AtbGVmdCBvcmlnaW5cbiAgICAgICAgbmV3U2VsZWN0aW9uLmZpcnN0U2VsZWN0ZWRDZWxsID0gdGhpcy5ncmlkLm5ld1BvaW50KHRoaXMuY2hlY2tDZWxsTGVmdChfb3gsIF9veSksIHRoaXMuY2hlY2tDZWxsVG9wKF9veCwgX295KSk7XG5cbiAgICAgICAgbmV3U2VsZWN0aW9uLmxhc3RTZWxlY3RlZENlbGwgPSAoXG4gICAgICAgICAgICBuZXdTZWxlY3Rpb24uZmlyc3RTZWxlY3RlZENlbGwueCA9PT0gbmV3U2VsZWN0aW9uLm9yaWdpbi54ICYmXG4gICAgICAgICAgICBuZXdTZWxlY3Rpb24uZmlyc3RTZWxlY3RlZENlbGwueSA9PT0gbmV3U2VsZWN0aW9uLm9yaWdpbi55XG4gICAgICAgIClcbiAgICAgICAgICAgID8gbmV3U2VsZWN0aW9uLmNvcm5lclxuICAgICAgICAgICAgOiBuZXdTZWxlY3Rpb24ub3JpZ2luO1xuXG4gICAgICAgIGlmICh0aGlzLmdyaWQucHJvcGVydGllcy5tdWx0aXBsZVNlbGVjdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9ucy5wdXNoKG5ld1NlbGVjdGlvbik7XG4gICAgICAgICAgICB0aGlzLmZsYXR0ZW5lZFgucHVzaChuZXdTZWxlY3Rpb24uZmxhdHRlblhBdCgwKSk7XG4gICAgICAgICAgICB0aGlzLmZsYXR0ZW5lZFkucHVzaChuZXdTZWxlY3Rpb24uZmxhdHRlbllBdCgwKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbnNbMF0gPSBuZXdTZWxlY3Rpb247XG4gICAgICAgICAgICB0aGlzLmZsYXR0ZW5lZFhbMF0gPSBuZXdTZWxlY3Rpb24uZmxhdHRlblhBdCgwKTtcbiAgICAgICAgICAgIHRoaXMuZmxhdHRlbmVkWVswXSA9IG5ld1NlbGVjdGlvbi5mbGF0dGVuWUF0KDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0TGFzdFNlbGVjdGlvblR5cGUoJ2NlbGwnKTtcblxuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLnNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG94IC0gb3JpZ2luIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBveSAtIG9yaWdpbiB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXggLSBleHRlbnQgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV5IC0gZXh0ZW50IHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIHRvZ2dsZVNlbGVjdDogZnVuY3Rpb24ob3gsIG95LCBleCwgZXkpIHtcblxuICAgICAgICB2YXIgc2VsZWN0ZWQsIGluZGV4O1xuXG4gICAgICAgIHNlbGVjdGVkID0gdGhpcy5zZWxlY3Rpb25zLmZpbmQoZnVuY3Rpb24oc2VsZWN0aW9uLCBpZHgpIHtcbiAgICAgICAgICAgIGluZGV4ID0gaWR4O1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24ub3JpZ2luLnggPT09IG94ICYmIHNlbGVjdGlvbi5vcmlnaW4ueSA9PT0gb3kgJiZcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uZXh0ZW50LnggPT09IGV4ICYmIHNlbGVjdGlvbi5leHRlbnQueSA9PT0gZXlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLmZsYXR0ZW5lZFguc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMuZmxhdHRlbmVkWS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5ncmlkLnNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KG94LCBveSwgZXgsIGV5KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVtb3ZlIHRoZSBsYXN0IHNlbGVjdGlvbiB0aGF0IHdhcyBjcmVhdGVkLlxuICAgICAqL1xuICAgIGNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbjogZnVuY3Rpb24oa2VlcFJvd1NlbGVjdGlvbnMpIHtcbiAgICAgICAgaWYgKCFrZWVwUm93U2VsZWN0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zZXRBbGxSb3dzU2VsZWN0ZWQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAtLXRoaXMuc2VsZWN0aW9ucy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmxhdHRlbmVkWC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC0tdGhpcy5mbGF0dGVuZWRYLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mbGF0dGVuZWRZLmxlbmd0aCkge1xuICAgICAgICAgICAgLS10aGlzLmZsYXR0ZW5lZFkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vdGhpcy5nZXRHcmlkKCkuc2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBzZWxlY3Rpb25Nb2RlbENsZWFyTW9zdFJlY2VudDogZnVuY3Rpb24oc2VsZWN0aW9uTW9kZWwpIHtcbiAgICAgICAgc2VsZWN0aW9uTW9kZWwuY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjbGVhck1vc3RSZWNlbnRDb2x1bW5TZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsQ2xlYXJNb3N0UmVjZW50KHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwpO1xuICAgICAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCdjb2x1bW4nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNsZWFyTW9zdFJlY2VudFJvd1NlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWxDbGVhck1vc3RSZWNlbnQodGhpcy5yb3dTZWxlY3Rpb25Nb2RlbCk7XG4gICAgICAgIHRoaXMuc2V0TGFzdFNlbGVjdGlvblR5cGUoJ3JvdycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgY2xlYXJSb3dTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuc2V0TGFzdFNlbGVjdGlvblR5cGUoJ3JvdycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlcmUgYXJlIGFjdGl2ZSBzZWxlY3Rpb24ocykuXG4gICAgICovXG4gICAgaGFzU2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbnMubGVuZ3RoICE9PSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzUm93U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5pc0VtcHR5KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNDb2x1bW5TZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsLmlzRW1wdHkoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFNlbGVjdGlvbiBjb3ZlcnMgYSBzcGVjaWZpYyBjb2x1bW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKi9cbiAgICBpc0NlbGxTZWxlY3RlZEluUm93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NlbGxTZWxlY3RlZCh0aGlzLmZsYXR0ZW5lZFgsIDAsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgU2VsZWN0aW9uIGNvdmVycyBhIHNwZWNpZmljIHJvdy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqL1xuICAgIGlzQ2VsbFNlbGVjdGVkSW5Db2x1bW46IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2VsbFNlbGVjdGVkKHRoaXMuZmxhdHRlbmVkWSwgeCwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTZWxlY3Rpb24gcXVlcnkgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiBjZWxsIGlzIHNlbGVjdGVkIChwYXJ0IG9mIGFuIGFjdGl2ZSBzZWxlY3Rpb24pLlxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlW119IHNlbGVjdGlvbnMgLSBTZWxlY3Rpb24gcmVjdGFuZ2xlcyB0byBzZWFyY2ggdGhyb3VnaC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICovXG4gICAgaXNTZWxlY3RlZDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5pc0NvbHVtblNlbGVjdGVkKHgpIHx8XG4gICAgICAgICAgICB0aGlzLmlzUm93U2VsZWN0ZWQoeSkgfHxcbiAgICAgICAgICAgIHRoaXMuX2lzQ2VsbFNlbGVjdGVkKHRoaXMuc2VsZWN0aW9ucywgeCwgeSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBpc0NlbGxTZWxlY3RlZDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDZWxsU2VsZWN0ZWQodGhpcy5zZWxlY3Rpb25zLCB4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb25zXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzQ2VsbFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3Rpb25zLCB4LCB5KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuICEhc2VsZWN0aW9ucy5maW5kKGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYucmVjdGFuZ2xlQ29udGFpbnMoc2VsZWN0aW9uLCB4LCB5KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBlbXB0eSBvdXQgYWxsIG91ciBzdGF0ZVxuICAgICAqXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uKGtlZXBSb3dTZWxlY3Rpb25zKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9ucy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmZsYXR0ZW5lZFgubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5mbGF0dGVuZWRZLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwuY2xlYXIoKTtcbiAgICAgICAgaWYgKCFrZWVwUm93U2VsZWN0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zZXRBbGxSb3dzU2VsZWN0ZWQoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JpZC5zZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3ggLSBvcmlnaW4geCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG95IC0gb3JpZ2luIHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleCAtIGV4dGVudCB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXkgLSBleHRlbnQgeSBjb29yZGluYXRlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNSZWN0YW5nbGVTZWxlY3RlZDogZnVuY3Rpb24ob3gsIG95LCBleCwgZXkpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5zZWxlY3Rpb25zLmZpbmQoZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5vcmlnaW4ueCA9PT0gb3ggJiYgc2VsZWN0aW9uLm9yaWdpbi55ID09PSBveSAmJlxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5leHRlbnQueCA9PT0gZXggJiYgc2VsZWN0aW9uLmV4dGVudC55ID09PSBleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGlzQ29sdW1uU2VsZWN0ZWQ6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwuaXNTZWxlY3RlZCh4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMge2Jvb2xlYW58Kn1cbiAgICAgKi9cbiAgICBpc1Jvd1NlbGVjdGVkOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFsbFJvd3NTZWxlY3RlZCB8fCB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLmlzU2VsZWN0ZWQoeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geDFcbiAgICAgKiBAcGFyYW0geDJcbiAgICAgKi9cbiAgICBzZWxlY3RDb2x1bW46IGZ1bmN0aW9uKHgxLCB4Mikge1xuICAgICAgICBpZiAoeDIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgeDIgPSB4MTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJld3JpdGUgaWYgbWVyZ2VkIGNlbGxzIHdpbGwgYmUgbm90IGZpcnN0IGNlbGwgaW4gcm93XG4gICAgICAgIGlmICh4MSA8PSB4Mikge1xuICAgICAgICAgICAgeDEgPSB0aGlzLmNoZWNrQ2VsbExlZnQoeDEsIDApO1xuICAgICAgICAgICAgeDIgPSB0aGlzLmNoZWNrQ2VsbFJpZ2h0KHgyLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHgxID0gdGhpcy5jaGVja0NlbGxSaWdodCh4MSwgMCk7XG4gICAgICAgICAgICB4MiA9IHRoaXMuY2hlY2tDZWxsTGVmdCh4MiwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsLnNlbGVjdCh4MSwgeDIpO1xuICAgICAgICB0aGlzLnNlbGVjdCh4MSwgMCwgeDIgLSB4MSwgdGhpcy5ncmlkLmdldFJvd0NvdW50KCkgLSAxKTtcbiAgICAgICAgdGhpcy5ncmlkLnNlbGVjdENvbERlZnNGb3JBcGkoKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgnY29sdW1uJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZWxlY3RBbGxSb3dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB0aGlzLnNldEFsbFJvd3NTZWxlY3RlZCh0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gICAgc2V0QWxsUm93c1NlbGVjdGVkOiBmdW5jdGlvbihpc0l0KSB7XG4gICAgICAgIHRoaXMuYWxsUm93c1NlbGVjdGVkID0gaXNJdDtcbiAgICAgICAgaWYgKGlzSXQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KDAsIDAsIHRoaXMuZ3JpZC5nZXRDb2x1bW5Db3VudCgpIC0gMSwgdGhpcy5ncmlkLmdldFJvd0NvdW50KCkgLSAxKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhcmVBbGxSb3dzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGxSb3dzU2VsZWN0ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geTFcbiAgICAgKiBAcGFyYW0geTJcbiAgICAgKi9cbiAgICBzZWxlY3RSb3c6IGZ1bmN0aW9uKHkxLCB5Mikge1xuICAgICAgICBpZiAoeTIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgeTIgPSB5MTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJld3JpdGUgaWYgbWVyZ2VkIGNlbGxzIHdpbGwgYmUgbm90IGZpcnN0IGNlbGwgaW4gcm93XG4gICAgICAgIGlmICh5MSA8PSB5Mikge1xuICAgICAgICAgICAgeTEgPSB0aGlzLmNoZWNrQ2VsbFRvcCgwLCB5MSk7XG4gICAgICAgICAgICB5MiA9IHRoaXMuY2hlY2tDZWxsQm90dG9tKDAsIHkyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHkxID0gdGhpcy5jaGVja0NlbGxCb3R0b20oMCwgeTEpO1xuICAgICAgICAgICAgeTIgPSB0aGlzLmNoZWNrQ2VsbFRvcCgwLCB5Mik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLnNlbGVjdCh5MSwgeTIpO1xuICAgICAgICB0aGlzLnNlbGVjdCgwLCB5MSwgdGhpcy5ncmlkLmdldENvbHVtbkNvdW50KCkgLSAxLCB5MiAtIHkxKTtcbiAgICAgICAgdGhpcy5ncmlkLnNlbGVjdENvbERlZnNGb3JBcGkoKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgncm93Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geDFcbiAgICAgKiBAcGFyYW0geDJcbiAgICAgKi9cbiAgICBkZXNlbGVjdENvbHVtbjogZnVuY3Rpb24oeDEsIHgyKSB7XG4gICAgICAgIHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwuZGVzZWxlY3QoeDEsIHgyKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgnY29sdW1uJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geTFcbiAgICAgKiBAcGFyYW0geTJcbiAgICAgKi9cbiAgICBkZXNlbGVjdFJvdzogZnVuY3Rpb24oeTEsIHkyKSB7XG4gICAgICAgIGlmICh0aGlzLmFyZUFsbFJvd3NTZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICAvLyBUbyBkZXNlbGVjdCBhIHJvdywgd2UgbXVzdCBmaXJzdCByZW1vdmUgdGhlIGFsbCByb3dzIGZsYWcuLi5cbiAgICAgICAgICAgIHRoaXMuc2V0QWxsUm93c1NlbGVjdGVkKGZhbHNlKTtcbiAgICAgICAgICAgIC8vIC4uLmFuZCBjcmVhdGUgYSBzaW5nbGUgcmFuZ2UgcmVwcmVzZW50aW5nIGFsbCByb3dzXG4gICAgICAgICAgICB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLnNlbGVjdCgwLCB0aGlzLmdyaWQuZ2V0Um93Q291bnQoKSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm93U2VsZWN0aW9uTW9kZWwuZGVzZWxlY3QoeTEsIHkyKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgncm93Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZFJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5hcmVBbGxSb3dzU2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgdmFyIGhlYWRlclJvd3MgPSB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgICAgIHZhciByb3dDb3VudCA9IHRoaXMuZ3JpZC5nZXRSb3dDb3VudCgpIC0gaGVhZGVyUm93cztcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkocm93Q291bnQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gaSArIGhlYWRlclJvd3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHsqfEFycmF5LkFycmF5Lm51bWJlcn1cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZENvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0NvbHVtbk9yUm93U2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwuaXNFbXB0eSgpIHx8ICF0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLmlzRW1wdHkoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRGbGF0dGVuZWRZczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIHNldCA9IHt9O1xuICAgICAgICB0aGlzLnNlbGVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciB0b3AgPSBzZWxlY3Rpb24ub3JpZ2luLnk7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHNlbGVjdGlvbi5leHRlbnQueSArIDE7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHNpemU7IHIrKykge1xuICAgICAgICAgICAgICAgIHZhciB0aSA9IHIgKyB0b3A7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXRbdGldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRpKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0W3RpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0LnNvcnQoZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHggLSB5O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBvZmZzZXRcbiAgICAgKi9cbiAgICBzZWxlY3RSb3dzRnJvbUNlbGxzOiBmdW5jdGlvbihvZmZzZXQsIGtlZXBSb3dTZWxlY3Rpb25zKSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgICAgIHZhciBzbSA9IHRoaXMucm93U2VsZWN0aW9uTW9kZWw7XG5cbiAgICAgICAgaWYgKCFrZWVwUm93U2VsZWN0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zZXRBbGxSb3dzU2VsZWN0ZWQoZmFsc2UpO1xuICAgICAgICAgICAgc20uY2xlYXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIHRvcCA9IHNlbGVjdGlvbi5vcmlnaW4ueSxcbiAgICAgICAgICAgICAgICBleHRlbnQgPSBzZWxlY3Rpb24uZXh0ZW50Lnk7XG4gICAgICAgICAgICB0b3AgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgc20uc2VsZWN0KHRvcCwgdG9wICsgZXh0ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAgICovXG4gICAgc2VsZWN0Q29sdW1uc0Zyb21DZWxsczogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgICAgIHZhciBzbSA9IHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWw7XG4gICAgICAgIHNtLmNsZWFyKCk7XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IHNlbGVjdGlvbi5vcmlnaW4ueCxcbiAgICAgICAgICAgICAgICBleHRlbnQgPSBzZWxlY3Rpb24uZXh0ZW50Lng7XG4gICAgICAgICAgICBsZWZ0ICs9IG9mZnNldDtcbiAgICAgICAgICAgIHNtLnNlbGVjdChsZWZ0LCBsZWZ0ICsgZXh0ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgaXNJbkN1cnJlbnRTZWxlY3Rpb25SZWN0YW5nbGU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIGxhc3QgPSB0aGlzLnNlbGVjdGlvbnNbdGhpcy5zZWxlY3Rpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gbGFzdCAmJiB0aGlzLnJlY3RhbmdsZUNvbnRhaW5zKGxhc3QsIHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGlzRmlyc3RTZWxlY3RlZENlbGw6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIGZpcnN0U2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRGaXJzdFNlbGVjdGVkQ2VsbE9mTGFzdFNlbGVjdGlvbigpO1xuICAgICAgICByZXR1cm4gZmlyc3RTZWxlY3RlZENlbGwgJiYgKGZpcnN0U2VsZWN0ZWRDZWxsLnggPT09IHgpICYmIChmaXJzdFNlbGVjdGVkQ2VsbC55ID09PSB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJldHVybnMgZmlyc3Qgc2VsZWN0ZWQgY2VsbCBvZiBsYXN0IHNlbGVjdGlvblxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldEZpcnN0U2VsZWN0ZWRDZWxsT2ZMYXN0U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxhc3QgPSB0aGlzLnNlbGVjdGlvbnNbdGhpcy5zZWxlY3Rpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhc3QuZmlyc3RTZWxlY3RlZENlbGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSByZWN0XG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHJlY3RhbmdsZUNvbnRhaW5zOiBmdW5jdGlvbihyZWN0LCB4LCB5KSB7IC8vVE9ETzogZXhwbG9yZSB3aHkgdGhpcyB3b3JrcyBhbmQgY29udGFpbnMgb24gcmVjdGFuZ2x1bGFyIGRvZXMgbm90XG4gICAgICAgIHZhciBtaW5YID0gcmVjdC5vcmlnaW4ueDtcbiAgICAgICAgdmFyIG1pblkgPSByZWN0Lm9yaWdpbi55O1xuICAgICAgICB2YXIgbWF4WCA9IG1pblggKyByZWN0LmV4dGVudC54O1xuICAgICAgICB2YXIgbWF4WSA9IG1pblkgKyByZWN0LmV4dGVudC55O1xuXG4gICAgICAgIGlmIChyZWN0LmV4dGVudC54IDwgMCkge1xuICAgICAgICAgICAgbWluWCA9IG1heFg7XG4gICAgICAgICAgICBtYXhYID0gcmVjdC5vcmlnaW4ueDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWN0LmV4dGVudC55IDwgMCkge1xuICAgICAgICAgICAgbWluWSA9IG1heFk7XG4gICAgICAgICAgICBtYXhZID0gcmVjdC5vcmlnaW4ueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPVxuICAgICAgICAgICAgeCA+PSBtaW5YICYmXG4gICAgICAgICAgICB5ID49IG1pblkgJiZcbiAgICAgICAgICAgIHggPD0gbWF4WCAmJlxuICAgICAgICAgICAgeSA8PSBtYXhZO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3Rpb25Nb2RlbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNlbGxFdmVudFByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7fSwgeyAvLyBhbGwgcHJvcHMgbm9uLWVudW1lcmFibGVcbiAgICAvKipcbiAgICAgKiBUaGUgcmF3IHZhbHVlIG9mIHRoZSBjZWxsLCB1bmZvcm1hdHRlZC5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIHZhbHVlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnN1YmdyaWQuZ2V0VmFsdWUodGhpcy52YWx1ZUNlbGwueCwgdGhpcy52YWx1ZUNlbGwueSk7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5zdWJncmlkLnNldFZhbHVlKHRoaXMudmFsdWVDZWxsLngsIHRoaXMudmFsdWVDZWxsLnksIHZhbHVlKTsgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93cyBjZWxsIHZhbHVlIGlzIGEgaHR0cC9odHRwcyB1cmwgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGlzVmFsdWVVcmw6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc3ViZ3JpZC5pc1ZhbHVlVXJsKHRoaXMudmFsdWUpOyB9LFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSB3aG9sZSBkYXRhIHJvdywgaW5jbHVkaW5nIGhpZGRlbiBjb2x1bW5zLlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgKi9cbiAgICBkYXRhUm93OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJncmlkLmdldFJvdyh0aGlzLmRhdGFDZWxsLnksIHRoaXMuY29sdW1uLnRyZWVMZXZlbCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbHNwYW4gdmFsdWUgb2YgdGhlIGNlbGwsIHVuZm9ybWF0dGVkLlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgY29sc3Bhbjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zdWJncmlkLmdldENvbHNwYW4odGhpcy5kYXRhQ2VsbC54LCB0aGlzLmRhdGFDZWxsLnkpOyB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSByb3dzcGFuIHZhbHVlIG9mIHRoZSBjZWxsLCB1bmZvcm1hdHRlZC5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIHJvd3NwYW46IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc3ViZ3JpZC5nZXRSb3dzcGFuKHRoaXMuZGF0YUNlbGwueCwgdGhpcy5kYXRhQ2VsbC55KTsgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBjZWxsIHdpbGwgYmUgaWdub3JlZCBvbiByZW5kZXJcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGlzUmVuZGVyU2tpcE5lZWRlZDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zdWJncmlkLmlzUmVuZGVyU2tpcE5lZWRlZCh0aGlzLnZhbHVlQ2VsbC54LCB0aGlzLnZhbHVlQ2VsbC55KTsgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93cywgaXMgY2VsbCBuZWVkIHRvIGJlIGhpZGRlbiBiZWNhdXNlIG9mIGxlZnQgY29sdW1uXG4gICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgKi9cbiAgICBpc0NvbHNwYW5lZEJ5TGVmdENvbHVtbjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zdWJncmlkLmlzQ29sc3BhbmVkQnlMZWZ0Q29sdW1uKHRoaXMuZGF0YUNlbGwueCwgdGhpcy5kYXRhQ2VsbC55KTsgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGluZGV4IG9mIHJvdywgdGhhdCBvdmVybGFwcyBjdXJyZW50IGNlbGxcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIHJvd3NwYW5NYWluUm93OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnN1YmdyaWQuZ2V0Um93c3Bhbk1haW5Sb3codGhpcy5kYXRhQ2VsbC54LCB0aGlzLmRhdGFDZWxsLnkpOyB9XG4gICAgfSxcblxuICAgIGNlbGxEYXRhOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnN1YmdyaWQuX2dldERhdGFSb3dPYmplY3QodGhpcy52YWx1ZUNlbGwueCwgdGhpcy52YWx1ZUNlbGwueSk7IH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBuYW1lIG9mIGNvbHVtbiwgdGhhdCBvdmVybGFwcyBjdXJyZW50IGNlbGxcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGNvbHNwYW5NYWluQ29sdW1uTmFtZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zdWJncmlkLmdldENvbHNwYW5NYWluQ29sdW1uTmFtZSh0aGlzLmRhdGFDZWxsLngsIHRoaXMuZGF0YUNlbGwueSk7IH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjaGlsZCBjb2xEZWZzLCBpZiBjZWxsIGhhcyBpdFxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICogQHJldHVybiB7YXJyYXl9XG4gICAgICovXG4gICAgY2hpbGRDb2x1bW5zOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnN1YmdyaWQuZ2V0Q2hpbGRDb2x1bW5zRnJvbUNlbGwodGhpcy5kYXRhQ2VsbC54LCB0aGlzLmRhdGFDZWxsLnkpOyB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYm9vbGVhbiB2YWx1ZSwgdGhhdCBzaG93cywgaXMgY2VsbCBoYXMgY2hpbGQgY29sRGVmc1xuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0V4cGFuZGFibGVDb2x1bW46IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc3ViZ3JpZC5nZXRIYXNDaGlsZENvbHVtbnNGcm9tQ2VsbCh0aGlzLmRhdGFDZWxsLngsIHRoaXMuZGF0YUNlbGwueSk7IH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBib29sZWFuIHZhbHVlLCB0aGF0IHNob3dzLCBpcyBjaGlsZCBjb2x1bW5zIG5lZWRlZCB0byBiZSBzaG93biBieSBkZWZhdWx0XG4gICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzQ29sdW1uT3BlbkJ5RGVmYXVsdDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zdWJncmlkLmdldElzQ29sdW1uT3BlbkJ5RGVmYXVsdEZyb21DZWxsKHRoaXMuZGF0YUNlbGwueCwgdGhpcy5kYXRhQ2VsbC55KTsgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGJvb2xlYW4gdmFsdWUsIHRoYXQgc2hvd3MsIGlzIGNlbGwgaGFzIGNoaWxkIGNvbERlZnNcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNDb2x1bW5FeHBhbmRlZDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zdWJncmlkLmdldElzQ29sdW1uR3JvdXBTaG93RnJvbUNlbGwodGhpcy5kYXRhQ2VsbC54LCB0aGlzLmRhdGFDZWxsLnkpOyB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYm9vbGVhbiB2YWx1ZSwgdGhhdCBzaG93cywgaXMgY2VsbCB3YXMgcm93c3BhbmVkIGJ5IGFueSByb3cgYXQgbGVmdFxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1Jvd3NwYW5lZEJ5Um93OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnN1YmdyaWQuaXNSb3dzcGFuZWRCeVJvdyh0aGlzLmRhdGFDZWxsLngsIHRoaXMuZGF0YUNlbGwueSk7IH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xEZWZzIGdyb3VwIGlkLCBpZiBleGlzdCAoaWYgY2VsbCByZXByZXNlbnQgZmljdGl2ZSBoZWFkZXIpXG4gICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgY29sdW1uR3JvdXBJZDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zdWJncmlkLmdldENvbHVtbkdyb3VwSWRGcm9tQ2VsbCh0aGlzLmRhdGFDZWxsLngsIHRoaXMuZGF0YUNlbGwueSk7IH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZvcm1hdHRlZCB2YWx1ZSBvZiB0aGUgY2VsbC5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGZvcm1hdHRlZFZhbHVlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9ybWF0dGVkVmFsdWUgfHwgKHRoaXMuX2Zvcm1hdHRlZFZhbHVlID0gdGhpcy5ncmlkLmZvcm1hdFZhbHVlKHRoaXMucHJvcGVydGllcy5mb3JtYXQsIHRoaXMudmFsdWUsIHRoaXMucm93UHJvcGVydGllcy5oZWFkZXJSb3cpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBUaGUgZm9ybWF0dGVkIGFuZCBoaWdobGlnaHRlZCB2YWx1ZSBvZiB0aGUgY2VsbC5cbiAgICAgKiAgQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgKi9cbiAgICBoaWdobGlnaHRlZENoYXJzOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCBoaWdobGlnaHRzID0gW107XG5cbiAgICAgICAgICAgIGNvbnN0IHsgaGlnaExpZ2h0VGV4dCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgaWYgKCFoaWdoTGlnaHRUZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhpZ2hsaWdodHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaFR5cGUgPSB0aGlzLmNvbHVtbiA/IHRoaXMuY29sdW1uLnNlYXJjaFR5cGUgOiAnTk9ORSc7XG4gICAgICAgICAgICBpZiAoc2VhcmNoVHlwZSA9PT0gJ05PTkUnIHx8IHNlYXJjaFR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoaWdobGlnaHRzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBzdHIgPSB0aGlzLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgaWYgKCFzdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGlnaGxpZ2h0cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcmVnID0gdGhpcy5zdWJncmlkLmdldEhpZ2hsaWdodFJlZ2V4KGhpZ2hMaWdodFRleHQsIHNlYXJjaFR5cGUpO1xuICAgICAgICAgICAgaWYgKCFyZWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGlnaGxpZ2h0cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IG07XG4gICAgICAgICAgICB3aGlsZSAoKG0gPSByZWcuZXhlYyhzdHIgKyAnJykpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBoaWdobGlnaHRzLnB1c2goeyBmcm9tOiBtLmluZGV4LCB0bzogbS5pbmRleCArIG1bMF0ubGVuZ3RoIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaGlnaGxpZ2h0cztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYm91bmRzIG9mIHRoZSBjZWxsLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZWZ0XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRvcFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGJvdW5kczoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kcyB8fCAodGhpcy5fYm91bmRzID0ge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMudmlzaWJsZUNvbHVtbi5sZWZ0LFxuICAgICAgICAgICAgICAgIHk6IHRoaXMudmlzaWJsZVJvdy50b3AsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMudmlzaWJsZUNvbHVtbi53aWR0aCArICh0aGlzLmNvbHNwYW4gPyB0aGlzLmJlaGF2aW9yLmdldEFkZGl0aW9uYWxXaWR0aCh0aGlzLmRhdGFDZWxsLngsIHRoaXMuZGF0YUNlbGwueSkgOiAwKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMudmlzaWJsZVJvdy5oZWlnaHQgKyAodGhpcy5yb3dzcGFuID8gdGhpcy5iZWhhdmlvci5nZXRBZGRpdGlvbmFsSGVpZ2h0KHRoaXMuZGF0YUNlbGwueCwgdGhpcy5kYXRhQ2VsbC55KSA6IDApXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb2x1bW5Qcm9wZXJ0aWVzOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjcCA9IHRoaXMuX2NvbHVtblByb3BlcnRpZXM7XG4gICAgICAgIGlmICghY3ApIHtcbiAgICAgICAgICAgIGNwID0gdGhpcy5jb2x1bW4ucHJvcGVydGllcztcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSGFuZGxlQ29sdW1uKXtcbiAgICAgICAgICAgICAgICBjcCA9IGNwLnJvd0hlYWRlcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1RyZWVDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICBjcCA9IGNwLnRyZWVIZWFkZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNEYXRhUm93KSB7XG4gICAgICAgICAgICAgICAgLy8gY3AgYWxyZWFkeSBzZXQgdG8gYmFzaWMgcHJvcHNcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0ZpbHRlclJvdykge1xuICAgICAgICAgICAgICAgIGNwID0gY3AuZmlsdGVyUHJvcGVydGllcztcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIHVuc2VsZWN0ZWQgaGVhZGVyLCBzdW1tYXJ5LCBldGMuLCBhbGwgaGF2ZSBzYXZlIGxvb2sgYXMgdW5zZWxlY3RlZCBoZWFkZXJcbiAgICAgICAgICAgICAgICBjcCA9IGNwLmNvbHVtbkhlYWRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NvbHVtblByb3BlcnRpZXMgPSBjcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3A7XG4gICAgfSB9LFxuICAgIGNlbGxPd25Qcm9wZXJ0aWVzOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGRvIG5vdCB1c2UgZm9yIGdldC9zZXQgcHJvcCBiZWNhdXNlIG1heSByZXR1cm4gbnVsbDsgaW5zdGVhZCB1c2UgLmdldENlbGxQcm9wZXJ0eSgncHJvcCcpIG9yIC5wcm9wZXJ0aWVzLnByb3AgKHByZWZlcnJlZCkgdG8gZ2V0LCBzZXRDZWxsUHJvcGVydHkoJ3Byb3AnLCB2YWx1ZSkgdG8gc2V0XG4gICAgICAgIGlmICh0aGlzLl9jZWxsT3duUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jZWxsT3duUHJvcGVydGllcyA9IHRoaXMuY29sdW1uLmdldENlbGxPd25Qcm9wZXJ0aWVzKHRoaXMuZGF0YUNlbGwueSwgdGhpcy5zdWJncmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG51bGwgcmV0dXJuIG1lYW5zIHRoZXJlIGlzIG5vIGNlbGwgcHJvcGVydGllcyBvYmplY3RcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NlbGxPd25Qcm9wZXJ0aWVzO1xuICAgIH0gfSxcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBDZWxsIHByb3BlcnRpZXMgb2JqZWN0IGlmIGl0IGV4aXN0cywgZWxzZSB0aGUgY29sdW1uIHByb3BlcnRpZXMgb2JqZWN0IGl0IHdvdWxkIGhhdmUgYXMgYSBwcm90b3R5cGUgaWYgZGlkIGV4aXN0LlxuICAgICAqIEBtZXRob2QqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydGllcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHByb3BzID0gc2hhbGxvd0Nsb25lKHRoaXMuY2VsbE93blByb3BlcnRpZXMgfHwgdGhpcy5jb2x1bW5Qcm9wZXJ0aWVzKTtcblxuICAgICAgICAgICAgdGhpcy5fY2VsbE93bkRlZmluZWRQcm9wZXJ0aWVzID0gdGhpcy5fY2VsbE93bkRlZmluZWRQcm9wZXJ0aWVzIHx8IHRoaXMuc3ViZ3JpZC5nZXREZWZpbmVkQ2VsbFByb3BlcnRpZXModGhpcy52YWx1ZUNlbGwueCwgdGhpcy52YWx1ZUNlbGwueSk7XG5cbiAgICAgICAgICAgIGlmIChwcm9wcyAmJiB0eXBlb2YgcHJvcHMgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fY2VsbE93bkRlZmluZWRQcm9wZXJ0aWVzICYmIHR5cGVvZiB0aGlzLl9jZWxsT3duRGVmaW5lZFByb3BlcnRpZXMgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5fY2VsbE93bkRlZmluZWRQcm9wZXJ0aWVzKS5sZW5ndGhcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocHJvcHMsIHRoaXMuX2NlbGxPd25EZWZpbmVkUHJvcGVydGllcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fcHJvcGVydGllcyA9IHByb3BzKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFByb3BlcnR5IG5hbWUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUHJvcGVydHkgdmFsdWUuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgZ2V0Q2VsbFByb3BlcnR5OiB7IHZhbHVlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgLy8gaW5jbHVkZWQgZm9yIGNvbXBsZXRlbmVzcyBidXQgYC5wcm9wZXJ0aWVzW2tleV1gIGlzIHByZWZlcnJlZFxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzW2tleV07XG4gICAgfSB9LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBQcm9wZXJ0eSBuYW1lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFByb3BlcnR5IHZhbHVlLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIHNldENlbGxQcm9wZXJ0eTogeyB2YWx1ZTogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAvLyBkbyBub3QgdXNlIGAuY2VsbE93blByb3BlcnRpZXNba2V5XSA9IHZhbHVlYCBiZWNhdXNlIG9iamVjdCBtYXkgYmUgbnVsbCAodGhpcyBtZXRob2QgY3JlYXRlcyBuZXcgb2JqZWN0IGFzIG5lZWRlZClcbiAgICAgICAgdGhpcy5fY2VsbE93blByb3BlcnRpZXMgPSB0aGlzLmNvbHVtbi5zZXRDZWxsUHJvcGVydHkodGhpcy5kYXRhQ2VsbC55LCBrZXksIHZhbHVlLCB0aGlzLnN1YmdyaWQpO1xuICAgIH0gfSxcblxuICAgIHJvd093blByb3BlcnRpZXM6IHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIHJldHVybiBtZWFucyB0aGVyZSBpcyBubyByb3cgcHJvcGVydGllcyBvYmplY3RcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldFJvd1Byb3BlcnRpZXModGhpcywgdW5kZWZpbmVkLCB0aGlzLnN1YmdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByb3dQcm9wZXJ0aWVzOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyB1c2UgY2FyZWZ1bGx5ISBjcmVhdGVzIG5ldyBvYmplY3QgYXMgbmVlZGVkOyBvbmx5IHVzZSB3aGVuIG9iamVjdCBkZWZpbml0ZWx5IG5lZWRlZDogZm9yIHNldHRpbmcgcHJvcCB3aXRoIGAucm93UHJvcGVydGllc1trZXldID0gdmFsdWVgIG9yIGBPYmplY3QuYXNzaWduKC5yb3dQcm9wZXJ0aWVzLCB7Li4ufSlgOyB1c2UgZ2V0Um93UHJvcGVydHkoa2V5KSBpbnN0ZWFkIGZvciBnZXR0aW5nIGEgcHJvcGVydHkgdGhhdCBtYXkgbm90IGV4aXN0IGJlY2F1c2UgaXQgd2lsbCBub3QgY3JlYXRlIGEgbmV3IG9iamVjdFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Um93UHJvcGVydGllcyh0aGlzLCBudWxsLCB0aGlzLnN1YmdyaWQpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIC8vIGZvciByZXNldHRpbmcgd2hvbGUgcm93IHByb3BlcnRpZXMgb2JqZWN0OiBgLnJvd1Byb3BlcnRpZXMgPSB7Li4ufWBcbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0Um93UHJvcGVydGllcyh0aGlzLCBwcm9wZXJ0aWVzLCB0aGlzLnN1YmdyaWQpOyAvLyBjYWxscyBgc3RhdGVDaGFuZ2VkKClgXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldFJvd1Byb3BlcnR5OiB7IHZhbHVlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIHJldHVybiBtZWFucyB0aGVyZSBpcyBubyByb3cgcHJvcGVydGllcyBvYmplY3QgT1Igbm8gc3VjaCByb3cgcHJvcGVydHkgYFtrZXldYFxuICAgICAgICB2YXIgcm93UHJvcHMgPSB0aGlzLnJvd093blByb3BlcnRpZXM7XG4gICAgICAgIHJldHVybiByb3dQcm9wcyAmJiByb3dQcm9wc1trZXldO1xuICAgIH0gfSxcbiAgICBzZXRSb3dQcm9wZXJ0eTogeyB2YWx1ZTogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAvLyBjcmVhdGVzIG5ldyBvYmplY3QgYXMgbmVlZGVkXG4gICAgICAgIHRoaXMucm93UHJvcGVydGllc1trZXldID0gdmFsdWU7IC8vIHRvZG86IGNhbGwgYHN0YXRlQ2hhbmdlZCgpYCBhZnRlciByZWZhYy1hcy1mbGFnc1xuICAgIH0gfSxcblxuICAgIC8vIHNwZWNpYWwgbWV0aG9kIGZvciB1c2UgYnkgcmVuZGVyZXIgd2hpY2ggcmV1c2VzIGNlbGxFdmVudCBvYmplY3QgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAgICByZXNldDoge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24odmlzaWJsZUNvbHVtbiwgdmlzaWJsZVJvdykge1xuICAgICAgICAgICAgLy8gZ2V0dGVyIGNhY2hlc1xuICAgICAgICAgICAgdGhpcy5fY29sdW1uUHJvcGVydGllcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX2NlbGxPd25Qcm9wZXJ0aWVzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fY2VsbE93bkRlZmluZWRQcm9wZXJ0aWVzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fYm91bmRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fZm9ybWF0dGVkVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAvLyBwYXJ0aWFsIHJlbmRlciBzdXBwb3J0XG4gICAgICAgICAgICB0aGlzLnNuYXBzaG90ID0gW107XG4gICAgICAgICAgICB0aGlzLm1pbldpZHRoID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy8gdGhpcy5kaXNhYmxlZCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgdGhpcy52aXNpYmxlQ29sdW1uID0gdmlzaWJsZUNvbHVtbjtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZVJvdyA9IHZpc2libGVSb3c7XG5cbiAgICAgICAgICAgIHRoaXMuc3ViZ3JpZCA9IHZpc2libGVSb3cuc3ViZ3JpZDtcblxuICAgICAgICAgICAgdGhpcy5jb2x1bW4gPSB2aXNpYmxlQ29sdW1uLmNvbHVtbjsgLy8gZW51bWVyYWJsZSBzbyB3aWxsIGJlIGNvcGllZCB0byBjZWxsIHJlbmRlcmVyIG9iamVjdFxuXG4gICAgICAgICAgICB0aGlzLmdyaWRDZWxsLnggPSB2aXNpYmxlQ29sdW1uLmNvbHVtbkluZGV4O1xuICAgICAgICAgICAgdGhpcy5ncmlkQ2VsbC55ID0gdmlzaWJsZVJvdy5pbmRleDtcblxuICAgICAgICAgICAgdGhpcy52YWx1ZUNlbGwueCA9IHRoaXMuZGF0YUNlbGwueCA9IHRoaXMuY29sdW1uICYmIHRoaXMuY29sdW1uLmluZGV4O1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNlbGwueSA9IHRoaXMuZGF0YUNlbGwueSA9IHZpc2libGVSb3cucm93SW5kZXg7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmVuZGVyU2tpcE5lZWRlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlQ2VsbC54ID4gMSAmJiAhdGhpcy5ncmlkLmlzQ29sdW1uVmlzaWJsZSh0aGlzLnZhbHVlQ2VsbC54IC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZUNlbGwueCA9IHRoaXMuZ3JpZC5zZWxlY3Rpb25Nb2RlbC5jaGVja0NlbGxMZWZ0KHRoaXMudmFsdWVDZWxsLngsIHRoaXMudmFsdWVDZWxsLnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZUNlbGwueSA+IDAgJiYgIXRoaXMuZ3JpZC5pc0RhdGFSb3dWaXNpYmxlKHRoaXMudmFsdWVDZWxsLnkgLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlQ2VsbC55ID0gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLmNoZWNrQ2VsbFRvcCh0aGlzLnZhbHVlQ2VsbC54LCB0aGlzLnZhbHVlQ2VsbC55KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHVwIHRoaXMgYENlbGxFdmVudGAgaW5zdGFuY2UgdG8gcG9pbnQgdG8gdGhlIGNlbGwgYXQgdGhlIGdpdmVuIGdyaWQgY29vcmRpbmF0ZXMuXG4gICAgICogQGRlc2MgSWYgdGhlIHJlcXVlc3RlZCBjZWxsIGlzIG5vdCBiZSB2aXNpYmxlIChkdWUgdG8gYmVpbmcgc2Nyb2xsZWQgb3V0IG9mIHZpZXcgb3Igb3V0c2lkZSB0aGUgYm91bmRzIG9mIHRoZSByZW5kZXJlZCBncmlkKSwgdGhlIGluc3RhbmNlIGlzIG5vdCByZXNldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JpZEMgLSBIb3Jpem9udGFsIGdyaWQgY2VsbCBjb29yZGluYXRlIGFkanVzdGVkIGZvciBob3Jpem9udGFsIHNjcm9sbGluZyBhZnRlciBmaXhlZCBjb2x1bW5zLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncmlkWSAtIFJhdyB2ZXJ0aWNhbCBncmlkIGNlbGwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVmlzaWJpbGl0eS5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgKi9cbiAgICByZXNldEdyaWRDWTogeyB2YWx1ZTogZnVuY3Rpb24oZ3JpZEMsIGdyaWRZKSB7XG4gICAgICAgIHZhciB2ciwgdmMsIHZpc2libGUgPSAoXG4gICAgICAgICAgICAodmMgPSB0aGlzLnJlbmRlcmVyLmdldFZpc2libGVDb2x1bW4oZ3JpZEMpKSAmJlxuICAgICAgICAgICAgKHZyID0gdGhpcy5yZW5kZXJlci5nZXRWaXNpYmxlUm93KGdyaWRZKSlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHZpc2libGUpIHsgdGhpcy5yZXNldCh2YywgdnIpOyB9XG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xuICAgIH0gfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB1cCB0aGlzIGBDZWxsRXZlbnRgIGluc3RhbmNlIHRvIHBvaW50IHRvIHRoZSBjZWxsIGF0IHRoZSBnaXZlbiBncmlkIGNvb3JkaW5hdGVzLlxuICAgICAqIEBkZXNjIElmIHRoZSByZXF1ZXN0ZWQgY2VsbCBpcyBub3QgYmUgdmlzaWJsZSAoZHVlIHRvIGJlaW5nIHNjcm9sbGVkIG91dCBvZiB2aWV3IG9yIG91dHNpZGUgdGhlIGJvdW5kcyBvZiB0aGUgcmVuZGVyZWQgZ3JpZCksIHRoZSBpbnN0YW5jZSBpcyBub3QgcmVzZXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyaWRYIC0gUmF3IGhvcml6b250YWwgZ3JpZCBjZWxsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyaWRZIC0gUmF3IHZlcnRpY2FsIGdyaWQgY2VsbCBjb29yZGluYXRlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBWaXNpYmlsaXR5LlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIHJlc2V0R3JpZFhZOiB7IHZhbHVlOiBmdW5jdGlvbihncmlkWCwgZ3JpZFkpIHtcbiAgICAgICAgdmFyIHZyLCB2YywgdmlzaWJsZSA9IChcbiAgICAgICAgICAgICh2YyA9IHRoaXMucmVuZGVyZXIudmlzaWJsZUNvbHVtbnNbZ3JpZFhdKSAmJlxuICAgICAgICAgICAgKHZyID0gdGhpcy5yZW5kZXJlci5nZXRWaXNpYmxlUm93KGdyaWRZKSlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHZpc2libGUpIHsgdGhpcy5yZXNldCh2YywgdnIpOyB9XG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xuICAgIH0gfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNldCB1cCB0aGlzIGBDZWxsRXZlbnRgIGluc3RhbmNlIHRvIHBvaW50IHRvIHRoZSBjZWxsIGF0IHRoZSBnaXZlbiBkYXRhIGNvb3JkaW5hdGVzLlxuICAgICAqIEBkZXNjIElmIHRoZSByZXF1ZXN0ZWQgY2VsbCBpcyBub3QgYmUgdmlzaWJsZSAoZHVlIHRvIGJlaW5nIHNjcm9sbGVkIG91dCBvZiB2aWV3KSwgdGhlIGluc3RhbmNlIGlzIG5vdCByZXNldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YVggLSBIb3Jpem9udGFsIGRhdGEgY2VsbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhWSAtIFZlcnRpY2FsIGRhdGEgY2VsbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7ZGF0YU1vZGVsQVBJfSBbc3ViZ3JpZD10aGlzLmJlaGF2aW9yLnN1YmdyaWRzLmRhdGFdXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFZpc2liaWxpdHkuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgcmVzZXREYXRhWFk6IHsgdmFsdWU6IGZ1bmN0aW9uKGRhdGFYLCBkYXRhWSwgc3ViZ3JpZCkge1xuICAgICAgICB2YXIgdnIsIHZjLCB2aXNpYmxlID0gKFxuICAgICAgICAgICAgKHZjID0gdGhpcy5yZW5kZXJlci5nZXRWaXNpYmxlRGF0YUNvbHVtbihkYXRhWCkpICYmXG4gICAgICAgICAgICAodnIgPSB0aGlzLnJlbmRlcmVyLmdldFZpc2libGVEYXRhUm93KGRhdGFZLCBzdWJncmlkKSlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHZpc2libGUpIHsgdGhpcy5yZXNldCh2YywgdnIpOyB9XG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xuICAgIH0gfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB1cCB0aGlzIGBDZWxsRXZlbnRgIGluc3RhbmNlIHRvIHBvaW50IHRvIHRoZSBjZWxsIGF0IHRoZSBnaXZlbiBncmlkIGNvbHVtbiBhbmQgZGF0YSByb3cgY29vcmRpbmF0ZXMuXG4gICAgICogQGRlc2MgSWYgdGhlIHJlcXVlc3RlZCBjZWxsIGlzIG5vdCBiZSB2aXNpYmxlIChkdWUgdG8gYmVpbmcgc2Nyb2xsZWQgb3V0IG9mIHZpZXcgb3Igb3V0c2lkZSB0aGUgYm91bmRzIG9mIHRoZSByZW5kZXJlZCBncmlkKSwgdGhlIGluc3RhbmNlIGlzIG5vdCByZXNldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JpZFggLSBIb3Jpem9udGFsIGdyaWQgY2VsbCBjb29yZGluYXRlIChhZGp1c3RlZCBmb3IgaG9yaXpvbnRhbCBzY3JvbGxpbmcgYWZ0ZXIgZml4ZWQgY29sdW1ucykuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFZIC0gVmVydGljYWwgZGF0YSBjZWxsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtkYXRhTW9kZWxBUEl9IFtzdWJncmlkPXRoaXMuYmVoYXZpb3Iuc3ViZ3JpZHMuZGF0YV1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VBbGxDZWxsc10gLSBTZWFyY2ggaW4gYWxsIHJvd3MgYW5kIGNvbHVtbnMgaW5zdGVhZCBvZiBvbmx5IHJlbmRlcmVkIG9uZXMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFZpc2liaWxpdHkuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgcmVzZXRHcmlkWERhdGFZOiB7IHZhbHVlOiBmdW5jdGlvbihncmlkWCwgZGF0YVksIHN1YmdyaWQsIHVzZUFsbENlbGxzKSB7XG4gICAgICAgIHZhciB2aXNpYmxlLCB2YywgdnI7XG5cbiAgICAgICAgaWYgKHVzZUFsbENlbGxzKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGV4cGFuZGluZyBzZWxlY3Rpb25zIGxhcmdlciB0aGFuIHRoZSB2aWV3cG9ydCwgdGhlIG9yaWdpbi9jb3JuZXJcbiAgICAgICAgICAgIC8vIHBvaW50cyBtYXkgbm90IGJlIHJlbmRlcmVkIGFuZCB3b3VsZCBub3JtYWxseSBmYWlsIHRvIHJlc2V0IGNlbGwncyBwb3NpdGlvbi5cbiAgICAgICAgICAgIC8vIE1vY2sgY29sdW1uIGFuZCByb3cgb2JqZWN0cyBmb3IgdGhpcy5yZXNldCgpIHRvIHVzZTpcbiAgICAgICAgICAgIHZjID0ge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5iZWhhdmlvci5nZXRDb2x1bW4oZ3JpZFgpLFxuICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4OiBncmlkWFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZyID0ge1xuICAgICAgICAgICAgICAgIHN1YmdyaWQ6IHN1YmdyaWQgfHwgdGhpcy5iZWhhdmlvci5zdWJncmlkcy5sb29rdXAuZGF0YSxcbiAgICAgICAgICAgICAgICByb3dJbmRleDogZGF0YVlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpc2libGUgPSAoXG4gICAgICAgICAgICAgICAgKHZjID0gdGhpcy5yZW5kZXJlci5nZXRWaXNpYmxlQ29sdW1uKGdyaWRYKSkgJiZcbiAgICAgICAgICAgICAgICAodnIgPSB0aGlzLnJlbmRlcmVyLmdldFZpc2libGVEYXRhUm93KGRhdGFZLCBzdWJncmlkKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCh2YywgdnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZpc2libGUgJiYgdGhpcztcbiAgICB9IH0sXG5cbiAgICAvKipcbiAgICAgKiBDb3B5IHNlbGYgd2l0aCBvciB3aXRob3V0IG93biBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtib29sYW59IFthc3NpZ249ZmFsc2VdIC0gQ29weSB0aGUgb3duIHByb3BlcnRpZXMgdG8gdGhlIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtDZWxsRXZlbnR9XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgY2xvbmU6IHsgdmFsdWU6IGZ1bmN0aW9uKGFzc2lnbikge1xuICAgICAgICB2YXIgY2VsbEV2ZW50ID0gbmV3IHRoaXMuY29uc3RydWN0b3I7XG5cbiAgICAgICAgY2VsbEV2ZW50LnJlc2V0R3JpZFhZKHRoaXMudmlzaWJsZUNvbHVtbi5pbmRleCwgdGhpcy52aXNpYmxlUm93LmluZGV4KTtcblxuICAgICAgICBpZiAoYXNzaWduKSB7XG4gICAgICAgICAgICAvLyBjb3B5IG93biBwcm9wc1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjZWxsRXZlbnQsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNlbGxFdmVudDtcbiAgICB9IH0sXG5cbiAgICBlZGl0UG9pbnQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93ICdUaGUgYC5lZGl0UG9pbnRgIHByb3BlcnR5IGlzIG5vIGxvbmdlciBhdmFpbGFibGUgYXMgb2YgdjEuMi4xMC4gVXNlIHRoZSBmb2xsb3dpbmcgY29vcmRpbmF0ZXMgaW5zdGVhZDpcXG4nICtcbiAgICAgICAgICAgICdgLmdyaWRDZWxsLnhgIC0gVGhlIGFjdGl2ZSBjb2x1bW4gaW5kZXguIChBZGp1c3RlZCBmb3IgY29sdW1uIHNjcm9sbGluZyBhZnRlciBmaXhlZCBjb2x1bW5zLilcXG4nICtcbiAgICAgICAgICAgICdgLmdyaWRDZWxsLnlgIC0gVGhlIHZlcnRpY2FsIGdyaWQgY29vcmRpbmF0ZS4gKFVuYWZmZWN0ZWQgYnkgcm93IHNjcm9sbGluZy4pXFxuJyArXG4gICAgICAgICAgICAnYC5kYXRhQ2VsbC54YCAtIFRoZSBkYXRhIG1vZGVsXFwncyBjb2x1bW4gaW5kZXguIChVbmFmZmVjdGVkIGJ5IGNvbHVtbiBzY3JvbGxpbmcuKVxcbicgK1xuICAgICAgICAgICAgJ2AuZGF0YUNlbGwueWAgLSBUaGUgZGF0YSBtb2RlbFxcJ3Mgcm93IGluZGV4LiAoQWRqdXN0ZWQgZm9yIGRhdGEgcm93IHNjcm9sbGluZyBhZnRlciBmaXhlZCByb3dzLilcXG4nO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKiBcIlZpc2libGVcIiBtZWFucyBzY3JvbGxlZCBpbnRvIHZpZXcuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgKi9cbiAgICBpc1Jvd1Zpc2libGU6ICAgIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuICEhdGhpcy52aXNpYmxlUm93OyB9IH0sXG4gICAgLyoqIFwiVmlzaWJsZVwiIG1lYW5zIHNjcm9sbGVkIGludG8gdmlldy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGlzQ29sdW1uVmlzaWJsZTogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gISF0aGlzLnZpc2libGVDb2x1bW47IH0gfSxcbiAgICAvKiogXCJWaXNpYmxlXCIgbWVhbnMgc2Nyb2xsZWQgaW50byB2aWV3LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgaXNDZWxsVmlzaWJsZTogICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlzUm93VmlzaWJsZSAmJiB0aGlzLmlzQ29sdW1uVmlzaWJsZTsgfSB9LFxuXG5cbiAgICAvKiogQSBkYXRhIHJvdyBpcyBhbnkgcm93IGluIHRoZSBkYXRhIHN1YmdyaWQ7IGFsbCBvdGhlciByb3dzIChoZWFkZXJzLCBmb290ZXJzLCBfZXRjLl8pIGFyZSBub3QgZGF0YSByb3dzLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgaXNEYXRhUm93OiAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnN1YmdyaWQuaXNEYXRhOyB9IH0sXG4gICAgLyoqIEEgZGF0YSBjb2x1bW4gaXMgYW55IGNvbHVtbiB0aGF0IGlzIG5vdCB0aGUgcm93IG51bWJlciBjb2x1bW4gb3IgdGhlIHRyZWUgY29sdW1uLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgaXNEYXRhQ29sdW1uOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmdyaWRDZWxsLnggPj0gMDsgfSB9LFxuICAgIC8qKiBBIGRhdGEgY2VsbCBpcyBhIGNlbGwgaW4gYm90aCBhIGRhdGEgcm93IGFuZCBhIGRhdGEgY29sdW1uLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgaXNEYXRhQ2VsbDogICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlzRGF0YVJvdyAmJiB0aGlzLmlzRGF0YUNvbHVtbjsgfSB9LFxuXG5cbiAgICAvKiogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgKi9cbiAgICBpc1Jvd1NlbGVjdGVkOiAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlzRGF0YVJvdyAmJiB0aGlzLnNlbGVjdGlvbk1vZGVsLmlzUm93U2VsZWN0ZWQodGhpcy5kYXRhQ2VsbC55KTsgfSB9LFxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGlzQ29sdW1uU2VsZWN0ZWQ6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuaXNEYXRhQ29sdW1uICYmIHRoaXMuc2VsZWN0aW9uTW9kZWwuaXNDb2x1bW5TZWxlY3RlZCh0aGlzLmdyaWRDZWxsLngpOyB9IH0sXG4gICAgLyoqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgaXNDZWxsU2VsZWN0ZWQ6ICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5pc0NlbGxTZWxlY3RlZCh0aGlzLmdyaWRDZWxsLngsIHRoaXMuZGF0YUNlbGwueSk7IH0gfSxcblxuXG4gICAgLyoqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgaXNSb3dIb3ZlcmVkOiAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmdyaWQuY2FudmFzLmhhc01vdXNlICYmIHRoaXMuaXNEYXRhUm93ICYmIHRoaXMuZ3JpZC5ob3ZlckNlbGwgJiYgdGhpcy5ncmlkLmhvdmVyQ2VsbC55ID09PSB0aGlzLmdyaWRDZWxsLnk7IH0gfSxcbiAgICAvKiogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgKi9cbiAgICBpc0NvbHVtbkhvdmVyZWQ6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZ3JpZC5jYW52YXMuaGFzTW91c2UgJiYgdGhpcy5pc0RhdGFDb2x1bW4gJiYgdGhpcy5ncmlkLmhvdmVyQ2VsbCAmJiB0aGlzLmdyaWQuaG92ZXJDZWxsLnggPT09IHRoaXMuZ3JpZENlbGwueDsgfSB9LFxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGlzQ2VsbEhvdmVyZWQ6ICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pc1Jvd0hvdmVyZWQgJiYgdGhpcy5pc0NvbHVtbkhvdmVyZWQ7IH0gfSxcblxuXG4gICAgLyoqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgaXNSb3dGaXhlZDogICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pc0RhdGFSb3cgJiYgdGhpcy5kYXRhQ2VsbC55IDwgdGhpcy5ncmlkLnByb3BlcnRpZXMuZml4ZWRSb3dDb3VudDsgfSB9LFxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGlzQ29sdW1uRml4ZWQ6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuaXNEYXRhQ29sdW1uICYmIHRoaXMuZ3JpZENlbGwueCA8IHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLmZpeGVkQ29sdW1uQ291bnQ7IH0gfSxcbiAgICAvKiogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgKi9cbiAgICBpc0NlbGxGaXhlZDogICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlzUm93Rml4ZWQgJiYgdGhpcy5pc0NvbHVtbkZpeGVkOyB9IH0sXG5cblxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGlzSGFuZGxlQ29sdW1uOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmdyaWRDZWxsLnggPT09IHRoaXMuYmVoYXZpb3Iucm93Q29sdW1uSW5kZXggJiYgdGhpcy5ncmlkLnByb3BlcnRpZXMuc2hvd1Jvd051bWJlcnM7IH0gfSxcbiAgICAvKiogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgKi9cbiAgICBpc0hhbmRsZUNlbGw6ICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pc0hhbmRsZUNvbHVtbiAmJiB0aGlzLmlzRGF0YVJvdzsgfSB9LFxuXG5cbiAgICAvKiogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgKi9cbiAgICBpc1RyZWVDb2x1bW46IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZ3JpZENlbGwueCA9PT0gdGhpcy5iZWhhdmlvci50cmVlQ29sdW1uSW5kZXg7IH0gfSxcblxuXG4gICAgLyoqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgaXNIZWFkZXJSb3c6ICAgIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc3ViZ3JpZC5pc0hlYWRlcjsgfSB9LFxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGlzSGVhZGVySGFuZGxlOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlzSGVhZGVyUm93ICYmIHRoaXMuaXNIYW5kbGVDb2x1bW47IH0gfSxcbiAgICAvKiogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgKi9cbiAgICBpc0hlYWRlckNlbGw6ICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pc0hlYWRlclJvdyAmJiB0aGlzLmlzRGF0YUNvbHVtbjsgfSB9LFxuXG5cbiAgICAvKiogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgKi9cbiAgICBpc0ZpbHRlclJvdzogICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zdWJncmlkLmlzRmlsdGVyOyB9IH0sXG4gICAgLyoqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgaXNGaWx0ZXJIYW5kbGU6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuaXNGaWx0ZXJSb3cgJiYgdGhpcy5pc0hhbmRsZUNvbHVtbjsgfSB9LFxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGlzRmlsdGVyQ2VsbDogICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlzRmlsdGVyUm93ICYmIHRoaXMuaXNEYXRhQ29sdW1uOyB9IH0sXG5cblxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGlzU3VtbWFyeVJvdzogICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zdWJncmlkLmlzU3VtbWFyeTsgfSB9LFxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGlzU3VtbWFyeUhhbmRsZTogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pc1N1bW1hcnlSb3cgJiYgdGhpcy5pc0hhbmRsZUNvbHVtbjsgfSB9LFxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGlzU3VtbWFyeUNlbGw6ICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pc1N1bW1hcnlSb3cgJiYgdGhpcy5pc0RhdGFDb2x1bW47IH0gfSxcblxuXG4gICAgLyoqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgaXNUb3BUb3RhbHNSb3c6ICAgIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc3ViZ3JpZCA9PT0gdGhpcy5iZWhhdmlvci5zdWJncmlkcy5sb29rdXAudG9wVG90YWxzOyB9IH0sXG4gICAgLyoqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgaXNUb3BUb3RhbHNIYW5kbGU6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuaXNUb3BUb3RhbHNSb3cgJiYgdGhpcy5pc0hhbmRsZUNvbHVtbjsgfSB9LFxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGlzVG9wVG90YWxzQ2VsbDogICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlzVG9wVG90YWxzUm93ICYmIHRoaXMuaXNEYXRhQ29sdW1uOyB9IH0sXG5cblxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGlzQm90dG9tVG90YWxzUm93OiAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnN1YmdyaWQgPT09IHRoaXMuYmVoYXZpb3Iuc3ViZ3JpZHMubG9va3VwLmJvdHRvbVRvdGFsczsgfSB9LFxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGlzQm90dG9tVG90YWxzSGFuZGxlOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlzQm90dG9tVG90YWxzUm93ICYmIHRoaXMuaXNIYW5kbGVDb2x1bW47IH0gfSxcbiAgICAvKiogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgKi9cbiAgICBpc0JvdHRvbVRvdGFsc0NlbGw6ICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pc0JvdHRvbVRvdGFsc1JvdyAmJiB0aGlzLmlzRGF0YUNvbHVtbjsgfSB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2Mgc2hvd3MsIGlzIGNlbGwgbG9jYXRlZCBpbiBhZ2dyZWdhdGlvbiBjb2x1bW5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGlzQWdncmVnYXRpb25UcmVlQ29sdW1uOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLmNvbHVtbiAmJiB0aGlzLmNvbHVtbi5uYW1lID09PSAnJCRhZ2dyZWdhdGlvbic7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2Mgc2hvd3MsIGlzIGNlbGwgbG9jYXRlZCBpbiBhZ2dyZWdhdGlvbiBjb2x1bW5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGlzQWdncmVnYXRpb25Db2x1bW46IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuY29sdW1uICYmIHRoaXMuY29sdW1uLm5hbWUuc3RhcnRzV2l0aCgnJCRhZ2dyZWdhdGlvbicpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHNob3dzLCBpcyBjZWxsIGxvY2F0ZWQgaW4gYWdncmVnYXRpb24gcm93XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgKi9cbiAgICBpc0FnZ3JlZ2F0aW9uUm93OiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmdyaWQuYmVoYXZpb3IuaXNBZ2dyZWdhdGlvblJvdyh0aGlzLmRhdGFSb3cpOyB9IH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyByZXR1cm5zIGFycmF5IG9mIGNoaWxkIHJvd3Mgb2YgYW4gY3VycmVudCBhZ2dyZWdhdGVkIHJvd1xuICAgICAqIEB0eXBlIHthcnJheX1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGNoaWxkUm93czogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5ncmlkLmJlaGF2aW9yLmdldENoaWxkUm93cyh0aGlzLmRhdGFSb3cpOyB9IH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBzaG93cywgaXMgY2VsbCBsb2NhdGVkIGluIHJvdywgdGhhdCBoYXMgY2hpbGQgcm93c1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgaGFzQ2hpbGRSb3dzOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmdyaWQuYmVoYXZpb3IuaGFzQ2hpbGRSb3dzKHRoaXMuZGF0YVJvdyk7IH0gfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHJldHVybnMgY291bnQgb2YgYWdncmVnYXRlZCBjaGlsZCByb3dzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGFnZ3JlZ2F0aW9uQ2hpbGRDb3VudDogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5ncmlkLmJlaGF2aW9yLmdldEFnZ3JlZ2F0aW9uQ2hpbGRDb3VudCh0aGlzLmRhdGFSb3cpOyB9IH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBzaG93cywgaXMgcm93IGNhbiBiZSBleHBhbmRlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgaXNFeHBhbmRhYmxlUm93OiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmdyaWQuYmVoYXZpb3IuaXNFeHBhbmRhYmxlUm93KHRoaXMuZGF0YVJvdyk7IH0gfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHNob3dzLCBpcyByb3cgYWxyZWFkeSBleHBhbmRlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgaXNSb3dFeHBhbmRlZDogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5ncmlkLmJlaGF2aW9yLmlzUm93RXhwYW5kZWQodGhpcy5kYXRhUm93KTsgfSB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2Mgc2hvd3MsIGlzIHJvdyBjb250YWlucyBncmFuZCB0b3RhbCB2YWx1ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgaXNHcmFuZFRvdGFsUm93OiB7Z2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuICEhdGhpcy5kYXRhUm93ICYmICEhdGhpcy5kYXRhUm93LiQkZ3JhbmRfdG90YWw7IH19LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgdHJlZSBsZXZlbCBvZiBhbiByb3dcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgdHJlZUxldmVsOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmdyaWQuYmVoYXZpb3IuZ2V0Um93VHJlZUxldmVsKHRoaXMuZGF0YVJvdyk7IH0gfSxcblxuICAgICQkQ0xBU1NfTkFNRTogeyB2YWx1ZTogJ0NlbGxFdmVudCcgfVxufSk7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3JlY3Rhbmd1bGFyJykuUG9pbnQ7XG5cbi8qKlxuICogVmFyaWF0aW9uIG9mIGByZWN0YW5ndWxhci5Qb2ludGAgYnV0IHdpdGggd3JpdGFibGUgYHhgIGFuZCBgeWBcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBXcml0YWJsZVBvaW50KHgsIHkpIHtcbiAgICAvLyBza2lwIHggYW5kIHkgaW5pdGlhbGl6YXRpb24gaGVyZSBmb3IgcGVyZm9ybWFuY2VcbiAgICAvLyBiZWNhdXNlIHR5cGljYWxseSByZXNldCBhZnRlciBpbnN0YW50aWF0aW9uXG59XG5cbldyaXRhYmxlUG9pbnQucHJvdG90eXBlID0gUG9pbnQucHJvdG90eXBlO1xuXG5cbnZhciB3cml0YWJsZURlc2NyaXB0b3IgPSB7IHdyaXRhYmxlOiB0cnVlIH07XG52YXIgZXVtZXJhYmxlRGVzY3JpcHRvciA9IHsgd3JpdGFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUgfTtcblxuLyoqIEB0eXBlZGVmIHtXcml0YWJsZVBvaW50fSBkYXRhQ2VsbENvb3Jkc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHggLSBUaGUgZGF0YSBtb2RlbCdzIGNvbHVtbiBpbmRleCwgdW5hZmZlY3RlZCBieSBjb2x1bW4gc2Nyb2xsaW5nOyBfaS5lLixfXG4gKiBhbiBpbmRleCBzdWl0YWJsZSBmb3IgZGVyZWZlcmVuY2luZyB0aGUgY29sdW1uIG9iamVjdCB0byB3aGljaCB0aGUgY2VsbCBiZWxvbmdzIHZpYSB7QGxpbmsgQmVoYXZpb3IjZ2V0Q29sdW1ufS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IC0gVGhlIGRhdGEgbW9kZWwncyByb3cgaW5kZXgsIGFkanVzdGVkIGZvciBkYXRhIHJvdyBzY3JvbGxpbmcgYWZ0ZXIgZml4ZWQgcm93cy5cbiAqL1xuXG4vKiogQHR5cGVkZWYge1dyaXRhYmxlUG9pbnR9IGdyaWRDZWxsQ29vcmRzXG4gKiBAcHJvcGVydHkge251bWJlcn0geCAtIFRoZSBhY3RpdmUgY29sdW1uIGluZGV4LCBhZGp1c3RlZCBmb3IgY29sdW1uIHNjcm9sbGluZyBhZnRlciBmaXhlZCBjb2x1bW5zOyBfaS5lLixfXG4gKiBhbiBpbmRleCBzdWl0YWJsZSBmb3IgZGVyZWZlcmVuY2luZyB0aGUgY29sdW1uIG9iamVjdCB0byB3aGljaCB0aGUgY2VsbCBiZWxvbmdzIHZpYSB7QGxpbmsgQmVoYXZpb3IjZ2V0QWN0aXZlQ29sdW1ufS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IC0gVGhlIHZlcnRpY2FsIGdyaWQgY29vcmRpbmF0ZSwgdW5hZmZlY3RlZCBieSBzdWJncmlkLCByb3cgc2Nyb2xsaW5nLCBhbmQgZml4ZWQgcm93cy5cbiAqL1xuXG4vKipcbiAqIEBuYW1lIGNlbGxFdmVudEZhY3RvcnlcbiAqXG4gKiBAc3VtbWFyeSBDcmVhdGUgYSBjdXN0b20gYENlbGxFdmVudGAgY2xhc3MuXG4gKlxuICogQGRlc2MgQ3JlYXRlIGEgY3VzdG9tIGRlZmluaXRpb24gb2YgYENlbGxFdmVudGAgZm9yIGVhY2ggZ3JpZCBpbnN0YW5jZSwgc2V0dGluZyB0aGUgYGdyaWRgLCBgYmVoYXZpb3JgLCBhbmQgYGRhdGFNb2RlbGAgcHJvcGVydGllcyBvbiB0aGUgcHJvdG90eXBlLiBBcyB0aGlzIGhhcHBlbnMgb25jZSBwZXIgZ3JpZCBpbnN0YW50aWF0aW9uLCBpdCBhdm9pZHMgaGF2aW5nIHRvIHBlcmZvcm0gdGhpcyBzZXQgdXAgd29yayBvbiBldmVyeSBgQ2VsbEV2ZW50YCBpbnN0YW50aWF0aW9uLlxuICpcbiAqIEBwYXJhbSB7SHlwZXJHcmlkfSBncmlkXG4gKlxuICogQHJldHVybnMge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBmYWN0b3J5KGdyaWQpIHtcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBDZWxsRXZlbnQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGNsYXNzZGVzYyBgQ2VsbEV2ZW50YCBpcyBhIHZlcnkgbG93LWxldmVsIG9iamVjdCB0aGF0IG5lZWRzIHRvIGJlIHN1cGVyLWVmZmljaWVudC4gSmF2YVNjcmlwdCBvYmplY3RzIGFyZSB3ZWxsIGtub3duIHRvIGJlIGxpZ2h0IHdlaWdodCBpbiBnZW5lcmFsLCBidXQgYXQgdGhpcyBsZXZlbCB3ZSBuZWVkIHRvIGJlIGNhcmVmdWwuXG4gICAgICpcbiAgICAgKiBUaGVzZSBvYmplY3RzIHdlcmUgb3JpZ2luYWxseSBvbmx5IGJlaW5nIGNyZWF0ZWQgb24gbW91c2UgZXZlbnRzLiBUaGlzIHdhcyBubyBiaWcgZGVhbCBhcyBtb3VzZSBldmVudHMgYXJlIGZldyBhbmQgZmFyIGJldHdlZW4uIEhvd2V2ZXIsIGFzIG9mIHYxLjIuMCwgdGhlIHJlbmRlcmVyIG5vdyBhbHNvIGNyZWF0ZXMgb25lIGZvciBlYWNoIHZpc2libGUgY2VsbCBvbiBlYWNoIGFuZCBldmVyeSBncmlkIHBhaW50LlxuICAgICAqXG4gICAgICogRm9yIHRoaXMgcmVhc29uLCB0byBtYWludGFpbiBwZXJmb3JtYW5jZSwgZWFjaCBncmlkIGdldHMgYSBjdXN0b20gZGVmaW5pdGlvbiBvZiBgQ2VsbEV2ZW50YCwgY3JlYXRlZCBieSB0aGlzIGNsYXNzIGZhY3RvcnksIHdpdGggdGhlIGZvbGxvd2luZyBvcHRpbWl6YXRpb25zOlxuICAgICAqXG4gICAgICogKiBVc2Ugb2YgYGV4dGVuZC1tZWAgaXMgYXZvaWRlZCBiZWNhdXNlIGl0cyBgaW5pdGlhbGl6ZWAgY2hhaW4gaXMgYSBiaXQgdG9vIGhlYXZ5IGhlcmUuXG4gICAgICogKiBDdXN0b20gdmVyc2lvbnMgb2YgYENlbGxFdmVudGAgZm9yIGVhY2ggZ3JpZCBsaWdodGVucyB0aGUgbG9hZCBvbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAZGVzYyBBbGwgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgbWl4ZWQgaW50byBjZWxsIGVkaXRvcjpcbiAgICAgKiAqIEluY2x1ZGVzIGB0aGlzLmNvbHVtbmAgZGVmaW5lZCBieSBjb25zdHJ1Y3RvciAoYXMgZW51bWVyYWJsZSkuXG4gICAgICogKiBFeGNsdWRlcyBhbGwgb3RoZXIgcHJvcGVydGllcyBkZWZpbmVkIGJ5IGNvbnN0cnVjdG9yIGFuZCBwcm90b3R5cGUsIGFsbCBvZiB3aGljaCBhcmUgbm9uLWVudW1lcmFibGUuXG4gICAgICogKiBBbnkgYWRkaXRpb25hbCAoZW51bWVyYWJsZSkgbWVtYmVycyBtaXhlZCBpbiBieSBhcHBsaWNhdGlvbidzIGBnZXRDZWxsRWRpdG9yQXRgIG92ZXJyaWRlLlxuICAgICAqXG4gICAgICogSW5jbHVkaW5nIHRoZSBwYXJhbXMgY2FsbHMge0BsaW5rIENlbGxFdmVudCNyZXNldEdyaWRDWSByZXNldEdyaWRDWShncmlkWCwgZ3JpZFkpfS5cbiAgICAgKiBBbHRlcm5hdGl2ZWx5LCBpbnN0YW50aWF0ZSB3aXRob3V0IHBhcmFtcyBhbmQvb3IgbGF0ZXIgY2FsbCBvbmUgb2YgdGhlc2U6XG4gICAgICogKiB7QGxpbmsgQ2VsbEV2ZW50I3Jlc2V0R3JpZFhZIHJlc2V0R3JpZFhZKC4uLil9XG4gICAgICogKiB7QGxpbmsgQ2VsbEV2ZW50I3Jlc2V0RGF0YVhZIHJlc2V0RGF0YVhZKC4uLil9XG4gICAgICogKiB7QGxpbmsgQ2VsbEV2ZW50I3Jlc2V0R3JpZFhEYXRhWSByZXNldEdyaWRYRGF0YVkoLi4uKX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZ3JpZFhdIC0gZ3JpZCBjZWxsIGNvb3JkaW5hdGUgKGFkanVzdGVkIGZvciBob3Jpem9udGFsIHNjcm9sbGluZyBhZnRlciBmaXhlZCBjb2x1bW5zKS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2dyaWRZXSAtIGdyaWQgY2VsbCBjb29yZGluYXRlLCBhZGp1c3RlZCAoYWRqdXN0ZWQgZm9yIHZlcnRpY2FsIHNjcm9sbGluZyBpZiBkYXRhIHN1YmdyaWQpXG4gICAgICogQGNvbnN0cnVjdG9yIENlbGxFdmVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENlbGxFdmVudChncmlkWCwgZ3JpZFkpIHtcbiAgICAgICAgLy8gcmVtYWluaW5nIGluc3RhbmNlIHZhcnMgYXJlIG5vbi1lbnVtZXJhYmxlIHNvIGBDZWxsRWRpdG9yYCBjb25zdHJ1Y3RvciB3b24ndCBtaXggdGhlbSBpbiAoZm9yIG11c3RhY2hlIHVzZSkuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG5hbWUgdmlzaWJsZUNvbHVtblxuICAgICAgICAgICAgICogQHR5cGUge3Zpc2libGVDb2x1bW5BcnJheX1cbiAgICAgICAgICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2libGVDb2x1bW46IHdyaXRhYmxlRGVzY3JpcHRvcixcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbmFtZSB2aXNpYmxlUm93XG4gICAgICAgICAgICAgKiBAdHlwZSB7dmlzaWJsZVJvd0FycmF5fVxuICAgICAgICAgICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaWJsZVJvdzogd3JpdGFibGVEZXNjcmlwdG9yLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBuYW1lIHN1YmdyaWRcbiAgICAgICAgICAgICAqIEB0eXBlIHtkYXRhTW9kZWxBUEl9XG4gICAgICAgICAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzdWJncmlkOiB3cml0YWJsZURlc2NyaXB0b3IsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG5hbWUgZ3JpZENlbGxcbiAgICAgICAgICAgICAqIEB0eXBlIHtncmlkQ2VsbENvb3Jkc31cbiAgICAgICAgICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdyaWRDZWxsOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBXcml0YWJsZVBvaW50XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBuYW1lIGRhdGFDZWxsXG4gICAgICAgICAgICAgKiBAdHlwZSB7ZGF0YUNlbGxDb29yZHN9XG4gICAgICAgICAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkYXRhQ2VsbDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgV3JpdGFibGVQb2ludFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbmFtZSB2YWx1ZUNlbGxcbiAgICAgICAgICAgICAqIEB0eXBlIHtkYXRhQ2VsbENvb3Jkc31cbiAgICAgICAgICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhbHVlQ2VsbDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgV3JpdGFibGVQb2ludFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgY2VsbCdzIHtAbGluayBDb2x1bW59IG9iamVjdC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGlzIHByb3BlcnR5IGlzIGVudW1lcmFibGUgc28gdGhhdCBpdCB3aWxsIGJlIGNvcGllZCB0byBjZWxsIGVkaXRvciBvbiB7QGxpbmsgQ2VsbEVkaXRvcn0gaW5zdGFudGlhdGlvbi5cbiAgICAgICAgICAgICAqIEBuYW1lIGNvbHVtblxuICAgICAgICAgICAgICogQHR5cGUge0NvbHVtbn1cbiAgICAgICAgICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbHVtbjogZXVtZXJhYmxlRGVzY3JpcHRvcixcblxuICAgICAgICAgICAgLy8gZ2V0dGVyIGNhY2hlc1xuICAgICAgICAgICAgX2NvbHVtblByb3BlcnRpZXM6IHdyaXRhYmxlRGVzY3JpcHRvcixcbiAgICAgICAgICAgIF9jZWxsT3duUHJvcGVydGllczogd3JpdGFibGVEZXNjcmlwdG9yLFxuICAgICAgICAgICAgX2NlbGxPd25EZWZpbmVkUHJvcGVydGllczogd3JpdGFibGVEZXNjcmlwdG9yLFxuICAgICAgICAgICAgX2JvdW5kczogd3JpdGFibGVEZXNjcmlwdG9yLFxuXG4gICAgICAgICAgICAvLyBGb2xsb3dpbmcgc3VwcG9ydHMgY2VsbCByZW5kZXJlcnMnIFwicGFydGlhbCByZW5kZXJcIiBjYXBhYmlsaXR5OlxuICAgICAgICAgICAgc25hcHNob3Q6IHdyaXRhYmxlRGVzY3JpcHRvcixcbiAgICAgICAgICAgIG1pbldpZHRoOiB3cml0YWJsZURlc2NyaXB0b3IsXG4gICAgICAgICAgICBkaXNhYmxlZDogd3JpdGFibGVEZXNjcmlwdG9yXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0R3JpZENZKGdyaWRYLCBncmlkWSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBDZWxsRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjZWxsRXZlbnRQcm9wZXJ0aWVzLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBDZWxsRXZlbnQgfSxcbiAgICAgICAgZ3JpZDogeyB2YWx1ZTogZ3JpZCB9LFxuICAgICAgICByZW5kZXJlcjogeyB2YWx1ZTogZ3JpZC5yZW5kZXJlciB9LFxuICAgICAgICBzZWxlY3Rpb25Nb2RlbDogeyB2YWx1ZTogZ3JpZC5zZWxlY3Rpb25Nb2RlbCB9LFxuICAgICAgICBiZWhhdmlvcjogeyB2YWx1ZTogZ3JpZC5iZWhhdmlvciB9LFxuICAgICAgICBkYXRhTW9kZWw6IHsgdmFsdWU6IGdyaWQuYmVoYXZpb3IuZGF0YU1vZGVsIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBDZWxsRXZlbnQ7XG59XG5cbmZ1bmN0aW9uIHNoYWxsb3dDbG9uZShvYmopIHtcbiAgICBjb25zdCBjbG9uZSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikpO1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikuZm9yRWFjaCgoa2V5KSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xvbmUsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkpKTtcbiAgICByZXR1cm4gY2xvbmU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gY29uc29sZS53YXJuIHBvbHlmaWxsIGFzIG5lZWRlZFxuLy8gdXNlZCBmb3IgZGVwcmVjYXRpb24gd2FybmluZ3NcbmlmICghY29uc29sZS53YXJuKSB7XG4gICAgY29uc29sZS53YXJuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIFsnV0FSTklORzonXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG59XG5cbnZhciByZWdleElzTWV0aG9kID0gL15bXFx3XFwuXStcXCguKlxcKSQvO1xuXG4vKipcbiAqIFVzZXIgaXMgd2FybmVkIGFuZCBuZXcgcHJvcGVydHkgaXMgcmV0dXJuZWQgb3IgbmV3IG1ldGhvZCBpcyBjYWxsZWQgYW5kIHRoZSByZXN1bHQgaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSAtIFdhcm5pbmcga2V5IHBhaXJlZCB3aXRoIGFyYml0cmFyeSB3YXJuaW5nIGluIGBkb3RQcm9wc2AgT1IgZGVwcmVjYXRlZCBtZXRob2QgbmFtZSB3aXRoIHBhcmVudGhlc2VzIGNvbnRhaW5pbmcgb3B0aW9uYWwgYXJndW1lbnQgbGlzdCBwYWlyZWQgd2l0aCByZXBsYWNlbWVudCBwcm9wZXJ0eSBvciBtZXRob2QgaW4gYGRvdFByb3BzYC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkb3RQcm9wcyAtIEFyYml0cmFyeSB3YXJuaW5nIHBhaXJlZCB3aXRoIHdhcm5pbmcga2V5IGluIGBtZXRob2ROYW1lYCBPUiBkb3Qtc2VwYXJhdGVkIG5ldyBwcm9wZXJ0eSBuYW1lIHRvIGludm9rZSBvciBtZXRob2QgbmFtZSB0byBjYWxsLiBNZXRob2QgbmFtZXMgYXJlIGluZGljYXRlZCBieSBpbmNsdWRpbmcgcGFyZW50aGVzZXMgd2l0aCBvcHRpb25hbCBhcmd1bWVudCBsaXN0LiBUaGUgYXJndW1lbnRzIGluIGVhY2ggbGlzdCBhcmUgZHJhd24gZnJvbSB0aGUgYXJndW1lbnRzIHByZXNlbnRlZCBpbiB0aGUgYG1ldGhvZE5hbWVgIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzaW5jZSAtIFZlcnNpb24gaW4gd2hpY2ggdGhlIG5hbWUgd2FzIGRlcHJlY2F0ZWQuXG4gKiBAcGFyYW0ge0FyZ3VtZW50c3xBcnJheX0gW2FyZ3NdIC0gVGhlIGFjdHVhbCBhcmd1bWVudHMgaW4gdGhlIG9yZGVyIGxpc3RlZCBpbiBgbWV0aG9kTmFtZWAuIE9ubHkgbmVlZGVkIHdoZW4gYXJndW1lbnRzIG5lZWQgdG8gYmUgZm9yd2FyZGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtub3Rlc10gLSBOb3RlcyB0byBhZGQgdG8gbWVzc2FnZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm4gdmFsdWUgb2YgbmV3IHByb3BlcnR5IG9yIG1ldGhvZCBjYWxsLlxuICovXG52YXIgZGVwcmVjYXRlZCA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGRvdFByb3BzLCBzaW5jZSwgYXJncywgbm90ZXMpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIGBhcmdzYCBvbWl0dGVkXG4gICAgICAgIG5vdGVzID0gYXJncztcbiAgICAgICAgYXJncyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgY2hhaW4gPSBkb3RQcm9wcy5zcGxpdCgnLicpLFxuICAgICAgICB3YXJuZWQgPSB0aGlzLiQkREVQUkVDQVRJT05fV0FSTkVEID0gdGhpcy4kJERFUFJFQ0FUSU9OX1dBUk5FRCB8fCB7fSxcbiAgICAgICAgcmVzdWx0ID0gdGhpcyxcbiAgICAgICAgaXNTaW1wbGVXYXJuaW5nID0gZG90UHJvcHMuaW5kZXhPZignICcpID49IDAsXG4gICAgICAgIGlzTWV0aG9kQ2FsbCA9IHJlZ2V4SXNNZXRob2QudGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgbWVtYmVyVHlwZSxcbiAgICAgICAgd2FybmluZztcblxuICAgIGlmICghKG1ldGhvZE5hbWUgaW4gd2FybmVkKSkge1xuICAgICAgICB3YXJuZWRbbWV0aG9kTmFtZV0gPSBkZXByZWNhdGVkLndhcm5pbmdzO1xuICAgIH1cblxuICAgIGlmIChpc01ldGhvZENhbGwpIHtcbiAgICAgICAgaWYgKGlzU2ltcGxlV2FybmluZykge1xuICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIHJlcGxhY2VtZW50IG1ldGhvZCBvciBwcm9wZXJ0eSBpbiAybmQgcGFyYW1ldGVyIG9mIGRlcHJlY2F0ZWQoKSBjYWxsLic7XG4gICAgICAgIH0gZWxzZSBpZiAod2FybmVkW21ldGhvZE5hbWVdKSB7XG4gICAgICAgICAgICAtLXdhcm5lZFttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIG1lbWJlclR5cGUgPSByZWdleElzTWV0aG9kLnRlc3QoZG90UHJvcHMpID8gJ21ldGhvZCcgOiAncHJvcGVydHknO1xuICAgICAgICAgICAgd2FybmluZyA9ICdUaGUgLicgKyBtZXRob2ROYW1lICsgJyBtZXRob2QgaGFzIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2JyArIHNpbmNlICtcbiAgICAgICAgICAgICAgICAnIGluIGZhdm9yIG9mIHRoZSAuJyArIGNoYWluLmpvaW4oJy4nKSArICcgJyArIG1lbWJlclR5cGUgKyAnLicgK1xuICAgICAgICAgICAgICAgICcgKFdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiknO1xuXG4gICAgICAgICAgICBpZiAobm90ZXMpIHtcbiAgICAgICAgICAgICAgICB3YXJuaW5nICs9ICcgJyArIG5vdGVzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4od2FybmluZyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzU2ltcGxlV2FybmluZykge1xuICAgICAgICBpZiAod2FybmVkW21ldGhvZE5hbWVdKSB7XG4gICAgICAgICAgICAtLXdhcm5lZFttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybihkb3RQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93ICdFeHBlY3RlZCBtZXRob2QgbmFtZSB3aXRoIHBhcmVudGhlc2VzIGluIDFzdCBwYXJhbWV0ZXIgT1Igc2ltcGxlIHdhcm5pbmcgKGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgc3BhY2VzKSBpbiAybmQgcGFyYW1ldGVyIG9mIGRlcHJlY2F0ZWQoKSBjYWxsLic7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hbEFyZ0xpc3QgPSBhcmdMaXN0KG1ldGhvZE5hbWUpO1xuXG4gICAgZnVuY3Rpb24gbWFwVG9Gb3JtYWxBcmcoYXJnTmFtZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBmb3JtYWxBcmdMaXN0LmluZGV4T2YoYXJnTmFtZSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93ICdBY3R1YWwgYXJnIFwiJyArIGFyZ05hbWUgKyAnXCIgbm90IGZvdW5kIGluIGZvcm1hbCBhcmcgbGlzdCAnICsgZm9ybWFsQXJnTGlzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnc1tpbmRleF07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxhc3QgPSBjaGFpbi5sZW5ndGggLSAxOyBpIDw9IGxhc3Q7ICsraSkge1xuICAgICAgICB2YXIgbGluayA9IGNoYWluW2ldLFxuICAgICAgICAgICAgbmFtZSA9IGxpbmsubWF0Y2goL1xcdysvKVswXSxcbiAgICAgICAgICAgIGxpbmtJc01ldGhvZENhbGwgPSByZWdleElzTWV0aG9kLnRlc3QobGluayksXG4gICAgICAgICAgICBhY3R1YWxBcmdMaXN0ID0gbGlua0lzTWV0aG9kQ2FsbCA/IGFyZ0xpc3QobGluaykgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhY3R1YWxBcmdzID0gW107XG5cbiAgICAgICAgaWYgKGFjdHVhbEFyZ0xpc3QpIHtcbiAgICAgICAgICAgIGFjdHVhbEFyZ3MgPSBhY3R1YWxBcmdMaXN0Lm1hcChtYXBUb0Zvcm1hbEFyZyk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRbbmFtZV0uYXBwbHkocmVzdWx0LCBhY3R1YWxBcmdzKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaW5rSXNNZXRob2RDYWxsKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRbbmFtZV0oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFtuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5kZXByZWNhdGVkLndhcm5pbmdzID0gMTsgLy8gMyBvciA1IHdvdWxkIGdldCBtb3JlIGF0dGVudGlvblxuXG5mdW5jdGlvbiBhcmdMaXN0KHMpIHtcbiAgICByZXR1cm4gcy5tYXRjaCgvXlxcdytcXCgoLiopXFwpJC8pWzFdLm1hdGNoKC8oXFx3KykvZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlZDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHdhcm5lZERvdWJsZUNsaWNrRGVsYXk7XG5cbi8qKlxuICogQHN1bW1hcnkgRHluYW1pYyBncmlkIHByb3BlcnR5IGdldHRlci9zZXR0ZXJzLlxuICogQGRlc2MgIER5bmFtaWMgZ3JpZCBwcm9wZXJ0aWVzIGNhbiBtYWtlIHVzZSBvZiBhIF9iYWNraW5nIHN0b3JlLl9cbiAqIFRoaXMgYmFja2luZyBzdG9yZSBpcyBjcmVhdGVkIGluIHRoZSBzYW1lIGxheWVyICh0aGUgZ3JpZCBwcm9wZXJ0aWVzIGxheWVyKSBieSB7QGxpbmsgSHlwZXJncmlkI2NsZWFyU3RhdGV8Y2xlYXJTdGF0ZX0gYW5kIGJhY2tzIGdyaWQtb25seSBwcm9wZXJ0aWVzLiBXZSBjdXJyZW50bHkgZG8gbm90IGNyZWF0ZSBvbmUgZm9yIGRlc2NlbmRhbnQgb2JqZWN0cywgc3VjaCBhcyBjb2x1bW4gYW5kIGNlbGwgcHJvcGVydGllcyBvYmplY3RzLlxuICogVGhlIG1lbWJlcnMgb2YgdGhlIGJhY2tpbmcgc3RvcmUgaGF2ZSB0aGUgc2FtZSBuYW1lcyBhcyB0aGUgZHluYW1pYyBwcm9wZXJ0aWVzIHRoYXQgdXRpbGl6ZSB0aGVtLlxuICogVGhleSBhcmUgaW5pdGlhbGl6ZWQgYnkge0BsaW5rIEh5cGVyZ3JpZCNjbGVhclN0YXRlfGNsZWFyU3RhdGV9IHRvIHRoZSBkZWZhdWx0IHZhbHVlcyBmcm9tIHtAbGluayBtb2R1bGU6ZGVmYXVsdHN8ZGVmYXVsdHN9IG9iamVjdCBtZW1iZXJzLCAoYWxzbykgb2YgdGhlIHNhbWUgbmFtZS5cbiAqXG4gKiBOb3RlIHRoYXQgZHluYW1pYyBwcm9wZXJ0aWVzIG11c3QgZW51bWVyYWJsZSB0byBiZSB2aXNpYmxlIHRvIHtAbGluayBIeXBlcmdyaWQjc2F2ZVN0YXRlfS5cbiAqIEBuYW1lIGR5bmFtaWNQcm9wZXJ0eURlc2NyaXB0b3JzXG4gKiBAbW9kdWxlXG4gKi9cbnZhciBkeW5hbWljUHJvcGVydHlEZXNjcmlwdG9ycyA9IHtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZHxvYmplY3R9IE9uZSBvZjpcbiAgICAgKiAqICoqc3RyaW5nOioqIFdoZW4gdGhlbWUgbmFtZSBpcyByZWdpc3RlcmVkIChleGNlcHQgJ2RlZmF1bHQnKS5cbiAgICAgKiAqICoqdW5kZWZpbmVkOioqIFdoZW4gdGhlbWUgbGF5ZXIgaXMgZW1wdHkgKG9yIHRoZW1lIG5hbWUgaXMgJ2RlZmF1bHQnKS5cbiAgICAgKiAqICoqb2JqZWN0OioqIFdoZW4gdGhlbWUgbmFtZSBpcyBub3QgcmVnaXN0ZXJlZC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmR5bmFtaWNQcm9wZXJ0eURlc2NyaXB0b3JzXG4gICAgICovXG4gICAgdGhlbWU6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0VGhlbWUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih0aGVtZSkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmFwcGx5VGhlbWUodGhlbWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZHluYW1pY1Byb3BlcnR5RGVzY3JpcHRvcnNcbiAgICAgKi9cbiAgICBzdWJncmlkczoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFyLnN1YmdyaWRzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHN1YmdyaWRzKSB7XG4gICAgICAgICAgICB0aGlzLnZhci5zdWJncmlkcyA9IHN1YmdyaWRzLnNsaWNlKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWQuYmVoYXZpb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQuYmVoYXZpb3Iuc3ViZ3JpZHMgPSBzdWJncmlkcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmR5bmFtaWNQcm9wZXJ0eURlc2NyaXB0b3JzXG4gICAgICovXG4gICAgZmVhdHVyZXM6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhci5mZWF0dXJlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihmZWF0dXJlcykge1xuICAgICAgICAgICAgdGhpcy52YXIuZmVhdHVyZXMgPSBmZWF0dXJlcy5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZC5iZWhhdmlvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5iZWhhdmlvci5pbml0aWFsaXplRmVhdHVyZUNoYWluKGZlYXR1cmVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQuYWxsb3dFdmVudHModGhpcy5ncmlkLmdldFJvd0NvdW50KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZHluYW1pY1Byb3BlcnR5RGVzY3JpcHRvcnNcbiAgICAgKi9cbiAgICBncmlkUmVuZGVyZXI6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhci5ncmlkUmVuZGVyZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24ocmVuZGVyZXJOYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnZhci5ncmlkUmVuZGVyZXIgPSByZW5kZXJlck5hbWU7XG4gICAgICAgICAgICB0aGlzLmdyaWQucmVuZGVyZXIuc2V0R3JpZFJlbmRlcmVyKHJlbmRlcmVyTmFtZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkeW5hbWljUHJvcGVydHlEZXNjcmlwdG9yc1xuICAgICAqL1xuICAgIGNvbHVtbkluZGV4ZXM6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyaWQuYmVoYXZpb3IuZ2V0QWN0aXZlQ29sdW1ucygpLm1hcChmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uLmluZGV4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oY29sdW1uSW5kZXhlcykge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmJlaGF2aW9yLnNldENvbHVtbk9yZGVyKGNvbHVtbkluZGV4ZXMpO1xuICAgICAgICAgICAgdGhpcy5ncmlkLmJlaGF2aW9yLmNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmR5bmFtaWNQcm9wZXJ0eURlc2NyaXB0b3JzXG4gICAgICovXG4gICAgY29sdW1uTmFtZXM6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyaWQuYmVoYXZpb3IuZ2V0QWN0aXZlQ29sdW1ucygpLm1hcChmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uLm5hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihjb2x1bW5OYW1lcykge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmJlaGF2aW9yLnNldENvbHVtbk9yZGVyQnlOYW1lKGNvbHVtbk5hbWVzKTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5iZWhhdmlvci5jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkeW5hbWljUHJvcGVydHlEZXNjcmlwdG9yc1xuICAgICAqL1xuICAgIHJvd3M6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBnZXRSb3dQcm9wZXJ0aWVzQnlTdWJncmlkQW5kUm93SW5kZXgsXG4gICAgICAgIHNldDogZnVuY3Rpb24ocm93c0hhc2gpIHtcbiAgICAgICAgICAgIGlmIChyb3dzSGFzaCkge1xuICAgICAgICAgICAgICAgIHNldFJvd1Byb3BlcnRpZXNCeVN1YmdyaWRBbmRSb3dJbmRleC5jYWxsKHRoaXMsIHJvd3NIYXNoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQuYmVoYXZpb3IuY2hhbmdlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZHluYW1pY1Byb3BlcnR5RGVzY3JpcHRvcnNcbiAgICAgKi9cbiAgICBjb2x1bW5zOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZ2V0Q29sdW1uUHJvcGVydGllc0J5Q29sdW1uTmFtZSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihjb2x1bW5zSGFzaCkge1xuICAgICAgICAgICAgaWYgKGNvbHVtbnNIYXNoKSB7XG4gICAgICAgICAgICAgICAgc2V0Q29sdW1uUHJvcGVydGllc0J5Q29sdW1uTmFtZS5jYWxsKHRoaXMsIGNvbHVtbnNIYXNoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQuYmVoYXZpb3IuY2hhbmdlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZHluYW1pY1Byb3BlcnR5RGVzY3JpcHRvcnNcbiAgICAgKi9cbiAgICBjZWxsczoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGdldENlbGxQcm9wZXJ0aWVzQnlDb2x1bW5OYW1lQW5kUm93SW5kZXgsXG4gICAgICAgIHNldDogZnVuY3Rpb24oY2VsbHNIYXNoKSB7XG4gICAgICAgICAgICBpZiAoY2VsbHNIYXNoKSB7XG4gICAgICAgICAgICAgICAgc2V0Q2VsbFByb3BlcnRpZXNCeUNvbHVtbk5hbWVBbmRSb3dJbmRleC5jYWxsKHRoaXMsIGNlbGxzSGFzaCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLmJlaGF2aW9yLmNoYW5nZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmR5bmFtaWNQcm9wZXJ0eURlc2NyaXB0b3JzXG4gICAgICovXG4gICAgcm93SGVhZGVyQ2hlY2tib3hlczoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFyLnJvd0hlYWRlckNoZWNrYm94ZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy52YXIucm93SGVhZGVyQ2hlY2tib3hlcyA9IGVuYWJsZWQ7XG4gICAgICAgICAgICB0aGlzLmdyaWQucmVuZGVyZXIucmVzZXRSb3dIZWFkZXJDb2x1bW5XaWR0aCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZHluYW1pY1Byb3BlcnR5RGVzY3JpcHRvcnNcbiAgICAgKi9cbiAgICByb3dIZWFkZXJOdW1iZXJzOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YXIucm93SGVhZGVyTnVtYmVycztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnZhci5yb3dIZWFkZXJOdW1iZXJzID0gZW5hYmxlZDtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5yZW5kZXJlci5yZXNldFJvd0hlYWRlckNvbHVtbldpZHRoKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGVnYWN5IHByb3BlcnR5OyBub3cgcG9pbnRzIHRvIGJvdGggYHJvd0hlYWRlckZlYXR1cmVzYCBwcm9wcy5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmR5bmFtaWNQcm9wZXJ0eURlc2NyaXB0b3JzXG4gICAgICovXG4gICAgc2hvd1Jvd051bWJlcnM6IHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dIZWFkZXJDaGVja2JveGVzIHx8IHRoaXMucm93SGVhZGVyTnVtYmVycztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJvd0hlYWRlckNoZWNrYm94ZXMgPSB0aGlzLnJvd0hlYWRlck51bWJlcnMgPSBlbmFibGVkO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIHJlbW92ZSB0byBleHBpcmUgd2FybmluZzpcbiAgICBkb3VibGVDbGlja0RlbGF5OiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YXIuZG91YmxlQ2xpY2tEZWxheTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihkZWxheSkge1xuICAgICAgICAgICAgaWYgKCF3YXJuZWREb3VibGVDbGlja0RlbGF5KSB7XG4gICAgICAgICAgICAgICAgd2FybmVkRG91YmxlQ2xpY2tEZWxheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgZG91YmxlQ2xpY2tEZWxheSBwcm9wZXJ0eSBoYXMgYmVlbiBkZXByZWNhdGVkIGFzIG9mIHYyLjEuMC4gU2V0dGluZyB0aGlzIHByb3BlcnR5IG5vIGxvbmdlciBoYXMgYW55IGVmZmVjdC4gU2V0IGRvdWJsZS1jbGljayBzcGVlZCBpbiB5b3VyIHN5c3RlbVxcJ3MgbW91c2UgcHJlZmVyZW5jZXMuIChUaGlzIHdhcm5pbmcgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52YXIuZG91YmxlQ2xpY2tEZWxheSA9IGRlbGF5O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgZ3JpZCBsaW5lIHByb3BzIGFyZSBub3cgZHluYW1pYyAoYXMgb2YgdjIuMS4wKS5cbiAgICAvLyBUaGV5J3JlIG5vbi1lbnVtZXJhYmxlIHNvIHRoZXkgd2lsbCBub3QgYmUgb3V0cHV0IHdpdGggYGdyaWQuc2F2ZVN0YXRlKClgLlxuICAgIC8vIFRoZSBuZXcgKGFzIG9mIDIuMS4wKSBwcm9wcyB0aGV5IHJlZmVyIHRvIGFyZSBvdXRwdXQgaW5zdGVhZDpcbiAgICAvLyBgZ3JpZExpbmVzQ29sb3JgLCBgZ3JpZExpbmVzQ29sb3JgLCBgZ3JpZExpbmVzV2lkdGhgLCBhbmQgYGdyaWRMaW5lc1dpZHRoYFxuICAgIGxpbmVDb2xvcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5ncmlkTGluZXNDb2xvcjsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihjb2xvcikgeyB0aGlzLmdyaWRMaW5lc0NvbG9yID0gdGhpcy5ncmlkTGluZXNDb2xvciA9IGNvbG9yOyB9XG4gICAgfSxcblxuICAgIGxpbmVXaWR0aDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5ncmlkTGluZXNXaWR0aDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih3aWR0aCkgeyB0aGlzLmdyaWRMaW5lc1dpZHRoID0gdGhpcy5ncmlkTGluZXNXaWR0aCA9IHdpZHRoOyB9XG4gICAgfSxcblxuICAgIGdyaWRCb3JkZXI6IGdldEdyaWRCb3JkZXJEZXNjcmlwdG9yKCksXG4gICAgZ3JpZEJvcmRlckxlZnQ6IGdldEdyaWRCb3JkZXJEZXNjcmlwdG9yKCdMZWZ0JyksXG4gICAgZ3JpZEJvcmRlclJpZ2h0OiBnZXRHcmlkQm9yZGVyRGVzY3JpcHRvcignUmlnaHQnKSxcbiAgICBncmlkQm9yZGVyVG9wOiBnZXRHcmlkQm9yZGVyRGVzY3JpcHRvcignVG9wJyksXG4gICAgZ3JpZEJvcmRlckJvdHRvbTogZ2V0R3JpZEJvcmRlckRlc2NyaXB0b3IoJ0JvdHRvbScpXG59O1xuXG5mdW5jdGlvbiBnZXRSb3dQcm9wZXJ0aWVzQnlTdWJncmlkQW5kUm93SW5kZXgoKSB7IC8vIHRvIGJlIGNhbGxlZCB3aXRoIGdyaWQucHJvcGVydGllcyBhcyBjb250ZXh0XG4gICAgdmFyIHN1YmdyaWRzID0ge307XG4gICAgdmFyIGJlaGF2aW9yID0gdGhpcy5ncmlkLmJlaGF2aW9yO1xuICAgIGJlaGF2aW9yLnN1YmdyaWRzLmZvckVhY2goZnVuY3Rpb24oZGF0YU1vZGVsKSB7XG4gICAgICAgIHZhciBrZXkgPSBkYXRhTW9kZWwubmFtZSB8fCBkYXRhTW9kZWwudHlwZTtcbiAgICAgICAgZm9yICh2YXIgcm93SW5kZXggPSAwLCByb3dDb3VudCA9IGRhdGFNb2RlbC5nZXRSb3dDb3VudCgpOyByb3dJbmRleCA8IHJvd0NvdW50OyArK3Jvd0luZGV4KSB7XG4gICAgICAgICAgICB2YXIgcm93UHJvcHMgPSBiZWhhdmlvci5nZXRSb3dQcm9wZXJ0aWVzKHJvd0luZGV4LCB1bmRlZmluZWQsIGRhdGFNb2RlbCk7XG4gICAgICAgICAgICBpZiAocm93UHJvcHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViZ3JpZCA9IHN1YmdyaWRzW2tleV0gPSBzdWJncmlkc1trZXldIHx8IHt9O1xuICAgICAgICAgICAgICAgIHN1YmdyaWRbcm93SW5kZXhdID0gcm93UHJvcHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3ViZ3JpZHM7XG59XG5cbmZ1bmN0aW9uIHNldFJvd1Byb3BlcnRpZXNCeVN1YmdyaWRBbmRSb3dJbmRleChyb3dzSGFzaCkgeyAvLyB0byBiZSBjYWxsZWQgd2l0aCBncmlkLnByb3BlcnRpZXMgYXMgY29udGV4dFxuICAgIHZhciBiZWhhdmlvciA9IHRoaXMuZ3JpZC5iZWhhdmlvcjtcbiAgICBmb3IgKHZhciBzdWJncmlkTmFtZSBpbiByb3dzSGFzaCkge1xuICAgICAgICBpZiAocm93c0hhc2guaGFzT3duUHJvcGVydHkoc3ViZ3JpZE5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgc3ViZ3JpZCA9IGJlaGF2aW9yLnN1YmdyaWRzLmxvb2t1cFtzdWJncmlkTmFtZV07XG4gICAgICAgICAgICBpZiAoc3ViZ3JpZCkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJncmlkSGFzaCA9IHJvd3NIYXNoW3N1YmdyaWROYW1lXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByb3dJbmRleCBpbiBzdWJncmlkSGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3ViZ3JpZEhhc2guaGFzT3duUHJvcGVydHkocm93SW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHN1YmdyaWRIYXNoW3Jvd0luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BlcnRpZXNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdoZWlnaHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlaGF2aW9yLnNldFJvd0hlaWdodChyb3dJbmRleCwgTnVtYmVyKHByb3BWYWx1ZSksIHN1YmdyaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1VuZXhwZWN0ZWQgcm93IHByb3BlcnR5IFwiJyArIHByb3BOYW1lICsgJ1wiIGlnbm9yZWQuIChUaGUgb25seSByb3cgcHJvcGVydHkgY3VycmVudGx5IGltcGxlbWVudGVkIGlzIFwiaGVpZ2h0XCIpLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRDb2x1bW5Qcm9wZXJ0aWVzQnlDb2x1bW5OYW1lKCkgeyAvLyB0byBiZSBjYWxsZWQgd2l0aCBncmlkLnByb3BlcnRpZXMgYXMgY29udGV4dFxuICAgIHZhciBjb2x1bW5zID0gdGhpcy5ncmlkLmJlaGF2aW9yLmdldENvbHVtbnMoKSxcbiAgICAgICAgaGVhZGVyaWZ5ID0gdGhpcy5ncmlkLmhlYWRlcmlmeTtcbiAgICByZXR1cm4gY29sdW1ucy5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBjb2x1bW4pIHtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhjb2x1bW4ucHJvcGVydGllcykucmVkdWNlKGZ1bmN0aW9uKHByb3BlcnRpZXMsIGtleSkge1xuICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdwcmVmZXJyZWRXaWR0aCc6IC8vIG5vdCBhIHB1YmxpYyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVyaWZ5ICYmIGNvbHVtbi5wcm9wZXJ0aWVzLmhlYWRlciA9PT0gaGVhZGVyaWZ5KGNvbHVtbi5wcm9wZXJ0aWVzLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbHVtbi5wcm9wZXJ0aWVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqW2NvbHVtbi5uYW1lXSA9IHByb3BlcnRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIHNldENvbHVtblByb3BlcnRpZXNCeUNvbHVtbk5hbWUoY29sdW1uc0hhc2gpIHsgLy8gdG8gYmUgY2FsbGVkIHdpdGggZ3JpZC5wcm9wZXJ0aWVzIGFzIGNvbnRleHRcbiAgICB2YXIgY29sdW1ucyA9IHRoaXMuZ3JpZC5iZWhhdmlvci5nZXRDb2x1bW5zKCk7XG5cbiAgICBmb3IgKHZhciBjb2x1bW5OYW1lIGluIGNvbHVtbnNIYXNoKSB7XG4gICAgICAgIGlmIChjb2x1bW5zSGFzaC5oYXNPd25Qcm9wZXJ0eShjb2x1bW5OYW1lKSkge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IGNvbHVtbnMuZmluZChuYW1lTWF0Y2hlcyk7XG4gICAgICAgICAgICBpZiAoY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uLnByb3BlcnRpZXMgPSBjb2x1bW5zSGFzaFtjb2x1bW5OYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5hbWVNYXRjaGVzKGNvbHVtbikge1xuICAgICAgICByZXR1cm4gY29sdW1uLm5hbWUgPT09IGNvbHVtbk5hbWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRDZWxsUHJvcGVydGllc0J5Q29sdW1uTmFtZUFuZFJvd0luZGV4KCkge1xuICAgIHZhciBiZWhhdmlvciA9IHRoaXMuZ3JpZC5iZWhhdmlvcixcbiAgICAgICAgY29sdW1ucyA9IGJlaGF2aW9yLmdldENvbHVtbnMoKSxcbiAgICAgICAgc3ViZ3JpZHMgPSB7fTtcblxuICAgIGJlaGF2aW9yLnN1YmdyaWRzLmZvckVhY2goZnVuY3Rpb24oZGF0YU1vZGVsKSB7XG4gICAgICAgIHZhciBrZXkgPSBkYXRhTW9kZWwubmFtZSB8fCBkYXRhTW9kZWwudHlwZTtcblxuICAgICAgICBmb3IgKHZhciByb3dJbmRleCA9IDAsIHJvd0NvdW50ID0gZGF0YU1vZGVsLmdldFJvd0NvdW50KCk7IHJvd0luZGV4IDwgcm93Q291bnQ7ICsrcm93SW5kZXgpIHtcbiAgICAgICAgICAgIGNvbHVtbnMuZm9yRWFjaChjb3B5Q2VsbE93blByb3BlcnRpZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29weUNlbGxPd25Qcm9wZXJ0aWVzKGNvbHVtbikge1xuICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBiZWhhdmlvci5nZXRDZWxsT3duUHJvcGVydGllcyhjb2x1bW4uaW5kZXgsIHJvd0luZGV4LCBkYXRhTW9kZWwpO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViZ3JpZCA9IHN1YmdyaWRzW2tleV0gPSBzdWJncmlkc1trZXldIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICByb3cgPSBzdWJncmlkW3Jvd0luZGV4XSA9IHN1YmdyaWRbcm93SW5kZXhdID0ge307XG4gICAgICAgICAgICAgICAgcm93W2NvbHVtbi5uYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIHByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3ViZ3JpZHM7XG59XG5cbmZ1bmN0aW9uIHNldENlbGxQcm9wZXJ0aWVzQnlDb2x1bW5OYW1lQW5kUm93SW5kZXgoY2VsbHNIYXNoKSB7IC8vIHRvIGJlIGNhbGxlZCB3aXRoIGdyaWQucHJvcGVydGllcyBhcyBjb250ZXh0XG4gICAgdmFyIHN1YmdyaWRzID0gdGhpcy5ncmlkLmJlaGF2aW9yLnN1YmdyaWRzLFxuICAgICAgICBjb2x1bW5zID0gdGhpcy5ncmlkLmJlaGF2aW9yLmdldENvbHVtbnMoKTtcblxuICAgIGZvciAodmFyIHN1YmdyaWROYW1lIGluIGNlbGxzSGFzaCkge1xuICAgICAgICBpZiAoY2VsbHNIYXNoLmhhc093blByb3BlcnR5KHN1YmdyaWROYW1lKSkge1xuICAgICAgICAgICAgdmFyIHN1YmdyaWQgPSBzdWJncmlkcy5sb29rdXBbc3ViZ3JpZE5hbWVdO1xuICAgICAgICAgICAgaWYgKHN1YmdyaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViZ3JpZEhhc2ggPSBjZWxsc0hhc2hbc3ViZ3JpZE5hbWVdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHJvd0luZGV4IGluIHN1YmdyaWRIYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJncmlkSGFzaC5oYXNPd25Qcm9wZXJ0eShyb3dJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5Qcm9wcyA9IHN1YmdyaWRIYXNoW3Jvd0luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbHVtbk5hbWUgaW4gY29sdW1uUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uUHJvcHMuaGFzT3duUHJvcGVydHkoY29sdW1uTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IGNvbHVtbnMuZmluZChuYW1lTWF0Y2hlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gY29sdW1uUHJvcHNbY29sdW1uTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uYWRkQ2VsbFByb3BlcnRpZXMocm93SW5kZXgsIHByb3BlcnRpZXMsIHN1YmdyaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmFtZU1hdGNoZXMoY29sdW1uKSB7XG4gICAgICAgIHJldHVybiBjb2x1bW4ubmFtZSA9PT0gY29sdW1uTmFtZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEdyaWRCb3JkZXJEZXNjcmlwdG9yKGVkZ2UpIHtcbiAgICB2YXIgcHJvcE5hbWUgPSAnZ3JpZEJvcmRlcicgKyAoZWRnZSB8fCAnJyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFyW3Byb3BOYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihib3JkZXIpIHtcbiAgICAgICAgICAgIHRoaXMudmFyW3Byb3BOYW1lXSA9IGJvcmRlcjtcblxuICAgICAgICAgICAgaWYgKCFlZGdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YXIuZ3JpZEJvcmRlckxlZnQgPSB0aGlzLnZhci5ncmlkQm9yZGVyUmlnaHQgPSB0aGlzLnZhci5ncmlkQm9yZGVyVG9wID0gdGhpcy52YXIuZ3JpZEJvcmRlckJvdHRvbSA9IGJvcmRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5ncmlkLnJlc2V0R3JpZEJvcmRlcihlZGdlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZHluYW1pY1Byb3BlcnR5RGVzY3JpcHRvcnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIEh5cGVyZ3JpZEVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG4vLyBleHRlbmQgZnJvbSBgRXJyb3JgXG5IeXBlcmdyaWRFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5cbi8vIG92ZXJyaWRlIGVycm9yIG5hbWUgZGlzcGxheWVkIGluIGNvbnNvbGVcbkh5cGVyZ3JpZEVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0h5cGVyZ3JpZEVycm9yJztcblxubW9kdWxlLmV4cG9ydHMgPSBIeXBlcmdyaWRFcnJvcjtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBUEk7XG5cbmZ1bmN0aW9uIGNsZWFyRmlsbCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjb2xvcikge1xuICAgIHZhciBhID0gYWxwaGEoY29sb3IpO1xuICAgIGlmIChhIDwgMSkge1xuICAgICAgICAvLyBJZiBiYWNrZ3JvdW5kIGlzIHRyYW5zbHVjZW50LCB3ZSBtdXN0IGNsZWFyIHRoZSByZWN0IGJlZm9yZSB0aGUgZmlsbFJlY3RcbiAgICAgICAgLy8gYmVsb3cgdG8gcHJldmVudCBtaXhpbmcgd2l0aCBwcmV2aW91cyBmcmFtZSdzIHJlbmRlciBvZiB0aGlzIGNlbGwuXG4gICAgICAgIHRoaXMuY2xlYXJSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICBpZiAoYSA+IDApIHtcbiAgICAgICAgdGhpcy5jYWNoZS5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5maWxsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG59XG5cbnZhciBBTFBIQV9SRUdFWCA9IC9eKHRyYW5zcGFyZW50fCgoUkdCfEhTTClBXFwoLiosXFxzKihbXFxkXFwuXSspXFwpKSkkL2k7XG4vLyBUcmllZCB1c2luZyBhbiBgYWxwaGFDYWNoZWAgaGVyZSBidXQgaXQgZGlkbid0IG1ha2UgYSBtZWFzdXJhYmxlIGRpZmZlcmVuY2UuXG5mdW5jdGlvbiBhbHBoYShjc3NDb2xvclNwZWMpIHtcbiAgICB2YXIgbWF0Y2hlcywgcmVzdWx0O1xuXG4gICAgaWYgKCFjc3NDb2xvclNwZWMpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIHNvIG5vdCB2aXNpYmxlOyB0cmVhdCBhcyB0cmFuc3BhcmVudFxuICAgICAgICByZXN1bHQgPSAwO1xuICAgIH0gZWxzZSBpZiAoKG1hdGNoZXMgPSBjc3NDb2xvclNwZWMubWF0Y2goQUxQSEFfUkVHRVgpKSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBhbiBvcGFxdWUgY29sb3IgKGEgY29sb3Igc3BlYyB3aXRoIG5vIGFscGhhIGNoYW5uZWwpXG4gICAgICAgIHJlc3VsdCA9IDE7XG4gICAgfSBlbHNlIGlmIChtYXRjaGVzWzRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gY3NzQ29sb3JTcGVjIG11c3QgaGF2ZSBiZWVuICd0cmFuc3BhcmVudCdcbiAgICAgICAgcmVzdWx0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBOdW1iZXIobWF0Y2hlc1s0XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIGZvbnRNZXRyaWNzID0ge307XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgd2lkdGggb2Ygc3RyaW5nIGluIHBpeGVscywgY2hhcmFjdGVyIGJ5IGNoYXJhY3RlciwgYnkgY2hhY2hpbmcgY2hhcmFjdGVyIHdpZHRocyBhbmQgcmV1c2luZyB0aG9zZSB2YWx1ZXMgd2hlbiBwcmV2aW91c2x5IGNhY2hlZC5cbiAqXG4gKiBOT1RFOiBUaGVyZSBpcyBhIG1pbm9yIG1lYXN1cmluZyBlcnJvciB3aGVuIHRha2luZyB0aGUgc3VtIG9mIHRoZSBwaXhlbCB3aWR0aHMgb2YgaW5kaXZpZHVhbCBjaGFyYWN0ZXJzIHRoYXQgbWFrZSB1cCBhIHN0cmluZyB2cy4gdGhlIHBpeGVsIHdpZHRoIG9mIHRoZSBzdHJpbmcgdGFrZW4gYXMgYSB3aG9sZS4gVGhpcyBpcyBwb3NzaWJseSBkdWUgdG8ga2VybmluZyBvciByb3VuZGluZy4gVGhlIGVycm9yIGlzIHR5cGljYWxseSBhYm91dCAwLjElLlxuICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gVGV4dCB0byBtZWFzdXJlLlxuICogQHJldHVybnMge251Ym1lcn0gV2lkdGggb2Ygc3RyaW5nIGluIHBpeGVscy5cbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dFdpZHRoKHN0cmluZykge1xuICAgIHZhciBtZXRyaWNzID0gZm9udE1ldHJpY3NbdGhpcy5jYWNoZS5mb250XSA9IGZvbnRNZXRyaWNzW3RoaXMuY2FjaGUuZm9udF0gfHwge307XG4gICAgc3RyaW5nICs9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwLCBzdW0gPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIGMgPSBzdHJpbmdbaV07XG4gICAgICAgIHN1bSArPSBtZXRyaWNzW2NdID0gbWV0cmljc1tjXSB8fCB0aGlzLm1lYXN1cmVUZXh0KGMpLndpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuXG52YXIgRUxMSVBTSVMgPSAnXFx1MjAyNic7IC8vIFRoZSBcIuKAplwiIChkb3QtZG90LWRvdCkgY2hhcmFjdGVyXG5cbi8qKlxuICogU2ltaWxhciB0byBgZ2V0VGV4dFdpZHRoYCBleGNlcHQ6XG4gKiAxLiBBYm9ydHMgYWNjdW11bGF0aW5nIHdoZW4gc3VtIGV4Y2VlZHMgZ2l2ZW4gYHdpZHRoYC5cbiAqIDIuIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYm90aCB0aGUgdHJ1bmNhdGVkIHN0cmluZyBhbmQgdGhlIHN1bSAocmF0aGVyIHRoYW4gYSBudW1iZXIgcHJpbWl0aXZlIGNvbnRhaW5pbmcgdGhlIHN1bSBhbG9uZSkuXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gZ2NcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBUZXh0IHRvIG1lYXN1cmUuXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBXaWR0aCBvZiB0YXJnZXQgY2VsbDsgb3ZlcmZsb3cgcG9pbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW58bnVsbHx1bmRlZmluZWR9IHRydW5jYXRlVGV4dFdpdGhFbGxpcHNpcyAtIF9QZXIge0BsaW5rIG1vZHVsZTpkZWZhdWx0cy50cnVuY2F0ZVRleHRXaXRoRWxsaXBzaXN9Ll9cbiAqIEBwYXJhbSB7YXJyYXl9IGhpZ2hsaWdodENoYXJzIC0gTGlzdCBvZiB7ZnJvbToge251bWJlcn0sIHRvOiB7bnVtYmVyfX0gb2JqZWN0IHRvIGRldGVjdCBoaWdobGlnaHRpbmcgb2YgdGV4dFxuICogQHBhcmFtIHtib29sZWFufSBbYWJvcnQ9ZmFsc2VdIC0gQWJvcnQgbWVhc3VyaW5nIHVwb24gb3ZlcmZsb3cuIFJldHVybmVkIGB3aWR0aGAgc3VtIHdpbGwgcmVmbGVjdCB0cnVuY2F0ZWQgc3RyaW5nIHJhdGhlciB0aGFuIHVudHJ1bmNhdGVkIHN0cmluZy4gTm90ZSB0aGF0IHJldHVybmVkIGBzdHJpbmdgIGlzIHRydW5jYXRlZCBpbiBlaXRoZXIgY2FzZS5cbiAqIEByZXR1cm5zIHt7c3RyaW5nOnN0cmluZyx3aWR0aDpudW1iZXJ9fVxuICogKiBgb2JqZWN0LnN0cmluZ2AgLSBgdW5kZWZpbmVkYCBpZiBpdCBmaXRzOyB0cnVuY2F0ZWQgdmVyc2lvbiBvZiBwcm92aWRlZCBgc3RyaW5nYCBpZiBpdCBkb2VzIG5vdC5cbiAqICogYG9iamVjdC53aWR0aGAgLSBXaWR0aCBvZiBwcm92aWRlZCBgc3RyaW5nYCBpZiBpdCBmaXRzOyB3aWR0aCBvZiB0cnVuY2F0ZWQgc3RyaW5nIGlmIGl0IGRvZXMgbm90LlxuICovXG5mdW5jdGlvbiBnZXRUZXh0V2lkdGhUcnVuY2F0ZWQoc3RyaW5nLCB3aWR0aCwgdHJ1bmNhdGVUZXh0V2l0aEVsbGlwc2lzLCBoaWdobGlnaHRDaGFycywgYWJvcnQpIHtcbiAgICB2YXIgbWV0cmljcyA9IGZvbnRNZXRyaWNzW3RoaXMuY2FjaGUuZm9udF0sXG4gICAgICAgIHRydW5jYXRpbmcgPSB0cnVuY2F0ZVRleHRXaXRoRWxsaXBzaXMgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgdHJ1bmNTdHJpbmcsIHRydW5jV2lkdGgsIHRydW5jQXQ7XG4gICAgY29uc3QgaGlnaGxpZ2h0cyA9IFtdO1xuXG4gICAgaWYgKCFtZXRyaWNzKSB7XG4gICAgICAgIG1ldHJpY3MgPSBmb250TWV0cmljc1t0aGlzLmNhY2hlLmZvbnRdID0ge307XG4gICAgfVxuXG4gICAgaWYgKCFtZXRyaWNzW0VMTElQU0lTXSkge1xuICAgICAgICBtZXRyaWNzW0VMTElQU0lTXSA9IHRoaXMubWVhc3VyZVRleHQoRUxMSVBTSVMpLndpZHRoO1xuICAgIH1cblxuICAgIGxldCBzdW0gPSAwO1xuICAgIGxldCBoaWdobGlnaHRJbmRleCA9IDA7XG4gICAgbGV0IGNoYXJXaWR0aCA9IDA7XG4gICAgc3RyaW5nID0gc3RyaW5nICsgJyc7IC8vIGNvbnZlcnQgdG8gc3RyaW5nXG4gICAgd2lkdGggKz0gdHJ1bmNhdGVUZXh0V2l0aEVsbGlwc2lzID09PSBmYWxzZSA/IDIgOiAwOyAvLyBmdWRnZSBmb3IgaW5lcXVhbGl0eVxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgY29uc3QgY2hhciA9IHN0cmluZ1tpXTtcbiAgICAgICAgY2hhcldpZHRoID0gbWV0cmljc1tjaGFyXSA9IG1ldHJpY3NbY2hhcl0gfHwgdGhpcy5tZWFzdXJlVGV4dChjaGFyKS53aWR0aDtcblxuICAgICAgICBpZiAoaGlnaGxpZ2h0Q2hhcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hsaWdodE9iamVjdCA9IGhpZ2hsaWdodENoYXJzW2hpZ2hsaWdodEluZGV4XTtcbiAgICAgICAgICAgIGlmIChoaWdobGlnaHRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaGlnaGxpZ2h0T2JqZWN0LmZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBzdGFydCB3aWR0aCBvZiB0ZXh0IGhpZ2hsaWdodFxuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRzW2hpZ2hsaWdodEluZGV4XSA9IHsgeDogc3VtIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09PSBoaWdobGlnaHRPYmplY3QudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBlbmQgcG9zaXRpb24gb2YgdGV4dCBoaWdobGlnaHRcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0c1toaWdobGlnaHRJbmRleF0ud2lkdGggPSBzdW0gLSBoaWdobGlnaHRzW2hpZ2hsaWdodEluZGV4XS54O1xuICAgICAgICAgICAgICAgICAgICArK2hpZ2hsaWdodEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN1bSArPSBjaGFyV2lkdGg7XG4gICAgICAgIGlmICghdHJ1bmNTdHJpbmcgJiYgdHJ1bmNhdGluZyAmJiBzdW0gPiB3aWR0aCkge1xuICAgICAgICAgICAgdHJ1bmNBdCA9IGk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRydW5jYXRlVGV4dFdpdGhFbGxpcHNpcykge1xuICAgICAgICAgICAgICAgIGNhc2UgdHJ1ZTogLy8gdHJ1bmNhdGUgc3VmZmljaWVudCBjaGFyYWN0ZXJzIHRvIGZpdCBlbGxpcHNpcyBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICB0cnVuY1dpZHRoID0gc3VtIC0gY2hhcldpZHRoICsgbWV0cmljc1tFTExJUFNJU107XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVuY0F0ICYmIHRydW5jV2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1bmNXaWR0aCAtPSBtZXRyaWNzW3N0cmluZ1stLXRydW5jQXRdXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnVuY1N0cmluZyA9IHRydW5jV2lkdGggPiB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnJyAvLyBub3QgZW5vdWdoIHJvb20gZXZlbiBmb3IgZWxsaXBzaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHJ1bmNTdHJpbmcgPSBzdHJpbmcuc3Vic3RyKDAsIHRydW5jQXQpICsgRUxMSVBTSVM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgZmFsc2U6IC8vIHRydW5jYXRlICpiZWZvcmUqIGxhc3QgcGFydGlhbGx5IHZpc2libGUgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgIHRydW5jU3RyaW5nID0gc3RyaW5nLnN1YnN0cigwLCB0cnVuY0F0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogLy8gdHJ1bmNhdGUgKmFmdGVyKiBwYXJ0aWFsbHkgdmlzaWJsZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCsrdHJ1bmNBdCA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydW5jU3RyaW5nID0gc3RyaW5nLnN1YnN0cigwLCB0cnVuY0F0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFib3J0KSB7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzYXZlIGVuZCBwb3NpdGlvbiBvZiB0ZXh0IGhpZ2hsaWdodCB3aXRoIGNvcnJlY3Rpb25zIHJlbGF0ZWQgdG8gZWxsaXBzaXNcbiAgICBpZiAoaGlnaGxpZ2h0c1toaWdobGlnaHRJbmRleF0gJiYgIWhpZ2hsaWdodHNbaGlnaGxpZ2h0SW5kZXhdLndpZHRoKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gKHRydW5jV2lkdGggPyB0cnVuY1dpZHRoIC0gY2hhcldpZHRoIDogc3VtKSAtIGhpZ2hsaWdodHNbaGlnaGxpZ2h0SW5kZXhdLng7XG4gICAgICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgICAgICAgIGhpZ2hsaWdodHNbaGlnaGxpZ2h0SW5kZXhdLndpZHRoID0gd2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdobGlnaHRzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RyaW5nOiB0cnVuY1N0cmluZyxcbiAgICAgICAgd2lkdGg6IHN1bSxcbiAgICAgICAgaGlnaGxpZ2h0czogaGlnaGxpZ2h0c1xuICAgIH07XG59XG5cbnZhciBmb250RGF0YSA9IHt9O1xuXG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAqIEBwYXJhbSBmb250XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dEhlaWdodChmb250KSB7XG4gICAgdmFyIHJlc3VsdCA9IGZvbnREYXRhW2ZvbnRdO1xuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgICAgdmFyIHRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIHRleHQudGV4dENvbnRlbnQgPSAnSGcnO1xuICAgICAgICB0ZXh0LnN0eWxlLmZvbnQgPSBmb250O1xuXG4gICAgICAgIHZhciBibG9jayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBibG9jay5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgICAgIGJsb2NrLnN0eWxlLndpZHRoID0gJzFweCc7XG4gICAgICAgIGJsb2NrLnN0eWxlLmhlaWdodCA9ICcwcHgnO1xuXG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKHRleHQpO1xuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoYmxvY2spO1xuXG4gICAgICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcblxuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICBibG9jay5zdHlsZS52ZXJ0aWNhbEFsaWduID0gJ2Jhc2VsaW5lJztcblxuICAgICAgICAgICAgdmFyIGJsb2NrUmVjdCA9IGJsb2NrLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIHRleHRSZWN0ID0gdGV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgcmVzdWx0LmFzY2VudCA9IGJsb2NrUmVjdC50b3AgLSB0ZXh0UmVjdC50b3A7XG5cbiAgICAgICAgICAgIGJsb2NrLnN0eWxlLnZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgICAgICAgIHJlc3VsdC5oZWlnaHQgPSBibG9ja1JlY3QudG9wIC0gdGV4dFJlY3QudG9wO1xuXG4gICAgICAgICAgICByZXN1bHQuZGVzY2VudCA9IHJlc3VsdC5oZWlnaHQgLSByZXN1bHQuYXNjZW50O1xuICAgICAgICAgICAgcmVzdWx0Lm9mZnNldCA9IHRleHQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuaGVpZ2h0ICE9PSAwKSB7XG4gICAgICAgICAgICBmb250RGF0YVtmb250XSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNsaXBTYXZlKGNvbmRpdGlvbmFsLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5jb25kaXRpb25hbHNTdGFjay5wdXNoKGNvbmRpdGlvbmFsKTtcbiAgICBpZiAoY29uZGl0aW9uYWwpIHtcbiAgICAgICAgdGhpcy5jYWNoZS5zYXZlKCk7XG4gICAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jbGlwKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjbGlwUmVzdG9yZShjb25kaXRpb25hbCkge1xuICAgIGlmICh0aGlzLmNvbmRpdGlvbmFsc1N0YWNrLnBvcCgpKSB7XG4gICAgICAgIHRoaXMuY2FjaGUucmVzdG9yZSgpOyAvLyBSZW1vdmUgY2xpcCByZWdpb25cbiAgICB9XG59XG5cbkFQSSA9IHtcbiAgICBjbGVhckZpbGw6IGNsZWFyRmlsbCxcbiAgICBhbHBoYTogYWxwaGEsXG4gICAgZ2V0VGV4dFdpZHRoOiBnZXRUZXh0V2lkdGgsXG4gICAgZ2V0VGV4dFdpZHRoVHJ1bmNhdGVkOiBnZXRUZXh0V2lkdGhUcnVuY2F0ZWQsXG4gICAgZ2V0VGV4dEhlaWdodDogZ2V0VGV4dEhlaWdodCxcbiAgICBjbGlwU2F2ZTogY2xpcFNhdmUsXG4gICAgY2xpcFJlc3RvcmU6IGNsaXBSZXN0b3JlLFxuICAgIHRydW5jYXRlVGV4dFdpdGhFbGxpcHNpczogdHJ1ZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBUEk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBSRUdFWFBfV09SRF9TRVBBUkFUT1JTID0gL1tcXHNcXC1fXSooW15cXHNcXC1fXSkoW15cXHNcXC1fXSspL2csXG4gICAgUkVHRVhQX0NBUElUQUxfTEVUVEVSUyA9IC9bQS1aXS9nLFxuICAgIFJFR0VYUF9MT1dFUl9DQVNFX0xFVFRFUiA9IC9bYS16XS8sXG4gICAgc2hvcnRXb3JkcyA9IFsnb2YnLCAnYXQnLCAnYnknLCAnZnJvbScsICdhbmQnLCAnYnV0JywgJ2ZvcicsICdhJywgJ2FuJywgJ3RoZSddO1xuXG4vLyBSZXBsYWNlbWVudCBmdW5jdGlvbiBmb3IgdXNlIGluIHRoZSBkZWZhdWx0IHRpdGxlaXplIGZ1bmN0aW9uIGJlbG93LlxuLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9yZXBsYWNlXG5mdW5jdGlvbiBjYXBpdGFsaXplKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gYi50b1VwcGVyQ2FzZSgpICsgYztcbn1cblxuLyoqXG4gKiAqIFNlcGFyYXRlcyBjYW1lbCBjYXNlIG9yIHdoaXRlLXNwYWNlLSwgaHlwaGVuLSwgb3IgdW5kZXJzY29yZS1zZXBhcmF0ZWQgXCJ3b3JkcycgaW50byB0cnVlICh0cnVseSBzZXBhcmF0ZSkgd29yZHMuXG4gKiAqIENhcGl0YWxpemVzIHRoZSBmaXJzdCBsZXR0ZXIgb2YgZWFjaCB3b3JkICh1bmxlc3Mgbm90IGZpcnN0IHdvcmQgYW5kIGluIGBzaG9ydFdvcmRzYCkuXG4gKiBAcGFyYW0gc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogQG1lbWJlck9mIG5hbWVzcGFjZTpmaWVsZHNcbiAqL1xuZXhwb3J0cy50aXRsZWl6ZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciB0aXRsZSA9IChSRUdFWFBfTE9XRVJfQ0FTRV9MRVRURVIudGVzdChzdHJpbmcpID8gc3RyaW5nIDogc3RyaW5nLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIC5yZXBsYWNlKFJFR0VYUF9XT1JEX1NFUEFSQVRPUlMsIGNhcGl0YWxpemUpXG4gICAgICAgIC5yZXBsYWNlKFJFR0VYUF9DQVBJVEFMX0xFVFRFUlMsICcgJCYnKVxuICAgICAgICAudHJpbSgpO1xuXG4gICAgc2hvcnRXb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uKHdvcmQpIHtcbiAgICAgICAgd29yZCA9ICcgJyArIHdvcmQgKyAnICc7XG4gICAgICAgIHRpdGxlID0gdGl0bGUucmVwbGFjZShuZXcgUmVnRXhwKHdvcmQsICdnaScpLCB3b3JkKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aXRsZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNlbGxFdmVudEZhY3Rvcnk6IHJlcXVpcmUoJy4vY2VsbEV2ZW50RmFjdG9yeScpLFxuICAgIGR5bmFtaWNQcm9wZXJ0eURlc2NyaXB0b3JzOiByZXF1aXJlKCcuL2R5bmFtaWNQcm9wZXJ0aWVzJyksXG4gICAgZ3JhcGhpY3M6IHJlcXVpcmUoJy4vZ3JhcGhpY3MnKSxcbiAgICBDYW52YXM6IHJlcXVpcmUoJy4vQ2FudmFzJylcbn07XG5cbnZhciB3YXJuZWQ7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2ZpZWxkcycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgSHlwZXJncmlkLmxpYi5maWVsZHNgIG1vZHVsZSBoYXMgYmVlbiByZXRpcmVkIGFzIG9mIHYzLjAuMCBhbmQgaW5jb3Jwb3JhdGVkIGludG8gc2NoZW1hIGVucmljaG1lbnQgKHRyaWdnZXJlZCBieSB0aGUgbmV3IGBkYXRhLXNjaGVtYS1jaGFuZ2VkYCBkYXRhIGV2ZW50KSwgd2hpY2ggaXMgaW5mbHVlbmNlZCBieSB0aGUgbmV3IGBoZWFkZXJpZnlgIGdyaWQgcHJvcGVydHkuJyk7XG4gICAgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ0RhdGFTb3VyY2VPcmlnaW4nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlIGBEYXRhU291cmNlT3JpZ2luYCBtb2R1bGUgaGFzIGJlZW4gcmV0aXJlZCBhcyBvZiB2My4wLjAuIFRoZSBuZXcgZGVmYXVsdCBkYXRhIG1vZGVsLCBgZGF0YXNhdXItbG9jYWxgLCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQuIE5vdGUsIGhvd2V2ZXIsIHRoYXQgaXQgbWF5IGJlIHJlbW92ZWQgZnJvbSB0aGUgYnVpbGQgaW4gYSBmdXR1cmUgcmVsZWFzZS4gRGV2ZWxvcGVycyBhcmUgYWR2aXNlZCBhbmQgZW5jb3VyYWdlZCB0byBwcm92aWRlIHRoZWlyIG93biBkYXRhIG1vZGVsIGdvaW5nIGZvcndhcmQuIEZvciBleGFtcGxlOiBgbmV3IEh5cGVyZ3JpZCh7IERhdGFTb3VyY2U6IHJlcXVpcmUoXFwnZGF0YXNhdXItbG9jYWxcXCcpIH0pYDsgb3IgcHJvdmlkZSBhIGxpdmUgZGF0YSBtb2RlbCBpbnN0YW5jZSBpbiB0aGUgYGRhdGFTb3VyY2VgIChzbWFsbCBcImRcIikgb3B0aW9uLicpO1xuICAgICAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWlyZSgnLi4vRGF0YXNhdXJMb2NhbCcpO1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbi8qIElNUE9SVEFOVCBOT1RFOlxuICogSWYgYW55IG9mIHRoZSBtb2R1bGVzIGxpc3RlZCBiZWxvdyBpcyByZW1vdmVkIGZyb20gSHlwZXJncmlkLCB0aGUgcG9seWZpbGwocykgdGhleSBkZWZpbmUgbXVzdCBiZSBhZGRlZCBoZXJlISEhXG4gKlxuICogMS4gb2JqZWN0LWl0ZXJhdG9ycyBkZWZpbmVzIEFycmF5LnByb3RvdHlwZS5maW5kXG4gKi9cblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1leHRlbmQtbmF0aXZlICovXG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvc2lnbiNQb2x5ZmlsbFxuLy8gKFNhZmFyaSBub3cgc3VwcG9ydHMgTWF0aC5zaWduIGJ1dCBJRSBzdGlsbCBkb2VzIG5vdCBhcyBvZiB2MTEuKVxuTWF0aC5zaWduID0gTWF0aC5zaWduID0gZnVuY3Rpb24oeCkge1xuICAgIHggPSAreDsgLy8gY29udmVydCB0byBhIG51bWJlclxuICAgIGlmICh4ID09PSAwIHx8IGlzTmFOKHgpKSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICByZXR1cm4geCA+IDAgPyAxIDogLTE7XG59O1xuXG4vLyBMaXRlIHZlcnNpb24gb2Y6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbmRJbmRleCNQb2x5ZmlsbFxuaWYgKHR5cGVvZiBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB0aGlzW2ldLCBpLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xufVxuXG4vLyBTaW1wbGVyIHZlcnNpb24gb2Y6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbGwjUG9seWZpbGxcbmlmICh0eXBlb2YgQXJyYXkucHJvdG90eXBlLmZpbGwgIT09ICdmdW5jdGlvbicpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgPT09IHVuZGVmaW5lZCA/IDAgOiBzdGFydCA8IDAgPyB0aGlzLmxlbmd0aCArIHN0YXJ0IDogc3RhcnQ7XG4gICAgICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPCAwID8gdGhpcy5sZW5ndGggKyBlbmQgOiBlbmQ7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydCB8fCAwOyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXNbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufVxuXG4vLyBMaXRlIHZlcnNpb24gb2Y6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24jUG9seWZpbGxcbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIE9iamVjdC5hc3NpZ24gPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuZXh0S2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25leHRLZXldID0gc291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbn1cblxuaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpLnJlZHVjZShmdW5jdGlvbihkZXNjcmlwdG9ycywga2V5KSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yc1trZXldID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIGtleSk7XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgSHlwZXJncmlkRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yJyk7XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbnxzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybnMge2Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBzdHJpbmcpIHtcbiAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEh5cGVyZ3JpZEVycm9yKCdFeHBlY3RlZCBzdHJpbmcsIGZ1bmN0aW9uLCBvciB1bmRlZmluZWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3MgPSBzdHJpbmcubWF0Y2goL15mdW5jdGlvblxccypcXHcqXFxzKlxcKChbXl0qPylcXCkvKTtcbiAgICBpZiAoIWFyZ3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEh5cGVyZ3JpZEVycm9yKCdFeHBlY3RlZCBmdW5jdGlvbiBrZXl3b3JkIHdpdGggZm9ybWFsIHBhcmFtZXRlciBsaXN0LicpO1xuICAgIH1cbiAgICBhcmdzID0gYXJnc1sxXS5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbihzLCBpKSB7XG4gICAgICAgIHMgPSBzLm1hdGNoKC9cXHMqKFxcdyopXFxzKi8pOyAvLyB0cmltIGVhY2ggYXJndW1lbnRcbiAgICAgICAgaWYgKCFzICYmIGkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBIeXBlcmdyaWRFcnJvcignRXhwZWN0ZWQgZm9ybWFsIHBhcmFtZXRlci4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc1sxXTtcbiAgICB9KTtcblxuICAgIHZhciBib2R5ID0gc3RyaW5nLm1hdGNoKC97XFxzKihbXl0qPylcXHMqfVxccyokLyk7XG4gICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHRocm93IG5ldyBIeXBlcmdyaWRFcnJvcignRXhwZWN0ZWQgZnVuY3Rpb24gYm9keS4nKTtcbiAgICB9XG4gICAgYm9keSA9IGJvZHlbMV07XG5cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgIWFyZ3NbMF0pIHtcbiAgICAgICAgYXJnc1swXSA9IGJvZHk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KGJvZHkpO1xuICAgIH1cblxuICAgIHJldHVybiBGdW5jdGlvbi5hcHBseShudWxsLCBhcmdzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGJ1bmRsZUNvbHVtbnMocmVzZXRDZWxsRXZlbnRzKSB7XG4gICAgdmFyIGdyaWRQcm9wcyA9IHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLFxuICAgICAgICB2ciwgdmlzaWJsZVJvd3MgPSB0aGlzLnZpc2libGVSb3dzLFxuICAgICAgICByLCBSID0gdmlzaWJsZVJvd3MubGVuZ3RoLCBwb29sO1xuXG4gICAgaWYgKHJlc2V0Q2VsbEV2ZW50cykge1xuICAgICAgICBwb29sID0gdGhpcy5jZWxsRXZlbnRQb29sO1xuICAgICAgICB2YXIgcCA9IDA7XG4gICAgICAgIHRoaXMudmlzaWJsZUNvbHVtbnMuZm9yRWFjaFdpdGhOZWcoZnVuY3Rpb24odmMpIHtcbiAgICAgICAgICAgIGZvciAociA9IDA7IHIgPCBSOyByKyssIHArKykge1xuICAgICAgICAgICAgICAgIHZyID0gdmlzaWJsZVJvd3Nbcl07XG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgcG9vbCBtZW1iZXIgdG8gcmVmbGVjdCBjb29yZGluYXRlcyBvZiBjZWxsIGluIG5ld2x5IHNoYXBlZCBncmlkXG4gICAgICAgICAgICAgICAgcG9vbFtwXS5yZXNldCh2YywgdnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgYnVuZGxlLFxuICAgICAgICBjb2x1bW5CdW5kbGVzID0gW10sXG4gICAgICAgIGdyaWRQcmVmaWxsQ29sb3IgPSBncmlkUHJvcHMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICB0aGlzLnZpc2libGVDb2x1bW5zLmZvckVhY2hXaXRoTmVnKGZ1bmN0aW9uKHZjKSB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvciA9IHZjLmNvbHVtbi5wcm9wZXJ0aWVzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgaWYgKGJ1bmRsZSAmJiBidW5kbGUuYmFja2dyb3VuZENvbG9yID09PSBiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICAgIGJ1bmRsZS5yaWdodCA9IHZjLnJpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKGJhY2tncm91bmRDb2xvciA9PT0gZ3JpZFByZWZpbGxDb2xvcikge1xuICAgICAgICAgICAgYnVuZGxlID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVuZGxlID0ge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHZjLmxlZnQsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHZjLnJpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29sdW1uQnVuZGxlcy5wdXNoKGJ1bmRsZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuY29sdW1uQnVuZGxlcyA9IGNvbHVtbkJ1bmRsZXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnVuZGxlQ29sdW1ucztcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYnVuZGxlUm93cyhyZXNldENlbGxFdmVudHMpIHtcbiAgICB2YXIgZ3JpZFByb3BzID0gdGhpcy5ncmlkLnByb3BlcnRpZXMsXG4gICAgICAgIHZyLCB2aXNpYmxlUm93cyA9IHRoaXMudmlzaWJsZVJvd3MsXG4gICAgICAgIHIsIFIgPSB2aXNpYmxlUm93cy5sZW5ndGgsXG4gICAgICAgIHAsIHBvb2w7XG5cbiAgICBpZiAocmVzZXRDZWxsRXZlbnRzKSB7XG4gICAgICAgIHBvb2wgPSB0aGlzLmNlbGxFdmVudFBvb2w7XG4gICAgICAgIGZvciAocCA9IDAsIHIgPSAwOyByIDwgUjsgcisrKSB7XG4gICAgICAgICAgICB2ciA9IHZpc2libGVSb3dzW3JdO1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlQ29sdW1ucy5mb3JFYWNoV2l0aE5lZyhmdW5jdGlvbih2YykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgICAgICAgICAgIHArKztcbiAgICAgICAgICAgICAgICAvLyByZXNldCBwb29sIG1lbWJlciB0byByZWZsZWN0IGNvb3JkaW5hdGVzIG9mIGNlbGwgaW4gbmV3bHkgc2hhcGVkIGdyaWRcbiAgICAgICAgICAgICAgICBwb29sW3BdLnJlc2V0KHZjLCB2cik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBidW5kbGUsIHJvd0J1bmRsZXMgPSBbXSxcbiAgICAgICAgZ3JpZFByZWZpbGxDb2xvciA9IGdyaWRQcm9wcy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgIHJvd1N0cmlwZXMgPSBncmlkUHJvcHMucm93U3RyaXBlcyxcbiAgICAgICAgcm93UHJlZmlsbENvbG9ycyA9IEFycmF5KFIpLFxuICAgICAgICBzdHJpcGUsIGJhY2tncm91bmRDb2xvcjtcblxuICAgIGZvciAociA9IDA7IHIgPCBSOyByKyspIHtcbiAgICAgICAgdnIgPSB2aXNpYmxlUm93c1tyXTsgLy8gZmlyc3QgY2VsbCBpbiByb3cgclxuICAgICAgICBzdHJpcGUgPSB2ci5zdWJncmlkLmlzRGF0YSAmJiByb3dTdHJpcGVzICYmIHJvd1N0cmlwZXNbdnIucm93SW5kZXggJSByb3dTdHJpcGVzLmxlbmd0aF07XG4gICAgICAgIGJhY2tncm91bmRDb2xvciA9IHJvd1ByZWZpbGxDb2xvcnNbcl0gPSBzdHJpcGUgJiYgc3RyaXBlLmJhY2tncm91bmRDb2xvciB8fCBncmlkUHJlZmlsbENvbG9yO1xuICAgICAgICBpZiAoYnVuZGxlICYmIGJ1bmRsZS5iYWNrZ3JvdW5kQ29sb3IgPT09IGJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgICAgYnVuZGxlLmJvdHRvbSA9IHZyLmJvdHRvbTtcbiAgICAgICAgfSBlbHNlIGlmIChiYWNrZ3JvdW5kQ29sb3IgPT09IGdyaWRQcmVmaWxsQ29sb3IpIHtcbiAgICAgICAgICAgIGJ1bmRsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1bmRsZSA9IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICB0b3A6IHZyLnRvcCxcbiAgICAgICAgICAgICAgICBib3R0b206IHZyLmJvdHRvbVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJvd0J1bmRsZXMucHVzaChidW5kbGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yb3dCdW5kbGVzID0gcm93QnVuZGxlcztcbiAgICB0aGlzLnJvd1ByZWZpbGxDb2xvcnMgPSByb3dQcmVmaWxsQ29sb3JzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1bmRsZVJvd3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBwYWludENlbGxzQnlDb2x1bW5zQW5kUm93cyA9IHJlcXVpcmUoJy4vYnktY29sdW1ucy1hbmQtcm93cycpO1xuXG4vKiogQHN1bW1hcnkgUmVuZGVyIHRoZSBncmlkIG9ubHkgYXMgbmVlZGVkIChcInBhcnRpYWwgcmVuZGVyXCIpLlxuICogQGRlc2MgUGFpbnRzIGFsbCB0aGUgY2VsbHMgb2YgYSBncmlkLCBvbmUgY29sdW1uIGF0IGEgdGltZSwgYnV0IG9ubHkgYXMgbmVlZGVkLlxuICpcbiAqICMjIyMgT24gcmVzZXRcbiAqXG4gKiBEZWZlcnMgdG8ge0BsaW5rIFJlbmRlcmVyI3BhaW50Q2VsbHNCeUNvbHVtbnNBbmRSb3dzfHBhaW50Q2VsbHNCeUNvbHVtbnNBbmRSb3dzfSwgd2hpY2ggY2xlYXJzIHRoZSBjYW52YXMsIGRyYXdzIHRoZSBncmlkLCBhbmQgZHJhd3MgdGhlIGdyaWQgbGluZXMuXG4gKlxuICogIyMjIyBPbiB0aGUgbmV4dCBjYWxsIChhZnRlciByZXNldClcbiAqXG4gKiBGaXJzdCwgYSBiYWNrZ3JvdW5kIHJlY3QgaXMgZHJhd24gdXNpbmcgdGhlIGdyaWQgYmFja2dyb3VuZCBjb2xvci5cbiAqXG4gKiBUaGVuLCBlYWNoIGNlbGwgaXMgZHJhd24uIElmIGl0cyBiYWNrZ3JvdW5kIGRpZmZlcnMgZnJvbSB0aGUgZ3JpZCBiYWNrZ3JvdW5kLCB0aGUgYmFja2dyb3VuZCBpcyByZXBhaW50ZWQuXG4gKlxuICogYHRyeS4uLmNhdGNoYCBzdXJyb3VuZHMgZWFjaCBjZWxsIHBhaW50IGluIGNhc2UgYSBjZWxsIHJlbmRlcmVyIHRocm93cyBhbiBlcnJvci5cbiAqIFRoZSBlcnJvciBtZXNzYWdlIGlzIGVycm9yLWxvZ2dlZCB0byBjb25zb2xlIEFORCBkaXNwbGF5ZWQgaW4gY2VsbC5cbiAqXG4gKiAjIyMjIE9uIHN1YnNlcXVlbnQgY2FsbHNcbiAqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGVhY2ggY2VsbCwgY2FsbGluZyBgX3BhaW50Q2VsbGAgd2l0aCBgdW5kZWZpbmVkYCBwcmVmaWxsIGNvbG9yLiBUaGlzIHNpZ25pZmllcyBwYXJ0aWFsIHJlbmRlciB0byB0aGUge0BsaW5rIFNpbXBsZUNlbGx9IGNlbGwgcmVuZGVyZXIsIHdoaWNoIG9ubHkgcmVuZGVycyB0aGUgY2VsbCB3aGVuIGl0J3MgdGV4dCwgZm9udCwgb3IgY29sb3JzIGhhdmUgY2hhbmdlZC5cbiAqXG4gKiBFYWNoIGNlbGwgdG8gYmUgcmVuZGVyZWQgaXMgZGVzY3JpYmVkIGJ5IGEge0BsaW5rIENlbGxFdmVudH0gb2JqZWN0LiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgdG8gYXZvaWQgY29uc3RhbnRseSBpbnN0YW50aWF0aW5nIHRoZXNlIG9iamVjdHMsIHdlIG1haW50YWluIGEgcG9vbCBvZiB0aGVzZS4gV2hlbiB0aGUgZ3JpZCBzaGFwZSBjaGFuZ2VzLCB3ZSByZXNldCB0aGVpciBjb29yZGluYXRlcyBieSBzZXR0aW5nIHtAbGluayBDZWxsRXZlbnQjcmVzZXR8cmVzZXR9IG9uIGVhY2guXG4gKlxuICogU2VlIGFsc28gdGhlIGRpc2N1c3Npb24gb2YgY2xpcHBpbmcgaW4ge0BsaW5rIFJlbmRlcmVyI3BhaW50Q2VsbHNCeUNvbHVtbnN8cGFpbnRDZWxsc0J5Q29sdW1uc30uXG4gKiBAdGhpcyB7UmVuZGVyZXJ9XG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gZ2NcbiAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAqL1xuZnVuY3Rpb24gcGFpbnRDZWxsc0FzTmVlZGVkKGdjKSB7XG4gICAgdmFyIGNlbGxFdmVudCxcbiAgICAgICAgdmlzaWJsZUNvbHVtbnMgPSB0aGlzLnZpc2libGVDb2x1bW5zLFxuICAgICAgICB2aXNpYmxlUm93cyA9IHRoaXMudmlzaWJsZVJvd3MsXG4gICAgICAgIEMgPSB2aXNpYmxlQ29sdW1ucy5sZW5ndGgsIGNMYXN0ID0gQyAtIDEsXG4gICAgICAgIHIsIFIgPSB2aXNpYmxlUm93cy5sZW5ndGgsXG4gICAgICAgIHAgPSAwLCBwb29sID0gdGhpcy5jZWxsRXZlbnRQb29sLFxuICAgICAgICBwcmVmZXJyZWRXaWR0aCxcbiAgICAgICAgY29sdW1uQ2xpcCxcbiAgICAgICAgLy8gY2xpcFRvR3JpZCxcbiAgICAgICAgLy8gdmlld1dpZHRoID0gQyA/IHZpc2libGVDb2x1bW5zW2NMYXN0XS5yaWdodCA6IDAsXG4gICAgICAgIHZpZXdIZWlnaHQgPSBSID8gdmlzaWJsZVJvd3NbUiAtIDFdLmJvdHRvbSA6IDA7XG5cblxuICAgIGlmICghQyB8fCAhUikgeyByZXR1cm47IH1cblxuICAgIGlmICh0aGlzLmdyaWRSZW5kZXJlci5yZXNldCkge1xuICAgICAgICB0aGlzLnJlc2V0QWxsR3JpZFJlbmRlcmVycygpO1xuICAgICAgICBwYWludENlbGxzQnlDb2x1bW5zQW5kUm93cy5jYWxsKHRoaXMsIGdjKTtcbiAgICAgICAgdGhpcy5ncmlkUmVuZGVyZXIucmVzZXQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBnYy5jbGlwU2F2ZShjbGlwVG9HcmlkLCAwLCAwLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQpO1xuXG4gICAgLy8gRm9yIGVhY2ggY29sdW1uLi4uXG4gICAgdGhpcy52aXNpYmxlQ29sdW1ucy5mb3JFYWNoV2l0aE5lZyhmdW5jdGlvbih2YywgYykge1xuICAgICAgICBjZWxsRXZlbnQgPSBwb29sW3BdOyAvLyBmaXJzdCBjZWxsIGluIGNvbHVtbiBjXG4gICAgICAgIHZjID0gY2VsbEV2ZW50LnZpc2libGVDb2x1bW47XG5cbiAgICAgICAgLy8gT3B0aW9uYWxseSBjbGlwIHRvIHZpc2libGUgcG9ydGlvbiBvZiBjb2x1bW4gdG8gcHJldmVudCB0ZXh0IGZyb20gb3ZlcmZsb3dpbmcgdG8gcmlnaHQuXG4gICAgICAgIGNvbHVtbkNsaXAgPSB2Yy5jb2x1bW4ucHJvcGVydGllcy5jb2x1bW5DbGlwO1xuICAgICAgICBnYy5jbGlwU2F2ZShjb2x1bW5DbGlwIHx8IGNvbHVtbkNsaXAgPT09IG51bGwgJiYgYyA9PT0gY0xhc3QsIDAsIDAsIHZjLnJpZ2h0LCB2aWV3SGVpZ2h0KTtcblxuICAgICAgICAvLyBGb3IgZWFjaCByb3cgb2YgZWFjaCBzdWJncmlkIChvZiBlYWNoIGNvbHVtbikuLi5cbiAgICAgICAgZm9yIChwcmVmZXJyZWRXaWR0aCA9IHIgPSAwOyByIDwgUjsgcisrLCBwKyspIHtcbiAgICAgICAgICAgIGNlbGxFdmVudCA9IHBvb2xbcF07IC8vIG5leHQgY2VsbCBkb3duIHRoZSBjb2x1bW4gKHJlZHVuZGFudCBmb3IgZmlyc3QgY2VsbCBpbiBjb2x1bW4pXG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHJlZmVycmVkV2lkdGggPSBNYXRoLm1heChwcmVmZXJyZWRXaWR0aCwgdGhpcy5fcGFpbnRDZWxsKGdjLCBwb29sW3BdKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJFcnJvckNlbGwoZSwgZ2MsIHZjLCBwb29sW3BdLnZpc2libGVSb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2MuY2xpcFJlc3RvcmUoY29sdW1uQ2xpcCk7XG5cbiAgICAgICAgY2VsbEV2ZW50LmNvbHVtbi5wcm9wZXJ0aWVzLnByZWZlcnJlZFdpZHRoID0gTWF0aC5yb3VuZChwcmVmZXJyZWRXaWR0aCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIGdjLmNsaXBSZXN0b3JlKGNsaXBUb0dyaWQpO1xufVxuXG5wYWludENlbGxzQXNOZWVkZWQua2V5ID0gJ2J5LWNlbGxzJztcblxucGFpbnRDZWxsc0FzTmVlZGVkLnBhcnRpYWwgPSB0cnVlOyAvLyBza2lwIHBhaW50aW5nIHNlbGVjdGlvblJlZ2lvbk92ZXJsYXlDb2xvclxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhaW50Q2VsbHNBc05lZWRlZDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEBzdW1tYXJ5IFJlbmRlciB0aGUgZ3JpZCBoZWFkZXJzLiBVc2VmdWwgd2hlbiBuZWVkIHRvIGF2b2lkIG92ZXJsYXBwaW5nXG4gKiBAZGVzYyBQYWludHMgYWxsIHRoZSBoZWFkZXIgY2VsbHMgb2YgYSBncmlkLCBvbmUgY29sdW1uIGF0IGEgdGltZS5cbiAqXG4gKiBUaGVuLCBpZiB0aGVyZSBhcmUgYW55IHJvd3Mgd2l0aCB0aGVpciBvd24gYmFja2dyb3VuZCBjb2xvciBfdGhhdCBkaWZmZXJzIGZyb20gdGhlIGdyaWQgYmFja2dyb3VuZCBjb2xvcixfIHRoZXNlIGFyZSBjb25zb2xpZGF0ZWQgYW5kIHRoZSBjb25zb2xpZGF0ZWQgZ3JvdXBzIG9mIHJvdyBiYWNrZ3JvdW5kcyBhcmUgYWxsIGRyYXduIGJlZm9yZSBpdGVyYXRpbmcgdGhyb3VnaCBjZWxscy4gVGhlc2Ugcm93IGJhY2tncm91bmRzIGdldCBwcmlvcml0eSBvdmVyIGNvbHVtbiBiYWNrZ3JvdW5kcy5cbiAqXG4gKiBJZiB0aGVyZSBhcmUgbm8gc3VjaCByb3cgYmFja2dyb3VuZCByZWN0cyB0byBkcmF3LCB0aGUgY29sdW1uIHJlY3RzIGFyZSBjb25zb2xpZGF0ZWQgYW5kIGRyYXduIGluc3RlYWQgKGFnYWluLCBiZWZvcmUgdGhlIGNlbGxzKS4gTm90ZSB0aGF0IHRoZXNlIGNvbHVtbiByZWN0cyBhcmUgX25vdF8gc3VpdGFibGUgZm9yIGNsaXBwaW5nIG92ZXJmbG93IHRleHQgZnJvbSBwcmV2aW91cyBjb2x1bW5zLiBJZiB5b3UgaGF2ZSBvdmVyZmxvdyB0ZXh0LCBlaXRoZXIgdHVybiBvbiBjbGlwcGluZyAoYmlnIHBlcmZvcm1hbmNlIGhpdCkgb3IgdHVybiBvbiBvbmUgb2YgdGhlIGB0cnVuY2F0ZVRleHRXaXRoRWxsaXBzaXNgIG9wdGlvbnMuXG4gKlxuICogYHRyeS4uLmNhdGNoYCBzdXJyb3VuZHMgZWFjaCBjZWxsIHBhaW50IGluIGNhc2UgYSBjZWxsIHJlbmRlcmVyIHRocm93cyBhbiBlcnJvci5cbiAqIFRoZSBlcnJvciBtZXNzYWdlIGlzIGVycm9yLWxvZ2dlZCB0byBjb25zb2xlIEFORCBkaXNwbGF5ZWQgaW4gY2VsbC5cbiAqXG4gKiBFYWNoIGNlbGwgdG8gYmUgcmVuZGVyZWQgaXMgZGVzY3JpYmVkIGJ5IGEge0BsaW5rIENlbGxFdmVudH0gb2JqZWN0LiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgdG8gYXZvaWQgY29uc3RhbnRseSBpbnN0YW50aWF0aW5nIHRoZXNlIG9iamVjdHMsIHdlIG1haW50YWluIGEgcG9vbCBvZiB0aGVzZS4gV2hlbiB0aGUgZ3JpZCBzaGFwZSBjaGFuZ2VzLCB3ZSByZXNldCB0aGVpciBjb29yZGluYXRlcyBieSBzZXR0aW5nIHtAbGluayBDZWxsRXZlbnQjcmVzZXR8cmVzZXR9IG9uIGVhY2guXG4gKlxuICogU2VlIGFsc28gdGhlIGRpc2N1c3Npb24gb2YgY2xpcHBpbmcgaW4ge0BsaW5rIFJlbmRlcmVyI3BhaW50Q2VsbHNCeUNvbHVtbnN8cGFpbnRDZWxsc0J5Q29sdW1uc30uXG4gKiBAdGhpcyB7UmVuZGVyZXJ9XG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gZ2NcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb25seUhlYWRlcnNcbiAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAqL1xuZnVuY3Rpb24gcGFpbnRDZWxsc0J5Q29sdW1uc0FuZFJvd3NIZWFkZXJzKGdjKSB7XG4gICAgdmFyIHByZWZpbGxDb2xvciwgcm93UHJlZmlsbENvbG9ycyxcbiAgICAgICAgY2VsbEV2ZW50LFxuICAgICAgICB2aXNpYmxlQ29sdW1ucyA9IHRoaXMudmlzaWJsZUNvbHVtbnMsXG4gICAgICAgIHZpc2libGVSb3dzID0gdGhpcy52aXNpYmxlUm93cyxcbiAgICAgICAgQyA9IHZpc2libGVDb2x1bW5zLmxlbmd0aCxcbiAgICAgICAgLy8gY0xhc3QgPSBDIC0gMSxcbiAgICAgICAgcm93SW5kZXgsIFIgPSB2aXNpYmxlUm93cy5sZW5ndGgsXG4gICAgICAgIHBvb2wgPSB0aGlzLmNlbGxFdmVudFBvb2w7XG5cbiAgICBpZiAoIUMgfHwgIVIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEZvciBlYWNoIGNvbHVtbi4uLlxuICAgIHZhciBwb29sSW5kZXggPSAwO1xuICAgIHZpc2libGVDb2x1bW5zLmZvckVhY2hXaXRoTmVnKGZ1bmN0aW9uKHZpc2libGVDb2x1bW4sIGNvbHVtbkluZGV4KSB7XG5cbiAgICAgICAgY2VsbEV2ZW50ID0gcG9vbFtwb29sSW5kZXhdO1xuICAgICAgICB2aXNpYmxlQ29sdW1uID0gY2VsbEV2ZW50LnZpc2libGVDb2x1bW47XG5cbiAgICAgICAgaWYgKCFyb3dQcmVmaWxsQ29sb3JzKSB7XG4gICAgICAgICAgICBwcmVmaWxsQ29sb3IgPSBjZWxsRXZlbnQuY29sdW1uLnByb3BlcnRpZXMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIGVhY2ggcm93IG9mIGVhY2ggc3ViZ3JpZCAob2YgZWFjaCBjb2x1bW4pLi4uXG4gICAgICAgIGZvciAocm93SW5kZXggPSAwOyByb3dJbmRleCA8IFI7IHJvd0luZGV4KyssIHBvb2xJbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAocm93UHJlZmlsbENvbG9ycykge1xuICAgICAgICAgICAgICAgIHByZWZpbGxDb2xvciA9IHJvd1ByZWZpbGxDb2xvcnNbcm93SW5kZXhdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBwb29sSXRlbSA9IHBvb2xbcG9vbEluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAocG9vbEl0ZW0uaXNIZWFkZXJSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFpbnRDZWxsKGdjLCBwb29sSXRlbSwgcHJlZmlsbENvbG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJFcnJvckNlbGwoZSwgZ2MsIHZpc2libGVDb2x1bW4sIHBvb2xbcG9vbEluZGV4XS52aXNpYmxlUm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLnBhaW50SGVhZGVyR3JpZGxpbmVzKGdjKTtcbn1cblxucGFpbnRDZWxsc0J5Q29sdW1uc0FuZFJvd3NIZWFkZXJzLmtleSA9ICdieS1jb2x1bW5zLWFuZC1yb3dzLWhlYWRlcnMnO1xucGFpbnRDZWxsc0J5Q29sdW1uc0FuZFJvd3NIZWFkZXJzLnJlYnVuZGxlID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYWludENlbGxzQnlDb2x1bW5zQW5kUm93c0hlYWRlcnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBidW5kbGVDb2x1bW5zID0gcmVxdWlyZSgnLi9idW5kbGUtY29sdW1ucycpO1xudmFyIGJ1bmRsZVJvd3MgPSByZXF1aXJlKCcuL2J1bmRsZS1yb3dzJyk7XG5cbi8qKiBAc3VtbWFyeSBSZW5kZXIgdGhlIGdyaWQgd2l0aCBjb25zb2xpZGF0ZWQgcm93IE9SIGNvbHVtbiByZWN0cy5cbiAqIEBkZXNjIFBhaW50cyBhbGwgdGhlIGNlbGxzIG9mIGEgZ3JpZCwgb25lIGNvbHVtbiBhdCBhIHRpbWUuXG4gKlxuICogRmlyc3QsIGEgYmFja2dyb3VuZCByZWN0IGlzIGRyYXduIHVzaW5nIHRoZSBncmlkIGJhY2tncm91bmQgY29sb3IuXG4gKlxuICogVGhlbiwgaWYgdGhlcmUgYXJlIGFueSByb3dzIHdpdGggdGhlaXIgb3duIGJhY2tncm91bmQgY29sb3IgX3RoYXQgZGlmZmVycyBmcm9tIHRoZSBncmlkIGJhY2tncm91bmQgY29sb3IsXyB0aGVzZSBhcmUgY29uc29saWRhdGVkIGFuZCB0aGUgY29uc29saWRhdGVkIGdyb3VwcyBvZiByb3cgYmFja2dyb3VuZHMgYXJlIGFsbCBkcmF3biBiZWZvcmUgaXRlcmF0aW5nIHRocm91Z2ggY2VsbHMuIFRoZXNlIHJvdyBiYWNrZ3JvdW5kcyBnZXQgcHJpb3JpdHkgb3ZlciBjb2x1bW4gYmFja2dyb3VuZHMuXG4gKlxuICogSWYgdGhlcmUgYXJlIG5vIHN1Y2ggcm93IGJhY2tncm91bmQgcmVjdHMgdG8gZHJhdywgdGhlIGNvbHVtbiByZWN0cyBhcmUgY29uc29saWRhdGVkIGFuZCBkcmF3biBpbnN0ZWFkIChhZ2FpbiwgYmVmb3JlIHRoZSBjZWxscykuIE5vdGUgdGhhdCB0aGVzZSBjb2x1bW4gcmVjdHMgYXJlIF9ub3RfIHN1aXRhYmxlIGZvciBjbGlwcGluZyBvdmVyZmxvdyB0ZXh0IGZyb20gcHJldmlvdXMgY29sdW1ucy4gSWYgeW91IGhhdmUgb3ZlcmZsb3cgdGV4dCwgZWl0aGVyIHR1cm4gb24gY2xpcHBpbmcgKGJpZyBwZXJmb3JtYW5jZSBoaXQpIG9yIHR1cm4gb24gb25lIG9mIHRoZSBgdHJ1bmNhdGVUZXh0V2l0aEVsbGlwc2lzYCBvcHRpb25zLlxuICpcbiAqIGB0cnkuLi5jYXRjaGAgc3Vycm91bmRzIGVhY2ggY2VsbCBwYWludCBpbiBjYXNlIGEgY2VsbCByZW5kZXJlciB0aHJvd3MgYW4gZXJyb3IuXG4gKiBUaGUgZXJyb3IgbWVzc2FnZSBpcyBlcnJvci1sb2dnZWQgdG8gY29uc29sZSBBTkQgZGlzcGxheWVkIGluIGNlbGwuXG4gKlxuICogRWFjaCBjZWxsIHRvIGJlIHJlbmRlcmVkIGlzIGRlc2NyaWJlZCBieSBhIHtAbGluayBDZWxsRXZlbnR9IG9iamVjdC4gRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHRvIGF2b2lkIGNvbnN0YW50bHkgaW5zdGFudGlhdGluZyB0aGVzZSBvYmplY3RzLCB3ZSBtYWludGFpbiBhIHBvb2wgb2YgdGhlc2UuIFdoZW4gdGhlIGdyaWQgc2hhcGUgY2hhbmdlcywgd2UgcmVzZXQgdGhlaXIgY29vcmRpbmF0ZXMgYnkgc2V0dGluZyB7QGxpbmsgQ2VsbEV2ZW50I3Jlc2V0fHJlc2V0fSBvbiBlYWNoLlxuICpcbiAqIFNlZSBhbHNvIHRoZSBkaXNjdXNzaW9uIG9mIGNsaXBwaW5nIGluIHtAbGluayBSZW5kZXJlciNwYWludENlbGxzQnlDb2x1bW5zfHBhaW50Q2VsbHNCeUNvbHVtbnN9LlxuICogQHRoaXMge1JlbmRlcmVyfVxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gKi9cbmZ1bmN0aW9uIHBhaW50Q2VsbHNCeUNvbHVtbnNBbmRSb3dzKGdjKSB7XG4gICAgdmFyIGdyaWQgPSB0aGlzLmdyaWQsXG4gICAgICAgIGdyaWRQcm9wcyA9IGdyaWQucHJvcGVydGllcyxcbiAgICAgICAgcHJlZmlsbENvbG9yLCByb3dQcmVmaWxsQ29sb3JzLCBncmlkUHJlZmlsbENvbG9yID0gZ3JpZFByb3BzLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgY2VsbEV2ZW50LFxuICAgICAgICByb3dCdW5kbGUsIHJvd0J1bmRsZXMsXG4gICAgICAgIGNvbHVtbkJ1bmRsZSwgY29sdW1uQnVuZGxlcyxcbiAgICAgICAgdmlzaWJsZUNvbHVtbnMgPSB0aGlzLnZpc2libGVDb2x1bW5zLFxuICAgICAgICB2aXNpYmxlUm93cyA9IHRoaXMudmlzaWJsZVJvd3MsXG4gICAgICAgIGMsIEMgPSB2aXNpYmxlQ29sdW1ucy5sZW5ndGgsXG4gICAgICAgIGNMYXN0ID0gQyAtIDEsXG4gICAgICAgIHJvd0luZGV4LCBSID0gdmlzaWJsZVJvd3MubGVuZ3RoLFxuICAgICAgICBwb29sID0gdGhpcy5jZWxsRXZlbnRQb29sLFxuICAgICAgICBjb2x1bW5DbGlwLFxuICAgICAgICAvLyBjbGlwVG9HcmlkLFxuICAgICAgICB2aWV3V2lkdGggPSBDID8gdmlzaWJsZUNvbHVtbnNbQyAtIDFdLnJpZ2h0IDogMCxcbiAgICAgICAgdmlld0hlaWdodCA9IFIgPyB2aXNpYmxlUm93c1tSIC0gMV0uYm90dG9tIDogMDtcblxuICAgIGdjLmNsZWFyUmVjdCgwLCAwLCB0aGlzLmJvdW5kcy53aWR0aCwgdGhpcy5ib3VuZHMuaGVpZ2h0KTtcbiAgICBnYy5maWxsU3R5bGUgPSBncmlkUHJvcHMuY2FudmFzQmFja2dyb3VuZENvbG9yO1xuICAgIGdjLmZpbGxSZWN0KDAsIDAsIHRoaXMuYm91bmRzLndpZHRoLCB0aGlzLmJvdW5kcy5oZWlnaHQpO1xuXG4gICAgaWYgKCFDIHx8ICFSKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKGdjLmFscGhhKGdyaWRQcmVmaWxsQ29sb3IpID4gMCkge1xuICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSBncmlkUHJlZmlsbENvbG9yO1xuICAgICAgICBnYy5maWxsUmVjdCgwLCAwLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmdyaWRSZW5kZXJlci5yZXNldCkge1xuICAgICAgICB0aGlzLnJlc2V0QWxsR3JpZFJlbmRlcmVycygpO1xuICAgICAgICB0aGlzLmdyaWRSZW5kZXJlci5yZXNldCA9IGZhbHNlO1xuICAgICAgICBidW5kbGVSb3dzLmNhbGwodGhpcywgZmFsc2UpO1xuICAgICAgICBidW5kbGVDb2x1bW5zLmNhbGwodGhpcywgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmdyaWRSZW5kZXJlci5yZWJ1bmRsZSkge1xuICAgICAgICB0aGlzLmdyaWRSZW5kZXJlci5yZWJ1bmRsZSA9IGZhbHNlO1xuICAgICAgICBidW5kbGVDb2x1bW5zLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgcm93QnVuZGxlcyA9IHRoaXMucm93QnVuZGxlcztcbiAgICBpZiAocm93QnVuZGxlcy5sZW5ndGgpIHtcbiAgICAgICAgcm93UHJlZmlsbENvbG9ycyA9IHRoaXMucm93UHJlZmlsbENvbG9ycztcbiAgICAgICAgZm9yIChyb3dJbmRleCA9IHJvd0J1bmRsZXMubGVuZ3RoOyByb3dJbmRleC0tOykge1xuICAgICAgICAgICAgcm93QnVuZGxlID0gcm93QnVuZGxlc1tyb3dJbmRleF07XG4gICAgICAgICAgICBnYy5jbGVhckZpbGwoMCwgcm93QnVuZGxlLnRvcCwgdmlld1dpZHRoLCByb3dCdW5kbGUuYm90dG9tIC0gcm93QnVuZGxlLnRvcCwgcm93QnVuZGxlLmJhY2tncm91bmRDb2xvcik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbHVtbkJ1bmRsZXMgPSB0aGlzLmNvbHVtbkJ1bmRsZXMsIGMgPSBjb2x1bW5CdW5kbGVzLmxlbmd0aDsgYy0tOykge1xuICAgICAgICAgICAgY29sdW1uQnVuZGxlID0gY29sdW1uQnVuZGxlc1tjXTtcbiAgICAgICAgICAgIGdjLmNsZWFyRmlsbChjb2x1bW5CdW5kbGUubGVmdCwgMCwgY29sdW1uQnVuZGxlLnJpZ2h0IC0gY29sdW1uQnVuZGxlLmxlZnQsIHZpZXdIZWlnaHQsIGNvbHVtbkJ1bmRsZS5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZ2MuY2xpcFNhdmUoY2xpcFRvR3JpZCwgMCwgMCwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0KTtcblxuICAgIC8vIEZvciBlYWNoIGNvbHVtbi4uLlxuICAgIHZhciBwb29sSW5kZXggPSAwO1xuICAgIHZpc2libGVDb2x1bW5zLmZvckVhY2hXaXRoTmVnKGZ1bmN0aW9uKHZpc2libGVDb2x1bW4sIGNvbHVtbkluZGV4KSB7XG5cbiAgICAgICAgY2VsbEV2ZW50ID0gcG9vbFtwb29sSW5kZXhdO1xuICAgICAgICB2aXNpYmxlQ29sdW1uID0gY2VsbEV2ZW50LnZpc2libGVDb2x1bW47XG5cbiAgICAgICAgaWYgKCFyb3dQcmVmaWxsQ29sb3JzKSB7XG4gICAgICAgICAgICBwcmVmaWxsQ29sb3IgPSBjZWxsRXZlbnQuY29sdW1uLnByb3BlcnRpZXMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3B0aW9uYWxseSBjbGlwIHRvIHZpc2libGUgcG9ydGlvbiBvZiBjb2x1bW4gdG8gcHJldmVudCB0ZXh0IGZyb20gb3ZlcmZsb3dpbmcgdG8gcmlnaHQuXG4gICAgICAgIGNvbHVtbkNsaXAgPSB2aXNpYmxlQ29sdW1uLmNvbHVtbi5wcm9wZXJ0aWVzLmNvbHVtbkNsaXA7XG4gICAgICAgIGdjLmNsaXBTYXZlKGNvbHVtbkNsaXAgfHwgY29sdW1uQ2xpcCA9PT0gbnVsbCAmJiBjb2x1bW5JbmRleCA9PT0gY0xhc3QsIDAsIDAsIHZpc2libGVDb2x1bW4ucmlnaHQsIHZpZXdIZWlnaHQpO1xuXG4gICAgICAgIC8vIEZvciBlYWNoIHJvdyBvZiBlYWNoIHN1YmdyaWQgKG9mIGVhY2ggY29sdW1uKS4uLlxuICAgICAgICBmb3IgKHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCBSOyByb3dJbmRleCsrLCBwb29sSW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKHJvd1ByZWZpbGxDb2xvcnMpIHtcbiAgICAgICAgICAgICAgICBwcmVmaWxsQ29sb3IgPSByb3dQcmVmaWxsQ29sb3JzW3Jvd0luZGV4XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYWludENlbGwoZ2MsIHBvb2xbcG9vbEluZGV4XSwgcHJlZmlsbENvbG9yKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckVycm9yQ2VsbChlLCBnYywgdmlzaWJsZUNvbHVtbiwgcG9vbFtwb29sSW5kZXhdLnZpc2libGVSb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2MuY2xpcFJlc3RvcmUoY29sdW1uQ2xpcCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIGdjLmNsaXBSZXN0b3JlKGNsaXBUb0dyaWQpO1xuXG4gICAgdGhpcy5wYWludEdyaWRsaW5lcyhnYyk7XG59XG5cbnBhaW50Q2VsbHNCeUNvbHVtbnNBbmRSb3dzLmtleSA9ICdieS1jb2x1bW5zLWFuZC1yb3dzJztcbnBhaW50Q2VsbHNCeUNvbHVtbnNBbmRSb3dzLnJlYnVuZGxlID0gdHJ1ZTsgLy8gc2VlIHJlYnVuZGxlR3JpZFJlbmRlcmVyc1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhaW50Q2VsbHNCeUNvbHVtbnNBbmRSb3dzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnVuZGxlQ29sdW1ucyA9IHJlcXVpcmUoJy4vYnVuZGxlLWNvbHVtbnMnKTtcblxuLyoqIEBzdW1tYXJ5IFJlbmRlciB0aGUgZ3JpZCB3aXRoIGRpc2NyZXRlIGNvbHVtbiByZWN0cy5cbiAqIEBkZXNjIFBhaW50cyBhbGwgdGhlIGNlbGxzIG9mIGEgZ3JpZCwgb25lIGNvbHVtbiBhdCBhIHRpbWUuXG4gKlxuICogSW4gdGhpcyBncmlkIHJlbmRlcmVyLCBhIGJhY2tncm91bmQgcmVjdCBpcyBfbm90XyBkcmF3biB1c2luZyB0aGUgZ3JpZCBiYWNrZ3JvdW5kIGNvbG9yLlxuICpcbiAqIFJhdGhlciwgYWxsIGNvbHVtbnMgcGFpbnQgdGhlaXIgb3duIGJhY2tncm91bmQgcmVjdHMsIHdpdGggY29sb3IgZGVmYXVsdGluZyB0byBncmlkIGJhY2tncm91bmQgY29sb3IuXG4gKlxuICogVGhlIGlkZWEgb2YgcGFpbnRpbmcgZWFjaCBjb2x1bW4gcmVjdCBpcyB0byBcImNsaXBcIiB0ZXh0IHRoYXQgbWlnaHQgaGF2ZSBvdmVyZmxvd2VkIGZyb20gdGhlIHByZXZpb3VzIGNvbHVtbiBieSBwYWludGluZyBvdmVyIGl0IHdpdGggdGhlIGJhY2tncm91bmQgZnJvbSB0aGlzIGNvbHVtbi4gT25seSB0aGUgbGFzdCBjb2x1bW4gd2lsbCBzaG93IG92ZXJmbG93aW5nIHRleHQsIGFuZCBvbmx5IGlmIHRoZSBjYW52YXMgd2lkdGggZXhjZWVkcyB0aGUgZ3JpZCB3aWR0aC4gSWYgdGhpcyBpcyB0aGUgY2FzZSwgeW91IGNhbiB0dXJuIG9uIGNsaXBwaW5nIGZvciB0aGUgbGFzdCBjb2x1bW4gb25seSBieSBzZXR0aW5nIGBjb2x1bW5DbGlwYCB0byBgdHJ1ZWAgZm9yIHRoZSBsYXN0IGNvbHVtbi5cbiAqXG4gKiBOT1RFOiBBcyBhIGNvbnZlbmllbmNlIGZlYXR1cmUsIHNldHRpbmcgYGNvbHVtbkNsaXBgIHRvIGBudWxsYCB3aWxsIGNsaXAgb25seSB0aGUgbGFzdCBjb2x1bW4sIHNvIHNpbXBseSBzZXR0aW5nIGl0IG9uIHRoZSBncmlkIChyYXRoZXIgdGhhbiB0aGUgbGFzdCBjb2x1bW4pIHdpbGwgaGF2ZSB0aGUgc2FtZSBlZmZlY3QuIFRoaXMgaXMgbXVjaCBtb3JlIGNvbnZlbmllbnQgYmVjYXVzZSB5b3UgZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCB0aGUgbGFzdCBjb2x1bW4gYmVpbmcgcmVkZWZpbmVkIChtb3ZlZCwgaGlkZGVuLCBldGMpLlxuICpcbiAqIGB0cnkuLi5jYXRjaGAgc3Vycm91bmRzIGVhY2ggY2VsbCBwYWludCBpbiBjYXNlIGEgY2VsbCByZW5kZXJlciB0aHJvd3MgYW4gZXJyb3IuXG4gKiBUaGUgZXJyb3IgbWVzc2FnZSBpcyBlcnJvci1sb2dnZWQgdG8gY29uc29sZSBBTkQgZGlzcGxheWVkIGluIGNlbGwuXG4gKlxuICogRWFjaCBjZWxsIHRvIGJlIHJlbmRlcmVkIGlzIGRlc2NyaWJlZCBieSBhIHtAbGluayBDZWxsRXZlbnR9IG9iamVjdC4gRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHRvIGF2b2lkIGNvbnN0YW50bHkgaW5zdGFudGlhdGluZyB0aGVzZSBvYmplY3RzLCB3ZSBtYWludGFpbiBhIHBvb2wgb2YgdGhlc2UuIFdoZW4gdGhlIGdyaWQgc2hhcGUgY2hhbmdlcywgd2UgcmVzZXQgdGhlaXIgY29vcmRpbmF0ZXMgYnkgc2V0dGluZyB7QGxpbmsgQ2VsbEV2ZW50I3Jlc2V0fHJlc2V0fSBvbiBlYWNoLlxuICpcbiAqIFNlZSBhbHNvIHRoZSBkaXNjdXNzaW9uIG9mIGNsaXBwaW5nIGluIHtAbGluayBSZW5kZXJlciNwYWludENlbGxzQnlDb2x1bW5zRGlzY3JldGV8cGFpbnRDZWxsc0J5Q29sdW1uc0Rpc2NyZXRlfS5cblxuICogQHRoaXMge1JlbmRlcmVyfVxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gKi9cbmZ1bmN0aW9uIHBhaW50Q2VsbHNCeUNvbHVtbnNEaXNjcmV0ZShnYykge1xuICAgIHZhciBwcmVmaWxsQ29sb3IsXG4gICAgICAgIGNlbGxFdmVudCxcbiAgICAgICAgdmlzaWJsZUNvbHVtbnMgPSB0aGlzLnZpc2libGVDb2x1bW5zLFxuICAgICAgICB2aXNpYmxlUm93cyA9IHRoaXMudmlzaWJsZVJvd3MsXG4gICAgICAgIEMgPSB2aXNpYmxlQ29sdW1ucy5sZW5ndGgsIGNMYXN0ID0gQyAtIDEsXG4gICAgICAgIHIsIFIgPSB2aXNpYmxlUm93cy5sZW5ndGgsXG4gICAgICAgIHBvb2wgPSB0aGlzLmNlbGxFdmVudFBvb2wsXG4gICAgICAgIHByZWZlcnJlZFdpZHRoLFxuICAgICAgICBjb2x1bW5DbGlwLFxuICAgICAgICAvLyBjbGlwVG9HcmlkLFxuICAgICAgICAvLyB2aWV3V2lkdGggPSBDID8gdmlzaWJsZUNvbHVtbnNbQyAtIDFdLnJpZ2h0IDogMCxcbiAgICAgICAgdmlld0hlaWdodCA9IFIgPyB2aXNpYmxlUm93c1tSIC0gMV0uYm90dG9tIDogMDtcblxuICAgIGdjLmNsZWFyUmVjdCgwLCAwLCB0aGlzLmJvdW5kcy53aWR0aCwgdGhpcy5ib3VuZHMuaGVpZ2h0KTtcblxuICAgIGlmICghQyB8fCAhUikgeyByZXR1cm47IH1cblxuICAgIGlmICh0aGlzLmdyaWRSZW5kZXJlci5yZXNldCkge1xuICAgICAgICB0aGlzLnJlc2V0QWxsR3JpZFJlbmRlcmVycyhbJ2J5LWNvbHVtbnMnXSk7XG4gICAgICAgIHRoaXMuZ3JpZFJlbmRlcmVyLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgIGJ1bmRsZUNvbHVtbnMuY2FsbCh0aGlzLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBnYy5jbGlwU2F2ZShjbGlwVG9HcmlkLCAwLCAwLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQpO1xuXG4gICAgLy8gRm9yIGVhY2ggY29sdW1uLi4uXG4gICAgdmFyIHAgPSAwO1xuICAgIHRoaXMudmlzaWJsZUNvbHVtbnMuZm9yRWFjaFdpdGhOZWcoZnVuY3Rpb24odmMsIGMpIHtcbiAgICAgICAgY2VsbEV2ZW50ID0gcG9vbFtwXTsgLy8gZmlyc3QgY2VsbCBpbiBjb2x1bW4gY1xuICAgICAgICB2YyA9IGNlbGxFdmVudC52aXNpYmxlQ29sdW1uO1xuXG4gICAgICAgIHByZWZpbGxDb2xvciA9IGNlbGxFdmVudC5jb2x1bW4ucHJvcGVydGllcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGdjLmNsZWFyRmlsbCh2Yy5sZWZ0LCAwLCB2Yy53aWR0aCwgdmlld0hlaWdodCwgcHJlZmlsbENvbG9yKTtcblxuICAgICAgICAvLyBPcHRpb25hbGx5IGNsaXAgdG8gdmlzaWJsZSBwb3J0aW9uIG9mIGNvbHVtbiB0byBwcmV2ZW50IHRleHQgZnJvbSBvdmVyZmxvd2luZyB0byByaWdodC5cbiAgICAgICAgY29sdW1uQ2xpcCA9IHZjLmNvbHVtbi5wcm9wZXJ0aWVzLmNvbHVtbkNsaXA7XG4gICAgICAgIGdjLmNsaXBTYXZlKGNvbHVtbkNsaXAgfHwgY29sdW1uQ2xpcCA9PT0gbnVsbCAmJiBjID09PSBjTGFzdCwgMCwgMCwgdmMucmlnaHQsIHZpZXdIZWlnaHQpO1xuXG4gICAgICAgIC8vIEZvciBlYWNoIHJvdyBvZiBlYWNoIHN1YmdyaWQgKG9mIGVhY2ggY29sdW1uKS4uLlxuICAgICAgICBmb3IgKHByZWZlcnJlZFdpZHRoID0gciA9IDA7IHIgPCBSOyByKyssIHArKykge1xuICAgICAgICAgICAgY2VsbEV2ZW50ID0gcG9vbFtwXTsgLy8gbmV4dCBjZWxsIGRvd24gdGhlIGNvbHVtbiAocmVkdW5kYW50IGZvciBmaXJzdCBjZWxsIGluIGNvbHVtbilcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcmVmZXJyZWRXaWR0aCA9IE1hdGgubWF4KHByZWZlcnJlZFdpZHRoLCB0aGlzLl9wYWludENlbGwoZ2MsIGNlbGxFdmVudCwgcHJlZmlsbENvbG9yKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJFcnJvckNlbGwoZSwgZ2MsIHZjLCBjZWxsRXZlbnQudmlzaWJsZVJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnYy5jbGlwUmVzdG9yZShjb2x1bW5DbGlwKTtcblxuICAgICAgICBjZWxsRXZlbnQuY29sdW1uLnByb3BlcnRpZXMucHJlZmVycmVkV2lkdGggPSBNYXRoLnJvdW5kKHByZWZlcnJlZFdpZHRoKTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgLy8gZ2MuY2xpcFJlc3RvcmUoY2xpcFRvR3JpZCk7XG5cbiAgICB0aGlzLnBhaW50R3JpZGxpbmVzKGdjKTtcbn1cblxucGFpbnRDZWxsc0J5Q29sdW1uc0Rpc2NyZXRlLmtleSA9ICdieS1jb2x1bW5zLWRpc2NyZXRlJztcblxubW9kdWxlLmV4cG9ydHMgPSBwYWludENlbGxzQnlDb2x1bW5zRGlzY3JldGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBidW5kbGVDb2x1bW5zID0gcmVxdWlyZSgnLi9idW5kbGUtY29sdW1ucycpO1xuXG4vKiogQHN1bW1hcnkgUmVuZGVyIHRoZSBncmlkIHdpdGggY29uc29saWRhdGVkIGNvbHVtbiByZWN0cy5cbiAqIEBkZXNjIFBhaW50cyBhbGwgdGhlIGNlbGxzIG9mIGEgZ3JpZCwgb25lIGNvbHVtbiBhdCBhIHRpbWUuXG4gKlxuICogRmlyc3QsIGEgYmFja2dyb3VuZCByZWN0IGlzIGRyYXduIHVzaW5nIHRoZSBncmlkIGJhY2tncm91bmQgY29sb3IuXG4gKlxuICogVGhlbiwgaWYgdGhlcmUgYXJlIGFueSBjb2x1bW5zIHdpdGggdGhlaXIgb3duIGJhY2tncm91bmQgY29sb3IgX3RoYXQgZGlmZmVycyBmcm9tIHRoZSBncmlkIGJhY2tncm91bmQgY29sb3IsXyB0aGVzZSBhcmUgY29uc29saWRhdGVkIGFuZCB0aGUgY29uc29saWRhdGVkIGdyb3VwcyBvZiBjb2x1bW4gYmFja2dyb3VuZHMgYXJlIGFsbCBkcmF3biBiZWZvcmUgaXRlcmF0aW5nIHRocm91Z2ggY2VsbHMuIE5vdGUgdGhhdCB0aGVzZSBjb2x1bW4gcmVjdHMgYXJlIF9ub3RfIHN1aXRhYmxlIGZvciBjbGlwcGluZyBvdmVyZmxvdyB0ZXh0IGZyb20gcHJldmlvdXMgY29sdW1ucy4gSWYgeW91IGhhdmUgb3ZlcmZsb3cgdGV4dCwgZWl0aGVyIHR1cm4gb24gY2xpcHBpbmcgKGJpZyBwZXJmb3JtYW5jZSBoaXQpIG9yIHR1cm4gb24gb25lIG9mIHRoZSBgdHJ1bmNhdGVUZXh0V2l0aEVsbGlwc2lzYCBvcHRpb25zLlxuICpcbiAqIGB0cnkuLi5jYXRjaGAgc3Vycm91bmRzIGVhY2ggY2VsbCBwYWludCBpbiBjYXNlIGEgY2VsbCByZW5kZXJlciB0aHJvd3MgYW4gZXJyb3IuXG4gKiBUaGUgZXJyb3IgbWVzc2FnZSBpcyBlcnJvci1sb2dnZWQgdG8gY29uc29sZSBBTkQgZGlzcGxheWVkIGluIGNlbGwuXG4gKlxuICogRWFjaCBjZWxsIHRvIGJlIHJlbmRlcmVkIGlzIGRlc2NyaWJlZCBieSBhIHtAbGluayBDZWxsRXZlbnR9IG9iamVjdC4gRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHRvIGF2b2lkIGNvbnN0YW50bHkgaW5zdGFudGlhdGluZyB0aGVzZSBvYmplY3RzLCB3ZSBtYWludGFpbiBhIHBvb2wgb2YgdGhlc2UuIFdoZW4gdGhlIGdyaWQgc2hhcGUgY2hhbmdlcywgd2UgcmVzZXQgdGhlaXIgY29vcmRpbmF0ZXMgYnkgc2V0dGluZyB7QGxpbmsgQ2VsbEV2ZW50I3Jlc2V0fHJlc2V0fSBvbiBlYWNoLlxuICpcbiAqICoqUmVnYWRpbmcgY2xpcHBpbmcuKiogVGhlIHJlYXNvbiBmb3IgY2xpcHBpbmcgaXMgdG8gcHJldmVudCB0ZXh0IGZyb20gb3ZlcmZsb3dpbmcgaW50byB0aGUgbmV4dCBjb2x1bW4uIEhvd2V2ZXIgdGhlcmUgaXMgYSBzZXJpb3VzIHBlcmZvcm1hbmNlIGNvc3QuXG4gKlxuICogRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMge0BsaW5rIFJlbmRlcmVyI19wYWludENlbGx8X3BhaW50Q2VsbH0gZG9lcyBub3Qgc2V0IHVwIGEgY2xpcHBpbmcgcmVnaW9uIGZvciBlYWNoIGNlbGwuIEhvd2V2ZXIsIGlmZiBncmlkIHByb3BlcnR5IGBjb2x1bW5DbGlwYCBpcyB0cnV0aHksIHRoaXMgZ3JpZCByZW5kZXJlciB3aWxsIHNldCB1cCBhIGNsaXBwaW5nIHJlZ2lvbiB0byBwcmV2ZW50IHRleHQgb3ZlcmZsb3cgdG8gcmlnaHQuIElmIGBjb2x1bW5DbGlwYCBpcyBgbnVsbGAsIGEgY2xpcHBpbmcgcmVnaW9uIHdpbGwgb25seSBiZSBzZXQgdXAgb24gdGhlIGxhc3QgY29sdW1uLiBPdGhlcndpc2UsIHRoZXJlIHdpbGwgYmUgbm8gY2xpcHBpbmcgcmVnaW9uLlxuICpcbiAqIFRoZSBpZGVhIG9mIGNsaXBwaW5nIGp1c3QgdGhlIGxhc3QgY29sdW1uIGlzIGJlY2F1c2UgaW4gYWRkaXRpb24gdG8gdGhlIG9wdGlvbmFsIGdyYXBoaWNzIGNsaXBwaW5nLCB3ZSBhbHNvIGNsaXAgKFwidHJ1bmNhdGVcIikgdGV4dC4gVGV4dCBjYW4gYmUgdHJ1bmNhdGVkIGNvbnNlcnZhdGl2ZWx5IHNvIGl0IHdpbGwgbmV2ZXIgb3ZlcmZsb3cuIFRoZSBwcm9ibGVtIHdpdGggdGhpcyBpcyB0aGF0IGNoYXJhY3RlcnMgdmFuaXNoIGFzIHRoZXkgaGl0IHRoZSByaWdodCBjZWxsIGJvdW5kYXJ5LCB3aGljaCBtYXkgb3IgbWF5IGJlIG9idmlvdXMgZGVwZW5kaW5nIG9uIGZvbnQgc2l6ZS4gQWx0ZXJuYXRpdmVseSwgdGV4dCBjYW4gYmUgdHJ1bmNhdGVkIHNvIHRoYXQgdGhlIG92ZXJmbG93IHdpbGwgYmUgYSBtYXhpbXVtIG9mIDEgY2hhcmFjdGVyLiBUaGlzIGFsbG93cyBwYXJ0aWFsIGNoYXJhY3RlcnMgdG8gYmUgcmVuZGVyZWQuIEJ1dCB0aGlzIGlzIHdoZXJlIGdyYXBoaWNzIGNsaXBwaW5nIGlzIHJlcXVpcmVkLlxuICpcbiAqIFdoZW4gcmVuZGVyZXJpbmcgY29sdW1uIGJ5IGNvbHVtbiBhcyB0aGlzIHBhcnRpY3VsYXIgcmVuZGVyZXIgZG9lcywgX2FuZF8gd2hlbiB0aGUgYmFja2dyb3VuZCBjb2xvciBfb2YgdGhlIG5leHQgY2VsbCB0byB0aGUgcmlnaHRfIGlzIG9wYXF1ZSAoYWxwaGEgPSAxKSwgY2xpcHBpbmcgY2FuIGJlIHR1cm5lZCBvZmYgYmVjYXVzZSBlYWNoIGNvbHVtbiB3aWxsIF9vdmVycGFpbnRfIGFueSB0ZXh0IHRoYXQgb3ZlcmZsb3dlZCBmcm9tIHRoZSBvbmUgYmVmb3JlLiBIb3dldmVyLCBhbnkgdGV4dCB0aGF0IG92ZXJmbG93cyB0aGUgbGFzdCBjb2x1bW4gd2lsbCBwYWludCBpbnRvIHVudXNlZCBjYW52YXMgcmVnaW9uIHRvIHRoZSByaWdodCBvZiB0aGUgZ3JpZC4gVGhpcyBpcyB0aGUgX3JhaXNvbiBkJ8OqdHJlXyBmb3IgXCJjbGlwIGxhc3QgY29sdW1uIG9ubHlcIiBvcHRpb24gbWVudGlvbmVkIGFib3ZlICh3aGVuIGBjb2x1bW5DbGlwYCBpcyBzZXQgdG8gYG51bGxgKS4gVG8gYXZvaWQgZXZlbiB0aGlzIHBlcmZvcm1hbmNlIGNvc3QgKG9mIGNsaXBwaW5nIGp1c3QgdGhlIGxhc3QgY29sdW1uKSwgY29sdW1uIHdpZHRocyBjYW4gYmUgc2V0IHRvIGZpbGwgdGhlIGF2YWlsYWJsZSBjYW52YXMuXG4gKlxuICogTm90ZSB0aGF0IHRleHQgbmV2ZXIgb3ZlcmZsb3dzIHRvIGxlZnQgYmVjYXVzZSB0ZXh0IHN0YXJ0aW5nIHBvaW50IGlzIG5ldmVyIDwgMC4gVGhlIHJlYXNvbiB3ZSBkb24ndCBjbGlwIHRvIHRoZSBsZWZ0IGlzIGZvciBjZWxsIHJlbmRlcmVycyB0aGF0IG5lZWQgdG8gcmUtcmVuZGVyIHRvIHRoZSBsZWZ0IHRvIHByb2R1Y2UgYSBtZXJnZWQgY2VsbCBlZmZlY3QsIHN1Y2ggYXMgZ3JvdXBlZCBjb2x1bW4gaGVhZGVyLlxuXG4gKiBAdGhpcyB7UmVuZGVyZXJ9XG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gZ2NcbiAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAqL1xuZnVuY3Rpb24gcGFpbnRDZWxsc0J5Q29sdW1ucyhnYykge1xuICAgIHZhciBncmlkID0gdGhpcy5ncmlkLFxuICAgICAgICBncmlkUHJvcHMgPSBncmlkLnByb3BlcnRpZXMsXG4gICAgICAgIHByZWZpbGxDb2xvciwgZ3JpZFByZWZpbGxDb2xvciA9IGdyaWRQcm9wcy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgIGNlbGxFdmVudCxcbiAgICAgICAgY29sdW1uQnVuZGxlLCBjb2x1bW5CdW5kbGVzLFxuICAgICAgICB2aXNpYmxlQ29sdW1ucyA9IHRoaXMudmlzaWJsZUNvbHVtbnMsXG4gICAgICAgIHZpc2libGVSb3dzID0gdGhpcy52aXNpYmxlUm93cyxcbiAgICAgICAgYywgQyA9IHZpc2libGVDb2x1bW5zLmxlbmd0aCwgY0xhc3QgPSBDIC0gMSxcbiAgICAgICAgciwgUiA9IHZpc2libGVSb3dzLmxlbmd0aCxcbiAgICAgICAgcG9vbCA9IHRoaXMuY2VsbEV2ZW50UG9vbCxcbiAgICAgICAgcHJlZmVycmVkV2lkdGgsXG4gICAgICAgIGNvbHVtbkNsaXAsXG4gICAgICAgIC8vIGNsaXBUb0dyaWQsXG4gICAgICAgIHZpZXdXaWR0aCA9IEMgPyB2aXNpYmxlQ29sdW1uc1tjTGFzdF0ucmlnaHQgOiAwLFxuICAgICAgICB2aWV3SGVpZ2h0ID0gUiA/IHZpc2libGVSb3dzW1IgLSAxXS5ib3R0b20gOiAwO1xuXG5cbiAgICBnYy5jbGVhclJlY3QoMCwgMCwgdGhpcy5ib3VuZHMud2lkdGgsIHRoaXMuYm91bmRzLmhlaWdodCk7XG5cbiAgICBpZiAoIUMgfHwgIVIpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAoZ2MuYWxwaGEoZ3JpZFByZWZpbGxDb2xvcikgPiAwKSB7XG4gICAgICAgIGdjLmNhY2hlLmZpbGxTdHlsZSA9IGdyaWRQcmVmaWxsQ29sb3I7XG4gICAgICAgIGdjLmZpbGxSZWN0KDAsIDAsIHZpZXdXaWR0aCwgdmlld0hlaWdodCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ3JpZFJlbmRlcmVyLnJlc2V0KSB7XG4gICAgICAgIHRoaXMucmVzZXRBbGxHcmlkUmVuZGVyZXJzKFsnYnktY29sdW1ucy1kaXNjcmV0ZSddKTtcbiAgICAgICAgdGhpcy5ncmlkUmVuZGVyZXIucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgYnVuZGxlQ29sdW1ucy5jYWxsKHRoaXMsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5ncmlkUmVuZGVyZXIucmVidW5kbGUpIHtcbiAgICAgICAgdGhpcy5ncmlkUmVuZGVyZXIucmVidW5kbGUgPSBmYWxzZTtcbiAgICAgICAgYnVuZGxlQ29sdW1ucy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZvciAoY29sdW1uQnVuZGxlcyA9IHRoaXMuY29sdW1uQnVuZGxlcywgYyA9IGNvbHVtbkJ1bmRsZXMubGVuZ3RoOyBjLS07KSB7XG4gICAgICAgIGNvbHVtbkJ1bmRsZSA9IGNvbHVtbkJ1bmRsZXNbY107XG4gICAgICAgIGdjLmNsZWFyRmlsbChjb2x1bW5CdW5kbGUubGVmdCwgMCwgY29sdW1uQnVuZGxlLnJpZ2h0IC0gY29sdW1uQnVuZGxlLmxlZnQsIHZpZXdIZWlnaHQsIGNvbHVtbkJ1bmRsZS5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgIH1cblxuICAgIC8vIGdjLmNsaXBTYXZlKGNsaXBUb0dyaWQsIDAsIDAsIHZpZXdXaWR0aCwgdmlld0hlaWdodCk7XG5cbiAgICAvLyBGb3IgZWFjaCBjb2x1bW4uLi5cbiAgICB2YXIgcCA9IDA7XG4gICAgdGhpcy52aXNpYmxlQ29sdW1ucy5mb3JFYWNoV2l0aE5lZyhmdW5jdGlvbih2YywgYykge1xuICAgICAgICBjZWxsRXZlbnQgPSBwb29sW3BdOyAvLyBmaXJzdCBjZWxsIGluIGNvbHVtbiBjXG4gICAgICAgIHZjID0gY2VsbEV2ZW50LnZpc2libGVDb2x1bW47XG5cbiAgICAgICAgcHJlZmlsbENvbG9yID0gY2VsbEV2ZW50LmNvbHVtbi5wcm9wZXJ0aWVzLmJhY2tncm91bmRDb2xvcjtcblxuICAgICAgICAvLyBPcHRpb25hbGx5IGNsaXAgdG8gdmlzaWJsZSBwb3J0aW9uIG9mIGNvbHVtbiB0byBwcmV2ZW50IHRleHQgZnJvbSBvdmVyZmxvd2luZyB0byByaWdodC5cbiAgICAgICAgY29sdW1uQ2xpcCA9IHZjLmNvbHVtbi5wcm9wZXJ0aWVzLmNvbHVtbkNsaXA7XG4gICAgICAgIGdjLmNsaXBTYXZlKGNvbHVtbkNsaXAgfHwgY29sdW1uQ2xpcCA9PT0gbnVsbCAmJiBjID09PSBjTGFzdCwgMCwgMCwgdmMucmlnaHQsIHZpZXdIZWlnaHQpO1xuXG4gICAgICAgIC8vIEZvciBlYWNoIHJvdyBvZiBlYWNoIHN1YmdyaWQgKG9mIGVhY2ggY29sdW1uKS4uLlxuICAgICAgICBmb3IgKHByZWZlcnJlZFdpZHRoID0gciA9IDA7IHIgPCBSOyByKyssIHArKykge1xuICAgICAgICAgICAgY2VsbEV2ZW50ID0gcG9vbFtwXTsgLy8gbmV4dCBjZWxsIGRvd24gdGhlIGNvbHVtbiAocmVkdW5kYW50IGZvciBmaXJzdCBjZWxsIGluIGNvbHVtbilcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcmVmZXJyZWRXaWR0aCA9IE1hdGgubWF4KHByZWZlcnJlZFdpZHRoLCB0aGlzLl9wYWludENlbGwoZ2MsIGNlbGxFdmVudCwgcHJlZmlsbENvbG9yKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJFcnJvckNlbGwoZSwgZ2MsIHZjLCBjZWxsRXZlbnQudmlzaWJsZVJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnYy5jbGlwUmVzdG9yZShjb2x1bW5DbGlwKTtcblxuICAgICAgICBjZWxsRXZlbnQuY29sdW1uLnByb3BlcnRpZXMucHJlZmVycmVkV2lkdGggPSBNYXRoLnJvdW5kKHByZWZlcnJlZFdpZHRoKTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgLy8gZ2MuY2xpcFJlc3RvcmUoY2xpcFRvR3JpZCk7XG5cbiAgICB0aGlzLnBhaW50R3JpZGxpbmVzKGdjKTtcbn1cblxucGFpbnRDZWxsc0J5Q29sdW1ucy5rZXkgPSAnYnktY29sdW1ucyc7XG5wYWludENlbGxzQnlDb2x1bW5zLnJlYnVuZGxlID0gdHJ1ZTsgLy8gc2VlIHJlYnVuZGxlR3JpZFJlbmRlcmVyc1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhaW50Q2VsbHNCeUNvbHVtbnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBidW5kbGVSb3dzID0gcmVxdWlyZSgnLi9idW5kbGUtcm93cycpO1xuXG4vKiogQHN1bW1hcnkgUmVuZGVyIHRoZSBncmlkLlxuICogQGRlc2MgXyoqTk9URToqKiBUaGlzIGdyaWQgcmVuZGVyZXIgaXMgbm90IGFzIHBlcmZvcm1hbnQgYXMgdGhlIG90aGVycyBhbmQgaXQncyB1c2UgaXMgbm90IHJlY29tbWVuZGVkIGlmIHlvdSBjYXJlIGFib3V0IHBlcmZvcm1hbmNlLiBUaGUgcmVhc29ucyBmb3IgdGhlIHdhbnRpbmcgcGVyZm9ybWFuY2UgYXJlIHVuY2xlYXIsIHBvc3NpYmx5IGhhdmluZyB0byBkbyB3aXRoIHRoZSB3YXkgQ2hyb21lIG9wdGltaXplcyBhY2Nlc3MgdG8gdGhlIGNvbHVtbiBvYmplY3RzP19cbiAqXG4gKiBQYWludHMgYWxsIHRoZSBjZWxscyBvZiBhIGdyaWQsIG9uZSByb3cgYXQgYSB0aW1lLlxuICpcbiAqIEZpcnN0LCBhIGJhY2tncm91bmQgcmVjdCBpcyBkcmF3biB1c2luZyB0aGUgZ3JpZCBiYWNrZ3JvdW5kIGNvbG9yLlxuICpcbiAqIFRoZW4sIGlmIHRoZXJlIGFyZSBhbnkgcm93cyB3aXRoIHRoZWlyIG93biBiYWNrZ3JvdW5kIGNvbG9yIF90aGF0IGRpZmZlcnMgZnJvbSB0aGUgZ3JpZCBiYWNrZ3JvdW5kIGNvbG9yLF8gdGhlc2UgYXJlIGNvbnNvbGlkYXRlZCBhbmQgdGhlIGNvbnNvbGlkYXRlZCBncm91cHMgb2Ygcm93IGJhY2tncm91bmRzIGFyZSBhbGwgZHJhd24gYmVmb3JlIGl0ZXJhdGluZyB0aHJvdWdoIGNlbGxzLlxuICpcbiAqIGB0cnkuLi5jYXRjaGAgc3Vycm91bmRzIGVhY2ggY2VsbCBwYWludCBpbiBjYXNlIGEgY2VsbCByZW5kZXJlciB0aHJvd3MgYW4gZXJyb3IuXG4gKiBUaGUgZXJyb3IgbWVzc2FnZSBpcyBlcnJvci1sb2dnZWQgdG8gY29uc29sZSBBTkQgZGlzcGxheWVkIGluIGNlbGwuXG4gKlxuICogRWFjaCBjZWxsIHRvIGJlIHJlbmRlcmVkIGlzIGRlc2NyaWJlZCBieSBhIHtAbGluayBDZWxsRXZlbnR9IG9iamVjdC4gRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHRvIGF2b2lkIGNvbnN0YW50bHkgaW5zdGFudGlhdGluZyB0aGVzZSBvYmplY3RzLCB3ZSBtYWludGFpbiBhIHBvb2wgb2YgdGhlc2UuIFdoZW4gdGhlIGdyaWQgc2hhcGUgY2hhbmdlcywgd2UgcmVzZXQgdGhlaXIgY29vcmRpbmF0ZXMgYnkgc2V0dGluZyB7QGxpbmsgQ2VsbEV2ZW50I3Jlc2V0fHJlc2V0fSBvbiBlYWNoLlxuICpcbiAqIFNlZSBhbHNvIHRoZSBkaXNjdXNzaW9uIG9mIGNsaXBwaW5nIGluIHtAbGluayBSZW5kZXJlciNwYWludENlbGxzQnlDb2x1bW5zfHBhaW50Q2VsbHNCeUNvbHVtbnN9LlxuICogQHRoaXMge1JlbmRlcmVyfVxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gKi9cbmZ1bmN0aW9uIHBhaW50Q2VsbHNCeVJvd3MoZ2MpIHtcbiAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZCxcbiAgICAgICAgZ3JpZFByb3BzID0gZ3JpZC5wcm9wZXJ0aWVzLFxuICAgICAgICBwcmVmaWxsQ29sb3IsIHJvd1ByZWZpbGxDb2xvcnMsIGdyaWRQcmVmaWxsQ29sb3IgPSBncmlkUHJvcHMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICBjZWxsRXZlbnQsXG4gICAgICAgIHJvd0J1bmRsZSwgcm93QnVuZGxlcyA9IHRoaXMucm93QnVuZGxlcyxcbiAgICAgICAgdmlzaWJsZUNvbHVtbnMgPSB0aGlzLnZpc2libGVDb2x1bW5zLFxuICAgICAgICB2ciwgdmlzaWJsZVJvd3MgPSB0aGlzLnZpc2libGVSb3dzLFxuICAgICAgICBjLCBDID0gdmlzaWJsZUNvbHVtbnMubGVuZ3RoLCBjMCA9IDAsIGNMYXN0ID0gQyAtIDEsXG4gICAgICAgIHIsIFIgPSB2aXNpYmxlUm93cy5sZW5ndGgsXG4gICAgICAgIHAsIHBvb2wgPSB0aGlzLmNlbGxFdmVudFBvb2wsXG4gICAgICAgIHByZWZlcnJlZFdpZHRoID0gQXJyYXkoQyAtIGMwKS5maWxsKDApLFxuICAgICAgICBjb2x1bW5DbGlwLFxuICAgICAgICAvLyBjbGlwVG9HcmlkLFxuICAgICAgICB2aWV3V2lkdGggPSBDID8gdmlzaWJsZUNvbHVtbnNbQyAtIDFdLnJpZ2h0IDogMCxcbiAgICAgICAgdmlld0hlaWdodCA9IFIgPyB2aXNpYmxlUm93c1tSIC0gMV0uYm90dG9tIDogMCxcbiAgICAgICAgZHJhd0xpbmVzID0gZ3JpZFByb3BzLmdyaWRMaW5lc0gsXG4gICAgICAgIGxpbmVXaWR0aCA9IGdyaWRQcm9wcy5ncmlkTGluZXNXaWR0aCxcbiAgICAgICAgbGluZUNvbG9yID0gZ3JpZFByb3BzLmdyaWRMaW5lc0NvbG9yO1xuXG4gICAgZ2MuY2xlYXJSZWN0KDAsIDAsIHRoaXMuYm91bmRzLndpZHRoLCB0aGlzLmJvdW5kcy5oZWlnaHQpO1xuXG4gICAgaWYgKCFDIHx8ICFSKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKGdjLmFscGhhKGdyaWRQcmVmaWxsQ29sb3IpID4gMCkge1xuICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSBncmlkUHJlZmlsbENvbG9yO1xuICAgICAgICBnYy5maWxsUmVjdCgwLCAwLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmdyaWRSZW5kZXJlci5yZXNldCkge1xuICAgICAgICB0aGlzLnJlc2V0QWxsR3JpZFJlbmRlcmVycygpO1xuICAgICAgICB0aGlzLmdyaWRSZW5kZXJlci5yZXNldCA9IGZhbHNlO1xuICAgICAgICBidW5kbGVSb3dzLmNhbGwodGhpcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcm93UHJlZmlsbENvbG9ycyA9IHRoaXMucm93UHJlZmlsbENvbG9ycztcblxuICAgIGZvciAociA9IHJvd0J1bmRsZXMubGVuZ3RoOyByLS07KSB7XG4gICAgICAgIHJvd0J1bmRsZSA9IHJvd0J1bmRsZXNbcl07XG4gICAgICAgIGdjLmNsZWFyRmlsbCgwLCByb3dCdW5kbGUudG9wLCB2aWV3V2lkdGgsIHJvd0J1bmRsZS5ib3R0b20gLSByb3dCdW5kbGUudG9wLCByb3dCdW5kbGUuYmFja2dyb3VuZENvbG9yKTtcbiAgICB9XG5cbiAgICAvLyBnYy5jbGlwU2F2ZShjbGlwVG9HcmlkLCAwLCAwLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQpO1xuXG4gICAgLy8gRm9yIGVhY2ggcm93IG9mIGVhY2ggc3ViZ3JpZC4uLlxuICAgIGZvciAocCA9IDAsIHIgPSAwOyByIDwgUjsgcisrKSB7XG4gICAgICAgIHByZWZpbGxDb2xvciA9IHJvd1ByZWZpbGxDb2xvcnNbcl07XG5cbiAgICAgICAgaWYgKGRyYXdMaW5lcykge1xuICAgICAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gbGluZUNvbG9yO1xuICAgICAgICAgICAgZ2MuZmlsbFJlY3QoMCwgcG9vbFtwXS52aXNpYmxlUm93LmJvdHRvbSwgdmlld1dpZHRoLCBsaW5lV2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIGVhY2ggY29sdW1uIChvZiBlYWNoIHJvdykuLi5cbiAgICAgICAgdGhpcy52aXNpYmxlQ29sdW1ucy5mb3JFYWNoV2l0aE5lZyhmdW5jdGlvbih2YykgeyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgICAgICAgIHArKztcbiAgICAgICAgICAgIGNlbGxFdmVudCA9IHBvb2xbcF07IC8vIG5leHQgY2VsbCBhY3Jvc3MgdGhlIHJvdyAocmVkdW5kYW50IGZvciBmaXJzdCBjZWxsIGluIHJvdylcbiAgICAgICAgICAgIHZjID0gY2VsbEV2ZW50LnZpc2libGVDb2x1bW47XG5cbiAgICAgICAgICAgIC8vIE9wdGlvbmFsbHkgY2xpcCB0byB2aXNpYmxlIHBvcnRpb24gb2YgY29sdW1uIHRvIHByZXZlbnQgdGV4dCBmcm9tIG92ZXJmbG93aW5nIHRvIHJpZ2h0LlxuICAgICAgICAgICAgY29sdW1uQ2xpcCA9IHZjLmNvbHVtbi5wcm9wZXJ0aWVzLmNvbHVtbkNsaXA7XG4gICAgICAgICAgICBnYy5jbGlwU2F2ZShjb2x1bW5DbGlwIHx8IGNvbHVtbkNsaXAgPT09IG51bGwgJiYgYyA9PT0gY0xhc3QsIDAsIDAsIHZjLnJpZ2h0LCB2aWV3SGVpZ2h0KTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcmVmZXJyZWRXaWR0aFtjXSA9IE1hdGgubWF4KHByZWZlcnJlZFdpZHRoW2NdLCB0aGlzLl9wYWludENlbGwoZ2MsIGNlbGxFdmVudCwgcHJlZmlsbENvbG9yKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJFcnJvckNlbGwoZSwgZ2MsIHZjLCB2cik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdjLmNsaXBSZXN0b3JlKGNvbHVtbkNsaXApO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8vIGdjLmNsaXBSZXN0b3JlKGNsaXBUb0dyaWQpO1xuXG4gICAgdGhpcy5wYWludEdyaWRsaW5lcyhnYyk7XG5cbiAgICB0aGlzLnZpc2libGVDb2x1bW5zLmZvckVhY2hXaXRoTmVnKGZ1bmN0aW9uKHZjLCBjKSB7XG4gICAgICAgIHZjLmNvbHVtbi5wcm9wZXJ0aWVzLnByZWZlcnJlZFdpZHRoID0gTWF0aC5yb3VuZChwcmVmZXJyZWRXaWR0aFtjXSk7XG4gICAgfSk7XG59XG5cbnBhaW50Q2VsbHNCeVJvd3Mua2V5ID0gJ2J5LXJvd3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhaW50Q2VsbHNCeVJvd3M7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbi8qIGdsb2JhbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4uL0Jhc2UnKTtcbnZhciBpbWFnZXMgPSByZXF1aXJlKCcuLi8uLi9pbWFnZXMnKTtcbnZhciBsYXllclByb3BzID0gcmVxdWlyZSgnLi9sYXllci1wcm9wcycpO1xuXG5cbnZhciB2aXNpYmxlQ29sdW1uUHJvcGVydGllc0Rlc2NyaXB0b3JGbiA9IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmaW5kV2l0aE5lZzoge1xuICAgICAgICAgICAgLy8gTGlrZSB0aGUgQXJyYXkucHJvdG90eXBlIHZlcnNpb24gZXhjZXB0IHNlYXJjaGVzIHRoZSBuZWdhdGl2ZSBpbmRleGVzIGFzIHdlbGwuXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gZ3JpZC5iZWhhdmlvci5sZWZ0TW9zdENvbEluZGV4OyBpIDwgMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZXJhdGVlLmNhbGwoY29udGV4dCwgdGhpc1tpXSwgaSwgdGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKHRoaXMsIGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZm9yRWFjaFdpdGhOZWc6IHtcbiAgICAgICAgICAgIC8vIExpa2UgdGhlIEFycmF5LnByb3RvdHlwZSB2ZXJzaW9uIGV4Y2VwdCBpdCBpdGVyYXRlcyB0aGUgbmVnYXRpdmUgaW5kZXhlcyBhcyB3ZWxsLlxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGdyaWQuYmVoYXZpb3IubGVmdE1vc3RDb2xJbmRleDsgaSA8IDA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdGVlLmNhbGwoY29udGV4dCwgdGhpc1tpXSwgaSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHRoaXMsIGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIHRvdGFsTGVuZ3RoOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhncmlkLmJlaGF2aW9yLmxlZnRNb3N0Q29sSW5kZXgpICsgdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuXG4vKipcbiAqIEBzdW1tYXJ5IExpc3Qgb2YgZ3JpZCByZW5kZXJlcnMgYXZhaWxhYmxlIHRvIG5ldyBncmlkIGluc3RhbmNlcy5cbiAqIEBkZXNjIERldmVsb3BlciBtYXkgYXVnbWVudCB0aGlzIGxpc3Qgd2l0aCBhZGRpdGlvbmFsIGdyaWQgcmVuZGVyZXJzIGJlZm9yZSBncmlkIGluc3RhbnRpYXRpb24gYnkgY2FsbGluZyBAbGluayB7UmVuZGVyZXIucmVnaXN0ZXJHcmlkUmVuZGVyZXJ9LlxuICogQG1lbWJlck9mIFJlbmRlcmVyflxuICogQHByaXZhdGVcbiAqIEB0eXBlIHtmdW5jdGlvbltdfVxuICovXG52YXIgcGFpbnRDZWxsc0Z1bmN0aW9ucyA9IFtdO1xuXG5cbi8qKiBAdHlwZWRlZiB7b2JqZWN0fSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcbiAqIEBzZWUgW0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRClcbiAqL1xuXG4vKiogQHR5cGVkZWYge29iamVjdH0gdmlzaWJsZUNvbHVtbkFycmF5XG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXggLSBBIGJhY2sgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50J3MgYXJyYXkgaW5kZXggaW4ge0BsaW5rIFJlbmRlcmVyI3Zpc2libGVDb2x1bW5zfS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIERlcmVmZXJlbmNlcyB7QGxpbmsgQmVoYXZpb3IjY29sdW1uc30sIHRoZSBzdWJzZXQgb2YgX2FjdGl2ZV8gY29sdW1ucywgc3BlY2lmeWluZyB3aGljaCBjb2x1bW4gdG8gc2hvdyBpbiB0aGF0IHBvc2l0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlZnQgLSBQaXhlbCBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhpcyBjb2x1bW4sIHJvdW5kZWQgdG8gbmVhcmVzdCBpbnRlZ2VyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJpZ2h0IC0gUGl4ZWwgY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgZWRnZSBvZiB0aGlzIGNvbHVtbiwgcm91bmRlZCB0byBuZWFyZXN0IGludGVnZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggLSBXaWR0aCBvZiB0aGlzIGNvbHVtbiBpbiBwaXhlbHMsIHJvdW5kZWQgdG8gbmVhcmVzdCBpbnRlZ2VyLlxuICovXG5cbi8qKiBAdHlwZWRlZiB7b2JqZWN0fSB2aXNpYmxlUm93QXJyYXlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbmRleCAtIEEgYmFjayByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQncyBhcnJheSBpbmRleCBpbiB7QGxpbmsgUmVuZGVyZXIjdmlzaWJsZVJvd3N9LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJvd0luZGV4IC0gTG9jYWwgdmVydGljYWwgcm93IGNvb3JkaW5hdGUgd2l0aGluIHRoZSBzdWJncmlkIHRvIHdoaWNoIHRoZSByb3cgYmVsb25ncywgYWRqdXN0ZWQgZm9yIHNjcm9sbGluZy5cbiAqIEBwcm9wZXJ0eSB7ZGF0YU1vZGVsQVBJfSBzdWJncmlkIC0gQSByZWZlcmVuY2UgdG8gdGhlIHN1YmdyaWQgdG8gd2hpY2ggdGhlIHJvdyBiZWxvbmdzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRvcCAtIFBpeGVsIGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBlZGdlIG9mIHRoaXMgcm93LCByb3VuZGVkIHRvIG5lYXJlc3QgaW50ZWdlci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib3R0b20gLSBQaXhlbCBjb29yZGluYXRlIG9mIHRoZSBib3R0b20gZWRnZSBvZiB0aGlzIHJvdywgcm91bmRlZCB0byBuZWFyZXN0IGludGVnZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoaXMgcm93IGluIHBpeGVscywgcm91bmRlZCB0byBuZWFyZXN0IGludGVnZXIuXG4gKi9cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBkZXNjIGZpbi1oeXBlcmdyaWQtcmVuZGVyZXIgaXMgdGhlIGNhbnZhcyBlbmFibGVkIHRvcCBsZXZlbCBzdWIgY29tcG9uZW50IHRoYXQgaGFuZGxlcyB0aGUgcmVuZGVyZXJpbmcgb2YgdGhlIEdyaWQuXG4gKlxuICogSXQgcmVsaWVzIG9uIHR3byBvdGhlciBleHRlcm5hbCBzdWJwcm9qZWN0c1xuICpcbiAqIDEuIGZpbi1jYW52YXM6IGEgd3JhcHBlciB0byBwcm92aWRlIGEgc2ltcGxlciBpbnRlcmZhY2UgdG8gdGhlIEhUTUw1IGNhbnZhcyBjb21wb25lbnRcbiAqIDIuIHJlY3Rhbmd1bGFyOiBhIHNtYWxsIG5wbSBtb2R1bGUgcHJvdmlkaW5nIFBvaW50IGFuZCBSZWN0YW5nbGUgb2JqZWN0c1xuICpcbiAqIFRoZSBmaW4taHlwZXJncmlkLXJlbmRlcmVyIGlzIGluIGEgdW5pcXVlIHBvc2l0aW9uIHRvIHByb3ZpZGUgY3JpdGljYWwgZnVuY3Rpb25hbGl0eSB0byB0aGUgZmluLWh5cGVyZ3JpZCBpbiBhIGhpZ2h0bHkgcGVyZm9ybWFudCBtYW5uZXIuXG4gKiBCZWNhdXNlIGl0IE1VU1QgaXRlcmF0ZSBvdmVyIGFsbCB0aGUgdmlzaWJsZSBjZWxscyBpdCBjYW4gc3RvcmUgdmFyaW91cyBiaXRzIG9mIGluZm9ybWF0aW9uIHRoYXQgY2FuIGJlIGVuY2Fwc3VsYXRlZCBhcyBhIHNlcnZpY2UgZm9yIGNvbnN1bXB0aW9uIGJ5IHRoZSBmaW4taHlwZXJncmlkIGNvbXBvbmVudC5cbiAqXG4gKiBJbnN0YW5jZXMgb2YgdGhpcyBvYmplY3QgaGF2ZSBiYXNpY2FsbHkgZm91ciBtYWluIGZ1bmN0aW9ucy5cbiAqXG4gKiAxLiByZW5kZXIgZml4ZWQgcm93IGhlYWRlcnNcbiAqIDIuIHJlbmRlciBmaXhlZCBjb2wgaGVhZGVyc1xuICogMy4gcmVuZGVyIG1haW4gZGF0YSBjZWxsc1xuICogNC4gcmVuZGVyIGdyaWQgbGluZXNcbiAqXG4gKiBTYW1lIHBhcmFtZXRlcnMgYXMge0BsaW5rIFJlbmRlcmVyI2luaXRpYWxpemV8aW5pdGlhbGl6ZX0sIHdoaWNoIGlzIGNhbGxlZCBieSB0aGlzIGNvbnN0cnVjdG9yLlxuICpcbiAqL1xudmFyIFJlbmRlcmVyID0gQmFzZS5leHRlbmQoJ1JlbmRlcmVyJywge1xuXG4gICAgLy90aGUgc2hhcmVkIHNpbmdsZSBpdGVtIFwicG9vbGVkXCIgY2VsbCBvYmplY3QgZm9yIGRyYXdpbmcgZWFjaCBjZWxsXG4gICAgY2VsbDoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgfSxcblxuICAgIHNjcm9sbEhlaWdodDogMCxcblxuICAgIHZpZXdIZWlnaHQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDb250YWlucyB2ZXJ0aWNhbCB2aWV3IGZyZWUgc3BhY2VcbiAgICAgKiBAZGVzYyBJZiB2aXNpYmxlIHJvd3Mgbm90IGhvbGRzIGFsbCB0aGUgZ3JpZCBzcGFjZSwgdGhpcyB2YXJpYWJsZSB3aWxsIGNvbnRhaW4gbWlzc2luZyBwaXhlbHMgY291bnRcbiAgICAgKi9cbiAgICBib3R0b21GcmVlU3BhY2U6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDb3VudCBvZiByb3dzLCB0aGF0IHdhcyByZW5kZXJlZCBwYXJ0bHlcbiAgICAgKiBAZGVzYyB1c2VkLCB3aGVuIHJlbmRlcmVkIG9uIGxhc3QgcGFnZSwgYW5kIGZpcnN0IHJvdyBtdXN0IGJlIHBhcnRseSBoaWRkZW4sIHRvIGF2b2lkIGVtcHR5IHNwYWNlIG9uIGVuZFxuICAgICAqL1xuICAgIHJlbmRlcmVkQ3V0dGVkUm93c0NvdW50OiAwLFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgTnVtYmVyIG9mIHBpeGVscyB0aGF0IHdhcyBza2lwcGVkIG9uIHJlbmRlciB0byBjdXQgZmlyc3Qgcm93XG4gICAgICogQGRlc2MgdXNlZCwgd2hlbiByZW5kZXJlZCBvbiBsYXN0IHBhZ2UsIGFuZCBmaXJzdCByb3cgbXVzdCBiZSBwYXJ0bHkgaGlkZGVuLCB0byBhdm9pZCBlbXB0eSBzcGFjZSBvbiBlbmRcbiAgICAgKi9cbiAgICBza2lwcGVkVG9wU3BhY2U6IDAsXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYm91bmRzID0ge1xuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVwcmVzZW50cyB0aGUgb3JkZXJlZCBzZXQgb2YgdmlzaWJsZSBjb2x1bW5zLiBBcnJheSBzaXplIGlzIGFsd2F5cyB0aGUgZXhhY3QgbnVtYmVyIG9mIHZpc2libGUgY29sdW1ucywgdGhlIGxhc3Qgb2Ygd2hpY2ggbWF5IG9ubHkgYmUgcGFydGlhbGx5IHZpc2libGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgc2VxdWVuY2Ugb2YgZWxlbWVudHMnIGBjb2x1bW5JbmRleGAgdmFsdWVzIGFzc3VtZXMgb25lIG9mIHRocmVlIHBhdHRlcm5zLiBXaGljaCBwYXR0ZXJuIGlzIGJhc2Ugb24gdGhlIGZvbGxvd2luZyB0d28gcXVlc3Rpb25zOlxuICAgICAgICAgKiAqIEFyZSB0aGVyZSBcImZpeGVkXCIgY29sdW1ucyBvbiB0aGUgbGVmdD9cbiAgICAgICAgICogKiBJcyB0aGUgZ3JpZCBob3Jpem9udGFsbHkgc2Nyb2xsZWQ/XG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBzZXQgb2YgYGNvbHVtbkluZGV4YCB2YWx1ZXMgY29uc2lzdHMgb2Y6XG4gICAgICAgICAqIDEuIFRoZSBmaXJzdCBlbGVtZW50IHdpbGwgYmUgLTEgaWYgdGhlIHJvdyBoYW5kbGUgY29sdW1uIGlzIGJlaW5nIHJlbmRlcmVkLlxuICAgICAgICAgKiAyLiBBIHplcm8tYmFzZWQgbGlzdCBvZiBjb25zZWN1dGl2ZSBvZiBpbnRlZ2VycyByZXByZXNlbnRpbmcgdGhlIGZpeGVkIGNvbHVtbnMgKGlmIGFueSkuXG4gICAgICAgICAqIDMuIEFuIG4tYmFzZWQgbGlzdCBvZiBjb25zZWN1dGl2ZSBvZiBpbnRlZ2VycyByZXByZXNlbnRpbmcgdGhlIHNjcm9sbGFibGUgY29sdW1ucyAod2hlcmUgbiA9IG51bWJlciBvZiBmaXhlZCBjb2x1bW5zICsgdGhlIG51bWJlciBvZiBjb2x1bW5zIHNjcm9sbGVkIG9mZiB0byB0aGUgbGVmdCkuXG4gICAgICAgICAqIEB0eXBlIHt2aXNpYmxlQ29sdW1uQXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpc2libGVDb2x1bW5zID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoW10sIHZpc2libGVDb2x1bW5Qcm9wZXJ0aWVzRGVzY3JpcHRvckZuKHRoaXMuZ3JpZCkpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXByZXNlbnRzIHRoZSBvcmRlcmVkIHNldCBvZiB2aXNpYmxlIHJvd3MuIEFycmF5IHNpemUgaXMgYWx3YXlzIHRoZSBleGFjdCBudW1iZXIgb2YgdmlzaWJsZSByb3dzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgc2VxdWVuY2Ugb2YgZWxlbWVudHMnIGByb3dJbmRleGAgdmFsdWVzIGlzIGxvY2FsIHRvIGVhY2ggc3ViZ3JpZC5cbiAgICAgICAgICogKiAqKkZvciBlYWNoIG5vbi1zY3JvbGxhYmxlIHN1YmdyaWQ6KiogVGhlIHNlcXVlbmNlIGlzIGEgemVyby1iYXNlZCBsaXN0IG9mIGNvbnNlY3V0aXZlIGludGVnZXJzLlxuICAgICAgICAgKiAqICoqRm9yIHRoZSBzY3JvbGxhYmxlIHN1YmdyaWQ6KipcbiAgICAgICAgICogICAxLiBBIHplcm8tYmFzZWQgbGlzdCBvZiBjb25zZWN1dGl2ZSBvZiBpbnRlZ2VycyByZXByZXNlbnRpbmcgdGhlIGZpeGVkIHJvd3MgKGlmIGFueSkuXG4gICAgICAgICAqICAgMi4gQW4gbi1iYXNlZCBsaXN0IG9mIGNvbnNlY3V0aXZlIG9mIGludGVnZXJzIHJlcHJlc2VudGluZyB0aGUgc2Nyb2xsYWJsZSByb3dzICh3aGVyZSBuID0gbnVtYmVyIG9mIGZpeGVkIHJvd3MgKyB0aGUgbnVtYmVyIG9mIHJvd3Mgc2Nyb2xsZWQgb2ZmIHRoZSB0b3ApLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgbm9uLXNjcm9sbGFibGUgc3ViZ3JpZHMgY2FuIGNvbWUgYm90aCBiZWZvcmUgX2FuZF8gYWZ0ZXIgdGhlIHNjcm9sbGFibGUgc3ViZ3JpZC5cbiAgICAgICAgICogQHR5cGUge3Zpc2libGVSb3dBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlzaWJsZVJvd3MgPSBbXTtcblxuICAgICAgICB0aGlzLmluc2VydGlvbkJvdW5kcyA9IFtdO1xuXG4gICAgICAgIHRoaXMuY2VsbEV2ZW50UG9vbCA9IFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDb25zdHJ1Y3RvciBsb2dpY1xuICAgICAqIEBkZXNjIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIHVwb24gaW5zdGFudGlhdGlvbiBvZiB0aGlzIGNsYXNzIG9yIG9mIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgZnJvbSB0aGlzIGNsYXNzLlxuICAgICAqID4gQWxsIGBpbml0aWFsaXplKClgIG1ldGhvZHMgaW4gdGhlIGluaGVyaXRhbmNlIGNoYWluIGFyZSBjYWxsZWQsIGluIHR1cm4sIGVhY2ggd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLCBiZWdpbm5pbmcgd2l0aCB0aGF0IG9mIHRoZSBtb3N0IFwic2VuaW9yXCIgY2xhc3MgdGhyb3VnaCB0aGF0IG9mIHRoZSBjbGFzcyBvZiB0aGUgbmV3IGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG5cbiAgICAgICAgdGhpcy5ncmlkUmVuZGVyZXJzID0ge307XG4gICAgICAgIHBhaW50Q2VsbHNGdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbihwYWludENlbGxzRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJHcmlkUmVuZGVyZXIocGFpbnRDZWxsc0Z1bmN0aW9uKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgLy8gdHlwaWNhbGx5IGdyaWQgcHJvcGVydGllcyB3b24ndCBleGlzdCB5ZXRcbiAgICAgICAgdGhpcy5zZXRHcmlkUmVuZGVyZXIodGhpcy5wcm9wZXJ0aWVzLmdyaWRSZW5kZXJlciB8fCAnYnktY29sdW1ucy1hbmQtcm93cycpO1xuXG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9LFxuXG4gICAgcmVnaXN0ZXJHcmlkUmVuZGVyZXI6IGZ1bmN0aW9uKHBhaW50Q2VsbHNGdW5jdGlvbikge1xuICAgICAgICB0aGlzLmdyaWRSZW5kZXJlcnNbcGFpbnRDZWxsc0Z1bmN0aW9uLmtleV0gPSB7XG4gICAgICAgICAgICBwYWludENlbGxzOiBwYWludENlbGxzRnVuY3Rpb25cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgc2V0R3JpZFJlbmRlcmVyOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGdyaWRSZW5kZXJlciA9IHRoaXMuZ3JpZFJlbmRlcmVyc1trZXldO1xuXG4gICAgICAgIGlmICghZ3JpZFJlbmRlcmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgdGhpcy5IeXBlcmdyaWRFcnJvcignVW5yZWdpc3RlcmVkIGdyaWQgcmVuZGVyZXIgXCInICsga2V5ICsgJ1wiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ3JpZFJlbmRlcmVyICE9PSB0aGlzLmdyaWRSZW5kZXJlcikge1xuICAgICAgICAgICAgdGhpcy5ncmlkUmVuZGVyZXIgPSBncmlkUmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLmdyaWRSZW5kZXJlci5yZXNldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVzZXRBbGxHcmlkUmVuZGVyZXJzOiBmdW5jdGlvbihibGFja0xpc3QpIHtcbiAgICAgICAgLy8gTm90aWZ5IHJlbmRlcmVycyB0aGF0IGdyaWQgc2hhcGUgaGFzIGNoYW5nZWRcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5ncmlkUmVuZGVyZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdGhpcy5ncmlkUmVuZGVyZXJzW2tleV0ucmVzZXQgPSAhYmxhY2tMaXN0IHx8IGJsYWNrTGlzdC5pbmRleE9mKGtleSkgPCAwO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VydGFpbiByZW5kZXJlcnMgdGhhdCBwcmUtYnVuZGxlIGNvbHVtbiByZWN0cyBiYXNlZCBvbiBjb2x1bW5zJyBiYWNrZ3JvdW5kIGNvbG9ycyBuZWVkIHRvIHJlLWJ1bmRsZSB3aGVuIGNvbHVtbnMnIGJhY2tncm91bmQgY29sb3JzIGNoYW5nZS4gVGhpcyBtZXRob2Qgc2V0cyB0aGUgYHJlYnVuZGxlYCBwcm9wZXJ0eSB0byBgdHJ1ZWAgZm9yIHRob3NlIHJlbmRlcmVycyB0aGF0IGhhdmUgdGhhdCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICByZWJ1bmRsZUdyaWRSZW5kZXJlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmdyaWRSZW5kZXJlcnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ncmlkUmVuZGVyZXJzW2tleV0ucGFpbnRDZWxscy5yZWJ1bmRsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFJlbmRlcmVyc1trZXldLnJlYnVuZGxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIHJlc2V0Um93SGVhZGVyQ29sdW1uV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmxhc3RLbm93Um93Q291bnQgPSB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIGNvbXB1dGVDZWxsc0JvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubmVlZHNDb21wdXRlQ2VsbHNCb3VuZHMgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDQVVUSU9OOiBLZWVwIGluIHBsYWNlISBVc2VkIGJ5IHtAbGluayBDYW52YXN9LlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY3VycmVudCBncmlkIHByb3BlcnRpZXMgb2JqZWN0LlxuICAgICAqL1xuICAgIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnByb3BlcnRpZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBOb3RpZnkgdGhlIGZpbi1oeXBlcmdyaWQgZXZlcnkgdGltZSB3ZSd2ZSByZXBhaW50ZWQuXG4gICAgICogQGRlc2MgVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqL1xuICAgIHBhaW50OiBmdW5jdGlvbihnYykge1xuICAgICAgICBpZiAodGhpcy5ncmlkLmNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJHcmlkKGdjKTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5ncmlkUmVuZGVyZWROb3RpZmljYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB0aWNrTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ncmlkLnRpY2tOb3RpZmljYXRpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEFuc3dlciBob3cgbWFueSByb3dzIHdlIHJlbmRlcmVkXG4gICAgICovXG4gICAgZ2V0VmlzaWJsZVJvd3NDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVSb3dzLmxlbmd0aCAtIDE7XG4gICAgfSxcblxuICAgIGdldFZpc2libGVTY3JvbGxIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3SGVpZ2h0IC0gdGhpcy5ncmlkLmdldEZpeGVkUm93c0hlaWdodCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIG9mIGNvbHVtbnMgd2UganVzdCByZW5kZXJlZC5cbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlQ29sdW1uc0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZUNvbHVtbnMubGVuZ3RoIC0gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fG51bWJlcn0geCAtIENlbGxFdmVudCBvYmplY3Qgb3IgZ3JpZCBjb2x1bW4gY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ldIC0gR3JpZCByb3cgY29vcmRpbmF0ZS4gT21pdCBpZiBgeE9yQ2VsbEV2ZW50YCBpcyBhIENlbGxFdmVudC5cbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBCb3VuZGluZyByZWN0IG9mIGNlbGwgd2l0aCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgZ2V0Qm91bmRzT2ZDZWxsOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIGNvbnN0IHZjID0gdGhpcy52aXNpYmxlQ29sdW1uc1t4XSwgdnIgPSB0aGlzLnZpc2libGVSb3dzW3ldO1xuXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5jZWxsRXZlbnRQb29sLmZpbmQoKGUpID0+IGUudmlzaWJsZUNvbHVtbiA9PT0gdmMgJiYgZS52aXNpYmxlUm93ID09PSB2cik7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LmJvdW5kcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB2Yy5sZWZ0LFxuICAgICAgICAgICAgeTogdnIudG9wLFxuICAgICAgICAgICAgd2lkdGg6IHZjLndpZHRoICsgdGhpcy5ncmlkLmJlaGF2aW9yLmdldEFkZGl0aW9uYWxXaWR0aCh4LCB5KSxcbiAgICAgICAgICAgIGhlaWdodDogdnIuaGVpZ2h0ICsgdGhpcy5ncmlkLmJlaGF2aW9yLmdldEFkZGl0aW9uYWxIZWlnaHQoeCwgeSlcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGFuc3dlciB0aGUgY29sdW1uIGluZGV4IHVuZGVyIHRoZSBjb29yZGluYXRlIGF0IHBpeGVsWFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFggLSBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBjb2x1bW4gaW5kZXggdW5kZXIgdGhlIGNvb3JkaW5hdGUgYXQgcGl4ZWxYLlxuICAgICAqL1xuICAgIGdldENvbHVtbkZyb21QaXhlbFg6IGZ1bmN0aW9uKHBpeGVsWCkge1xuICAgICAgICB2YXIgd2lkdGggPSAwLFxuICAgICAgICAgICAgZml4ZWRDb2x1bW5Db3VudCA9IHRoaXMuZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCksXG4gICAgICAgICAgICBzY3JvbGxMZWZ0ID0gdGhpcy5ncmlkLmdldEhTY3JvbGxWYWx1ZSgpLFxuICAgICAgICAgICAgdmlzaWJsZUNvbHVtbnMgPSB0aGlzLnZpc2libGVDb2x1bW5zO1xuICAgICAgICBmb3IgKHZhciBjID0gMTsgYyA8IHZpc2libGVDb2x1bW5zLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICB3aWR0aCA9IHZpc2libGVDb2x1bW5zW2NdLmxlZnQ7XG4gICAgICAgICAgICBpZiAocGl4ZWxYIDwgd2lkdGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA+IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYyArPSBzY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYyAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPiBmaXhlZENvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICBjICs9IHNjcm9sbExlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGMgLSAxO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBBbnN3ZXIgc3BlY2lmaWMgZGF0YSBjZWxsIGNvb3JkaW5hdGVzIGdpdmVuIG1vdXNlIGNvb3JkaW5hdGVzIGluIHBpeGVscy5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludFxuICAgICAqIEByZXR1cm5zIHtQb2ludH0gQ2VsbCBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIGdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIGlmICghdGhpcy52aXNpYmxlQ29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQ7XG4gICAgICAgIGNvbnN0IHsgdmlzaWJsZVJvd3MsIHZpc2libGVDb2x1bW5zIH0gPSB0aGlzO1xuXG4gICAgICAgIGNvbnN0IGZpcnN0Q29sdW1uID0gdmlzaWJsZUNvbHVtbnNbdGhpcy5ncmlkLmJlaGF2aW9yLmxlZnRNb3N0Q29sSW5kZXhdO1xuICAgICAgICBjb25zdCBpbkZpcnN0Q29sdW1uID0geCA8IGZpcnN0Q29sdW1uLnJpZ2h0O1xuXG4gICAgICAgIGNvbnN0IFtmaXJzdFJvd10gPSB2aXNpYmxlUm93cztcbiAgICAgICAgY29uc3QgYmVoaW5kRmlyc3RSb3cgPSB5IDwgZmlyc3RSb3cudG9wO1xuXG4gICAgICAgIGxldCBpc1BzZXVkb1JvdyA9IGZhbHNlO1xuICAgICAgICBsZXQgaXNQc2V1ZG9Db2wgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBmYWtlOiBmYWxzZSB9O1xuXG4gICAgICAgIGxldCB2YyA9IGluRmlyc3RDb2x1bW4gPyBmaXJzdENvbHVtbiA6IHZpc2libGVDb2x1bW5zLmZpbmRXaXRoTmVnKHZjID0+IHggPCB2Yy5yaWdodCk7XG5cbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSB2aXNpYmxlUm93c1xuICAgICAgICAgICAgLmZpbHRlcih2ciA9PiBiZWhpbmRGaXJzdFJvdyA/ICh2ci5pbmRleCAhPT0gdnIucm93SW5kZXgpIDogKHkgPD0gdnIuYm90dG9tICYmIHkgPj0gdnIudG9wKSlcbiAgICAgICAgICAgIC5zb3J0KCh2cjEsIHZyMikgPT4gdnIyLnJvd0luZGV4IC0gdnIxLnJvd0luZGV4KTtcblxuICAgICAgICBsZXQgdnIgPSBmaWx0ZXJlZFtmaWx0ZXJlZC5sZW5ndGggLSAxXTtcblxuICAgICAgICAvLyBkZWZhdWx0IHRvIGxhc3Qgcm93IGFuZCBjb2xcbiAgICAgICAgaWYgKHZyKSB7XG4gICAgICAgICAgICBpc1BzZXVkb1JvdyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdnIgPSB2aXNpYmxlUm93c1tiZWhpbmRGaXJzdFJvdyA/IDAgOiB2aXNpYmxlUm93cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlzUHNldWRvUm93ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2Yykge1xuICAgICAgICAgICAgaXNQc2V1ZG9Db2wgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZjID0gdmlzaWJsZUNvbHVtbnNbdmlzaWJsZUNvbHVtbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpc1BzZXVkb0NvbCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtb3VzZVBvaW50ID0gdGhpcy5ncmlkLm5ld1BvaW50KHggLSB2Yy5sZWZ0LCB5IC0gdnIudG9wKSxcbiAgICAgICAgICAgIGNlbGxFdmVudCA9IG5ldyB0aGlzLmdyaWQuYmVoYXZpb3IuQ2VsbEV2ZW50KHZjLmNvbHVtbkluZGV4LCB2ci5pbmRleCk7XG5cbiAgICAgICAgcmVzdWx0LmNlbGxFdmVudCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjZWxsRXZlbnQsICdtb3VzZVBvaW50JywgeyB2YWx1ZTogbW91c2VQb2ludCB9KTtcblxuICAgICAgICBpZiAoaXNQc2V1ZG9Db2wgfHwgaXNQc2V1ZG9Sb3cpIHtcbiAgICAgICAgICAgIHJlc3VsdC5mYWtlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5iZUN1cnNvcihudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1hdHJpeCBvZiB1bmZvcm1hdHRlZCB2YWx1ZXMgb2YgdmlzaWJsZSBjZWxscy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk+fVxuICAgICAqL1xuICAgIGdldFZpc2libGVDZWxsTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJvd3MgPSBBcnJheSh0aGlzLnZpc2libGVSb3dzLmxlbmd0aCk7XG4gICAgICAgIHZhciBhZGp1c3QgPSB0aGlzLmdyaWQuYmVoYXZpb3IuaGFzVHJlZUNvbHVtbigpID8gMSA6IDA7XG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgcm93cy5sZW5ndGg7ICsreSkge1xuICAgICAgICAgICAgcm93c1t5XSA9IEFycmF5KHRoaXMudmlzaWJsZUNvbHVtbnMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNlbGxFdmVudFBvb2wubWFwKGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgICAgIHZhciB4ID0gY2VsbC5ncmlkQ2VsbC54ICsgYWRqdXN0O1xuICAgICAgICAgICAgaWYgKHggPj0gMCkge1xuICAgICAgICAgICAgICAgIHJvd3NbY2VsbC5ncmlkQ2VsbC55XVt4XSA9IGNlbGwudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcm93cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBjb2x1bW4gbWF0Y2hpbmcgdGhlIHByb3ZpZGVkIGdyaWQgY29sdW1uIGluZGV4LlxuICAgICAqIEBkZXNjIFJlcXVlc3RlZCBjb2x1bW4gbWF5IG5vdCBiZSB2aXNpYmxlIGR1ZSB0byBiZWluZyBzY3JvbGxlZCBvdXQgb2Ygdmlldy5cbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgRGV0ZXJtaW5lcyBpZiBhIGNvbHVtbiBpcyB2aXNpYmxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIHRoZSBjb2x1bW4gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGdpdmVuIGNvbHVtbiBpcyB2aXNpYmxlLlxuICAgICAqL1xuICAgIGlzQ29sdW1uVmlzaWJsZTogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5nZXRWaXNpYmxlQ29sdW1uKGNvbHVtbkluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBcInZpc2libGUgY29sdW1uXCIgb2JqZWN0IG1hdGNoaW5nIHRoZSBwcm92aWRlZCBncmlkIGNvbHVtbiBpbmRleC5cbiAgICAgKiBAZGVzYyBSZXF1ZXN0ZWQgY29sdW1uIG1heSBub3QgYmUgdmlzaWJsZSBkdWUgdG8gYmVpbmcgc2Nyb2xsZWQgb3V0IG9mIHZpZXcuXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IEZpbmQgYSB2aXNpYmxlIGNvbHVtbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gVGhlIGdyaWQgY29sdW1uIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R8dW5kZWZpbmVkfSBUaGUgZ2l2ZW4gY29sdW1uIGlmIHZpc2libGUgb3IgYHVuZGVmaW5lZGAgaWYgbm90LlxuICAgICAqL1xuICAgIGdldFZpc2libGVDb2x1bW46IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVDb2x1bW5zLmZpbmRXaXRoTmVnKGZ1bmN0aW9uKHZjKSB7XG4gICAgICAgICAgICByZXR1cm4gdmMuY29sdW1uSW5kZXggPT09IGNvbHVtbkluZGV4O1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgQ2FsY3VsYXRlIHRoZSBtaW5pbXVtIGxlZnQgY29sdW1uIGluZGV4IHNvIHRoZSB0YXJnZXQgY29sdW1uIHNob3dzIHVwIGluIHZpZXdwb3J0ICh3ZSBuZWVkIHRvIGJlIGF3YXJlIG9mIHZpZXdwb3J0J3Mgd2lkdGgsIG51bWJlciBvZiBmaXhlZCBjb2x1bW5zIGFuZCBlYWNoIGNvbHVtbidzIHdpZHRoKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRDb2xJZHggLSBUYXJnZXQgY29sdW1uIGluZGV4XG4gICAgICogQHJldHVybnMge251bWJlcn0gTWluaW11bSBsZWZ0IGNvbHVtbiBpbmRleCBzbyB0YXJnZXQgY29sdW1uIHNob3dzIHVwXG4gICAgICovXG4gICAgZ2V0TWluaW11bUxlZnRQb3NpdGlvblRvU2hvd0NvbHVtbjogZnVuY3Rpb24odGFyZ2V0Q29sSWR4KSB7XG4gICAgICAgIHZhciBmaXhlZENvbHVtbkNvdW50ID0gdGhpcy5ncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGZpeGVkQ29sdW1uc1dpZHRoID0gMDtcbiAgICAgICAgdmFyIHJvd051bWJlcnNXaWR0aCA9IDA7XG4gICAgICAgIHZhciBmaWx0ZXJzV2lkdGggPSAwO1xuICAgICAgICB2YXIgdmlld3BvcnRXaWR0aCA9IDA7XG4gICAgICAgIHZhciBsZWZ0Q29sSWR4ID0gMDtcbiAgICAgICAgdmFyIHRhcmdldFJpZ2h0ID0gMDtcbiAgICAgICAgdmFyIGxhc3RGaXhlZENvbHVtbiA9IG51bGw7XG4gICAgICAgIHZhciBjb21wdXRlZENvbHMgPSBbXTtcbiAgICAgICAgdmFyIGNvbCA9IG51bGw7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlZnQgPSAwO1xuICAgICAgICB2YXIgcmlnaHQgPSAwO1xuXG5cbiAgICAgICAgLy8gMSkgZm9yIGVhY2ggY29sdW1uLCB3ZSdsbCBjb21wdXRlIGxlZnQgYW5kIHJpZ2h0IHBvc2l0aW9uIGluIHBpeGVscyAodW50aWwgdGFyZ2V0IGNvbHVtbilcbiAgICAgICAgZm9yIChpID0gMDsgaSA8PSB0YXJnZXRDb2xJZHg7IGkrKykge1xuICAgICAgICAgICAgbGVmdCA9IHJpZ2h0O1xuICAgICAgICAgICAgcmlnaHQgKz0gTWF0aC5jZWlsKHRoaXMuZ3JpZC5nZXRDb2x1bW5XaWR0aChpKSk7XG5cbiAgICAgICAgICAgIGNvbXB1dGVkQ29scy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXRSaWdodCA9IGNvbXB1dGVkQ29sc1tjb21wdXRlZENvbHMubGVuZ3RoIC0gMV0ucmlnaHQ7XG5cbiAgICAgICAgLy8gMikgY2FsYyB1c2FibGUgdmlld3BvcnQgd2lkdGhcbiAgICAgICAgbGFzdEZpeGVkQ29sdW1uID0gY29tcHV0ZWRDb2xzW2ZpeGVkQ29sdW1uQ291bnQgLSAxXTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLnNob3dSb3dOdW1iZXJzKSB7XG4gICAgICAgICAgICByb3dOdW1iZXJzV2lkdGggPSB0aGlzLmdyaWQuZ2V0Q29sdW1uV2lkdGgodGhpcy5ncmlkLmJlaGF2aW9yLnJvd0NvbHVtbkluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdyaWQuaGFzVHJlZUNvbHVtbigpKSB7XG4gICAgICAgICAgICBmaWx0ZXJzV2lkdGggPSB0aGlzLmdyaWQuZ2V0Q29sdW1uV2lkdGgodGhpcy5ncmlkLmJlaGF2aW9yLnRyZWVDb2x1bW5JbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBmaXhlZENvbHVtbnNXaWR0aCA9IGxhc3RGaXhlZENvbHVtbiA/IGxhc3RGaXhlZENvbHVtbi5yaWdodCA6IDA7XG4gICAgICAgIHZpZXdwb3J0V2lkdGggPSB0aGlzLmdldEJvdW5kcygpLndpZHRoIC0gZml4ZWRDb2x1bW5zV2lkdGggLSByb3dOdW1iZXJzV2lkdGggLSBmaWx0ZXJzV2lkdGg7XG5cbiAgICAgICAgLy8gMykgZnJvbSByaWdodCB0byBsZWZ0LCBmaW5kIHRoZSBsYXN0IGNvbHVtbiB0aGF0IGNhbiBzdGlsbCByZW5kZXIgdGFyZ2V0IGNvbHVtblxuICAgICAgICBpID0gdGFyZ2V0Q29sSWR4O1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGxlZnRDb2xJZHggPSBpO1xuICAgICAgICAgICAgY29sID0gY29tcHV0ZWRDb2xzW2ldO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9IHdoaWxlIChjb2wubGVmdCArIHZpZXdwb3J0V2lkdGggPiB0YXJnZXRSaWdodCAmJiBpID49IDApO1xuXG4gICAgICAgIHJldHVybiBsZWZ0Q29sSWR4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGNvbHVtbiBtYXRjaGluZyB0aGUgcHJvdmlkZWQgZGF0YSBjb2x1bW4gaW5kZXguXG4gICAgICogQGRlc2MgUmVxdWVzdGVkIGNvbHVtbiBtYXkgbm90IGJlIHZpc2libGUgZHVlIHRvIGJlaW5nIHNjcm9sbGVkIG91dCBvZiB2aWV3IG9yIGlmIHRoZSBjb2x1bW4gaXMgaW5hY3RpdmUuXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IERldGVybWluZXMgaWYgYSBjb2x1bW4gaXMgdmlzaWJsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXggLSB0aGUgY29sdW1uIGluZGV4XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiBjb2x1bW4gaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpc0RhdGFDb2x1bW5WaXNpYmxlOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdldFZpc2libGVEYXRhQ29sdW1uKGNvbHVtbkluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBcInZpc2libGUgY29sdW1uXCIgb2JqZWN0IG1hdGNoaW5nIHRoZSBwcm92aWRlZCBkYXRhIGNvbHVtbiBpbmRleC5cbiAgICAgKiBAZGVzYyBSZXF1ZXN0ZWQgY29sdW1uIG1heSBub3QgYmUgdmlzaWJsZSBkdWUgdG8gYmVpbmcgc2Nyb2xsZWQgb3V0IG9mIHZpZXcgb3IgaWYgdGhlIGNvbHVtbiBpcyBpbmFjdGl2ZS5cbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgRmluZCBhIHZpc2libGUgY29sdW1uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXggLSBUaGUgZ3JpZCBjb2x1bW4gaW5kZXguXG4gICAgICogQHJldHVybnMge29iamVjdHx1bmRlZmluZWR9IFRoZSBnaXZlbiBjb2x1bW4gaWYgdmlzaWJsZSBvciBgdW5kZWZpbmVkYCBpZiBub3QuXG4gICAgICovXG4gICAgZ2V0VmlzaWJsZURhdGFDb2x1bW46IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVDb2x1bW5zLmZpbmRXaXRoTmVnKGZ1bmN0aW9uKHZjKSB7XG4gICAgICAgICAgICByZXR1cm4gdmMuY29sdW1uLmluZGV4ID09PSBjb2x1bW5JbmRleDtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgd2lkdGggeCBjb29yZGluYXRlIG9mIHRoZSBsYXN0IHJlbmRlcmVkIGNvbHVtblxuICAgICAqL1xuICAgIGdldEZpbmFsVmlzaWJsZUNvbHVtbkJvdW5kYXJ5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNob3AgPSB0aGlzLmlzTGFzdENvbHVtblZpc2libGUoKSA/IDIgOiAxO1xuICAgICAgICB2YXIgY29sV2FsbCA9IHRoaXMudmlzaWJsZUNvbHVtbnNbdGhpcy52aXNpYmxlQ29sdW1ucy5sZW5ndGggLSBjaG9wXS5yaWdodDtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKGNvbFdhbGwsIHRoaXMuZ2V0Qm91bmRzKCkud2lkdGgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHJvdyBtYXRjaGluZyB0aGUgcHJvdmlkZWQgZ3JpZCByb3cgaW5kZXguXG4gICAgICogQGRlc2MgUmVxdWVzdGVkIHJvdyBtYXkgbm90IGJlIHZpc2libGUgZHVlIHRvIGJlaW5nIG91dHNpZGUgdGhlIGJvdW5kcyBvZiB0aGUgcmVuZGVyZWQgZ3JpZC5cbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgRGV0ZXJtaW5lcyB2aXNpYmlsaXR5IG9mIGEgcm93LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIFRoZSBncmlkIHJvdyBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGdpdmVuIHJvdyBpcyB2aXNpYmxlLlxuICAgICAqL1xuICAgIGlzUm93VmlzaWJsZTogZnVuY3Rpb24ocm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy52aXNpYmxlUm93c1tyb3dJbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgXCJ2aXNpYmxlIHJvd1wiIG9iamVjdCBtYXRjaGluZyB0aGUgcHJvdmlkZWQgZ3JpZCByb3cgaW5kZXguXG4gICAgICogQGRlc2MgUmVxdWVzdGVkIHJvdyBtYXkgbm90IGJlIHZpc2libGUgZHVlIHRvIGJlaW5nIG91dHNpZGUgdGhlIGJvdW5kcyBvZiB0aGUgcmVuZGVyZWQgZ3JpZC5cbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgRmluZCBhIHZpc2libGUgcm93IG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUaGUgZ3JpZCByb3cgaW5kZXguXG4gICAgICogQHJldHVybnMge29iamVjdHx1bmRlZmluZWR9IFRoZSBnaXZlbiByb3cgaWYgdmlzaWJsZSBvciBgdW5kZWZpbmVkYCBpZiBub3QuXG4gICAgICovXG4gICAgZ2V0VmlzaWJsZVJvdzogZnVuY3Rpb24ocm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZVJvd3Nbcm93SW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHJvdyBtYXRjaGluZyB0aGUgcHJvdmlkZWQgZGF0YSByb3cgaW5kZXguXG4gICAgICogQGRlc2MgUmVxdWVzdGVkIHJvdyBtYXkgbm90IGJlIHZpc2libGUgZHVlIHRvIGJlaW5nIHNjcm9sbGVkIG91dCBvZiB2aWV3LlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBEZXRlcm1pbmVzIHZpc2liaWxpdHkgb2YgYSByb3cuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gVGhlIGRhdGEgcm93IGluZGV4LlxuICAgICAqIEBwYXJhbSB7ZGF0YU1vZGVsQVBJfSBbc3ViZ3JpZD10aGlzLmJlaGF2aW9yLnN1YmdyaWRzLmRhdGFdXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiByb3cgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpc0RhdGFSb3dWaXNpYmxlOiBmdW5jdGlvbihyb3dJbmRleCwgc3ViZ3JpZCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdldFZpc2libGVEYXRhUm93KHJvd0luZGV4LCBzdWJncmlkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBcInZpc2libGUgcm93XCIgb2JqZWN0IG1hdGNoaW5nIHRoZSBwcm92aWRlZCBkYXRhIHJvdyBpbmRleC5cbiAgICAgKiBAZGVzYyBSZXF1ZXN0ZWQgcm93IG1heSBub3QgYmUgdmlzaWJsZSBkdWUgdG8gYmVpbmcgc2Nyb2xsZWQgb3V0IG9mIHZpZXcuXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IEZpbmQgYSB2aXNpYmxlIHJvdyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gVGhlIGRhdGEgcm93IGluZGV4IHdpdGhpbiB0aGUgZ2l2ZW4gc3ViZ3JpZC5cbiAgICAgKiBAcGFyYW0ge2RhdGFNb2RlbEFQSX0gW3N1YmdyaWQ9dGhpcy5iZWhhdmlvci5zdWJncmlkcy5kYXRhXVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R8dW5kZWZpbmVkfSBUaGUgZ2l2ZW4gcm93IGlmIHZpc2libGUgb3IgYHVuZGVmaW5lZGAgaWYgbm90LlxuICAgICAqL1xuICAgIGdldFZpc2libGVEYXRhUm93OiBmdW5jdGlvbihyb3dJbmRleCwgc3ViZ3JpZCkge1xuICAgICAgICBzdWJncmlkID0gc3ViZ3JpZCB8fCB0aGlzLmdyaWQuYmVoYXZpb3Iuc3ViZ3JpZHMubG9va3VwLmRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVSb3dzLmZpbmQoZnVuY3Rpb24odnIpIHtcbiAgICAgICAgICAgIHJldHVybiB2ci5zdWJncmlkID09PSBzdWJncmlkICYmIHZyLnJvd0luZGV4ID09PSByb3dJbmRleDtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBEZXRlcm1pbmVzIGlmIGEgY2VsbCBpcyBzZWxlY3RlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSB4IGNlbGwgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIHkgY2VsbCBjb29yZGluYXRlKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY2VsbCBpcyBmdWxseSB2aXNpYmxlLlxuICAgICAqL1xuICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5pc1NlbGVjdGVkKHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhpcyBpcyB0aGUgbWFpbiBmb3JraW5nIG9mIHRoZSByZW5kZXJlcmluZyB0YXNrLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqL1xuICAgIHJlbmRlckdyaWQ6IGZ1bmN0aW9uKGdjKSB7XG4gICAgICAgIHRoaXMuZ3JpZC5kZWZlcnJlZEJlaGF2aW9yQ2hhbmdlKCk7XG5cbiAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgdGhpcy5idXR0b25DZWxscyA9IHt9O1xuXG4gICAgICAgIHZhciByb3dDb3VudCA9IHRoaXMuZ3JpZC5nZXRSb3dDb3VudCgpO1xuICAgICAgICBpZiAocm93Q291bnQgIT09IHRoaXMubGFzdEtub3dSb3dDb3VudCkge1xuICAgICAgICAgICAgdmFyIG5ld1dpZHRoID0gcmVzZXRSb3dIZWFkZXJDb2x1bW5XaWR0aC5jYWxsKHRoaXMsIGdjLCByb3dDb3VudCk7XG4gICAgICAgICAgICBpZiAobmV3V2lkdGggIT09IHRoaXMuaGFuZGxlQ29sdW1uV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5lZWRzQ29tcHV0ZUNlbGxzQm91bmRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNvbHVtbldpZHRoID0gbmV3V2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxhc3RLbm93Um93Q291bnQgPSByb3dDb3VudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm5lZWRzQ29tcHV0ZUNlbGxzQm91bmRzKSB7XG4gICAgICAgICAgICBjb21wdXRlQ2VsbHNCb3VuZHMuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMubmVlZHNDb21wdXRlQ2VsbHNCb3VuZHMgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ3JpZFJlbmRlcmVyLnBhaW50Q2VsbHMuY2FsbCh0aGlzLCBnYyk7XG4gICAgICAgIC8vcmVuZGVyIGhlYWRlciBjZWxscyBhZnRlciBhbGwgYW5vdGhlciBjZWxscyB0byBhdm9pZCBvdmVybGFwcGluZ1xuICAgICAgICB0aGlzLmdyaWRSZW5kZXJlcnNbJ2J5LWNvbHVtbnMtYW5kLXJvd3MtaGVhZGVycyddLnBhaW50Q2VsbHMuY2FsbCh0aGlzLCBnYyk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJTZWxlY3Rpb25zKGdjKTtcbiAgICAgICAgdGhpcy5yZW5kZXJGaXJzdFNlbGVjdGVkQ2VsbChnYyk7XG5cbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIHJlbmRlckZpcnN0U2VsZWN0ZWRDZWxsOiBmdW5jdGlvbihnYykge1xuICAgICAgICBsZXQgZmlyc3RTZWxlY3RlZENlbGwgPSB0aGlzLmdyaWQuc2VsZWN0aW9uTW9kZWwuZ2V0Rmlyc3RTZWxlY3RlZENlbGxPZkxhc3RTZWxlY3Rpb24oKTtcblxuICAgICAgICBpZiAoIWZpcnN0U2VsZWN0ZWRDZWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgeyB4LCB5IH0gPSBmaXJzdFNlbGVjdGVkQ2VsbDtcblxuICAgICAgICBpZiAoIXRoaXMuZ3JpZC5pc0RhdGFWaXNpYmxlKHgsIHkpICYmIHRoaXMudmlzaWJsZUNvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0VmlzaWJsZUNvbHVtbkluZGV4ID0gdGhpcy52aXNpYmxlQ29sdW1uc1swXS5jb2x1bW5JbmRleDtcbiAgICAgICAgICAgIGxldCBmaXJzdFZpc2libGVSb3dJbmRleCA9IHRoaXMudmlzaWJsZVJvd3NbMF0ucm93SW5kZXggKyB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbHNwYW4gPSB0aGlzLmdyaWQuYmVoYXZpb3IuZ2V0Q29sc3Bhbih4LCB5KTtcbiAgICAgICAgICAgIGNvbnN0IHJvd3NwYW4gPSB0aGlzLmdyaWQuYmVoYXZpb3IuZ2V0Um93c3Bhbih4LCB5KTtcbiAgICAgICAgICAgIGlmIChjb2xzcGFuICYmICgoeCArIGNvbHNwYW4pID49IGZpcnN0VmlzaWJsZUNvbHVtbkluZGV4KSkge1xuICAgICAgICAgICAgICAgIHggPSBmaXJzdFZpc2libGVDb2x1bW5JbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJvd3NwYW4gJiYgKCh5ICsgcm93c3BhbiArIHRoaXMuZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpKSA+PSBmaXJzdFZpc2libGVSb3dJbmRleCkpIHtcbiAgICAgICAgICAgICAgICB5ID0gZmlyc3RWaXNpYmxlUm93SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuZ3JpZC5pc0RhdGFWaXNpYmxlKHgsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZml4ZWRDb2x1bW5zQ291bnQgPSB0aGlzLmdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgbmV3WCA9ICh4ID49IGZpeGVkQ29sdW1uc0NvdW50KSA/XG4gICAgICAgICAgICB4IC0gdGhpcy5kYXRhV2luZG93Lm9yaWdpbi54IDpcbiAgICAgICAgICAgIHg7XG5cbiAgICAgICAgbmV3WCA9IE1hdGgubWF4KDAsIG5ld1gpO1xuXG4gICAgICAgIHZhciBwb2ludFdpdGhIZWFkZXJzID0ge1xuICAgICAgICAgICAgeDogbmV3WCxcbiAgICAgICAgICAgIHk6IHkgKyB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKSAtIHRoaXMuZ3JpZC5nZXRWU2Nyb2xsVmFsdWUoKSArIHRoaXMucmVuZGVyZWRDdXR0ZWRSb3dzQ291bnRcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY2VsbEJvdW5kcyA9IHRoaXMuZ3JpZC5nZXRCb3VuZHNPZkNlbGwocG9pbnRXaXRoSGVhZGVycyk7XG5cbiAgICAgICAgdmFyIGhlYWRlclJvd3NDb3VudCA9IHRoaXMuZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgaGVhZGVySGVpZ2h0ID0gaGVhZGVyUm93c0NvdW50ICogdGhpcy5wcm9wZXJ0aWVzLmRlZmF1bHRIZWFkZXJSb3dIZWlnaHQ7XG4gICAgICAgIGlmICghaGVhZGVySGVpZ2h0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWRlclJvd3NDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVySGVpZ2h0ICs9IHRoaXMuZ3JpZC5nZXRSb3dIZWlnaHQoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRYID0gY2VsbEJvdW5kcy5sZWZ0LFxuICAgICAgICAgICAgc3RhcnRZID0gY2VsbEJvdW5kcy50b3AsXG4gICAgICAgICAgICBzZWxlY3Rpb25XaWR0aCA9IGNlbGxCb3VuZHMud2lkdGgsXG4gICAgICAgICAgICBzZWxlY3Rpb25IZWlnaHQgPSBjZWxsQm91bmRzLmhlaWdodDtcblxuICAgICAgICBpZiAoc3RhcnRZIDwgaGVhZGVySGVpZ2h0KSB7XG4gICAgICAgICAgICBzdGFydFkgPSBoZWFkZXJIZWlnaHQ7XG4gICAgICAgICAgICBzZWxlY3Rpb25IZWlnaHQgLT0gdGhpcy5za2lwcGVkVG9wU3BhY2U7XG4gICAgICAgIH1cblxuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgZ2MucmVjdChzdGFydFgsIHN0YXJ0WSwgc2VsZWN0aW9uV2lkdGgsIHNlbGVjdGlvbkhlaWdodCk7XG4gICAgICAgIGdjLmNhY2hlLmxpbmVXaWR0aCA9IDI7XG4gICAgICAgIGdjLmNhY2hlLnN0cm9rZVN0eWxlID0gdGhpcy5ncmlkLnByb3BlcnRpZXMuc2VsZWN0aW9uUmVnaW9uT3V0bGluZUNvbG9yO1xuICAgICAgICBnYy5zdHJva2UoKTtcbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIHJlbmRlclNlbGVjdGlvbnM6IGZ1bmN0aW9uKGdjKSB7XG4gICAgICAgICh0aGlzLmdyaWQuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0aW9ucygpIHx8IFtdKS5mb3JFYWNoKChzLCBpLCBpdGVtcykgPT4gdGhpcy5yZW5kZXJTZWxlY3Rpb25SZWN0KGdjLCBzLCAoaSArIDEpID09PSBpdGVtcy5sZW5ndGgpKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyU2VsZWN0aW9uUmVjdDogZnVuY3Rpb24oZ2MsIHNlbGVjdGlvbiwgaXNMYXN0U2VsZWN0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbi5vcmlnaW4ueCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2Y2kgPSB0aGlzLnZpc2libGVDb2x1bW5zQnlJbmRleCxcbiAgICAgICAgICAgIHZyaSA9IHRoaXMudmlzaWJsZVJvd3NCeURhdGFSb3dJbmRleCxcbiAgICAgICAgICAgIGxhc3RDb2x1bW4gPSB0aGlzLnZpc2libGVDb2x1bW5zW3RoaXMudmlzaWJsZUNvbHVtbnMubGVuZ3RoIC0gMV0sIC8vIGxhc3QgY29sdW1uIGluIHNjcm9sbGFibGUgc2VjdGlvblxuICAgICAgICAgICAgbGFzdFJvdyA9IHZyaVt0aGlzLmRhdGFXaW5kb3cuY29ybmVyLnldOyAvLyBsYXN0IHJvdyBpbiBzY3JvbGxhYmxlIGRhdGEgc2VjdGlvblxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIChsYXN0Q29sdW1uICYmIHNlbGVjdGlvbi5vcmlnaW4ueCA+IGxhc3RDb2x1bW4uY29sdW1uSW5kZXgpIHx8XG4gICAgICAgICAgICAobGFzdFJvdyAmJiBzZWxlY3Rpb24ub3JpZ2luLnkgPiBsYXN0Um93LnJvd0luZGV4KVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2Y09yaWdpbiA9IHZjaVtzZWxlY3Rpb24ub3JpZ2luLnhdLFxuICAgICAgICAgICAgdmNDb3JuZXIgPSB2Y2lbc2VsZWN0aW9uLmNvcm5lci54XSxcbiAgICAgICAgICAgIHZyT3JpZ2luID0gdnJpW3NlbGVjdGlvbi5vcmlnaW4ueV0sXG4gICAgICAgICAgICB2ckNvcm5lciA9IHZyaVtzZWxlY3Rpb24uY29ybmVyLnldO1xuXG4gICAgICAgIHZhciBncmlkUHJvcHMgPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgICAgIHZjT3JpZ2luID0gdmNPcmlnaW4gfHwgdGhpcy52aXNpYmxlQ29sdW1uc1tncmlkUHJvcHMuZml4ZWRDb2x1bW5Db3VudF07XG4gICAgICAgIHZyT3JpZ2luID0gdnJPcmlnaW4gfHwgdGhpcy52aXNpYmxlUm93c1tncmlkUHJvcHMuZml4ZWRSb3dDb3VudCArIHRoaXMuZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpXTtcblxuICAgICAgICBpZiAoIWxhc3RDb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciBjb2xPZmZzZXQgPSAxO1xuICAgICAgICAgICAgd2hpbGUgKCFsYXN0Q29sdW1uICYmIHRoaXMuZGF0YVdpbmRvdy5jb3JuZXIueCA+IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0Q29sdW1uID0gdmNpW3RoaXMuZGF0YVdpbmRvdy5jb3JuZXIueCAtIGNvbE9mZnNldF07XG4gICAgICAgICAgICAgICAgY29sT2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYXN0Um93KSB7XG4gICAgICAgICAgICB2YXIgcm93T2Zmc2V0ID0gMTtcbiAgICAgICAgICAgIHdoaWxlICghbGFzdFJvdyAmJiB0aGlzLmRhdGFXaW5kb3cuY29ybmVyLnkgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdFJvdyA9IHZyaVt0aGlzLmRhdGFXaW5kb3cuY29ybmVyLnkgLSByb3dPZmZzZXRdO1xuICAgICAgICAgICAgICAgIHJvd09mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZjQ29ybmVyID0gdmNDb3JuZXIgfHwgKChsYXN0Q29sdW1uICYmIHNlbGVjdGlvbi5jb3JuZXIueCA+IGxhc3RDb2x1bW4uY29sdW1uSW5kZXgpID8gbGFzdENvbHVtbiA6IHZjaVt0aGlzLmdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpXSk7XG4gICAgICAgIHZyQ29ybmVyID0gdnJDb3JuZXIgfHwgKChsYXN0Um93ICYmIHNlbGVjdGlvbi5jb3JuZXIueSA+IGxhc3RSb3cucm93SW5kZXgpID8gbGFzdFJvdyA6IHZyaVt0aGlzLmdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpXSk7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgISh2Y09yaWdpbiAmJiB2Y0Nvcm5lciAmJiB2ck9yaWdpbiAmJiB2ckNvcm5lcilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGVhZGVyUm93c0NvdW50ID0gdGhpcy5ncmlkLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciBoZWFkZXJIZWlnaHQgPSBoZWFkZXJSb3dzQ291bnQgKiB0aGlzLnByb3BlcnRpZXMuZGVmYXVsdEhlYWRlclJvd0hlaWdodDtcbiAgICAgICAgaWYgKCFoZWFkZXJIZWlnaHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZGVyUm93c0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJIZWlnaHQgKz0gdGhpcy5ncmlkLmdldFJvd0hlaWdodChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydFggPSB2Y09yaWdpbi5sZWZ0LFxuICAgICAgICAgICAgc3RhcnRZID0gdnJPcmlnaW4udG9wLFxuICAgICAgICAgICAgd2lkdGggPSB2Y0Nvcm5lci5yaWdodCAtIHZjT3JpZ2luLmxlZnQsXG4gICAgICAgICAgICBoZWlnaHQgPSB2ckNvcm5lci5ib3R0b20gLSB2ck9yaWdpbi50b3A7XG4gICAgICAgIGlmIChzdGFydFkgPCBoZWFkZXJIZWlnaHQpIHtcbiAgICAgICAgICAgIHN0YXJ0WSA9IGhlYWRlckhlaWdodDtcbiAgICAgICAgICAgIGhlaWdodCAtPSB0aGlzLnNraXBwZWRUb3BTcGFjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbmRlciB0aGUgc2VsZWN0aW9uIG1vZGVsIGFyb3VuZCB0aGUgYm91bmRzXG4gICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICBib3VuZHM6IHtcbiAgICAgICAgICAgICAgICB4OiBzdGFydFgsXG4gICAgICAgICAgICAgICAgeTogc3RhcnRZLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbGVjdGlvblJlZ2lvbk92ZXJsYXlDb2xvcjogKHRoaXMuZ3JpZFJlbmRlcmVyLnBhaW50Q2VsbHMucGFydGlhbCB8fCAoaXNMYXN0U2VsZWN0aW9uICYmIChzZWxlY3Rpb24ud2lkdGggPT09IDAgJiYgc2VsZWN0aW9uLmhlaWdodCA9PT0gMCkpKSA/XG4gICAgICAgICAgICAgICAgJ3RyYW5zcGFyZW50JyA6XG4gICAgICAgICAgICAgICAgZ3JpZFByb3BzLnNlbGVjdGlvblJlZ2lvbk92ZXJsYXlDb2xvcixcbiAgICAgICAgICAgIHNlbGVjdGlvblJlZ2lvbk91dGxpbmVDb2xvcjogZ3JpZFByb3BzLnNlbGVjdGlvblJlZ2lvbk91dGxpbmVDb2xvcixcbiAgICAgICAgICAgIHNlbGVjdGlvblJlZ2lvbkJvcmRlcldpZHRoOiBncmlkUHJvcHMuc2VsZWN0aW9uUmVnaW9uQm9yZGVyV2lkdGggPyBncmlkUHJvcHMuc2VsZWN0aW9uUmVnaW9uQm9yZGVyV2lkdGggOiAxXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ3JpZC5jZWxsUmVuZGVyZXJzLmdldCgnbGFzdHNlbGVjdGlvbicpLnBhaW50KGdjLCBjb25maWcpO1xuICAgICAgICBpZiAodGhpcy5ncmlkUmVuZGVyZXIucGFpbnRDZWxscy5rZXkgPT09ICdieS1jZWxscycpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZFJlbmRlcmVyLnJlc2V0ID0gdHJ1ZTsgLy8gZml4ZXMgR1JJRC00OTBcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgaXRlcmF0ZSB0aGUgcmVuZGVyZXJpbmcgb3ZlcnJpZGVzIGFuZCBtYW5pZmVzdCBlYWNoXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gICAgICovXG4gICAgcmVuZGVyT3ZlcnJpZGVzOiBmdW5jdGlvbihnYykge1xuICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLmdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGU7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgICAgICAgICAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3ZlcnJpZGUgPSBjYWNoZVtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck92ZXJyaWRlKGdjLCBvdmVycmlkZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBjb3B5IGVhY2ggb3ZlcnJpZGVzIHNwZWNpZmllZCBhcmVhIHRvIGl0J3MgdGFyZ2V0IGFuZCBibGFuayBvdXQgdGhlIHNvdXJjZSBhcmVhXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gICAgICogQHBhcmFtIHtPdmVycmlkZU9iamVjdH0gb3ZlcnJpZGUgLSBhbiBvYmplY3Qgd2l0aCBkZXRhaWxzIGNvbnRhaW4gYW4gYXJlYSBhbmQgYSB0YXJnZXQgY29udGV4dFxuICAgICAqL1xuICAgIHJlbmRlck92ZXJyaWRlOiBmdW5jdGlvbihnYywgb3ZlcnJpZGUpIHtcbiAgICAgICAgLy9sZXRzIGJsYW5rIG91dCB0aGUgZHJhZyByb3dcbiAgICAgICAgdmFyIGhkcGlSYXRpbyA9IG92ZXJyaWRlLmhkcGlyYXRpbztcbiAgICAgICAgdmFyIHN0YXJ0WCA9IG92ZXJyaWRlLnN0YXJ0WDsgLy9oZHBpUmF0aW8gKiBlZGdlc1tvdmVycmlkZS5jb2x1bW5JbmRleF07XG4gICAgICAgIHZhciB3aWR0aCA9IG92ZXJyaWRlLndpZHRoICsgMTtcbiAgICAgICAgdmFyIGhlaWdodCA9IG92ZXJyaWRlLmhlaWdodDtcbiAgICAgICAgdmFyIHRhcmdldENUWCA9IG92ZXJyaWRlLmN0eDtcbiAgICAgICAgdmFyIGltZ0RhdGEgPSBnYy5nZXRJbWFnZURhdGEoc3RhcnRYLCAwLCBNYXRoLnJvdW5kKHdpZHRoICogaGRwaVJhdGlvKSwgTWF0aC5yb3VuZChoZWlnaHQgKiBoZHBpUmF0aW8pKTtcbiAgICAgICAgdGFyZ2V0Q1RYLnB1dEltYWdlRGF0YShpbWdEYXRhLCAwLCAwKTtcbiAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gdGhpcy5wcm9wZXJ0aWVzLmJhY2tncm91bmRDb2xvcjI7XG4gICAgICAgIGdjLmZpbGxSZWN0KE1hdGgucm91bmQoc3RhcnRYIC8gaGRwaVJhdGlvKSwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBDdXJyZW50IHZlcnRpY2FsIHNjcm9sbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRTY3JvbGxUb3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmdldFZTY3JvbGxWYWx1ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gQ3VycmVudCBob3Jpem9udGFsIHNjcm9sbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRTY3JvbGxMZWZ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgbGFzdCBjb2wgd2FzIHJlbmRlcmVkIChpcyB2aXNpYmxlKVxuICAgICAqL1xuICAgIGlzTGFzdENvbHVtblZpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGFzdENvbHVtbkluZGV4ID0gdGhpcy5ncmlkLmdldENvbHVtbkNvdW50KCkgLSAxO1xuICAgICAgICByZXR1cm4gISF0aGlzLnZpc2libGVDb2x1bW5zLmZpbmRXaXRoTmVnKGZ1bmN0aW9uKHZjKSB7XG4gICAgICAgICAgICByZXR1cm4gdmMuY29sdW1uSW5kZXggPT09IGxhc3RDb2x1bW5JbmRleDtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcmVuZGVyZWQgY29sdW1uIHdpZHRoIGF0IGluZGV4XG4gICAgICovXG4gICAgZ2V0UmVuZGVyZWRXaWR0aDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICAgIGNvbHVtbnMgPSB0aGlzLnZpc2libGVDb2x1bW5zO1xuXG4gICAgICAgIGlmIChpbmRleCA+PSBjb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29sdW1uc1tjb2x1bW5zLmxlbmd0aCAtIDFdLnJpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29sdW1uc1tpbmRleF0ubGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcmVuZGVyZWQgcm93IGhlaWdodCBhdCBpbmRleFxuICAgICAqL1xuICAgIGdldFJlbmRlcmVkSGVpZ2h0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgcm93cyA9IHRoaXMudmlzaWJsZVJvd3M7XG5cbiAgICAgICAgaWYgKGluZGV4ID49IHJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IHJvd3Nbcm93cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGxhc3QuYm90dG9tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gcm93c1tpbmRleF0udG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBVc2VyIGlzIGN1cnJlbnRseSBkcmFnZ2luZyBhIGNvbHVtbiBmb3IgcmVvcmRlcmluZy5cbiAgICAgKi9cbiAgICBpc0RyYWdnaW5nQ29sdW1uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5pc0RyYWdnaW5nQ29sdW1uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcm93IHRvIGdvIHRvIGZvciBhIHBhZ2UgdXAuXG4gICAgICovXG4gICAgZ2V0UGFnZVVwUm93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdyaWQgPSB0aGlzLmdyaWQsXG4gICAgICAgICAgICBzY3JvbGxIZWlnaHQgPSB0aGlzLmdldFZpc2libGVTY3JvbGxIZWlnaHQoKSxcbiAgICAgICAgICAgIHRvcCA9IHRoaXMuZGF0YVdpbmRvdy5vcmlnaW4ueSAtIHRoaXMucHJvcGVydGllcy5maXhlZFJvd0NvdW50IC0gMSxcbiAgICAgICAgICAgIHNjYW5IZWlnaHQgPSAwO1xuICAgICAgICB3aGlsZSAoc2NhbkhlaWdodCA8IHNjcm9sbEhlaWdodCAmJiB0b3AgPj0gMCkge1xuICAgICAgICAgICAgc2NhbkhlaWdodCArPSBncmlkLmdldFJvd0hlaWdodCh0b3ApO1xuICAgICAgICAgICAgdG9wLS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcCArIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcm93IHRvIGdvdG8gZm9yIGEgcGFnZSBkb3duLlxuICAgICAqL1xuICAgIGdldFBhZ2VEb3duUm93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVdpbmRvdy5jb3JuZXIueSAtIHRoaXMucHJvcGVydGllcy5maXhlZFJvd0NvdW50ICsgMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByb3cgdG8gZ290byBmb3IgYSBwYWdlIHJpZ2h0LlxuICAgICAqL1xuICAgIGdldFBhZ2VSaWdodENvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFXaW5kb3cuY29ybmVyLnggLSB0aGlzLnByb3BlcnRpZXMuZml4ZWRDb2x1bW5Db3VudCArIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcm93IHRvIGdvIHRvIGZvciBhIHBhZ2UgbGVmdC5cbiAgICAgKi9cbiAgICBnZXRQYWdlTGVmdENvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB3aWR0aExlZnQgPSB0aGlzLmJvdW5kcy53aWR0aDtcbiAgICAgICAgdmFyIGN1cnJlbnRDb2x1bW5Ub1Njcm9sbEluZGV4ID0gdGhpcy5kYXRhV2luZG93Lm9yaWdpbi54IC0gMTtcblxuICAgICAgICB3aGlsZSAoY3VycmVudENvbHVtblRvU2Nyb2xsSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgd2lkdGhMZWZ0IC09IHRoaXMuZ3JpZC5nZXRDb2x1bW5XaWR0aChjdXJyZW50Q29sdW1uVG9TY3JvbGxJbmRleCk7XG5cbiAgICAgICAgICAgIGlmICh3aWR0aExlZnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnRDb2x1bW5Ub1Njcm9sbEluZGV4IC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWRkaXRpb25hbENvbHVtbnMgPSB0aGlzLmdyaWQucHJvcGVydGllcy5yb3dIZWFkZXJOdW1iZXJzID8gMSA6IDA7XG4gICAgICAgIHJldHVybiBjdXJyZW50Q29sdW1uVG9TY3JvbGxJbmRleCArIGFkZGl0aW9uYWxDb2x1bW5zO1xuICAgIH0sXG5cbiAgICByZW5kZXJFcnJvckNlbGw6IGZ1bmN0aW9uKGVyciwgZ2MsIHZjLCB2cikge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGVyciAmJiAoZXJyLm1lc3NhZ2UgfHwgZXJyKSB8fCAnVW5rbm93biBlcnJvci4nLFxuICAgICAgICAgICAgYm91bmRzID0geyB4OiB2Yy5sZWZ0LCB5OiB2ci50b3AsIHdpZHRoOiB2Yy53aWR0aCwgaGVpZ2h0OiB2ci5oZWlnaHQgfSxcbiAgICAgICAgICAgIGNvbmZpZyA9IHsgYm91bmRzOiBib3VuZHMgfTtcblxuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuXG4gICAgICAgIGdjLmNhY2hlLnNhdmUoKTsgLy8gZGVmaW5lIGNsaXBwaW5nIHJlZ2lvblxuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgZ2MucmVjdChib3VuZHMueCwgYm91bmRzLnksIGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCk7XG4gICAgICAgIGdjLmNsaXAoKTtcblxuICAgICAgICB0aGlzLmdyaWQuY2VsbFJlbmRlcmVycy5nZXQoJ2Vycm9yY2VsbCcpLnBhaW50KGdjLCBjb25maWcsIG1lc3NhZ2UpO1xuXG4gICAgICAgIGdjLmNhY2hlLnJlc3RvcmUoKTsgLy8gZGlzY2FyZCBjbGlwcGluZyByZWdpb25cbiAgICB9LFxuXG4gICAgZHJhd0xpbmU6IGZ1bmN0aW9uKGdjLCB4MSwgeTEsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgZ2MuZmlsbFJlY3QoeDEsIHkxLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYSByb3VuZGVkIHJlY3RhbmdsZSB1c2luZyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgY2FudmFzLlxuICAgICAqIElmIHlvdSBvbWl0IHRoZSBsYXN0IHRocmVlIHBhcmFtcywgaXQgd2lsbCBkcmF3IGEgcmVjdGFuZ2xlXG4gICAgICogb3V0bGluZSB3aXRoIGEgNSBwaXhlbCBib3JkZXIgcmFkaXVzXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHRvcCBsZWZ0IHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB0b3AgbGVmdCB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcmFkaXVzID0gNV0gVGhlIGNvcm5lciByYWRpdXM7IEl0IGNhbiBhbHNvIGJlIGFuIG9iamVjdFxuICAgICAqICAgICAgICAgICAgICAgICB0byBzcGVjaWZ5IGRpZmZlcmVudCByYWRpaSBmb3IgY29ybmVyc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcmFkaXVzLnRsID0gMF0gVG9wIGxlZnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3JhZGl1cy50ciA9IDBdIFRvcCByaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcmFkaXVzLmJyID0gMF0gQm90dG9tIHJpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyYWRpdXMuYmwgPSAwXSBCb3R0b20gbGVmdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZpbGwgPSBmYWxzZV0gV2hldGhlciB0byBmaWxsIHRoZSByZWN0YW5nbGUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc3Ryb2tlID0gdHJ1ZV0gV2hldGhlciB0byBzdHJva2UgdGhlIHJlY3RhbmdsZS5cbiAgICAgKi9cbiAgICByZW5kZXJSb3VuZFJlY3Q6IGZ1bmN0aW9uKGdjLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMsIGZpbGwsIHN0cm9rZSkge1xuICAgICAgICBpZiAodHlwZW9mIHN0cm9rZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHN0cm9rZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByYWRpdXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByYWRpdXMgPSA1O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmFkaXVzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmFkaXVzID0geyB0bDogcmFkaXVzLCB0cjogcmFkaXVzLCBicjogcmFkaXVzLCBibDogcmFkaXVzIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGVmYXVsdFJhZGl1cyA9IHsgdGw6IDAsIHRyOiAwLCBicjogMCwgYmw6IDAgfTtcbiAgICAgICAgICAgIGZvciAobGV0IHNpZGUgaW4gZGVmYXVsdFJhZGl1cykge1xuICAgICAgICAgICAgICAgIHJhZGl1c1tzaWRlXSA9IHJhZGl1c1tzaWRlXSB8fCBkZWZhdWx0UmFkaXVzW3NpZGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICBnYy5tb3ZlVG8oeCArIHJhZGl1cy50bCwgeSk7XG4gICAgICAgIGdjLmxpbmVUbyh4ICsgd2lkdGggLSByYWRpdXMudHIsIHkpO1xuICAgICAgICBnYy5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzLnRyKTtcbiAgICAgICAgZ2MubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGl1cy5icik7XG4gICAgICAgIGdjLnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByYWRpdXMuYnIsIHkgKyBoZWlnaHQpO1xuICAgICAgICBnYy5saW5lVG8oeCArIHJhZGl1cy5ibCwgeSArIGhlaWdodCk7XG4gICAgICAgIGdjLnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJhZGl1cy5ibCk7XG4gICAgICAgIGdjLmxpbmVUbyh4LCB5ICsgcmFkaXVzLnRsKTtcbiAgICAgICAgZ2MucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcmFkaXVzLnRsLCB5KTtcbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgICBnYy5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cm9rZSkge1xuICAgICAgICAgICAgZ2Muc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFdlIG9wdGVkIHRvIG5vdCBwYWludCBib3JkZXJzIGZvciBlYWNoIGNlbGwgYXMgdGhhdCB3YXMgZXh0cmVtZWx5IGV4cGVuc2l2ZS4gSW5zdGVhZCB3ZSBkcmF3IGdyaWQgbGluZXMgaGVyZS5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gZ2NcbiAgICAgKi9cbiAgICBwYWludEdyaWRsaW5lczogZnVuY3Rpb24oZ2MpIHtcbiAgICAgICAgY29uc3QgdmlzaWJsZUNvbHVtbnMgPSB0aGlzLnZpc2libGVDb2x1bW5zLFxuICAgICAgICAgICAgY29sdW1uc0xlbmd0aCA9IHZpc2libGVDb2x1bW5zLmxlbmd0aCxcbiAgICAgICAgICAgIHZpc2libGVSb3dzID0gdGhpcy52aXNpYmxlUm93cyxcbiAgICAgICAgICAgIHJvd3NMZW5ndGggPSB2aXNpYmxlUm93cy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGNvbHVtbnNMZW5ndGggJiYgcm93c0xlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZ3JpZFByb3BzID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIHZpZXdXaWR0aCA9IHZpc2libGVDb2x1bW5zW2NvbHVtbnNMZW5ndGggLSAxXS5yaWdodCxcbiAgICAgICAgICAgICAgICB2aWV3SGVpZ2h0ID0gdmlzaWJsZVJvd3Nbcm93c0xlbmd0aCAtIDFdLmJvdHRvbTtcblxuICAgICAgICAgICAgaWYgKGdyaWRQcm9wcy5ncmlkTGluZXNWKSB7XG4gICAgICAgICAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gZ2MuY2FjaGUuc3Ryb2tlU3R5bGUgPSBncmlkUHJvcHMuZ3JpZExpbmVzQ29sb3I7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCByaWdodCwgdmMgPSB2aXNpYmxlQ29sdW1uc1swXSwgYyA9IDA7IGMgPCBjb2x1bW5zTGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmMgPSB2aXNpYmxlQ29sdW1uc1tjXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2Yy5nYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdmMucmlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzaGlmdCA9IGdyaWRQcm9wcy5kZWZhdWx0SGVhZGVyUm93SGVpZ2h0IC0gZ3JpZFByb3BzLmdyaWRMaW5lc1dpZHRoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3NMZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IHZpc2libGVSb3dzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3cuc3ViZ3JpZC5pc0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZC5iZWhhdmlvci5kYXRhTW9kZWwuaXNDb2xzcGFuZWRCeUxlZnRDb2x1bW4odmMuY29sdW1uSW5kZXggKyAxLCByb3cucm93SW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCArPSByb3cuaGVpZ2h0ICsgZ3JpZFByb3BzLmdyaWRMaW5lc1dpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdMaW5lKGdjLCByaWdodCwgc2hpZnQsIGdyaWRQcm9wcy5ncmlkTGluZXNXaWR0aCwgdmlld0hlaWdodCAtIHNoaWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGdyaWRQcm9wcy5ncmlkTGluZXNIKSB7XG4gICAgICAgICAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gZ2MuY2FjaGUuc3Ryb2tlU3R5bGUgPSBncmlkUHJvcHMuZ3JpZExpbmVzQ29sb3I7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYm90dG9tLCB2ciA9IHZpc2libGVSb3dzWzBdLCByID0gMDsgciA8IHJvd3NMZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgICAgICAgICB2ciA9IHZpc2libGVSb3dzW3JdO1xuICAgICAgICAgICAgICAgICAgICBib3R0b20gPSB2ci5ib3R0b207XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5zTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IHZpc2libGVDb2x1bW5zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2ci5nYXAgJiYgIXRoaXMuZ3JpZC5iZWhhdmlvci5kYXRhTW9kZWwuaXNSb3dzcGFuZWRCeVJvdyhjb2x1bW4uY29sdW1uSW5kZXgsIHZyLnJvd0luZGV4ICsgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdMaW5lKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLndpZHRoICsgKGdyaWRQcm9wcy5ncmlkTGluZXNWID8gZ3JpZFByb3BzLmdyaWRMaW5lc1dpZHRoIDogMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRQcm9wcy5ncmlkTGluZXNXaWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHZyLnJvd0luZGV4ID4gZ3JpZFByb3BzLmZpY3RpdmVIZWFkZXJSb3dzQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uc0xlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgY29uc3QgY29sdW1uID0gdmlzaWJsZUNvbHVtbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgaWYgKCF2ci5nYXAgJiYgIXRoaXMuZ3JpZC5iZWhhdmlvci5kYXRhTW9kZWwuaXNSb3dzcGFuZWRCeVJvdyhjb2x1bW4uY29sdW1uSW5kZXggLSAxLCB2ci5yb3dJbmRleCArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIHRoaXMuZHJhd0xpbmUoZ2MsIGNvbHVtbi5sZWZ0LCBib3R0b20sIGNvbHVtbi53aWR0aCwgZ3JpZFByb3BzLmdyaWRMaW5lc1dpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIH0gZWxzZSBpZiAoIXZyLmdhcCkge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5kcmF3TGluZShnYywgMCwgYm90dG9tLCB2aWV3V2lkdGgsIGdyaWRQcm9wcy5ncmlkTGluZXNXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKCF2ci5nYXApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHRoaXMuZHJhd0xpbmUoZ2MsIDAsIGJvdHRvbSwgdmlld1dpZHRoLCBncmlkUHJvcHMuZ3JpZExpbmVzV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgZWRnZVdpZHRoO1xuICAgICAgICAgICAgbGV0IGdhcCA9IHZpc2libGVSb3dzLmdhcDtcbiAgICAgICAgICAgIGlmIChnYXApIHtcbiAgICAgICAgICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSBnYy5jYWNoZS5zdHJva2VTdHlsZSA9IGdyaWRQcm9wcy5maXhlZExpbmVzSENvbG9yIHx8IGdyaWRQcm9wcy5ncmlkTGluZXNDb2xvcjtcbiAgICAgICAgICAgICAgICBlZGdlV2lkdGggPSBncmlkUHJvcHMuZml4ZWRMaW5lc0hFZGdlO1xuICAgICAgICAgICAgICAgIGlmIChlZGdlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3TGluZShnYywgMCwgZ2FwLnRvcCwgdmlld1dpZHRoLCBlZGdlV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdMaW5lKGdjLCAwLCBnYXAuYm90dG9tIC0gZWRnZVdpZHRoLCB2aWV3V2lkdGgsIGVkZ2VXaWR0aCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChncmlkUHJvcHMuZml4ZWRSb3dDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3TGluZShnYywgMCwgZ2FwLnRvcCwgdmlld1dpZHRoLCBnYXAuYm90dG9tIC0gZ2FwLnRvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnYXAgPSB2aXNpYmxlQ29sdW1ucy5nYXA7XG4gICAgICAgICAgICBpZiAoZ2FwKSB7XG4gICAgICAgICAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gZ2MuY2FjaGUuc3Ryb2tlU3R5bGUgPSBncmlkUHJvcHMuZml4ZWRMaW5lc1ZDb2xvciB8fCBncmlkUHJvcHMuZ3JpZExpbmVzQ29sb3I7XG4gICAgICAgICAgICAgICAgZWRnZVdpZHRoID0gZ3JpZFByb3BzLmZpeGVkTGluZXNWRWRnZTtcbiAgICAgICAgICAgICAgICBpZiAoZWRnZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xpbmUoZ2MsIGdhcC5sZWZ0LCAwLCBlZGdlV2lkdGgsIHZpZXdIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdMaW5lKGdjLCBnYXAucmlnaHQgLSBlZGdlV2lkdGgsIDAsIGVkZ2VXaWR0aCwgdmlld0hlaWdodCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3TGluZShnYywgZ2FwLmxlZnQsIDAsIGdhcC5yaWdodCAtIGdhcC5sZWZ0LCB2aWV3SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGZ1bmN0aW9uIHRvIHJlbmRlciBoZWFkZXIgZ3JpZCBsaW5lcyBzZXBhcmF0ZWx5XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gICAgICovXG4gICAgcGFpbnRIZWFkZXJHcmlkbGluZXM6IGZ1bmN0aW9uKGdjKSB7XG4gICAgICAgIHZhciB2aXNpYmxlQ29sdW1ucyA9IHRoaXMudmlzaWJsZUNvbHVtbnMsXG4gICAgICAgICAgICBjb2x1bW5zTGVuZ3RoID0gdmlzaWJsZUNvbHVtbnMubGVuZ3RoLFxuICAgICAgICAgICAgdmlzaWJsZVJvd3MgPSB0aGlzLnZpc2libGVSb3dzLFxuICAgICAgICAgICAgcm93c0xlbmd0aCA9IHZpc2libGVSb3dzLmxlbmd0aDtcblxuICAgICAgICBpZiAoY29sdW1uc0xlbmd0aCAmJiByb3dzTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZ3JpZFByb3BzID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIHZpZXdXaWR0aCA9IHZpc2libGVDb2x1bW5zW2NvbHVtbnNMZW5ndGggLSAxXS5yaWdodCxcbiAgICAgICAgICAgICAgICB2aWV3SGVpZ2h0ID0gdmlzaWJsZVJvd3Nbcm93c0xlbmd0aCAtIDFdLmJvdHRvbTtcbiAgICAgICAgICAgIHZhciBoZWFkZXJSb3dzQ291bnQgPSB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcblxuICAgICAgICAgICAgaWYgKGdyaWRQcm9wcy5ncmlkTGluZXNWIHx8IGdyaWRQcm9wcy5ncmlkTGluZXNIZWFkZXJDb2xvcikge1xuICAgICAgICAgICAgICAgIHZhciBoZWFkZXJIZWlnaHQgPSBoZWFkZXJSb3dzQ291bnQgKiB0aGlzLnByb3BlcnRpZXMuZGVmYXVsdEhlYWRlclJvd0hlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoIWhlYWRlckhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWRlclJvd3NDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJIZWlnaHQgKz0gdGhpcy5ncmlkLmdldFJvd0hlaWdodChpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGdjLmNhY2hlLmZpbGxTdHlsZVxuICAgICAgICAgICAgICAgICAgICA9IGdjLmNhY2hlLnN0cm9rZVN0eWxlXG4gICAgICAgICAgICAgICAgICAgID0gZ3JpZFByb3BzLmdyaWRMaW5lc0hlYWRlckNvbG9yID8gZ3JpZFByb3BzLmdyaWRMaW5lc0hlYWRlckNvbG9yIDogZ3JpZFByb3BzLmdyaWRMaW5lc0NvbG9yO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGhlYWRlclJpZ2h0LCBoZWFkZXJWYyA9IHZpc2libGVDb2x1bW5zWzBdLCBoZWFkZXJDID0gMDsgaGVhZGVyQyA8IGNvbHVtbnNMZW5ndGg7IGhlYWRlckMrKykge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJWYyA9IHZpc2libGVDb2x1bW5zW2hlYWRlckNdO1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJSaWdodCA9IGhlYWRlclZjLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhlYWRlclZjLmdhcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3TGluZShnYywgaGVhZGVyUmlnaHQsIDAsIGdyaWRQcm9wcy5ncmlkTGluZXNXaWR0aCwgaGVhZGVySGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdyaWQucHJvcGVydGllcy5yb3dIZWFkZXJOdW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByaWdodCA9IHZpc2libGVDb2x1bW5zW3RoaXMuZ3JpZC5iZWhhdmlvci5yb3dDb2x1bW5JbmRleF0ucmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGdjLmNhY2hlLmZpbGxTdHlsZSA9IGdjLmNhY2hlLnN0cm9rZVN0eWxlID0gZ3JpZFByb3BzLmdyaWRMaW5lc0hlYWRlckNvbG9yIHx8IGdyaWRQcm9wcy5ncmlkTGluZXNDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3TGluZShnYywgcmlnaHQsIDAsIGdyaWRQcm9wcy5ncmlkTGluZXNXaWR0aCwgdmlld0hlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ3JpZFByb3BzLmdyaWRMaW5lc0ggfHwgZ3JpZFByb3BzLmdyaWRMaW5lc0hlYWRlckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlXG4gICAgICAgICAgICAgICAgICAgID0gZ2MuY2FjaGUuc3Ryb2tlU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgPSBncmlkUHJvcHMuZ3JpZExpbmVzSGVhZGVyQ29sb3IgPyBncmlkUHJvcHMuZ3JpZExpbmVzSGVhZGVyQ29sb3IgOiBncmlkUHJvcHMuZ3JpZExpbmVzQ29sb3I7XG5cbiAgICAgICAgICAgICAgICB2YXIgYWRkaXRpb25hbFdpZHRoID0gZ3JpZFByb3BzLmdyaWRMaW5lc1YgPyBncmlkUHJvcHMuZ3JpZExpbmVzV2lkdGggOiAwO1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdFJvd1dpZHRoID0gdGhpcy5ncmlkLnByb3BlcnRpZXMucm93SGVhZGVyTnVtYmVyc1xuICAgICAgICAgICAgICAgICAgICA/IHZpc2libGVDb2x1bW5zW3RoaXMuZ3JpZC5iZWhhdmlvci5yb3dDb2x1bW5JbmRleF0ucmlnaHQgKyBhZGRpdGlvbmFsV2lkdGhcbiAgICAgICAgICAgICAgICAgICAgOiAwO1xuXG4gICAgICAgICAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gZ2MuY2FjaGUuc3Ryb2tlU3R5bGUgPSBncmlkUHJvcHMuZ3JpZExpbmVzSGVhZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaGVhZGVyQm90dG9tLCBoZWFkZXJWciA9IHZpc2libGVSb3dzWzBdLCBoZWFkZXJSID0gMDsgaGVhZGVyUiA8IHJvd3NMZW5ndGg7IGhlYWRlclIrKykge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJWciA9IHZpc2libGVSb3dzW2hlYWRlclJdO1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJCb3R0b20gPSBoZWFkZXJWci5ib3R0b207XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGVhZGVyVnIuZ2FwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVyUiA8IGhlYWRlclJvd3NDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xpbmUoZ2MsIDAsIGhlYWRlckJvdHRvbSwgdmlld1dpZHRoLCBncmlkUHJvcHMuZ3JpZExpbmVzV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdMaW5lKGdjLCAwLCBoZWFkZXJCb3R0b20sIGZpcnN0Um93V2lkdGgsIGdyaWRQcm9wcy5ncmlkTGluZXNXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKi9cbiAgICBwYWludENlbGw6IGZ1bmN0aW9uKGdjLCB4LCB5KSB7XG4gICAgICAgIGdjLm1vdmVUbygwLCAwKTtcblxuICAgICAgICBsZXQgYyA9IHRoaXMudmlzaWJsZUNvbHVtbnNbeF0uaW5kZXgsIC8vIHRvZG8gcmVmYWNcbiAgICAgICAgICAgIHIgPSB0aGlzLnZpc2libGVSb3dzW3ldLmluZGV4O1xuXG4gICAgICAgIGlmIChjKSB7IC8vc29tZXRoaW5nIGlzIGJlaW5nIHZpZXdlZCBhdCBhdCB0aGUgbW9tZW50IChvdGhlcndpc2UgcmV0dXJucyB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLl9wYWludENlbGwoZ2MsIGMsIHIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJlbmRlciBhIHNpbmdsZSBjZWxsLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fSBjZWxsRXZlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpbGxDb2xvcl0gSWYgb21pdHRlZCwgdGhpcyBpcyBhIHBhcnRpYWwgcmVuZGVyZXI7IGFsbCBvdGhlciByZW5kZXJlcnMgbXVzdCBwcm92aWRlIHRoaXMuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUHJlZmVycmVkIHdpZHRoIG9mIHJlbm5kZXJlZCBjZWxsLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyXG4gICAgICovXG4gICAgX3BhaW50Q2VsbDogZnVuY3Rpb24oZ2MsIGNlbGxFdmVudCwgcHJlZmlsbENvbG9yKSB7XG4gICAgICAgIGlmIChjZWxsRXZlbnQuaXNSZW5kZXJTa2lwTmVlZGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZCxcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGVsID0gZ3JpZC5zZWxlY3Rpb25Nb2RlbCxcbiAgICAgICAgICAgIGJlaGF2aW9yID0gZ3JpZC5iZWhhdmlvcixcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSBjZWxsRXZlbnQucHJvcGVydGllcyxcblxuICAgICAgICAgICAgaXNIYW5kbGVDb2x1bW4gPSBjZWxsRXZlbnQuaXNIYW5kbGVDb2x1bW4sXG4gICAgICAgICAgICBpc1RyZWVDb2x1bW4gPSBjZWxsRXZlbnQuaXNUcmVlQ29sdW1uLFxuICAgICAgICAgICAgaXNDb2x1bW5TZWxlY3RlZCA9IGNlbGxFdmVudC5pc0NvbHVtblNlbGVjdGVkLFxuXG4gICAgICAgICAgICBpc0RhdGFSb3cgPSBjZWxsRXZlbnQuaXNEYXRhUm93LFxuICAgICAgICAgICAgaXNSb3dTZWxlY3RlZCA9IGNlbGxFdmVudC5pc1Jvd1NlbGVjdGVkLFxuICAgICAgICAgICAgaXNDZWxsU2VsZWN0ZWQgPSBjZWxsRXZlbnQuaXNDZWxsU2VsZWN0ZWQsXG5cbiAgICAgICAgICAgIGlzSGVhZGVyUm93ID0gY2VsbEV2ZW50LmlzSGVhZGVyUm93LFxuICAgICAgICAgICAgaXNGaWx0ZXJSb3cgPSBjZWxsRXZlbnQuaXNGaWx0ZXJSb3csXG5cbiAgICAgICAgICAgIGlzUm93SGFuZGxlT3JIaWVyYXJjaHlDb2x1bW4gPSBpc0hhbmRsZUNvbHVtbiB8fCBpc1RyZWVDb2x1bW4sXG4gICAgICAgICAgICBpc1VzZXJEYXRhQXJlYSA9ICFpc1Jvd0hhbmRsZU9ySGllcmFyY2h5Q29sdW1uICYmIGlzRGF0YVJvdyxcblxuICAgICAgICAgICAgY29uZmlnID0gdGhpcy5hc3NpZ25Qcm9wcyhjZWxsRXZlbnQpLFxuXG4gICAgICAgICAgICB4ID0gKGNvbmZpZy5ncmlkQ2VsbCA9IGNlbGxFdmVudC5ncmlkQ2VsbCkueCxcbiAgICAgICAgICAgIHIgPSAoY29uZmlnLmRhdGFDZWxsID0gY2VsbEV2ZW50LmRhdGFDZWxsKS55LFxuXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGZvcm1hdCxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQ7XG5cbiAgICAgICAgaWYgKGlzSGFuZGxlQ29sdW1uICYmIGlzRGF0YVJvdykge1xuICAgICAgICAgICAgaXNTZWxlY3RlZCA9IGlzUm93U2VsZWN0ZWQgfHwgc2VsZWN0aW9uTW9kZWwuaXNDZWxsU2VsZWN0ZWRJblJvdyhyKTtcbiAgICAgICAgICAgIGNvbmZpZy5oYWxpZ24gPSB0aGlzLnByb3BlcnRpZXMuY29sdW1uSGVhZGVySGFsaWduO1xuICAgICAgICB9IGVsc2UgaWYgKGlzVHJlZUNvbHVtbikge1xuICAgICAgICAgICAgaXNTZWxlY3RlZCA9IGlzUm93U2VsZWN0ZWQgfHwgc2VsZWN0aW9uTW9kZWwuaXNDZWxsU2VsZWN0ZWRJblJvdyhyKTtcbiAgICAgICAgICAgIGNvbmZpZy5oYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRhUm93KSB7XG4gICAgICAgICAgICBpc1NlbGVjdGVkID0gaXNDZWxsU2VsZWN0ZWQgfHwgaXNSb3dTZWxlY3RlZCB8fCBpc0NvbHVtblNlbGVjdGVkO1xuICAgICAgICAgICAgZm9ybWF0ID0gY29uZmlnLmZvcm1hdDtcbiAgICAgICAgfSBlbHNlIGlmICh4ID09PSBncmlkLmJlaGF2aW9yLnJvd0NvbHVtbkluZGV4ICYmIHIgPT09IDAgJiYgaXNIYW5kbGVDb2x1bW4gJiYgaXNIZWFkZXJSb3cgJiYgYmVoYXZpb3IuZXJyb3JDb3VudCkge1xuICAgICAgICAgICAgY29uZmlnLmZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IGNvbmZpZy5jb2xvciA9IHByb3BlcnRpZXMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgLy8gY29uZmlnLmJhY2tncm91bmRUZXh0ID0gdGhpcy5wcm9wZXJ0aWVzLmVycm9yVG90YWxVbmljb2RlQ2hhcjtcbiAgICAgICAgICAgIC8vIGNvbmZpZy5iYWNrZ3JvdW5kVGV4dEZvbnQgPSB0aGlzLnByb3BlcnRpZXMuZXJyb3JJY29uRm9udDtcbiAgICAgICAgICAgIC8vIGNvbmZpZy5iYWNrZ3JvdW5kVGV4dENvbG9yID0gdGhpcy5wcm9wZXJ0aWVzLmVycm9ySWNvbkNvbG9yO1xuICAgICAgICAgICAgY29uZmlnLnJlbmRlclRvdGFsRXJyb3JTaWduTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5yZW5kZXJUb3RhbEVycm9yQ291bnQgPSBiZWhhdmlvci5lcnJvckNvdW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gY2VsbEV2ZW50LnN1YmdyaWQuZm9ybWF0IHx8IGNvbmZpZy5mb3JtYXQ7IC8vIHN1YmdyaWQgZm9ybWF0IGNhbiBvdmVycmlkZSBjb2x1bW4gZm9ybWF0XG4gICAgICAgICAgICBpZiAoaXNGaWx0ZXJSb3cpIHtcbiAgICAgICAgICAgICAgICBpc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQ29sdW1uU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNTZWxlY3RlZCA9IHNlbGVjdGlvbk1vZGVsLmlzQ2VsbFNlbGVjdGVkSW5Db2x1bW4oeCk7IC8vIGhlYWRlciBvciBzdW1tYXJ5IG9yIG90aGVyIG5vbi1tZXRhXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgY2VsbCBjb250ZW50czpcbiAgICAgICAgLy8gKiBGb3IgYWxsIGNlbGxzOiBzZXQgYGNvbmZpZy52YWx1ZWAgKHdyaXRhYmxlIHByb3BlcnR5KVxuICAgICAgICAvLyAqIEZvciBjZWxscyBvdXRzaWRlIG9mIHJvdyBoYW5kbGUgY29sdW1uOiBhbHNvIHNldCBgY29uZmlnLmRhdGFSb3dgIGZvciB1c2UgYnkgdmFsT3JGdW5jXG5cbiAgICAgICAgaWYgKCFpc0hhbmRsZUNvbHVtbikge1xuICAgICAgICAgICAgLy9JbmNsdWRpbmcgaGllcmFyY2h5Q29sdW1uXG4gICAgICAgICAgICBjb25maWcuZGF0YVJvdyA9IGNlbGxFdmVudC5kYXRhUm93O1xuICAgICAgICAgICAgdmFsdWUgPSBjZWxsRXZlbnQudmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS50eXBlID09PSAnRVJST1InKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IGNvbmZpZy5jb2xvciA9IGNvbmZpZy5lcnJvckNlbGxEYXRhQ29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yID0gY29uZmlnLmNvbG9yID0gY29uZmlnLm51bGxDZWxsQ29sb3I7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb25maWcubnVsbENlbGxQbGFjZWhvbGRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc0RhdGFSb3cpIHtcbiAgICAgICAgICAgICAgICAvLyByb3cgaGFuZGxlIGZvciBhIGRhdGEgcm93XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5yb3dIZWFkZXJOdW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gciArIGNvbmZpZy5yb3dIZWFkZXJTdGFydERpc3BsYXllZEluZGV4OyAvLyByb3cgbnVtYmVyIGlzIDEtYmFzZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzSGVhZGVyUm93KSB7XG4gICAgICAgICAgICAgICAgLy8gcm93IGhhbmRsZSBmb3IgaGVhZGVyIHJvdzogZ2V0cyBcIm1hc3RlclwiIGNoZWNrYm94XG4gICAgICAgICAgICAgICAgY29uZmlnLmFsbFJvd3NTZWxlY3RlZCA9IHNlbGVjdGlvbk1vZGVsLmFyZUFsbFJvd3NTZWxlY3RlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLmlzU2VsZWN0ZWQgPSBpc1NlbGVjdGVkO1xuICAgICAgICBjb25maWcuaXNEYXRhQ29sdW1uID0gIWlzUm93SGFuZGxlT3JIaWVyYXJjaHlDb2x1bW47XG4gICAgICAgIGNvbmZpZy5pc0hhbmRsZUNvbHVtbiA9IGlzSGFuZGxlQ29sdW1uO1xuICAgICAgICBjb25maWcuaXNUcmVlQ29sdW1uID0gaXNUcmVlQ29sdW1uO1xuICAgICAgICBjb25maWcuaXNEYXRhUm93ID0gaXNEYXRhUm93O1xuICAgICAgICBjb25maWcuaXNIZWFkZXJSb3cgPSBpc0hlYWRlclJvdztcbiAgICAgICAgY29uZmlnLmlzRmlsdGVyUm93ID0gaXNGaWx0ZXJSb3c7XG4gICAgICAgIGNvbmZpZy5pc1VzZXJEYXRhQXJlYSA9IGlzVXNlckRhdGFBcmVhO1xuICAgICAgICBjb25maWcuaXNDb2x1bW5Ib3ZlcmVkID0gY2VsbEV2ZW50LmlzQ29sdW1uSG92ZXJlZDtcbiAgICAgICAgY29uZmlnLmlzUm93SG92ZXJlZCA9IGNlbGxFdmVudC5pc1Jvd0hvdmVyZWQ7XG4gICAgICAgIGNvbmZpZy5pc0NlbGxIb3ZlcmVkID0gY2VsbEV2ZW50LmlzQ2VsbEhvdmVyZWQ7XG4gICAgICAgIGNvbmZpZy5ib3VuZHMgPSBjZWxsRXZlbnQuYm91bmRzO1xuICAgICAgICBjb25maWcuaXNDZWxsU2VsZWN0ZWQgPSBpc0NlbGxTZWxlY3RlZDtcbiAgICAgICAgY29uZmlnLmlzUm93U2VsZWN0ZWQgPSBpc1Jvd1NlbGVjdGVkO1xuICAgICAgICBjb25maWcuaXNDb2x1bW5TZWxlY3RlZCA9IGlzQ29sdW1uU2VsZWN0ZWQ7XG4gICAgICAgIGNvbmZpZy5pc0luQ3VycmVudFNlbGVjdGlvblJlY3RhbmdsZSA9IHNlbGVjdGlvbk1vZGVsLmlzSW5DdXJyZW50U2VsZWN0aW9uUmVjdGFuZ2xlKHgsIHIpO1xuICAgICAgICBjb25maWcuaXNGaXJzdFNlbGVjdGVkQ2VsbCA9ICFpc0hlYWRlclJvdyAmJiBzZWxlY3Rpb25Nb2RlbC5pc0ZpcnN0U2VsZWN0ZWRDZWxsKHgsIHIpO1xuICAgICAgICBjb25maWcucHJlZmlsbENvbG9yID0gcHJlZmlsbENvbG9yO1xuICAgICAgICBjb25maWcuYnV0dG9uQ2VsbHMgPSB0aGlzLmJ1dHRvbkNlbGxzOyAvLyBhbGxvdyB0aGUgcmVuZGVyZXIgdG8gaWRlbnRpZnkgaXRzZWxmIGlmIGl0J3MgYSBidXR0b25cbiAgICAgICAgY29uZmlnLnN1YnJvdyA9IDA7XG4gICAgICAgIGNvbmZpZy5oYWxpZ24gPSBpc0hlYWRlclJvdyA/IGNvbmZpZy5yb3dIZWFkZXJIYWxpZ24gOiBiZWhhdmlvci5nZXRDZWxsUHJvcGVydHkoJ2hhbGlnbicpIHx8IGNvbmZpZy5oYWxpZ247XG4gICAgICAgIGNvbmZpZy5pZ25vcmVWYWx1ZVByZWZpeCA9IHByb3BlcnRpZXMuaWdub3JlVmFsdWVQcmVmaXg7XG4gICAgICAgIGNvbmZpZy5oaWdobGlnaHRlZENoYXJzID0gY2VsbEV2ZW50LmhpZ2hsaWdodGVkQ2hhcnM7XG5cbiAgICAgICAgY29uZmlnLmlzQWdncmVnYXRpb25UcmVlQ29sdW1uID0gY2VsbEV2ZW50LmlzQWdncmVnYXRpb25UcmVlQ29sdW1uO1xuICAgICAgICBpZiAoY29uZmlnLmlzQWdncmVnYXRpb25UcmVlQ29sdW1uKSB7XG4gICAgICAgICAgICBjb25maWcuYWdncmVnYXRpb25DaGlsZENvdW50ID0gY2VsbEV2ZW50LmFnZ3JlZ2F0aW9uQ2hpbGRDb3VudDtcbiAgICAgICAgICAgIGlmIChjb25maWcuYWdncmVnYXRpb25DaGlsZENvdW50ICYmICFjb25maWcuaGVhZGVyUm93KSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLnZhbHVlUG9zdGZpeCA9IGAoJHtjb25maWcuYWdncmVnYXRpb25DaGlsZENvdW50fSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLmlzQWdncmVnYXRpb25Db2x1bW4gPSBjZWxsRXZlbnQuaXNBZ2dyZWdhdGlvbkNvbHVtbjtcbiAgICAgICAgaWYgKGNvbmZpZy5pc0FnZ3JlZ2F0aW9uQ29sdW1uKSB7XG4gICAgICAgICAgICBjb25maWcuaGFzQ2hpbGRSb3dzID0gY2VsbEV2ZW50Lmhhc0NoaWxkUm93cztcbiAgICAgICAgICAgIGNvbmZpZy5pc0FnZ3JlZ2F0aW9uUm93ID0gY2VsbEV2ZW50LmlzQWdncmVnYXRpb25Sb3c7XG4gICAgICAgICAgICBjb25maWcuaXNSb3dFeHBhbmRlZCA9IGNlbGxFdmVudC5pc1Jvd0V4cGFuZGVkO1xuICAgICAgICAgICAgY29uZmlnLnRyZWVMZXZlbCA9IGNlbGxFdmVudC50cmVlTGV2ZWw7XG5cbiAgICAgICAgICAgIGNvbmZpZy5pc0dyYW5kVG90YWxSb3cgPSBjZWxsRXZlbnQuaXNHcmFuZFRvdGFsUm93O1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5pc0dyYW5kVG90YWxSb3cpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuYmFja2dyb3VuZFRleHRGb250ID0gdGhpcy5wcm9wZXJ0aWVzLmdyYW5kQWdncmVnYXRpb25DZWxsRm9udDtcbiAgICAgICAgICAgICAgICBjb25maWcuZm9yZWdyb3VuZFNlbGVjdGlvbkZvbnQgPSB0aGlzLnByb3BlcnRpZXMuZ3JhbmRBZ2dyZWdhdGlvbkNlbGxGb250O1xuICAgICAgICAgICAgICAgIGNvbmZpZy5mb250ID0gdGhpcy5wcm9wZXJ0aWVzLmdyYW5kQWdncmVnYXRpb25DZWxsRm9udDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uZmlnLmlzRXhwYW5kYWJsZVJvdyA9IGNlbGxFdmVudC5pc0V4cGFuZGFibGVSb3c7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmlzRXhwYW5kYWJsZVJvdyAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy52YWx1ZVByZWZpeCA9IGNvbmZpZy5pc1Jvd0V4cGFuZGVkXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5wcm9wZXJ0aWVzLmFnZ3JlZ2F0aW9uR3JvdXBFeHBhbmRJY29uQ29sbGFwc2VkQ2hhclxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMucHJvcGVydGllcy5hZ2dyZWdhdGlvbkdyb3VwRXhwYW5kSWNvbkV4cGFuZGVkQ2hhcjtcbiAgICAgICAgICAgICAgICBjb25maWcudmFsdWVQcmVmaXhGb250ID0gdGhpcy5wcm9wZXJ0aWVzLmFnZ3JlZ2F0aW9uR3JvdXBFeHBhbmRJY29uRm9udDtcbiAgICAgICAgICAgICAgICBjb25maWcudmFsdWVQcmVmaXhDb2xvciA9IHRoaXMucHJvcGVydGllcy5hZ2dyZWdhdGlvbkdyb3VwRXhwYW5kSWNvbkNvbG9yO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5wcmVmaXhJZ25vcmVVbmRlcmxpbmluZ05lZWRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2VsbEV2ZW50LmlzRXhwYW5kYWJsZUNvbHVtbikge1xuICAgICAgICAgICAgY29uZmlnLnZhbHVlUHJlZml4ID0gY2VsbEV2ZW50LmlzQ29sdW1uRXhwYW5kZWRcbiAgICAgICAgICAgICAgICA/IHRoaXMucHJvcGVydGllcy5hZ2dyZWdhdGlvbkdyb3VwRXhwYW5kSWNvbkNvbGxhcHNlZENoYXJcbiAgICAgICAgICAgICAgICA6IHRoaXMucHJvcGVydGllcy5hZ2dyZWdhdGlvbkdyb3VwRXhwYW5kSWNvbkV4cGFuZGVkQ2hhcjtcbiAgICAgICAgICAgIGNvbmZpZy52YWx1ZVByZWZpeEZvbnQgPSB0aGlzLnByb3BlcnRpZXMuYWdncmVnYXRpb25Hcm91cEV4cGFuZEljb25Gb250O1xuICAgICAgICAgICAgY29uZmlnLnZhbHVlUHJlZml4Q29sb3IgPSB0aGlzLnByb3BlcnRpZXMuYWdncmVnYXRpb25Hcm91cEV4cGFuZEljb25Db2xvcjtcbiAgICAgICAgICAgIGNvbmZpZy5wcmVmaXhJZ25vcmVVbmRlcmxpbmluZ05lZWRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbmZpZy52YWx1ZVByZWZpeCAmJiBjb25maWcuaGVhZGVyUm93KSB7XG4gICAgICAgICAgICBpZiAoY2VsbEV2ZW50LmNvbHVtbi5oYXNFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbmZpZy52YWx1ZVByZWZpeCA9IHRoaXMucHJvcGVydGllcy5lcnJvckljb25Vbmljb2RlQ2hhcjtcbiAgICAgICAgICAgICAgICBjb25maWcudmFsdWVQcmVmaXhGb250ID0gdGhpcy5wcm9wZXJ0aWVzLmVycm9ySWNvbkZvbnQ7XG4gICAgICAgICAgICAgICAgY29uZmlnLnZhbHVlUHJlZml4Q29sb3IgPSB0aGlzLnByb3BlcnRpZXMuZXJyb3JJY29uQ29sb3I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZy52YWx1ZVByZWZpeCA9IGNlbGxFdmVudC5jb2x1bW4uc2NoZW1hID8gY2VsbEV2ZW50LmNvbHVtbi5zY2hlbWEuaGVhZGVyUHJlZml4IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbmZpZy52YWx1ZVByZWZpeEZvbnQgPSB0aGlzLnByb3BlcnRpZXMuY29sdW1uVGl0bGVQcmVmaXhGb250O1xuICAgICAgICAgICAgICAgIGNvbmZpZy52YWx1ZVByZWZpeENvbG9yID0gdGhpcy5wcm9wZXJ0aWVzLmNvbHVtblRpdGxlUHJlZml4Q29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbmZpZy5jb2xUeXBlU2lnbikge1xuICAgICAgICAgICAgY29uZmlnLmNvbFR5cGVTaWduID0gY2VsbEV2ZW50LmNvbHVtbi5zY2hlbWEgPyBjZWxsRXZlbnQuY29sdW1uLnNjaGVtYS5jb2xUeXBlU2lnbiA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChncmlkLm1vdXNlRG93blN0YXRlKSB7XG4gICAgICAgICAgICBjb25maWcubW91c2VEb3duID0gZ3JpZC5tb3VzZURvd25TdGF0ZS5ncmlkQ2VsbC5lcXVhbHMoY2VsbEV2ZW50LmdyaWRDZWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN1YnJvdyBsb2dpYyAtIGNvZGVkIGZvciBlZmZpY2llbmN5IHdoZW4gbm8gc3Vicm93cyAoIXZhbHVlLnN1YnJvd3MpXG4gICAgICAgIHZhciBpc0FycmF5ID0gaXNVc2VyRGF0YUFyZWEgJiYgdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IEFycmF5LCAvLyBmYXN0ZXN0IGFycmF5IGRldGVybWluYXRpb25cbiAgICAgICAgICAgIHN1YnJvd3MgPSBpc0FycmF5ICYmIHZhbHVlLnN1YnJvd3MgJiYgdmFsdWUubGVuZ3RoO1xuXG4gICAgICAgIGlmIChzdWJyb3dzKSB7XG4gICAgICAgICAgICB2YXIgYm91bmRzID0gY29uZmlnLmJvdW5kcyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZy5ib3VuZHMpO1xuICAgICAgICAgICAgYm91bmRzLmhlaWdodCAvPSBzdWJyb3dzO1xuICAgICAgICAgICAgY29uZmlnLnN1YnJvd3MgPSBzdWJyb3dzO1xuICAgICAgICAgICAgY29uZmlnLnZhbHVlID0gY29uZmlnLmV4ZWModmFsdWVbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3Vicm93cyA9IDE7XG4gICAgICAgICAgICBjb25maWcudmFsdWUgPSAhaXNBcnJheSAmJiBpc1VzZXJEYXRhQXJlYSA/IGNvbmZpZy5leGVjKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5pc0RhdGFSb3cgJiYgIWNvbmZpZy5saW5rICYmIGNvbmZpZy52YWx1ZSAmJiBjb25maWcuZGV0ZWN0TGlua3NQZXJtYW5lbnRseSAmJiBjZWxsRXZlbnQuaXNWYWx1ZVVybCkge1xuICAgICAgICAgICAgY29uZmlnLmxpbmsgPSBjb25maWcudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAodHJ1ZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICAvLyBUaGlzIGNhbGwncyBkYXRhTW9kZWwuZ2V0Q2VsbCB3aGljaCBkZXZlbG9wZXIgY2FuIG92ZXJyaWRlIHRvOlxuICAgICAgICAgICAgLy8gKiBtdXRhdGUgdGhlICh3cml0YWJsZSkgcHJvcGVydGllcyBvZiBgY29uZmlnYCAoaW5jbHVkaW5nIGNvbmZpZy52YWx1ZSlcbiAgICAgICAgICAgIC8vICogbXV0YXRlIGNlbGwgcmVuZGVyZXIgY2hvaWNlIChpbnN0YW5jZSBvZiB3aGljaCBpcyByZXR1cm5lZClcbiAgICAgICAgICAgIHZhciBjZWxsUmVuZGVyZXIgPSBjZWxsRXZlbnQuc3ViZ3JpZC5nZXRDZWxsKGNvbmZpZywgY29uZmlnLnJlbmRlcmVyKTtcblxuICAgICAgICAgICAgYmVoYXZpb3IuY2VsbFByb3BlcnRpZXNQcmVQYWludE5vdGlmaWNhdGlvbihjb25maWcpO1xuXG4gICAgICAgICAgICBjb25maWcuZm9ybWF0VmFsdWUgPSBncmlkLmdldEZvcm1hdHRlcihmb3JtYXQpO1xuXG4gICAgICAgICAgICAvLyBGb2xsb3dpbmcgc3VwcG9ydHMgcGFydGlhbCByZW5kZXJcbiAgICAgICAgICAgIGNvbmZpZy5zbmFwc2hvdCA9IGNlbGxFdmVudC5zbmFwc2hvdDtcbiAgICAgICAgICAgIGNvbmZpZy5taW5XaWR0aCA9IGNlbGxFdmVudC5taW5XaWR0aDsgLy8gaW4gY2FzZSBgcGFpbnRgIGFib3J0cyBiZWZvcmUgc2V0dGluZyBgbWluV2lkdGhgXG5cbiAgICAgICAgICAgIC8vIFJlbmRlciB0aGUgY2VsbFxuICAgICAgICAgICAgY2VsbFJlbmRlcmVyLnBhaW50KGdjLCBjb25maWcpO1xuXG4gICAgICAgICAgICAvLyBGb2xsb3dpbmcgc3VwcG9ydHMgcGFydGlhbCByZW5kZXI6XG4gICAgICAgICAgICBjZWxsRXZlbnQuc25hcHNob3RbY29uZmlnLnN1YnJvd10gPSBjb25maWcuc25hcHNob3Q7XG4gICAgICAgICAgICBpZiAoY2VsbEV2ZW50Lm1pbldpZHRoID09PSB1bmRlZmluZWQgfHwgY29uZmlnLm1pbldpZHRoID4gY2VsbEV2ZW50Lm1pbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgY2VsbEV2ZW50Lm1pbldpZHRoID0gY29uZmlnLm1pbldpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKytjb25maWcuc3Vicm93ID09PSBzdWJyb3dzKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJvdW5kcy55ICs9IGJvdW5kcy5oZWlnaHQ7XG4gICAgICAgICAgICBjb25maWcudmFsdWUgPSBjb25maWcuZXhlYyh2YWx1ZVtjb25maWcuc3Vicm93XSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnLm1pbldpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkYWJsZSBmb3IgYWx0ZXJuYXRpdmUgb3IgZmFzdGVyIGxvZ2ljLlxuICAgICAqIEBwYXJhbSBDZWxsRXZlbnRcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBMYXllcmVkIGNvbmZpZyBvYmplY3QuXG4gICAgICovXG4gICAgYXNzaWduUHJvcHM6IGxheWVyUHJvcHMsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcnxDZWxsRXZlbnR9IGNvbEluZGV4T3JDZWxsRXZlbnQgLSBUaGlzIGlzIHRoZSBcImRhdGFcIiB4IGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyb3dJbmRleF0gLSBUaGlzIGlzIHRoZSBcImRhdGFcIiB5IGNvb3JkaW5hdGUuIE9taXQgaWYgYGNvbEluZGV4T3JDZWxsRXZlbnRgIGlzIGEgYENlbGxFdmVudGAuXG4gICAgICogQHBhcmFtIHtkYXRhTW9kZWxBUEl9IFtkYXRhTW9kZWw9dGhpcy5ncmlkLmJlaGF2aW9yLmRhdGFNb2RlbF0gT21pdCBpZiBgY29sSW5kZXhPckNlbGxFdmVudGAgaXMgYSBgQ2VsbEV2ZW50YC5cbiAgICAgKiBAcmV0dXJucyB7Q2VsbEV2ZW50fSBUaGUgbWF0Y2hpbmcgYENlbGxFdmVudGAgb2JqZWN0IGZyb20gdGhlIHJlbmRlcmVyJ3MgcG9vbC4gUmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGUgcmVxdWVzdGVkIGNlbGwgaXMgbm90IGN1cnJlbnRseSB2aXNpYmxlIChkdWUgdG8gYmVpbmcgc2Nyb2xsZWQgb3V0IG9mIHZpZXcpLlxuICAgICAqL1xuICAgIGZpbmRDZWxsOiBmdW5jdGlvbihjb2xJbmRleE9yQ2VsbEV2ZW50LCByb3dJbmRleCwgZGF0YU1vZGVsKSB7XG4gICAgICAgIHZhciBjb2xJbmRleCwgY2VsbEV2ZW50LFxuICAgICAgICAgICAgcG9vbCA9IHRoaXMuY2VsbEV2ZW50UG9vbDtcblxuICAgICAgICBpZiAodHlwZW9mIGNvbEluZGV4T3JDZWxsRXZlbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBjb2xJbmRleE9yQ2VsbEV2ZW50IGlzIGEgY2VsbCBldmVudCBvYmplY3RcbiAgICAgICAgICAgIGRhdGFNb2RlbCA9IHJvd0luZGV4O1xuICAgICAgICAgICAgcm93SW5kZXggPSBjb2xJbmRleE9yQ2VsbEV2ZW50LnZpc2libGVSb3cucm93SW5kZXg7XG4gICAgICAgICAgICBjb2xJbmRleCA9IGNvbEluZGV4T3JDZWxsRXZlbnQuY29sdW1uLmluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sSW5kZXggPSBjb2xJbmRleE9yQ2VsbEV2ZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YU1vZGVsID0gZGF0YU1vZGVsIHx8IHRoaXMuZ3JpZC5iZWhhdmlvci5kYXRhTW9kZWw7XG5cbiAgICAgICAgZm9yICh2YXIgcCA9IDAsIGxlbiA9IHRoaXMudmlzaWJsZUNvbHVtbnMubGVuZ3RoICogdGhpcy52aXNpYmxlUm93cy5sZW5ndGg7IHAgPCBsZW47ICsrcCkge1xuICAgICAgICAgICAgY2VsbEV2ZW50ID0gcG9vbFtwXTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBjZWxsRXZlbnQuc3ViZ3JpZCA9PT0gZGF0YU1vZGVsICYmXG4gICAgICAgICAgICAgICAgY2VsbEV2ZW50LmNvbHVtbi5pbmRleCA9PT0gY29sSW5kZXggJiZcbiAgICAgICAgICAgICAgICBjZWxsRXZlbnQudmlzaWJsZVJvdy5yb3dJbmRleCA9PT0gcm93SW5kZXhcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjZWxsRXZlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBjZWxsIHByb3BlcnRpZXMgY2FjaGUgaW4gdGhlIG1hdGNoaW5nIGBDZWxsRXZlbnRgIG9iamVjdCBmcm9tIHRoZSByZW5kZXJlcidzIHBvb2wuIFRoaXMgd2lsbCBpbnN1cmUgdGhhdCBhIG5ldyBjZWxsIHByb3BlcnRpZXMgb2JqZWN0IHdpbGwgYmUga25vd24gdG8gdGhlIHJlbmRlcmVyLiAoTm9ybWFsbHksIHRoZSBjYWNoZSBpcyBub3QgcmVzZXQgdW50aWwgdGhlIHBvb2wgaXMgdXBkYXRlZCBieSB0aGUgbmV4dCBjYWxsIHRvIHtAbGluayBSZW5kZXJlciNjb21wdXRlQ2VsbEJvdW5kc30pLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfENlbGxFdmVudH0geE9yQ2VsbEV2ZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5XVxuICAgICAqIEBwYXJhbSB7ZGF0YU1vZGVsQVBJfSBbZGF0YU1vZGVsPXRoaXMuZ3JpZC5iZWhhdmlvci5kYXRhTW9kZWxdXG4gICAgICogQHJldHVybnMge0NlbGxFdmVudH0gVGhlIG1hdGNoaW5nIGBDZWxsRXZlbnRgIG9iamVjdC5cbiAgICAgKi9cbiAgICByZXNldENlbGxQcm9wZXJ0aWVzQ2FjaGU6IGZ1bmN0aW9uKHhPckNlbGxFdmVudCwgeSwgZGF0YU1vZGVsKSB7XG4gICAgICAgIHZhciBjZWxsRXZlbnQgPSB0aGlzLmZpbmRDZWxsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChjZWxsRXZlbnQpIHtcbiAgICAgICAgICAgIGNlbGxFdmVudC5fY2VsbE93blByb3BlcnRpZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNlbGxFdmVudDtcbiAgICB9LFxuXG4gICAgcmVzZXRBbGxDZWxsUHJvcGVydGllc0NhY2hlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2VsbEV2ZW50UG9vbC5mb3JFYWNoKGZ1bmN0aW9uKGNlbGxFdmVudCkge1xuICAgICAgICAgICAgY2VsbEV2ZW50Ll9jZWxsT3duUHJvcGVydGllcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGlzVmlld2FibGVCdXR0b246IGZ1bmN0aW9uKGMsIHIpIHtcbiAgICAgICAgLy8gQ2VsbCB3aXRoICdidXR0b24nIHJlbmRlcmVyIGNsaWNrZWQgcmV0dXJucyBhbiBhcnJheTsgb3RoZXIgY2VsbHMgcmV0dXJuIGB1bmRlZmluZWRgLlxuICAgICAgICAvLyBUaGUgYXJyYXkgY29udGFpbnMgYm91bmRpbmcgcmVjdCBwZXIgc3Vicm93IHdpdGggYSBidXR0b24uIFdoZW4gbm8gc3Vicm93cyBhcnJheSBsZW5ndGggaXMgMS5cbiAgICAgICAgcmV0dXJuIHRoaXMuYnV0dG9uQ2VsbHNbYyArICcsJyArIHJdO1xuICAgIH0sXG5cbiAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZHM7XG4gICAgfSxcblxuICAgIHNldEJvdW5kczogZnVuY3Rpb24oYm91bmRzKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5ib3VuZHMgPSBib3VuZHMpO1xuICAgIH0sXG5cbiAgICBzZXRJbmZvOiBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIHZhciB3aWR0aDtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZUNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMudmlzaWJsZUNvbHVtbnNbdGhpcy52aXNpYmxlQ29sdW1ucy5sZW5ndGggLSAxXS5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyaWQuY2FudmFzLnNldEluZm8obWVzc2FnZSwgd2lkdGgpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyBzZXZlcmFsIGRhdGEgc3RydWN0dXJlczpcbiAqICoge0BsaW5rIFJlbmRlcmVyI3Zpc2libGVDb2x1bW5zfVxuICogKiB7QGxpbmsgUmVuZGVyZXIjdmlzaWJsZVJvd3N9XG4gKlxuICogT3JpZ2luYWwgY29tbWVudDpcbiAqIFwidGhpcyBmdW5jdGlvbiBjb21wdXRlcyB0aGUgZ3JpZCBjb29yZGluYXRlcyB1c2VkIGZvciBleHRyZW1lbHkgZmFzdCBpdGVyYXRpb24gb3ZlclxuICogcGFpbnRpbmcgdGhlIGdyaWQgY2VsbHMuIHRoaXMgZnVuY3Rpb24gaXMgdmVyeSBmYXN0LCBmb3IgdGhvdXNhbmQgcm93cyBYIDEwMCBjb2x1bW5zXG4gKiBvbiBhIG1vZGVzdCBtYWNoaW5lIHRha2luZyB1c3VhbGx5IDBtcyBhbmQgbm8gbW9yZSB0aGF0IDMgbXMuXCJcbiAqXG4gKiBAdGhpcyB7UmVuZGVyZXJ9XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVDZWxsc0JvdW5kcygpIHtcbiAgICAvL3ZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMuZ2V0U2Nyb2xsVG9wKCksXG4gICAgICAgIHNjcm9sbExlZnQgPSB0aGlzLmdldFNjcm9sbExlZnQoKSxcblxuICAgICAgICBmaXhlZENvbHVtbkNvdW50ID0gdGhpcy5ncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKSxcbiAgICAgICAgZml4ZWRSb3dDb3VudCA9IHRoaXMuZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCksXG5cbiAgICAgICAgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcbiAgICAgICAgZ3JpZCA9IHRoaXMuZ3JpZCxcbiAgICAgICAgYmVoYXZpb3IgPSBncmlkLmJlaGF2aW9yLFxuICAgICAgICBub1RyZWVDb2x1bW4gPSAhYmVoYXZpb3IuaGFzVHJlZUNvbHVtbigpLFxuICAgICAgICBlZGl0b3JDZWxsRXZlbnQgPSBncmlkLmNlbGxFZGl0b3IgJiYgZ3JpZC5jZWxsRWRpdG9yLmV2ZW50LFxuXG4gICAgICAgIHZjRWQsIHhFZCxcbiAgICAgICAgdnJFZCwgeUVkLFxuICAgICAgICBzZ0VkLCBpc1N1YmdyaWRFZCxcblxuICAgICAgICBpbnNlcnRpb25Cb3VuZHNDdXJzb3IgPSAwLFxuICAgICAgICBwcmV2aW91c0luc2VydGlvbkJvdW5kc0N1cnNvclZhbHVlID0gMCxcblxuICAgICAgICBncmlkUHJvcHMgPSBncmlkLnByb3BlcnRpZXMsXG4gICAgICAgIGxpbmVXaWR0aFYgPSBncmlkUHJvcHMuZ3JpZExpbmVzV2lkdGgsXG4gICAgICAgIGxpbmVXaWR0aEggPSBncmlkUHJvcHMuZ3JpZExpbmVzV2lkdGgsXG4gICAgICAgIGZpeGVkV2lkdGhWID0gZ3JpZFByb3BzLmZpeGVkTGluZXNWV2lkdGggfHwgZ3JpZFByb3BzLmdyaWRMaW5lc1dpZHRoLFxuICAgICAgICBmaXhlZFdpZHRoSCA9IGdyaWRQcm9wcy5maXhlZExpbmVzSFdpZHRoIHx8IGdyaWRQcm9wcy5ncmlkTGluZXNXaWR0aCxcbiAgICAgICAgaGFzRml4ZWRDb2x1bW5HYXAgPSBmaXhlZFdpZHRoViAmJiBmaXhlZENvbHVtbkNvdW50LFxuICAgICAgICBoYXNGaXhlZFJvd0dhcCA9IGZpeGVkV2lkdGhIICYmIGZpeGVkUm93Q291bnQsXG5cbiAgICAgICAgc3RhcnQgPSAwLFxuICAgICAgICBudW1PZkludGVybmFsQ29scyA9IDAsXG4gICAgICAgIHgsIFgsIC8vIGhvcml6b250YWwgcGl4ZWwgbG9vcCBpbmRleCBhbmQgbGltaXRcbiAgICAgICAgeSwgWSwgLy8gdmVydGljYWwgcGl4ZWwgbG9vcCBpbmRleCBhbmQgbGltaXRcbiAgICAgICAgY29sdW1uSW5kZXgsIGNvbHVtbkNvdW50LCAvLyBjb2x1bW4gbG9vcCBpbmRleCBhbmQgbGltaXRcbiAgICAgICAgY3VycmVudFN1YmdyaWRJbmRleCwgc3ViZ3JpZHNTaXplLCAvLyBzdWJncmlkIGxvb3AgaW5kZXggYW5kIGxpbWl0XG4gICAgICAgIHIsIFIsIC8vIHJvdyBsb29wIGluZGV4IGFuZCBsaW1pdFxuICAgICAgICBzdWJyb3dzLCAvLyByb3dzIGluIHN1YmdyaWQgZ1xuICAgICAgICBiYXNlLCAvLyBzdW0gb2Ygcm93cyBmb3IgYWxsIHN1YmdyaWRzIHNvIGZhclxuICAgICAgICBzdWJncmlkcyA9IGJlaGF2aW9yLnN1YmdyaWRzLFxuICAgICAgICBzdWJncmlkLFxuICAgICAgICByb3dJbmRleCxcbiAgICAgICAgc2Nyb2xsYWJsZVN1YmdyaWQsXG4gICAgICAgIGZvb3RlckhlaWdodCxcbiAgICAgICAgdngsIHZ5LFxuICAgICAgICB2aXNpYmxlUm93LCB2YyxcbiAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgZmlyc3RWWCwgbGFzdFZYLFxuICAgICAgICBmaXJzdFZZLCBsYXN0VlksXG4gICAgICAgIHRvcFIsXG4gICAgICAgIGdhcCxcbiAgICAgICAgbGVmdCwgd2lkdGhTcGFjZWQsIGhlaWdodFNwYWNlZDsgLy8gYWRqdXN0ZWQgZm9yIGNlbGwgc3BhY2luZ1xuXG4gICAgaWYgKGVkaXRvckNlbGxFdmVudCkge1xuICAgICAgICB4RWQgPSBlZGl0b3JDZWxsRXZlbnQuZ3JpZENlbGwueDtcbiAgICAgICAgeUVkID0gZWRpdG9yQ2VsbEV2ZW50LmRhdGFDZWxsLnk7XG4gICAgICAgIHNnRWQgPSBlZGl0b3JDZWxsRXZlbnQuc3ViZ3JpZDtcbiAgICB9XG5cbiAgICBpZiAobm9UcmVlQ29sdW1uKSB7XG4gICAgICAgIHRoaXMudmlzaWJsZUNvbHVtbnNbYmVoYXZpb3IudHJlZUNvbHVtbkluZGV4XSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9IE1hdGgubWluKHN0YXJ0LCBiZWhhdmlvci50cmVlQ29sdW1uSW5kZXgpO1xuICAgICAgICBudW1PZkludGVybmFsQ29scyArPSAxO1xuICAgIH1cblxuICAgIGlmIChncmlkUHJvcHMuc2hvd1Jvd051bWJlcnMpIHtcbiAgICAgICAgc3RhcnQgPSBNYXRoLm1pbihzdGFydCwgYmVoYXZpb3Iucm93Q29sdW1uSW5kZXgpO1xuICAgICAgICBudW1PZkludGVybmFsQ29scyArPSAxO1xuICAgIH1cblxuICAgIHRoaXMuc2Nyb2xsSGVpZ2h0ID0gMDtcblxuICAgIHRoaXMudmlzaWJsZUNvbHVtbnMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnZpc2libGVDb2x1bW5zLmdhcCA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMudmlzaWJsZVJvd3MubGVuZ3RoID0gMDtcbiAgICB0aGlzLnZpc2libGVSb3dzLmdhcCA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMudmlzaWJsZUNvbHVtbnNCeUluZGV4ID0gW107IC8vIGFycmF5IGJlY2F1c2UgbnVtYmVyIG9mIGNvbHVtbnMgd2lsbCBhbHdheXMgYmUgcmVhc29uYWJsZVxuICAgIHRoaXMudmlzaWJsZVJvd3NCeURhdGFSb3dJbmRleCA9IHt9OyAvLyBoYXNoIGJlY2F1c2Uga2V5ZWQgYnkgKGZpeGVkIGFuZCkgc2Nyb2xsZWQgcm93IGluZGV4ZXNcblxuICAgIHRoaXMuaW5zZXJ0aW9uQm91bmRzID0gW107XG5cbiAgICB2YXIgdG90YWxTcGFjZSA9IGdyaWQucmVuZGVyZXIuYm91bmRzLndpZHRoO1xuICAgIHZhciB0b3RhbFdpZHRoID0gYmVoYXZpb3IuZ2V0Q29sdW1uc1dpZHRoKCk7XG4gICAgdmFyIHNjcm9sbGVkV2lkdGggPSBiZWhhdmlvci5nZXRDb2x1bW5zV2lkdGgoc2Nyb2xsTGVmdCk7XG4gICAgdmFyIHZpc2libGVTcGFjZSA9IHRvdGFsV2lkdGggLSBzY3JvbGxlZFdpZHRoICsgYmVoYXZpb3IuZ2V0Q29sdW1uV2lkdGgoYmVoYXZpb3Iucm93Q29sdW1uSW5kZXgpO1xuICAgIHZhciBmcmVlU3BhY2UgPSB0b3RhbFNwYWNlIC0gdmlzaWJsZVNwYWNlO1xuICAgIHZhciBsYXN0U2hpZnQgPSAwO1xuXG4gICAgd2hpbGUgKGZyZWVTcGFjZSA+IDAgJiYgc2Nyb2xsTGVmdCA+IDApIHtcbiAgICAgICAgc2Nyb2xsTGVmdC0tO1xuICAgICAgICB2YXIgd2lkdGhGb3JTdWIgPSB0aGlzLmdyaWQuZ2V0Q29sdW1uV2lkdGgoc2Nyb2xsTGVmdCk7XG4gICAgICAgIGxhc3RTaGlmdCA9IHdpZHRoRm9yU3ViIC0gZnJlZVNwYWNlO1xuICAgICAgICBmcmVlU3BhY2UgLT0gd2lkdGhGb3JTdWI7XG4gICAgfVxuXG4gICAgbGFzdFNoaWZ0ID0gTWF0aC5yb3VuZChsYXN0U2hpZnQpO1xuXG4gICAgZm9yIChcbiAgICAgICAgeCA9IDAsIGNvbHVtbkluZGV4ID0gc3RhcnQsIGNvbHVtbkNvdW50ID0gZ3JpZC5nZXRDb2x1bW5Db3VudCgpLCBYID0gKGJvdW5kcy53aWR0aCB8fCBncmlkLmNhbnZhcy53aWR0aCkgKyBsYXN0U2hpZnQ7XG4gICAgICAgIGNvbHVtbkluZGV4IDwgY29sdW1uQ291bnQgJiYgeCA8PSBYO1xuICAgICAgICBjb2x1bW5JbmRleCsrXG4gICAgKSB7XG4gICAgICAgIGlmIChub1RyZWVDb2x1bW4gJiYgY29sdW1uSW5kZXggPT09IGJlaGF2aW9yLnRyZWVDb2x1bW5JbmRleCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2eCA9IGNvbHVtbkluZGV4O1xuICAgICAgICBpZiAoY29sdW1uSW5kZXggPj0gZml4ZWRDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgbGFzdFZYID0gdnggKz0gc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIGlmIChmaXJzdFZYID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmaXJzdFZYID0gbGFzdFZYO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2eCA+PSBjb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgYnJlYWs7IC8vIHNjcm9sbGVkIGJleW9uZCBsYXN0IGNvbHVtblxuICAgICAgICB9XG5cbiAgICAgICAgd2lkdGggPSBNYXRoLmNlaWwoYmVoYXZpb3IuZ2V0Q29sdW1uV2lkdGgodngpKTtcblxuICAgICAgICBpZiAoeCkge1xuICAgICAgICAgICAgaWYgKChnYXAgPSBoYXNGaXhlZENvbHVtbkdhcCAmJiBjb2x1bW5JbmRleCA9PT0gZml4ZWRDb2x1bW5Db3VudCkpIHtcbiAgICAgICAgICAgICAgICB4ICs9IGZpeGVkV2lkdGhWIC0gbGluZVdpZHRoVjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2libGVDb2x1bW5zLmdhcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogdmMucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVmdCA9IHggKyBsaW5lV2lkdGhWO1xuICAgICAgICAgICAgd2lkdGhTcGFjZWQgPSB3aWR0aCAtIGxpbmVXaWR0aFY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWZ0ID0geDtcbiAgICAgICAgICAgIHdpZHRoU3BhY2VkID0gd2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29sdW1uID0gYmVoYXZpb3IuZ2V0QWN0aXZlQ29sdW1uKHZ4KTtcblxuICAgICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiAoY29sdW1uLmluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gICAgIGNvbHVtbi5pbmRleCA9IGM7XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyB0b2RvIHByb2JhYmx5IG5lZWQgdG8gYmUgZml4ZWQgd2l0aCBmaXhlZENvbHVtbkNvdW50ID4gMFxuICAgICAgICAvLyByZXNpemUgZmlyc3QgY29sdW1uXG4gICAgICAgIGlmIChjb2x1bW5JbmRleCA9PT0gZml4ZWRDb2x1bW5Db3VudCAmJiBsYXN0U2hpZnQpIHtcbiAgICAgICAgICAgIHdpZHRoU3BhY2VkIC09IGxhc3RTaGlmdDtcbiAgICAgICAgICAgIHdpZHRoIC09IGxhc3RTaGlmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmlzaWJsZUNvbHVtbnNbY29sdW1uSW5kZXhdID0gdGhpcy52aXNpYmxlQ29sdW1uc0J5SW5kZXhbdnhdID0gdmMgPSB7XG4gICAgICAgICAgICBpbmRleDogY29sdW1uSW5kZXgsXG4gICAgICAgICAgICBjb2x1bW5JbmRleDogdngsXG4gICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgIGdhcDogZ2FwLFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aFNwYWNlZCxcbiAgICAgICAgICAgIHJpZ2h0OiBsZWZ0ICsgd2lkdGhTcGFjZWRcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2FwKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2libGVDb2x1bW5zLmdhcC5yaWdodCA9IHZjLmxlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeEVkID09PSB2eCkge1xuICAgICAgICAgICAgdmNFZCA9IHZjO1xuICAgICAgICB9XG5cbiAgICAgICAgeCArPSB3aWR0aDtcblxuICAgICAgICBpbnNlcnRpb25Cb3VuZHNDdXJzb3IgKz0gTWF0aC5yb3VuZCh3aWR0aCAvIDIpICsgcHJldmlvdXNJbnNlcnRpb25Cb3VuZHNDdXJzb3JWYWx1ZTtcbiAgICAgICAgdGhpcy5pbnNlcnRpb25Cb3VuZHMucHVzaChpbnNlcnRpb25Cb3VuZHNDdXJzb3IpO1xuICAgICAgICBwcmV2aW91c0luc2VydGlvbkJvdW5kc0N1cnNvclZhbHVlID0gTWF0aC5yb3VuZCh3aWR0aCAvIDIpO1xuICAgIH1cblxuICAgIC8vIGdldCBoZWlnaHQgb2YgdG90YWwgbnVtYmVyIG9mIHJvd3MgaW4gYWxsIHN1YmdyaWRzIGZvbGxvd2luZyB0aGUgZGF0YSBzdWJncmlkXG4gICAgZm9vdGVySGVpZ2h0ID0gZ3JpZFByb3BzLmRlZmF1bHRSb3dIZWlnaHQgKiBiZWhhdmlvci5nZXRGb290ZXJSb3dDb3VudCgpO1xuXG4gICAgZm9yIChcbiAgICAgICAgYmFzZSA9IHIgPSBjdXJyZW50U3ViZ3JpZEluZGV4ID0geSA9IDAsIHN1YmdyaWRzU2l6ZSA9IHN1YmdyaWRzLmxlbmd0aCwgWSA9IGJvdW5kcy5oZWlnaHQgLSBmb290ZXJIZWlnaHQ7XG4gICAgICAgIGN1cnJlbnRTdWJncmlkSW5kZXggPCBzdWJncmlkc1NpemU7XG4gICAgICAgIGN1cnJlbnRTdWJncmlkSW5kZXgrKywgYmFzZSArPSBzdWJyb3dzXG4gICAgKSB7XG4gICAgICAgIHN1YmdyaWQgPSBzdWJncmlkc1tjdXJyZW50U3ViZ3JpZEluZGV4XTtcbiAgICAgICAgc3Vicm93cyA9IHN1YmdyaWQuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgc2Nyb2xsYWJsZVN1YmdyaWQgPSBzdWJncmlkLmlzRGF0YTtcbiAgICAgICAgaXNTdWJncmlkRWQgPSAoc2dFZCA9PT0gc3ViZ3JpZCk7XG4gICAgICAgIHRvcFIgPSByO1xuXG4gICAgICAgIC8vIEZvciBlYWNoIHJvdyBvZiBlYWNoIHN1YmdyaWQuLi5cbiAgICAgICAgdmFyIG1pblZpc2libGVSb3cgPSAwO1xuICAgICAgICBmb3IgKFIgPSByICsgc3Vicm93czsgciA8IFIgJiYgeSA8IFk7IHIrKykge1xuICAgICAgICAgICAgdnkgPSByO1xuXG4gICAgICAgICAgICBpZiAobWluVmlzaWJsZVJvdyA+IHZ5ICYmIHZ5ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgbWluVmlzaWJsZVJvdyA9IHZ5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2Nyb2xsYWJsZVN1YmdyaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGdhcCA9IGhhc0ZpeGVkUm93R2FwICYmIHIgPT09IGZpeGVkUm93Q291bnQgJiYgciAhPT0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeSArPSBmaXhlZFdpZHRoSCAtIGxpbmVXaWR0aEg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZVJvd3MuZ2FwID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiB2aXNpYmxlUm93LmJvdHRvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyID49IGZpeGVkUm93Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdnkgKz0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgICAgICBsYXN0VlkgPSB2eSAtIGJhc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdFZZID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0VlkgPSBsYXN0Vlk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZ5ID49IFIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBzY3JvbGxlZCBiZXlvbmQgbGFzdCByb3dcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcm93SW5kZXggPSB2eSAtIGJhc2U7XG4gICAgICAgICAgICBoZWlnaHQgPSBiZWhhdmlvci5nZXRSb3dIZWlnaHQocm93SW5kZXgsIHN1YmdyaWQpO1xuXG4gICAgICAgICAgICBoZWlnaHRTcGFjZWQgPSBoZWlnaHQgLSBsaW5lV2lkdGhIO1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlUm93c1tyXSA9IHZpc2libGVSb3cgPSB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHIsXG4gICAgICAgICAgICAgICAgc3ViZ3JpZDogc3ViZ3JpZCxcbiAgICAgICAgICAgICAgICBnYXA6IGdhcCxcbiAgICAgICAgICAgICAgICByb3dJbmRleDogcm93SW5kZXgsXG4gICAgICAgICAgICAgICAgdG9wOiB5LFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0U3BhY2VkLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogeSArIGhlaWdodFNwYWNlZFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGdhcCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZVJvd3MuZ2FwLmJvdHRvbSA9IHZpc2libGVSb3cudG9wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2Nyb2xsYWJsZVN1YmdyaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2libGVSb3dzQnlEYXRhUm93SW5kZXhbdnkgLSBiYXNlXSA9IHZpc2libGVSb3c7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc1N1YmdyaWRFZCAmJiB5RWQgPT09IHJvd0luZGV4KSB7XG4gICAgICAgICAgICAgICAgdnJFZCA9IHZpc2libGVSb3c7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHkgKz0gaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjcm9sbGFibGVTdWJncmlkKSB7XG4gICAgICAgICAgICBzdWJyb3dzID0gciAtIHRvcFI7XG4gICAgICAgICAgICBZICs9IGZvb3RlckhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh5IDwgWSkge1xuICAgICAgICAgICAgdGhpcy5ib3R0b21GcmVlU3BhY2UgPSBZIC0geTtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvdHRvbUZyZWVTcGFjZSA8PSBncmlkUHJvcHMuZGVmYXVsdFJvd0hlaWdodCkge1xuICAgICAgICAgICAgICAgIHZhciBoZWFkZXJSb3dzQ291bnQgPSBiZWhhdmlvci5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0ZpcnN0Um93ID0gdGhpcy52aXNpYmxlUm93c1toZWFkZXJSb3dzQ291bnRdIHx8IHRoaXMudmlzaWJsZVJvd3NbaGVhZGVyUm93c0NvdW50IC0gMV07XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNraXBwZWRUb3BTcGFjZSA9IGdyaWRQcm9wcy5kZWZhdWx0Um93SGVpZ2h0IC0gdGhpcy5ib3R0b21GcmVlU3BhY2UgKyBsaW5lV2lkdGhIO1xuICAgICAgICAgICAgICAgIHZhciB0b3AgPSBwcmV2aW91c0ZpcnN0Um93LnRvcCAtIHRoaXMuc2tpcHBlZFRvcFNwYWNlO1xuICAgICAgICAgICAgICAgIHZhciBoYWxmU2l6ZWRSb3cgPSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBoZWFkZXJSb3dzQ291bnQsXG4gICAgICAgICAgICAgICAgICAgIHN1YmdyaWQ6IHByZXZpb3VzRmlyc3RSb3cuc3ViZ3JpZCxcbiAgICAgICAgICAgICAgICAgICAgZ2FwOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcm93SW5kZXg6IHByZXZpb3VzRmlyc3RSb3cucm93SW5kZXggLSAxLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBncmlkUHJvcHMuZGVmYXVsdFJvd0hlaWdodCArIGxpbmVXaWR0aEgsXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogdG9wICsgZ3JpZFByb3BzLmRlZmF1bHRSb3dIZWlnaHQgKyBsaW5lV2lkdGhILFxuICAgICAgICAgICAgICAgICAgICBza2lwcGVkVG9wU3BhY2U6IHRoaXMuc2tpcHBlZFRvcFNwYWNlXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBoZWFkZXJSb3dzQ291bnQ7IGkgPCB0aGlzLnZpc2libGVSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZVJvd3NbaV0udG9wICs9IHRoaXMuYm90dG9tRnJlZVNwYWNlICsgbGluZVdpZHRoSDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlUm93c1tpXS5pbmRleCArPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2libGVSb3dzW2ldLmJvdHRvbSArPSB0aGlzLmJvdHRvbUZyZWVTcGFjZSArIGxpbmVXaWR0aEg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZVJvd3Muc3BsaWNlKGhlYWRlclJvd3NDb3VudCwgMCwgaGFsZlNpemVkUm93KTtcblxuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxhYmxlU3ViZ3JpZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2libGVSb3dzQnlEYXRhUm93SW5kZXhbaGFsZlNpemVkUm93LnJvd0luZGV4XSA9IGhhbGZTaXplZFJvdztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB0aGlzLnZpc2libGVSb3dzLnVuc2hpZnQoaGFsZlNpemVkUm93KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkQ3V0dGVkUm93c0NvdW50ID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlZEN1dHRlZFJvd3NDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwcGVkVG9wU3BhY2UgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlZEN1dHRlZFJvd3NDb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLnNraXBwZWRUb3BTcGFjZSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWRpdG9yQ2VsbEV2ZW50KSB7XG4gICAgICAgIGVkaXRvckNlbGxFdmVudC52aXNpYmxlQ29sdW1uID0gdmNFZDtcbiAgICAgICAgZWRpdG9yQ2VsbEV2ZW50LnZpc2libGVSb3cgPSB2ckVkO1xuICAgICAgICBlZGl0b3JDZWxsRXZlbnQuZ3JpZENlbGwueSA9IHZyRWQgJiYgdnJFZC5pbmRleDtcbiAgICAgICAgZWRpdG9yQ2VsbEV2ZW50Ll9ib3VuZHMgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMudmlld0hlaWdodCA9IFk7XG5cbiAgICB0aGlzLmRhdGFXaW5kb3cgPSB0aGlzLmdyaWQubmV3UmVjdGFuZ2xlKGZpcnN0VlgsIGZpcnN0VlksIGxhc3RWWCAtIGZpcnN0VlgsIGxhc3RWWSAtIGZpcnN0VlkpO1xuXG4gICAgLy8gUmVzaXplIENlbGxFdmVudCBwb29sXG4gICAgdmFyIHBvb2wgPSB0aGlzLmNlbGxFdmVudFBvb2wsXG4gICAgICAgIHByZXZpb3VzTGVuZ3RoID0gcG9vbC5sZW5ndGgsXG4gICAgICAgIFAgPSAodGhpcy52aXNpYmxlQ29sdW1ucy5sZW5ndGggKyBudW1PZkludGVybmFsQ29scykgKiB0aGlzLnZpc2libGVSb3dzLmxlbmd0aDtcblxuICAgIGlmIChQID4gcHJldmlvdXNMZW5ndGgpIHtcbiAgICAgICAgcG9vbC5sZW5ndGggPSBQOyAvLyBncm93IHBvb2wgdG8gYWNjb21tb2RhdGUgbW9yZSBjZWxsc1xuICAgIH1cbiAgICBmb3IgKHZhciBwID0gcHJldmlvdXNMZW5ndGg7IHAgPCBQOyBwKyspIHtcbiAgICAgICAgcG9vbFtwXSA9IG5ldyBiZWhhdmlvci5DZWxsRXZlbnQ7IC8vIGluc3RhbnRpYXRlIG5ldyBtZW1iZXJzXG4gICAgfVxuXG4gICAgdGhpcy5yZXNldEFsbEdyaWRSZW5kZXJlcnMoKTtcbn1cblxuLyoqXG4gKiBAc3VtbWFyeSBSZXNpemUgdGhlIGhhbmRsZSBjb2x1bW4uXG4gKiBAZGVzYyBIYW5kbGUgY29sdW1uIHdpZHRoIGlzIHN1bSBvZjpcbiAqICogV2lkdGggb2YgdGV4dCB0aGUgbWF4aW11bSByb3cgbnVtYmVyLCBpZiB2aXNpYmxlLCBiYXNlZCBvbiBoYW5kbGUgY29sdW1uJ3MgY3VycmVudCBmb250XG4gKiAqIFdpZHRoIG9mIGNoZWNrYm94LCBpZiB2aXNpYmxlXG4gKiAqIFNvbWUgcGFkZGluZ1xuICpcbiAqIEB0aGlzIHtSZW5kZXJlcn1cbiAqIEBwYXJhbSBnY1xuICogQHBhcmFtIHJvd0NvdW50XG4gKi9cbmZ1bmN0aW9uIHJlc2V0Um93SGVhZGVyQ29sdW1uV2lkdGgoZ2MsIHJvd0NvdW50KSB7XG4gICAgdmFyIGNvbHVtblByb3BlcnRpZXMgPSB0aGlzLmdyaWQuYmVoYXZpb3IuZ2V0Q29sdW1uUHJvcGVydGllcyh0aGlzLmdyaWQuYmVoYXZpb3Iucm93Q29sdW1uSW5kZXgpLFxuICAgICAgICBncmlkUHJvcHMgPSB0aGlzLmdyaWQucHJvcGVydGllcyxcbiAgICAgICAgLy8gd2lkdGggPSAyICogY29sdW1uUHJvcGVydGllcy5jZWxsUGFkZGluZztcbiAgICAgICAgd2lkdGggPSBjb2x1bW5Qcm9wZXJ0aWVzLmNlbGxQYWRkaW5nTGVmdCArIGNvbHVtblByb3BlcnRpZXMuY2VsbFBhZGRpbmdSaWdodDtcblxuICAgIC8vIENoZWNraW5nIGltYWdlcy5jaGVja2VkIGFsc28gc3VwcG9ydHMgYSBsZWdhY3kgZmVhdHVyZSBpbiB3aGljaCBjaGVja2JveCBjb3VsZCBiZSBoaWRkZW4gYnkgdW5kZWZpbmluZyB0aGUgaW1hZ2UuXG4gICAgaWYgKGdyaWRQcm9wcy5yb3dIZWFkZXJDaGVja2JveGVzICYmIGltYWdlcy5jaGVja2VkKSB7XG4gICAgICAgIHdpZHRoICs9IGltYWdlcy5jaGVja2VkLndpZHRoO1xuICAgIH1cblxuICAgIGlmIChncmlkUHJvcHMucm93SGVhZGVyTnVtYmVycykge1xuICAgICAgICB2YXIgY2VsbFByb3BlcnRpZXMgPSBjb2x1bW5Qcm9wZXJ0aWVzLnJvd0hlYWRlcjtcbiAgICAgICAgZ2MuY2FjaGUuZm9udCA9IGNlbGxQcm9wZXJ0aWVzLmZvcmVncm91bmRTZWxlY3Rpb25Gb250LmluZGV4T2YoJ2JvbGQgJykgPj0gMFxuICAgICAgICAgICAgPyBjZWxsUHJvcGVydGllcy5mb3JlZ3JvdW5kU2VsZWN0aW9uRm9udFxuICAgICAgICAgICAgOiBjZWxsUHJvcGVydGllcy5mb250O1xuXG4gICAgICAgIHdpZHRoICs9IGdjLmdldFRleHRXaWR0aChyb3dDb3VudCk7XG4gICAgICAgIHdpZHRoID0gd2lkdGggPCBjZWxsUHJvcGVydGllcy5taW5XaWR0aCA/IGNlbGxQcm9wZXJ0aWVzLm1pbldpZHRoIDogd2lkdGg7XG4gICAgfVxuXG4gICAgY29sdW1uUHJvcGVydGllcy5wcmVmZXJyZWRXaWR0aCA9IGNvbHVtblByb3BlcnRpZXMud2lkdGggPSB3aWR0aDtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJHcmlkUmVuZGVyZXIocGFpbnRDZWxsc0Z1bmN0aW9uKSB7XG4gICAgaWYgKHBhaW50Q2VsbHNGdW5jdGlvbnMuaW5kZXhPZihwYWludENlbGxzRnVuY3Rpb24pIDwgMCkge1xuICAgICAgICBwYWludENlbGxzRnVuY3Rpb25zLnB1c2gocGFpbnRDZWxsc0Z1bmN0aW9uKTtcbiAgICB9XG59XG5cbnJlZ2lzdGVyR3JpZFJlbmRlcmVyKHJlcXVpcmUoJy4vYnktY2VsbHMnKSk7XG5yZWdpc3RlckdyaWRSZW5kZXJlcihyZXF1aXJlKCcuL2J5LWNvbHVtbnMnKSk7XG5yZWdpc3RlckdyaWRSZW5kZXJlcihyZXF1aXJlKCcuL2J5LWNvbHVtbnMtZGlzY3JldGUnKSk7XG5yZWdpc3RlckdyaWRSZW5kZXJlcihyZXF1aXJlKCcuL2J5LWNvbHVtbnMtYW5kLXJvd3MnKSk7XG5yZWdpc3RlckdyaWRSZW5kZXJlcihyZXF1aXJlKCcuL2J5LWNvbHVtbnMtYW5kLXJvd3MtaGVhZGVycycpKTtcbnJlZ2lzdGVyR3JpZFJlbmRlcmVyKHJlcXVpcmUoJy4vYnktcm93cycpKTtcblxuUmVuZGVyZXIucmVnaXN0ZXJHcmlkUmVuZGVyZXIgPSByZWdpc3RlckdyaWRSZW5kZXJlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcblxudmFyIENPTFVNTlMgPSBkZWZhdWx0cy5wcm9wQ2xhc3NFbnVtLkNPTFVNTlMsXG4gICAgQ0VMTFMgPSBkZWZhdWx0cy5wcm9wQ2xhc3NFbnVtLkNFTExTLFxuICAgIHByb3BDbGFzc0dldCA9IFtdO1xuXG5wcm9wQ2xhc3NHZXRbQ09MVU1OU10gPSBmdW5jdGlvbihjZWxsRXZlbnQpIHtcbiAgICByZXR1cm4gY2VsbEV2ZW50LmNvbHVtblByb3BlcnRpZXM7XG59O1xucHJvcENsYXNzR2V0W0NFTExTXSA9IGZ1bmN0aW9uKGNlbGxFdmVudCkge1xuICAgIHJldHVybiBjZWxsRXZlbnQuY2VsbE93blByb3BlcnRpZXM7XG59O1xucHJvcENsYXNzR2V0W2RlZmF1bHRzLnByb3BDbGFzc0VudW0uU1RSSVBFU10gPSBmdW5jdGlvbihjZWxsRXZlbnQpIHtcbiAgICB2YXIgcm93U3RyaXBlcyA9IGNlbGxFdmVudC5pc0RhdGFSb3cgJiYgY2VsbEV2ZW50LmNvbHVtblByb3BlcnRpZXMucm93U3RyaXBlcztcbiAgICByZXR1cm4gcm93U3RyaXBlcyAmJiByb3dTdHJpcGVzW2NlbGxFdmVudC5kYXRhQ2VsbC55ICUgcm93U3RyaXBlcy5sZW5ndGhdO1xufTtcbnByb3BDbGFzc0dldFtkZWZhdWx0cy5wcm9wQ2xhc3NFbnVtLlJPV1NdID0gZnVuY3Rpb24oY2VsbEV2ZW50KSB7XG4gICAgcmV0dXJuIGNlbGxFdmVudC5yb3dPd25Qcm9wZXJ0aWVzO1xufTtcblxuZnVuY3Rpb24gYXNzaWduUHJvcHMoY2VsbEV2ZW50KSB7XG4gICAgdmFyIGksIGJhc2UsIGFzc2lnbm1lbnRzLFxuICAgICAgICBwcm9wcyA9IGNlbGxFdmVudC5wcm9wZXJ0aWVzLFxuICAgICAgICBwcm9wTGF5ZXJzID0gcHJvcHMucHJvcENsYXNzTGF5ZXJzO1xuXG4gICAgc3dpdGNoIChwcm9wTGF5ZXJzWzBdKSB7XG4gICAgICAgIGNhc2UgQ09MVU1OUzpcbiAgICAgICAgICAgIGkgPSAxOyAvLyBza2lwIGNvbHVtbiBwcm9wIGxheWVyXG4gICAgICAgICAgICBiYXNlID0gY2VsbEV2ZW50LmNvbHVtblByb3BlcnRpZXM7IC8vIGJlY2F1c2UgY29sdW1uIGhhcyBncmlkIHByb3BzIGFzIHByb3RvdHlwZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ0VMTFM6XG4gICAgICAgICAgICBpID0gMTsgLy8gc2tpcCBjZWxsIHByb3AgbGF5ZXJcbiAgICAgICAgICAgIGJhc2UgPSBwcm9wczsgLy8gYmVjYXVzZSBjZWxsIGhhcyBjb2x1bW4gcHJvcHMgYXMgcHJvdG90eXBlXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGkgPSAwOyAvLyBhbGwgcHJvcCBsYXllcnNcbiAgICAgICAgICAgIGJhc2UgPSB0aGlzLmdyaWQucHJvcGVydGllcztcbiAgICB9XG5cbiAgICBmb3IgKGFzc2lnbm1lbnRzID0gW09iamVjdC5jcmVhdGUoYmFzZSldOyBpIDwgcHJvcExheWVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBhc3NpZ25tZW50cy5wdXNoKHByb3BDbGFzc0dldFtwcm9wTGF5ZXJzW2ldXShjZWxsRXZlbnQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIGFzc2lnbm1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25Qcm9wcztcbiJdfQ==
